{"id": "http://arxiv.org/abs/quant-ph/0610200v5", "guidislink": true, "updated": "2016-10-14T16:38:13Z", "updated_parsed": [2016, 10, 14, 16, 38, 13, 4, 288, 0], "published": "2006-10-23T14:57:40Z", "published_parsed": [2006, 10, 23, 14, 57, 40, 0, 296, 0], "title": "Quantum List Decoding of Classical Block Codes of Polynomially Small\n  Rate from Quantumly Corrupted Codewords", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0610105%2Cquant-ph%2F0610258%2Cquant-ph%2F0610035%2Cquant-ph%2F0610266%2Cquant-ph%2F0610089%2Cquant-ph%2F0610094%2Cquant-ph%2F0610095%2Cquant-ph%2F0610145%2Cquant-ph%2F0610251%2Cquant-ph%2F0610143%2Cquant-ph%2F0610153%2Cquant-ph%2F0610210%2Cquant-ph%2F0610015%2Cquant-ph%2F0610213%2Cquant-ph%2F0610183%2Cquant-ph%2F0610124%2Cquant-ph%2F0610154%2Cquant-ph%2F0610218%2Cquant-ph%2F0610200%2Cquant-ph%2F0610118%2Cquant-ph%2F0610242%2Cquant-ph%2F0610088%2Cquant-ph%2F0610236%2Cquant-ph%2F0610217%2Cquant-ph%2F0610184%2Cquant-ph%2F0610019%2Cquant-ph%2F0610024%2Cquant-ph%2F0610135%2Cquant-ph%2F0610045%2Cquant-ph%2F0610228%2Cquant-ph%2F0610102%2Cquant-ph%2F0610192%2Cquant-ph%2F0610106%2Cquant-ph%2F0610219%2Cquant-ph%2F0610067%2Cquant-ph%2F0610126%2Cquant-ph%2F0610162%2Cquant-ph%2F0610129%2Cquant-ph%2F0610071%2Cquant-ph%2F0610193%2Cquant-ph%2F0610025%2Cquant-ph%2F0610137%2Cquant-ph%2F0610205%2Cquant-ph%2F0610120%2Cquant-ph%2F0610229%2Cquant-ph%2F0610174%2Cquant-ph%2F0610194%2Cquant-ph%2F0610244%2Cquant-ph%2F0610175%2Cquant-ph%2F0610249%2Cquant-ph%2F0610147%2Cquant-ph%2F0610046%2Cquant-ph%2F0610103%2Cquant-ph%2F0610037%2Cquant-ph%2F0610034%2Cquant-ph%2F0610161%2Cquant-ph%2F0610123%2Cquant-ph%2F0610130%2Cquant-ph%2F0610169%2Cquant-ph%2F0610151%2Cquant-ph%2F0610226%2Cquant-ph%2F0610257%2Cquant-ph%2F0610128%2Cquant-ph%2F0610252%2Cquant-ph%2F0610263%2Cquant-ph%2F0610038%2Cquant-ph%2F0610031%2Cquant-ph%2F0610010%2Cquant-ph%2F0610189%2Cquant-ph%2F0610064%2Cquant-ph%2F0610171%2Cquant-ph%2F0610013%2Cquant-ph%2F0610086%2Cquant-ph%2F0610040%2Cquant-ph%2F0610059%2Cquant-ph%2F0610181%2Cquant-ph%2F0610198%2Cquant-ph%2F0610240%2Cquant-ph%2F0610255%2Cquant-ph%2F0610238%2Cquant-ph%2F0610012%2Cquant-ph%2F0610082%2Cquant-ph%2F0610188%2Cquant-ph%2F0610026%2Cquant-ph%2F0610179%2Cquant-ph%2F0610253%2Cquant-ph%2F0610112%2Cquant-ph%2F0610039%2Cquant-ph%2F0610152%2Cquant-ph%2F0610029%2Cquant-ph%2F0610172%2Cquant-ph%2F0610007%2Cquant-ph%2F0610165%2Cquant-ph%2F0610215%2Cquant-ph%2F0610017%2Cquant-ph%2F0610235%2Cquant-ph%2F0610220%2Cquant-ph%2F0610051%2Cquant-ph%2F0610097%2Cquant-ph%2F0610020%2Cquant-ph%2F0610243&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Quantum List Decoding of Classical Block Codes of Polynomially Small\n  Rate from Quantumly Corrupted Codewords"}, "summary": "Given a classical error-correcting block code, the task of quantum list\ndecoding is to produce from any quantumly corrupted codeword a short list\ncontaining all messages whose codewords exhibit high \"presence\" in the\nquantumly corrupted codeword. Efficient quantum list decoders have been used to\nprove a quantum hardcore property of classical codes. However, the code rates\nof all known families of efficiently quantum list-decodable codes are,\nunfortunately, too small for other practical applications. To improve those\nknown code rates, we prove that a specific code family of polynomially small\ncode rate over a fixed code alphabet, obtained by concatenating generalized\nReed-Solomon codes as outer codes with Hadamard codes as inner codes, has an\nefficient quantum list-decoding algorithm if its codewords have relatively high\ncodeword presence in a given quantumly corrupted codeword. As an immediate\napplication, we use the quantum list decodability of this code family to solve\na certain form of quantum search problems in polynomial time. When the codeword\npresence becomes smaller, in contrast, we show that the quantum list\ndecodability of generalized Reed-Solomon codes with high confidence is closely\nrelated to the efficient solvability of the following two problems: the noisy\npolynomial interpolation problem and the bounded distance vector problem.\nMoreover, assuming that NP is not included in BQP, we also prove that no\nefficient quantum list decoder exists for the generalized Reed-Solomon codes.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0610105%2Cquant-ph%2F0610258%2Cquant-ph%2F0610035%2Cquant-ph%2F0610266%2Cquant-ph%2F0610089%2Cquant-ph%2F0610094%2Cquant-ph%2F0610095%2Cquant-ph%2F0610145%2Cquant-ph%2F0610251%2Cquant-ph%2F0610143%2Cquant-ph%2F0610153%2Cquant-ph%2F0610210%2Cquant-ph%2F0610015%2Cquant-ph%2F0610213%2Cquant-ph%2F0610183%2Cquant-ph%2F0610124%2Cquant-ph%2F0610154%2Cquant-ph%2F0610218%2Cquant-ph%2F0610200%2Cquant-ph%2F0610118%2Cquant-ph%2F0610242%2Cquant-ph%2F0610088%2Cquant-ph%2F0610236%2Cquant-ph%2F0610217%2Cquant-ph%2F0610184%2Cquant-ph%2F0610019%2Cquant-ph%2F0610024%2Cquant-ph%2F0610135%2Cquant-ph%2F0610045%2Cquant-ph%2F0610228%2Cquant-ph%2F0610102%2Cquant-ph%2F0610192%2Cquant-ph%2F0610106%2Cquant-ph%2F0610219%2Cquant-ph%2F0610067%2Cquant-ph%2F0610126%2Cquant-ph%2F0610162%2Cquant-ph%2F0610129%2Cquant-ph%2F0610071%2Cquant-ph%2F0610193%2Cquant-ph%2F0610025%2Cquant-ph%2F0610137%2Cquant-ph%2F0610205%2Cquant-ph%2F0610120%2Cquant-ph%2F0610229%2Cquant-ph%2F0610174%2Cquant-ph%2F0610194%2Cquant-ph%2F0610244%2Cquant-ph%2F0610175%2Cquant-ph%2F0610249%2Cquant-ph%2F0610147%2Cquant-ph%2F0610046%2Cquant-ph%2F0610103%2Cquant-ph%2F0610037%2Cquant-ph%2F0610034%2Cquant-ph%2F0610161%2Cquant-ph%2F0610123%2Cquant-ph%2F0610130%2Cquant-ph%2F0610169%2Cquant-ph%2F0610151%2Cquant-ph%2F0610226%2Cquant-ph%2F0610257%2Cquant-ph%2F0610128%2Cquant-ph%2F0610252%2Cquant-ph%2F0610263%2Cquant-ph%2F0610038%2Cquant-ph%2F0610031%2Cquant-ph%2F0610010%2Cquant-ph%2F0610189%2Cquant-ph%2F0610064%2Cquant-ph%2F0610171%2Cquant-ph%2F0610013%2Cquant-ph%2F0610086%2Cquant-ph%2F0610040%2Cquant-ph%2F0610059%2Cquant-ph%2F0610181%2Cquant-ph%2F0610198%2Cquant-ph%2F0610240%2Cquant-ph%2F0610255%2Cquant-ph%2F0610238%2Cquant-ph%2F0610012%2Cquant-ph%2F0610082%2Cquant-ph%2F0610188%2Cquant-ph%2F0610026%2Cquant-ph%2F0610179%2Cquant-ph%2F0610253%2Cquant-ph%2F0610112%2Cquant-ph%2F0610039%2Cquant-ph%2F0610152%2Cquant-ph%2F0610029%2Cquant-ph%2F0610172%2Cquant-ph%2F0610007%2Cquant-ph%2F0610165%2Cquant-ph%2F0610215%2Cquant-ph%2F0610017%2Cquant-ph%2F0610235%2Cquant-ph%2F0610220%2Cquant-ph%2F0610051%2Cquant-ph%2F0610097%2Cquant-ph%2F0610020%2Cquant-ph%2F0610243&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Given a classical error-correcting block code, the task of quantum list\ndecoding is to produce from any quantumly corrupted codeword a short list\ncontaining all messages whose codewords exhibit high \"presence\" in the\nquantumly corrupted codeword. Efficient quantum list decoders have been used to\nprove a quantum hardcore property of classical codes. However, the code rates\nof all known families of efficiently quantum list-decodable codes are,\nunfortunately, too small for other practical applications. To improve those\nknown code rates, we prove that a specific code family of polynomially small\ncode rate over a fixed code alphabet, obtained by concatenating generalized\nReed-Solomon codes as outer codes with Hadamard codes as inner codes, has an\nefficient quantum list-decoding algorithm if its codewords have relatively high\ncodeword presence in a given quantumly corrupted codeword. As an immediate\napplication, we use the quantum list decodability of this code family to solve\na certain form of quantum search problems in polynomial time. When the codeword\npresence becomes smaller, in contrast, we show that the quantum list\ndecodability of generalized Reed-Solomon codes with high confidence is closely\nrelated to the efficient solvability of the following two problems: the noisy\npolynomial interpolation problem and the bounded distance vector problem.\nMoreover, assuming that NP is not included in BQP, we also prove that no\nefficient quantum list decoder exists for the generalized Reed-Solomon codes."}, "authors": ["Tomoyuki Yamakami"], "author_detail": {"name": "Tomoyuki Yamakami"}, "author": "Tomoyuki Yamakami", "links": [{"title": "doi", "href": "http://dx.doi.org/10.22364/bjmc.2016.4.4", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/quant-ph/0610200v5", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/quant-ph/0610200v5", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "(A4 size, 10 pt, 25 pages) A complete version of an extended abstract\n  that appeared in the Proceedings of the 13th Computing: The Australasian\n  Theory Symposium (CATS 2007), pp.153-162, Ballarat, Australia, January\n  30-February 2, 2007", "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/quant-ph/0610200v5", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/quant-ph/0610200v5", "journal_reference": "Baltic Journal of Modern Computing, Vol. 4 (2016), No. 4, pp.\n  753-788", "doi": "10.22364/bjmc.2016.4.4", "fulltext": "Quantum List Decoding of Classical Block Codes of\nPolynomially Small Rate from Quantumly Corrupted Codewords\u2217\n\narXiv:quant-ph/0610200v5 14 Oct 2016\n\nTomoyuki Yamakami\u2020\n\nAbstract. Given a classical error-correcting block code, the task of quantum list decoding is\nto produce from any quantumly corrupted codeword a short list containing all messages whose\ncodewords exhibit high \"presence\" in the quantumly corrupted codeword. Efficient quantum list\ndecoders have been used to prove a quantum hardcore property of classical codes. However, the\ncode rates of all known families of efficiently quantum list-decodable codes are, unfortunately, too\nsmall for other practical applications. To improve those known code rates, we prove that a specific\ncode family of polynomially small code rate over a fixed code alphabet, obtained by concatenating\ngeneralized Reed-Solomon codes as outer codes with Hadamard codes as inner codes, has an\nefficient quantum list-decoding algorithm if its codewords have relatively high codeword presence\nin a given quantumly corrupted codeword. As an immediate application, we use the quantum list\ndecodability of this code family to solve a certain form of quantum search problems in polynomial\ntime. When the codeword presence becomes smaller, in contrast, we show that the quantum list\ndecodability of generalized Reed-Solomon codes with high confidence is closely related to the\nefficient solvability of the following two problems: the noisy polynomial interpolation problem\nand the bounded distance vector problem. Moreover, assuming that NP * BQP, we also prove\nthat no efficient quantum list decoder exists for the generalized Reed-Solomon codes.\nKeywords: quantum computation, block error-correcting code, quantum list decoding, quantumly corrupted codeword, quantum one-way function, generalized Reed-Solomon code, Hadamard\ncode, concatenated code\n\n1\n\nQuantum List Decoding\n\nClassical list decoding, whose notion is attributed to Elias [4] and Wozencraft [24] in late 1950s, has recently\ndrawn significant attention after Sudan's [19] discovery of an efficient list-decoding algorithm for well-studied\nReed-Solomon codes beyond its \"traditional\" error-correction radius. List decoding has since then found\nuseful applications to cryptography as well as computational complexity theory (see, e.g., survey articles of\nSudan [20] and Trevisan [22]). For a wider range of applications to, in particular, quantum computations,\nan introduction of quantum analogue of such list decoding is an inevitable consequence.\nIn a seminal paper of Kawachi and Yamakami [13] (following an early work of Adcock and Cleve [1] on\nbiased oracles) published first in 2006, a notion of quantum list decoding of classical block codes arose quite\nnaturally in their study of quantum hardcore functions for arbitrary (strongly) quantum one-way functions.\nA goal of quantum list decoding in Kawachi and Yamakami's implicit-input explicit-output model is to produce a relatively short list of message candidates by means of oracle queries to a faulty quantum encoding\nprocedure given as a form of oracle. This model of quantum list decoding slightly differs from a conventional\ntransmission model between a sender and a receiver through a noisy channel, particularly, in the following\naspects. Given an original message hidden to the receiver, assumed is the existence of a faulty quantum\nencoding procedure (called as a quantum-computationally corrupted codeword or quantumly corrupted codeword) that tries to generate a code symbol at each specified block location of a desired codeword induced\nfrom the original message. To recover the hidden message from this quantumly corrupted codeword, the\nreceiver is allowed to access the quantumly corrupted codeword repeatedly, partly because he cannot duplicate \"unknown\" quantum states by a quantum-mechanical principle. The quantumly corrupted codeword is\nlikely to behave \"adversarially\" and hinder the receiver's effort of recovering uniquely the original message.\nQuite often, however, it is sufficient to produce a reasonably short list of message candidates including all the\nmessages whose corresponding codewords are in close proximity to the given quantumly corrupted codeword,\nand thus this list certainly contains the hidden message. This \"closeness\" is scaled by the notion of codeword\npresence (or presence, in short), which indicates the average probability of obtaining successfully each block\n\u2217 An early version appeared in the Proceedings of the 13th Computing: The Australasian Theory Symposium (CATS 2007),\npp. 153\u2013162, Ballarat, Australia, January 30\u2013February 2, 2007. This work was in part supported by the Mazda Foundation.\n\u2020 Current Affiliation: Faculty of Engineering, University of Fukui, 3-9-1 Bunkyo, Fukui, 910-8507, Japan\n\n1\n\n\fsymbol of the target codeword from the quantumly corrupted codeword (see Kawachi and Yamakami [13] for\nan intuition behind this notion). Because of these differences, the classical list decodability does not generally\nimply the quantum list decodability. To construct hardcore functions is the primary purpose of quantum\nlist decoding by Kawachi and Yamakami [13], and their study of quantum list decoding was centered at a\nnatural question of what types of classical block codes are efficiently quantum list decodable.\nIn the past literature showed several families of block codes that are classical/quantum list decodable\nin polynomial time. The first of such examples is a family of Hadamard codes. In the case of classical list\ndecoding, Goldreich and Levin [6] proved the classical list decodability of the binary Hadamard codes, and\nsubsequently Goldreich, Rubinfeld, and Sudan [7] presented a general list-decoding algorithm for the q-ary\nHadamard codes. Concerning quantum list decoding, by contrast, Adcock and Cleve [1] essentially proved\nthat the binary Hadamard codes are quantum list decodable in polynomial time. For the q-ary Hadamard\ncodes, a fast quantum list-decoding algorithm was given by Kawachi and Yamakami [13]. They also presented\ntwo additional quantum list-decodable codes: shifted Legendre symbol codes and pairwise equality codes. A\ncommon feature of these codes is that they all have exponentially small code rate, where the rate of a code\nis a ratio of message length (or a dimension of the code) and codeword's block length. For instance, the\nrate of the binary Hadamard code is exactly n/2n for message length n. Notice that, in a practical setting,\ncode rate and block length are important factors in designing error-correcting codes. In particular, a family\nof polynomial-time classical list-decodable codes of polynomially small rate over the binary code alphabet\nfinds numerous applications in the fields of cryptography and computational complexity theory (refer to,\ne.g., survey articles by Sudan [20] or Trevisan [22]).\nAll known efficiently quantum list-decodable code families have so far exponentially small code rate, which\nis extremely smaller than the code rates of many practical codes. It is therefore natural to ask whether there\nexists an efficiently quantum list-decodable code of polynomially small rate and of fixed alphabet size for\nany given bias parameter. This paper is profoundly motivated by this intriguing question and, as its main\ntheorem, it will successfully prove the existence of such a code family; more strongly, we will show the\nfollowing statement.\nTheorem 1 [Main Theorem] Let q be any prime constant. For any constant k \u2265 1, there exist a\npolynomially-time computable function t : N \u2192 N+ and a classical block (t(n), n)q -code family C such that\n1. C is polynomial-time classically list decodable with confidence 5/6, and\n2. C is polynomial-time quantumly list decodable with presence at least 1/q + 1/nk and confidence 2/3.\n\nThis code family C has code rate n/t(n), which is only polynomially small.\nThe rest of this paper is dedicated to proving this theorem and seeking its application.\nTo obtain the desired code family stated in the main theorem, we will initially seek a well-studied code\nfamily. A family of generalized Reed-Solomon (GRS) codes has relatively large code rate; however, it usually\nhas large alphabet size. From this code family, we will build a family of codes of high code rate over a\nfixed code alphabet by an idea of Forney [5]. In this paper, we will use in Section 3 a concatenated code\nC GRS -H of Guruswami and Sudan [10], which is obtained by concatenating the generalized Reed-Solomon\ncodes with the Hadamard codes. Our key claim-Theorem 7-states that the codes C GRS -H (with an\nadequate choice of code parameters) are efficiently quantum list decodable as far as their codeword presence\nis relatively high. Theorem 1 follows immediately from this claim, because C GRS -H was already proven to\nbe classically list decodable (Guruswami and Sudan [10]). As the first step toward the proof of Theorem\n7, we will demonstrate in Proposition 8 that this concatenated code family possesses efficient quantum list\ndecodability, provided that the generalized Reed-Solomon codes are efficiently quantum list decodable. This\nclaim will be proven in Section 3.2 by employing a technique of constructing an efficient \"quantum reduction\"\nbetween two quantumly corrupted codewords. An advantage of this proof technique is that it requires no\nsoft information, which is a key ingredient in the classical case of Guruswami and Sudan [9, 10].\nOur next step is to show in Lemma 11 that the generalized Reed-Solomon codes are indeed efficiently\nquantum list decodable, by partially applying a polynomial reconstruction algorithm of Guruswami and\nSudan [9], as far as a target codeword has relatively high presence in a given quantumly corrupted codeword.\nUnfortunately, the use of such a classical algorithm makes the query complexity of our quantum list decoder\nquite high. On the contrary, as the presence becomes lower, it seems to become harder to solve efficiently the\nquantum list-decoding problem. For instance, when the presence is arbitrary close to a reciprocal of the code\nalphabet size, we can convert an efficient quantum list-decoding algorithm to an efficient quantum algorithm\nthat even solves a certain NP-complete problem. This immediately leads to an unlikely consequence that\nevery NP-problem can be solved efficiently on a quantum computer with high success probability. In a\nsimilar vein, we will present a direct connection between quantum list decodability of the generalized Reed2\n\n\fSolomon codes and the quantum solvability of two classical problems: the noisy polynomial interpolation\nproblem (NPIP) of Naor and Pinkas [15] and the bounded distance vector problem (BDVP), both of which\nwill be defined in Sections 4.2\u20134.3. To be more precise, we will show that (1) if the generalized Reed-Solomon\ncodes are quantumly list decodable, then the NPIP is quantumly solvable and (2) if the BDVP is quantumly\nsolvable, then the generalized Reed-Solomon codes are quantumly list decodable.\nOur quantum list-decoding algorithm for the aforementioned concatenated code finds an immediate\napplication to certain types of problems. Our example in this paper is an NBQP-search problem, in which,\ngiven a polynomial-time quantum algorithm and an input instance, we want to find a classical witness of\npolynomial size that forces the algorithm to accept the input with high probability. We will show in Section\n5 that solving this search problem on average implies solving it in worst case. This can be compared to a\nclassical case of an NP-search problem of Kumar and Sivakumar [14].\nIn line of the study on quantum list decoding, we will make a brief discussion in Section 6 on another\nnotion of local quantum list decoding based on an implicit-input implicit-output model where an outcome of a\nlist-decoding algorithm is a list of descriptions of quantum-circuit list decoders rather than a list of messages.\nSimilarly to the classical case of Sudan, Trevisan, and Vadhan [21], we can apply our quantum list decoder\nfor generalized Reed-Solomon codes to conduct local quantum list decoding for the Reed-M\u00fcller codes. As\nan immediate consequence, we can prove the so-called hardness amplification of quantum circuits, following\nthe argument of Sudan, Trevisan, and Vadhan [21].\n\n2\n\nFoundations of Quantum List Decoding\n\nThis section explains basic notions and notation concerning quantum list decoding. Throughout this paper,\nlet N denote the set of all natural numbers (i.e., nonnegative integers) and set N+ = N \u2212 {0}. For any\npositive integers m and n with m \u2264 n, the notation [m, n]Z means the integer set {m, m + 1, m + 2, . . . , n}\nand [n] is the shorthand for [1, n]Z whenever n \u2265 1. For any number q \u2208 N+ , Fq (or GF (q)) denotes a finite\n(Galois) field of size q. When q is a prime number, we often express the elements of Fq in terms of the\nnumbers in [0, q \u2212 1]Z . We sometimes use a prime power q m rather than a prime q. Conventionally, we also\nidentify each vector in (Fq )m with its corresponding element in Fqm . Let Q and C respectively denote the\nsets of all rational numbers and of all complex numbers. We further set Q\u22650 = {r \u2208 Q | r \u2265 0}.\nFor a finite alphabet \u03a3, a string x over \u03a3 is a finite sequence of symbols from \u03a3, and |x| denotes the\nlength of x (i.e., the number of all the occurrences of symbols in x).\n\n2.1\n\nClassical Block Codes\n\nWe briefly explain classical block (error-correcting) codes, which are key objects of our interest. Roughly\nspeaking, a (block) code is a set of strings of the same length over a finite alphabet \u03a3 and each string of\na code is indexed by a message and is called a codeword. In this paper, we mostly deal with a family of\ncodes, each of which corresponds to a different message length n in N. Such a code family can be specified\nin general by a series (\u03a3n , In , \u0393n ) of triplets composed of message space \u03a3n , index set In , and code alphabet\n\u0393n for each message length\u2021 n (which serves as a \"basis parameter\" in this paper).\nAs standard nowadays in computational complexity theory, we view a code C (or C (n) , to emphasize\n\"n\") for each fixed message length n as a \"function\" that maps \u03a3n \u00d7 In to \u0393n . For convenience, let the code\nsize N (n) = |\u03a3n | and let the code alphabet size q(n) = |\u0393n |. It is also convenient to assume that \u03a3n = (\u03a3\u2032 )n\nfor a certain fixed message alphabet \u03a3\u2032 so that n actually represents the length of messages in \u03a3n over \u03a3\u2032 ;\nin this case, n = log|\u03a3\u2032 | N (n) holds for every length n \u2208 N. For instance, if \u03a3\u2032 = {0, 1}, then all messages\ncan be expressed in binary. By abbreviating C(x, y) as Cx (y), we treat Cx (*) as a function mapping In to\n\u0393n and we call it a codeword, whose block length (or code length) M (n) equals |In |. Since the elements in\nIn serve as indices of block locations of a codeword, it is often assumed that In = {0, 1, . . . , M (n) \u2212 1} so\nthat each element of In can be expressed in \u2308log2 M (n)\u2309 bits. For convenience, we also identify Cx with\nthe vector (Cx (0), Cx (1), * * * , Cx (M (n) \u2212 1)) in the ambient space (\u0393n )M(n) of dimension M (n). Because we\nmainly work on a finite field, we often regard \u0393n as a finite field Fq(n) of order q(n).\nThe rate of a code C is defined to be the ratio n/M (n). The (Hamming) distance d(Cx , Cy ) between two\ncodewords Cx and Cy is the number of non-zero components in the vector Cx \u2212 Cy . The minimal distance\nd(C (n) ) (or d(n), in short) of the codes of message length n is the smallest distance between any pair of\ndistinct codewords associated with the messages of length n. In contrast, \u2206(Cx , Cy ) denotes the relative\n\u2021 This\n\nparameter is also known as the dimension or information length of a code.\n\n3\n\n\f(Hamming) distance d(Cx , Cy )/M (n). The above-described code is simply called an (M (n), n)q(n) -code\u00a7 (or\n(M (n), n, d(n))q(n) -code, to emphasize the minimal distance d(n) of the code of message length n). For\nreadability, we often drop a length parameter n from both subscripts and argument places whenever we\ndiscuss a set of codewords of a \"fixed\" message length n. A linear (M (n), n)q(n) -code forms a n-dimensional\n\u0001M(n)\nvector space in Fq(n)\n.\n\nHadamard Codes HAD. Let n be any message length used as a parameter, and let q be any prime number.\nA q-ary Hadamard code family HAD(q) = {HAD(q,n) }n\u2208N consists of all (q n , n, q n \u2212 q n\u22121 )q -codes HAD(q,n) :\n(Fq )n \u00d7P(Fq )n \u2192 Fq obtained as follows. For each message x = (x1 , x2 , . . . , xn ) in (Fq )n , HAD(q,n) (x, r)\nn\nequals i=1 xi ri mod q, where r = (r1 , r2 , . . . , rn ) is in the index set (Fq )n .\n\n(Normalized) Generalized Reed-Solomon Codes GRS. Let q be any prime number and let k and n be any\ntwo positive integers satisfying that n \u2264 k \u2264 q. A (normalized) generalized Reed-Solomon code family\nGRS = {GRS(k,n,q) }n,k\u2208N consists of all (k, n, k \u2212 n + 1)q -codes defined as follows. Let x = (x1 , x2 , . . . , xn ) \u2208\n(Fq )n be any message and let Dk be a fixed set of k distinct elements (called code locators) in Fq . Let\nP\nGRS(k,n,q) : (Fq )n \u00d7 Dk \u2192 Fq be defined as GRS(k,n,q) (x, r) = ni=1 xi ri\u22121 mod q, which is a polynomial of\ndegree at most n \u2212 1 with r \u2208 Dk . Occasionally, we expand the domain Dk of GRS(k,n,q)\nto the entire field\nx\nFq .\n\n2.2\n\nQuantumly Corrupted Codewords and Codeword Presence\n\nA quantum bit (or a qubit, in short) is a unit vector in the complex space C2 , and a quantum state is\ngenerally a tensor product of some of these qubits. To express such a quantum state, we customarily use\nDirac's notation. For instance, a quantum state |\u03c6i of two qubits can be expressed as |\u03c61 i \u2297 |\u03c61 i, where |\u03c61 i\nand |\u03c62 i are both qubits; however, we often abbreviate |\u03c61 i \u2297 |\u03c62 i as |\u03c61 i|\u03c62 i. An execution of a quantum\nalgorithm on an input instance corresponds to a series of applications of unitary operations, and it is usually\nmodeled by a \"computation\" of a quantum Turing machine (Bernstein and Vazirani [2]; Yamakami [25, 26])\nor a quantum circuit (Yao [27]). We use the notation A(x) (or more formally, A|xi) to denote a quantum\nstate obtained after executing quantum algorithm A on classical input x (which is formally given in the\nform of quantum state |xi). When we refer to an output of A on x, we mean a classical string that is\nobtained by measuring (or observing) the quantum state A(x) in the standard computational basis, where a\nmeasurement is a projection onto a certain Hilbert space. For simplicity, we say that a quantum algorithm\nruns in polynomial time if its corresponding quantum Turing machine halts within time polynomial in the\nlength of each input. Similar to the complexity classes P and NP, BQP denotes the collection of all (classical)\ndecision problems that can be solved by quantum algorithms in polynomial time with success probability\nat least 2/3. For more details on quantum computation, the reader may refer to, e.g., Nielsen and Chuang\n[16].\nLet us consider a quantum procedure that tries to encode a classical message into its codeword. In\ngeneral, a quantum computation tends to interact with an outside system of a currently operating quantum\nsystem, causing a quantum corruption of the computation. Hence, our process of quantum encoding may be\ncorrupted. A corrupted process of such quantum encoding can be described as an application of a certain\nform of unitary operator. As noted before, when q(n) is a prime number, we represent each element in Fq(n) as\nan integer in [0, q(n) \u2212 1]Z , which is further expressed in binary. In their 2006 conference paper, Kawachi and\nYamakami coined the terminology-a quantum-computationally corrupted codeword or quantumly corrupted\ncodeword-to describe such a unitary operator O, with two fixed parameter functions l(n) and m(n) mapping\nN to N, that satisfies the following condition: for any two strings r \u2208 In and s \u2208 {0, 1}m(n) and any number\nl(n), there exists a quantum state |\u03c6r,z i of l(n) qubits such that\nX\n\u03b1r,z |ri|s \u2295 zi|\u03c6r,z i,\n(1)\nO|ri|si|0l(n) i =\nz\u2208{0,1}m(n)\n\nwhere the notation \u2295 denotes the bitwise XOR, |\u03c6r,z i indicates garbage information\nP produced when we apply\nthe operator O to the three registers, and the amplitudes {\u03b1r,z }r,z satisfy that z\u2208{0,1}m(n) |\u03b1r,z |2 = 1 for\nevery index r \u2208 In . Since O is a unitary operator, so is its inverse O\u22121 . Another important notion of Kawachi\nand Yamakami is \"codeword presence\" in O. The presence of codeword Cx in O, denoted PreO (Cx ), is the\naverage probability of obtaining\nthe correct values Cx (r) by a measurement over all indices r \u2208 In ; namely,\nP\nPreO (Cx ) = (1/M (n)) r\u2208In |\u03b1r,Cx (r) |2 .\n\u00a7 The\n\nreader should be aware that, in some literature, the notation (M (n), \u0393n )q(n) is used instead.\n\n4\n\n\f2.3\n\nAsymptotic Behaviors of Codeword Presence\n\nThe value of codeword presence is a key to the performance of a quantum list decoder. We will briefly argue\nasymptotic behaviors of codeword presence for arbitrary quantumly corrupted codewords in a fashion similar\nto classical cases of Guruswami, H\u00e5stad, Sudan, and Zuckerman [8]. For this purpose, we need to expand\nthe existing notions of presence and (Hamming) distance of codewords in a more general fashion. Notice\nthat these generalized presence and distance are applied only to this subsection.\nLet n be any message length and define Wn to be the set of all vectors w = (wr,z )r\u2208In ,z\u2208Fq(n) \u2208\n2\n[0, 1]q(n)M(n) (where each wr,z may be viewed as the probability |\u03b1r,z\nP| of obtaining (r, z) after measuring a quantumly corrupted codeword) satisfying the restriction that z\u2208[0,q(n)\u22121]Z wr,z = 1 for each index\nP P\nr \u2208 [0, M (n) \u2212 1]Z , where M (n) = |In |. For every w \u2208 Wn , it follows that r z wr,z = M (n). Next, we\nconsider the set Vn of all codewords (viewed as a vector) a = (ar )r\u2208In \u2208 ([0, q(n) \u2212 1]Z )M(n) . We embed\n(a)\neach codeword a into Wn by the special mapping v, defined as v(a) = (\u03b4r,z )r\u2208In ,z\u2208Fq(n) \u2208 {0, 1}q(n)M(n) ,\n(a)\n\nwhere \u03b4r,z is 1 if a(r) = z, and 0 otherwise. Moreover, for any code (seen as a subset of Vn ) C (n) , let\nv(C (n) ) = {v(a) | a \u2208 C (n) }. Obviously, v(Vn ) \u2286 Wn holds.\nUsing the above notations, let us generalize the notions of distance and presence as follows. For any\npair v, w \u2208 Wn , we define d(v, w) = M (n) \u2212 hv|wi, where h*|*i denotes the standard inner product. This\ngeneralized notion naturally expands the standard notion of the distance d(*, *) because, for any a, b \u2208 Vn ,\nwe have\nd(v(a), v(b)) = M (n) \u2212 hv(a)|v(b)i) = M (n) \u2212 |{(r, z) | a(r) = b(r) = z}| = d(a, b).\nMoreover, for any two vectors a \u2208 Vn and w \u2208 Wn , define Prew (a) =\nPrew (a) =\n\n1\nM(n) hv(a)|wi.\n\nWe then obtain\n\nM (n) \u2212 d(v(a), w)\nhv(a)|wi\nd(v(a), w)\n=\n=1\u2212\n.\nM (n)\nM (n)\nM (n)\n\nFirst, we wish to obtain an asymptotic lower bound of codeword presence in terms of minimal relative\ndistance \u03bb. For this purpose, we will introduce the notation QLpoly (\u03bb) for the minimal possible \"presence\"\n\u03b5, with which, for an arbitrary family of block codes with minimal relative distance \u03bb, the cardinality of all\nmessages having codeword presence of at least \u03b5 is polynomially bounded. More precisely, let C = {C (n) }n\u2208N\nbe any (M (n), n, d(n))q(n) -code family and let \u2206(C (n) ) = d(C (n) )/M (n) express the relative distance of\nC (n) . For each pair w \u2208 Wn and \u03b5 \u2208 [0, 1], we write E(w, \u03b5) for the set {a \u2208 Vn | Prew (a) \u2265 \u03b5}. For\n\u22650\nany function f : N \u2192 N and any number n \u2208 N, the notation presence(C,\no min{\u03b5 \u2208 R |\nn f )(n) denotes\n)(n)\n. In addition, let\n\u2200w \u2208 Wn [ |E(w, \u03b5) \u2229 C (n) | \u2264 f (n) ]} and we set P re(C, f ) = lim supn\u2192\u221e presence(C,f\nM(n)\nQLf (\u03bb) = inf C:\u2206(C)\u2265\u03bb {P re(C, f )}, where \u2206(C) = lim inf n\u2192\u221e {\u2206(C (n) )}. For each fixed constant c \u2208 N, we\n(c)\n\nset QLpoly\n(\u03bb) = supa>0 {QLf (c) (\u03bb)}, where fa (n) = anc for any number n \u2208 N. Finally, QLpoly (\u03bb) is set\nc\na\nto be lim supc\u2192\u221e {QLpoly\n(\u03bb)}.\nc\nProposition 2 Let c be any positive constant and let \u03bb be any number in [0, 1], representing a minimal\n1/2\nrelative distance. It holds that either QLpoly\n(\u03bb) \u2265 1/q + (1 \u2212 1/q) (1 \u2212 \u03bb/(1 \u2212 1/q) + \u03bb/anc (1 \u2212 1/q))\nor\nc\n1/2\n1/2\npoly\npoly\nQLc (\u03bb) \u2265 1/q + (1 \u2212 1/q) (1 \u2212 \u03bb/(1 \u2212 1/q)) . Therefore, QL\n(\u03bb) \u2265 1/q + (1 \u2212 1/q) (1 \u2212 \u03bb(1 \u2212 1/q))\nfollows.\np\np\nIn certain extreme cases, it holds that QLpoly (0) = 1 and QLpoly (1) \u2265 1/q + (1 \u2212 1/q)/q. It remains\n1/2\nopen whether the equality QLpoly (\u03bb) = 1/q + (1 \u2212 1/q) (1 \u2212 \u03bb(1 \u2212 1/q))\nholds or not.\nNext, we will show an asymptotic upper bound of codeword presence, particularly, in terms of the rate of\na \"linear\" (M (n), n, d(n))q(n) -code family C = {C (n) }n\u2208N . For convenience, we write rate(C (n) ) for the code\nrate n/M (n) of C (n) . Here, let R be any code rate in [0, 1] and let f : N \u2192 N be any function. We define\nQUf (R) = supC:rate(C)\u2265R {P re(C, f )}, where rate(C) = lim inf n\u2192\u221e {rate(C (n) )}. With this notation, for\neach constant c > 0, we write QUcconst (R) for QUfc (R), where fc is a constant function defined as fc (n) = c\nfor all numbers n \u2208 N. Define QU const (R) to be lim supc\u2192\u221e {QUcconst (R)}.\nProposition 3 Fix an odd prime number q. For every constant c \u2208 N+ with c > 2(q \u2212 1) and every code\n\nrate R \u2208 (0, 1), it holds that QUcconst (R) \u2265 1 \u2212 q \u2212\n\n(1+2R)c\u2212q\n(q\u22122)c\n\n. Therefore, QU const (R) \u2265 1 \u2212 q \u2212\n\nFor readability, we place the proofs of Propositions 2\u20133 in Appendix.\n\n5\n\n1+2R\nq\u22122\n\nfollows.\n\n\f2.4\n\nKawachi-Yamakami Implicit-Input Explicit-Output Model\n\nTo formulate the notion of quantum list decoding, this paper deals with a specific model in which we implicitly\ntake a quantumly corrupted codeword as a form of \"oracle\" and then we output a list of messages explicitly\nafter accessing the oracle by way of oracle queries. A process of making an oracle query and then receiving\nits oracle answer is conventionally assumed to take a unit time. Upon this implicit-input explicit-output\nmodel, the quantum list-decoding problem (QLDP) for a classical block code family C can be described as\nfollows. First, let C = {C (n) }n\u2208N be any (M (n), n, d(n))q(n) -code family with message space \u03a3n and let O\nbe any set of quantumly corrupted codewords for C. Taking a bias parameter \u03b5 : N \u2192 [0, 1], we define the\n\u03b5-QLDP as:\n\u03b5-Quantum List Decoding Problem (\u03b5-QLDP) for Code Family C with respect to O\n\u25e6 Input: a message length n and a value 1/\u03b5(n) > 0.\n\u25e6 Implicit Input: an oracle O \u2208 O representing a quantumly corrupted codeword for C (n) .\n\u25e6 Output: a list of messages including all messages x \u2208 \u03a3n that satisfy the inequality PreO (Cx ) \u2265\n1/q(n) + \u03b5(n). For convenience, we refer to such a list as a valid list for the \u03b5-QLDP.\nOur goal is to solve the problem \u03b5-QLDP for C using an efficient quantum algorithm that makes an oracle\naccess to a given quantumly corrupted codeword in O with success probability at least \u03b4(n), which is given\nas a confidence parameter. Here, let us formally introduce the notion of a quantum list-decoding algorithm\n(or simply, a quantum list decoder) that works with two parameters: bias \u03b5 and confidence \u03b4.\nDefinition 4 (quantum list decoding) Let C be any code family, let \u03b5(n) be any bias parameter, and let\n\u03b4(n) be any confidence parameter. A quantum list-decoding algorithm (or a quantum list decoder) for C with\nbias \u03b5 and confidence \u03b4 is a quantum algorithm A that solves the \u03b5-QLDP for C with success probability at\nleast \u03b4(n). If A further runs in time polynomial in (n, 1/\u03b5(n), 1/\u03b4(n)), it is called a polynomial-time quantum\nlist-decoding algorithm for C.\nThe list size of a quantum list decoder with respect to input size n refers to the maximal size of any valid\nlist produced by the algorithm on any input of size n. In certain applications, the list size of a single valid\nlist plays a crucial role; for instance, when a quantum list decoder produces only a single valid list L (along\nall measured outcomes) with probability at least \u03b4(n), certain \"advice\" of size \u2308log|\u03a3| |L|\u2309 over a message\nalphabet \u03a3 may help specify a hidden message x uniquely with the same success probability.\nA close connection between quantum list decoding and (strongly) quantum one-way functions was exhibited by Kawachi and Yamakami [13]. The rest of this subsection briefly discusses a further relationship\nbetween quantum list decoding and a restricted form of quantum one-way functions, called quantum super\none-way functions, which can be seen as a natural extension of quantum one-way permutations.\nDefinition 5 (quantum super one-wayness) Let f be any function mapping \u03a3\u2217 to \u03a3\u2217 with length\nfunction l : N \u2192 N, that is, |f (x)| = l(|x|) for every x. This function f is called quantum super oneway if (i) there exists a polynomial-time quantum algorithm A such that, for every input x of length n,\nA|xi|0l(n) i|0e(n) i = |xi|f (x)i|\u03c6x i holds for a certain unit-norm quantum state |\u03c6x i of e(n) qubits and (ii) for\nany positive polynomial p and any polynomial-time quantum algorithm B, the probability that B on input\n|1n i|f (x)i|\u03c6x i outputs x of length n is at most 1/p(n) for all but finitely many strings x.\nIn comparison with Definition 5, the quantum one-wayness formulated by Kawachi and Yamakami [13]\nrequires that B|f (x)i outputs x only with negligible probability whereby the information |\u03c6x i is hidden from\nthe adversary B who tries to invert f . Definition 5, on the contrary, indicates that B cannot output x\nwith non-negligible probability even though |\u03c6x i is given to B besides f (x) as supplemental information. In\ncomputational cryptography, this notion naturally arises. A typical example of super one-way function is\na quantum one-way permutation obtained by replacing further the quantum state |\u03c6x i in Definition 5 with\n|0m i, which is obtained, for example, by uncomputing a deterministic procedure that computes f (x) from\nx.\nIn what follows, for any index i, the notation (f (x))i denotes the ith bit of the value f (x) whenever\n1 \u2264 i \u2264 |f (x)|.\nLemma 6 Let f be any quantum super one-way function with its length function m(n) \u2208 nO(1)\n(i.e., |f (x)| = m(|x|)). Consider an (m(n), n, d(n))q(n) -code C whose codeword Cx (r) is (f (x))r . For\nevery positive polynomial p, this code C cannot be polynomial-time quantum list decodable with confidence\n1/p(n).\n\n6\n\n\fProof.\nLet f be a quantum super one-way function with its length function m(n), where m(n) is\npolynomially bounded, and consider an (m(n), n, d(n))q(n) -code C satisfying Cx (r) = (f (x))r for any x and\nr. Since a certain polynomial-time quantum algorithm must compute f exactly as stated in Definition 5,\nby modifying this algorithm slightly, we obtain another polynomial-time quantum algorithm, say, A that\ncomputes C(x, r). Without loss of generality, we may assume that, for every n \u2208 N+ , every x \u2208 \u03a3n , and\nevery r \u2208 [l(n)], A|xi|ri|0i|0e(n) i = |xi|ri|Cx (r)i|\u03c6x i holds for a certain quantum state |\u03c6x i that depends\nonly on x. Here, we fix x of length n arbitrarily and define Ox |ri|si|0e(n) i = |ri|s \u2295 Cx (r)i|\u03c6x i for any strings\nr and s. Notice that PreOx (Cx ) = 1 holds. Toward a contradiction, assume that C has a polynomial-time\nquantum list decoder B such that, since the presence of Cx in Ox is 1, B on input 1n produces the hidden\nstring x with probability at least 1/p(n) for a certain fixed positive polynomial p, where \"1n \" indicates an\ninput representing \"n\" in the definition of the \u03b5-QLDP. We want to invert f in polynomial time. For this\ngoal, we define a quantum algorithm D as follows.\nOn input |1n i|f (x)i|\u03c6x i, where n = |x|, we run the quantum list decoder B on input 1n using Ox\nas an oracle. However, whenever B makes an oracle query |ri|si|ti to the oracle Ox , we simulate\nthe behavior of Ox as follows. We generate an oracle answer |ri|s \u2295 (f (x))r i|\u03c6x i directly using\nthe input information. Finally, we output an outcome of B. Since PreOx (Cx ) = 1, the outcome\nof B must be x itself.\n\nThe above algorithm D thus inverts f correctly with probability at least 1/p(n). This implies that f cannot\nbe quantum super one-way, a contradiction against our assumption. Therefore, C is not polynomial-time\nquantum list decodable with confidence 1/p(n).\n\u2737\n\n3\n\nCodes of Polynomially Small Rate\n\nThe proof of our main theorem (Theorem 1) requires a suitable code family of polynomially small code rate\nover a fixed code alphabet. Such a code family can be obtained by Forney's [5] idea of concatenating two\nappropriate code families. In Section 3.1, we will claim that this concatenated code family is efficiently\nquantumly list decodable for a certain choice of code parameters. This claim-Theorem 7-then leads to\nthe main theorem. Therefore, our primary goal is to conduct necessary ground work that leads to the proof\nof Theorem 7. For the sake of readability, we will split the proof into two claims-Proposition 8 and Lemma\n11-and this section will prove only the proposition, leaving the lemma to Section 4. A key proof technique\nof this section in handling the concatenated code is a quantum reduction between two quantumly corrupted\ncodewords, maintaining \"similar\" codeword presence values.\n\n3.1\n\nConcatenated Codes\n\nA typical way to build a family of classical block codes that have desired code rate and desired code alphabet\nsize is to compose two appropriate block codes with certain necessary code properties. This is Forney's [5]\nnovel method of creating so-called concatenated codes. In our case, concatenating an appropriate generalized\nReed-Solomon code with its matching Hadamard code, we can build a code of polynomially small code rate\nand constant code alphabet size. For such a code family, we will prove its efficient quantum list decodability,\nprovided that the generalized Reed-Solomon codes have efficient quantum list decoders.\nMore formally, let us consider two block codes C1 and C2 such that C1 is an (M1 , n1 , d1 )qn2 -code and C2\nis an (M2 , n2 , d2 )q -code. Let x = (x1 , x2 , . . . , xn1 ) be any message of length n1 , where each entry xi is taken\nfrom \u03a3n2 over a q-letter alphabet \u03a3. Since xi can be expressed as an n2 -letter string, x can be viewed as a\nstring of total length n1 n2 over \u03a3. By taking the inner code C2 concatenated with the outer code C1 , the\nconcatenated code C = C2 \u2299 C1 is defined as C(x, r, s) = C2 (C1 (x, r), s) for every triplet (x, r, s). This code\nC becomes an (M1 M2 , n1 n2 , d)q -code with d satisfying d \u2265 d1 d2 , where d1 d2 is called the design distance.\nFor our purpose of this section, we choose the concatenated code C GRS -H [n, q, \u03b8] given by Guruswami\nand Sudan [10]. This concatenated code is obtained from a certain generalized Reed-Solomon code used as\nan outer code together with an appropriate Hadamard code used as an inner code. Following Guruswami\nand Sudan [10], here we choose three parameters (n, q, \u03b8) with n, q \u2208 N and \u03b8 \u2208 [0, 1] that satisfy n \u2265 1,\nq \u2265 2, n = mq m \u03b8, and q m \u03b8 \u2208 N for a certain number m \u2208 N. In what follows, we freely identify elements in\n(Fq )n with elements in Fqn in the standard fashion.\nConcatenated Code C GRS -H [n, q, \u03b8]. The concatenated code C GRS -H [n, q, \u03b8] is defined by C GRS -H [n, q, \u03b8] =\nHAD(q,m) \u2299 GRS(q\n\nm\n\n,qm \u03b8,qm )\n\n. This is a (q 2m , n, d)q -code, where n = mq m \u03b8 and d \u2265 (1 \u2212 1/q)(1 \u2212 \u03b8)q 2m\n7\n\n\f(design distance). From n = mq m \u03b8, we obtain log n = log mq m \u03b8, from which m =\n\nlog n\u2212log m+log(1/\u03b8)\nlog q\nk\n\nn log q\nn\nfollows. This implies log(1/\u03b8)\n\u2264 m \u2264 n; thus, q m = m\u03b8\n\u2264 \u03b8 log(1/\u03b8)\n. As long as q is fixed and \u03b8 = \u03a9(1/n )\nlog q\n+\nm\nk+1\nholds for a certain constant k \u2208 N , q is upper-bounded by O(n\n/ log n). Hence, the code rate n/q 2m is\nc log n\nlower-bounded by nk for a certain constant c > 0.\nThis concatenated code family C GRS -H = {C GRS -H [n, q, \u03b8]}\nis proven by Guruswami and Sudan [10]\nn,q,\u03b8\n\nto be efficiently classically list decodable; that is, there exists a polynomial-time probabilistic algorithm that\nproduces, from any classically corrupted codeword (or conventionally, a received word ) w, a list containing\nall messages x whose codewords are all at distance close to w. To prove Theorem 1, it therefore suffices to\nshow that the code family C GRS -H is also quantumly list decodable in an efficient manner for appropriately\nchosen parameters. In a more general fashion, we intend to show the following statement. Let T denote the\ncollection of all tuples (n, m, q, \u03b8) such that m, q, \u2208 N+ , q \u2265 2, \u03b8 \u2208 [0, 1], q m \u03b8 \u2208 N, and n = mq m \u03b8.\nTheorem 7 For each n \u2208 N+ , assume that a parameter tuple (m, q, \u03b8, \u03b5, \u03b4) satisfies the following\nconditions:\nq\n(n, m, q, \u03b8) \u2208 T , \u03b5, \u03b4 \u2208 [0, 1], 2(1 \u2212 1/q)2 (1/M + \u03b5\u2032 ) < \u03b52 , and 2(1 \u2212 1/q)2 (1 \u2212 1/M \u2212 \u03b5\u2032 )\n\n\u2206\n1+M\u03b5\u2032\n\n< \u03b52 for\n\na certain \u03b5\u2032 \u2208 (0, 1), where M = q m and \u2206 = 2(n \u2212 1) log(M 2 /(1 \u2212 \u03b4)). The concatenated code family\nC GRS -H = {C GRS -H [n, q, \u03b8]}n,q,\u03b8 with the above conditions has a quantum list decoder with bias \u03b5 and\nconfidence \u03b4 running in time polynomial in (n, q, 1/\u03b5, 1/\u03b4, 1/(1 \u2212 \u03b4)).\nHere, we give the proof of Theorem 1 using Theorem 7. Although it is possible to relax the conditions\nstated in Theorem 7 further, they are sufficient to prove Theorem 1.\nProof of Theorem 1. Fix a prime number q, a constant k \u2208 N+ , and a confidence parameter \u03b4. Here,\nwe set \u03b5 = 1/nk . We also choose other parameters (n, m, q, \u03b8) \u2208 T and M = q m = O(nl ) \u2229 \u03a9(n8k+4 )\nfor a certain fixed constant l \u2265 8k + 4 and consider the code C GRS -H [n, q, \u03b8]. In this case, it holds that\n\u03b8 = n/mM = \u03a9(1/nl\u22121 ) since m = log M/ log q. This guarantees the polynomially small code rate of C. Let\nus define t(n) = M 2 . Note that the value \u2206 = 2(n \u2212p\n1) log(M 2 /(1 \u2212 \u03b4)) satisfies \u2206\u221a= O(n log n) = O(n1.4 ).\n4k+2\n\u2032\n\u2032\n). It thus\nFor simplicity, set \u03b1 =\nq1/M + \u03b5 . Now, defining \u03b5 = 1/M , we obtain M \u03b1 = 1 + qM = \u03a9(n\n\u2206\n\u2206\nfollows that 2(1 \u2212 \u03b1) M\u03b1\n= O(n0.7 /n2k+1 ). Since \u03b5 = 1/nk , we obtain 2(1 \u2212 \u03b1) M\u03b1\n< \u03b52 and 2\u03b1 < \u03b52\nfor any sufficiently large n. Since all premises of Theorem 7 are fulfilled, there must exist a quantum list\ndecoder with bias \u03b5 and confidence \u03b4. This quantum list decoder runs in time polynomial in n since the\nparameters (q, \u03b4) are constants. This completes the proof.\n\u2737\n\nLet us return to Theorem 7. This theorem, in fact, follows from two technical claims: Proposition 8 and Lemma 11. We will prove in Proposition 8 that the concatenated code family C GRS -H =\n{C GRS -H [n, q, \u03b8]}n,q,\u03b8 has a polynomial-time quantum list decoder for an appropriate choice of three parameters (n, q, \u03b8), assuming that the generalized Reed-Solomon codes are quantum list decodable in polynomial\ntime. This last assumption will be later eliminated, in Lemma 11, completing the proof of Theorem 7.\nProposition 8 For each n \u2208 N+ , let (q, \u03b8, m, \u03b5, \u03b5\u2032 , \u03b4) satisfy the following conditions: (n, m, q, \u03b8) \u2208 T ,\n\u03b5, \u03b5\u2032 , \u03b4 \u2208 [0, 1], and \u03b52 \u2265 (1 \u2212 1/q)2 (1/M + \u03b5\u2032 ). If the (M, M \u03b8, (1 \u2212 \u03b8)M + 1)M -generalized Reed-Solomon code\nhas a quantum list decoder with bias \u03b5\u2032 and confidence \u03b4 running in time polynomial in (n, q, 1/\u03b5\u2032 , 1/\u03b4, 1/\u03b8),\nwhere M = q m , then C GRS -H [n, q, \u03b8] has a quantum list decoder with bias \u03b5 and confidence \u03b4 running in\ntime polynomial in (n, q, 1/\u03b5\u2032 , 1/\u03b4, 1/\u03b8).\nNote that the confidence \u03b4 for the GRS-code in Proposition 8 is carried over to the confidence for the\nconcatenated code C GRS -H [n, q, \u03b8]. The proposition is an important ingredient of Theorem 7 and its proof\nwill be given in the subsequent subsection.\n\n3.2\n\nA Quantum Reduction Technique\n\nAiming at proving Proposition 8, we wish to construct a \"quantum reduction\" between two quantumly\ncorrupted codewords. Such a reduction, say, from O to O\u2032 can be described as a quantum algorithm that,\non input of the form |ri|si|ti, computes the outcome O\u2032 |ri|si|ti by invoking a number of oracle calls to O as\nwell as O\u22121 . This can be seen as a strong form of well-known Turing reduction between two languages.\nHere, let C be any (q m , n/m)qm -code, which is, as before, treated as a function C(x, r) mapping from\nn\n(Fq ) m \u00d7 Fqm to Fqm whenever n/m \u2208 N+ . Recall that we freely identify (Fq )m with Fqm . As a technical\nlemma essential for the proof of Proposition 8, we will show a general result concerning a concatenated code\n\n8\n\n\fD = HAD(q,m) \u2299 C. Since the q-ary Hadamard code HAD(q,m) is used as an inner code, we can rephrase D\nas\nD(x, r, s) = C(x, r) * s mod q\n\nfor any r, s \u2208 Fqm and any x \u2208 (Fqm )n .\nIn what follows, let us aim at constructing a quantum reduction between quantumly corrupted codewords\nOC and OD associated with the codes C and D, respectively. For convenience, we introduce new terminology.\nFor any unitary transform U , we say that a quantum algorithm A realizes U if, for any basis quantum state\n|ri, A on input |ri exactly produces the quantum state U |ri. This notion will help describe a quantum\nreduction from OC to OD .\nLemma 9 Let C and D be the codes given as above. For any quantumly corrupted codeword OC for C,\nthere exist a polynomial-time quantum algorithm A and a quantumly corrupted codeword OD for D such that\n1. PreOD (Dx ) = 1/q + (1 \u2212 1/q) PreOC (Cx ); and\n2. A realizes OD with one oracle access to OC .\nFor the proof of Proposition 8, we need to weaken the notions of \"quantumly corrupted codeword\" and\n\"realization.\" A generalized\nquantumly corrupted codeword O is defined by Eq.(1) except that we require\nP\nonly the inequality z |\u03b1r,z |2 \u2264 1 among the amplitudes {\u03b1r,z }r,z . The codeword presence of Cx in each\nof the operators Ok is defined as before. Let O = {Ok }k\u2208[q\u22121] denote a series of generalized quantumly\ncorrupted codewords.\nPFor this series O, we also define the average (codeword) presence avPreO (Cx ) of Cx in\nO to be (1/(q \u2212 1)) k\u2208[q\u22121] PreOk (Cx ). For a series U = {Uk }k\u2208[q\u22121] of unitary operations, we say that a\nquantum algorithm A weakly realizes U if A on input |ki|ri|0i generates a certain quantum state and, after\ntracing out the third register by the observable |0i, it becomes |ki \u2297 Uk |ri.\nLemma 10 Let C and D be the codes given as above. For any quantumly corrupted codeword OD for\nD, then there exist a polynomial-time quantum algorithm A and a series O = {Ok }k\u2208[q\u22121] of generalized\nquantumly corrupted codewords for C such that\n1. avPreO (Cx ) \u2265 (q/(q \u2212 1))2 (PreOD (Dx ) \u2212 1/q)2 ; and\n\u22121\n2. A weakly realizes O with one oracle access to each of OD and OD\n.\nLemma 10 gives a fast quantum reduction from OD to OC . From this lemma directly follows Proposition\n8. Before proving Lemmas 9\u201310, we briefly describe the proof of the proposition.\nProof of Proposition 8. Let n \u2208 N+ be any length parameter and assume that all other parameters\n(m, q, \u03b8, \u03b5, \u03b5\u2032 , \u03b4) satisfy the premise of the proposition. Hereafter, we set M = q m and D = C GRS -H [n, q, \u03b8]\nfor brevity. Let us assume that the (M, M \u03b8, (1\u2212\u03b8)M +1)M -generalized Reed-Solomon code has a polynomialtime quantum list decoder, say, A with bias \u03b5\u2032 and confidence \u03b4. Take any quantumly corrupted codeword\nO for D. Our goal here is to find from O all messages x that satisfy the inequality PreO (Cx ) \u2265 1/q + \u03b5 in\ntime polynomial in (n, q, 1/\u03b5\u2032 , 1/\u03b4, 1/\u03b8) with confidence \u03b4.\nSince D = HAD(q,m) \u2299 GRS(M,M\u03b8,M) , Lemma 10 helps reduce O to a series O\u2032 = {Ok\u2032 }k\u2208[q\u22121] of generalized quantumly corrupted codewords for the outer code GRS(M,M\u03b8,M) so that O\u2032 can be weakly realized\nby a certain polynomial-time quantum algorithm, say, B with the following average presence condition:\n\u00132 \u0012\n\u00132\n\u0012\n\u0010\n\u0011\n1\nq\n(M,M\u03b8,M)\nPreO (Dx ) \u2212\n\u2265\navPreO\u2032 GRSx\nq\u22121\nq\n\u00132\n\u0012\n1\nq\n\u03b52 \u2265\n+ \u03b5\u2032 ,\n\u2265\nq\u22121\nM\nwhere the last inequality follows directly from the bound \u03b52 \u2265 (1 \u2212 1/q)2 (1/M + \u03b5\u2032 ), which is given as\na part of the premise of the proposition. In other words, the average value of PreOk\u2032 (GRS(M,M\u03b8,M)\n) over\nx\nall k \u2208 [q \u2212 1] is lower-bounded by 1/M + \u03b5\u2032 . Thus, we can choose an index k0 \u2208 [q \u2212 1] for which\nPreOk\u2032 (GRS(M,M\u03b8,M)\n) \u2265 1/M + \u03b5\u2032 . By our assumption, for this k0 , A correctly produces a list including all\nx\nmessages x satisfying PreOk\u2032 (GRS(M,M\u03b8,M)\n) \u2265 1/M + \u03b5\u2032 with confidence \u03b4.\nx\nLet us consider the following quantum algorithm, which uses A and B as subroutines.\nOn input, we first set k = 0 and, by incrementing k by one, we inductively run the quantum list\ndecoder A with Ok\u2032 as an oracle to produce a list of message candidates. During inductive steps,\nwe always append new candidates to the existing list. Whenever a query is made, we run B to\n9\n\n\fgenerate its oracle answer. This is possible because B weakly realizes O\u2032 . Eventually, we reach k0\n) \u2265 1/M + \u03b5\u2032\nand we then obtain a list containing of all messages x satisfying PreO\u2032 (GRS(M,M\u03b8,M)\nx\nwith probability at least \u03b4.\nThis algorithm is obviously a quantum list decoder and it produces with confidence \u03b4 a list that contains\nall messages x satisfying PreO (Dx ) \u2265 1/q + \u03b5. This completes the proof.\n\u2737\nNext, we want to prove Lemmas 9\u201310. We begin with the proof of Lemma 10.\nWe denote by D the concatenated code HAD(q,m) \u2299\nProof of Lemma 10. Let C be any (q m , n/m)qm -code.\nP\nC and assume that OD satisfies OD |r, si|ui|0l(n) i = z\u2208Fq \u03b1r,s,z |r, si|u \u2295 zi|\u03c6r,s,z i for any r, s \u2208 Fqm , where\nP\nl(n) indicates the size of garbage information |\u03c6r,s,z i. Note that PreOD (Dx ) = q \u22122m r,s\u2208Fqm |\u03b1r,s,Dx (r,s) |2\nP\nand that z\u2208Fq |\u03b1r,s,z |2 = 1 for every pair (r, s).\nWe wish to define the desired quantum algorithm A and the desired series O = {Ok }k of generalized\nquantumly corrupted codewords that can be weakly realized by A using OD as an oracle.\nTo\nP describe the\n\u221a\nalgorithm A, we utilize a special unitary transform U over [q \u2212 1] acting as U |0i = (1/ q \u2212 1) k\u2208[q\u22121] |ki as\nP\nwell as a quantum Fourier transform Fq over Fq that acts as Fq |si = q \u22121/2 w\u2208Fq \u03c9qs*w |wi for any s \u2208 Fq . It\nwas proven by van Dam, Hallgren, and Ip [23] that Fq can be approximated to within error \u03b7 on a quantum\ncomputer in time polynomial in (log q, log(1/\u03b7)).\nQuantum Algorithm A:\n\n(1) Start with an initial quantum state |\u03c81 i = |ki|ri|0m i|0i|0l i.\n(2) By applying the\n(Fq )m to the third register, we generate the quantum state\nP quantum Fourier transform\nl\n\u2212m/2\n|\u03c82 i = q\ns\u2208(Fq )m |ki|r, si|0i|0 i, where |r, si is a shorthand for |ri|si.\n(3) Apply P\nOD to the\nP last three registers. This step transforms the quantum state |\u03c82 i into |\u03c83 i =\nq \u2212m/2 s\u2208(Fq )m z\u2208Fq \u03b1r,s,z |ki|r, si|zi|\u03c6r,s,z i.\n(4) Apply the phase encoding of Kawachi and Yamakami [13]; that is, encode the content of\nthe fourth\nregister\nP into the \"phase\" together with the information on k to obtain |\u03c84 i =\nP\nq \u2212m/2 s\u2208(Fq )m z\u2208Fq \u03c9qk*z \u03b1r,s,z |ki|r, si|zi|\u03c6r,s,z i.\n\u22121\n(5) P\nApply OD\n,Pthe inverse of OD , to the last four registers. The resulted state |\u03c85 i can be expressed as\nl\nm\ns\u2208(F\u2212q)\nz\u2208Fq \u03b2k,r,s,z |ki|r, si|0i|0 i + |ki|\u2206k,r i with certain amplitudes \u03b2k,r,s,z and a certain vector\n|\u2206k,r i whose last two registers does not contain the term |0i|0l i. Each amplitude \u03b2k,r,s,z is calculated\nas\n1\n\u22121\n\u03b2k,r,s,z = hk|hr|hs|h0|h0l |I \u2297 OD\n|\u03c8k i = m/2 \u03c9qk*z |\u03b1r,s,z |2 ,\nq\nwhere I is the identity transform. The quantum state |\u03c85 i is thus written in the form\nX X\n1\n\u03c9qk*z |\u03b1r,s,z |2 |ki|ri|si|0i|0l i + |ki|\u2206k,r i.\nm/2\nq\nm z\u2208F\ns\u2208(Fq )\n\nq\n\n(6) Focusing on the last two registers, if they contain |0i|0l i, then we multiply the content s of the third\nregister by k to obtain k * s (seen as a scalar multiplication of a vector); otherwise, do nothing. Note\nthat k * s is in (Fq )m since s \u2208 (Fq )m and k \u2208 Fq . Let |\u03c86 i denote the obtained quantum state.\n(7) Similarly, whenever |0i|0l i appears in the last two registers, apply the inverse of the quantum\nFourier transform (Fq\u22121 )m to the third register. This transform produces the quantum state |\u03c87 i =\nP\nl\nw\u2208(Fq )m \u03b3k,r,w |ki|ri|wi|0i|0 i + |ki|\u2206k,r i, where \u03b3k,r,w is a complex number given as\n\u03b3k,r,w = hr|hw|h0|h0l |(F |\u03c86 i) =\n\n1\nqm\n\nX\n\ns\u2208(Fq\n\n)m\n\nX\n\nz\u2208Fq\n\n\u03c9qk(z\u2212w*s) |\u03b1r,s,z |2 ,\n\nwhere F = I \u2297 I \u2297 (Fq\u22121 )m \u2297 I.\nl\n(8) Observe the last\nP register in state |0i|0 i and discard the term |\u2206k,r i. Finally, output the final quantum\nstate |\u03c88 i = w\u2208(Fq )m \u03b3k,r,w |ki|ri|wi. This finishes the description of A.\nWe define O = {Ok }k\u2208[q\u22121] , where each Ok is a generalized quantumly corrupted codeword that is\nrealized by A with |ki in the first register.\n10\n\n\fTo complete the proof, we need to estimate the average presence avPre\nP O (Cx ) of Cx in O. For each\nindex k \u2208 [q \u2212 1], the presence of Cx in Ok is exactly PreOk (Cx ) = q \u2212m r\u2208Fqm |\u03b3k,r,Cx (r) |2 , which equals\n2\nP P k(z\u2212w*s)\nP\n|\u03b1r,s,z |2 . It thus follows that\nq \u2212m r\u2208Fq q \u2212m s z \u03c9q\n2\n\navPreO (Cx )\n\n=\n\nX 1 X 1 X\n1\nq\u22121\nqm\nqm\nm\nr\u2208Fq\n\nk\u2208[q\u22121]\n\n=\n\n\u2265\n\nj\u2208Fq\n\nj\u2208Fq\n\nk\n\nPn\n\n1\n(q \u2212 1)2\n\ni=1\n\na2i \u2265\n\nX\n\nX\n\nk\u2208[q\u22121] j\u2208Fq\n\nFor each index j \u2208 Fq , we write \u03b2j for q\nKawachi and Yamakami [13], we can derive\navPreO (Cx ) \u2265\n=\n\n1\n(q \u2212 1)2\n\nr\n\ns\n\nX\n\n2\n\n!\n\n1 X\n|\u03b1r,s,Dx (r,s)+j |2\nqm s\n\n!\n\nP\n2\n( ni=1 ai ) . We therefore obtain\n\n1\nn\n\nP P\n\u22122m\n\n\u03c9qk(z\u2212Dx (r,s)) |\u03b1r,s,Dx (r,s) |2\n\n1 X\n|\u03b1r,s,Dx (r,s)+j |2\nqm s\n\nXX X\n1\n\u03c9qk*j\n2m\n2\nq (q \u2212 1)\nr\n\nwhere the last inequality follows from\n\navPreO (Cx ) \u2265\n\nz\u2208Fq s\u2208(Fq )m\n\nXX X\n1\n\u03c9qk*j\nm\nq (q \u2212 1)\nr\nk\n\nX\n\n\uf8eb\n\n1 X\n\u03c9qk*j \uf8ed 2m\nq\n\nX\n\nr\u2208Fq s\u2208(Fq\n\n,\n\n\uf8f6\n\n2\n\n|\u03b1r,s,Dx (r,s)+j |2 \uf8f8 .\n\n|\u03b1r,s,Dx (r,s)+j |2 . Similarly to the proof of Lemma 4.5 of\n\n\u03b20 +\n\nX\n\n1\u2264j<q\n\nk\u2208[q\u22121]\n\n\uf8eb\n\uf8ed\n\nX\n\nk\u2208[q\u22121]\n2\n\nX\n1\n(q \u2212 1)\u03b20 \u2212\n\u03b2j\n2\n(q \u2212 1)\n\n=\n\n1\u2264j<q\n\nP\nP\nk*j\n=\n= 1 and\nbecause\nk\u2208Fq \u03c9q\nj\u2208Fq \u03b2j\nP\n2\n\u22122m\n|\u03b1\n|\n=\n\u03b2\n,\nit\nfollows\nthat\nq\nm\n0\nr,s,Dx (r,s)\nr,s\u2208(Fq )\n\n)m\n\n2\n\n0 for any j\n\n1\navPreO (Cx ) \u2265\n|q * PreO (Dx ) \u2212 1|2 =\n(q \u2212 1)2\n\nThis completes the proof of Lemma 10.\n\n\u0012\n\nq\nq\u22121\n\n2\n\n\uf8f6\n\n\u03c9qk*j \uf8f8 \u03b2j\n1\n2\n|q\u03b20 \u2212 1| ,\n(q \u2212 1)2\n6=\n\n0.\n\nSince PreOD (Dx )\n\n=\n\n\u00132 \u0012\n\u00132\n1\nPreOD (Dx ) \u2212\n.\nq\n\u2737\n\nNext, we give the remaining proof of Lemma 9.\nProof of Lemma 9. Recall that D = HAD(q,m) \u2299 C for a given (q m , n/m)qm -code C, provided that\n+\nd\nn/m\nP \u2208 N . Regarding this code C, a quantumly corrupted codeword OC is assumed to act as OC |ri|0i|0 i =\nz\u2208Fqm \u03b1r,z |ri|zi|\u03c6r,z i. Using this OC as an oracle, let us consider a polynomial-time quantum algorithm\nA defined below. Let e be the size of garbage qubits produced in the description of A.\nQuantum Algorithm A:\nStart with the quantum state |\u03c81 i = |ri|si|0i|0d i|0e i, where r, s \u2208 Fqm .\nChange the register order to obtain the quantum state |\u03c82 i = |ri|0i|0d i|si|0e i.\nInvoke\nOC using the first three registers and obtain the quantum state |\u03c83 i\n=\nP\ne\n\u03b1\n|ri|zi|\u03c6\ni|si|0\ni.\nr,z\nz\u2208Fqm r,z\n(4) Compute thePvalue u = z * s mod q in a reversible fashion from (s, z). We then obtain the quantum\nstate |\u03c84 i = z\u2208Fqm \u03b1r,z |ri|zi|\u03c6r,z i|si|ui|\u03c6\u2032s,z i, where |\u03c6\u2032s,z i indicates a certain garbage that might be\nproduced while reversing the computation for u on a quantum computer.\nP\n(5) Again, change the register order so that we obtain the quantum state |\u03c85 i = z\u2208Fqm \u03b1r,z |ri|si|z *\ns mod qi|zi|\u03c6r,z i|\u03c6\u2032s,z i. Finally, output |\u03c85 i.\n\n(1)\n(2)\n(3)\n\n11\n\n\fThe desired quantumly corrupted codeword O for D is defined as\nX\n\u03b1r,z |ri|si|z * s mod qi|zi|\u03c6r,z i|\u03c6\u2032s,z i\nO|ri|si|0l i|0d i|0e i =\nz\u2208Fqm\n\n=\n\nX\n\nw\u2208Fq\n\n\uf8eb\n\n|ri|si|wi \u2297 \uf8ed\n\nX\n\nz\u2208As (w)\n\n\uf8f6\n\n\u03b1r,z |zi|\u03c6\u0302r,s,z i\uf8f8 ,\n\nwhere |\u03c6\u0302r,s,z i = |\u03c6r,z i|\u03c6\u2032s,z i and As (a) = {z \u2208 Fqm | z * s \u2261 a mod q} for any a \u2208 Fq . It is obvious that O\ncan be realized by A.\nTo end the proof, we want to show that PreO (Dx ) equals 1/q + (1 \u2212 1/q)PreOC (Cx ). For convenience,\nP\nP\n2\nlet the notation Tr for each index r \u2208 Fqm express the value\nz\u2208As (Dx (r,s)) \u03b1r,z |zi|\u03c6\u0302r,s,z ik .\ns\u2208Fqm k\nP\nWith this notation, the presence PreO (Dx ) can be expressed as q \u2212m r\u2208Fqm Tr , which equals\nP\nP\n2\ns\u2208Fqm\nz\u2208As (Dx (r,s)) |\u03b1r,z | . Since the condition \"z * s \u2261 Dx (r, s) mod q\" is equivalent to the condiP\nP\ntion \"z * s \u2261 Cx (r) * s mod q,\" it follows that Tr = z\u2208Fqm s\u2208EQq (z,Cx (r)) |\u03b1r,z |2 , where EQq (a, b) = {s \u2208\nFqm | a * s \u2261 b * s mod q}. We therefore derive\nX\n|EQq (z, Cx (r))| * |\u03b1r,z |2\nTr = |EQq (Cx (r), Cx (r))| * |\u03b1r,Cx (r) |2 +\nz:z6=Cx (r)\n\nm\n\n2\n\n= q |\u03b1r,Cx (r) | + q\n= qm\n\n\u0012\n\nm\u22121\n\nX\n\nz:z6=Cx (r)\n\n|\u03b1r,z |2\n\n\u0013\n\u0013\n\u0012\n1\n1\n|\u03b1r,Cx (r) |2 ,\n+ 1\u2212\nq\nq\n\nwhere the second equality follows from the fact that |EQq (a, b)| = q m\u22121 if a 6= b. From the above relation,\nwe obtain\n\u0013 X\n\u0012\n1\n1 X\n1\n1\n|\u03b1r,Cx (r) |2\nPreO (Dx ) =\n+ m 1\u2212\nTr =\nqm\nq\nq\nq\nr\u2208Fqm\nr\u2208Fqm\n\u0013\n\u0012\n1\n1\nPreOC (Cx ).\n+ 1\u2212\n=\nq\nq\nThis completes the proof of Lemma 9.\n\n\u2737\n\nIn the end, we have finished the proof of Proposition 8.\n\n4\n\nComplexity of Generalized Reed-Solomon Codes\n\nWe have shown in Proposition 8 that the concatenated code family C GRS -H has an efficient quantum list\ndecoder if the generalized Reed-Solomon (GRS) codes are efficiently quantum list decodable. In order to\nverify Theorem 7, however, it remains to claim that the GRS-codes are efficiently quantum list decodable\nwhen the bias is relatively large. This claim will be proven as Lemma 11 in Section 4.1 in a more general\nfashion. For a much smaller bias, in contrast, there seems little hope in finding an efficient quantum list\ndecoder, based on the common belief that NP-complete problems have no efficient quantum algorithms. In\nSections 4.2\u20134.3, we will further show that the GRS-codes have natural connections to the noisy polynomial\ninterpolation problem (NPIP) of Naor and Pinkas [15] and a lattice problem, which we call the bounded\ndistance vector problem (BDVP).\n\n4.1\n\nPolynomial Reconstruction\n\nProposition 8 requires the existence of efficient quantum list decodability of a family of GRS-codes. This\nassumption can be removed for an appropriate choice of parameters. Now, we claim, in the following technical\nlemma, that the family of GRS-codes is indeed quantumly list decodable.\n\n12\n\n\fLemma 11 For any number n \u2208 N, assume that a prime\nq number q and real numbers \u03b5, \u03b4 \u2208 (0, 1) satisfy the\n\u2206\n1+q\u03b5\u2032\n\nfollowing conditions: 2 \u2264 n \u2264 q and \u03b5\u2032 + (1 \u2212 1/q \u2212 \u03b5\u2032 )\n\n< \u03b5 \u2264 1 \u2212 1/q for a certain number \u03b5\u2032 \u2208 (0, 1),\n\nwhere \u2206 = 2(n \u2212 1) log(q 2 /(1 \u2212 \u03b4)). There exists a quantum list decoder for a (q, n, q \u2212 n + 1)q -generalized\nReed-Solomon code with bias \u03b5 and confidence \u03b4 running in time polynomial in (n, q, 1/\u03b4, 1/(1 \u2212 \u03b4)).\n\nCombining Proposition 8 together with Lemma 11, Theorem 7 follows immediately. Before proving\nLemma 11, we briefly present the proof of Theorem 7, which leads to Theorem 1.\nProof of Theorem 7. Consider the concatenated code C GRS -H [n, q, \u03b8] = HAD(q,m) \u2299 GRS(M,M\u03b8,M) with\nparameters n, q, \u03b8 as specified in the theorem, where M = q m and n = mq m \u03b8. The premise of the theorem\nimplies\n#\n\u00132 \"\n\u0013r\n\u0012\n\u0012\n1\n\u03b52\n1\n\u03b52\n1\n\u2206\n<\n+ \u03b5\u2032\u2032 + 1 \u2212\n\u2212 \u03b5\u2032\u2032\n+\n= \u03b52 ,\n1\u2212\nq\nM\nM\n1 + M \u03b5\u2032\u2032\n2\n2\np\nq2 \u03b52\n1\nwhich further implies \u03b5\u2032\u2032 + (1 \u2212 1/M \u2212 \u03b5\u2032\u2032 ) \u2206/(1 + M \u03b5\u2032\u2032 ) < (q\u22121)\nNow, choose an appropriate\n2 \u2212 M .\np\nq2 \u03b52\n1\nreal number \u03b5\u2032 \u2208 (0, 1) so that (1) \u03b5\u2032\u2032 + (1 \u2212 1/M \u2212 \u03b5\u2032\u2032 ) \u2206/(1 + M \u03b5\u2032\u2032 ) < \u03b5\u2032 and (2) \u03b5\u2032 \u2264 (q\u22121)\n2 \u2212 M (or\n2\n\nequivalently, \u03b52 \u2265 (1 \u2212 1/q) (1/M + \u03b5\u2032 )).\nFrom (1), Lemma 11 guarantees the existence of a quantum list decoder A for GRS(M,M\u03b8,M) with bias\n\u2032\n\u03b5 and confidence \u03b4 running in time polynomial in (n, M, 1/\u03b4, 1/(1 \u2212 \u03b4)). With this quantum list decoder\ntogether with (2), Proposition 8 provides us with the desired quantum list decoder for C GRS -H with bias \u03b5\nand confidence \u03b4.\n\u2737\n\nTo complete the proof of Theorem 7, what still remains to deal with is the proof of Lemma 11. A direct\nuse of a polynomial reconstruction algorithm of Guruswami and Sudan [9] works well to prove this lemma.\nWe will apply this classical algorithm after collecting enough information on possible values of a target\n\"polynomial\" by a simple application of random sampling, that is, performing measurement on all oracle\nanswers.\nProof of Lemma 11. Let n be an arbitrary message length and choose four parameters q \u2208 N+ and\n\u03b5, \u03b5\u2032 , \u03b4 \u2208 (0, 1) that satisfy the premise of the lemma. For simplicity, we P\nwrite C for GRS(q,n,q) . Let O be any\nl\nquantumly corrupted codeword for Cx , having the form O|ri|si|0 i = z\u2208Fq \u03b1r,z |ri|s \u2295 zi|\u03c6r,z i for certain\ncomplex\nP numbers \u03b1r,z and certain unit-norm quantum states |\u03c6r,z i. Recall that the presence of Cx in O is\n(1/q) r\u2208Fq |\u03b1r,Cx (r) |2 . Here, we want to find all messages x satisfying the inequality PreO (Cx ) \u2265 1/q + \u03b5.\nFix a message x arbitrarily and omit script \"x\" in the following argument. Let us define two sets\nA\u03b5\u2032 = {r \u2208 Fq | |\u03b1r,Cx (r) |2 \u2265 1/q + \u03b5\u2032 } and D\u03b5\u2032 = {(r, y) \u2208 F2q | |\u03b1r,y |2 \u2265 1/q + \u03b5\u2032 }. Note that Cx passes at\nleast |A\u03b5\u2032 | points in D\u03b5\u2032 . First, we note that |D\u03b5\u2032 | \u2264 q 2 /(1 + q\u03b5\u2032 ). This upper bound is easily obtained from\n\u0012\n\u0013\nXX\nX\n1\nq2 \u2265\n|\u03b1r,y |2 \u2265\n|\u03b1r,y |2 \u2265 |D\u03b5\u2032 |\n+ \u03b5\u2032 .\nq\nr\ny\n(r,y)\u2208D\u03b5\u2032\n\nThe assumption PreO (Cx ) \u2265 1/q + \u03b5 implies\n1\n+\u03b5 \u2264\nq\n\u2264\n\n1 X\n1 X\n|\u03b1r,Cx (r) |2 +\n|\u03b1r,Cx (r) |2\nq\nq\nr\u2208A\u03b5\u2032\nr\u2208Fq \u2212A\u03b5\u2032\n\u0012\n\u0013\n|A\u03b5\u2032 | q \u2212 |A\u03b5\u2032 | 1\n+\n+ \u03b5\u2032 .\nq\nq\nq\n\nPreO (Cx ) =\n\nThis concludes that |A\u03b5\u2032 | \u2265 (1 \u2212 \u03b3\u03b5,\u03b5\u2032 )q, where \u03b3\u03b5,\u03b5\u2032 =\n2\n\n1\u22121/q\u2212\u03b5\n1\u22121/q\u2212\u03b5\u2032 .\n\n2\n\n/(1\u2212\u03b4))\nFor a later use, we set T \u2032 = q log(q\n. Now, we claim that (1 \u2212 \u03b3\u03b5,\u03b5\u2032 )2 q 2 > 2(n \u2212 1)T \u2032 . This\n1+q\u03b5\u2032\n\u2206\ninequality is equivalent to (\u03b5 \u2212 \u03b5\u2032 )2 > (1 \u2212 1/q \u2212 \u03b5\u2032 )2 1+q\u03b5\n\u2032 , which directly follows from our assumption that\np\n\u2032\n\u2032\n\u2032\n\u03b5 > \u03b5 + (1 \u2212 1/q \u2212 \u03b5 ) \u2206/(1 + q\u03b5 ), where \u2206 = 2(n \u2212 1) log(q 2 /(1 \u2212 \u03b4)). Let us consider the following\nquantum algorithm.\n\u221a P\nInitially, from the quantum state |0i|0i|0i, we generate |\u03c80 i = (1/ q) r\u2208Fq |ri|0i|0i. By making a query\nP\nP\n\u221a\nto oracle O, we generate |\u03c81 i = (1/ q) r y \u03b1r,y |ri|yi|\u03c6y i. Next, we measure the first two registers and\nobtain (r, y) with probability |\u03b1r,y |2 /q. Let us repeat these steps exactly T times, where T is the minimal\n\n13\n\n\fpositive integer satisfying 2T \u2032 \u2265 T \u2265 T \u2032 . Since T \u2265 T \u2032 , we obtain\nT \u2265\n\nlog (1 + q\u03b5\u2032 ) (1 \u2212 \u03b4) /q 2\nq 2 log(q 2 /(1 \u2212 \u03b4))\n\u2265\n,\n1 + q\u03b5\u2032\nlog (1 \u2212 1/q 2 \u2212 \u03b5\u2032 /q)\n\n(2)\n\nwhere we use inequalities: log(1 \u2212 z) < \u2212z and 1 + q\u03b5\u2032 \u2265 1. After receiving each answer from O, we perform\na measurement in the computational basis over Fq \u00d7 Fq and store a point (r, y) that is a result of this\nmeasurement.\nLet S\u03b5\u2032 indicate the set of all the obtained points. Clearly, |S\u03b5\u2032 | \u2264 T holds. Note that, with probability\n(1 \u2212 |\u03b1r,y |2 /q)T , each point (r, y) is never observed during the procedure. Hence, the probability P of\nobtaining all (r, y)'s in D\u03b5\u2032 is lower-bounded by\nP \u22651\u2212\n\nX\n\n(r,y)\u2208D\u03b5\u2032\n\n\u0012\n\u0013T\n\u0013T\n\u0012\n|\u03b1r,y |2\n1\n\u03b5\u2032\nq2\n1\u2212\n\u2265 \u03b4,\n* 1\u2212 2 \u2212\n\u22651\u2212\nq\n1 + q\u03b5\u2032\nq\nq\n\nwhere the last inequality follows from Eq.(2). Therefore, the probability that S\u03b5\u2032 includes D\u03b5\u2032 is at least \u03b4.\nLastly, we wish to find all univariate polynomials p of degree at most n \u2212 1 that lie on at least |A\u03b5\u2032 | points\nin S\u03b5\u2032 . For this purpose, we run the well-known Guruswami-Sudan polynomial reconstruction algorithm.\nEarlier, Guruswami and Sudan [9] described a deterministic algorithm A that solves in time polynomial in\n(m, log q) the following polynomial reconstruction problem.\nPolynomial Reconstruction Problem\n\u25e6 Input: three positive integers m\u2032 , n\u2032 , t and m\u2032 points {(xi , yi )}i\u2208[m\u2032 ] \u2286 Fq \u00d7 Fq .\n\u25e6 Output:\nall univariate polynomials p of degree at most n\u2032 that lie on at least t points, provided that\n\u221a\n\u2032\n\u2032\nt> mn.\nTo apply the Guruswami-Sudan algorithmpto our case, letting n\u2032 = n \u2212 1, m\u2032 = |S\u03b5\u2032 |, and t = |A\u03b5\u2032 |, we\nshould demand the requirement that |A\u03b5\u2032 | > (n \u2212 1)|S\u03b5\u2032 |. This requirement is met because the choice of\nour parameters \u03b5 and \u03b5\u2032 implies that\np\np\np\n|A\u03b5\u2032 | \u2265 (1 \u2212 \u03b3\u03b5,\u03b5\u2032 )q > 2(n \u2212 1)T \u2032 > (n \u2212 1)T \u2265 (n \u2212 1)|S\u03b5\u2032 |.\n\nTherefore, the algorithm A correctly produces a list that includes all the polynomials p of degree at most\nn \u2212 1 satisfying |\u03b1r,p(r) |2 \u2265 1/q + \u03b5\u2032 for at least |A\u03b5\u2032 | indices r. Concerning the efficiency of the algorithm, we\nnote that the running time of A is bounded by a polynomial in (q, n). As a consequence, the list produced\nby A includes all messages x for which PreO (Cx ) \u2265 1/q + \u03b5.\nSince A is deterministic, we can execute it quantumly as well. In the end, we produce the desired list\nwith probability at least \u03b4 in time polynomial in (n, q, 1/\u03b4, 1/(1 \u2212 \u03b4)).\n\u2737\n\nDue to the random sampling of quantum states necessary to apply for the Guruswami-Sudan algorithm,\nthe total number of oracle queries made by the quantum algorithm described in the above proof of Lemma\n11 is at most T , guaranteeing the confidence \u03b4. An important open question is whether the same confidence\n\u03b4 can be achieved with a significantly fewer (e.g., a constant number of) queries.\nTo apply the Guruswami-Sudan algorithm, we have required the bias \u03b5 in the proof of Lemma 11 to be\nrelatively large. One may wonder whether, even if the bias is relatively small, there is another way to listdecode the generalized Reed-Solomon codes from a quantumly corrupted codeword. In the next proposition,\nwe will show that any efficient quantum list decoder for the generalized Reed-Solomon codes with small\nbias and high confidence can be used to solve all NP-problems efficiently on a quantum computer with high\nsuccess probability, leading to NP \u2286 BQP.\nProposition 12 Let t(n) be any function from N to N with t(n) \u2265 n for all n \u2208 N. If, for any arbitrary\nbias \u03b5(n), there exists a quantum list decoder A for the generalized Reed-Solomon codes with bias \u03b5(n) and\nconfidence 2/3 running in t(n) time, then every NP-problem can be solved in nO(1) t(n) time by a certain\nquantum algorithm with success probability at least 2/3. In particular, if A runs in polynomial time, then\nNP \u2286 BQP holds.\nProof. We want to give a polynomial-time reduction from a certain suitable NP-complete problem to an\n\u03b5-QLDP for the GRS-code with respect to a specific quantumly corrupted codeword, where \u03b5 will be defined\nlater. As a target NP-complete problem, we choose the following restricted form of the interpolation problem\ndiscussed by Goldreich, Rubinfeld, and Sudan [7].\nConstrained Interpolation Problem (CIP)\n14\n\n\f\u25e6 Input: three numbers d, e, m \u2208 N+ , a prime number q, and a set A = {(x1 , y1 ), . . . , (xm , ym )} \u2286 Fq \u00d7Fq\nof m points, expressed appropriately in binary.\n\u25e6 Requirement: dA (xi ) = 2 for any index i \u2208 [m], where dA (x) = |{y | (x, y) \u2208 A}|.\n\u25e6 Question: is there any univariate polynomial p over Fq of degree at most d such that p(xi ) = yi for\nat least e different i's?\nNote that, when e = 1, we always take a polynomial p satisfying p(x1 ) = y1 . Therefore, in what follows,\nwe assume that e \u2265 2.\nThe problem CIP is clearly in NP and it can be proven to be NP-hard.\u00b6 As a starting point, let\nd, e, m \u2208 N+ , let q be a prime number, and let A = {(x1 , y1 ), . . . , (xm , ym )} \u2286 Fq \u00d7 Fq as an input to\nPd+1\nthe CIP. Let l = (m \u2212 1)/2. Any polynomial p(r) = i=1 zi ri\u22121 for any r can be viewed as a codeword\nGRS(l,d+1,q)\n, where z = z1 z2 * * * zd+1 . For convenience, since dA (xi ) = 2 for all i's, the set D = {x1 , . . . , xm }\nz\nof code locators has cardinality exactly l. Without loss of generality, we assume that l + 1 \u2264 q.\nBased on the set A, we wish top\nconstruct a quantumly corrupted codeword O. For any point (x, y) in\nFq \u00d7 Fq , if (x, y) \u2208P\nA, let \u03b1x,y = 1/ dA (x); otherwise, let \u03b1x,y = 0. The amplitude set {\u03b1x,y }x,y\u2208Fq defines\nO as O|xi|si|ti = y\u2208Fq \u03b1x,y |xi|y \u2295 si|ti. Define \u03b5 = 1/q \u2212 e/2l.\nIt is not difficult to show that, for any polynomial p of degree d, p passes on at least e points in A if and\nonly if the presence of p (seen as a codeword) in O satisfies the inequalities:\nPreO (GRS(l,d+1,q)\n)=\nz\n\ne\n1 X\ne\n1\n1X1\n=\n= + \u03b5,\n|\u03b1x,p(x) |2 \u2265\n|D|\nl i=1 2\n2l\nq\nx\u2208D\n\nprovided that p is identical with GRS(l,d+1,q)\n. Therefore, solving the CIP can be reduced to solving the \u03b5z\nQLDP for the GRS-code {GRS(l,d+1,q) }l,d,q with respect to O. Moreover, it takes only quantum polynomialtime to realize O from the set A (which is given as an input). Applying a t(n)-time quantum list decoder\nfor the \u03b5-QLDP with confidence 2/3, we can obtain a valid list of polynomials p. Obviously, the size of the\nobtained list is at most t(n). Since the list may contain certain illegitimate polynomials, we need to check\nthat every candidate p passes on at least e different points in A. If the list contains a legitimate polynomial,\nwe output \"YES\"; otherwise, output \"NO.\" This quantum algorithm solves the CIP with success probability\nat least 2/3.\nIf this quantum algorithm runs in polynomial time, we can solve efficiently the CIP with high probability,\nleading to the inclusion NP \u2286 BQP because the CIP is NP-complete.\n\u2737\nDespite the power of quantum computation, it seems unlikely that polynomial-time quantum algorithms\ncan solve all the NP-problems with high success probability. Proposition 12 thus leaves little hope for\nfinding a \"polynomial-time\" quantum list decoder for the GRS-codes with a smaller bias. However, it seems\na challenging task to determine the exact threshold of such a bias for efficient quantum list decoders to exist.\n\n4.2\n\nNoisy Polynomial Interpolation Problem\n\nAs Proposition 12 indicates, for the generalized Reed-Solomon (GRS) codes, we may not be able to obtain a\npolynomial-time quantum list decoder having extremely small bias; however, it is still meaningful to study,\nfor example, subexponential-time quantum list decoders with relatively small bias for the GRS-codes and\nthus to seek their applications to the field of computational cryptography. Here, we wish to propose one of\nthose possible applications.\nEarlier, Naor and Pinkas [15] studied the noisy polynomial interpolation problem (NPIP) as an intractable\nassumption for a new cryptographic primitive, called oblivious polynomial evaluation. We restate their noisy\ninterpolation problem as a promise problem of finding a unique polynomial passing through exactly one\npoint from each given set.\nNoisy Polynomial Interpolation Problem (NPIP)\n\u25e6 Input: three numbers k, m, n \u2208 N+ , a prime number q, n distinct points {x1 , x2 , . . . , xn } in Fq , and n\nsets S1 , . . . , Sn , each of which consists of exactly m elements from Fq , where k + 1 \u2264 n \u2264 q.\n\u25e6 Promise: there exists a unique polynomial p of degree at most k such that, for each index i \u2208 [n],\nthere exists exactly one element y \u2208 Si satisfying p(xi ) = y.\n\u25e6 Output: the hidden polynomial p.\n\u00b6 This\n\nfact is observed by examining the reduction constructed by Goldreich, Rubinfeld, and Sudan [7] from the subset sum\nproblem, which is known to be NP-complete.\n\n15\n\n\fDisappointingly, no polynomial-time algorithm has been so far known to solve this promise problem\nNPIP. Apparent similarity exists between this problem and the GRS-codes (see, e.g., Roth [18]) and, in the\nfollowing proposition, this similarity helps us solve the NPIP using suitable quantum list decoders for the\nGRS-codes if such list decoders are actually built.\nProposition 13 If, for any bias parameter \u03b5(n), there exists a quantum list-decoder for any GRS(n,k+1,q) code with bias \u03b5(n) and confidence 2/3, then there exists a quantum algorithm that solves the NPIP with\nprobability at least 2/3.\nProof. Take n distinct elements X = {x1 , . . . , xn } \u2286 Fq and n sets S1 , . . . , Sn of m elements each. Let us\nassume that the promise of the NPIP holds for a unique polynomial, say,Sp\u2217 of degree at most k. Note that\nk, m, n \u2264 q. We set the bias parameter \u03b5 to be 1/m \u2212 1/q, and let S be i\u2208[n] Si .\n\nHere, we define the \u03b5-QLDP for thePGRS(n,k+1,q) -code with respect to a quantumly corrupted codeword\nO, which is defined by O|xi i|0i = \u221a1m y\u2208S \u03b1xi ,y |xi i|yi for each index i \u2208 [n], where \u03b1xi ,y = 1 if y \u2208 Si and\n0 otherwise. We first claim that the unique polynomial p\u2217 satisfies the condition PreO (p\u2217 ) \u2265 1/q + \u03b5. Since\n|X| = n, it follows that\n\u0013\n\u0012\n1\n1 X\n1\n1\n1\n1 X 1\n\u2217\n2\n\u2265 + \u03b5.\nPreO (p ) =\n= +\n\u2212\n|\u03b1x,p\u2217 (x) | =\n|X|\nn\nm\nq\nm q\nq\nx\u2208X\n\nx\u2208X\n\nHence, p\u2217 has codeword presence at least 1/q + \u03b5.\nThe assumption of the proposition guarantees the existence of a quantum list decoder A that solves\nthe \u03b5-QLDP with confidence 2/3. To realize O from the given inputs (x1 , . . . , xn , S1 , . . . , Sn ) of the NPIP,\nwe generate the quantum\nstate O|xi i|si by choosing y in S uniformly at random and then generating the\n\u221a\namplitude \u03b1xi ,y / m. For the NPIP, let us consider the following quantum algorithm.\nTaking (k, m, n, q), (x1 , . . . , xn ) and S1 , . . . , Sn as input instance, run the quantum list decoder\nA using O as an oracle. We then obtain a list of polynomials p that satisfy PreO (p) \u2265 1/q + \u03b5.\nSince the hidden polynomial p\u2217 must be in the list, we deterministically check, through this list,\nwhether each polynomial passes exactly one point from each set Si . The uniqueness of p\u2217 ensures\nthat this algorithm eventually finds p\u2217 .\nIt is not difficult to show that the above quantum algorithm solves the NPIP with success probability at\nleast 2/3 because A has confidence 2/3.\n\u2737\n\n4.3\n\nBounded Distance Vector Problem\n\nThe previous section has sought out an application of a quantum list decoder for the generalized ReedSolomon (GRS) codes. Here, we further intend to explore its relevant computational problems. Let us\nrecall that codewords (viewed as functions) of the GRS codes can be identified with polynomials. Since\npolynomials are closely related to certain types of lattice problems, by exploiting this relationship, we will\nintroduce a specific lattice problem, which we preferably call the bounded distance vector problem (BDVP).\nNext, we will show that any quantum algorithm solving this BDVP with high probability yields, for any bias\n\u03b5, a quantum list decoder for GRS-codes with bias \u03b5 and relatively high confidence. The problem BDVP is\nformally described as follows.\nBounded Distance Vector Problem (BDVP)\n\u25e6 Input: a number n \u2208 N+ , m basis vectors b1 , b2 , . . . , bm \u2208 Zn , and a radius \u03be \u2208 Q\u22650 .\n\u25e6 ImplicitPInput: an oracle that, given a vector v \u2208 Zn , returns the square of the weighted norm,\nn\n2 2\nkvk2 =\nj\u2208[n] \u03bbj vj , where \u03bb = (\u03bbj )j \u2208 [0, 1] is a predetermined (but hidden) weight vector and\nv = (v1 , . . . , vn ).\n\u25e6 Output: a list that contains all vectors v in the lattice L spanned by {b1 , b2 , . . . , bm } for which\nkvk2 \u2264 \u03be holds.\nIn the next proposition, we show the aforementioned relationship between the BDVP and quantum list\ndecoding.\nProposition 14 If there exists a quantum algorithm that solves the BDVP with probability at least 2/3,\nthen, for any positive bias \u03b5, there exists a quantum list decoder for the family of generalized Reed-Solomon\ncodes with bias \u03b5 and confidence 2/3.\n16\n\n\fProof.\nA basic idea of using Lagrange's interpolation formulas in the following argument comes from\nBleichenbacher and Nguyen [3]. To prove the proposition, it suffices to construct a quantum \"reduction\" to\nthe BDVP from the \u03b5-QLDP for the generalized Reed-Solomon code GRS(M,n,q) , where \u03b5 is any positive bias.\nLet us assume that the BDVP with a hidden weight vector is quantumly solvable with success probability\nat least 2/3. We start with an arbitrary input instance given to the \u03b5-QLDP for GRS(M,n,q) .\nFix a message length n arbitrarily. Let \u03b5 be any positive bias and assume, without loss of generality,\nthat \u03b5 is a rational number. Fix a set DM = {x1 , x2 , . . . , xM } of M distinct code locators in Fq and\nexpress the Cartesian product DM \u00d7 Fq as {(xi , zj ) | i \u2208 [M ], j \u2208 [q]}. Let O denote any quantumly\nP\ncorrupted codeword O for GRS(M,n,q) and assume that O|xi i|si|0i =\nj\u2208[q] \u03b1i,j |xi i|s \u2295 zj i|\u03c6i,j i, where\n|\u03c6i,j i is a certain unit-norm quantum state. Let a = (a1 , a2 , . . . , an ) \u2208 (Fq )n be any hidden message and let\nP\n, which is a polynomial over Fq of degree at\npa (x) = k\u2208[n] ak xk\u22121 (mod q) denote its codeword GRS(M,n,q)\na\nP\n1\n2\nmost n \u2212 1. Now, assume that PreO (pa ) = M\n|\u03b1\n|\n\u2265 1/q + \u03b5.\nxi ,pa (xi )\ni\u2208[M]\nNext, we will define an instance to the BDVP. Firstly, we define our radius \u03be \u2208 Q as M (1 \u2212 1/q \u2212 \u03b5).\nSecondly, we define a lattice L spanned by certain basis vectors {b1 , bQ\n2 , . . . , bm } as follows. The (special)\nx\u2212x\nLagrange interpolation polynomials corresponding to DM are Li (x) = j\u2208[M]\u2212{i} xi \u2212xjj in Fq [x], which are\npolynomials of degree M \u2212 1, for each index i \u2208 [M ]. Every polynomial Li (x) satisfies\nP the following property:\nLi (xi ) = 1 and Li (xj ) = 0 if j 6= i. Here, we assume that Li (x) is of the form k\u2208[M] cik xk\u22121 for certain\nconstants cik in Fq . Note that pa satisfies the Lagrange's interpolation formula:\nX X (a)\nX\n\u03b4ij zj Li (x)\npa (xi )Li (x) =\npa (x) =\ni\u2208[M] j\u2208[q]\n\ni\u2208[M]\n\n=\n\nX\n\nk\u2208[M]\n(a)\n\n\uf8eb\n\uf8ed\n\nX X\n\ni\u2208[M] j\u2208[q]\n\n\uf8f6\n\n(a)\n\u03b4ij zj cik \uf8f8 xk\u22121 ,\n\nwhere \u03b4ij = 1 if pa (xi ) = zj and 0 otherwise. Obviously, for each fixed pair i and a, it holds that\nP\n(a)\n(a)\n(a)\n= (\u03b4ij )ij \u2208 ZqM becomes our target vector in the desired lattice L (which\nj\u2208[q] \u03b4ij = 1. The vector \u03b4\nwill be defined below).\nWe\nonly vectors \u0011 d \u0011 =\n(dij )ij\n\u2208\nZqM\nsatisfying the\ncondition\n\u0010P consider\n\u0010P\nP\nP\nP\nk\u22121\n\u2264 n, which is equivalent to i\u2208[M] j\u2208[q] dij zj cik = 0 (mod q)\ndeg\nk\u2208[M]\ni\u2208[M]\nj\u2208[q] dij zj cik x\nPq\nPq\nfor every index k \u2208 [n + 1, q]Z . Moreover, d should satisfy that j=1 dij = j=1 di\u2032 j for all pairs (i, i\u2032 ). At\nlast, the lattice L is defined as the collection of all vectors d = (dij )ij \u2208 ZqM such that\nP\nP\ndij = j\u2208[q] di\u2032 j (mod q) for all pairs i, i\u2032 \u2208 [M ]; and\n1.\nPj\u2208[q] P\n2.\ni\u2208[M]\nj\u2208[q] dij zj cik = 0 (mod q) for all k \u2208 [n + 1, M ]Z .\n\nIt is not difficult to show that L forms a lattice. It is important to note that the target vector \u03b4 (a) belongs\nto L. From the definition of L, a suitable set of basis vectors {b1 , b2 , . . . , bm } for L can be found easily (see,\ne.g., Bleichenbacher and Nguyen [3]).\nFinally, we introduce an oracle O\u2032 for the BDVP. To formulate this O\u2032 , it suffices to define\np its associated weight vector \u03bb = (\u03bbij )ij \u2208 [0, 1]qM . For each point (xi , zj ) \u2208 DM \u00d7 Fq , let \u03bbi,j = 1 \u2212 |\u03b1xi ,zj |2 .\nqP\n2 2\nThe weighted norm kdk of a vector d = (dij )ij \u2208 L is thus calculated as kdk =\ni,j dij \u03bbij =\nqP\n(a)\n2\n2\nequals\ni,j dij (1 \u2212 |\u03b1xi ,zj | ). Therefore, the square of the weighted norm of \u03b4\nk\u03b4 (a) k2\n\n=\n\nX\nX X \u0010 (a) \u00112\n\u0001\n|\u03b1xi ,pa (xi ) |2\n1 \u2212 |\u03b1xi ,pa (xi ) |2 = M \u2212\n\u03b4ij\ni\u2208[M]\n\ni\u2208[M] j\u2208[q]\n\n=\n\nM (1 \u2212 PreO (pa )) .\n\nSince \u03be = M (1 \u2212 1/q \u2212 \u03b5), it follows that k\u03b4 (a) k2 \u2264 \u03be iff PreO (pa ) \u2265 1/q + \u03b5.\nTo solve the \u03b5-QLDP for GRS(M,n,q) with respect to O, we first compute the set of basis vectors b1 , . . . , bm\nand the radius \u03be as defined above. We then solve the BDVP using the weight vector (given by the oracle\nO\u2032 ) with success probability at least 2/3. Let v1 , . . . , vk be the resulted list of vectors in L. For each vi , find\nai \u2208 (Fq )n such that vi = \u03b4 (ai ) by solving a set of linear equations. These ai 's form a list that contains all\nmessages satisfying PreO (pa ) \u2265 1/q + \u03b5. Moreover, this list can be obtained with probability at least 2/3.\nIt is not difficult to show that the above-described quantum algorithm indeed solves the \u03b5-QLDP for\nGRS(M,n,q) . This completes the proof of Proposition 14.\n\u2737\n\n17\n\n\f5\n\nAn Application to Quantum Search Problems\n\nTheorem 1 has given an efficiently quantumly list-decodable code family C over a fixed code alphabet that\nhas polynomially small code rate; in addition, C is also efficiently classically list decodable. This fulfills our\nprimary goal of this paper. As the next goal, we will seek an application of such an interesting code family\nto computational complexity theory. Of all possible applications, we will choose an issue on approximate\nsolvability of quantum search problems. For ease of description, we use the notation ProbM [M (x) = b]\nto denote the probability that observing the final configuration of a quantum algorithm M starting with\ninput x results in b. Analogous to NP-search problems, an NBQP-search problem P is formally defined as a\ntriplet (\u03a3\u2217 , M, p), where M is a polynomial-time quantum algorithm taking inputs from \u03a3\u2217 \u00d7 \u03a3\u2217 and p is a\npolynomial, together with the requirement that, for every x \u2208 \u03a3\u2217 and every witness y \u2208 \u03a3p(|x|) , there exists\na bit b such that ProbM [M (x, y) = b] \u2265 2/3. For each x \u2208 \u03a3\u2217 , let Sx,M = {y \u2208 \u03a3p(|x|) | ProbM [M (x, y) =\n1] \u2265 2/3} be the set of solutions of x. For simplicity, we fix our message alphabet \u03a3 to be {0, 1} throughout\nthis section.\nNBQP-Search Problem\n\u25e6 input: a (binary) string x of length n;\n\u25e6 output: a solution y \u2208 Sx,M for x if Sx 6= \u00d8. Otherwise, output \u22a5 (a special symbol not in \u03a3).\n\nDefine LM = {x | Sx,M 6= \u00d8}. A solution function f for the NBQP-search problem P = (\u03a3\u2217 , M, p)\nsatisfies that (i) for every x \u2208 LM , f (x) belongs to Sx,M and (ii) for every x 6\u2208 LM , f (x) = \u22a5. We also\nintroduce a class NBQP of decision problems as follows: a language L belongs to NBQP if and only if there\nexist a polynomial-time quantum algorithm M and a polynomial p for which (\u03a3\u2217 , M, p) is an NBQP-search\nproblem and L = LM .\nWe want to show that a certain NBQP-search problem cannot be solved even \"approximately\" if BQP 6=\nNBQP.\nProposition 15 Assuming that BQP 6= NBQP, for every positive polynomial triplet (p, p\u2032 , p\u2032\u2032 ) with p\u2032 (n) >\np(n) for all numbers n \u2208 N, there exists an NBQP-search problem P = (\u03a3\u2217 , M, p) that satisfies the following:\nfor any solution function f for P, no polynomial-time quantum algorithm B finds strings y, on each input\n2p(n)\nx \u2208 LM of length n, with probability at least 1 \u2212 p\u2032 (n)(p(n)+2)\nsuch that the relative distance \u2206(y, f (x)) is at\nmost 1/2 \u2212 1/p(n); on every input x 6\u2208 LM , B outputs \u22a5 with probability at least 1/2 + 1/p\u2032\u2032 (n).\nThis proposition roughly implies that solving NBQP-search problems on average leads to solving them\nin worst case. The proof of the proposition requires the following technical lemma, which gives a method of\ncomputing solution functions. Recall from Section 2.4 the notation (f (x))i .\nLemma 16 Let s be any positive polynomial with s(n) \u2265 6 for every n \u2208 N. The following two statements\nare logically equivalent.\n1. For every NBQP-search problem P = (\u03a3\u2217 , M, p), there exist its solution function g and a polynomialtime quantum algorithm A such that (i) for every x \u2208 LM , ProbA,i [A(x, 1i ) = (g(x))i ] \u2265 1/2 + 1/s(|x|)\nand (ii) for every x 6\u2208 LM , ProbA,i [A(x, 1i ) = 0] \u2265 1/2 + 1/s(|x|), where \"i\" is a random variable\nuniformly distributed over [p(n)].\n2. For every NBQP-search problem, there exist its solution function f and a polynomial-time quantum\nalgorithm B such that, for every x \u2208 \u03a3\u2217 , ProbB [B(x) = f (x)] \u2265 2/3.\nWith the help of the above lemma, we give the proof of Proposition 15.\nProof of Proposition 15. We show the proposition by contradiction. First of all, we assume that\nBQP 6= NBQP. Toward a contradiction, we assume that there exist a positive polynomial triplet (p, p\u2032 , p\u2032\u2032 )\nsatisfying p\u2032 (n) > p(n) for every n \u2208 N that meet the following requirement: for any choice of NBQPsearch problem P = (\u03a3\u2217 , M, p), there are a solution function g for P and a polynomial-time quantum\n2p(n)\na string y\nalgorithm B for which (i) on each input x \u2208 LM , B finds with probability at least 1 \u2212 p\u2032 (n)(p(n)+2)\nsatisfying \u2206(y, g(x)) \u2264 1/2 \u2212 1/p(n) and (ii) on every input x 6\u2208 LM , B outputs \u22a5 with probability at least\n1/2 + 1/p\u2032\u2032 (n). Let us fix a polynomial s satisfying that s(n) \u2265 max{6, p\u2032\u2032 (n), p\u2032 (n)p(n)/(p\u2032 (n) \u2212 p(n))} for\nall numbers n \u2208 N. Notice that LM belongs to NBQP.\nWe wish to compute (g(x))i from (x, 1i ) using B so that we obtain Lemma 16(1). Let us consider the\nfollowing algorithm A: on input (x, 1i ), run the quantum algorithm B on input x and then output the ith\nbit of its outcome y if y 6= \u22a5, and output 0 otherwise.\n18\n\n\fLet x be an arbitrary string of length n. If x \u2208 LM , then the average probability of A producing (g(x))i\ncorrectly over all i's is lower-bounded by\n\u0013\u0012\n\u0013\n\u0012\n2p(n)\ni\n1 \u2212 max{\u2206(y, g(x))}\nProbA,i [A(x, 1 ) = (g(x))i ] \u2265\n1\u2212 \u2032\ny\np (n)(p(n) + 2)\n\u0012\n\u0013\u0012\n\u0012\n\u0013\u0013\n2p(n)\n1\n1\n\u2265\n1\u2212 \u2032\n1\u2212\n\u2212\np (n)(p(n) + 2)\n2 p(n)\n1\n1\n1\n1\n1\n+\n\u2212 \u2032\n\u2265\n+\n,\n=\n2 p(n) p (n)\n2 s(n)\nwhere the maximization is taken over all strings y produced by B that satisfy \u2206(y, g(x)) \u2264 1/2 \u2212 1/p(n). If\nx 6\u2208 LM , then it follows that ProbA,i [A(x, 1i ) = 0] = ProbB [B(x) = \u22a5] \u2265 1/2+1/p\u2032\u2032(n) \u2265 1/2+1/s(n). Since\nP is arbitrary, the statement of Lemma 16(1) holds. Lemma 16(2) then provides us with a polynomial-time\nquantum algorithm that computes a certain solution function f correctly with probability at least 2/3. Since\nLM = {x | f (x) \u2208 \u03a3\u2217 } holds, LM must be recognized with probability at least 2/3 on a quantum computer\nin polynomial time; thus, LM belongs to BQP. As a result, we conclude that NBQP is included in BQP, a\ncontradiction against our assumption that BQP 6= NBQP.\n\u2737\nFinally, we present the proof of Lemma 16, in which we extensively utilize an efficiently quantumly and\nclassically list-decodable code family given in Theorem 1.\nProof of Lemma 16. Let s be any positive polynomial with s(n) \u2265 6 for every n \u2208 N. Because we\nconsider only sufficiently large lengths n, we can assume without loss of generality that, for a certain fixed\nconstant k \u2265 1, s(n) = nk holds for all numbers n \u2265 6. By Theorem 1, there are a polynomial-time\ncomputable function t and a (t(n), n)2 -code family C that has a polynomial-time quantum list decoder D,\nwith bias 1/s(n) and confidence 2/3, producing a list of message candidates, where n is a message length.\nLet q denote a positive polynomial that bounds the sizes of any valid list produced by D. For convenience,\nwe also assume that t(n) \u2265 n for all numbers n \u2208 N. Moreover, we write D for a polynomial-time classical\nlist decoder for C. Note that, for each y, Cy denotes the codeword, to which y is encoded, of block length\nt(|y|). For the sake of convenience, in this proof, we also identify this codeword Cy (defined as a function in\nSection 2.1) as a t(n)-letter string Cy (0)Cy (1) * * * Cy (t(n) \u2212 1).\nThe implication (2) \u21d2 (1) in the lemma is trivial, since 1/2 + 1/s(n) \u2264 2/3 and, if we can computer\nf (x) with high probability, then we can compute its ith bit (f (x))i or the symbol \u22a5 with success probability\nat least 2/3. Hereafter, assuming (1), we intend to show (2). Let P = (\u03a3\u2217 , M, p) be any NBQP-search\nproblem. To make our proof simple, we assume that p(n) \u2265 n for all numbers n \u2208 N. First, we reduce\nthe error probability of the quantum algorithm M to be exponentially small (without changing the witness\nsize). This step can be done by a standard technique of majority voting among polynomially many runs of\nthe original quantum algorithm. To be more precise, there exists a polynomial-time quantum algorithm M \u2032 ,\ndepending only on (p, r, M ), that satisfies the following two conditions:\n1. for every x \u2208 LM and every y \u2208 Sx,M , ProbM \u2032 [M \u2032 (x, y) = 1] \u2265 1 \u2212 2\u2212r(|x|); and\n2. for any other pair (x, y) with y \u2208 \u03a3p(|x|) , ProbM \u2032 [M \u2032 (x, y) = 0] \u2265 1 \u2212 2\u2212r(|x|),\n\nwhere r(n) = q(p(n)) + 3. Notice that LM \u2032 coincides with LM .\nLet us consider a quantum search problem P \u2032 = (\u03a3\u2217 , N, p) defined by the following quantum algorithm\nN.\nOn input (x, z) with n = |x|, if |z| 6= t(p(n)), then reject the input immediately. Otherwise, run\nthe classical list decoder D in polynomial time using z as a classically corrupted codeword (or\na received word) to produce with probability at least 5/6 a list T of message candidates for C.\nCheck deterministically whether z = Cy holds for a certain string y in T . If there is no such y,\nreject the input. On the contrary, if z = Cy , then run M \u2032 on the input (x, y) and outputs its\noutcome.\nFirst, we claim that P \u2032 is indeed an NBQP-search problem. Fix an arbitrary n \u2208 N, take any x \u2208 \u03a3n ,\nand consider the case in which x \u2208 LM . Since there exists a witness y \u2208 \u03a3p(n) for x, y should be included\nin the list T . \u0001Hence, its corresponding codeword z = Cy forces N to accept (x, z) with probability at least\n5\n\u2212r(|x|)\n\u2265 2/3, because r(n) \u2265 3. For the other case where x 6\u2208 LM , let z be any string in \u03a3t(p(n)) . If\n6 1\u22122\nz 6= Cy for all y \u2208 T , then N rejects (x, z) with probability at least 5/6. By contrast, if z = Cy holds for a\ncertain y \u2208 T , then N accepts (x, z) with probability \u2264 65 * 2\u2212r(|x|) \u2264 1/3. Therefore, P \u2032 is an NBQP-search\nproblem.\n19\n\n\fAgain, applying the majority vote technique, we can reduce the error probability of N down to 2\u2212r(n) .\nAbusing the notation, we use the same notation N to denote this new algorithm. For our NBQP-search\nproblem P \u2032 , the statement (1) gives a solution function g and a polynomial-time quantum algorithm A for\nwhich ProbA,i [A(x, 1i ) = (g(x))i ] \u2265 1/2 + 1/s(n) for every x \u2208 LM \u2229 \u03a3n , and ProbA,i [A(x, 1i ) = 0] \u2265\n1/2 + 1/s(n) for every x \u2208 \u03a3n \u2212 LM . Now, assume that the final quantum state A|x, 1i i has the form\nA|x, 1i i = \u03b1x,i,0 |ii|0i|\u03c6x,0 i + \u03b1x,i,1 |ii|1i|\u03c6x,1 i\ni\nwith certain amplitudes\nk|\u03c6x,b ik = 1 for any bit b. It is obvious that Prob\nP A,i [A(x, 1 ) =2\nP {\u03b1x,i,b }x,i,b , where\n2\ni\n(g(x))i ] = (1/p(n)) i\u2208[p(n)] |\u03b1x,i,(g(x))i | for x \u2208 LM and ProbA,i [A(x, 1 ) = 0] = (1/p(n)) i\u2208[p(n)] |\u03b1x,i,0 |\nfor x 6\u2208 LM .\nWe fix an arbitrary x \u2208 LM of length n and, in the meantime, we omit script \"x.\" Let us define an oracle\nO as\nO|ii|ei|0i = \u03b1i,0 |ii|e \u2295 0i|\u03c6i,0 i + \u03b1i,1 |ii|e \u2295 1i|\u03c6i,1 i\n\nfor any e \u2208 {0, 1} and any i \u2208 [p(n)]. This oracle O is a quantumly corrupted codeword for C and obviously\nO can be realized by A. If there exists a string y satisfying Cy = g(x), then the presence of Cy in O is\ncalculated as\n1\n1 X\n1 X\n1\n|\u03b1i,Cy (i) |2 =\n|\u03b1i,(g(x))i |2 \u2265 +\nPreO (Cy ) =\n.\np(n) i\np(n) i\n2 s(n)\n\nThis makes us possible to run D using O to list-decode C.\nFinally, we define a new quantum algorithm B, based on the quantum list decoder D for C, that finds a\nwitness of the problem P \u2032 . Recall that D produces a list of size at most q(n\u2032 ) for each message length n\u2032 .\nWe assume the standard lexicographic order in \u03a3p(n) . Let us consider the following quantum algorithm B.\nOn input x (n = |x|), run D using O as an oracle to produce a list T \u2032 of at most q(p(n)) message\ncandidates (since the message size is p(n)), which includes the solution g(x) (if x \u2208 LM ) or\nthe string 0p(n) (if x 6\u2208 LM ), with probability at least 1 \u2212 2\u2212r(n) . Run N on the input (x, z)\nsequentially for all elements z \u2208 T \u2032 in order. Output the lexicographically smallest z \u2208 T \u2032 for\nwhich N (x, z) outputs 1 if any. On the contrary, if there is no such z, output \u22a5.\nLet f (x) denote the minimal string z in T \u2032 such that (i) ProbN [N (x, z) = 1] \u2265 1 \u2212 2\u2212r(n) and (ii)\nProbN [N (x, z \u2032 ) = 0] \u2265 1 \u2212 2\u2212r(n) for all z \u2032 < z in T \u2032 if any; let f (x) = \u22a5 otherwise. Since |T \u2032 | \u2264 q(p(n)),\nthe probability that B on input x of length n outputs f (x) correctly is lower-bounded by\n\u0010\n\n1 \u2212 2\u2212r(n)\n\n\u0011q(p(n))\n\n\u2265 1 \u2212 2\u2212r(n)+q(p(n))\u22121 \u2265 3/4.\n\nThis guarantees that the success probability of obtaining f (x) is at least 3/4. Since P is arbitrary, the\nstatement (2) should hold.\n\u2737\n\n6\n\nLocal Quantum List Decoding\n\nThe previous sections have dealt with a specific computational model using implicit inputs and explicit\noutputs. When the running time of a quantum list decoder is limited to sublinear, however, it becomes\nimpossible to produce a short list of messages explicitly. In such a case, it is better to allow the quantum\nlist decoder to produces a list of short \"descriptions\" of oracle quantum circuits, each of which can generate\nevery block symbol of a specific message by means of an appropriate oracle access to a given quantumly\ncorrupted codeword. We call such a model an implicit-input implicit-output model. We will discuss a realm\nof quantum list decoding on this specific model and briefly state two results on the hardness amplification\nof quantum circuits.\nLet us first introduce the notion of local quantum list decoding, analogous to the well-known notion of\nlocal list decoding.\nDefinition 17 (local quantum list decoding) Let C be any (M (n), n, d(n))q(n) -code family with a message alphabet \u03a3 (not depending on the choice of n). We say that C is locally quantum list decodable with bias\n\u03b5 and confidence \u03b4 if there exists a quantum algorithm A such that, for any message length n \u2208 N, any quantumly corrupted codeword O for C, and any message x = x1 x2 * * * xn \u2208 \u03a3n satisfying PreO (Cx ) \u2265 1/q + \u03b5(n),\nthe following two conditions hold with probability at least 3/4:\n20\n\n\f1. A(n) outputs a list of \"descriptions\" of l oracle quantum circuits D1 , D2 , . . . , Dl ; and\n2. there exists an index j \u2208 [l] such that, for every index i \u2208 [n] (expressed in binary), DjO on input i\noutputs xi with probability at least \u03b4(n)\nSimilarly to the concatenated code family C GRS -H , we can define another concatenated code family\nC RM -H using appropriate Reed-M\u00fcller codes instead of the generalized Reed-Solomon codes. Following an\nargument of Sudan, Trevisan, and Vadhan [21], we can claim that the code C RM -H is efficiently locally\nquantumly list decodable with polynomially small bias and confidence 2/3. For the proof of this claim, by\nLemma 10, it suffices for us to construct an efficient quantum list decoder for the Reed-M\u00fcller codes by\nfollowing Sudan, Trevisan, and Vadhan [21]. Such a quantum list decoder can be given by employing an\nargument similar to that of Lemma 11. Hence, we can conclude:\nProposition 18 There exists a code family of polynomially small rate and constant codeword alphabet size\nthat are efficiently locally quantum list decodable with polynomially small bias and confidence 2/3.\nAn immediate consequence of this proposition is the hardness amplification of quantum circuits, obtained\nby again following an argument of Sudan, Trevisan, and Vadhan [21].\nCorollary 19 There exists a constant d > 0 for which the following is true. Let \u03b5 \u2208 (0, 1) and let f be\nany Boolean function from {0, 1}k(n) for a certain function k(n). If no quantum circuit of size s computes\nf with success probability at least \u03b4, then there exists a Boolean function g mapping {0, 1}l(k(n)) to {0, 1}\nwith a certain function l(n) \u2208 nO(1) such that no quantum circuit C of size s\u2032 = (k(n)/\u03b5)d * s satisfies\nProbC,x [C(x) = g(x)] \u2265 1/2 + \u03b5, where C(x) denotes the random variable indicating the observed outcome\nbit of C on input x.\n\n7\n\nConcluding Remarks and Open Problems\n\nThe main theme of this paper is to show the existence of a quantumly list-decodable code family of polynomially small code rate over a fixed code alphabet and to seek its application to computational complexity\ntheory. To achieve such goals, we have considered certain codes made up of generalized Reed-Solomon (GRS)\ncodes, concatenated with the Hadamard codes, and we have proven that they are indeed efficiently quantum\nlist decodable whenever the bias of their codeword presence is relatively large. Notice that a core part of\nthe proof of this result heavily relies on a classical algorithm of Guruswami and Sudan [9] and it therefore\nrequires a relatively large number of queries. For certain types of applications, it may be desirable to make a\nfewer queries. At present, we have no answer to the question of whether there exists a quantum list decoder\nthat makes a significantly fewer queries (say, less than the degree of a hidden polynomial).\nBecause of the different formulations of classical list decoding and quantum list decoding, we cannot verify\nthat all classically list decodable codes are also quantumly list decodable. Among all codes of polynomially\nsmall rate, is there any quantum list decodable code that is not even classically list decodable?\nWhen a bias becomes arbitrary small, in contrast, we have shown that the aforementioned concatenated\ncode is unlikely to be efficiently quantumly list decodable, because the GRS codes are unlikely to have\nefficient quantum list decoders against arbitrary small bias. If we relax the running time of list decoders,\ncan we build a subexponential-time quantum list decoder for the GRS code against arbitrary bias? Another\nimportant open problem is to find useful applications of quantum list decoding to a wide range of topics in\nquantum information processing.\n\nAppendix\nIn this appendix, we will present the proofs of Propositions 2\u20133, which have left unproven in Section 2.3.\nThe proof of Proposition 2 comes from an early result of Kawachi and Yamakami [13] and the proof of\nProposition 3 closely follows an argument of Guruswami, H\u00e5stad, Sudan, and Zuckerman [8].\nWe begin with the proof of Proposition 2. Earlier, Kawachi and Yamakami [13] presented a relatively good\nupper bound on the size of a message list in terms of the value of codeword presence by employing a geometric\nmethod of Guruswami and Sudan [11], who gave a q-ary extension of the well-known Johnson bound. Let\nC be any (M (n), n, d(n))q(n) -code family with a message space \u03a3n and define Pq(n) (M (n), d(n), \u03b5(n)) as\nsupO {|{x \u2208 \u03a3n | PreO (Cx ) \u2265 \u03b5(n)}|}, where \"sup\" is taken over all quantumly corrupted codeword O for\nC. The following statement is a slight modification of Lemma 3.4 of Kawachi and Yamakami [13] and we\ntherefore omit its proof.\n21\n\n\fLemma 20 Let n be any message length. Let p\n(\u03b5(n), q(n), d(n), M (n)) satisfy the inequality \u03b5(n) >\nl(n), where l(n) equals 1/q(n) + (1 \u2212 1/q(n)) 1 \u2212 (d(n)/M (n)) (q(n)/(q(n) \u2212 1)).\nAssume that\nC isn an (M (n), n, d(n))q(n) -code family. o The value Pq(n) (M (n), d(n), \u03b5(n)) is upper-bounded by\n2\n\nd(n)(1\u22121/q(n))\nmin M (n)(q(n) \u2212 1), d(n)(1\u22121/q(n))+M(n)\u033a(n)\n, where \u033a(n) = (\u03b5(n) \u2212 1/q(n))2 \u2212 (1 \u2212 1/q(n)) . In the case\nof \u03b5(n) = l(n), it holds that Pq(n) (M (n), d(n), \u03b5(n)) \u2264 2M (n)(q(n) \u2212 1) \u2212 1.\n\nProposition 2 easily follows from Lemma 20.\nProof of Proposition 2. Consider any (M (n), n, d(n))q(n) -code family C. Since \u03bb is the relative distance\nof C, it follows that \u03bb = d(n)/M (n). For readability, we will omit the parameter \"n\" in the following\ncalculation. Let c > 0 be a constant and suppose that the upper bound of Pq (M, d, \u03b5) given in Lemma 20\ndoes not exceed anc ; that is, assuming \u03b5 > l, it holds that\nPq (M, d, \u03b5) \u2264\n\nd (1 \u2212 1/q)\n\u2264 anc .\nd (1 \u2212 1/q) + M \u033a\n\nFrom the last inequality, we immediately obtain\n\u0012\n\u00132\n\u0013\n\u0012\n\u00132\n\u0012\n1\n1\nd (1 \u2212 1/q)\n1\nM \u03b5\u2212\n+\nM\n1\n\u2212\n\u2265\n,\n\u2212\nd\n1\n\u2212\nq\nanc\nq\nq\nsince \u033a = (\u03b5 \u2212 1/q)2 \u2212 (1 \u2212 1/q)2 . The absolute value |\u03b5 \u2212 1/q| is thus lower-bounded by\n\u00132 !1/2\n\u0012\n1\nd (1 \u2212 1/q) d (1 \u2212 1/q)\n1\n.\n\u2212\n+ 1\u2212\n|\u03b5 \u2212 | \u2265\nq\nM anc\nM\nq\nAssuming that \u03b5 \u2265 1/q, we therefore conclude\n\u0013\u0012\n\u00131/2\n\u0012\nd\n1\nd\n1\n1\u2212\n.\n+ 1\u2212\n+\n\u03b5 \u2265\nq\nq\nM (1 \u2212 1/q) M anc (1 \u2212 1/q)\n\u0011\u0010\n\u0010\n1\u2212\nMoreover, in the case of \u03b5 = l, the definition of l yields \u03b5 = q1 + 1 \u2212 1q\nQLpoly\n(\u03bb)\nc\n\nd\nM(1\u22121/q)\n\n\u00111/2\n\n. Since\n\n\u2265 \u03b5, the proposition follows immediately from the relation \u03bb = d/M .\nThe second part of the proposition can be directly obtained by making c approach to the infinity.\n\n\u2737\n\nNext, we give the proof of Proposition 3.\nProof of Proposition 3. Let q be any odd prime number and fix c \u2208 N+ and R \u2208 (0, 1) arbitrarily\nto satisfy c > 2(q \u2212 1). Let n = \u230aM R\u230b and set In = [0, M \u2212 1]Z . In this proof, we consider only linear\n(M, n)q -codes. Recall from Section 2.3 the notations Vn , Wn , and E(w, \u03b5). For brevity, let \u03b5 = QUcconst (R)\nand set 0 = 0M and t = q \u2212 1.\nP\nSince Vn is composed of all vectors v = (vr,z )r\u2208In ,z\u2208Fq with vr,z \u2208 [0, t]Z and z\u2208Fq vr,z = t for every\nindex r \u2208 In , it follows that |Vn | \u2265 q M . Note that, for every v \u2208 Vn , the vector v\u0302 = (vr,z /t)r,z belongs to\nWn . Write v\u0302r,z for vr,z /t. Let the notation Vr,n denote the rth block of Vn . Note that Vr,n is related to\nFaulhaber's formula and it holds that\n\uf8f6 \uf8f6\n\uf8eb\n\uf8eb\nj2\nj3\nt\nX\nX\nX\ntq\u22121\n\uf8ed\n\uf8ed* * *\n1\uf8f8 * * * \uf8f8 =\n|Vr,n | =\n+ \u0398(tq\u22122 ).\n(q\n\u2212\n1)!\nj =0 j =0\nj\n=0\nHence, we obtain |Vn | \u2264\n\nQM\n\n|Vr,n | \u2264\n\n1\n\n2\n\nq\u22121\n\n\u0010\n\ntq\u22121\nqq\n\n\u0011M\n\n. Here, we want to introduce a new notion. For any subset\nP\nA \u2286 Vn and any function f : W \u2192 R, a restricted expectation \u011aA [f (v\u0302)] is defined to be |V1n | v\u2208Vn A(v)f (v\u0302),\nwhere A(v) is the characteristic function for A (i.e., A(v) = 1 if v \u2208 A and A(v) = 0 otherwise). For\n(c\u2212q)M\n(q\u22122)M\nsimplicity, let \u03b1 denote (1 \u2212 \u03b5) 2 q 2c . In the rest of this proof, we assume that q MR \u03b1 < 1. If we can\nfind a linear (M, n)q -code C such that, for every v \u2208 Vn , there exists a vector b \u2208 C satisfying Prev\u0302 (b) < \u03b5,\nour assumption q MR \u03b1 < 1 implies that\ni=1\n\n2\n\nc\u2212q\n\nQUcconst (R) \u2265 \u03b5 = 1 \u2212 \u03b1 (q\u22122)M q \u2212 c(q\u22122) \u2265 1 \u2212 q \u2212\n22\n\n(1+2R)c\u2212q\n(q\u22122)c\n\n.\n\n\fTherefore, the remaining task is to show the existence of a linear code C that satisfies the following condition:\nfor every v \u2208 Vn , |E(v\u0302, \u03b5) \u2229 C| \u2264 c holds under the assumption of q MR \u03b1 < 1.\nHereafter, we construct C by stages. The notation Ci expresses a code defined at Stage i \u2208 [0, n]Z and,\nin the end of our construction, we set the desired code C to be Cn . The key notion for this construction\n1\nis the potential function Si for Ci defined as Si = \u011aVn [|Vn | c |E(v\u0302,\u01eb)\u2229Ci | ] for each index i \u2208 [0, n]Z . At Stage\n0, we set b0 = 0 and C0 P\n= span{b0 }. Clearly, for every v \u2208 P\nVn , we have |E(v\u0302, \u01eb) \u2229 C0 | \u2264 1. Since\n1\n1\nv\u0302\n,\nit\nfollows\nthat\nPre\n(0)\n\u2265\n\u01eb\niff\nhv(0)|v\u0302i = M\nPrev\u0302 (0) = M\nv\u0302\nr\u2208In v\u0302r,0 \u2265 \u01ebM . Next, we consider the\nr r,0\nP\n(\u03b5)\n(\u03b5)\nset Tt = {v \u2208 Vn | r\u2208In v\u0302r,0 \u2265 \u01ebM t}. Here, we give a crude estimation to the size of Tt as follows. The\naverage value of v\u0302r,0 over all r \u2208 In is t\u03b5, and at most a half of them should be at least this value. Hence,\nq\u22122\n\n|Vr,n | possible choices of vectors v = (vr,z )z\u2208Fq . Since\neach block indexed r contains at most (q\u22121)(1\u2212\u03b5)\nt\n(\u03b5)\nthere are at most M ! possible series (vr,0 )r\u2208In and M ! \u2264 t(1/2\u2212(q\u22121)/c)M , |Tt | is upper-bounded by\n(\u03b5)\n|Tt |\n\n\u2264 M! *\n\n\u0012\n\n(q \u2212 1)(1 \u2212 \u03b5)q\u22122\n* |V0,n |\nt\n\n\u2264 (1 \u2212 \u03b5)\n(\u03b5)\n\nNote that v \u2208 Tt\ncalculate S0 as\n\n(q\u22122)M\n2\n\nq\n\nM\n2\n\nt\u2212\n\nq\u22121\nc M\n\n\u0013 12 M\n\n1\n\n|V0,n | 2 M\n\n|Vn |.\n\niff 0 \u2208 E(v\u0302, \u01eb) iff |E(v\u0302, \u01eb) \u2229 C0 | = 1. Therefore, since |Vn |1/c \u2264\n(\u03b5)\n\nS0\n\n=\n\u2264\n\n\u011aVn \u2212T (\u03b5) [1] + \u011aT (\u03b5) [|Vn |1/c ] =\nt\n\n1 + (1 \u2212 \u03b5)\n\nt\n\n(q\u22122)M\n2\n\nq\n\n(c\u2212q)M\n2c\n\n\u0010\n\ntq\u22121\nqq\n\n\u0011M/c\n\n, we can\n\n(\u03b5)\n\n|Vn \u2212 Tt | |Vn |1/c |Tt |\n+\n|Vn |\n|Vn |\n\n= 1 + \u03b1.\n\nAt Stage i \u2265 1, we choose bi uniformly at random from Vn so that bi is linearly independent of b1 , . . . , bi\u22121 .\nWe define Ci = span{Ci\u22121 \u222a {bi }}. Since bi is a random variable, so is Ci . To complete the construction,\nwe should claim that |E(v\u0302, \u01eb) \u2229 Cn | \u2264 c for any v \u2208 Vn . For this purpose, we will define a series {\u015ci }0\u2264i\u2264n\nof \"average\" values of Si 's, starting with \u015c0 = S0 . Let us consider the conditional expectation Eb\u2032 i+1 [Si+1 |\n\nSi = \u015ci ] over a random choice of bi+1 chosen uniformly at random from Vn \u2212 span{b1 , . . . , bi }. Now,\nwe define \u015ci+1 by \u015ci+1 = Eb\u2032 i+1 [Si+1 |Si = \u015ci ], and we want to show that \u015cn \u2264 6. Let the notation\n\nEbi+1 [Si+1 | Si = \u015ci ] be defined similarly, except that bi+1 is taken uniformly at random from Vn . Similarly\nto an argument of Guruswami, H\u00e5stad, Sudan, and Zuckerman [8], it holds that Ebi+1 [Si+1 | Si = \u015ci ] \u2264 (\u015ci )q .\n\nSince\n\n(1 \u2212 q\n\n|Vn |\u2212qi\n*\n|Vn |\n\u2212M+i \u22121\n\n)\n\nEb\u2032 i+1 [Si+1 | Si = \u015ci ] \u2264 Ebi+1 [Si+1 | Si = \u015ci ], we conclude that Eb\u2032 i+1 [Si+1 |Si = \u015ci ] \u2264\n\n(\u015ci )q since |Vn | \u2265 q M . Therefore, when i = n, we obtain\nn\n\nn\n(\u015cn\u22121 )q\n(\u015c0 )q\n\u015cn \u2264\n\u2264\n\u2264 2(\u015c0 )q ,\nQ\nn\u22121\nn\u2212i\n\u2212M+i\nq\n1 \u2212 q \u2212M+n\u22121\n)\ni=0 (1 \u2212 q\n\nQn\u22121\nn\u2212i\nwhere the last inequality follows from the lower bound i=0 (1 \u2212 q \u2212M+i )q\n\u2265 12 . Since q MR \u03b1 < 1, it\nfollows that\n\u0001\nn\nqn\n\u015cn \u2264 2(\u015c0 )q \u2264 2 (1 + \u03b1) \u2264 2 1 + 2q MR \u03b1 \u2264 2(1 + 2) = 6\n\nsince n \u2264 M R and (1+x)m \u2264 1+2mx for any and m \u2208 N+ and any x < 1/m. By the definition of Si , it follows\n1\n1\n\u22121\nc |E(v\u0302,\u01eb)\u2229Cn | \u2264 \u015c\nthat \u015ci \u2265 |Vn |\u22121 |Vn | c |E(v\u0302,\u03b5)\u2229Ci | for every v \u2208 Vn\u0010. In particular,\nn \u2264 6,\n\u0011 we obtain |Vn | |Vn |\nlog 6\nand we therefore conclude that |E(v\u0302, \u01eb) \u2229 Cn | \u2264 1 + log |Vn | c < c + 1, as requested.\n\u2737\n\nAcknowledgments\nThe author thanks Akinori Kawachi for a discussion on quantum cryptography and Igor Shparlinski for a\nuseful pointer to Reference (Bleichenbacher and Nguyen [3]) when the author was preparing the preliminary\nversion of this paper for the conference proceedings of CATS 2007.\n\n23\n\n\fReferences\n[1] Adcock, M., Cleve, R. (2002). A quantum Goldreich-Levin theorem with cryptographic applications. In the\nProceedings of the 19th Annual Symposium on Theoretical Aspects of Computer Science (STACS 2002). Lecture\nNotes in Computer Science, Springer, vol. 2285, pp. 323\u2013334.\n[2] Bernstein, E., Vazirani, U. (1997). Quantum complexity theory. SIAM J. Comput. 26, 1411\u20131473.\n[3] Bleichenbacher, D., Nguyen, P. Q. (2000). Noisy polynomial interpolation and noisy Chinese remaindering. In\nthe Proceedings of the International Conference on the Theory and Application of Cryptographic Techniques-\nAdvances in Cryptology (EUROCRYPT 2000), Lecture Notes in Computer Science, Springer, vol. 1807, pp.\n53\u201369.\n[4] Elias, P. List decoding for noisy channels. WESCON Convention Record, Part 2, Institute of Radio Engineers,\npp.94\u2013104.\n[5] Forney, G. D. (1966). Concatenated Codes, MIT Press, Cambridge, MA.\n[6] Goldreich, O., Levin, L. A. (1989). A hard-core predicate for all one-way functions. In the Proceedings of the\n21st Annual ACM symposium on Theory of computing (STOC'89), pp. 25\u201332.\n[7] Goldreich, O., Rubinfeld, R., Sudan, M. (1995). Learning polynomials with queries: the highly noisy case. In the\nProceedings of the 36th IEEE Symposium on Foundations of Computer Science (FOCS'95), pp. 294\u2013303.\n[8] Guruswami, V., H\u00e5stad, J., Sudan, M., Zuckerman, D. (2002). Combinatorial bounds for list decoding. IEEE\nTransactions on Information Theory 48, 1021\u20131034.\n[9] Guruswami, V., Sudan, M. (1999). Improved decoding of Reed-Solomon and algebraic-geometric codes. IEEE\nTransactions on Information Theory 45, 1757\u20131767.\n[10] Guruswami, V., Sudan, M. (2000). List decoding algorithms for certain concatenated codes. In the Proceedings\nof the 32nd Annual ACM symposium on Theory of computing (STOC 2000), pp.181\u2013190.\n[11] Guruswami, V., Sudan, M. (2001). Extensions to the Johnson bound. Unpublished manuscript. Available at\nhttp://madhu.seas.harvard.edu/papers/2001/johnson.pdf.\n[12] Katz, J., Trevisan, L. (2000). On the efficiency of local decoding procedures for error-correcting codes. In the\nProceedings of the 32nd Annual ACM symposium on Theory of computing (STOC 2000), pp. 80\u201386.\n[13] Kawachi, A., Yamakami, T. (2010). Quantum hardcore functions by complexity-theoretical quantum list decoding. SIAM J. Comput. 39, 2941\u20132969. An extended abstract appeared in the Proc. of the 33rd International Colloquium on Automata, Languages and Programming (ICALP 2006), Lecture Notes in Computer Science, Springer,\nvol. 4052, pp. 216\u2013227, 2006.\n[14] Kumar, S. R., Sivakumar, D. (1999). Proofs, codes, and polynomial-time reducibilities. In the Proceedings of\nthe 14th Annual IEEE Conference on Computational Complexity, pp. 46\u201353.\n[15] Naor, M., Pinkas, B. (1999). Oblivious transfer and polynomial evaluation. In the Proceedings of the 31st Annual\nACM symposium on Theory of computing (STOC'99), pp. 245\u2013254.\n[16] Nielsen, M. A., Chuang, I. L. (2000). Quantum Computation and Quantum Information, Cambridge University\nPress.\n[17] Reed, I. S., Solomon, G. (1960). Polynomial codes over certain finite fields. J. SIAM 8, 300\u2013304.\n[18] Roth, R. M. (2006). Introduction to Coding Theory, Cambridge University Press.\n[19] Sudan, M. (1997). Decoding of Reed-Solomon codes beyond the error-correction bound. J. Complexity 13,\n180\u2013193.\n[20] Sudan, M. (2000). List decoding: Algorithms and applications. SIGACT News, vol. 31, pp. 16\u201327.\n[21] Sudan, M., Trevisan, L., Vadhan, S. (2001). Pseudorandom generators without the XOR lemma. J. Comput.\nSystem Sci. 62, 236\u2013266.\n[22] Trevisan, L. (2004). Some applications of coding theory in computational complexity. Available at\nhttps://arxiv.org/abs/cs/0409044.\n[23] van Dam, W., Hallgren, S., Ip, L. (2006). Quantum algorithms for some hidden shift problems. SIAM J. Comput.\n36, 763\u2013778.\n[24] Wozencraft, J. M. (1958). List decoding. Quarterly Progress Report. Research Laboratory of Electronics, MIT,\nvol. 48, pp. 90\u201395.\n[25] Yamakami, T. (1999). A foundation of programming a multi-tape quantum Turing machine. In the\nProceedings of the 24th International Symposium on Mathematical Foundations of Computer Science\n(MFCS'99), Lecture Notes in Computer Science, Springer, vol. 1672, pp. 430\u2013441. Also available at\nhttps://arxiv.org/abs/quant-ph/9906084.\n[26] Yamakami, T. (2003). Analysis of quantum functions. Int. J. Found. Comput. Sci. 14, 815\u2013852.\n\n24\n\n\f[27] Yao, A. C. (1993). Quantum circuit complexity. In the Proceedings of the 34th IEEE Symposium on Foundations\nof Computer Science (FOCS'93), pp. 352\u2013361.\n\n25\n\n\f"}