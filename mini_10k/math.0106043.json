{"id": "http://arxiv.org/abs/math/0106043v2", "guidislink": true, "updated": "2002-08-14T06:40:59Z", "updated_parsed": [2002, 8, 14, 6, 40, 59, 2, 226, 0], "published": "2001-06-07T12:18:18Z", "published_parsed": [2001, 6, 7, 12, 18, 18, 3, 158, 0], "title": "Computing the Face Lattice of a Polytope from its Vertex-Facet\n  Incidences", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=math%2F0106138%2Cmath%2F0106253%2Cmath%2F0106191%2Cmath%2F0106189%2Cmath%2F0106220%2Cmath%2F0106101%2Cmath%2F0106023%2Cmath%2F0106173%2Cmath%2F0106065%2Cmath%2F0106073%2Cmath%2F0106092%2Cmath%2F0106114%2Cmath%2F0106015%2Cmath%2F0106184%2Cmath%2F0106239%2Cmath%2F0106069%2Cmath%2F0106155%2Cmath%2F0106233%2Cmath%2F0106176%2Cmath%2F0106100%2Cmath%2F0106078%2Cmath%2F0106213%2Cmath%2F0106072%2Cmath%2F0106133%2Cmath%2F0106204%2Cmath%2F0106056%2Cmath%2F0106167%2Cmath%2F0106219%2Cmath%2F0106034%2Cmath%2F0106129%2Cmath%2F0106003%2Cmath%2F0106232%2Cmath%2F0106227%2Cmath%2F0106099%2Cmath%2F0106081%2Cmath%2F0106107%2Cmath%2F0106113%2Cmath%2F0106036%2Cmath%2F0106238%2Cmath%2F0106102%2Cmath%2F0106203%2Cmath%2F0106149%2Cmath%2F0106035%2Cmath%2F0106162%2Cmath%2F0106037%2Cmath%2F0106199%2Cmath%2F0106235%2Cmath%2F0106144%2Cmath%2F0106116%2Cmath%2F0106074%2Cmath%2F0106255%2Cmath%2F0106103%2Cmath%2F0106130%2Cmath%2F0106261%2Cmath%2F0106177%2Cmath%2F0106008%2Cmath%2F0106225%2Cmath%2F0106061%2Cmath%2F0106021%2Cmath%2F0106248%2Cmath%2F0106156%2Cmath%2F0106011%2Cmath%2F0106143%2Cmath%2F0106222%2Cmath%2F0106157%2Cmath%2F0106231%2Cmath%2F0106170%2Cmath%2F0106254%2Cmath%2F0106183%2Cmath%2F0106242%2Cmath%2F0106154%2Cmath%2F0106020%2Cmath%2F0106197%2Cmath%2F0106208%2Cmath%2F0106013%2Cmath%2F0106004%2Cmath%2F0106214%2Cmath%2F0106104%2Cmath%2F0106175%2Cmath%2F0106172%2Cmath%2F0106031%2Cmath%2F0106047%2Cmath%2F0106147%2Cmath%2F0106095%2Cmath%2F0106043%2Cmath%2F0106086%2Cmath%2F0106249%2Cmath%2F0106169%2Cmath%2F0106150%2Cmath%2F0106200%2Cmath%2F0106135%2Cmath%2F0106148%2Cmath%2F0106049%2Cmath%2F0106045%2Cmath%2F0106224%2Cmath%2F0106042%2Cmath%2F0106128%2Cmath%2F0106093%2Cmath%2F0106136%2Cmath%2F0106010%2Cmath%2F0106001&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Computing the Face Lattice of a Polytope from its Vertex-Facet\n  Incidences"}, "summary": "We give an algorithm that constructs the Hasse diagram of the face lattice of\na convex polytope P from its vertex-facet incidences in time O(min{n,m}*a*f),\nwhere n is the number of vertices, m is the number of facets, a is the number\nof vertex-facet incidences, and f is the total number of faces of P. This\nimproves results of Fukuda and Rosta (1994), who described an algorithm for\nenumerating all faces of a d-polytope in O(min{n,m}*d*f^2) steps. For simple or\nsimplicial d-polytopes our algorithm can be specialized to run in time\nO(d*a*f). Furthermore, applications of the algorithm to other atomic lattices\nare discussed, e.g., to face lattices of oriented matroids.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=math%2F0106138%2Cmath%2F0106253%2Cmath%2F0106191%2Cmath%2F0106189%2Cmath%2F0106220%2Cmath%2F0106101%2Cmath%2F0106023%2Cmath%2F0106173%2Cmath%2F0106065%2Cmath%2F0106073%2Cmath%2F0106092%2Cmath%2F0106114%2Cmath%2F0106015%2Cmath%2F0106184%2Cmath%2F0106239%2Cmath%2F0106069%2Cmath%2F0106155%2Cmath%2F0106233%2Cmath%2F0106176%2Cmath%2F0106100%2Cmath%2F0106078%2Cmath%2F0106213%2Cmath%2F0106072%2Cmath%2F0106133%2Cmath%2F0106204%2Cmath%2F0106056%2Cmath%2F0106167%2Cmath%2F0106219%2Cmath%2F0106034%2Cmath%2F0106129%2Cmath%2F0106003%2Cmath%2F0106232%2Cmath%2F0106227%2Cmath%2F0106099%2Cmath%2F0106081%2Cmath%2F0106107%2Cmath%2F0106113%2Cmath%2F0106036%2Cmath%2F0106238%2Cmath%2F0106102%2Cmath%2F0106203%2Cmath%2F0106149%2Cmath%2F0106035%2Cmath%2F0106162%2Cmath%2F0106037%2Cmath%2F0106199%2Cmath%2F0106235%2Cmath%2F0106144%2Cmath%2F0106116%2Cmath%2F0106074%2Cmath%2F0106255%2Cmath%2F0106103%2Cmath%2F0106130%2Cmath%2F0106261%2Cmath%2F0106177%2Cmath%2F0106008%2Cmath%2F0106225%2Cmath%2F0106061%2Cmath%2F0106021%2Cmath%2F0106248%2Cmath%2F0106156%2Cmath%2F0106011%2Cmath%2F0106143%2Cmath%2F0106222%2Cmath%2F0106157%2Cmath%2F0106231%2Cmath%2F0106170%2Cmath%2F0106254%2Cmath%2F0106183%2Cmath%2F0106242%2Cmath%2F0106154%2Cmath%2F0106020%2Cmath%2F0106197%2Cmath%2F0106208%2Cmath%2F0106013%2Cmath%2F0106004%2Cmath%2F0106214%2Cmath%2F0106104%2Cmath%2F0106175%2Cmath%2F0106172%2Cmath%2F0106031%2Cmath%2F0106047%2Cmath%2F0106147%2Cmath%2F0106095%2Cmath%2F0106043%2Cmath%2F0106086%2Cmath%2F0106249%2Cmath%2F0106169%2Cmath%2F0106150%2Cmath%2F0106200%2Cmath%2F0106135%2Cmath%2F0106148%2Cmath%2F0106049%2Cmath%2F0106045%2Cmath%2F0106224%2Cmath%2F0106042%2Cmath%2F0106128%2Cmath%2F0106093%2Cmath%2F0106136%2Cmath%2F0106010%2Cmath%2F0106001&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We give an algorithm that constructs the Hasse diagram of the face lattice of\na convex polytope P from its vertex-facet incidences in time O(min{n,m}*a*f),\nwhere n is the number of vertices, m is the number of facets, a is the number\nof vertex-facet incidences, and f is the total number of faces of P. This\nimproves results of Fukuda and Rosta (1994), who described an algorithm for\nenumerating all faces of a d-polytope in O(min{n,m}*d*f^2) steps. For simple or\nsimplicial d-polytopes our algorithm can be specialized to run in time\nO(d*a*f). Furthermore, applications of the algorithm to other atomic lattices\nare discussed, e.g., to face lattices of oriented matroids."}, "authors": ["Volker Kaibel", "Marc E. Pfetsch"], "author_detail": {"name": "Marc E. Pfetsch"}, "author": "Marc E. Pfetsch", "arxiv_comment": "14 pages; to appear in: Comput. Geom.; the new version contains some\n  minor extensions and corrections as well as a more detailed treatment of\n  oriented matroids", "links": [{"href": "http://arxiv.org/abs/math/0106043v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/math/0106043v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "math.MG", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "math.MG", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.CO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "68R05 68U05 52B11 68Q25 52C40", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/math/0106043v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/math/0106043v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:math/0106043v2 [math.MG] 14 Aug 2002\n\nComputing the Face Lattice of a Polytope\nfrom its Vertex-Facet Incidences\nVolker Kaibel and Marc E. Pfetsch\u2217\nOctober 29, 2018\n\nAbstract\nWe give an algorithm that constructs the Hasse diagram of the\nface lattice of a convex polytope P from its vertex-facet incidences in\ntime O(min{n, m} * \u03b1 * \u03c6), where n is the number of vertices, m is the\nnumber of facets, \u03b1 is the number of vertex-facet incidences, and \u03c6 is\nthe total number of faces of P . This improves results of Fukuda and\nRosta [5], who described an algorithm for enumerating all faces of a\nd-polytope in O(min{n, m} * d * \u03c62 ) steps. For simple or simplicial dpolytopes our algorithm can be specialized to run in time O(d * \u03b1 * \u03c6).\nFurthermore, applications of the algorithm to other atomic lattices are\ndiscussed, e.g., to face lattices of oriented matroids.\n\nKeywords: polytope, face lattice, enumeration, vertex-facet incidences,\nalgorithm, oriented matroid\nMSC 2000: 68R05 68U05 52B11 68Q25 52C40\n\n1\n\nIntroduction\n\nLet P be a d-polytope, i.e., a d-dimensional bounded convex polyhedron. It\nis well-known that the set F of its faces (including \u2205 and P itself), ordered\nby inclusion, is a graded, atomic, and coatomic lattice: the face lattice of P .\nIn particular, each face can be identified with its set of vertices or the set\nTU Berlin, Fakult\u00e4t II, Institut f\u00fcr Mathematik, MA 6\u20132, Strasse des 17. Juni 136,\n10623 Berlin, {kaibel,pfetsch}@math.tu-berlin.de. The first author has been supported by a DFG Gerhard-Hess-Forschungsf\u00f6rderungspreis donated to G\u00fcnter M. Ziegler\n(Zi 475/2-3).\n\u2217\n\n1\n\n\fof facets it is contained in. In this paper, a face is usually identified with\nits vertex set. We define \u03c6 := |F| and denote by L the Hasse diagram (as\nan abstract graph) of the face lattice. Hence, L is a directed rooted acyclic\ngraph whose nodes correspond to the elements of F. If lH , lG are nodes in L\nand H, G \u2208 F are the corresponding faces of P , then there is an arc (lH , lG )\nin L if and only if H ( G and dim(G) = dim(H) + 1.\nThe combinatorial face lattice enumeration problem is the following:\ngiven a vertex-facet incidence matrix of P (see Section 2 for a definition),\nconstruct the Hasse diagram L of the face lattice. By definition, L is unlabeled. Nevertheless, it might be desired to label each node of L corresponding to a face F with the set of (indices of) vertices contained in F , the set\nof (indices of) facets containing F , or with the dimension of F .\nFukuda and Rosta [5] gave an algorithm for the combinatorial face lattice\nenumeration problem for d-polytopes P which runs in O(min{n, m} * d * \u03c62 )\ntime, where m is the number of facets and n is the number of vertices of P .\nSince \u03c6 can be exponential in n and m (consider the d-simplex, for instance)\nit is desirable to have an algorithm whose running time depends only linearly\non \u03c6 (and polynomially on n and m). The main result of this paper is such\nan algorithm.\nFor the geometric face lattice enumeration problem, which asks for the\nface lattice of a polytope that is given by an inequality description, there are\nalgorithms satisfying this requirement on the running time, e.g., by Fukuda,\nLiebling, and Margot [4]. However, in our context no geometric data are\navailable.\nGanter [7] described an algorithm which, given the incidences of atoms\nand coatoms of a general atomic and coatomic lattice, enumerates all elements of the lattice in lexicographic order, where each element is identified\nwith the set of atoms below it (which are ordered arbitrarily). Specialized\nto our situation, one obtains an algorithm that computes all vertex sets of\nfaces of P in O(min{n, m} * \u03b1 * \u03c6) steps, where \u03b1 is the number of vertexfacet incidences of P . Note that d*max{n, m} \u2264 \u03b1 \u2264 n*m, in particular, \u03b1 is\nbounded polynomially in n and m. This algorithm, however, does not compute the inclusion relations between the faces, i.e., the edges of the Hasse\ndiagram of the face lattice. Of course, once all (vertex sets of) faces are\ncomputed, one may construct the Hasse diagram in an obvious way afterwards, but this would require a number of steps which is quadratic in the\ntotal number \u03c6 of faces.\nInspired by Ganter's algorithm, we developed the (quite different) algorithm presented below, which computes the entire Hasse diagram in the\nsame running time of O(min{n, m} * \u03b1 * \u03c6), see Theorem 1. It requires\n2\n\n\fO(\u03c6 * min{n, m}) memory (without output storage). In our algorithm, the\nvertex set of each face or the set of facets it is contained in, as well as its\ndimension, is readily available (or can be computed without increasing the\nasymptotic running time). Of course, this may increase the (output) storage\nrequirements significantly.\nFukuda and Rosta [5] also considered the combinatorial face lattice enumeration problem for the special case of simple or simplicial polytopes. They\npresented an algorithm that computes the face lattice of a simple polytope\nin O(d * \u03c6) steps, provided that in addition to the vertex-facet incidences an\nacyclic orientation of the graph of the polytope is given that induces precisely one sink on every non-empty face. Such an orientation is called a good\norientation or an abstract objective function orientation. Unfortunately, no\npolynomial time algorithm is known that computes a good orientation of a\nsimple polytope P - neither if P is given by its vertex-facet incidences nor\nif it is specified by its whole face lattice.\nFor simple or simplicial polytopes, our algorithm can be specialized such\nthat it computes the Hasse diagram of the face lattice in O(d * \u03b1 * \u03c6) steps\nfrom the vertex-facet incidences, where no good orientation is required (see\nSection 3.1).\nIn Section 2.1 we give a rough sketch of the algorithm, which is followed\nby a more detailed description in Sections 2.2, 2.3, and 2.4. In Section 2.5\nwe analyze the algorithm. We present the specialization of the algorithm for\nsimple or simplicial polytopes in Section 3.1 and a variant that computes\nthe k-skeleton in Section 3.2. Furthermore, in Section 3.3 a version that\nneeds significantly less memory is described which enumerates just the faces\ntogether with their dimensions (i.e., without the edges of the Hasse diagram).\nFinally, a modification that computes the face lattice of an oriented matroid\nfrom its cocircuits (Section 3.4) is explained.\nFor the basic properties of polytopes that are important in our context,\nwe refer to Ziegler's book [8]. The few concepts from the theory of algorithms and data structures that play a role in the paper can be found in any\ncorresponding textbook (e.g. in the one by Cormen, Leiserson, Rivest, and\nStein [2]). Our running time estimates refer to the uniform time measure\n(i.e., every arithmetic operation/comparison takes one unit of time), while\nour statements on memory requirements refer to the bit model.\n\n3\n\n\f2\n\nThe Algorithm\n\nDefine m to be the number of facets and n the number of vertices of the\nd-polytope P . Let A = (af v ) \u2208 {0, 1}m\u00d7n be a vertex-facet incidence matrix\nof P . Hence the facets of P can be identified with F := {1, . . . , m} and\nits vertices can be identified with V := {1, . . . , n}, such that af v = 1 if\nfacet f contains vertex v, and af v = 0 otherwise. Denote by \u03b1 the number\nof vertex-facet incidences, i.e., the number of ones in A. For S \u2286 V , define\nF(S) := {f \u2208 F : af s = 1 for all s \u2208 S}, the set of facets containing all\nvertices of S. For T \u2286 F , define V(T ) := {v \u2208 V : atv = 1 for all t \u2208 T },\nthe set of vertices contained in all facets of T .\nFor S \u2286 V , the set cl(S) := V(F(S)) is the (vertex set of) the smallest\nface of P containing S (in lattice theoretic terms, the join of the elements\nin S). One can check easily that this defines a closure map on the subsets\nof V , i.e., for all S, S \u2032 \u2286 V we have:\nS \u2286 cl(S),\n\ncl(cl(S)) = cl(S),\n\nS \u2286 S \u2032 \u21d2 cl(S) \u2286 cl(S \u2032 ).\n\nThe faces of P correspond exactly to the closed sets of V with respect to\nthis closure map (i.e., sets S \u2286 V with cl(S) = S). Our algorithm crucially\nrelies on the fact that closures can be computed fast (see Section 2.2).\n\n2.1\n\nThe Skeleton of the Algorithm\n\nThe strategy is to build up the Hasse diagram L of the face lattice from\nbottom (\u2205) to top (P ). Consequently, L is initialized with the single face \u2205\nand then enlarged iteratively by adding out-neighbors of nodes that have\nalready been constructed. We will say that a face has been seen, once its\ncorresponding node in L has been constructed.\nDuring the algorithm, we keep a set Q containing those faces that we\nhave seen so far, but for which we have not yet inserted their out-arcs into\nthe Hasse diagram. At each major step, we remove a face H from the set Q\nand construct the set G of all faces G with H ( G and dim(G) = dim(H)+1.\nFor each face G \u2208 G we check whether it has already been seen. If this is\nnot the case, then a new node in L representing G is constructed, and G is\nadded to Q. In any case, an arc from the node corresponding to H to the\nnode corresponding to G is inserted into L.\nIn order to compute the set G, we exploit the fact that G consists of\nthe inclusion minimal faces among the ones that properly contain H. Since\nthe face lattice of a polytope is atomic, each face G \u2208 G must be of the\nform H(v) := cl(H \u222a {v}) for some vertex (atom) v; in particular, the Hasse\n4\n\n\fdiagram has at most n * \u03c6 arcs. Thus, we first construct the collection H of\nall sets H(v), v \u2208 V \\ H, and then compute G as the set of inclusion minimal\nsets of H.\nComputing H(v) for some v \u2208 V \\ H requires determining a closure.\nIn Section 2.2, we describe a method to perform this task in O(\u03b1) steps.\nDetermining the inclusion minimal sets in the collection H clearly could\nbe done in O(n3 ) steps by pairwise comparisons, since H has at most n\nelements, each of size at most n. In Section 2.3 we show that this can even\nbe performed in O(n2 ) time.\nAnother crucial ingredient is a data structure, described in Section 2.4,\nthat allows us to locate the node in L representing a given face G or to\nassert that G has not yet been seen. This can be performed in O(\u03b1) steps.\nA summary of the analysis of the time complexity of the algorithm, along\nwith a pseudo-code description of it, is given in Section 2.5.\n\n2.2\n\nComputing Closures\n\nIn order to be able to compute closures fast, we store the incidence matrix A\nin a sorted sparse format both in a row and column based way. For each\nvertex v \u2208 V , the elements in F({v}) \u2286 {1, . . . , m} are stored increasingly\nin a list. Similarly, for each facet f \u2208 F , we store the sorted set V({f })\nin a list. This preprocessing can be performed in O(n * m) time (which\nis dominated by O(n * \u03b1) and thus does not influence the estimate of the\nasymptotic running time in Proposition 1 below). The sorted sparse format\nuses O(\u03b1 * log max{n, m}) storage.\nWhenever we want to compute the closure of a set S \u2286 V , the first step\nis to compute F(S), i.e., the intersection of the lists F({v}), v \u2208 S. Since\nthe intersection of two sorted lists can be computed in time proportional to\nthe sum of the lengths of the two lists and because the intersection of two\nlists\nPis at most as long as the shorter one, F(S) can be computed in time\nO( v\u2208S |F({v})|) \u2286 O(\u03b1). Similarly, V(T ) can be computed in time O(\u03b1)\nfor a set T \u2286 F .\nLemma 1. The closure cl(S) of a set S \u2286 V can be computed in O(\u03b1) steps\n(provided that the vertex-facet incidence matrix is given in the sorted sparse\nformat).\n\n2.3\n\nIdentifying the Minimal Sets\n\nSuppose that H ( V is a face of P and H is the collection of all faces\nH(v) = cl(H \u222a {v}) \u2286 V , v \u2208 V \\ H.\n5\n\n\fOur procedure to identify the set G of minimal sets in the collection H\nstarts by assigning a label candidate to each vertex in V \\ H. Subsequently,\nthe label candidate of each vertex will either be removed or replaced by a\nlabel minimal. We keep the following three invariants: For each vertex v\nthat is labeled minimal we have H(v) \u2208 G; if two different vertices v and w\nboth are labeled minimal, then we have H(v) 6= H(w); G is contained in the\nset of all H(v) for which v is labeled minimal or candidate. Clearly, if no\nvertex is labeled candidate anymore, the set of vertices labeled minimal is\nin one-to-one correspondence to G via H(*).\nSuppose there is still some v labeled candidate available. If H(v) \\ {v}\ncontains some vertex w, then we have H(w) \u2286 H(v), because H(w) is the\nintersection of all faces containing H and w, and one of these faces is H(v).\nHence, if w is labeled minimal or candidate, we remove the label candidate\nfrom v; otherwise we label v minimal.\nIt follows by induction that the three invariants are satisfied throughout\nthe procedure. Moreover, at each major step (choosing a candidate v) the\nnumber of candidate labels decreases by one. Since each such step takes\nO(n) time, the entire procedure has complexity O(n2 ).\nLemma 2. The set G of inclusion minimal sets in H = {H(v) : v \u2208 V \\ H}\ncan be identified in O(n2 ) steps.\n\n2.4\n\nLocating Nodes\n\nDuring the algorithm, we have to keep track of the faces that we have\nseen so far and their corresponding nodes in L. To this end, we maintain a special data structure, the face tree. In this data structure, a face\nS = {s1 , . . . , sk } \u2286 V (with s1 < * * * < sk ) is represented by the lexicographically smallest set C(S) \u2286 S that generates S, i.e., cl(C(S)) = S.\nWe call C(S) the canonical spanning set of the face S. The map C(*) is\none-to-one; its inverse map is the closure map.\nThe set C(S) can be computed efficiently as follows. For k = 1, 2\nset C(S) := S. For k \u2265 3, C(S) is computed iteratively: initialize C(S)\nwith the set {s1 , s2 }; at each iteration extend C(S) by the smallest si such\nthat cl(C(S)) ( cl(C(S) \u222a {si }). Note that |C(S)| \u2264 dim(S) + 1 \u2264 d + 1.\nRecall that we stored the vertex-facet incidences in the sorted sparse format (see Section 2.2). Similarly to the method for computing closures, this\ncomputation can be performed in O(\u03b1) steps, since just the intersections\nF({s1 }) \u2229 * * * \u2229 F({si }), i = 1, . . . , k, have to be computed iteratively. Then,\nC(S) is obtained as the set of those si for which the intersection becomes\nsmaller.\n6\n\n\fWe now explain the structure of the face tree. Its arcs are directed away\nfrom the root. They are labeled with vertex numbers, such that no two\narcs leaving the same node have the same label and on every directed path\nin the tree the labels are increasing. Via the sets of labels on the paths\nfrom the root, the nodes of the tree correspond to the sorted sets C(S) for\nthe faces S \u2286 V that have been seen so far. In particular, the root node\nrepresents the face \u2205. Each node has a pointer to the corresponding node\nof L. By construction, the depth of the tree is bounded by d + 1.\nSuppose we want to find the node lS corresponding to some face S \u2286 V\nin the part of L that we have already constructed or to assert that this\nface has not yet been seen. We first sort S (a subset of {1, . . . , n}) increasingly in O(n) steps (by counting or bucket sort, see [2, Chap. 8]) and\ncompute C(S) in O(\u03b1) steps. Then, starting from the root, we proceed (as\nlong as possible) downwards in the face tree along arcs labeled by the successive elements of C(S). Either we find an existing node in the tree which\ncorresponds to S, or we have to introduce new labeled arcs (and nodes) into\nthe tree until we have constructed a node representing S.\nIn the latter case, it might be necessary to construct an entire new path\nin the tree. The definition of the canonical spanning sets C(S) ensures that\nall \"intermediate nodes\" on that path will correspond to canonical spanning\nsets of faces as well. Hence, the number of nodes in the face tree always\nwill be bounded by \u03c6, the total number of faces of the polytope. The faces\nrepresented by intermediate nodes will be seen later in the algorithm. Consequently, the corresponding pointers to L are set to nil for the meantime.\nLater in the algorithm, when we are searching for the face represented by\nsuch a tree-node for the first time, the nil-pointer will indicate that this face\nis not yet represented in L. The nil-pointer is then replaced by a pointer\nto a newly created node representing the face in L.\nIn any case, since the face tree has depth at most d+1 and the out-degree\nof each node is at most n, we need a total time of O(n + \u03b1 + (d + 1) * n) =\nO(\u03b1) to either locate or create the tree-node representing a certain face.\nLemma 3. Using the face tree, it is possible to locate or create the node\nin L representing a face in O(\u03b1) steps (provided the vertex-facet incidence\nmatrix is stored in the sorted sparse format).\nIn the description given above, we have assumed that for each node in\nthe face tree the out-arcs are stored in a list which is searched linearly for\na certain label when walking down the tree. Of course, one can store the\nset of out-arcs in a balanced search tree (see, e.g., [2, Chap. 13]), allowing\n\n7\n\n\fto perform the search for a certain label in logarithmic time. After computing C(S) for a face S (in O(\u03b1) time), this allows to locate or create the node\ncorresponding to S in the face tree in O((d + 1) * log n) steps. The total\nrunning time remains O(\u03b1); nevertheless this might speed up the algorithm\nin practice.\nInstead of using the face tree, one can also store the faces in a balanced search tree. Again, the faces are represented by their canonical\nspanning sets, which are ordered lexicographically. Once C(S) is computed for a face S, searching S can be performed in O((d + 1) * log \u03c6) \u2286\nO((d + 1) * min{n, m}) steps (since \u03c6 \u2264 2min{n,m} ). This yields the same\ntotal asymptotic running time, but searching the tree takes more (or the\nsame) time compared to the variant of the face tree with balanced search\ntrees at its nodes, since log n \u2264 min{n, m}.\n\n2.5\n\nThe Analysis\n\nWe summarize the algorithm in pseudo-code (Algorithm 1):\nAlgorithm 1 Computing the face lattice of a polytope from its incidences\n1: Input: incidence matrix of a polytope P\n2: Output: Hasse diagram L of the face lattice of P\n3: initialize L and a face tree with l\u2205 corresponding to the empty face\n4: initialize a set Q \u2286 {nodes of L} \u00d7 {subsets of V } by (l\u2205, \u2205)\n5: while Q 6= \u2205 do\n6:\nchoose some (lH , H) \u2208 Q and remove it from Q\n7:\ncompute the collection H of all H(v), v \u2208 V \\ H\n8:\ncompute the set G of minimal sets in H\n9:\nfor each G \u2208 G do\n10:\nlocate/create the node lG corresponding to G in L\n11:\nif lG was newly created then\n12:\nadd (lG , G) to Q\n13:\nend if\n14:\nadd the arc (lH , lG ) to L\n15:\nend for\n16: end while\nProposition 1. Algorithm 1 computes the Hasse diagram of the face lattice\nof a polytope P from its vertex-facet incidences in O(n * \u03b1 * \u03c6) time. It can\nbe implemented such that its space requirements (without output space) are\nbounded by O(\u03c6 * n).\n8\n\n\fProof. Algorithm 1 works correctly by the discussion above.\nStep 7 can be performed in O(n * \u03b1) steps by Lemma 1. Lemma 2 shows\nthat we can execute Step 8 in O(n2 ) \u2286 O(n * \u03b1) time. Hence, Steps 7 and 8\nin total contribute at most O(n * \u03b1 * \u03c6) to the running time (since the whileloop is executed once per face).\nThe body of the for-loop has to be executed for each of the O(n * \u03c6) arcs\nin the Hasse diagram L. Lemma 3 implies that each execution of the body\nof the for-loop can be performed in O(\u03b1) steps. Thus, the claim on the\nrunning time follows.\nSince each node of the face tree corresponds to a face of P , the face tree\nhas O(\u03c6) nodes. Each label on an edge of the face tree needs at most O(log n)\nbits, and we can estimate the space requirements of any of the (internal and\nexternal) pointers by O(log \u03c6) \u2286 O(min{n, m}). Hence, the face tree needs\nno more than O(\u03c6 * min{n, m}) bits.\nThe space required for the storage of Q is bounded by O(\u03c6 * n), if for\neach pair (lH , H) \u2208 Q the set H is stored as a bit set, i.e., the characteristic\nvector of H \u2286 V is stored bit by bit.\nIf m < n, then it is more efficient to apply Algorithm 1 to the incidences\nof the dual polytope, i.e., to the transpose of the incidence matrix. Of\ncourse, after the computations the roles of vertices and facets have to be\nexchanged again. This yields the main result of the paper.\nTheorem 1. The Hasse diagram of the face lattice of a polytope P can\nbe computed from the vertex-facet incidences of P in O(min{n, m} * \u03b1 * \u03c6)\ntime, where n is the number of vertices, m is the number of facets, \u03b1 is\nthe number of vertex-facet incidences, and \u03c6 is the total number of faces\nof P . The space requirements of the algorithm (without output space) can\nbe bounded by O(\u03c6 * min{n, m}).\nWhenever a new node representing a face G in the Hasse diagram L is\nconstructed, we can label that node with the vertex set of G, the set of\nfacets containing G, or with the dimension of G without (asymptotically)\nincreasing the running time of the algorithm. The output, however, might\nbecome much larger with such labelings. For instance, labeling the Hasse\ndiagram of the d-cube by vertex labels requires \u03a9(4d * d) output storage\nspace, while the Hasse diagram with facet labels needs only O(d * 3d * log d)\nspace.\nIn practice, the computation can be speeded up by exploiting that every\nvertex that is contained in a face G with H ( G and dim G = dim H + 1\n\n9\n\n\fmust be contained in some facetSwhich contains\u0001 H. Thus, it suffices to\nconsider only the sets H(v), v \u2208\nf \u2208F(H) V({f }) \\ H in Step 7.\n\n3\n3.1\n\nExtensions\nSimple or Simplicial Polytopes\n\nFor a simple d-polytope P with n vertices, the above procedure can be\nimplemented to run more efficiently. We have \u03b1 = n * d in this case. From\nthe incidences (stored in the sorted sparse format), the graph G(P ) of P\n(i.e., all one-dimensional faces) can be computed in time O(n2 * d), since a\npair of vertices forms an edge if and only if it is contained in d \u2212 1 common\nfacets.\nAfter initialization with the vertices instead of \u2205 (in Steps 3 and 4),\nSteps 7 and 8 can now be simplified. Consider an arbitrary vertex w \u2208 H.\nFor each neighbor v \u2208\n/ H of w in G(P ), H(v) yields the other end node of\nan arc in the Hasse diagram; and each out-arc of H is produced this way.\nThus, we can avoid constructing non-minimal faces in Step 7. Hence, Step 8\ncan be skipped. The total running time for simple d-polytopes decreases\nto O(d * \u03b1 * \u03c6) (since the body of the for-loop is executed at most d * \u03c6\ntimes).\nThe space complexity stays O(\u03c6 * n) (see Proposition 1). It can, however, be reduced to O(\u03c6 * m) (we have m \u2264 n for simple polytopes): instead of storing pairs (lH , H) in the set Q, we store the pairs (lH , F(H)),\nsince |F(H)| \u2264 m. Converting between H and F(H) can be performed\nin O(\u03b1) steps and hence does not increase the asymptotic total running\ntime.\nBy duality, the same running times and space requirements can be\nachieved for simplicial polytopes.\nSimilarly to the situation with general polytopes, for both simple and\nsimplicial polytopes we can also output for each face its vertices, the facets\ncontaining it, or its dimension without (asymptotically) increasing the running time.\n\n3.2\n\nThe k-Skeleton\n\nA variant of Algorithm 1 computes the Hasse diagram of the k-skeleton\n(all faces of dimension at most k) of a polytope P . One simply prevents\nthe computation of faces of dimensions larger than k by not inserting any\n\n10\n\n\f(k \u2212 1)-face into the list Q. This leads to an O(n * \u03b1 * \u03c6\u2264k ) time algorithm,\nwhere \u03c6\u2264k is the number of faces of P of dimension at most k.\n\n3.3\n\nComputing the \"Hasse Diagram without Edges\"\n\nIf we only want to compute the faces of P together with their descriptions\nand dimensions (i.e., the \"Hasse diagram without edges\"), there exists a\nvariant of Algorithm 1 with the same asymptotic running time, but significantly reduced space requirements. The difference is that no face tree is\nused, and the set Q is organized as a stack, i.e., the faces are investigated\nin a depth-first search manner. At each step, we take a face H from the\nstack, output it, and compute the set G of (dim H + 1)-faces containing H,\nlike in Steps 7 and 8 of Algorithm 1. This needs time O(n * \u03b1) for each H.\nThe for-loop beginning at Step 10, including the search in the face tree, is\nreplaced by an efficient way to decide which of the faces in G is put onto\nthe stack Q, such that every face appears exactly once on the stack during\nthe algorithm. For this, we compute for each face G \u2208 G a unique canonical\nfacet H \u2032 of it. We put G onto the stack if and only if H = H \u2032 . This ensures\nthat each face is picked exactly once.\nWe take H \u2032 as the closure of a set D(G), which is computed similar\nto the set C(G) of Section 2.4, except that we reject vertices which would\nproduce G. More precisely, let G = {g1 , g2 , . . . , gl }, with g1 < g2 < * * * < gl .\nInitialize D(G) with \u2205 and in each iteration extend D(G) by the smallest gi\nsuch that cl(D(G)) ( cl(D(G) \u222a {gi }) and cl(D(G) \u222a {gi }) 6= G. After\nthe computation, H \u2032 , the closure of D(G), clearly is a proper face of G.\nMoreover, it is a facet of G, since otherwise there exists a vertex g \u2208 G \\ H \u2032 ,\nsuch that cl(H \u2032 \u222a {g}) ( G. But then g would have been included into D(G)\nwhen it was considered. Hence, D(G) is the lexicographically smallest subset\nof G which spans a facet of G. It can be computed in time O(\u03b1), and hence,\nchecking for all faces G \u2208 G whether H is the canonical facet D(G) of G can\nbe performed in O(n * \u03b1) time.\nAltogether, this leads to an O(n * \u03b1 * \u03c6) time algorithm (see the proof of\nProposition 1). The algorithm needs O(n2 * d * log n) space for Q; since the\ndepth of Q is at most d + 1, there are never more than n * (d + 1) sets on the\nstack, each of size at most n. Additionally, we need O(\u03b1 * log max{n, m})\nspace for storing the incidences in the sorted sparse format. Applying this\nmethod to the dual polytope, if necessary, we obtain an O(min{n, m} * \u03b1 * \u03c6)\ntime algorithm.\n\n11\n\n\f3.4\n\nOriented Matroids\n\nAlgorithm 1 can be used for the enumeration of the elements of any atomic\nlattice provided a subroutine is available that computes the join of a set of\natoms. For instance, this holds for every atomic and coatomic lattice if the\natom-coatom incidences are given, because in this case one can compute the\njoins of atoms similarly to the case of face lattices of polytopes.\nIn the following, we describe such an application of our algorithm to\noriented matroids. The set of covectors of an oriented matroid with ground\nset {1, . . . , k} is a subset of {\u2212, 0, +}k that satisfies certain axioms. We refer\nto Bj\u00f6rner, Las Vergnas, Sturmfels, White, and Ziegler [1, Chap. 4] for the\ndefinitions and concepts that are relevant in the following. A specific, but\nillustrative, example arises from any finite set X of points in d as follows.\nFor every linear functional \u03c6 \u2208 ( d )\u22c6 denote by sign(\u03c6) \u2208 {\u2212, 0, +}X the\nvector \bwhose component corresponding to x \u2208 X encodes the sign of \u03c6(x).\nThen sign(\u03c6) : \u03c6 \u2208 ( d )\u22c6 is the set of covectors of an oriented matroid O(X).\nFor v, w \u2208 {\u2212, 0, +}k the separation set of v and w contains all indices i\nsuch that one of vi , wi is +, and the other one is \u2212. The composition v \u25e6 w\nof v and w is defined by (v\u25e6w)i := vi if vi 6= 0 and (v\u25e6w)i := wi otherwise.\nWe define a partial order \u0016 on {\u2212, 0, +}k , where v \u0016 w holds if and\nonly if for all i we have vi = 0 or vi = wi . The \u0016-minimal elements among\nthe nonzero covectors of an oriented matroid are called its cocircuits. If one\nadjoins an artificial maximal element 1\u0302 to the poset formed by the covectors\nof an oriented matroid (ordered by \u0016), then one obtains its (big) face lattice.\nIf, in the above example, X is the vertex set of a polytope P \u2282 d ,\nthen the faces of P correspond to the positive covectors (i.e., the covectors\nwith no component equal to \u2212) of O(X). The facets of P correspond to the\npositive cocircuits of O(X). The face lattice of P is anti-isomorphic to a\nsublattice of the face lattice of O(X).\nThe face lattice of an oriented matroid is atomic and coatomic; its atoms\nare the cocircuits, and its coatoms are called topes. Hence, we can compute\nits Hasse diagram from the abstract atom-coatom incidences as above.\nHowever, this is not the usual way to encode an oriented matroid. It is\nmore common to specify an oriented matroid by its cocircuits. The join of\ntwo covectors simply is their composition, if their separation set is empty,\nor 1\u0302 otherwise. Such a composition can be computed in O(k) steps, which\nenables us to compute the face lattice (efficiently) from its cocircuits by a\nvariant of Algorithm 1.\nIn Step 6, H now is a face of the oriented matroid, i.e., a covector. In\n\nR\n\nR\n\nR\n\nR\n\n12\n\n\fStep 7, one has to compute the joins of H with every cocircuit v 6\u0016 H. Thus,\nStep 7 can be performed in O(n * k * \u03c6) steps altogether (where \u03c6 is the total\nnumber of covectors and n is the number of cocircuits). We do not know\nany method to perform Step 8 faster than by pairwise comparisons, which\ntake O(n2 * k * \u03c6) time in total.\nThe face tree is organized similarly to the description in Section 2.4.\nOne fixes an ordering C1 , . . . , Cn of the cocircuits. For a covector S let\n{i1 , . . . , ir } (i1 < * * * < ir ) be the index set of cocircuits Cij \u0016 S. Then we\niteratively form the joins of Ci1 , . . . , Cir , and let C(S) consist of all those\nindices for which the \"joins change.\" Computing C(S) from S takes O(n * k)\nsteps. Note that |C(S)| \u2264 k.\nUsing this modified face tree, a given covector S can now be searched\nin the same way as in the case of face lattices of polytopes. The depth of\nthe face tree is bounded by k. Hence, location/creation of a covector can be\nperformed in O(n * k) time. The rest of the analysis is similar to the proof\nof Proposition 1. Thus, by this variant of Algorithm 1, the Hasse diagram\nof the face lattice of an oriented matroid can be computed in O(n2 * k * \u03c6)\nsteps, requiring O(\u03c6 * k) working space (since \u03c6 \u2264 3k ).\nFinschi [3] describes a different algorithm that computes the covectors of\nan oriented matroid from its cocircuits in O(n * k2 * \u03c6) time. His algorithm,\nhowever, does not produce the edges of the Hasse diagram.\nThe case where the topes (i.e., the \u0016-maximal covectors) of an oriented\nmatroid are given is a bit different. Here, the number of faces is bounded\nby m2 , where m is the number of topes. Hence, the size of the face lattice\nis polynomial in m. Fukuda, Saito, and Tamura [6] give an O(k3 * m2 ) time\nalgorithm for constructing the face lattice from the maximal covectors.\n\nAcknowledgements\nWe are indepted to Michael Joswig and J\u00f6rg Rambau for stimulating discussions as well as to G\u00fcnter M. Ziegler for valuable comments on the paper.\nWe also thank the two referees for their helpful comments.\n\nReferences\n[1] A. Bj\u00f6rner, M. Las Vergnas, B. Sturmfels, N. White, and\nG. M. Ziegler, Oriented Matroids, vol. 46 of Encyclopedia of Mathematics and its Applications, Cambridge University Press, 2nd ed., 1999.\n\n13\n\n\f[2] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein,\nIntroduction to Algorithms, MIT Press, Cambridge, 2nd ed., 2001.\n[3] L. Finschi, A Graph Theoretical Approach for Reconstruction and Generation of Oriented Matroids, PhD thesis, IFOR, ETH Z\u00fcrich, 2001.\n[4] K. Fukuda, T. M. Liebling, and F. Margot, Analysis of backtrack\nalgorithms for listing all vertices and all faces of a convex polyhedron,\nComput. Geom., 8 (1997), pp. 1 \u2013 12.\n[5] K. Fukuda and V. Rosta, Combinatorial face enumeration in convex\npolytopes, Comput. Geom., 4 (4) (1994), pp. 191\u2013198.\n[6] K. Fukuda, S. Saito, and A. Tamura, Combinatorial face enumeration in arrangements and oriented matroids, Discrete Appl. Math., 31\n(2) (1991), pp. 141 \u2013 149.\n[7] B. Ganter, Algorithmen zur formalen Begriffsanalyse, in Beitr\u00e4ge zur\nBegriffsanalyse, B. Ganter, R. Wille, and K. E. Wolff, eds., B.I. Wissenschaftsverlag, 1987, pp. 241\u2013254.\n[8] G. M. Ziegler, Lectures on Polytopes, Springer-Verlag, 1995. Revised\nedition 1998.\n\n14\n\n\f"}