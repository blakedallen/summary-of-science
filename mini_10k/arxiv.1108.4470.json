{"id": "http://arxiv.org/abs/1108.4470v1", "guidislink": true, "updated": "2011-08-23T01:23:54Z", "updated_parsed": [2011, 8, 23, 1, 23, 54, 1, 235, 0], "published": "2011-08-23T01:23:54Z", "published_parsed": [2011, 8, 23, 1, 23, 54, 1, 235, 0], "title": "A Logic with Reverse Modalities for History-preserving Bisimulations", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1108.5751%2C1108.5398%2C1108.3100%2C1108.5082%2C1108.0554%2C1108.5642%2C1108.0179%2C1108.6017%2C1108.1224%2C1108.5562%2C1108.1992%2C1108.6059%2C1108.5778%2C1108.5078%2C1108.1635%2C1108.6263%2C1108.0142%2C1108.4210%2C1108.3747%2C1108.3350%2C1108.3253%2C1108.4095%2C1108.0467%2C1108.5277%2C1108.0251%2C1108.2976%2C1108.3824%2C1108.5278%2C1108.3627%2C1108.5105%2C1108.1711%2C1108.5493%2C1108.5643%2C1108.5815%2C1108.0784%2C1108.5183%2C1108.6035%2C1108.5843%2C1108.1728%2C1108.4114%2C1108.0486%2C1108.1167%2C1108.2827%2C1108.3943%2C1108.6034%2C1108.3019%2C1108.0432%2C1108.3866%2C1108.1769%2C1108.3323%2C1108.5043%2C1108.4686%2C1108.3597%2C1108.3756%2C1108.4302%2C1108.4523%2C1108.4470%2C1108.3143%2C1108.6184%2C1108.2728%2C1108.5404%2C1108.2533%2C1108.0664%2C1108.3340%2C1108.2696%2C1108.6282%2C1108.2237%2C1108.3894%2C1108.2984%2C1108.4607%2C1108.1825%2C1108.4718%2C1108.3573%2C1108.2147%2C1108.3416%2C1108.5990%2C1108.0657%2C1108.1961%2C1108.3947%2C1108.0151%2C1108.2024%2C1108.5569%2C1108.5820%2C1108.6270%2C1108.0826%2C1108.3654%2C1108.2572%2C1108.3596%2C1108.1188%2C1108.5213%2C1108.4515%2C1108.0524%2C1108.4188%2C1108.5780%2C1108.6037%2C1108.3433%2C1108.4421%2C1108.2538%2C1108.0877%2C1108.3919%2C1108.5755&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Logic with Reverse Modalities for History-preserving Bisimulations"}, "summary": "We introduce event identifier logic (EIL) which extends Hennessy-Milner logic\nby the addition of (1) reverse as well as forward modalities, and (2)\nidentifiers to keep track of events. We show that this logic corresponds to\nhereditary history-preserving (HH) bisimulation equivalence within a particular\ntrue-concurrency model, namely stable configuration structures. We furthermore\nshow how natural sublogics of EIL correspond to coarser equivalences. In\nparticular we provide logical characterisations of weak history-preserving (WH)\nand history-preserving (H) bisimulation. Logics corresponding to HH and H\nbisimulation have been given previously, but not to WH bisimulation (when\nautoconcurrency is allowed), as far as we are aware. We also present\ncharacteristic formulas which characterise individual structures with respect\nto history-preserving equivalences.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1108.5751%2C1108.5398%2C1108.3100%2C1108.5082%2C1108.0554%2C1108.5642%2C1108.0179%2C1108.6017%2C1108.1224%2C1108.5562%2C1108.1992%2C1108.6059%2C1108.5778%2C1108.5078%2C1108.1635%2C1108.6263%2C1108.0142%2C1108.4210%2C1108.3747%2C1108.3350%2C1108.3253%2C1108.4095%2C1108.0467%2C1108.5277%2C1108.0251%2C1108.2976%2C1108.3824%2C1108.5278%2C1108.3627%2C1108.5105%2C1108.1711%2C1108.5493%2C1108.5643%2C1108.5815%2C1108.0784%2C1108.5183%2C1108.6035%2C1108.5843%2C1108.1728%2C1108.4114%2C1108.0486%2C1108.1167%2C1108.2827%2C1108.3943%2C1108.6034%2C1108.3019%2C1108.0432%2C1108.3866%2C1108.1769%2C1108.3323%2C1108.5043%2C1108.4686%2C1108.3597%2C1108.3756%2C1108.4302%2C1108.4523%2C1108.4470%2C1108.3143%2C1108.6184%2C1108.2728%2C1108.5404%2C1108.2533%2C1108.0664%2C1108.3340%2C1108.2696%2C1108.6282%2C1108.2237%2C1108.3894%2C1108.2984%2C1108.4607%2C1108.1825%2C1108.4718%2C1108.3573%2C1108.2147%2C1108.3416%2C1108.5990%2C1108.0657%2C1108.1961%2C1108.3947%2C1108.0151%2C1108.2024%2C1108.5569%2C1108.5820%2C1108.6270%2C1108.0826%2C1108.3654%2C1108.2572%2C1108.3596%2C1108.1188%2C1108.5213%2C1108.4515%2C1108.0524%2C1108.4188%2C1108.5780%2C1108.6037%2C1108.3433%2C1108.4421%2C1108.2538%2C1108.0877%2C1108.3919%2C1108.5755&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We introduce event identifier logic (EIL) which extends Hennessy-Milner logic\nby the addition of (1) reverse as well as forward modalities, and (2)\nidentifiers to keep track of events. We show that this logic corresponds to\nhereditary history-preserving (HH) bisimulation equivalence within a particular\ntrue-concurrency model, namely stable configuration structures. We furthermore\nshow how natural sublogics of EIL correspond to coarser equivalences. In\nparticular we provide logical characterisations of weak history-preserving (WH)\nand history-preserving (H) bisimulation. Logics corresponding to HH and H\nbisimulation have been given previously, but not to WH bisimulation (when\nautoconcurrency is allowed), as far as we are aware. We also present\ncharacteristic formulas which characterise individual structures with respect\nto history-preserving equivalences."}, "authors": ["Iain Phillips", "Irek Ulidowski"], "author_detail": {"name": "Irek Ulidowski"}, "author": "Irek Ulidowski", "links": [{"title": "doi", "href": "http://dx.doi.org/10.4204/EPTCS.64.8", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1108.4470v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1108.4470v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "In Proceedings EXPRESS 2011, arXiv:1108.4077", "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1108.4470v1", "affiliation": "University of Leicester", "arxiv_url": "http://arxiv.org/abs/1108.4470v1", "journal_reference": "EPTCS 64, 2011, pp. 104-118", "doi": "10.4204/EPTCS.64.8", "fulltext": "A Logic with Reverse Modalities for History-preserving\nBisimulations\nIain Phillips\nDepartment of Computing, Imperial College London, England\niccp@doc.ic.ac.uk\n\nIrek Ulidowski\nDepartment of Computer Science, University of Leicester, England\niu3@mcs.le.ac.uk\n\nWe introduce event identifier logic (EIL) which extends Hennessy-Milner logic by the addition of\n(1) reverse as well as forward modalities, and (2) identifiers to keep track of events. We show\nthat this logic corresponds to hereditary history-preserving (HH) bisimulation equivalence within\na particular true-concurrency model, namely stable configuration structures. We furthermore show\nhow natural sublogics of EIL correspond to coarser equivalences. In particular we provide logical\ncharacterisations of weak history-preserving (WH) and history-preserving (H) bisimulation. Logics\ncorresponding to HH and H bisimulation have been given previously, but not to WH bisimulation\n(when autoconcurrency is allowed), as far as we are aware. We also present characteristic formulas\nwhich characterise individual structures with respect to history-preserving equivalences.\n\n1\n\nIntroduction\n\nThe paper presents a modal logic that can express simple properties of computation in the true concurrency setting of stable configuration structures. We aim, like Hennessy-Milner logic (HML) [19] in the\ninterleaving setting, to characterise the main true concurrency equivalences and to develop characteristic\nformulas for them. We focus in this paper on history-preserving bisimulation equivalences.\nHML has a \"diamond\" modality hai\u03c6 which says that an event labelled a can be performed, taking\nus to a new state which satisfies \u03c6 . The logic also contains negation (\u00ac), conjunction (\u2227) and a base\nformula which always holds (tt). HML is strong enough to distinguish any two processes which are not\nbisimilar.\nWe are interested in making true concurrency distinctions between processes. These processes will\nbe event structures, where the current state is represented by the set of events which have occurred so\nfar. Such sets are called configurations. Events have labels (ranged over by a, b, . . .), and different events\nmay have the same label. We shall refer to example event structures using a CCS-like notation, with\na | b denoting an event labelled with a in parallel with another labelled with b, a.b denoting two events\nlabelled a and b where the first causes the second, and a + b denoting two events labelled a and b which\nconflict.\nIn the true concurrency setting bisimulation is referred to as interleaving bisimulation, or IB for short.\nThe processes a|b and a.b + b.a are interleaving bisimilar, but from the point of view of true concurrency\nthey should be distinguished, and HML is not powerful enough to do this.\nWe therefore look for a more powerful logic, and we base this logic on adding reverse moves. Instead\nof the one modality hai\u03c6 we have two: forward diamond haii\u03c6 (which is just a new notation for the hai\u03c6\nof HML) and reverse diamond hhai\u03c6 . The latter is satisfied if we can reverse some event labelled with\nB. Luttik and F. D. Valencia (Eds.): 18th International Workshop on\nExpressiveness in Concurrency (EXPRESS 2011)\nEPTCS 64, 2011, pp. 104\u2013118, doi:10.4204/EPTCS.64.8\n\nc I.C.C. Phillips & I. Ulidowski\n\n\fI.C.C. Phillips & I. Ulidowski\n\n105\n\na and get to a configuration where \u03c6 holds. Such an event would have to be maximal to enable us to\nreverse it, i.e. it could not be causing some other event that has already occurred.\nWith this new reverse modality we can now distinguish a|b and a.b + b.a: a|b satisfies haiihbiihhaitt,\nwhile a.b + b.a does not. The formula expresses the idea that a and b are concurrent. Alternatively we\nsee that a.b + b.a satisfies haiihbii\u00achhaitt, while a | b does not. This latter formula expresses the idea that\na causes b.\nThe new logic corresponds to reverse interleaving bisimulation [31], or RI-IB for short. In the absence of autoconcurrency, Bednarczyk [3] showed that this is as strong as hereditary history-preserving\nbisimulation [3], or HH for short, which is usually regarded as the strongest desirable true concurrency\nequivalence. HH was independently proposed in [21], under the name of strong history-preserving bisimulation.\nAuto-concurrency is where events can occur concurrently and have the same label. To allow for\nthis, we need to strengthen the logic. For instance, we want to distinguish a | a from a.a, which is not\npossible with the logic as it stands: haiihaiihhaitt is satisfied by both processes. We need some way of\ndistinguishing the two events labelled with a. We change our modalities so that when we make a forward\nmove we declare an identifier (ranged over by x, y, . . .) which stands for that event, allowing us to refer to\nit again when reversing it. Now we can write hx : aiihy : aiihhxitt, and this is satisfied by a | a, but not by\na.a. Declaration is an identifier-binding operation, so that x and y are both bound in the formula. Baldan\nand Crafa [2] also used such declarations in their forward-only logic.\nWith this simple change we now have a logic which is as strong as HH, even with autoconcurrency.\nWe have to be careful that our logic does not become too strong. For instance, we want to ensure that\nprocesses a and a + a are indistinguishable. One might think that a + a satisfies hx : aiihhxihy : aii\u00achhxitt,\nwhile a does not. To avoid this, we need to ensure that x is forgotten about once it is reversed, and so\ncannot be used again. One could make a syntactic restriction that in a formula hhxi\u03c6 the identifier x is not\nallowed to occur (free) in \u03c6 . However this is not actually necessary, as our semantics will ensure that all\nidentifiers must be assigned to events in the current configuration. So in fact hx : aiihhxihy : aii\u00achhxitt is\nnot satisfied by a + a, since we are not allowed to reverse x as it would take us to a configuration where x\nis mentioned in hy : aii\u00achhxitt but x is assigned to an event outside the current configuration. Baldan and\nCrafa [2] also had to deal with this issue.\nOur logic is not quite complete, since we wish to express certain further properties. For instance, we\nwould like to express a reverse move labelled with a, i.e. hhai\u03c6 . Instead of adding this directly, we add\ndeclarations (x : a)\u03c6 . We can now express hhai\u03c6 by the formula (x : a)hhxi\u03c6 (where x does not occur\n(free) in \u03c6 ).\nWe also wish to express so-called step transitions, which are transitions consisting of multiple events\noccurring concurrently. For instance a forward step ha, aii\u03c6 of two events labelled with a can be achieved\nby hx : aiihy : aii(\u03c6 \u2227 hhxitt) and a reverse step hha, ai\u03c6 can be achieved by (x : a)(y : a)(hhxihhyi\u03c6 \u2227 hhyitt)\n(both formulas with x and y not free in \u03c6 ). Thus the reverse steps employ declarations. As well as\nexpressing reverse steps, declarations allow us to obtain a sublogic which corresponds to weak historypreserving bisimulation (WH).\nThis completes a brief introduction of our logic, which we call Event Identifier Logic, or EIL for\nshort. Apart from corresponding to HH, EIL has natural sublogics for several other true concurrency\nequivalences. Figure 1 shows a hierarchy of equivalences that we are able to characterise, where arrows\ndenote proper set inclusion. Apart from the mentioned HH and WH, history-preserving bisimulation (H)\nis a widely studied equivalence that employs history isomorphism. Hereditary weak-history preserving\nbisimulation (HWH) is WH with the hereditary property [3] that deals with reversing of events. The\ndefinitions of these equivalences can be found in [12, 31], and are outlined in Section 3.2.\n\n\fA Logic with Reverse Modalities\n\n106\nPSfrag replacements\n\nHH\nH\n\nHWH\nWH\n\nFigure 1: The hierarchy of history-preserving equivalences.\nIt is natural to ask if, at least for a finite structure, there is a single logical formula which captures all\nof its behaviour, up to a certain equivalence. Such formulas are called characteristic formulas. They have\nbeen investigated previously for HML and other logics [16, 35, 1]. We look at characteristic formulas\nwith respect to three of the equivalences we consider, namely HH, H and WH.\nThe main contribution of the paper is a logic EIL. It could be argued that EIL is a natural and\ncanonical logic for the true concurrency equivalences considered here in the following sense. Firstly, its\nforward and reverse modalities capture faithfully the information of the forward and reverse transitions\nin the definitions of the equivalences, Secondly, event identifier environments and event declarations give\nrise naturally to order isomorphisms for HH, H, HWH and WH. Finally, EIL extends HML and keeps\nwith its spirit of having simple modalities defined seamlessly over a general computation model.\nOther contributions include the first to our knowledge logics for WH and HWH. Finally, we present\nthe first to our knowledge characteristic formulas for HH, H and WH.\nThe paper is organised as follows. We look at related work in Section 2. Then we recall the definitions\nof configuration structures and the bisimulation-based equivalences that we shall need in Section 3. We\nthen introduce EIL in Section 4, giving examples of its usage. Next we look at how to characterise\nvarious equivalences using EIL and its sublogics (Section 5). In Section 6 we investigate characteristic\nformulas. We finish with conclusions and future work.\n\n2\n\nRelated work\n\nPrevious work on logics for true concurrency can be categorised loosely according to the type of semantic\nstructure (model) that the satisfaction relation of the logic is defined for. There are logics over configurations (sets of consistent events) [15, 2] and logics over paths (or computations) [5, 27, 28, 29, 32],\nalthough logics in [27, 28, 29] can be seen also as logics over configurations. Other structures such as\ntrees, graphs and Kripke frames are used as models in, for example, [26, 25, 17, 18].\nThe logic in this paper uses simple forward and reverse event identifier modalities that are sufficient\nto characterise HH. In contrast, Baldan and Crafa [2] achieved an alternative characterisation of HH\nwith a different modal logic that uses solely forward-only event identifier modalities hxi and (xx, \u0233y < a z).\nThe formula (xx, \u0233y < a z)\u03c6 holds in a configuration if in its future there is an a-labelled event e that can\nbe bound to z, and \u03c6 holds. Additionally, e must be (1) caused at least by the events already bound\nto the events in x and (2) concurrent with at least the events already bound to the events in y . Several\ninteresting sublogics were also identified in [2] that characterise H, pomset bisimulation [4, 12] and step\nbisimulation [33, 12] respectively.\nGoltz, Kuiper and Penczek [15] researched configurations of prime event structures without autoconcurrency. In such a setting HH coincides with reverse interleaving bisimulation RI-IB (shown in [3]).\nMoreover, H coincides with WH. Partial Order Logic (POL) is proposed in [15]. POL contains past\nmodalities and the authors stated that it characterises RI-IB (and thus HH). Also, it is conjectured that if\n\n\fI.C.C. Phillips & I. Ulidowski\n\n107\n\none restricts POL in such a way that no forward modalities can be nested in a past modality, then such a\nlogic characterises H (and thus WH).\nCherief [5] defined a pomset bisimulation relation over paths and shows that it coincides with H (defined over configurations). The author then predicted that an extension of HML with forward and reverse\npomset modalities characterises H. This idea was then developed further by Pinchinat, Laroussinie and\nSchnoebelen in [32].\nNielsen and Clausen defined a \u03b4 -bisimulation relation (\u03b4 b) over paths [27, 29]. Unlike in [5, 32], one\nis allowed to reverse independent maximal events in any order. This seemingly small change has a profound effect on the strength of the equivalence: \u03b4 b coincides with HH. It was shown that an extension of\nHML with a reverse modality characterises HH when there is no autoconcurrency [27, 29]. Additionally,\nit was stated (without a proof) [28] that an extension of HML with a reverse event index modality characterises HH even in the presence of autoconcurrency. The notion of paths used in [27, 28, 29] induces\na notion of configuration. Hence, their logics could be understood as logics over configurations and reverse index modality could be seen as a form of our reverse event identifier modality. We would argue,\nhowever, that many properties of configurations related to causality and concurrency between events are\nexpressed more naturally with reverse identifier modalities.\nPast or reverse modalities, which are central to our logic, were used before in a number of modal\nlogics and temporal logics [20, 7, 6, 26, 15, 23, 24, 30] but only [26, 15] proposed logical characterisations of true concurrency equivalences. Among the rest, HML with backward modalities in [7, 6] defined\nover paths is shown to characterise branching bisimulation. Finally, Gutierrez introduced a modal logic\nfor transition systems with independence [17, 18] that has two diamond modalities: one for causally\ndependent transitions and the other for concurrent transitions with respect to a given transition.\n\n3\n\nConfiguration structures and equivalences\n\nIn this section we define our computational model (stable configuration structures) and the various bisimulation equivalences for which we shall present logical characterisations.\n\n3.1 Configuration structures\nWe work with stable configuration structures [13, 14, 12], which are equivalent to stable event structures [36].\nDefinition 3.1. A configuration structure (over an alphabet Act) is a pair C = (C, l) where C is a family\nS\nof finite sets (configurations) and l : X\u2208C X \u2192 Act is a labelling function.\nWe use CC , lC to refer to the two components of a configuration structure C . Also we let EC =\nX\u2208C X , the events of C . We let e, . . . range over events, and E, F, . . . over sets of events. We let a, b, c, . . .\nrange over labels in Act.\nS\n\nDefinition 3.2 ([12]). A configuration structure C = (C, l) is stable if it is\n\u2022 rooted: 0/ \u2208 C; connected: 0/ 6= X \u2208 C implies \u2203e \u2208 X : X \\ {e} \u2208 C;\n\u2022 closed under bounded unions: if X ,Y, Z \u2208 C then X \u222aY \u2286 Z implies X \u222aY \u2208 C;\n\u2022 closed under bounded intersections: if X ,Y, Z \u2208 C then X \u222aY \u2286 Z implies X \u2229Y \u2208 C.\nAny stable configuration structure is the set of configurations of a stable event structure [12, Thm 5.3].\nDefinition 3.3. Let C = (C, l) be a stable configuration structure, and let X \u2208 C.\n\n\fA Logic with Reverse Modalities\n\n108\n\n\u2022 Causality: d \u2264X e iff for all Y \u2208 C with Y \u2286 X we have e \u2208 Y implies d \u2208 Y . Furthermore d <X e\niff d \u2264X e and d 6= e.\n\u2022 Concurrency: d coX e iff d 6<X e and e 6<X d.\nIt is shown in [12] that <X is a partial order and that the sub-configurations of X are precisely those\nsubsets Y which are left-closed w.r.t. <X , i.e. if d <X e \u2208 Y then d \u2208 Y . Furthermore, if X ,Y \u2208 C with\nY \u2286 X , then <Y = <X \u21be Y .\nRecall that a prime event structure is a set of events with a labelling function, together with a causality\nrelation and a conflict relation (between events that cannot be members of the same configuration) [36].\nThe set of configurations of a prime event structure forms a stable configuration structure; prime event\nstructures are a proper subclass of stable event structures. All of our examples are given as prime event\nstructures or the corresponding CCS expressions. When drawing diagrams of prime event structures we\nshall, as usual, depict the causal relation with arrows, and the conflict relation with dotted lines. We shall\nalso suppress the actual events and write their labels instead. Thus if we have two events e1 and e2 , both\nlabelled with a, in diagrams we shall denote them as a1 and a2 , respectively, when we wish to distinguish\nbetween them. This is justified, since all the notions of equivalence we shall discuss depend on the labels\nof the events, rather than the events themselves.\nExample 3.4. Consider a prime event structure with events e1 , e2 , e3 all labelled with a, where e1 causes\ne2 and e1 , e2 are concurrent with e3 . The corresponding CCS expression is (a.a) | a. The set of configurations consists of 0,\n/ {e1 }, {e3 }, {e1 , e2 }, {e1 , e3 } and {e1 , e2 , e3 }.\ne\n\nDefinition 3.5. Let C = (C, l) be a stable configuration structure and let a \u2208 Act. We let X \u2192C X \u2032 iff\na\ne\nX , X \u2032 \u2208 C, X \u2286 X \u2032 and X \u2032 \\ X = {e}. Furthermore we let X \u2192C X \u2032 iff X \u2192C X \u2032 for some e with l(e) = a.\na\ne\na\ne\nWe also define reverse transitions: X C X \u2032 iff X \u2032 \u2192C X , and X C X \u2032 iff X \u2032 \u2192C X . The overloading of\nnotation whereby transitions can be labelled with events or with event labels should not cause confusion.\nFor a set of events E, let l(E) be the multiset of labels of events in E. We define a step transition\nrelation where concurrent events are executed in a single step:\nDefinition 3.6. Let C = (C, l) be a stable configuration structure and let A \u2208 NAct (A is a multiset over\nA\nAct). We let X \u2192C X \u2032 iff X , X \u2032 \u2208 C, X \u2286 X \u2032 , and X \u2032 \\ X = E with d coX \u2032 e for all d, e \u2208 E and l(E) = A.\nWe shall assume in what follows that stable configuration structures are image finite with respect to\na\nforward transitions, i.e. for any configuration X and any label a, the set {X \u2032 : X \u2192C X \u2032 } is finite.\n\n3.2 Equivalences\nWe define history-preserving bisimulations and illustrate the differences between them with examples.\nDefinition 3.7. Let X = (X , <X , lX ) and Y = (Y, <Y , lY ) be partial orders which are labelled over Act.\nWe say that X and Y are isomorphic (X \u223c\n= Y ) iff there is a bijection from X to Y respecting the ordering\nand the labelling. The isomorphism class [X ]\u223c\n= of a partial order labelled over Act is called a pomset\nover Act.\nDefinition 3.8 ([8, 12]). Let C , D be stable configuration structures. A relation R \u2286 CC \u00d7CD is a weak\nhistory-preserving (WH) bisimulation between C and D if R(0,\n/ 0)\n/ and if R(X ,Y ) and a \u2208 Act then:\n\u223c\n\u2022 (X , <X , lC \u21be X ) = (Y, <Y , lD \u21be Y );\na\n\na\n\na\n\na\n\n\u2022 if X \u2192C X \u2032 then \u2203Y \u2032 . Y \u2192D Y \u2032 and R(X \u2032 ,Y \u2032 );\n\u2022 if Y \u2192D Y \u2032 then \u2203X \u2032 . X \u2192C X \u2032 and R(X \u2032 ,Y \u2032 ).\n\n\fPSfrag replacements\n\nI.C.C. Phillips & I. Ulidowski\n\n109\n\nE\n\nF\n\na1\n\na2\n\na3\n\na4\n\na1\n\na2\n\na3\n\na4\n\nb1\n\nb2\n\nb3\n\nb4\n\nb1\n\nb2\n\nb3\n\nb4\n\nFigure 2: Example 3.12.\nWe say that C and D are WH equivalent (C \u2248wh D) iff there is a WH bisimulation between C and D.\nDefinition 3.9 ([34, 12]). Let C , D be stable configuration structures. A relation R \u2286 CC \u00d7 CD \u00d7\nP(EC \u00d7 ED ) is a history-preserving (H) bisimulation between C and D iff R(0,\n/ 0,\n/ 0)\n/ and if R(X ,Y, f )\nand a \u2208 Act\n\u2022 f is an isomorphism between (X , <X , lC \u21be X ) and (Y, <Y , lD \u21be Y );\na\n\na\n\na\n\na\n\na\n\na\n\na\n\na\n\na\n\na\n\n\u2022 if X \u2192C X \u2032 then \u2203Y \u2032 , f \u2032 . Y \u2192D Y \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u2032 \u21be X = f ;\n\u2022 if Y \u2192D Y \u2032 then \u2203X \u2032 , f \u2032 . X \u2192C X \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u2032 \u21be X = f .\nWe say that C and D are H equivalent (C \u2248h D) iff there is an H bisimulation between C and D.\nBoth H and WH have associated hereditary versions:\nDefinition 3.10 ([3, 21, 12]). Let C , D be stable configuration structures and let a \u2208 Act. Then R \u2286\nCC \u00d7CD \u00d7 P(EC \u00d7 ED ) is a hereditary H (HH) bisimulation iff R is an H bisimulation and if R(X ,Y, f )\nthen for any a \u2208 Act,\na\na\n\u2022 if X C X \u2032 then \u2203Y \u2032 , f \u2032 . Y D Y \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u21be X \u2032 = f \u2032 ;\n\u2022 if Y D Y \u2032 then \u2203X \u2032 , f \u2032 . X C X \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u21be X \u2032 = f \u2032 .\nWe say that C and D are HH equivalent (C \u2248hh D) iff there is an HH bisimulation between C and D.\nDefinition 3.11. Let C , D be stable configuration structures and let a \u2208 Act. Then R \u2286 CC \u00d7 CD \u00d7\nP(EC \u00d7 ED ) is a hereditary WH (HWH) bisimulation if R(0,\n/ 0,\n/ 0)\n/ and if R(X ,Y, f ) and a \u2208 Act then:\n\u2022 f is an isomorphism between (X , <X , lC \u21be X ) and (Y, <Y , lD \u21be Y );\n\u2022 if X \u2192C X \u2032 then \u2203Y \u2032 , f \u2032 . Y \u2192D Y \u2032 and R(X \u2032 ,Y \u2032 , f \u2032 );\n\u2022 if Y \u2192D Y \u2032 then \u2203X \u2032 , f \u2032 . X \u2192C X \u2032 and R(X \u2032 ,Y \u2032 , f \u2032 );\n\u2022 if X\n\na\nC\na\n\nX \u2032 then \u2203Y \u2032 , f \u2032 . Y\n\na\nD\na\n\nY \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u21be X \u2032 = f \u2032 ;\n\n\u2022 if Y D Y \u2032 then \u2203X \u2032 , f \u2032 . X C X \u2032 , R(X \u2032 ,Y \u2032 , f \u2032 ) and f \u21be X \u2032 = f \u2032 .\nAlso C and D are HWH equivalent (C \u2248hwh D) iff there is an HWH bisimulation between C and D.\nThe inclusions in Figure 1 are immediate from the definitions. They are strict inclusions:\nExample 3.12 ([31]). Consider event structures E , F in Figure 2, where each event structure has four\na-labelled and four b-labelled events. E = F holds for \u2248hwh , and hence for \u2248wh , but not for \u2248h , and\nhence not for \u2248hh . We now show this. E , F have the same configurations except that {a2 , a3 , b3 } is\nmissing in F . We define a bisimulation by relating all isomorphic states, and check that it is an HWH.\na a\nTo see that E and F are not H-equivalent, consider 0/ \u21922 \u21923 {a2 , a3 } in F . This must be matched by\nmoving to configuration {ai , ai+1 } in E , where i \u2208 {1, 2, 3}. But then both bi and bi+1 are possible.\nHowever {a2 , a3 } in F can only do b2 . Hence one of the bi and bi+1 in E cannot be matched to b2 in\nsuch way that the resulting isomorphism contains the already established pairs (either (a2 , ai ), (a3 , ai+1 )\nor (a2 , ai+1 ), (a3 , ai )) and is history-preserving.\n\n\fA Logic with Reverse Modalities\n\n110\nExample 3.13. The Absorption Law [4, 3, 12]\n\n(a | (b + c)) + (a | b) + ((a + c) | b) = (a | (b + c)) + ((a + c) | b)\nholds for \u2248h , and thus for \u2248wh , but not for \u2248hwh .\n\n4\n\nEvent Identifier Logic\n\nWe now introduce our logic, which we call Event Identifier Logic (EIL). We assume an infinite set of\nidentifiers Id, ranged over by x, y, z, . . .. The syntax of EIL is as follows:\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | hx : aii\u03c6 | (x : a)\u03c6 | hhxi\u03c6\nWe include the usual operators of propositional logic: truth tt, negation \u00ac\u03c6 and conjunction \u03c6 \u2227 \u03c6 \u2032 . We\nthen have forward diamond hx : aii\u03c6 , which says that it is possible to perform an event labelled with a\nand reach a new configuration where \u03c6 holds. In the formula hx : aii\u03c6 , the modality hx : aii binds all free\noccurrences of x in \u03c6 . Next we have declaration (x : a)\u03c6 . This says that there is some event with label\na in the current configuration which can be bound to x, in such a way that \u03c6 holds. Here the declaration\n(x : a) binds all free occurrences of x in \u03c6 . Finally we have reverse diamond hhxi\u03c6 . This says that it\nis possible to perform the reverse event bound to identifier x, and reach a configuration where \u03c6 holds.\nNote that hhxi does not bind x. Clearly any occurrences of x that get bound by (x : a) must be of the form\nhhxi. We allow alpha-conversion of bound names. We use \u03c6 , \u03c8 , . . . to range over formulas of EIL.\nExample 4.1. The formula hx : aiihy : aiihhxitt says that there are events with label a, say e1 and e2 , that\ncan be bound to x and y such that, after performing e1 and then e2 , we can reverse e1 . Obviously, after\nperforming e1 followed by e2 , we can always reverse e2 . This formula could be interpreted as saying that\nan event bound to x is concurrent with an event bound to y. Next, consider hx : aiihy : aii\u00achhxitt. The\nformula expresses that an event bound to x causes an event bound to y (because if we could reverse x\nbefore y, we would reach a configuration containing y and not x, which contradicts x being a cause of y).\nDefinition 4.2. We define fi(\u03c6 ), the set of free identifiers of \u03c6 , by induction on formulas:.\nfi(tt) = 0/\nfi(\u03c61 \u2227 \u03c62 ) = fi(\u03c61 ) \u222a fi(\u03c62 ) fi((x : a)\u03c6 ) = fi(\u03c6 ) \\ {x}\nfi(\u00ac\u03c6 ) = fi(\u03c6 ) fi(hx : aii\u03c6 ) = fi(\u03c6 ) \\ {x}\nfi(hhxi\u03c6 ) = fi(\u03c6 ) \u222a {x}\n/ otherwise \u03c6 is open.\nWe say that \u03c6 is closed if fi(\u03c6 ) = 0;\nIn order to assign meaning to open formulas, as usual we employ environments which tell us what\nevents the free identifiers are bound to.\nDefinition 4.3. An environment \u03c1 is a partial mapping from Id to events. We say that \u03c1 is a permissible\nenvironment for \u03c6 and X if fi(\u03c6 ) \u2286 dom(\u03c1 ) and rge(\u03c1 \u21be fi(\u03c6 )) \u2286 X .\nWe let 0/ denote the empty environment. We let \u03c1 [x 7\u2192 e] denote the environment \u03c1 \u2032 which agrees\nwith \u03c1 except possibly on x, where \u03c1 \u2032 (x) = e (and \u03c1 (x) may or may not be defined). We abbreviate\n0[x\n/ 7\u2192 e] by [x 7\u2192 e]. We let \u03c1 \\ x denote \u03c1 with the assignment to x deleted (if defined in \u03c1 ).\nNow we can formally define the semantics of EIL:\nDefinition 4.4. Let C be a stable configuration structure. We define a satisfaction relation C , X , \u03c1 |= \u03c6\nwhere X is a configuration of C , and \u03c1 is a permissible environment for \u03c6 and X , by induction on\nformulas as follows (we suppress the C where it is clear from the context):\n\n\fI.C.C. Phillips & I. Ulidowski\n\n111\n\n\u2022 X , \u03c1 |= tt always\n\u2022 X , \u03c1 |= \u00ac\u03c6 iff X , \u03c1 6|= \u03c6\n\u2022 X , \u03c1 |= \u03c61 \u2227 \u03c62 iff X , \u03c1 |= \u03c61 and X , \u03c1 |= \u03c62\ne\n\n\u2022 X , \u03c1 |= hx : aii\u03c6 iff \u2203X \u2032 , e such that X \u2192C X \u2032 with l(e) = a and X \u2032 , \u03c1 [x 7\u2192 e] |= \u03c6\n\u2022 X , \u03c1 |= (x : a)\u03c6 iff \u2203e \u2208 X such that l(e) = a and X , \u03c1 [x 7\u2192 e] |= \u03c6\n\u2022 X , \u03c1 |= hhxi\u03c6 iff \u2203X \u2032 , e such that X\nenvironment for \u03c6 and X \u2032 )\n\ne\nC\n\nX \u2032 with \u03c1 (x) = e and X \u2032 , \u03c1 |= \u03c6 (and \u03c1 is a permissible\n\nFor closed \u03c6 we further define C , X |= \u03c6 iff C , X , 0/ |= \u03c6 , and C |= \u03c6 iff C , 0/ |= \u03c6 .\nIn the case of hhxi\u03c6 , note that even though according to the syntax x is allowed to occur free in \u03c6 , if\ne\nx does occur free in \u03c6 then X , \u03c1 |= hhxi\u03c6 can never hold: if \u03c1 (x) = e and X C X \u2032 then X \u2032 , \u03c1 |= \u03c6 cannot\nhold, since \u03c1 is not a permissible environment for \u03c6 and X \u2032 , as \u03c1 assigns a free identifier of \u03c6 to an event\noutside X \u2032 .\nExample 4.5. Consider the configuration structure from Example 3.4. The empty configuration satisfies hx : aiihy : aiihhxitt: we have 0,\n/ 0/ |= hx : aiihy : aiihhxitt since {e1 , e3 }, [x 7\u2192 e1 , y 7\u2192 e3 ] |= hhxitt;\ne1\n/ 0/ |= hx : aiihy : aii\u00achhxitt. We have\nthe latter holds because {e1 , e3 }\n{e3 } and \u03c1 (x) = e1 . Also, 0,\ne\n0,\n/ 0/ |= hx : aiihy : aii\u00achhxitt since {e1 , e2 }, [x 7\u2192 e1 , y 7\u2192 e2 ] |= \u00achhxitt. This is because {e1 , e2 } 6 1 {e2 } as\n{e2 } is not a configuration.\nThe closed formula (x : a)tt says that there is some event labelled with a in the current configuration:\nX |= (x : a)tt iff \u2203e \u2208 X . l(e) = a. Returning to Example 3.4, note that as well as {e1 , e2 }, [x 7\u2192 e1 , y 7\u2192\ne2 ] |= \u00achhxitt this also holds: {e1 , e2 }, [x 7\u2192 e1 , y 7\u2192 e2 ] |= (x : a)hhxitt. By the definition of (x : a), the\ncurrent environment is updated to [x 7\u2192 e2 , y 7\u2192 e2 ] and we obtain {e1 , e2 }, [x 7\u2192 e2 , y 7\u2192 e2 ] |= hhxitt. Correspondingly, {e1 , e2 }, [x 7\u2192 e1 , y 7\u2192 e2 ] |= (x : a)hhxi(y : a)hhyitt. However, {e1 , e2 }, [x 7\u2192 e1 , y 7\u2192 e2 ] 6|=\n(x : a)hhxihhyitt since {e1 }, [x 7\u2192 e2 , y 7\u2192 e2 ] 6|= hhyitt.\nWe introduce further operators as derived operators of EIL:\nNotation 4.6 (Derived operators). Let A = {a1 , . . . , an } be a multiset of labels.\ndf\n\n\u2022 ff = \u00actt,\n\ndf\n\n[x : a]] \u03c6 = \u00achx : aii\u00ac\u03c6 ,\n\ndf\n\n\u03c61 \u2228 \u03c62 = \u00ac(\u00ac\u03c61 \u2227 \u00ac\u03c62 )\nV\n\ndf\n\n\u2022 Forward step hAii\u03c6 = hx1 : a1 ii * * * hxn : an ii(\u03c6 \u2227 n\u22121\ni=1 hhxi itt) where x1 , . . . , xn are fresh and distinct\n(and in particular are not free in \u03c6 ). We write ha1 , . . . , an ii\u03c6 instead of h{a1 , . . . , an }ii\u03c6 . In the case\ndf\n\nn = 1 we have haii\u03c6 = hx : aii\u03c6 where x is fresh.\nV\n\ndf\n\n\u2022 Reverse step hhAi\u03c6 = (x1 : a1 ) * * * (xn : an )(hhx1 i * * * hhxn i\u03c6 \u2227 ni=2 hhxi itt) where x1 , . . . , xn are fresh\nand distinct (and in particular are not free in \u03c6 ). We write hha1 , . . . , an i\u03c6 instead of hh{a1 , . . . , an }i\u03c6 .\ndf\n\nIn the case n = 1 we have hhai\u03c6 = (x : a)hhxi\u03c6 where x is fresh.\nExample 4.7. Consider E , F in Figure 2 and \u03c6 \u2261 [x : a]] [y : a]] (hz : bii\u00achhxitt \u2227 hw : bii\u00achhyitt). We\neasily check that E satisfies \u03c6 and F does not. Next, consider \u03c8 \u2261 hx : aii( [w : c]] ff \u2227 hy : biihhxi [z : c]]\nff). Then the LHS structure of the Absorption Law in Example 3.13 satisfies \u03c8 and the RHS does\nnot. Strictly speaking, event identifiers are not necessary to distinguish the two pairs of configuration\nstructures. A formula with simple label modalities haii( [c]] ff \u2227 hbiihhai [c]] ff) is sufficient for the the\nAbsorption Law, and E , F in Figure 2 can be distinguished by a logic with pomset modalities (both\nreverse and forward) defined over runs [5, 32].\n\n\fPSfrag replacements\n\nA Logic with Reverse Modalities\n\n112\nE\n\na1\n\na2\n\na3\n\nF a\n1\n\na4\n\na5\n\na6\n\na4\n\na\u20324\n\na2\n\na3\n\na5\n\na6\n\nFigure 3: Example 4.8.\nExample 4.8. Consider E , F in Figure 3. There is a non-binary conflict among the three initial aevents (indicated by a dashed ellipsis) defined by requiring that at most two of these events can appear\nin any configuration. E and F are H equivalent: we define a bisimulation by relating configurations\nof identically labelled events (including where a4 is matched with a\u20324 ) and check that it is an H. The\nstructures are also HWH equivalent. This time we define a bisimulation between order isomorphic\nconfigurations (of which there only five isomorphism classes: 0,\n/ {a}, {a, a}, {a < a} and {a < a, a},\nwhere events separated by commas are concurrent) and check that it is an HWH. However, E and F\nare not HH equivalent and event identifiers are indeed necessary to distinguish them. The formula\nhx : aiihy : aii(\u00achhxitt \u2227 hz : aiihhyihw : aii\u00achhzitt \u2227 hz\u2032 : aiihhyi\u00achw\u2032 : aii\u00achhz\u2032 itt) is only satisfied by E . It\nrequires that x causes y and that z and z\u2032 are bound to different events because hz : aii and hz\u2032 : aii are\nfollowed by mutually contradictory behaviours. This is possible in E (a1 , a4 can be followed by either\na3 or a2 ) but not in F : none of the pairs of causally dependent events offers two different a-events.\n\n5\n\nUsing EIL to characterise equivalences\n\nWe wish to show that EIL and its various sublogics characterise the equivalences defined in Section 3.2.\nEach sublogic of EIL induces an equivalence on configuration structures in a standard fashion:\nDefinition 5.1. Let L be any sublogic of EIL. Then L induces an equivalence on stable configuration\nstructures as follows: C \u223cL D iff for all closed \u03c6 \u2208 L we have C |= \u03c6 iff D |= \u03c6 .\nFirst we introduce a simple sublogic that allows us to characterise order isomorphism.\n\n5.1 Reverse-only logic and order isomorphism\nWe define sublogics of EIL, consisting of formulas where only reverse transitions are allowed.\nDefinition 5.2. Reverse-only logic EILro :\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | (x : a)\u03c6 | hhxi\u03c6\nWe further define declaration-free reverse-only logic EILdfro :\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | hhxi\u03c6\nThese logics are preserved between isomorphic configurations, and characterise configurations up to\nisomorphism.\nLemma 5.3. Let C , D be stable configuration structures, and let X ,Y be configurations of C , D respectively. Suppose that f : X \u223c\n= Y . Then for any \u03c6 \u2208 EILro , and any \u03c1 (permissible environment for \u03c6 and\nX ), we have X , \u03c1 |= \u03c6 iff Y, f \u25e6 \u03c1\u03c6 |= \u03c6 .\n\n\fI.C.C. Phillips & I. Ulidowski\n\n113\n\nRecall that \u03c1\u03c6 is an abbreviation for \u03c1 \u21be fi(\u03c6 ). Function composition is in applicative rather than\ndiagrammatic order.\nGiven any configuration X we can create a closed formula \u03b8X \u2208 EILro which gives the order structure\nof X . We make this precise in the following lemma:\nLemma 5.4. Let X be a configuration of a stable configuration structure C . There is a closed formula\n\u03b8X \u2208 EILro , such that if Y is any configuration of a stable configuration structure D and |Y | = |X |, then\nY\u223c\n= X iff Y |= \u03b8X .\nThe next lemma follows fairly immediately from the proof of Lemma 5.4 and from Lemma 5.3:\nLemma 5.5. Let X be a configuration of a stable configuration structure C . Let {ze : e \u2208 X } be distinct\nidentifiers. Let the environment \u03c1X be defined by \u03c1X (ze ) = e (e \u2208 X ). There is a formula \u03b8X\u2032 \u2208 EILdfro\nwith fi(\u03b8 \u2032 ) = {ze : e \u2208 X }, such that X , \u03c1X |= \u03b8X\u2032 and if Y is any configuration of a stable configuration\nstructure D and |Y | = |X |, then Y \u223c\n= X iff \u2203\u03c1 . Y, \u03c1 |= \u03b8X\u2032 .\n\n5.2 Logics for history-preserving bisimulations\nWe start by showing that EIL characterises HH-bisimulation. We then present sublogics of EIL which\ncorrespond to H-bisimulation, WH-bisimulation and HWH-bisimulation.\nOur first result is related to the result of [28] that a logic with reverse event index modality (discussed\nabove in Section 2) characterises HH.\nTheorem 5.6. Let C , D be stable configuration structures. Then, C \u2248hh D if and only if C \u223cEIL D.\nRemark 5.7. In fact Theorem 5.6 would hold with the logic restricted by not using declarations (x : a)\u03c6 .\nHowever we include declarations in EIL because they are useful in defining sublogics for WH, among\nother things.\nWe define a sublogic of EIL which characterises history-preserving bisimulation:\nDefinition 5.8. EILh is given as follows, where \u03c6r is a formula of EILro :\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | hx : aii\u03c6 | (x : a)\u03c6 | \u03c6r\nEILh is just EIL with hhx : ai\u03c6 replaced by \u03c6r \u2208 EILro . Thus one is not allowed to go forward after\ngoing in reverse. This concept of disallowing forward moves embedded inside reverse moves appears\nin [15].\nTheorem 5.9. Let C , D be stable configuration structures. Then, C \u2248h D if and only if C \u223cEILh D.\nRemark 5.10. Just as for Theorem 5.6, Theorem 5.9 would still hold if we disallow declarations (x : a)\u03c6 .\nThis gives the following more minimal logic, where \u03c6r \u2208 EILdfro .\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | hx : aii\u03c6 | \u03c6r\nWe define a sublogic EILwh of EILh which characterises weak history-preserving bisimulation. We\nget from EILh to EILwh by simply requiring that all formulas of EILwh are closed.\nDefinition 5.11. EILwh is given as follows, where \u03c6rc is a closed formula of EILro (Definition 5.2):\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | haii\u03c6 | \u03c6rc\nIn the above definition we write haii\u03c6 rather than hx : aii\u03c6 since \u03c6 is closed and in particular x does\nnot occur free in \u03c6 (Notation 4.6). Also we omit declarations (x : a)\u03c6 since they have no effect when \u03c6\nis closed. Of course declarations can occur in \u03c6rc .\n\n\fA Logic with Reverse Modalities\n\n114\n\nTheorem 5.12. Let C , D be stable configuration structures. Then, C \u2248wh D iff C \u223cEILwh D.\nWe believe that EILwh is the first logic proposed for weak history-preserving bisimulation with autoconcurrency allowed. Goltz et al. [15] described a logic for weak history-preserving bisimulation\nwith no autoconcurrency allowed, but in this case, weak history-preserving bisimulation is as strong as\nhistory-preserving bisimulation [12].\nJust as we weakened EILh to get EILwh we can weaken EIL by requiring that forward transitions\nhx : aii\u03c6 are only allowed if \u03c6 is closed. Again instead of hx : aii\u03c6 we write haii\u03c6 . This gives us EILhwh :\nDefinition 5.13. EILhwh is given below, where \u03c6c ranges over closed formulas of EILhwh .\n\n\u03c6 ::= tt | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 \u2032 | haii\u03c6c | (x : a)\u03c6 | hhxi\u03c6\nPlainly EILwh is a sublogic of EILhwh as well as of EILh .\nTheorem 5.14. Let C , D be stable configuration structures. Then, C \u2248hwh D iff C \u223cEILhwh D.\nWith no (equidepth) autoconcurrency, we know that \u2248hwh is as strong as \u2248hh [3, 31]. So EILhwh is\nas strong as EIL in this case.\n\n6\n\nCharacteristic formulas\n\nIn this section we investigate characteristic formulas for three of the equivalences we have considered,\nnamely HH, H and WH. The idea is that we reduce checking whether C and D satisfy the same formulas\nin a logic such as EIL to the question of whether D satisfies a particular formula \u03c7C , the characteristic\nformula of C , which completely expresses the behaviour of C , at least as far as the particular logic\nis concerned. As pointed out in [1], this means that checking whether two structures are equivalent is\nchanged from the problem of potentially having to check infinitely many formulas into a single modelchecking problem D |= \u03c7C .\nCharacteristic formulas for models of concurrent systems were first investigated in [16], and subsequently in [35] and other papers-see [1] for further references. As far as we are aware, characteristic\nformulas have not previously been investigated for any true concurrency logic, although we should mention that in [1] characteristic formulas are studied for a logic with both forward and reverse modalities,\nrelated to the back and forth simulation of [6].\nWe shall confine ourselves to finite stable configuration structures in this section. Even with this\nassumption, it is not obvious that an equivalence such as HH, which employs both forward and reverse\ntransitions, can be captured by a single finite-depth formula. To show that forward and reverse transitions\nneed not alternate for ever, we first relate HH to a simple game.\nDefinition 6.1. Let C , D be finite stable configuration structures. The game G(C , D) has two players: A\ndf\n(attacker) and D (defender). The set of game states is S(C , D) = {(X ,Y, f ) : X \u2208 CC ,Y \u2208 CD , f : X \u223c\n= Y }.\nThe start state is (0,\n/ 0,\n/ 0).\n/ At each state of the game A chooses a forward (resp. reverse) move e of either\nC or D. Then D must reply with a corresponding forward (resp. reverse) move e\u2032 by the other structure.\nGoing forwards we extend f to f \u2032 and going in reverse we restrict f to f \u2032 , as in the definition of HH. The\ntwo moves produce a new game state (X \u2032 ,Y \u2032 , f \u2032 ). Then D wins if we get to a previously visited state.\nConversely, A wins if D cannot find a move. (Also D wins if A cannot find a move, but that can only\nhappen if both C and D have only the empty configuration.)\nIt is reasonable that D wins if a state is repeated, since if A then chooses a different and better move\nat the repeated state, A could have chosen that on the previous occasion.\n\n\fI.C.C. Phillips & I. Ulidowski\n\n115\ndf\n\nDefinition 6.2. Given finite stable configuration structures C , D, let s(C , D) = |S(C , D)|, let c(C ) =\nmax{|X | : X \u2208 CC }, and let c(C , D) = min{c(C ), c(D)}.\nClearly any play of the game G(C , D) finishes after no more than s(C , D) moves. We can place an\nupper bound on s(C , D) as follows:\nProposition 6.3. Let C , D be finite stable configuration structures. Then s(C , D) \u2264 |CC |.|CD |.c(C , D)!.\nNote that if there is no autoconcurrency, any isomorphism f : X \u223c\n= Y is unique, and so we can improve\nthe upper bound on the number of states to s(C , D) \u2264 |CC |.|CD |.\nProposition 6.4. Let C , D be finite stable configuration structures. Then C \u2248hh D iff defender D has a\nwinning strategy for the game G(C , D).\nRemark 6.5. Certainly game characterisations of HH equivalence have been used many times before; see\ne.g. [9, 10, 11, 22, 17]. However defender is usually said to win if the play continues for ever, whereas\nwe say that defender wins if a state is repeated. This is because we are working with finite configuration\nstructures, rather than, say, Petri nets.\nDefinition 6.6. Let \u03c6 \u2208 EIL. The modal depth md(\u03c6 ) of \u03c6 is defined as follows:\ndf\n\ndf\n\ndf\n\nmd(\u03c6 \u2227 \u03c6 \u2032 ) = max(md(\u03c6 ), md(\u03c6 \u2032 )) md((x : a)\u03c6 ) = md(\u03c6 )\n\nmd(tt) = 0\ndf\n\ndf\n\ndf\n\nmd(\u00ac\u03c6 ) = md(\u03c6 ) md(hx : aii\u03c6 ) = 1 + md(\u03c6 )\n\nmd(hhx : ai\u03c6 ) = 1 + md(\u03c6 )\n\nWe can use the game characterisation of HH to bound the modal depth of EIL formulas needed to\ncheck whether finite structures are HH equivalent:\nTheorem 6.7. Let C , D be finite stable configuration structures. Then C \u2248hh D iff C and D satisfy the\nsame EIL formulas of modal depth no more than s(C , D) + c(C , D).\nWe now define a family of characteristic formulas for HH equivalence, parametrised on modal depth.\nDefinition 6.8. Suppose that Act is finite. Let C be a finite stable configuration structure. We define\nhh (X a configuration of C ) by induction on n:\nformulas \u03c7X,n\ndf\n\nhh\n\u03c7X,0\n= \u03b8X\u2032\ndf\n\nhh\n= \u03b8X\u2032 \u2227 (\n\u03c7X,n+1\n\n^\ne\n\nX \u2192C X \u2032\n\nhze : l(e)ii\u03c7Xhh\u2032 ,n ) \u2227 (\n\n^\n\na\u2208Act\n\n_\n\n[x : a]]\ne\n\nX \u2192C X \u2032 ,l(e)=a\n\n^\n\n\u03c7Xhh\u2032 ,n [x/ze ]) \u2227 (\nX\n\ne\n\nCX\n\nhhze i\u03c7Xhh\u2032 ,n )\n\u2032\n\ndf\n\nhh ) = {z : e \u2208 X }. We further let \u03c7 hh = \u03c7 hh .\nHere \u03b8X\u2032 \u2208 EILdfro is as in Lemma 5.5 and fi(\u03c7X,n\ne\n0,n\n/\nC ,n\nhh \u2208 EIL and md(\u03c7 hh ) \u2264 n + c(C ).\nNote that \u03c7X,n\nX,n\ndf\n\nTheorem 6.9. Suppose that Act is finite. Let C , D be finite stable configuration structures. Let s =\ns(C , D). Then C \u2248hh D iff D |= \u03c7Chh,s .\nThus we do not have a single characteristic formula for C , but we can deal uniformly with all D\nup to a certain size. This is almost as good as having a single characteristic formula for C , since we\ncan generate a formula of the appropriate size once we have settled on D, so that we have still reduced\nequivalence checking to checking a single formula. Single characteristic formulas are certainly possible\nfor some C s; there remains an open question of whether for all finite C there is a single formula \u03c7Chh\nwhich works for all D.\nMatters are simpler for H and WH equivalences, since only forward transitions are employed.\n\n\fA Logic with Reverse Modalities\n\n116\n\nDefinition 6.10. Suppose that Act is finite. Let C be a finite stable configuration structure. We define\nformulas \u03c7Xh (X a configuration of C ) as follows:\ndf\n\n\u03c7Xh = \u03b8X\u2032 \u2227 (\n\n^\n\nhze : l(e)ii\u03c7Xh \u2032 ) \u2227 (\n\ne\n\n^\n\n\u03c7Xh \u2032 [x/ze ])\n\ne\n\na\u2208Act\n\nX \u2192C X \u2032\n\n_\n\n[x : a]]\n\nX \u2192C X \u2032 ,l(e)=a\n\ndf\n\nHere \u03b8X\u2032 \u2208 EILdfro is as in Lemma 5.5. We further let \u03c7Ch = \u03c70/h .\nNote that \u03c7Ch \u2208 EILh ; it is well-defined, since maximal configurations form the base cases of the\nrecursion. Also md(\u03c7Xh ) \u2264 2.c(C ).\nProposition 6.11. Suppose that Act is finite. Let C , D be finite stable configuration structures. Then\nD \u2248h C iff D |= \u03c7Ch .\nWH is even easier as formulas are closed:\nDefinition 6.12. Suppose that Act is finite. Let C be a finite stable configuration structure. We define\nformulas \u03c7Xwh (X a configuration of C ) as follows:\ndf\n\n\u03c7Xwh = \u03b8X \u2227 (\n\n^\n\nhaii\u03c7Xwh\u2032 ) \u2227 (\n\na\n\n^\n\na\u2208Act\n\nX \u2192C X \u2032\n\n[a]]\n\n_\n\n\u03c7Xwh\u2032 )\n\na\n\nX \u2192C X \u2032\n\ndf\n\nHere \u03b8X \u2208 EILro is as in Lemma 5.4. We further let \u03c7Cwh = \u03c70/wh .\nNote that \u03c7Cwh \u2208 EILwh and md(\u03c7Xwh ) \u2264 2.c(C ).\nProposition 6.13. Suppose that Act is finite. Let C , D be finite stable configuration structures. Then\nD \u2248wh C iff D |= \u03c7Cwh .\n\n7\n\nConclusions and future work\n\nWe have introduced a logic which uses event identifiers to track events in both forwards and reverse\ndirections. As we have seen, this enables it to express causality and concurrency between events. The\nlogic is strong enough to characterise hereditary history-preserving (HH) bisimulation equivalence. We\nare also able to characterise weaker equivalences using sublogics. In particular we can characterise weak\nhistory-preserving bisimulation, which has not been done previously as far as we are aware. We also\ninvestigated characteristic formulas for our logic with respect to HH and other equivalences. Again we\nare not aware of previous work on characteristic formulas for logics for true concurrency.\nBaldan and Crafa [2] gave logics for pomset bisimulation and step bisimulation; we have also been\nable to characterise these equivalences in our setting, but we had to omit this material for reasons of\nspace.\nIn future work we would like to (1) investigate general laws which hold for the logic, (2) look at\nsublogics characterising other true concurrency equivalences, including equivalences involving reverse\ntransitions from [3, 31], and (3) answer the open question raised in Section 6 about whether there is a\nsingle characteristic formula for a finite structure with respect to HH equivalence.\nAcknowledgements. We are grateful to Ian Hodkinson and the anonymous referees for helpful comments and suggestions.\n\n\fI.C.C. Phillips & I. Ulidowski\n\n117\n\nReferences\n[1] L. Aceto, A. Ing\u00f3lfsd\u00f3ttir & J. Sack (2009): Characteristic Formulae for Fixed-Point Semantics: A General\nFramework. In: Proceedings 16th International Workshop on Expressiveness in Concurrency, EXPRESS\n2009, Electronic Proceedings in Theoretical Computer Science 8, pp. 1\u201315, doi:10.4204/EPTCS.8.1.\n[2] P. Baldan & S. Crafa (2010): A Logic for True Concurrency. In: Proceedings of 21st International Conference\non Concurrency Theory, CONCUR 2010, Lecture Notes in Computer Science 6269, Springer-Verlag, pp.\n147\u2013161, doi:10.1007/978-3-642-15375-4_11.\n[3] M.A. Bednarczyk (1991): Hereditary history preserving bisimulations or what is the power of the future\nperfect in program logics. Technical Report, Institute of Computer Science, Polish Academy of Sciences,\nGda\u0144sk.\n[4] G. Boudol & I. Castellani (1987): On the semantics of concurrency: partial orders and transition systems.\nIn: Proceedings of TAPSOFT'87, Lecture Notes in Computer Science 249, Springer-Verlag, pp. 123\u2013137,\ndoi:10.1007/3-540-17660-8_52.\n[5] F. Cherief (1992): Back and forth bisimulations on prime event structures. In: Proceedings of\nPARLE '92, Lecture Notes in Computer Science 605, Springer-Verlag, pp. 843\u2013858, doi:10.1007/\n3-540-55599-4_128.\n[6] R. De Nicola, U. Montanari & F. Vaandrager (1990): Back and forth bisimulations. In: Proceedings of\nCONCUR '90, Theories of Concurrency: Unification and Extension, Lecture Notes in Computer Science\n458, Springer-Verlag, pp. 152\u2013165, doi:10.1007/BFb0039058.\n[7] R. De Nicola & F. Vaandrager (1990): Three Logics for Branching Bisimulation (Extended Abstract). In:\nProceedings, Fifth Annual IEEE Symposium on Logic in Computer Science, IEEE, Computer Society Press,\npp. 118\u2013129.\n[8] P. Degano, R. De Nicola & U. Montanari (1987): Observational equivalences for concurrency models. In\nM. Wirsing, editor: Formal Descriptions of Programming Concepts \u2013 III, Proceedings of the 3rd IFIP WG\n2.2 Conference, North-Holland, pp. 105\u2013129.\n[9] S.B. Fr\u00f6schle (1999): Decidability of Plain and Hereditary History-Preserving Bisimilarity for BPP. In:\nProceedings of Express'99, Electronic Notes in Theoretical Computer Science 27, Elsevier, doi:10.1016/\nS1571-0661(05)80297-X.\n[10] S.B. Fr\u00f6schle (2005): Composition and Decomposition in True-Concurrency. In: Foundations of Software\nScience and Computational Structures, 8th International Conference, FOSSACS 2005, Lecture Notes in\nComputer Science 3441, Springer-Verlag, pp. 333\u2013347, doi:10.1007/978-3-540-31982-5_21.\n[11] S.B. Fr\u00f6schle & S. Lasota (2005): Decomposition and Complexity of Hereditary History Preserving Bisimulation on BPP. In: CONCUR 2005, Lecture Notes in Computer Science 3653, Springer-Verlag, pp. 263\u2013277,\ndoi:10.1007/11539452_22.\n[12] R.J. van Glabbeek & U. Goltz (2001): Refinement of actions and equivalence notions for concurrent systems.\nActa Informatica 37(4/5), pp. 229\u2013327, doi:10.1007/s002360000041.\n[13] R.J. van Glabbeek & G.D. Plotkin (1995): Configuration structures. In: Proceedings of 10th Annual IEEE\nSymposium on Logic in Computer Science, LICS 1995, IEEE Computer Society Press, pp. 199\u2013209, doi:10.\n1109/LICS.1995.523257.\n[14] R.J. van Glabbeek & G.D. Plotkin (2009): Configuration structures, event structures and Petri nets. Theoretical Computer Science 410(41), pp. 4111\u20134159, doi:10.1016/j.tcs.2009.06.014.\n[15] U. Goltz, R. Kuiper & W. Penczek (1992): Propositional temporal logics and equivalences. In: Proceedings\nof 3rd International Conference on Concurrency Theory, CONCUR 1992, Lecture Notes in Computer Science\n630, Springer-Verlag, pp. 222\u2013236, doi:10.1007/BFb0084794.\n[16] S. Graf & J. Sifakis (1986): A Modal Characterization of Observational Congruence on Finite Terms of CCS.\nInformation and Control 68(1-3), pp. 125\u2013145, doi:10.1016/S0019-9958(86)80031-6.\n\n\f118\n\nA Logic with Reverse Modalities\n\n[17] J. Gutierrez (2009): Logics and Bisimulation Games for Concurrency, Causality and Conflict. In: Proceedings of the 12th International Conference on Foundations of Software Science and Computation Structures, FOSSACS 09, Lecture Notes in Computer Science 5504, Springer-Verlag, pp. 48\u201362, doi:10.1007/\n978-3-642-00596-1_5.\n[18] J. Gutierrez & J.C. Bradfield (2009): Model-Checking Games for Fixpoint Logics with Partial Order Models.\nIn: Proceedings of the 20th International Conference on Concurrency Theory, CONCUR 2009, Lecture Notes\nin Computer Science 5710, Springer-Verlag, pp. 354\u2013368, doi:10.1007/978-3-642-04081-8_24.\n[19] M.C.B. Hennessy & R. Milner (1985): Algebraic laws for nondeterminism and concurrency. Journal of the\nAssociation for Computing Machinery 32(1), pp. 137\u2013161, doi:10.1145/2455.2460.\n[20] M.C.B. Hennessy & C. Stirling (1985): The power of the future perfect in program logics. Infomation and\nControl 67, pp. 23\u201352, doi:10.1016/S0019-9958(85)80025-5.\n[21] A. Joyal, M. Nielsen & G. Winskel (1996): Bisimulation from Open Maps. Information and Computation\n127(2), pp. 164\u2013185, doi:10.1006/inco.1996.0057.\n[22] M. Jurdzinski, M. Nielsen & J. Srba (2003): Undecidability of domino games and hhp-bisimilarity. Information and Computation 184(2), pp. 343\u2013368, doi:10.1016/S0890-5401(03)00064-6.\n[23] F. Laroussinie, S. Pinchinat & Ph. Schnoebelen (1995): Translations between modal logics of reactive systems. Theoretical Computer Science 140(1), pp. 53\u201371, doi:10.1016/0304-3975(94)00204-V.\n[24] F. Laroussinie & Ph. Schnoebelen (1995): A hierarchy of temporal logics with past. Theoretical Computer\nScience 148, pp. 303\u2013324, doi:10.1016/0304-3975(95)00035-U.\n[25] M. Mukund & P.S. Thiagarajan (1992): A logical characterization of well branching event structures. Theoretical Computer Science 96(1), pp. 35\u201372, doi:10.1016/0304-3975(92)90181-E.\n[26] R. De Nicola & G.L. Ferrari (1990): Observational Logics and Concurrency Models. In: FSTTCS, Lecture\nNotes in Computer Science 472, Springer-Verlag, pp. 301\u2013315, doi:10.1007/3-540-53487-3_53.\n[27] M. Nielsen & C. Clausen (1994): Bisimulation for Models in Concurrency. In: Proceedings of 5th International Conference on Concurrency Theory, CONCUR'94, Lecture Notes in Computer Science 836,\nSpringer-Verlag, pp. 385\u2013400, doi:10.1007/BFb0015021.\n[28] M. Nielsen & C. Clausen (1994): Bisimulation, games, and logic. In: Results and Trends in Theoretical\nComputer Science, Lecture Notes in Computer Science 812, Springer-Verlag, pp. 289\u2013306, doi:10.1007/\n3-540-58131-6_54.\n[29] M. Nielsen & C. Clausen (1995): Games and logics for a noninterleaving bisimulation. Nordic Journal of\nComputing 2(2), pp. 221\u2013249.\n[30] W. Penczek (1995): Branching time and partial order in temporal logics. In: Time and Logic: A Computational Approach, UCL Press Ltd., pp. 179\u2013228.\n[31] I.C.C. Phillips & I. Ulidowski (2011): A Hierarchy of Reverse Bisimulations on Stable Configuration Structures. Mathematical Structures in Computer Science Available at http://www.doc.ic.ac.uk/~iccp/\npapers/hierarchymscs.pdf. To appear.\n[32] S. Pinchinat, F. Laroussinie & Ph. Schnoebelen (1994): Logical characterizations of truly concurrent bisimulation. Technical Report 114, Grenoble.\n[33] L. Pomello (1986): Some equivalence notions for concurrent systems \u2013 An overview. In: Advances in\nPetri Nets 1985, Lecture Notes in Computer Science 222, Springer-Verlag, pp. 381\u2013400, doi:10.1007/\nBFb0016222.\n[34] A. Rabinovich & B.A. Trakhtenbrot (1988): Behavior structures and nets. Fundamenta Informaticae 11(4),\npp. 357\u2013403.\n[35] B. Steffen & A. Ing\u00f3lfsd\u00f3ttir (1994): Characteristic Formulae for Processes with Divergence. Information\nand Computation 110(1), pp. 149\u2013163, doi:10.1006/inco.1994.1028.\n[36] G. Winskel (1987): Event structures. In: Advances in Petri Nets 1986, Lecture Notes in Computer Science\n255, Springer-Verlag, pp. 325\u2013392, doi:10.1007/3-540-17906-2_31.\n\n\f"}