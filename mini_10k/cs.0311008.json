{"id": "http://arxiv.org/abs/cs/0311008v1", "guidislink": true, "updated": "2003-11-08T14:02:47Z", "updated_parsed": [2003, 11, 8, 14, 2, 47, 5, 312, 0], "published": "2003-11-08T14:02:47Z", "published_parsed": [2003, 11, 8, 14, 2, 47, 5, 312, 0], "title": "A Parameterised Hierarchy of Argumentation Semantics for Extended Logic\n  Programming and its Application to the Well-founded Semantics", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0612138%2Ccs%2F0612072%2Ccs%2F0612122%2Ccs%2F0612132%2Ccs%2F0612134%2Ccs%2F0612032%2Ccs%2F0612069%2Ccs%2F0612127%2Ccs%2F0612001%2Ccs%2F0612047%2Ccs%2F0612095%2Ccs%2F0612062%2Ccs%2F0612089%2Ccs%2F0612118%2Ccs%2F0612124%2Ccs%2F0612065%2Ccs%2F0612066%2Ccs%2F0612038%2Ccs%2F0612121%2Ccs%2F0612086%2Ccs%2F0612025%2Ccs%2F0612053%2Ccs%2F0612060%2Ccs%2F0612130%2Ccs%2F0612143%2Ccs%2F0612104%2Ccs%2F0612057%2Ccs%2F0612007%2Ccs%2F0612081%2Ccs%2F0311006%2Ccs%2F0311003%2Ccs%2F0311039%2Ccs%2F0311008%2Ccs%2F0311015%2Ccs%2F0311033%2Ccs%2F0311004%2Ccs%2F0311049%2Ccs%2F0311012%2Ccs%2F0311011%2Ccs%2F0311009%2Ccs%2F0311048%2Ccs%2F0311030%2Ccs%2F0311037%2Ccs%2F0311051%2Ccs%2F0311036%2Ccs%2F0311021%2Ccs%2F0311045%2Ccs%2F0311031%2Ccs%2F0311024%2Ccs%2F0311041%2Ccs%2F0311010%2Ccs%2F0311044%2Ccs%2F0311022%2Ccs%2F0311043%2Ccs%2F0311005%2Ccs%2F0311027%2Ccs%2F0311052%2Ccs%2F0311040%2Ccs%2F0311018%2Ccs%2F0311038%2Ccs%2F0311013%2Ccs%2F0311042%2Ccs%2F0311054%2Ccs%2F0311025%2Ccs%2F0311035%2Ccs%2F0311029%2Ccs%2F0311007%2Ccs%2F0311014%2Ccs%2F0311023%2Ccs%2F0311028%2Ccs%2F0311026%2Ccs%2F0311050%2Ccs%2F0311034%2Ccs%2F0311020%2Ccs%2F0311001%2Ccs%2F0311046%2Ccs%2F0311019%2Ccs%2F0311053%2Ccs%2F0311002%2Ccs%2F0311017%2Ccs%2F0311016%2Ccs%2F0311047%2Ccs%2F0304011%2Ccs%2F0304040%2Ccs%2F0304044%2Ccs%2F0304009%2Ccs%2F0304004%2Ccs%2F0304039%2Ccs%2F0304042%2Ccs%2F0304046%2Ccs%2F0304019%2Ccs%2F0304026%2Ccs%2F0304001%2Ccs%2F0304014%2Ccs%2F0304007%2Ccs%2F0304006%2Ccs%2F0304021%2Ccs%2F0304033%2Ccs%2F0304045%2Ccs%2F0304020%2Ccs%2F0304022&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Parameterised Hierarchy of Argumentation Semantics for Extended Logic\n  Programming and its Application to the Well-founded Semantics"}, "summary": "Argumentation has proved a useful tool in defining formal semantics for\nassumption-based reasoning by viewing a proof as a process in which proponents\nand opponents attack each others arguments by undercuts (attack to an\nargument's premise) and rebuts (attack to an argument's conclusion). In this\npaper, we formulate a variety of notions of attack for extended logic programs\nfrom combinations of undercuts and rebuts and define a general hierarchy of\nargumentation semantics parameterised by the notions of attack chosen by\nproponent and opponent. We prove the equivalence and subset relationships\nbetween the semantics and examine some essential properties concerning\nconsistency and the coherence principle, which relates default negation and\nexplicit negation. Most significantly, we place existing semantics put forward\nin the literature in our hierarchy and identify a particular argumentation\nsemantics for which we prove equivalence to the paraconsistent well-founded\nsemantics with explicit negation, WFSX$_p$. Finally, we present a general proof\ntheory, based on dialogue trees, and show that it is sound and complete with\nrespect to the argumentation semantics.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0612138%2Ccs%2F0612072%2Ccs%2F0612122%2Ccs%2F0612132%2Ccs%2F0612134%2Ccs%2F0612032%2Ccs%2F0612069%2Ccs%2F0612127%2Ccs%2F0612001%2Ccs%2F0612047%2Ccs%2F0612095%2Ccs%2F0612062%2Ccs%2F0612089%2Ccs%2F0612118%2Ccs%2F0612124%2Ccs%2F0612065%2Ccs%2F0612066%2Ccs%2F0612038%2Ccs%2F0612121%2Ccs%2F0612086%2Ccs%2F0612025%2Ccs%2F0612053%2Ccs%2F0612060%2Ccs%2F0612130%2Ccs%2F0612143%2Ccs%2F0612104%2Ccs%2F0612057%2Ccs%2F0612007%2Ccs%2F0612081%2Ccs%2F0311006%2Ccs%2F0311003%2Ccs%2F0311039%2Ccs%2F0311008%2Ccs%2F0311015%2Ccs%2F0311033%2Ccs%2F0311004%2Ccs%2F0311049%2Ccs%2F0311012%2Ccs%2F0311011%2Ccs%2F0311009%2Ccs%2F0311048%2Ccs%2F0311030%2Ccs%2F0311037%2Ccs%2F0311051%2Ccs%2F0311036%2Ccs%2F0311021%2Ccs%2F0311045%2Ccs%2F0311031%2Ccs%2F0311024%2Ccs%2F0311041%2Ccs%2F0311010%2Ccs%2F0311044%2Ccs%2F0311022%2Ccs%2F0311043%2Ccs%2F0311005%2Ccs%2F0311027%2Ccs%2F0311052%2Ccs%2F0311040%2Ccs%2F0311018%2Ccs%2F0311038%2Ccs%2F0311013%2Ccs%2F0311042%2Ccs%2F0311054%2Ccs%2F0311025%2Ccs%2F0311035%2Ccs%2F0311029%2Ccs%2F0311007%2Ccs%2F0311014%2Ccs%2F0311023%2Ccs%2F0311028%2Ccs%2F0311026%2Ccs%2F0311050%2Ccs%2F0311034%2Ccs%2F0311020%2Ccs%2F0311001%2Ccs%2F0311046%2Ccs%2F0311019%2Ccs%2F0311053%2Ccs%2F0311002%2Ccs%2F0311017%2Ccs%2F0311016%2Ccs%2F0311047%2Ccs%2F0304011%2Ccs%2F0304040%2Ccs%2F0304044%2Ccs%2F0304009%2Ccs%2F0304004%2Ccs%2F0304039%2Ccs%2F0304042%2Ccs%2F0304046%2Ccs%2F0304019%2Ccs%2F0304026%2Ccs%2F0304001%2Ccs%2F0304014%2Ccs%2F0304007%2Ccs%2F0304006%2Ccs%2F0304021%2Ccs%2F0304033%2Ccs%2F0304045%2Ccs%2F0304020%2Ccs%2F0304022&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Argumentation has proved a useful tool in defining formal semantics for\nassumption-based reasoning by viewing a proof as a process in which proponents\nand opponents attack each others arguments by undercuts (attack to an\nargument's premise) and rebuts (attack to an argument's conclusion). In this\npaper, we formulate a variety of notions of attack for extended logic programs\nfrom combinations of undercuts and rebuts and define a general hierarchy of\nargumentation semantics parameterised by the notions of attack chosen by\nproponent and opponent. We prove the equivalence and subset relationships\nbetween the semantics and examine some essential properties concerning\nconsistency and the coherence principle, which relates default negation and\nexplicit negation. Most significantly, we place existing semantics put forward\nin the literature in our hierarchy and identify a particular argumentation\nsemantics for which we prove equivalence to the paraconsistent well-founded\nsemantics with explicit negation, WFSX$_p$. Finally, we present a general proof\ntheory, based on dialogue trees, and show that it is sound and complete with\nrespect to the argumentation semantics."}, "authors": ["Ralf Schweimeier", "Michael Schroeder"], "author_detail": {"name": "Michael Schroeder"}, "author": "Michael Schroeder", "arxiv_comment": "To appear in Theory and Practice of Logic Programming", "links": [{"href": "http://arxiv.org/abs/cs/0311008v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0311008v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.1.6.; F.3.2.; F.4.1; I.2.3.; I.2.4", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0311008v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0311008v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:cs/0311008v1 [cs.LO] 8 Nov 2003\n\nUnder consideration for publication in Theory and Practice of Logic Programming\n\n1\n\nA Parameterised Hierarchy of Argumentation\nSemantics for Extended Logic Programming and its\nApplication to the Well-founded Semantics\nRalf Schweimeier and Michael Schroeder\nDepartment of Computing, School of Informatics, City University\nNorthampton Square, London EC1V 0HB, UK\nDepartment of Computer Science, Technische Universit\u00e4t Dresden\n01062 Dresden, Germany\n(e-mail: {ralf,msch}@soi.city.ac.uk)\nsubmitted 4 December 2002; revised 29 June 2003; accepted 12 September 2003\n\nAbstract\nArgumentation has proved a useful tool in defining formal semantics for assumption-based reasoning\nby viewing a proof as a process in which proponents and opponents attack each others arguments by\nundercuts (attack to an argument's premise) and rebuts (attack to an argument's conclusion). In this\npaper, we formulate a variety of notions of attack for extended logic programs from combinations\nof undercuts and rebuts and define a general hierarchy of argumentation semantics parameterised by\nthe notions of attack chosen by proponent and opponent. We prove the equivalence and subset relationships between the semantics and examine some essential properties concerning consistency and\nthe coherence principle, which relates default negation and explicit negation. Most significantly, we\nplace existing semantics put forward in the literature in our hierarchy and identify a particular argumentation semantics for which we prove equivalence to the paraconsistent well-founded semantics\nwith explicit negation, WFSXp . Finally, we present a general proof theory, based on dialogue trees,\nand show that it is sound and complete with respect to the argumentation semantics.\n\nKeywords: Non-monotonic Reasoning, Extended Logic Programming, Argumentation semantics, Well-founded Semantics with Explicit Negation\n\n\f2\n\nRalf Schweimeier and Michael Schroeder\nContents\n\n1 Introduction\n2 Extended Logic Programming and Argumentation\n2.1 Arguments\n2.2 Notions of attack\n2.3 Acceptability and justified arguments\n3 Relationships between Notions of Justifiability\n3.1 Equivalence of argumentation semantics\n3.2 Distinguishing argumentation semantics\n3.3 A hierarchy of argumentation semantics\n4 Properties of Argumentation Semantics\n4.1 The coherence principle\n4.2 Consistency\n5 Argumentation Semantics and WFSX\n5.1 Well-founded semantics with explicit negation\n5.2 Equivalence of argumentation semantics and WFSXp\n6 Proof Theory\n6.1 Dialogue trees\n7 Related Work\n8 Conclusion and Further Work\nReferences\nAppendix A Proofs of Theorems\n\n3\n4\n5\n7\n10\n12\n12\n14\n16\n18\n18\n20\n21\n21\n22\n25\n25\n28\n30\n30\n33\n\n\fA Hierarchy of Argumentation Semantics\n\n3\n\n1 Introduction\nArgumentation has attracted much interest in the area of Artificial Intelligence. On the one\nhand, argumentation is an important way of human interaction and reasoning, and is therefore of interest for research into intelligent agents. Application areas include automated negotiation via argumentation (Parsons et al. 1998; Kraus et al. 1998; Schroeder 1999) and\nlegal reasoning (Prakken and Sartor 1997). On the other hand, argumentation provides a\nformal model for various assumption based (or non-monotonic, or default) reasoning formalisms (Bondarenko et al. 1997; Ches\u00f1evar et al. 2000). In particular, various argumentation based semantics have been proposed for logic programming with default negation (Bondarenko et al. 1997; Dung 1995).\nArgumentation semantics are elegant since they can be captured in an abstract framework (Dung 1995; Bondarenko et al. 1997; Vreeswijk 1997; Jakobovits and Vermeir 1999b),\nfor which an elegant theory of attack, defence, acceptability, and other notions can be developed, without recourse to the concrete instance of the reasoning formalism at hand. This\nframework can then be instantiated to various assumption based reasoning formalisms.\nSimilarly, a dialectical proof theory, based on dialogue trees, can be defined for an abstract\nargumentation framework, and then applied to any instance of such a framework (Simari et al. 1994;\nDung 1995; Jakobovits and Vermeir 1999a).\nIn general, an argument A is a proof which may use a set of defeasible assumptions.\nAnother argument B may have a conclusion which contradicts the assumptions or the conclusions of A, and thereby B attacks A. There are two fundamental notions of such attacks:\nundercut and rebut (Pollock 1987; Prakken and Sartor 1997) or equivalently ground-attack\nand reductio-ad-absurdum attack (Dung 1993). We will use the terminology of undercuts\nand rebuts. Both attacks differ in that an undercut attacks a premise of an argument, while\na rebut attacks a conclusion.\nGiven a logic program we can define an argumentation semantics by iteratively collecting those arguments which are acceptable to a proponent, i.e. they can be defended against\nall opponent attacks. In fact, such a notion of acceptability can be defined in a number of\nways depending on which attacks we allow the proponent and opponent to use.\nNormal logic programs do not have negative conclusions, which means that we cannot\nuse rebuts. Thus both opponents can only launch undercuts on each other's assumptions.\nVarious argumentation semantics have been defined for normal logic programs (Bondarenko et al. 1997;\nDung 1995; Kakas and Toni 1999), some of which are equivalent to existing semantics\nsuch as the stable model semantics (Gelfond and Lifschitz 1988) or the well-founded semantics (van Gelder et al. 1991).\nExtended logic programs (Gelfond and Lifschitz 1990; Alferes and Pereira 1996; Wagner 1994),\non the other hand, introduce explicit negation, which states that a literal is explicitly false.\nAs a result, both undercuts and rebuts are possible forms of attack; there are further variations depending on whether any kind of counter-attack is admitted. A variety of argumentation semantics arise if one allows one notion of attack as defence for the proponent, and another as attack for the opponent. Various argumentation semantics have been proposed for\nextended logic programs (Dung 1993; Prakken and Sartor 1997; M\u00f3ra and Alferes 1998;\n?). Dung has shown that a certain argumentation semantics is equivalent to the answer\nset semantics (Gelfond and Lifschitz 1990), a generalisation of the stable model seman-\n\n\f4\n\nRalf Schweimeier and Michael Schroeder\n\ntics (Gelfond and Lifschitz 1988). For the well-founded semantics with explicit negation,\nWFSX (Pereira and Alferes 1992; Alferes and Pereira 1996), there exists a scenario semantics (Alferes et al. 1993) which is similar to an argumentation semantics. This semantics applies only to non-contradictory programs; to our knowledge, no argumentation semantics has yet been found equivalent to the paraconsistent well-founded semantics with\nexplicit negation, WFSXp (Dam\u00e1sio 1996; Alferes et al. 1995; Alferes and Pereira 1996).\nThis paper makes the following contributions: we identify various notions of attack for\nextended logic programs. We set up a general framework of argumentation semantics, parameterised on these notions of attacks. This framework is then used to classify notions of\njustified arguments, and to compare them to the argumentation semantics of (Dung 1993)\nand (Prakken and Sartor 1997), among others. We examine some properties of the different semantics, concerning consistency, and the coherence principle which relates explicit\nand implicit negation. One particular argumentation semantics is then shown to be equivalent to the paraconsistent well-founded semantics with explicit negation (Dam\u00e1sio 1996).\nFinally, we develop a general dialectical proof theory for the notions of justified arguments\nwe introduce, and show how proof procedures for these proof theories can be derived. This\npaper builds upon an earlier conference publication (Schweimeier and Schroeder 2002),\nwhich reports initial findings, while this article provides detailed coverage including all\nproofs and detailed examples.\nThe paper is organised as follows: First we define arguments and notions of attack and\nacceptability. Then we set up a framework for classifying different least fixpoint argumentation semantics, based on different notions of attack. Section 4 examines some properties\n(coherence and consistency) of these semantics. In Section 5, we recall the definition of\nWFSXp , and prove the equivalence of an argumentation semantics and WFSXp . A general\ndialectical proof theory for arguments is presented in Section 6; we prove its soundness\nand completeness and outline how a proof procedure for the proof theory may be derived.\n2 Extended Logic Programming and Argumentation\nWe introduce extended logic programming and summarise the definitions of arguments\nassociated with extended logic programs. We identify various notions of attack between\narguments, and define a variety of semantics parametrised on these notions of attack.\nExtended logic programming extends logic programming by two kinds of negation: default negation and explicit negation. The former allows the assumption of the falsity of a\nfact if there is no evidence for this fact. Explicit negation, on the other hand, allows to\nexplicitly assert the falsity of a fact.\nThe default negation of a literal p, written not p, states the assumption of the falsity of\np. The assumption not p is intended to be true iff there is no evidence of p. Thus, the truth\nof not p relies on a lack of knowledge about p. An operational interpretation of default\nnegation is given by negation as failure (Clark 1978): the query not p succeeds iff the\nquery p fails. Default negation is usually not allowed in the head of a rule: the truth value\nof not p is defined in terms of p, and so there should not be any other rules that define\nnot p.\nDefault negation thus gives a way of expressing a kind of negation, based on a lack of\nknowledge about a fact. Sometimes, however, it is desirable to express the explicit knowl-\n\n\fA Hierarchy of Argumentation Semantics\n\n5\n\nedge of the falsity of a fact. The explicit negation \u00acp of a literal p states that p is known to\nbe false. In contrast to default negation, an explicit negation \u00acp is allowed in the head of a\nrule, and there is no other way of deriving \u00acp except by finding an applicable rule with \u00acp\nas its consequence.\nConsider the following example 1 : \"A school bus may cross the railway tracks under the\ncondition that there is no approaching train.\" It may be expressed using default negation as\ncross \u2190 not train\nThis is a dangerous statement, however: assume that there is no knowledge about an approaching train, e.g. because the driver's view is blocked. In this case, the default negation\nnot train is true, and we conclude that the bus may cross. Instead, it would be appropriate\nto demand the explicit knowledge that there is no approaching train, as expressed using\nexplicit negation:\ncross \u2190 \u00actrain\nThe combination of default and explicit negation also allows for a more cautious statement\nof positive facts: while the rule\n\u00accross \u2190 train\nstates that the driver should not cross if there is a train approaching, the rule\n\u00accross \u2190 not \u00actrain\nstates more cautiously that the driver should not cross if it has not been established that\nthere is no train approaching. In contrast to the former rule, the latter rule prevents a driver\nfrom crossing if there is no knowledge about approaching trains.\nA connection between the two kind of negations may be made by asserting the coherence\nprinciple (Pereira and Alferes 1992; Alferes and Pereira 1996): it states that whenever an\nexplicit negation \u00acp is true, then the default negation not p is also true. This corresponds\nto the statement that if something is known to be false, then it should also be assumed to\nbe false.\n2.1 Arguments\nDefinition 1\nAn objective literal is an atom A or its explicit negation \u00acA. We define \u00ac\u00acL = L. A\ndefault literal is of the form not L where L is an objective literal. A literal is either an\nobjective or a default literal.\nAn extended logic program is a (possibly infinite) set of rules of the form\nL0 \u2190 L1 , . . . , Lm , not Lm+1 , . . . , not Lm+n (m, n \u2265 0),\nwhere each Li is an objective literal (0 \u2264 i \u2264 m + n). For such a rule r, we call L0 the\nhead of the rule, head(r), and L1 , . . . , not Lm+n the body of the rule, body(r). A rule\nwith an empty body is called a fact, and we write L0 instead of L0 \u2190.\nOur definition of an argument associated with an extended logic program is based on (Prakken and Sartor 1997).\n1\n\nDue to John McCarthy, first published in (Gelfond and Lifschitz 1990)\n\n\f6\n\nRalf Schweimeier and Michael Schroeder\n\nEssentially, an argument is a partial proof, resting on a number of assumptions, i.e. a set of\ndefault literals.2 Note that we do not consider priorities of rules, as used e.g. in (Antoniou 2002;\nKakas and Moraitis 2002; Prakken and Sartor 1997; Brewka 1996; Garc\u0131\u0301a et al. 1998; Vreeswijk 1997).\nAlso, we do not distinguish between strict rules, which may not be attacked, and defeasible rules, which may be attacked (Prakken and Sartor 1997; Simari and Loui 1992;\nGarc\u0131\u0301a et al. 1998).\nDefinition 2\nLet P be an extended logic program. An argument associated with P is a finite sequence\nA = [r1 , . . . rn ] of ground instances of rules ri \u2208 P such that for every 1 \u2264 i \u2264 n, for\nevery objective literal Lj in the body of ri there is a k > i such that head(rk ) = Lj .\nA subargument of A is a subsequence of A which is an argument. The head of a rule in A\nis called a conclusion of A, and a default literal not L in the body of a rule of A is called\nan assumption of A. We write assm(A) for the set of assumptions and conc(A) for the set\nof conclusions of an argument A.\nAn argument A with a conclusion L is a minimal argument for L if there is no subargument of A with conclusion L. An argument is minimal if it is minimal for some literal L.\nGiven an extended logic program P , we denote the set of minimal arguments associated\nwith P by Args P .\nThe restriction to minimal arguments (cf. (Simari and Loui 1992)) is not essential, but\nconvenient, since it rules out arguments constructed from several unrelated arguments.\nGenerally, one is interested in the conclusions of an argument, and wants to avoid having rules in an argument which do not contribute to the desired conclusion. Furthermore,\nwhen designing a proof procedure to compute justified arguments, one generally wants to\ncompute only minimal arguments, for reasons of efficiency.\nExample 1\nConsider the following program:\n\u00accross\ncross\ntrain\n\u00actrain\nwear glasses\n\n\u2190\n\u2190\n\u2190\n\u2190\n\nnot \u00actrain\n\u00actrain\nsee train\nnot train, wear glasses\n\nThe program models the example from the introduction to this section. A bus is allowed to\ncross the railway tracks if it is known that there is no train approaching; otherwise, it is not\nallowed to cross. A train is approaching if the driver can see the train, and it is known that\nthere is no train approaching if there is no evidence of a train approaching, and the driver\nis wearing glasses.\nThere is exactly one minimal argument with conclusion cross:\n[cross \u2190 \u00actrain; \u00actrain \u2190 not train, wear glasses; wear glasses]\n2\n\nIn (Bondarenko et al. 1997; Dung 1993), an argument is a set of assumptions; the two approaches are equivalent in that there is an argument with a conclusion L iff there is a set of assumptions from which L can be\ninferred. See the discussion in (Prakken and Sartor 1997).\n\n\fA Hierarchy of Argumentation Semantics\n\n7\n\nIt contains as subarguments the only minimal arguments for \u00actrain and wear glasses:\n[\u00actrain \u2190 not train, wear glasses]\n[wear glasses]\nThere is also exactly one minimal argument with conclusion \u00accross:\n[\u00accross \u2190 not \u00actrain]\nThere is no argument with conclusion train, because there is no rule for see train.\n2.2 Notions of attack\nThere are two fundamental notions of attack: undercut, which invalidates an assumption\nof an argument, and rebut, which contradicts a conclusion of an argument (Dung 1993;\nPrakken and Sartor 1997). From these, we may define further notions of attack, by allowing\neither of the two fundamental kinds of attack, and considering whether any kind of counterattack is allowed or not. We will now formally define these notions of attack.\nDefinition 3\nLet A1 and A2 be arguments.\n1. A1 undercuts A2 if there is an objective literal L such that L is a conclusion\nof A1 and not L is an assumption of A2 .\n2. A1 rebuts A2 if there is an objective literal L such that L is a conclusion of\nA1 and \u00acL is a conclusion of A2 .\n3. A1 attacks A2 if A1 undercuts or rebuts A2 .\n4. A1 defeats A2 if\n\u2022 A1 undercuts A2 , or\n\u2022 A1 rebuts A2 and A2 does not undercut A1 .\n5. A1 strongly attacks A2 if A1 attacks A2 and A2 does not undercut A1 .\n6. A1 strongly undercuts A2 if A1 undercuts A2 and A2 does not undercut A1 .\nThe notions of undercut and rebut, and hence attack are fundamental for extended logic\nprograms (Dung 1993; Prakken and Sartor 1997). The notion of defeat is used in (Prakken and Sartor 1997),\nalong with a notion of strict defeat, i.e. a defeat that is not counter-defeated. For arguments\nwithout priorities, rebuts are symmetrical, and therefore strict defeat coincides with strict\nundercut, i.e. an undercut that is not counter-undercut. For this reason, we use the term\nstrong undercut instead of strict undercut, and similarly define strong attack to be an attack\nwhich is not counter-undercut. We will use the following abbreviations for these notions\nof attack. r for rebuts, u for undercuts, a for attacks, d for defeats, sa for strongly attacks,\nand su for strongly undercuts.\nExample 2\nConsider the program of example 1. There are the following minimal arguments:\nA:\nB:\nC:\nD:\n\n[cross \u2190 \u00actrain; \u00actrain \u2190 not train, wear glasses; wear glasses]\n[\u00accross \u2190 not \u00actrain]\n[\u00actrain \u2190 not train, wear glasses]\n[wear glasses]\n\n\f8\n\nRalf Schweimeier and Michael Schroeder\n\nThe argument A and B rebut each other. The subargument C of A also undercuts B, so\nA also undercuts B. Therefore A strongly attacks B, while B does not strongly attack or\ndefeat A.\n\nExample 3\nThe arguments [q \u2190 not p] and [p \u2190 not q] undercut each other. As a result, they do not\nstrongly undercut each other.\nThe arguments [p \u2190 not q] and [\u00acp \u2190 not r] do not undercut each other, but strongly\nattack each other.\nThe argument [\u00acp \u2190 not r] strongly undercuts [p \u2190 not \u00acp] and [p \u2190 not \u00acp] attacks\n- but does not defeat - the argument [\u00acp \u2190 not r].\nThese notions of attack define for any extended logic program a binary relation on the\nset of arguments associated with that program.\nDefinition 4\nA notion of attack is a function x which assigns to each extended logic program P a binary\nrelation xP on the set of arguments associated with P , i.e. xP \u2286 Args P \u00d7 Args P . Notions\nof attack are partially ordered by defining x \u2286 y iff \u2200P : xP \u2286 yP\nNotation We will use sans-serif font for the specific notions of attack introduced in Definition 3 and their abbreviations: r, u, a, d, sa, and su. We will use x, y, z, . . . to denote\nvariables for notions of attacks. Arguments are denoted by A, B, C, . . .\nThe term \"attack\" is somewhat overloaded: 1. it is the notion of attack a consisting\nof a rebut or an undercut; we use this terminology because it is standard in the literature (Dung 1993; Prakken and Sartor 1997). 2. in general, an attack is a binary relation\non the set of arguments of a program; we use the term \"notion of attack\". 3. if the argumentation process is viewed as a dialogue between an proponent who puts forward an\nargument, and an opponent who tries to dismiss it, we may choose one notion of attack\nfor the use of the proponent, and another notion of attack for the opponent. In such a setting, we call the former notion of attack the \"defence\", and refer to the latter as \"attack\",\nin the hope that the meaning of the term \"attack\" will be clear from the context.\n\nDefinition 5\nLet x be a notion of attack. Then the inverse of x, denoted by x\u22121 , is defined as x\u22121\nP =\n{(B, A) | (A, B) \u2208 xP }.\nIn this relational notation, Definition 3 can be rewritten as a = u \u222a r, d = u \u222a (r \u2212 u\u22121 ),\nsa = (u \u222a r) \u2212 u\u22121 , and su = u \u2212 u\u22121 .\nProposition 1\nThe notions of attack of Definition 3 are partially ordered according to the diagram in\nFigure 1.\n\n\fA Hierarchy of Argumentation Semantics\n\n9\n\nattacks = a = u \u222a r\n\ndefeats = d = u \u222a (r \u2212 u\u22121 )\n\nVVVV\nVVVV\nVVVV\n\niii\niiii\ni\ni\ni\niii\n\nstrongly attacks = sa = (u \u222a r) \u2212 u\u22121\n\nundercuts = u\n\nUUUU\nUUUU\nUUUU\n\niiii\niiii\ni\ni\ni\ni\n\nstrongly undercuts = su = u \u2212 u\u22121\n\nFig. 1. Notions of Attack\nProof\nA simple exercise, using the set-theoretic laws A \u2212 B \u2286 A \u2286 A \u222a C and (A \u222a B) \u2212 C =\n(A \u2212 C) \u222a (B \u2212 C) (for any arbitrary sets A, B, and C).\nAs mentioned above, we will work with notions of attack as examined in previous literature. Therefore Figure 1 contains the notions of undercut (Dung 1993; Prakken and Sartor 1997),\nattack (Dung 1993; Prakken and Sartor 1997), defeat (Prakken and Sartor 1997), strong\nundercut (Prakken and Sartor 1997), and strong attack as an intermediate notion between\nstrongly undercuts and defeats. All of these notions of attack are extensions of undercuts. The reason is that undercuts are asymmetric, i.e. for two arguments A, B, AuB\ndoes not necessarily imply BuA. Rebuts, on the other hand, are symmetric, i.e. ArB implies BrA. As a consequence, rebuts on their own always lead to a \"draw\" between arguments. There is, however, a lot of work on priorities between arguments (Antoniou 2002;\nKakas and Moraitis 2002; Prakken and Sartor 1997; Brewka 1996; Garc\u0131\u0301a et al. 1998; Vreeswijk 1997),\nwhich implies that rebuts become asymmetric and therefore lead to more interesting semantics. But the original, more basic approach does not consider this extension, and hence\nundercuts play the prime role and notions of attack mainly based on rebuts, such as r or\nr \u2212 u\u22121 , are not considered.\nThe following example shows that the inclusions in Figure 1 are strict.\nExample 4\nConsider the following program:\np\np\n\u00acp\nq\n\u00acq\n\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\nnot \u00acp\nnot q\nnot r\nnot p\nnot s\n\nIt has the minimal arguments {[p \u2190 not \u00acp], [p \u2190 not q], [\u00acp \u2190 not r], [q \u2190 not p], [\u00ac q \u2190\nnot s]}. The arguments [p \u2190 not q] and [q \u2190 not p] undercut (and hence defeat) each\nother, but they do not strongly undercut or strongly attack each other. The arguments\n[q \u2190 not r] and [\u00acq \u2190 not s] strongly attack (and hence defeat) each other, but they\n\n\f10\n\nRalf Schweimeier and Michael Schroeder\n\ndo not undercut each other. The argument [p \u2190 not \u00acp] attacks [\u00acp \u2190 not r], but it does\nnot defeat it, because [\u00acp \u2190 not r] (strongly) undercuts [p \u2190 not \u00acp].\n2.3 Acceptability and justified arguments\nGiven the above notions of attack, we define acceptability of an argument. Basically, an\nargument is acceptable if it can be defended against any attack. Our definition of acceptability is parametrised on the notions of attack allowed for the proponent and the opponent.\nAcceptability forms the basis for our argumentation semantics, which is defined as\nthe least fixpoint of a function, which collects all acceptable arguments (Pollock 1987;\nSimari and Loui 1992; Prakken and Sartor 1997; Dung 1993). The least fixpoint is of particular interest, because it provides a canonical fixpoint semantics and it can be constructed\ninductively.\nBecause the semantics is based on parametrised acceptability, we obtain a uniform\nframework for defining a variety of argumentation semantics for extended logic programs.\nIt can be instantiated to a particular semantics by choosing one notion of attack for the\nopponent, and another notion of attack as a defence for the proponent. The uniformity\nof the definition makes it a convenient framework for comparing different argumentation\nsemantics.\nDefinition 6\nLet x and y be notions of attack. Let A be an argument, and S a set of arguments. Then\nA is x/y-acceptable wrt. S if for every argument B such that (B, A) \u2208 x there exists an\nargument C \u2208 S such that (C, B) \u2208 y.\nBased on the notion of acceptability, we can then define a fixpoint semantics for arguments.\nDefinition 7\nLet x and y be notions of attack, and P an extended logic program. The operator FP,x/y :\nP(Args P ) \u2192 P(Args P ) is defined as\nFP,x/y (S) = {A | A is x/y-acceptable wrt. S}\nWe denote the least fixpoint of FP,x/y by JP,x/y . If the program P is clear from the context,\nwe omit the subscript P . An argument A is called x/y-justified if A \u2208 Jx/y ; an argument\nis called x/y-overruled if it is attacked by an x/y-justified argument; and an argument is\ncalled x/y-defensible if it is neither x/y-justified nor x/y-overruled.\nNote that this definition implies that the logic associated with justified arguments is 3valued, with justified arguments corresponding to true literals, overruled arguments to false\nliterals, and defensible arguments to undefined literals. We could also consider arguments\nwhich are both justified and overruled; these correspond to literals with the truth value\noverdetermined of Belnap's four-valued logic (Belnap 1977).\nProposition 2\nFor any program P , the operator FP,x/y is monotone. By the Knaster-Tarski fixpoint theorem (Tarski 1955; Birkhoff 1967), FP,x/y has a least fixpoint. It can be constructed by\ntransfinite induction as follows:\n\n\fA Hierarchy of Argumentation Semantics\nu/a\nu/d\nu/sa\n\n=\n=\n\nsa/sa =\nsa/su\n\n11\n\nsa/a\nsa/d\nsa/u\n\n=\n=\n\na/x\n\nd/x\n\nu/u =\nu/su\n\n1\n\n\u2205\n\n[s]\n\n[s]\n\n[s]\n\n2\n\n\u2205\n\n\u2205\n\n[\u00acq \u2190 not r]\n\n[\u00acq \u2190 not r]\n\n\u2205\n\n[\u00acq \u2190 not r]\n\n[\u00acq \u2190 not r]\n\n3\n\n\u2205\n\n\u2205\n\n\u2205\n\n[p \u2190 not q]\n\n\u2205\n\n\u2205\n\n\u2205\n\n4\n\n\u2205\n\n\u2205\n\n\u2205\n\n\u2205\n\n\u2205\n\n\u2205\n\n\u2205\n\n[p \u2190 not q], [p \u2190 not q],\n[s]\n[s]\n\nsu/x\n\n[p \u2190 not q],\n[q \u2190 not p],\n[s]\n\nTable 1. Computing justified arguments \u2013 the n-th row shows the justified arguments\nadded at the n-th iteration\n0\nJx/y\n:= \u2205\n\u03b1+1\n\u03b1\nJx/y\n:= FP,x/y (Jx/y\n)\nS\n\u03bb\n\u03b1\nJx/y\n:= \u03b1<\u03bb Jx/y\n\nfor \u03b1+1 a successor ordinal\nfor \u03bb a limit ordinal\n\n\u03bb0\n\u03bb0\n=: Jx/y .\n) = Jx/y\nThen there exists a least ordinal \u03bb0 such that Fx/y (Jx/y\n\nProof\nLet S1 \u2286 S2 , and A \u2208 FP,x/y , i.e. A is x/y-acceptable wrt. S1 , i.e. every x-attack against\nA is y-attacked by an argument in S1 . Then A is also x/y-acceptable wrt. S2 , because\nS1 \u2286 S2 , i.e. S2 contains more arguments to defend A.\nNote that our general framework encompasses some well-known argumentation semantics for extended logic programs: Dung's grounded semantics (Dung 1993) is Ja/u .\nPrakken and Sartor's argumentation semantics (Prakken and Sartor 1997), without priorities or strict rules is Jd/su . If we regard explicitly negated literals \u00acL as new atoms, unrelated to the positive literal L, then we can apply the well-founded argumentation semantics\nof (Bondarenko et al. 1997; Kakas and Toni 1999) to extended logic programs, and obtain\nJu/u .\nExample 5\nConsider the following program P :\np\nq\n\u00acq\nr\ns\n\u00acs\n\n\u2190\n\u2190\n\u2190\n\u2190\n\nnot q\nnot p\nnot r\nnot s\n\n\u2190 not s\n\nTable 1 shows the computation of justified arguments associated with P . The columns\nshow various combinations x/y of attack/defence, and a row n shows those arguments A\nn\u22121\nn\nthat get added at iteration stage n, i.e. A \u2208 JP,x/y\nand A 6\u2208 JP,x/y\n.\n\n\f12\n\nRalf Schweimeier and Michael Schroeder\n\nThe set of arguments associated with P is {[p \u2190 not q], [q \u2190 not p], [\u00acq \u2190 not r], [r \u2190\nnot s], [s], [\u00acs \u2190 not s]}.\nAll arguments are undercut by another argument, except [s]; the only attack against [s] is\na rebut by [\u00acs \u2190 not s], which is not a defeat. Thus, [s] is identified as a justified argument\nat stage 0 in all semantics, except if attacks is allowed as an attack. In the latter case, no\nargument is justified at stage 0, hence the set of justified arguments Ja/x is empty.\n3 Relationships between Notions of Justifiability\nThe definition of justified arguments provides a variety of semantics for extended logic\nprograms, depending on which notion of attack x is admitted to attack an argument, and\nwhich notion of attack y may be used as a defence.\nThis section is devoted to an analysis of the relationship between the different notions\nof justifiability, leading to a hierarchy of notions of justifiability illustrated in Figure 2.\n3.1 Equivalence of argumentation semantics\nWe will prove a series of theorems, which show that some of the argumentation semantics\ndefined above are subsumed by others, and that some of them are actually equivalent. Thus,\nwe establish a hierarchy of argumentation semantics, which is illustrated in Figure 2.\nFirst of all, it is easy to see that the least fixpoint increases if we weaken the attacks or\nstrengthen the defence.\nTheorem 3\nLet x\u2032 \u2286 x and y \u2286 y \u2032 be notions of attack, then Jx/y \u2286 Jx\u2032 /y\u2032 .\nProof\nSee Appendix A.\nTheorem 4 states that it does not make a difference if we allow only the strong version\nof the defence. This is because an argument need not defend itself on its own, but it may\nrely on other arguments to defend it.\nTheorem 4\nLet x and and y be notions of attack such that x \u2287 undercuts, and let sy = y\u2212undercuts\u22121 .\nThen Jx/y = Jx/sy .\nProof\nInformally, every x-attack B to an x/y-justified argument A is y-defended by some x/syjustified argument C (by induction). Now if C is not a sy-attack, then it is undercut by B,\nand because x \u2287 undercuts and C is justified, there exists a strong defence for C against\nB, which is also a defence of the original argument A against C.\nThe formal proof is by transfinite induction. By Theorem 3, we have Jx/sy \u2286 Jx/y . We\n\u03b1\n\u03b1\nprove the inverse inclusion by showing that for all ordinals \u03b1: Jx/y\n\u2286 Jx/sy\n, by transfinite\ninduction on \u03b1. See Appendix A for the detailed proof.\n\n\fA Hierarchy of Argumentation Semantics\n\n13\n\nIn particular, the previous Theorem states that undercut and strong undercut are equivalent as a defence, as are attack and strong attack. This may be useful in an implementation,\nwhere we may use the stronger notion of defence without changing the semantics, thereby\ndecreasing the number of arguments to be checked. The following Corollary shows that\nbecause defeat lies between attack and strong attack, it is equivalent to both as a defence.\nCorollary 5\nLet x be a notion of attack such that x \u2287 undercuts. Then Jx/a = Jx/d = Jx/sa .\n\nProof\nIt follows from Theorems 3 and 4 that Jx/sa \u2286 Jx/d \u2286 Jx/a = Jx/sa .\nThe following theorem states that defence with undercuts is equally strong as one with\ndefeats or with attacks, provided the opponent's permitted attacks include at least the\nstrong attacks.\nTheorem 6\nLet x be a notion of attack such that x \u2287 strongly attacks. Then Jx/u = Jx/d = Jx/a .\n\nProof\nIt is sufficient to show that Jx/a \u2286 Jx/u . Then by Theorem 3, Jx/u \u2286 Jx/d \u2286 Jx/a = Jx/u .\nInformally, every x-attack B to a x/a-justified argument A is attacked by some x/ujustified argument C (by induction). If C is a rebut, but not an undercut, then because\nB strongly attacks C, and because x \u2287 strongly attacks, there must have been an argument defending C by undercutting B, thereby also defending A against B.\n\u03b1\n\u03b1\nWe prove by transfinite induction that for all ordinals \u03b1: Jx/a\n\u2286 Jx/u\n. See Appendix A for\nthe detailed proof.\n\nIn analogy to Theorem 6, strong undercuts are an equivalent defence to strong attacks if\nthe allowed attacks are strong attacks.\nTheorem 7\nJsa/su = Jsa/sa\n\nProof\nThe proof is similar to the proof of Theorem 6. See Appendix A.\n\nTheorem 8\nJsu/a = Jsu/d\n\n\f14\n\nRalf Schweimeier and Michael Schroeder\n\nProof\nBy Theorem 3, Jsu/d \u2286 Jsu/a .\nWe now show the inverse inclusion. Informally, every strong undercut B to a su/a-justified\nargument A is attacked by some su/d-justified argument C (by induction). If C does not\ndefeat A, then there is some argument D defending C by defeating B, thereby also defending A against B.\n\u03b1\n\u03b1\nFormally, we show that for all ordinals \u03b1: Jsu/a\n\u2286 Jsu/d\n, by transfinite induction on \u03b1. See\nAppendix A for the detailed proof.\n\nThese results are summarised in a hierarchy of argumentation semantics in Theorem 9\nand Figure 2.\n\n3.2 Distinguishing argumentation semantics\nThe previous section showed equality and subset relationships for a host of notions of justified arguments. In this section we complement these positive findings by negative findings\nstating for which semantics there are no subset relationships. We prove these negative\nstatements by giving counter-examples distinguishing various notions of justifiability.\nThe first example shows that, in general, allowing only strong forms of attack for the\nopponent leads to a more credulous semantics, because in cases where only non-strong\nattacks exist, every argument is justified.\nExample 6\nConsider the following program:\np\nq\n\n\u2190 not q\n\u2190 not p\n\nFor any notion of attack x, we have Jsu/x = Jsa/x = {[p \u2190 not q], [q \u2190 not p]},\nbecause there is no strong undercut or strong attack to any of the arguments. However,\nJa/x = Jd/x = Ju/x = \u2205, because every argument is undercut (and therefore defeated and\nattacked).\nThus, in general, Js/x 6\u2286 Jw/y , for s \u2208 {su, sa}, w \u2208 {a, u, d}, and any notions of attack\nx and y.\nThe following example shows that some interesting properties need not hold for all\nargumentation semantics: a fact (i.e. a rule with an empty body) need not necessarily lead\nto a justified argument; this property distinguishes Dung's (Dung 1993) and Prakken and\nSartor's (Prakken and Sartor 1997) semantics from most of the others.\nExample 7\nConsider the following program:\np\nq\n\u00acp\n\n\u2190 not q\n\u2190 not p\n\n\fA Hierarchy of Argumentation Semantics\n\n15\n\nLet x be a notion of attack. Then Jd/x = Ja/x = \u2205, because every argument is defeated\n(hence attacked). Jsa/su = Jsa/sa = {[q \u2190 not p]}, because [q \u2190 not p] is the only\nargument which is not strongly attacked, but it does not strongly attack any other argument.\nJu/su = Ju/u = {[\u00acp]}, because there is no undercut to [\u00acp], but [\u00acp] does not undercut\nany other argument. Ju/a = {[\u00acp], [q \u2190 not p]}, because there is no undercut to [\u00acp],\nand the undercut [p \u2190 not p] to [q \u2190 not p] is attacked by [\u00acp]. We also have Jsa/u =\n{[\u00acp], [q \u2190 not p]}, because [q \u2190 not p] is not strongly attacked, and the strong attack\n[p \u2190 not q] on [\u00acp] is undercut by [q \u2190 not p].\nThus, in general, Ju/x 6\u2286 Jd/x , Ju/x 6\u2286 Ja/x , Jsa/sx 6\u2286 Ju/y (where sx \u2208 {su, sa} and\ny \u2208 {u, su}), and Ju/y 6\u2286 Jsa/sx (where sx \u2208 {su, sa} and y \u2208 {u, a, d, su, sa}).\nThe following example is similar to the previous example, except that all the undercuts\nare strong, whereas in the previous example there were only non-strong undercuts.\nExample 8\nConsider the following program:\np\nq\nr\ns\n\u00acp\n\n\u2190\n\u2190\n\u2190\n\u2190\n\nnot q\nnot r\nnot s\nnot p\n\nLet x be a notion of attack. Then Jsa/x = \u2205, because every argument is strongly attacked.\nJsu/u = Jsu/su = {[\u00acp]}, because all arguments except [\u00acp] are strongly undercut,\nbut [\u00acp] does not undercut any argument. And Ju/a = Jsu/sa = Jsu/a = {[\u00acp], [q \u2190\nnot r], [s \u2190 not p]}, because [\u00acp] is not undercut, and it defends [s \u2190 not p] against the\nstrong undercut [p \u2190 not q] (by rebut), and in turn, [s \u2190 not p] defends [q \u2190 not r]\nagainst the strong undercut [r \u2190 not s] (by strong undercut).\nThus, Ju/a 6\u2286 Jsu/y , Jsu/sa 6\u2286 Jsu/y , and Jsu/a 6\u2286 Jsu/y , for y \u2208 {u, su}.\nThe following example shows that in certain circumstances, non-strong defence allows\nfor more justified arguments than strong defence.\nExample 9\nConsider the following program:\np\nq\nr\n\n\u2190 not q\n\u2190 not p\n\u2190 not p\n\nLet x be a notion of attack. Then Ju/x = Jd/x = Ja/x = \u2205, because every argument is\nundercut. Jsu/su = Jsu/sa = Jsa/su = Jsa/sa = {[p \u2190 not q], [q \u2190 not p]} : In these\ncases, the strong attacks are precisely the strong undercuts; the argument [r \u2190 not p] is\nnot justified, because the strong undercut [p \u2190 not q] is undercut, but not strongly undercut, by [q \u2190 not p]. And finally, Jsu/u = Jsu/a = Jsa/u = Jsa/a = {[p \u2190 not q], [q \u2190\nnot p], [r \u2190 not p]} : Again, undercuts and attacks, and strong undercuts and strong attacks, coincide; but now [r \u2190 not p] is justified, because non-strong undercuts are allowed\nas defence.\nThus, in general, Jx/u 6\u2286 Jx/su and Jx/a 6\u2286 Jx/sa , where x \u2208 {su, sa}.\n\n\f16\n\nRalf Schweimeier and Michael Schroeder\n\nThe following example distinguishes the argumentation semantics of Dung (Dung 1993)\nand Prakken and Sartor (Prakken and Sartor 1997).\nExample 10\nConsider the following program:\np\n\u00acp\n\n\u2190 not \u00acp\n\nThen Ja/x = \u2205, because both arguments attack each other, while Jd/x = {[\u00acp]}, because\n[\u00acp] defeats [p \u2190 not \u00acp], but not vice versa.\nThus, Jd/x 6\u2286 Ja/x .\nThe final example shows that if we do not allow any rebuts as attacks, then we obtain a\nstrictly more credulous semantics.\nExample 11\nConsider the following program:\n\u00acp\n\u00acq\np\nq\n\n\u2190 not q\n\u2190 not p\n\nLet x be a notion of attack. Then Jsa/x = Jd/x = Ja/x = \u2205, because every argument is\nstrongly attacked (hence defeated and attacked), while Ju/x = Jsu/x = {[p], [q]}.\nThus, in general, Jv/x 6\u2286 Jw/y , where v \u2208 {u, su}, w \u2208 {a, d, sa}, and x and y are any\nnotions of attack.\n\n3.3 A hierarchy of argumentation semantics\nWe now summarise the results of this section, establishing a complete hierarchy of argumentation semantics, parametrised on a pair of notions of attack x/y where x stands for the\nattacks on an argument, and y for the possible defence. We locate in this hierarchy the argumentation semantics of Dung (Dung 1993) and Prakken and Sartor (Prakken and Sartor 1997),\nas well as the well-founded semantics for normal logic programs (van Gelder et al. 1991).\nIn Section 5 we will show that the paraconsistent well-founded semantics with explicit\nnegation, WFSXp (Dam\u00e1sio 1996), can also be found in our hierarchy. As a corollary, we\nobtain precise relationships between these well-known semantics and our argumentation\nsemantics.\nTheorem 9\nThe notions of justifiability are ordered (by set inclusion) according to the diagram in\nFigure 2, where x/y lies below x\u2032 /y \u2032 iff Jx/y ( Jx\u2032 /y\u2032 .\n\n\fA Hierarchy of Argumentation Semantics\n\n17\n\nsu/a = su/d\n\nSSSS\nj\nSSSS\njjjj\njjjj\nsu/u TT\nk su/sa LLL\nTTTT\nooo\nkkkk\nTTTT\nLL\no\nk\nk\no\nk\no\nT\nkk\nsa/u = sa/d = sa/a\nu/a = u/d = u/sa\nj su/su SSSS\nOOO\nSSSS\nrr\njjjj\nOO\nj\nj\nj\nrrr\nj\nu/su = u/u\nsa/su = sa/sa\nTTTT\nkk\nk\nTTT\nk\nk\nkk\nd/su = d/u = d/a = d/d = d/sa\na/su = a/u = a/a = a/d = a/sa\n\nFig. 2. Hierarchy of Notions of Justifiability\n\nProof\nAll equality and subset relationships (i.e. arcs between notions of justifiability) depicted in\nFigure 2 are underpinned by the theorems in section 3.1. Two notions of justifiability are\nnot subsets of each other iff they are not equal and not connected by an arc in Figure 2.\nThese findings are underpinned by the counter-examples of section 3.2.\nBy definition, Prakken and Sartor's semantics (Prakken and Sartor 1997), if we disregard priorities, amounts to d/su-justifiability.\nSimilarly, Dung's grounded argumentation semantics (Dung 1993) is exactly a/u-justifiability;\nand if we treat explicitly negated literals as new atoms, we can apply the least fixpoint argumentation semantics for normal logic programs (Dung 1995; Bondarenko et al. 1997) to\nextended logic programs, which is then, by definition, u/u-justifiability.\nNote that these latter semantics use a slightly different notation to ours: arguments are\nsets of assumptions (i.e. default literals), and a conclusion of an argument is a literal that\ncan be derived from these assumptions. This approach can be translated to ours by taking\nas arguments all those derivations of a conclusion from an argument. Then the definitions\nof the notions of attack and the fixpoint semantics coincide. See also the discussion in\n(Prakken and Sartor 1997).\nAs corollaries to Theorem 9 we obtain relationships of these semantics to the other\nnotions of justifiability.\nCorollary 10\nLet JDung be the set of justified arguments according to Dung's grounded argumentation semantics (Dung 1993). Then JDung = Ja/su = Ja/u = Ja/a = Ja/d = Ja/sa and\nJDung ( Jx/y for all notions of attack x 6= a and y. Thus, in Dung's semantics, it does not\nmatter which notion of attack, su,u,a,d,sa, is used as a defence, and Dung's semantics is\nmore sceptical than the others.\nCorollary 11\nLet JP S be the set of justified arguments according to Prakken and Sartor's argumentation\nsemantics (Prakken and Sartor 1997), where all arguments have the same priority. Then\nJP S = Jd/su = Jd/u = Jd/a = Jd/d = Jd/sa , JP S ( Jx/y for all notions of attack\n\n\f18\n\nRalf Schweimeier and Michael Schroeder\n\nx 6\u2208 {a, d} and y, and JP S ) Ja/y for all notions of attack y. Thus, in Prakken and\nSartor's semantics, it does not matter which notion of attack, su,u,a,d,sa, is used as a\ndefence, and JP S is more credulous than Dung's semantics, but more sceptical than all the\nothers.\nCorollary 12\nLet JW F S be the set of justified argument according to the well-founded argumentation\nsemantics for normal logic programs (Dung 1995; Bondarenko et al. 1997), where an explicitly negated atom \u00acL is treated as unrelated to the positive atom L. Then JW F S =\nJu/u = Ju/su , JW F S ) Jd/y ) Ja/y , JW F S ( Jsu/y , and JW F S ( Ju/a = Ju/d = Ju/sa ,\nfor all notions of attack y. Thus, in contrast to Dung's and Prakken and Sartor's semantics,\nfor WFS it makes a difference whether rebuts are permitted in the defence (a,d,sa) or not\n(u,su).\nRemark 1\n1. The notions of a/x-, d/x- and sa/x-justifiability are particularly sceptical in that even\na fact p may not be justified, if there is a rule \u00acp \u2190 B (where not p 6\u2208 B) that is not\nx-attacked. On the other hand this is useful in terms of avoiding inconsistency.\n2. sx/y-justifiability is particularly credulous, because it does not take into account nonstrong attacks, so e.g. the program {p \u2190 not q, q \u2190 not p} has the justified arguments\n[p \u2190 not q] and [q \u2190 not p].\nRemark 2\nOne might ask whether any of the semantics in Figure 2 are equivalent for non-contradictory\nprograms, i.e. programs for which there is no literal L such that there exist justified arguments for both L and \u00acL. The answer to this question is no: all the examples in Section 3.2\ndistinguishing different notions of justifiability involve only non-contradictory programs.\nIn particular, even for non-contradictory programs, Dung's and Prakken and Sartor's semantics differ, and both differ from u/a-justifiability, which will be shown equivalent to the\nparaconsistent well-founded semantics WFSXp (Dam\u00e1sio 1996; Pereira and Alferes 1992;\nAlferes and Pereira 1996) in Section 5.\n4 Properties of Argumentation Semantics\nWe will now state some important properties which a semantics for extended logic programs may have, and examine for which of the argumentation semantics these properties\nhold.\n4.1 The coherence principle\nThe coherence principle for extended logic programming (Alferes and Pereira 1996) states\nthat \"explicit negation implies implicit negation\". If the intended meaning of not L is \"if\nthere is no evidence for L, assume that L is false\", and the intended meaning of \u00acL is \"there\nis evidence for the falsity of L\", then the coherence principle states that explicit evidence\nis preferred over assumption of the lack of evidence. Formally, this can be stated as: if \u00acL\n\n\fA Hierarchy of Argumentation Semantics\n\n19\n\nis in the semantics, then not L is also in the semantics. In an argumentation semantics, we\nhave not defined what it means for a default literal to be \"in the semantics\". This can easily\nbe remedied, though, and for convenience we introduce the following transformation.3\nDefinition 8\nLet P be an extended logic program, and x and y notions of attack, and let L be an objective\nliteral. Then L is x/y-justified if there exists a x/y-justified argument for L.\nLet nL be a fresh atom, and P \u2032 = P \u222a {nL \u2190 not L}. Then not L is x/y-justified if\n[nL \u2190 not L] is a x/y-justified argument associated with P \u2032 .\nNote that because nL is fresh, then either Jx/y (P \u2032 ) = Jx/y (P ) or Jx/y (P \u2032 ) = Jx/y (P ) \u222a\n{[nL \u2190 not L]}.\nDefinition 9\nA least fixpoint semantics Jx/y satisfies the coherence principle if for every objective literal\nL, if \u00acL is x/y-justified, then not L is x/y-justified.\nThe following result states that a least fixpoint semantics satisfies the coherence principle\nexactly in those cases where we allow any attack for the defence. Informally, this is because\nthe only way of attacking a default literal not L is by undercut, i.e. an argument for L, and\nin general, such an argument can only be attacked by an argument for \u00acL by a rebut.\nTheorem 13\nLet x, y \u2208 {a, u, d, su, sa}. Then Jx/y satisfies the coherence principle iff Jx/y = Jx/a .\nProof\n\u2022 For the \"only if\" direction, we show that for those notions of justifiability x/y 6=\nx/a, the coherence principle does not hold.\n- Consider the program P :\np \u2190 not q\nq \u2190 not r\nr \u2190 not s\ns \u2190 not p\n\u00acp\nThen Ju/u (P \u2032 ) = Jsu/u (P \u2032 ) = Jsu/su (P \u2032 ) = {[\u00acp]}, where P \u2032 = P \u222a {np \u2190\nnot p}. In these cases, the coherence principle is not satisfied, because \u00acp is\njustified, but not p is not justified.\n- Now consider the program Q:\np \u2190 not \u00acp\n\u00acp \u2190 not p\nThen Jsu/sa (Q\u2032 ) = Jsa/sa (Q\u2032 ) = {[p \u2190 not \u00acp], [\u00acp \u2190 not p]}, where\nQ\u2032 = Q \u222a{np \u2190 not p}. Again, the coherence principle is not satisfied, because\n\u00acp is justified, but not p is not justified.\n\n3\n\nThe purpose of the transformation could be equally achieved by defining that not L is x/y-justified if all\narguments for L are overruled.\n\n\f20\n\nRalf Schweimeier and Michael Schroeder\n\u2022 For the \"if\" direction, let x be any notion of attack. Let P be an extended logic program, and \u00acL a x/a-justified literal, i.e. there is an argument A = [\u00acL \u2190 Body, . . .]\n\u03b1\nand an ordinal \u03b1 s.t. A \u2208 Jx/a\n.\n\u2032\nLet A = [nL \u2190 not L], and (B, A\u2032 ) \u2208 x. Because nL is fresh, the only possible\nattack on A\u2032 is a strong undercut, i.e. L is a conclusion of B. Then A attacks B, and\n\u03b1+1\nso [nL \u2190 not L] \u2208 Jx/a\n.\n\n4.2 Consistency\nConsistency is an important property of a logical system. It states that the system does not\nsupport contradictory conclusions. In classical logic \"ex falso quodlibet\", i.e. if both A and\n\u00acA hold, then any formula holds. In paraconsistent systems (Dam\u00e1sio and Pereira 1998),\nthis property does not hold, thus allowing both A and \u00acA to hold for a particular formula\nA, while not supporting any other contradictions.\nA set of arguments is consistent, or conflict-free (Prakken and Sartor 1997; Dung 1995),\nif it does not contain two arguments such that one attacks the other. There are several\nnotions of consistency, depending on which notion of attack is considered undesirable.\nDefinition 10\nLet x be a notion of attack, and P an extended logic program. Then a set of arguments\nassociated with P is called x-consistent if it does not contain arguments A and B such that\n(A, B) \u2208 xP .\nThe argumentation semantics of an extended logic program need not necessarily be consistent; because of explicit negation, there exist contradictory programs such as {p, \u00acp},\nfor which there exist sensible, but inconsistent arguments ([p] and [\u00acp] in this case).\nA general result identifies cases in which the set of justified arguments for a program is\nconsistent. It states that if we allow the attack to be at least as strong as the defence, i.e. if\nwe are sceptical, then the set of justified arguments is consistent.\nTheorem 14\nLet x and y be notions of attack such that x \u2287 y, and let P be an extended logic program.\nThen the set of x/y-justified arguments is x-consistent.\nProof\n\u03b1\nis x-consistent for all ordinals \u03b1, by transfinite induction on \u03b1.\nWe show that Jx/y\nBase case \u03b1 = 0: Trivial.\n\u03b1+1\nSuccessor ordinal \u03b1\n\u03b1 + 1: Assume A, B \u2208 Jx/y\nand (A, B) \u2208 x. Then there exists\n\u03b1\n\u03b1\n,\nC \u2208 Jx/y such that (C, A) \u2208 y \u2286 x. Then by induction hypothesis, because C \u2208 Jx/y\n\u03b1+1\n\u03b1\n\u03b1\nthen A 6\u2208 Jx/y . Because A \u2208 Jx/y , there exists D \u2208 Jx/y such that (D, C) \u2208 y \u2286 x. This\ncontradicts the induction hypothesis, so we have to retract the assumption and conclude\n\u03b1+1\nthat Jx/y\nis x-consistent.\n\u03bb\nLimit ordinal \u03bb: Assume A, B \u2208 Jx/y\nand (A, B) \u2208 x. Then there exist \u03b1, \u03b2 < \u03bb s.t. A \u2208\n\u03b2\n\u03b2\n\u03b1\n\u03b1\n, we have\n\u2286 Jx/y\nJx/y\nand B \u2208 Jx/y\n. W.l.o.g. assume that \u03b1 \u2264 \u03b2. Then because Jx/y\n\u03b2\n\u03b2\nA \u2208 Jx/y\n, contradicting the induction hypothesis that Jx/y\nis x-consistent.\n\n\fA Hierarchy of Argumentation Semantics\n\n21\n\nThe following example shows that, in general, the set of justified arguments may well\nbe inconsistent.\nExample 12\nConsider the following program:\nq\np\n\u00acp\n\n\u2190 not p\n\nThen Ju/a = {[q \u2190 not p], [p], [\u00acp]}, and [p] and [\u00acp] rebut each other, and [p] strongly\nundercuts [q \u2190 not p].\n5 Argumentation Semantics and WFSX\nIn this section we will prove that the argumentation semantics Ju/a is equivalent to the paraconsistent well-founded semantics with explicit negation WFSXp (Dam\u00e1sio 1996; Alferes and Pereira 1996).\nFirst, we summarise the definition of WFSXp .\n5.1 Well-founded semantics with explicit negation\nWe recollect the definition of the paraconsistent well-founded semantics for extended logic\nprograms, WFSXp . We use the definition of (Alferes et al. 1995), because it is closer to our\ndefinition of argumentation semantics than the original definition of (Pereira and Alferes 1992).\nDefinition 11\nThe set of all objective literals of a program P is called the Herbrand base of P and denoted\nby H(P ). A paraconsistent interpretation of a program P is a set T \u222a not F where T and\nF are subsets of H(P ). An interpretation is a paraconsistent interpretation where the sets\nT and F are disjoint. An interpretation is called two-valued if T \u222a F = H(P ).\nDefinition 12\nLet P be an extended logic program, I an interpretation, and let P \u2032 (resp. I \u2032 ) be obtained from P (resp. I) by replacing every literal \u00acA by a new atom, say \u00ac A. The GL\u2032\ntransformation PI \u2032 is the program obtained from P \u2032 by removing all rules containing a\ndefault literal not A such that A \u2208 I \u2032 , and then removing all remaining default literals\nfrom P \u2032 , obtaining a definite program P \u2032\u2032 . Let J be the least model of P \u2032\u2032 , i.e. J is the\nleast fixpoint of TP \u2032\u2032 (I) := {A | \u2203A \u2190 B1 , . . . , Bn \u2208 P \u2032\u2032 s.t. Bi \u2208 I}. Then \u0393P I is\nobtained from J by replacing the introduced atoms \u00ac A by \u00acA.\nDefinition 13\nThe semi-normal version of a program P is the program Ps obtained from P by replacing\nevery rule L \u2190 Body in P by the rule L \u2190 not \u00acL, Body. If the program P is clear from\nthe context, we write \u0393I for \u0393P I and \u0393s I for \u0393Ps I.\nNote that the set \u0393P I is just a set of literals; we will now use it to define the semantics\nof P as a (paraconsistent) interpretation.\n\n\f22\n\nRalf Schweimeier and Michael Schroeder\n\nDefinition 14\nLet P be a program whose least fixpoint of \u0393\u0393s is T . Then the paraconsistent well-founded\nmodel of P is the paraconsistent interpretation W F Mp (P ) = T \u222a not (H(P ) \u2212 \u0393s T ).\nIf W F Mp (P ) is an interpretation, then P is called non-contradictory, and W F Mp (P ) is\nthe well-founded model of P , denoted by W F M (P ).\nThe paraconsistent well-founded model can be defined iteratively by the transfinite sequence {I\u03b1 }:\nI0\n:= \u2205\nI\u03b1+1 := \u0393\u0393s I\u03b1\nfor successor ordinal \u03b1 + 1\nS\nfor limit ordinal \u03bb\nI\u03bb\n:=\n\u03b1<\u03bb I\u03b1\nThere exists a smallest ordinal \u03bb0 such that I\u03bb0 is the least fixpoint of \u0393\u0393s , and\nW F Mp (P ) := I\u03bb0 \u222a not (H(P ) \u2212 \u0393s I\u03bb0 ).\n5.2 Equivalence of argumentation semantics and WFSXp\nIn this section, we will show that the argumentation semantics Ju/a and the well-founded\nmodel coincide. That is, the conclusions of justified arguments are exactly the objective\nliterals which are true in the well-founded model; and those objective literals all of whose\narguments are overruled are exactly the literals which are false in the well-founded model.\nThe result holds also for contradictory programs under the paraconsistent well-founded\nsemantics. This is important, because it shows that contradictions in the argumentation\nsemantics are precisely the contradictions under the well-founded semantics, and allows\nthe application of contradiction removal (or avoidance) methods to the argumentation semantics (Dam\u00e1sio et al. 1997). For non-contradictory programs, the well-founded semantics coincides with the paraconsistent well-founded semantics (Alferes and Pereira 1996;\nDam\u00e1sio 1996); consequently, we obtain as a corollary that argumentation semantics and\nwell-founded semantics coincide for non-contradictory programs.\nBefore we come to the main theorem, we need the following Lemma, which shows a\nprecise connection between arguments and consequences of a program PI .\nLemma 15\nLet I be a two-valued interpretation.\n1. L \u2208 \u0393(I) iff \u2203 argument A with conclusion L such that assm(A) \u2286 I.\n2. L \u2208 \u0393s (I) iff \u2203 argument A with conclusion L such that assm(A) \u2286 I and\n\u00acconc(A) \u2229 I = \u2205.\n3. L 6\u2208 \u0393(I) iff \u2200 arguments A with conclusion L, assm(A) \u2229 I 6\u2286 \u2205.\n4. L 6\u2208 \u0393s (I) iff \u2200 arguments A with conclusion L, assm(A) \u2229 I 6\u2286 \u2205 or\n\u00acconc(A) \u2229 I 6= \u2205.\nProof\nSee Appendix A.\nIn order to compare the argumentation semantics with the well-founded semantics, we\nextend the definition conc(A) of the conclusions of a single argument A to work on a set\nof arguments A. The extended definition conc(A) includes all positive and negative conclusions of arguments in A; i.e. those literals L \u2208 conc(A), as well as the default literals\n\n\fA Hierarchy of Argumentation Semantics\n\n23\n\nnot L where all arguments for L are overruled by some argument A \u2208 A. We will use this\ndefinition of conc for the set of justified arguments Ju/a to compare the \"argumentation\nmodel\" conc(Ju/a ) to W F Mp (P ), the well-founded model.\nDefinition 15\nLet A be a set of arguments. Then\n[\nconc(A) =\nconc(A)\u222a{not L | all arguments for L are overruled by an argument A \u2208 A}\nA\u2208A\n\nWith the above definition, we can formulate the main theorem that u/a-justified arguments coincide with the well-founded semantics.\nTheorem 16\nLet P be an extended logic program. Then W F Mp (P ) = conc(Ju/a ).\nProof\nFirst, note that A undercuts B iff \u2203 L s.t. L \u2208 conc(A) and not L \u2208 assm(B); and A\nrebuts B iff \u2203 L \u2208 conc(A) \u2229 \u00acconc(B).\n\u03b1\nWe show that for all ordinals \u03b1, I\u03b1 = conc(Ju/a\n), by transfinite induction on \u03b1. The proof\nproceeds in two stages. First, we show that all objective literals L in W F Mp (P ) are conclusions of u/a-justified arguments and second, that for all default negated literals not L\nin W F Mp (P ), all arguments for L are overruled.\n\u03b1\n)\nBase case \u03b1 = 0: I\u03b1 = \u2205 = conc(Ju/a\n\nSuccessor ordinal \u03b1\n\n\u03b1 + 1:\n\nL \u2208 I\u03b1+1\niff (Def. of I\u03b1+1 )\nL \u2208 \u0393\u0393s I\u03b1\niff (Lemma 15(1))\n\u2203 argument A for L such that assm(A) \u2286 \u0393s I\u03b1\niff (Def. of \u2286, and \u0393s I\u03b1 is two-valued)\n\u2203 argument A for L such that \u2200 not L \u2208 assm(A), L 6\u2208 \u0393s I\u03b1\niff (Lemma 15(4))\n\u2203 argument A for L such that \u2200 not L \u2208 assm(A), for any argument B for L, ( \u2203 not L\u2032 \u2208\nassm(B) s.t. L\u2032 \u2208 I\u03b1 or \u2203 L\u2032\u2032 \u2208 conc(B) s.t. \u00acL\u2032\u2032 \u2208 I\u03b1 )\niff (Induction hypothesis)\n\u2203 argument A for L such that \u2200 not L \u2208 assm(A), for any argument B for L, ( \u2203 not L\u2032 \u2208\n\u03b1\n\u03b1\nassm(B) s.t. \u2203 argument C \u2208 Ju/a\nfor L\u2032 , or \u2203 L\u2032\u2032 \u2208 conc(B) s.t. \u2203 argument C \u2208 Ju/a\n\u2032\u2032\nfor \u00acL )\niff (Def. of undercut and rebut)\n\u03b1\n\u2203 argument A for L such that for any undercut B to A, ( \u2203 argument C \u2208 Ju/a\ns.t. C\n\u03b1\nundercuts B, or \u2203 argument C \u2208 Ju/a s.t. C rebuts B)\niff\n\u03b1\n\u2203 argument A for L such that for any undercut B to A, \u2203 argument C \u2208 Ju/a\ns.t. C attacks\nB\n\u03b1+1\n)\niff (Def. of Ju/a\n\n\f24\n\nRalf Schweimeier and Michael Schroeder\n\n\u03b1+1\n\u2203 argument A \u2208 Ju/a\nfor L\n\niff (Def. of conc)\n\u03b1+1\nL \u2208 conc(Ju/a\n)\n\nLimit ordinal \u03bb:\nS\nS\n\u03b1\n\u03b1\n\u03bb\n, so by induction hypothesis (I\u03b1 = conc(Ju/a\n) for\n= \u03b1<\u03bb Ju/a\nI\u03bb = \u03b1<\u03bb I\u03b1 and Ju/a\n\u03bb\nall \u03b1 < \u03bb), I\u03bb = conc(Ju/a ).\nNext we will show that a literal not L is in the well-founded semantics iff every argument\nfor L is overruled, i.e. not L \u2208 W F Mp (P ) implies not L \u2208 conc(Ju/a ).\nnot L \u2208 W F Mp (P )\niff (Def. of W F Mp (P ))\nL 6\u2208 \u0393s I\u03bb\niff (Lemma 15(4)\nfor all arguments A for L, ( \u2203 not L\u2032 \u2208 assm(A) s.t. L\u2032 \u2208 I\u03bb , or \u2203 L\u2032\u2032 \u2208 conc(A) s.t. \u00acL\u2032\u2032 \u2208\nI\u03bb )\n\u03bb\niff (I\u03bb = conc(Ju/a\n))\n\u2032\n\u03bb\nfor all arguments A for L, ( \u2203 not L \u2208 assm(A) s.t. \u2203 argument B \u2208 Ju/a\nfor L\u2032 , or\n\u03bb\n\u2203 L\u2032\u2032 \u2208 conc(A) s.t. \u2203 argument B \u2208 Ju/a\nfor \u00acL\u2032\u2032 )\niff (Def. of undercut and rebut)\n\u03bb\nfor all arguments A for L, ( \u2203 argument B \u2208 Ju/a\ns.t. B undercuts A, or \u2203 argument\n\u03bb\nB \u2208 Ju/a s.t. B rebuts A )\niff\n\u03bb\nevery argument for L is attacked by a justified argument in Ju/a\niff (Def. of overruled)\nevery argument for L is overruled\niff (Def. of conc(Ju/a ))\nnot L \u2208 conc(Ju/a )\nCorollary 17\nLet P be a non-contradictory program. Then W F M (P ) = conc(Ju/a ).\nRemark 3\nIn a similar way, one can show that the \u0393 operator corresponds to undercuts, while the\n\u0393s operator corresponds to attacks, and so the least fixpoints of \u0393\u0393, \u0393s \u0393, and \u0393s \u0393s correspond to Ju/u , Ja/u , and Ja/a , respectively. In (Alferes et al. 1995), the least fixpoints\nof these operators are shown to be ordered as lf p(\u0393s \u0393) \u2286 lf p(\u0393s \u0393s ) \u2286 lf p(\u0393\u0393s ), and\nlf p(\u0393s \u0393) \u2286 lf p(\u0393\u0393) \u2286 lf p(\u0393\u0393s ). Because Ja/u = Ja/a \u2286 Ju/u \u2286 Ju/a by Theorem 9,\nwe can strengthen this statement to lf p(\u0393s \u0393) = lf p(\u0393s \u0393s ) \u2286 lf p(\u0393\u0393) \u2286 lf p(\u0393\u0393s ).\nThe following corollary summarises the results so far.\nCorollary 18\nThe least fixpoint argumentation semantics of Dung (Dung 1993), denoted JDung , of\nPrakken and Sartor (Prakken and Sartor 1997), denoted JPS , and the well-founded semantics for normal logic programs WFS (Bondarenko et al. 1997; van Gelder et al. 1991) and\n\n\fA Hierarchy of Argumentation Semantics\n\n25\n\nfor logic programs with explicit negation WFSXp (Pereira and Alferes 1992; Alferes and Pereira 1996)\nare related to the other least fixpoint argumentation semantics as illustrated in Figure 3.\n\nsu/a = su/d\n\nTTTT\nTTTT\nTT\nsu/sa TT\nTTTT\njjjj\nj\nTTTT\nj\nj\nj\nj\njj\nsu/su TT\nu/a = u/d = u/sa =WFSXp\nTTTT\nnnn\njjjj\nT\nn\nT\nn\nT\nT\njjjj\nnn\n\nn\nnnn\nnnn\nsu/u Q\nQQQ\noo\no\nQQQ\no\nQ\noo\nsa/u = sa/d = sa/a\n\nOOO\nOOO\n\nu/su = u/u =WFS\n\nsa/su = sa/sa\n\nQQQ\nQQQ\n\njjjj\njjjj\n\nd/su = d/u = d/a = d/d = d/sa = JPS\na/su = a/u = a/a = a/d = a/sa = JDung\n\nFig. 3. Hierarchy of Notions of Justifiability and Existing Semantics\n\n6 Proof Theory\nOne of the benefits of relating the argumentation semantics Ju/a to WFSXp is the existence of an efficient top-down proof procedure for WFSXp (Alferes et al. 1995), which we\ncan use to compute justified arguments in Ju/a . On the other hand, dialectical proof theories, based on dialogue trees, have been defined for a variety of argumentation semantics\n(Simari et al. 1994; Prakken and Sartor 1997; Jakobovits and Vermeir 1999a; Kakas and Toni 1999).\nIn this section we present a sound and complete dialectical proof theory for the least fixpoint argumentation semantics Jx/y for any notions of attack x and y.\n6.1 Dialogue trees\nWe adapt the dialectical proof theory of (Prakken and Sartor 1997) to develop a general\nsound and complete proof theory for x/y-justified arguments.\nDefinition 16\nLet P be an extended logic program. An x/y-dialogue is a finite nonempty sequence of\nmoves movei = (Player i , Argi )(i > 0), such that P layeri \u2208 {P, O}, Argi \u2208 Args P ,\nand\n1. Player i = P iff i is odd; and Player i = O iff i is even.\n2. If Player i = Player j = P and i 6= j, then Argi 6= Argj .\n3. If Player i = P and i > 1, then Argi is a minimal argument such that\n(Argi , Argi\u22121 ) \u2208 y.\n4. If Player i = O, then (Argi , Argi\u22121 ) \u2208 x.\n\n\f26\n\nRalf Schweimeier and Michael Schroeder\n\nThe first condition states that the players P (Proponent) and O (Opponent) take turns,\nand P starts. The second condition prevents the proponent from repeating a move. The\nthird and fourth conditions state that both players have to attack the other player's last\nmove, where the opponent is allowed to use the notion of attack x, while the proponent\nmay use y to defend its arguments. Note that the minimality condition in 3 is redundant,\nbecause all arguments in Args P are required to be minimal by Definition 2. We have\nexplicitly repeated this condition, because it is important in that it prevents the proponent\nfrom repeating an argument by adding irrelevant rules to it.\nDefinition 17\nAn x/y-dialogue tree is a tree of moves such that every branch is a x/y-dialogue, and for\nall moves movei = (P, Argi ), the children of movei are all those moves (O, Argj ) such\nthat (Argj , Argi ) \u2208 x.\nThe height of a dialogue tree is 0 if it consists only of the root, and otherwise height(t) =\nsup{height(ti)} + 1 where ti are the trees rooted at the grandchildren of t.\nExample 13\nConsider the following program:\np\nq\n\u00acq\nr\ns\nt\nu\nv\n\u00acv\n\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\u2190\n\nq, not r\nnot s\nu\nnot t\nnot t\nnot w\nnot v\nnot r\nnot t\n\nA a/u-dialogue tree rooted at the argument [p \u2190 q, not r; q \u2190 not s] is given by Figure 4.\nx /\nEach node is marked with P for proponent or O for opponent, and an edge A\nB\ndenotes that A attacks B with the notion of attack x, i.e. (A, B) \u2208 x.\nNote that although dialogues are required to be finite, dialogue trees may be infinitely\nbranching. Therefore dialogue trees need not be finite, nor need their height be finite.\nExample 14\nConsider the following program P 4 :\np(0)\np(s(X))\nq(X)\nr\ns\n4\n\n\u2190\n\u2190\n\u2190\n\u2190\n\nnot q(X)\nnot p(X)\nq(X)\nnot r\n\nNote that by definition, programs are not allowed to contain variables. Here, X denotes a variable, and P is an\nabbreviation for the (infinite) program obtained by substituting the terms sn (0) for the variable X, in all the\nrules.\n\n\fA Hierarchy of Argumentation Semantics\n\n27\n\nP : [p \u2190 q, not r; q \u2190 not s]\n\njjj4\nu jjjj\nj\nj\nj\njj\njjjj\n\nO\nr\n\njTTTT\nTTTTu\nTTTT\nTTTT\n\nO : [r \u2190 not t]\n\nO : [\u00acq \u2190 u; u \u2190 not v]\n\nO : [s \u2190 not t]\n\nO\nO\n\nO\n\nu\n\nP : [t \u2190 not w]\n\nu\n\nu\n\nP : [v \u2190 not r]\n\nO\nu\n\nP : [t \u2190 not w]\n\njTTTT\nTTTTr\nTTTT\nTTTT\n\nO : [r \u2190 not t]\n\nO : [\u00acv \u2190 not t]\n\nO\nO\n\nu\n\nP : [t \u2190 not w]\n\nu\n\nP : [t \u2190 not w]\n\nFig. 4. An a/u-dialogue tree\nFor each n \u2208 N, there is exactly one minimal argument An with conclusion p(sn (0)),\nnamely [p(0)] for n = 0, and [p(sn (0)) \u2190 not q(sn\u22121 (0))] for n > 0. Similarly,\nthere is exactly one minimal argument Bn with conclusion q(sn (0)), namely [q(sn (0)) \u2190\nnot p(sn (0))].\nTherefore, a u/u-dialogue tree rooted at An+1 consists of just one dialogue Tn+1 of the\nform ((P, An+1 ), (O, Bn ), Tn ). A u/u-dialogue tree rooted at A0 consists only of the root,\nbecause there are no undercuts to A0 . Thus, the height of the dialogue tree Tn is n.\nNow consider the u/u-dialogue tree rooted at the argument C = [s \u2190 not r]. The argument C is undercut by infinitely many arguments Dn = [r \u2190 q(sn (0)); q(sn (0)) \u2190\nnot p(sn (0))]; each Dn is undercut by exactly one argument: An . A dialogue in the u/udialogue tree TC rooted at argument C is therefore a sequence ((P, C), (O, Bn ), Tn ). Because height (Tn ) = n, then by Definition 17: height (TC ) = sup{height (Tn ) | n \u2208\nN} + 1 = \u03c9 + 1.\nDefinition 18\nA player wins an x/y-dialogue iff the other player cannot move. A player wins an x/ydialogue tree iff it wins all branches of the tree. An x/y-dialogue tree which is won by the\nproponent is called a winning x/y-dialogue tree.\nWe show that the proof theory of x/y-dialogue trees is sound and complete for any\nnotions of attack x and y.\nTheorem 19\nAn argument A is x/y-justified iff there exists a x/y-dialogue tree with A as its root, and\nwon by the proponent.\nProof\n\u03b1\nif\nWe show by transfinite induction that for all arguments A, for all ordinals \u03b1: A \u2208 Jx/y\nand only if there exists a winning x/y-dialogue tree of height \u2264 \u03b1 for A. See Appendix A\nfor the detailed proof.\n\n\f28\n\nRalf Schweimeier and Michael Schroeder\n7 Related Work\n\nThere has been much work on argument-theoretic semantics for normal logic programs, i.e.\nlogic programs with default negation (Bondarenko et al. 1997; Dung 1995; Kakas and Toni 1999).\nBecause there is no explicit negation, there is only one form of attack, the undercut in our\nterminology. An abstract argumentation framework has been defined, which captures other\ndefault reasoning mechanisms besides normal logic programming. Within this framework,\na variety of semantics may be defined, such as preferred extensions; stable extensions,\nwhich are equivalent to stable models (Gelfond and Lifschitz 1988); and a least fixpoint\nsemantics based on the acceptability of arguments, which is equivalent to the well-founded\nsemantics (van Gelder et al. 1991). The latter fixpoint semantics forms the basis of our\nargumentation semantics. Proof theories and proof procedures for some of these argumentation semantics have been developed in (Kakas and Toni 1999).\nThere has been some work extending this argumentation semantics to logic programs\nwith explicit negation. Dung (Dung 1995) adapts the framework of (Dung 1993), by distinguishing between ground attacks and reductio-ad-absurdum-attacks, in our terminology undercuts and rebuts. Argumentation semantics analogous to those of normal logic\nprograms are defined, and the stable extension semantics is shown to be equivalent to\nthe answer set semantics (Gelfond and Lifschitz 1990), an adaptation of the stable model\nsemantics to extended logic programs. A least fixpoint semantics (called grounded semantics) based on a notion of acceptability is defined, and related to the well-founded semantics\nof (van Gelder et al. 1991), although only for the case of programs without explicit negation.\nPrakken and Sartor (Prakken and Sartor 1997) define an argumentation semantics for\nextended logic programs similar to that of Dung. Their language is more expressive in that\nit distinguishes between strict rules, which may not be attacked, and defeasible rules, which\nmay be attacked. Furthermore, rules have priorities, and rebuts are only permitted against a\nrule of equal or lower priority. Thus, rebuts are not necessarily symmetric, as in our setting.\nOur language corresponds to Prakken and Sartor's without strict rules, and either without\npriorities, or, equivalently, if all rules have the same priority. The semantics is given as\na least fixpoint of an acceptability operator, analogous to Dung's grounded semantics. A\nproof theory, similar to those of Kakas and Toni (Kakas and Toni 1999) is developed. This\nproof theory formed the basis of our general proof theory for justified arguments.\nIn (M\u00f3ra and Alferes 1998), an argumentation semantics for extended logic programs,\nsimilar to Prakken and Sartor's, is proposed; it is influenced by WFSX, and distinguishes\nbetween sceptical and credulous conclusions of an argument. It also provides a proof theory\nbased on dialogue trees, similar to Prakken and Sartor's.\nDefeasible Logic Programming (Garc\u0131\u0301a and Simari 2004; Simari et al. 1994; Garc\u0131\u0301a et al. 1998)\nis a formalism very similar to Prakken and Sartor's, based on the first order logic argumentation framework of (Simari and Loui 1992). It includes logic programming with two kinds\nof negation, distinction between strict and defeasible rules, and allowing for various criteria\nfor comparing arguments. Its semantics is given operationally, by proof procedures based\non dialectical trees (Garc\u0131\u0301a and Simari 2004; Simari et al. 1994). In (Ches\u00f1evar et al. 2002),\nthe semantics of Defeasible Logic Programming is related to the well-founded semantics,\nalbeit only for the restricted language corresponding to normal logic programs (van Gelder et al. 1991).\n\n\fA Hierarchy of Argumentation Semantics\n\n29\n\nThe answer set semantics for extended logic programs (Gelfond and Lifschitz 1990) is\ndefined via extensions which are stable under a certain program transformation. While this\nsemantics is a natural extension of stable models (Gelfond and Lifschitz 1988) and provides an elegant model-theoretic semantics, there are several drawbacks which the answer\nset semantics inherits from the stable models. In particular, there is no efficient top-down\nproof procedure for the answer set semantics, because the truth value of a literal L may depend on the truth value of a literal L\u2032 which does not occur in the proof tree below L 5 . The\nwell-founded semantics (van Gelder et al. 1991) is an approximation of the stable model\nsemantics, for which an efficient top-down proof procedure exists. In (Przymusinski 1990),\nthe well-founded semantics is adapted to extended logic programs. However, this semantics\ndoes not comply with the coherence principle, which states that explicit negation implies\nimplicit negation. In order to overcome this, (Pereira and Alferes 1992; Alferes and Pereira 1996)\ndeveloped WFSX, a well-founded semantics for extended logic programs, which satisfies\nthe coherence principle. It has several desirable properties not enjoyed by the answer set\nsemantics; in particular, an efficient goal-oriented top-down proof procedure for WFSX\nis presented in (Alferes et al. 1995). WFSX is well established and e.g. widely available\nthrough Prolog implementations such as XSB Prolog (Freire et al. 1997).\nOur own work is complementary to these approaches, in that we fill a gap by bringing\nargumentation and WFSX together in our definition of u/a-justified arguments, which are\nequivalent to WFSXp (Dam\u00e1sio 1996; Alferes and Pereira 1996; Alferes et al. 1995), the\nparaconsistent version of WFSX. Furthermore, the generality of our framework allows us\nto relate existing argumentation semantics such as Dung's and Prakken and Sartor's approach and thus provide a concise characterisation of all the existing semantics mentioned\nabove.\nA number of authors (Kraus et al. 1998; Parsons and Jennings 1996; Sierra et al. 1997;\nParsons et al. 1998; Sadri et al. 2001; Torroni 2002; Schroeder 1999; M\u00f3ra and Alferes 1998)\nwork on argumentation for negotiating agents. Of these, the approaches of (Sadri et al. 2001;\nTorroni 2002; Schroeder 1999) are based on logic programming. The advantage of the\nlogic programming approach for arguing agents is the availability of goal-directed, topdown proof procedures. This is vital when implementing systems which need to react in\nreal-time and therefore cannot afford to compute all justified arguments, as would be required when a bottom-up argumentation semantics would be used.\nIn (Sadri et al. 2001; Torroni 2002), abduction is used to define agent negotiation focusing on the generation of negotiation dialogues using abduction. This work is relevant\nin that it shows how to embed an argumentation proof procedure into a dialogue protocol, which is needed to apply proof procedures of argumentation semantics as defined in\nthis paper into agent communication languages such as KQML (Finin et al. 1994) or FIPA\nACL (Chiariglione et al. 1997).\nWith a variety of argument-based approaches being pursued to define negotiating agents,\nthe problem of how these agents may inter-operate arises. This paper could serve as a first\nstep towards inter-operation as existing approaches can be placed in our framework, thus\nmaking it easier to compare them.\n\n5\n\nSee the extensive discussion in (Alferes and Pereira 1996) for details.\n\n\f30\n\nRalf Schweimeier and Michael Schroeder\n8 Conclusion and Further Work\n\nWe have identified various notions of attack for extended logic programs. Based on these\nnotions of attack, we defined notions of acceptability and least fixpoint semantics. The\ncontributions of this paper are five-fold.\n\u2022 First, we defined a parameterised hierarchy of argumentation semantics by establishing a lattice of justified arguments based on set inclusion. We showed which\nargumentation semantics are equal, which are subsets of one another and which are\nneither.\n\u2022 Second, we examined some properties of the different semantics, and gave a necessary and sufficient condition for a semantics to satisfy the coherence principle (Alferes and Pereira 1996),\nand a sufficient criterion for a semantics to be consistent.\n\u2022 Third, we identified an argumentation semantics Ju/a equal to the paraconsistent\nwell-founded semantics for logic programs with explicit negation, WFSXp (Dam\u00e1sio 1996;\nAlferes and Pereira 1996) and proved this equivalence.\n\u2022 Forth, we established relationships between existing semantics, in particular that\nJDung ( JP S ( Ju/u = W F S ( Ju/a = W F SXp , where JDung and JP S are\nthe least fixpoint argumentation semantics of Dung (Dung 1993) and Prakken and\nSartor (Prakken and Sartor 1997), and W F S is the well-founded semantics without\nexplicit negation (van Gelder et al. 1991).\n\u2022 Fifth, we have defined a dialectical proof theory for argumentation. For all notions of\njustified arguments introduced, we prove that the proof theory is sound and complete\nwrt. the corresponding fixpoint argumentation semantics.\nIt remains to be seen whether a variation in the notion of attack yields interesting variations of alternative argumentation semantics for extended logic programs such as preferred\nextensions or stable extensions (Dung 1993). It is also an open question how the hierarchy\nchanges when priorities are added as defined in (Antoniou 2002; Kakas and Moraitis 2002;\nPrakken and Sartor 1997; Brewka 1996; Garc\u0131\u0301a et al. 1998; Vreeswijk 1997).\nAcknowledgement\nThanks to Iara Carnevale de Almeida and Jos\u00e9 J\u00falio Alferes for fruitful discussions on\ncredulous and sceptical argumentation semantics for extended logic programming.\nThis work has been supported by EPSRC grant GRM88433.\nReferences\nA LFERES , J. J., DAM \u00c1SIO , C. V., AND P EREIRA , L. M. 1995. A logic programming system for\nnon-monotonic reasoning. Journal of Automated Reasoning 14, 1, 93\u2013147.\nA LFERES , J. J., D UNG , P. M., AND P EREIRA , L. M. 1993. Scenario semantics for extended logic\nprogramming. In Proceedings of the Second International Workshop on Logic Programming and\nNon-monotonic Reasoning (LPNMR'93). MIT Press, 334\u2013348.\nA LFERES , J. J. AND P EREIRA , L. M. 1996. Reasoning with Logic Programming. LNAI 1111,\nSpringer-Verlag.\nA NTONIOU , G. 2002. Defeasible logic with dynamic priorities. In Proceedings of the 15th European\nConference on Artificial Intelligence. IOS Press, Lyon, France, 521\u2013525.\n\n\fA Hierarchy of Argumentation Semantics\n\n31\n\nB ELNAP, N. D. 1977. A useful four-valued logic. In Modern Uses of Many-valued Logic, G. Epstein\nand J. M. Dunn, Eds. Reidel Publishing Company, 8\u201337.\nB IRKHOFF , G. 1967. Lattice Theory, 3rd ed. American Mathematical Society.\nB ONDARENKO , A., D UNG , P., KOWALSKI , R., AND T ONI , F. 1997. An abstract, argumentationtheoretic approach to default reasoning. Artificial Intelligence 93, 1-2, 63\u2013101.\nB REWKA , G. 1996. Well-founded semantics for extended logic programs with dynamic preferences.\nJournal of Artificial Intelligence Research 4, 19\u201336.\nC HES \u00d1EVAR , C. I., D IX , J., S TOLZENBURG , F., AND S IMARI , G. R. 2002. Relating defeasible\nand normal logic programming through transformation properties. Theoretical Computer Science 290, 1, 499\u2013529.\nC HES \u00d1EVAR , C. I., M AGUITMAN , A. G., AND L OUI , R. P. 2000. Logical models of argument.\nACM Computing Surveys 32, 4 (December), 337\u2013383.\nC HIARIGLIONE , L. ET AL . 1997. Specification version 2.0. Tech. rep., Foundations of Intelligent\nPhysical Agents. http://www.fipa.org.\nC LARK , K. L. 1978. Negation as failure. In Logic and Databases, Gallaire and Minker, Eds. Plenum\nPress, New York, 293\u2013322.\nDAM \u00c1SIO , C. V. 1996. Paraconsistent extended logic programming with constraints. Ph.D. thesis,\nUniversidade Nova de Lisboa.\nDAM \u00c1SIO , C. V. AND P EREIRA , L. M. 1998. A survey on paraconsistent semantics for extended\nlogic programs. In Handbook of Defeasible Reasoning and Uncertainty Management, D. M. Gabbay and P. Smets, Eds. Vol. 2. Kluwer Academic Publishers, 241\u2013320.\nDAM \u00c1SIO , C. V., P EREIRA , L. M., AND S CHROEDER , M. 1997. REVISE: Logic programming\nand diagnosis. In Proceedings of the Conference on Logic Programming and Non-monotonic\nReasoning LPNMR97. LNAI 1265, Springer\u2013Verlag, 353\u2013362.\nD UNG , P. M. 1993. An argumentation semantics for logic programming with explicit negation. In\nProc. of the 10th International Conference on Logic Programming ICLP'93. MIT Press, 616\u2013630.\nD UNG , P. M. 1995. On the acceptability of arguments and its fundamental role in nonmonotonic\nreasoning, logic programming and n-person games. Artificial Intelligence 77, 2, 321\u2013357.\nF ININ , T., F RITZSON , R., M C K AY, D., AND M C E NTIRE , R. 1994. KQML as an agent communication lanugage. In Proceedings of the Third International Conference on Information and\nKnowledge Management (CIKM'94). ACM Press, 456\u2013463.\nF REIRE , J., R AO , P., S AGONAS , K., S WITFT, T., AND WARREN , D. S. 1997. XSB: A system for\nefficiently computing the well-founded semantics. In International Workshop on Logic Programming and Non-monotonic Reasoning. 431\u2013441.\nG ARC \u00cdA , A. J. AND S IMARI , G. R. 2004. Defeasible logic programming: An argumentative approach. Theory and Practice of Logic Programming 4, 1.\nG ARC \u00cdA , A. J., S IMARI , G. R., AND C HES \u00d1EVAR , C. I. 1998. An argumentative framework\nfor reasoning with inconsistent and incomplete information. In ECAI'98 Workshop on Practical\nReasoning and Rationality. Brighton, UK.\nG ELFOND , M. AND L IFSCHITZ , V. 1988. The stable model semantics for logic programming. In\nProceedings of the 5th International Conference on Logic Programming, R. A. Kowalski and K. A.\nBowen, Eds. MIT Press, 1070\u20131080.\nG ELFOND , M. AND L IFSCHITZ , V. 1990. Logic programs with classical negation. In Proceedings\nof the 7th International Conference on Logic Programming. MIT Press, 579\u2013597.\nJAKOBOVITS , H. AND V ERMEIR , D. 1999a. Dialectic semantics for argumentation frameworks.\nIn Proceedings of the Seventh International Conference on Artificial Intelligence and Law (ICAIL\n'99). 53\u201362.\nJAKOBOVITS , H. AND V ERMEIR , D. 1999b. Robust semantics for argumentation frameworks. Journal of Logic and Computation 9, 2, 215\u2013261.\n\n\f32\n\nRalf Schweimeier and Michael Schroeder\n\nK AKAS , A. AND T ONI , F. 1999. Computing argumentation in logic programming. Journal of Logic\nand Computation 9, 4, 515\u2013562.\nK AKAS , A. C. AND M ORAITIS , P. 2002. Argumentative agent deliberation, roles and context. In\nProceedings of the ICLP-Workshop Computational Logic in Multi-Agent Systems.\nK RAUS , S., S YCARA , K., AND E VENCHIK , A. 1998. Reaching agreements through argumentation:\na logical model and implementation. Artificial Intelligence 104, 1-2, 1\u201369.\nM \u00d3RA , I. A. AND A LFERES , J. J. 1998. Argumentative and cooperative multi-agent system for\nextended logic programming. In Proceedings of the 14th Brazilian Symposium on Artificial Intelligence (SBIA'98). 161\u2013170.\nPARSONS , S. AND J ENNINGS , N. 1996. Negotiation through argumentation-a preliminary report.\nIn Proceedings of the Second International Conference on Multi-Agent Systems. Kyoto, Japan,\n267\u2013274.\nPARSONS , S., S IERRA , C., AND J ENNINGS , N. 1998. Agents that reason and negotiate by arguing.\nJournal of Logic and Computation 8, 3, 261\u2013292.\nP EREIRA , L. M. AND A LFERES , J. J. 1992. Well founded semantics for logic programs with explicit\nnegation. In B. Neumann (Ed.), European Conference on Artificial Intelligence. Wiley, 102\u2013106.\nP OLLOCK , J. L. 1987. Defeasible reasoning. Cognitive Science 11, 481\u2013518.\nP RAKKEN , H. AND S ARTOR , G. 1997. Argument-based extended logic programming with defeasible priorities. Journal of Applied Non-Classical Logics 7, 1, 25\u201375.\nP RZYMUSINSKI , T. 1990. Extended stable semantics for normal and disjunctive programs. In\nProceedings of the 7th International Conference on Logic Programming. MIT Press, 459\u2013477.\nS ADRI , F., T ONI , F., AND T ORRONI , P. 2001. Logic agents, dialogue, negotiation - an abductive\napproach. In Proceedings of the AISB Symposium on Information Agents for E-commerce.\nS CHROEDER , M. 1999. An efficient argumentation framework for negotiating autonomous\nagents. In Proceedings of Modelling Autonomous Agents in a Multi-Agent World MAAMAW99.\nLNAI1647, Springer-Verlag.\nS CHWEIMEIER , R. AND S CHROEDER , M. 2002. Notions of attack and justified arguments for extended logic programs. In Proceedings of the 15th European Conference on Artificial Intelligence.\nIOS Press, Lyon, France, 536\u2013540.\nS IERRA , C., J ENNINGS , N., N ORIEGA , P., AND PARSONS , S. 1997.\nA framework for\nargumentation-based negotiation. In Proc. Fourth Int. Workshop on Agent Theories, Architectures\nand Languages (ATAL-97). Springer-Verlag, 167\u2013182.\nS IMARI , G. R., C HES \u00d1EVAR , C. I., AND G ARC \u00cdA , A. J. 1994. The role of dialectics in defeasible argumentation. In Anales de la XIV Conferencia Internacional de la Sociedad Chilena para\nCiencias de la Computaci\u00f3n. Universidad de Concepci\u00f3n, Concepci\u00f3n (Chile).\nS IMARI , G. R. AND L OUI , R. P. 1992. A mathematical treatment of defeasible reasoning and its\nimplementation. Artificial Intelligence 53, 125\u2013157.\nTARSKI , A. 1955. A lattice-theoretical fixpoint theorem and its applications. Pacific Journal of\nMathematics 5, 285\u2013309.\nT ORRONI , P. 2002. A study on the termination of negotiation dialogues. In Proceedings of Autonomous Agents and Multi Agent Systems 2002. ACM Press, 1223\u20131230.\nG ELDER , A., ROSS , K. A., AND S CHLIPF, J. S. 1991. The well-founded semantics for general\nlogic programs. Journal of the ACM 38, 3 (July), 620\u2013650.\n\nVAN\n\nV REESWIJK , G. A. W. 1997. Abstract argumentation systems. Artificial Intelligence 90, 1\u20132, 225\u2013\n279.\nWAGNER , G. 1994. Vivid Logic \u2013 Knowledge-Based Reasoning with Two Kinds of Negation. Vol.\nLNAI 764. Springer\u2013Verlag.\n\n\fA Hierarchy of Argumentation Semantics\n\n33\n\nAppendix A Proofs of Theorems\nTheorem 3\nLet x\u2032 \u2286 x and y \u2286 y \u2032 be notions of attack, then Jx/y \u2286 Jx\u2032 /y\u2032 .\nProof\n\u03b1\nWe show by transfinite induction that Jx/y\n\u2286 Jx\u03b1\u2032 /y\u2032 , for all \u03b1.\nBase case: \u03b1 = 0: Then Jx/y = \u2205 = Jx\u2032 /y\u2032 .\nSuccessor ordinal: \u03b1\n\u03b1 + 1:\n\u03b1+1\n\u03b1\nLet A \u2208 Jx/y\n, and (B, A) \u2208 x\u2032 . Then also (B, A) \u2208 x, and so there exists C \u2208 Jx/y\nsuch that (C, B) \u2208 y, so also (C, B) \u2208 y \u2032 . By induction hypothesis, C \u2208 Jx\u03b1\u2032 /y\u2032 , and so\nA \u2208 Jx\u03b1+1\n\u2032 /y \u2032 .\nLimit ordinal \u03bb:\n\u03b1\nAssume Jx/y\n\u2286 Jx\u03b1\u2032 /y for all \u03b1 < \u03bb. Then\nS\nS\n\u03bb\n\u03b1\nJx/y = \u03b1<\u03bb Jx/y\n\u2286 \u03b1<\u03bb Jx\u03b1\u2032 /y\u2032 = Jx\u03bb\u2032 /y\u2032\nTheorem 4\nLet x and and y be notions of attack such that x \u2287 undercuts, and let sy = y\u2212undercuts\u22121 .\nThen Jx/y = Jx/sy .\nProof\nBy Theorem 3, we have Jx/sy \u2286 Jx/y . We prove the inverse inclusion by showing that for\n\u03b1\n\u03b1\nall ordinals \u03b1: Jx/y\n\u2286 Jx/sy\n, by transfinite induction on \u03b1.\nBase case \u03b1 = 0: Jx/y = \u2205 = Jx/sy .\n\u03b1+1\nSuccessor ordinal \u03b1\n\u03b1 + 1: Let A \u2208 Jx/y\n, and (B, A) \u2208 x. By definition, there exists\n\u03b1\n\u03b1\nC \u2208 Jx/y such that (C, B) \u2208 y. By induction hypothesis, C \u2208 Jx/sy\n.\nIf B does not undercut C, then we are done. If, however, B undercuts C, then because\n\u03b10\n\u03b1\n(\u03b10 < \u03b1) such that (D, B) \u2208 sy.\nC \u2208 Jx/sy\n, and undercuts \u2286 x, there exists D \u2208 Jx/sy\n\u03b1+1\nIt follows that A \u2208 Jx/sy .\nS\n\u03b1\n\u03b1\n\u03b1\n\u03bb\n\u2286\nLimit ordinal \u03bb: Assume Jx/y\n\u2286 Jx/sy\nfor all \u03b1 < \u03bb. Then Jx/y\n= \u03b1<\u03bb Jx/y\nS\n\u03b1\n\u03bb\nJ\n=\nJ\n\u03b1<\u03bb x/sy\nx/sy\n\nTheorem 6\nLet x be a notion of attack such that x \u2287 strongly attacks. Then Jx/u = Jx/d = Jx/a .\nProof\nIt is sufficient to show that Jx/a \u2286 Jx/u . Then by Theorem 3, Jx/u \u2286 Jx/d \u2286 Jx/a = Jx/u .\n\u03b1\n\u03b1\nWe prove by transfinite induction that for all ordinals \u03b1: Jx/a\n\u2286 Jx/u\n.\n\nBase case: \u03b1 = 0\n\u03b1\n\u03b1\nJx/a\n= \u2205 = Jx/u\n.\n\nSuccessor ordinal: \u03b1\n\n\u03b1+1\n\n\f34\n\nRalf Schweimeier and Michael Schroeder\n\n\u03b1+1\n\u03b1\nLet A \u2208 Jx/a\n, and (B, A) \u2208 x. By definition, there exists C \u2208 Jx/a\nsuch that C undercuts\n\u03b1\nor rebuts B. By induction hypothesis, C \u2208 Jx/u .\nIf C undercuts B, then we are done. If, however, C does not undercut B, then C rebuts\nB, and so B also rebuts C, i.e. B strongly attacks C. Because strongly attacks \u2286 x and\n\u03b10\n\u03b1\n\u03b1\n\u2286 Jx/u\n(\u03b10 < \u03b1) such that D undercuts B. It follows\nC \u2208 Jx/u\n, there exists D \u2208 Jx/u\n\u03b1+1\nthat A \u2208 Jx/u\n.\n\nLimit ordinal \u03bb:\n\u03b1\n\u03b1\n\u03bb\nAssume Jx/a\n\u2286 Jx/u\nfor all \u03b1 < \u03bb. Then Jx/a\n=\n\nS\n\n\u03b1<\u03bb\n\n\u03b1\nJx/a\n\u2286\n\nS\n\n\u03b1<\u03bb\n\n\u03b1\n\u03bb\nJx/u\n= Jx/u\n.\n\nTheorem 7\nJsa/su = Jsa/sa\nProof\nBy Theorem 3, Jsa/su \u2286 Jsa/sa .\n\u03b1\n\u03b1\nWe prove the inverse inclusion by showing that for all ordinals \u03b1: Jsa/sa\n\u2286 Jsa/su\n, by\ntransfinite induction on \u03b1.\nBase case: n = 0\n0\n0\nJsa/sa\n= \u2205 = Jsa/su\n\nSuccessor ordinal: \u03b1\n\n\u03b1+1\n\n\u03b1+1\n\u03b1\nLet A \u2208 Jsa/sa\n, and B strongly attacks A. By definition, there exists C \u2208 Jsa/sa\nsuch that\n\u03b1\nC attacks B and B does not undercut C. By induction hypothesis, C \u2208 Jsa/su .\nIf C undercuts B, then we are done. If, however, C rebuts B and C does not undercut\n\u03b1\nB, then B also rebuts C, i.e. B strongly attacks C, and so because C \u2208 Jsa/su\nthere\n\u03b10\n\u03b1\nexists D \u2208 Jsa/su \u2286 Jsa/su (\u03b10 < \u03b1) such that D strongly undercuts B. It follows that\n\u03b1+1\nA \u2208 Jsa/su\n(\u2205).\n\nLimit ordinal \u03bb:\n\u03b1\n\u03b1\n\u03bb\nAssume Jsa/sa\n\u2286 Jsa/su\nfor all \u03b1 < \u03bb. Then Jsa/sa\n=\n\u03bb\nJsa/su .\n\nS\n\n\u03b1<\u03bb\n\n\u03b1\nJsa/sa\n\u2286\n\nS\n\n\u03b1<\u03bb\n\n\u03b1\nJsa/su\n=\n\nTheorem 8\nJsu/a = Jsu/d\nProof\nBy Theorem 3, Jsu/d \u2286 Jsu/a .\n\u03b1\n\u03b1\nFor the inverse inclusion, we show that for all ordinals \u03b1: Jsu/a\n\u2286 Jsu/d\n, by transfinite\ninduction on \u03b1.\n\nBase case: \u03b1 = 0\n\n\fA Hierarchy of Argumentation Semantics\n\n35\n\n0\n0\nJsu/a\n= \u2205 = Jsu/d\n\nSuccessor ordinal: \u03b1\n\n\u03b1+1\n\n\u03b1+1\n\u03b1\nLet A \u2208 Jsu/a\n, and B strongly undercuts A. By definition, there exists C \u2208 Jsu/a\nsuch that\n\u03b1\nC undercuts or rebuts B. By induction hypothesis, C \u2208 Jsu/d .\nIf C undercuts B, or B does not undercut C, then we are done.\n\u03b10\n\u03b1\nOtherwise, B strongly undercuts C, and so there exists D \u2208 Jsu/d\n\u2286 Jsu/d\n(\u03b10 < \u03b1)\n\u03b1+1\nsuch that D defeats B. It follows that A \u2208 Jsu/d .\n\nLimit ordinal \u03bb:\n\u03b1\n\u03b1\nAssume Jsu/a\n\u2286 Jsu/d\nfor all \u03b1 < \u03bb. Then\n[\n[\n\u03bb\n\u03bb\n\u03b1\n\u03b1\n=\n\u2286\nJsu/a\n= Jsu/d\nJsu/a\nJsu/d\n\u03b1<\u03bb\n\n\u03b1<\u03bb\n\nLemma 15\nLet I be a two-valued interpretation.\n1. L \u2208 \u0393(I) iff \u2203 argument A with conclusion L such that assm(A) \u2286 I.\n2. L \u2208 \u0393s (I) iff \u2203 argument A with conclusion L such that assm(A) \u2286 I and\n\u00acconc(A) \u2229 I = \u2205.\n3. L 6\u2208 \u0393(I) iff \u2200 arguments A with conclusion L, assm(A) \u2229 I 6= \u2205.\n4. L 6\u2208 \u0393s (I) iff \u2200 arguments A with conclusion L, assm(A) \u2229 I 6= \u2205 or\n\u00acconc(A) \u2229 I 6= \u2205.\nProof\n1. \"Only If\"-direction: Induction on the length n of the derivation of L \u2208 \u0393(I).\nBase case: n = 1:\nThen there exists a rule L \u2190 not L1 , . . . , not Ln in P s.t. L1 , . . . , Ln 6\u2208 I, and\n[L \u2190 not L1 , . . . , not Ln ] is an argument for L whose assumptions are contained\nin I.\nInduction step: n\nn + 1:\nLet L \u2208 \u0393n+1 (I). Then there exists a rule r = L \u2190 L1 , . . . , Ln , not L\u20321 , . . . , L\u2032m\nin P s.t. Li \u2208 \u0393n (I), and L\u2032i 6\u2208 I. By induction hypothesis, there exists arguments\nA1 , . . . , An for L1 , . . . , Ln with assm(Ai ) \u2286 I. Then A = [r] * A1 * * * An is an\nargument for L such that assm(A) \u2286 I.\n\"If\" direction: Induction on the length of the argument.\nBase case: n = 1:\nThen A = [L \u2190 not L1 , . . . , not Ln ], and L1 , . . . , Ln 6\u2208 I. Then L \u2190\u2208\nL \u2208 \u03931 (I).\nInduction step: n\n\nn + 1:\n\nP\nI\n\n, and\n\n\f36\n\nRalf Schweimeier and Michael Schroeder\nLet A = [L \u2190 L1 , . . . , Ln , not L\u20321 , . . . , not L\u2032m ; r2 , . . . , rn ] be an argument s.t.\nassm(A) \u2286 I. A contains subarguments A1 , . . . , An for L1 , . . . , Ln , with assm(Ai ) \u2286\nI. Because L\u20321 , . . . , L\u2032m 6\u2208 I, then L \u2190 L1 , . . . , Ln \u2208 PI . By induction hypothesis,\nLi \u2208 \u0393(I). so also L \u2208 \u0393(I).\n2. \"Only If\"-direction: Induction on the length n of the derivation of L \u2208 \u0393s (I).\nBase case: n = 1:\nThen there exists a rule L \u2190 not L1 , . . . , not Ln in P s.t. \u00acL, L1 , . . . , Ln 6\u2208 I, and\n[L \u2190 not L1 , . . . , not Ln ] is an argument for L whose assumptions are contained\nin I, and \u00acL 6\u2208 I.\nInduction step: n\nn + 1:\nLet L \u2208 \u0393n+1 (I). Then there exists a rule r = L \u2190 L1 , . . . , Ln , not L\u20321 , . . . , L\u2032 m\nin P s.t. Li \u2208 \u0393n (I), L\u2032i 6\u2208 I, and \u00acL 6\u2208 I. By induction hypothesis, there exists\narguments A1 , . . . , An for L1 , . . . , Ln with assm(Ai ) \u2286 I and \u00acconc(Ai ) \u2229 I =\n\u2205. Then A = [r] * A1 * * * An is an argument for L such that assm(A) \u2286 I, and\n\u00acconc(A) \u2229 I = \u2205.\n\"If\" direction: Induction on the length of the argument.\nBase case: n = 1:\nThen A = [L \u2190 not L1 , . . . , not Ln ], and \u00acL, L1 , . . . , Ln 6\u2208 I. Then L \u2190\u2208\nand L \u2208 \u03931 (I).\n\nPs\nI ,\n\nInduction step: n\nn + 1:\nLet A = [L \u2190 L1 , . . . , Ln , not L\u20321 , . . . , not L\u2032m ; r2 , . . . , rn ] be an argument s.t.\nassm(A) \u2286 I, and \u00acconc(A) \u2229 I = \u2205. A contains subarguments A1 , . . . , An for\nL1 , . . . , Ln , with assm(Ai ) \u2286 I, and \u00acconc(Ai )\u2229I = \u2205. Because L\u20321 , . . . , L\u2032m 6\u2208 I,\nand \u00acL 6\u2208 I, then L \u2190 L1 , . . . , Ln \u2208 PI . By induction hypothesis, Li \u2208 \u0393(I), so\nalso L \u2208 \u0393(I).\n3. and 4. follow immediately from 1. and 2. because I is two-valued.\n\nTheorem 19\nAn argument A is x/y-justified iff there exists a x/y-dialogue tree with A as its root, and\nwon by the proponent.\nProof\n\u03b1\n\"If\"-direction. We show by transfinite induction: If A \u2208 Jx/y\n, then there exists a winning\nx/y-dialogue tree of height \u2264 \u03b1 for A.\nBase case \u03b1 = 0:\nThen there exists no argument B such that (B, A) \u2208 x, and so A is a winning x/y-dialogue\ntree for A of height 0.\nSuccessor ordinal \u03b1 + 1:\n\u03b1+1\n\u03b1\nIf A \u2208 Jx/y\n, then for any Bi such that (Bi , A) \u2208 x there exists a Ci \u2208 Jx/y\nsuch that\n(Ci , Bi ) \u2208 y. By induction hypothesis, there exist winning x/y-dialogue trees for the Ci .\nFurthermore, if any of the Ci contains a move m = (P, A), then it also contains a winning\nsubtree for A rooted at m and we are done. Otherwise, we have a winning tree rooted at A,\n\n\fA Hierarchy of Argumentation Semantics\n\n37\n\nwith children Bi , whose children are the winning trees for Ci .\nLimit ordinal \u03bb:\n\u03bb\n\u03b1\nIf A \u2208 Jx/y\n, then there exists an \u03b1 < \u03bb such that A \u2208 Jx/y\n; by induction hypothesis, there\nexists a winning x/y-dialogue tree of height \u03b1 for A.\n\"Only-if\"-direction. We prove by transfinite induction: If there exists a winning tree of\n\u03b1\nheight \u03b1 for A, then A \u2208 Jx/y\n.\nNote that by definition, the height of a dialogue tree is either 0 or a successor ordinal\n\u03b1+1. So we prove the base case 0, and for the induction step, we assume that the induction\nhypothesis holds for all \u03b2 < \u03b1 + 1.\nBase case \u03b1 = 0:\n0\nThen there are no arguments B such that (B, A) \u2208 x, and so A \u2208 Jx/y\n.\nSuccessor ordinal \u03b1 + 1:\nLet T be a tree with root A, whose children are Bi , and the children of Bi are winning trees\n\u03b1\nrooted at Ci . By induction hypothesis, Ci \u2208 Jx/y\n. Because the Bi are all those arguments\n\u03b1+1\nsuch that (Bi , A) \u2208 x, then A is defended against each Bi by Ci , and so A \u2208 Jx/y\n.\n\n\f"}