{"id": "http://arxiv.org/abs/0708.1021v4", "guidislink": true, "updated": "2007-09-27T21:45:31Z", "updated_parsed": [2007, 9, 27, 21, 45, 31, 3, 270, 0], "published": "2007-08-07T20:01:22Z", "published_parsed": [2007, 8, 7, 20, 1, 22, 1, 219, 0], "title": "Codeword Stabilized Quantum Codes", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0708.2355%2C0708.1670%2C0708.2056%2C0708.2103%2C0708.1447%2C0708.0668%2C0708.0753%2C0708.2064%2C0708.1653%2C0708.3833%2C0708.0437%2C0708.0795%2C0708.3626%2C0708.0829%2C0708.0440%2C0708.3664%2C0708.0914%2C0708.1021%2C0708.4216%2C0708.1937%2C0708.3951%2C0708.1134%2C0708.0345%2C0708.2014%2C0708.3743%2C0708.3469%2C0708.2095%2C0708.0745%2C0708.4168%2C0708.0973%2C0708.3166%2C0708.0453%2C0708.3564%2C0708.1420%2C0708.0858%2C0708.3605%2C0708.3221%2C0708.0281%2C0708.2433%2C0708.1560%2C0708.3009%2C0708.4401%2C0708.1235%2C0708.2235%2C0708.3289%2C0708.1266%2C0708.1972%2C0708.2353%2C0708.4141%2C0708.0942%2C0708.2807%2C0708.1541%2C0708.4410%2C0708.1998%2C0708.0400%2C0708.0331%2C0708.1040%2C0708.0610%2C0708.3115%2C0708.2047%2C0708.2293%2C0708.2385%2C0708.2347%2C0708.4240%2C0708.2199%2C0708.4306%2C0708.4226%2C0708.0067%2C0708.0154%2C0708.0180%2C0708.1985%2C0708.4393%2C0708.0929%2C0708.2201%2C0708.2739%2C0708.2951%2C0708.4157%2C0708.4227%2C0708.2501%2C0708.0456%2C0708.3942%2C0708.1199%2C0708.1970%2C0708.3153%2C0708.1470%2C0708.1775%2C0708.3910%2C0708.2924%2C0708.1853%2C0708.0441%2C0708.0426%2C0708.3045%2C0708.1263%2C0708.4017%2C0708.3015%2C0708.2991%2C0708.4228%2C0708.1336%2C0708.2006%2C0708.3168%2C0708.1315&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Codeword Stabilized Quantum Codes"}, "summary": "We present a unifying approach to quantum error correcting code design that\nencompasses additive (stabilizer) codes, as well as all known examples of\nnonadditive codes with good parameters. We use this framework to generate new\ncodes with superior parameters to any previously known. In particular, we find\n((10,18,3)) and ((10,20,3)) codes. We also show how to construct encoding\ncircuits for all codes within our framework.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0708.2355%2C0708.1670%2C0708.2056%2C0708.2103%2C0708.1447%2C0708.0668%2C0708.0753%2C0708.2064%2C0708.1653%2C0708.3833%2C0708.0437%2C0708.0795%2C0708.3626%2C0708.0829%2C0708.0440%2C0708.3664%2C0708.0914%2C0708.1021%2C0708.4216%2C0708.1937%2C0708.3951%2C0708.1134%2C0708.0345%2C0708.2014%2C0708.3743%2C0708.3469%2C0708.2095%2C0708.0745%2C0708.4168%2C0708.0973%2C0708.3166%2C0708.0453%2C0708.3564%2C0708.1420%2C0708.0858%2C0708.3605%2C0708.3221%2C0708.0281%2C0708.2433%2C0708.1560%2C0708.3009%2C0708.4401%2C0708.1235%2C0708.2235%2C0708.3289%2C0708.1266%2C0708.1972%2C0708.2353%2C0708.4141%2C0708.0942%2C0708.2807%2C0708.1541%2C0708.4410%2C0708.1998%2C0708.0400%2C0708.0331%2C0708.1040%2C0708.0610%2C0708.3115%2C0708.2047%2C0708.2293%2C0708.2385%2C0708.2347%2C0708.4240%2C0708.2199%2C0708.4306%2C0708.4226%2C0708.0067%2C0708.0154%2C0708.0180%2C0708.1985%2C0708.4393%2C0708.0929%2C0708.2201%2C0708.2739%2C0708.2951%2C0708.4157%2C0708.4227%2C0708.2501%2C0708.0456%2C0708.3942%2C0708.1199%2C0708.1970%2C0708.3153%2C0708.1470%2C0708.1775%2C0708.3910%2C0708.2924%2C0708.1853%2C0708.0441%2C0708.0426%2C0708.3045%2C0708.1263%2C0708.4017%2C0708.3015%2C0708.2991%2C0708.4228%2C0708.1336%2C0708.2006%2C0708.3168%2C0708.1315&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a unifying approach to quantum error correcting code design that\nencompasses additive (stabilizer) codes, as well as all known examples of\nnonadditive codes with good parameters. We use this framework to generate new\ncodes with superior parameters to any previously known. In particular, we find\n((10,18,3)) and ((10,20,3)) codes. We also show how to construct encoding\ncircuits for all codes within our framework."}, "authors": ["Andrew Cross", "Graeme Smith", "John A. Smolin", "Bei Zeng"], "author_detail": {"name": "Bei Zeng"}, "author": "Bei Zeng", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1109/TIT.2008.2008136", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/0708.1021v4", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0708.1021v4", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "5 pages, 1 eps figure, ((11,48,3)) code removed, encoding circuits\n  added, typos corrected in codewords and elsewhere", "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0708.1021v4", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0708.1021v4", "journal_reference": "IEEE Trans. Info. Theory 55, 1, 433-438 (2009)", "doi": "10.1109/TIT.2008.2008136", "fulltext": "1\n\nCodeword Stabilized Quantum Codes\n\narXiv:0708.1021v4 [quant-ph] 27 Sep 2007\n\nAndrew Cross, Graeme Smith, John A. Smolin and Bei Zeng\n\nAbstract- We present a unifying approach to quantum error\ncorrecting code design that encompasses additive (stabilizer)\ncodes, as well as all known examples of nonadditive codes with\ngood parameters. We use this framework to generate new codes\nwith superior parameters to any previously known. In particular,\nwe find ((10, 18, 3)) and ((10, 20, 3)) codes. We also show how to\nconstruct encoding circuits for all codes within our framework.\nIndex Terms- quantum error correction, nonadditive codes,\nstabilizer codes\n\nI. I NTRODUCTION\nQuantum computers hold the promise of the efficient solution of problems, such as factoring [1] and simulation of\nquantum systems [2], [3], [4] that are generally believed to\nbe intractable on a classical computer. Furthermore, as the\nprocessor size in state-of-the-art computers continues to scale\ndown and performance begins to be limited by dissipative\neffects in logical processing, it has become increasingly clear\nthat considering the quantum nature of the components of\na classical computer will be essential in the not-too-distantfuture. In both of these scenarios-constructing a working\nquantum computer, or simply continuing to improve the performance of classical computers-quantum error correcting\ncodes and ideas from quantum fault-tolerance [5] will be\nessential elements in the future computer engineer's toolbox.\nStabilizer codes are an important class of quantum codes\ndeveloped in [6], [7], and are the quantum analogues of\nclassical additive codes. An [n, k] stabilizer code encodes k\nlogical qubits into n physical qubits, and is described by an\nabelian subgroup, S, of the Pauli group with size |S| = 2n\u2212k .\nThe codespace is the set of simultaneous eigenvectors of S\nwith eigenvalue 1. There is a rich theory of stabilizer codes,\nand a thorough understanding of their properties.\nNevertheless, such codes are strictly suboptimal in some\nsettings-there exist nonadditive codes which encode a larger\nlogical space than possible with a stabilizer code of the same\nlength and capable of tolerating the same number of errors.\nThere are only a handful of such examples [8], [9], [10], and\ntheir constructions have proceeded in an ad hoc fashion, each\ncode working for seemingly different reasons.\nIn the following we present a framework for code design\nthat includes as special cases stabilizer codes as well as all\nknown nonadditive codes with good parameters. We note\nthat the code of [10] was presented explicitly in the form\nAndrew Cross is with the Department of Electrical Engineering, Massachusetts Institute of Technology, Cambridge MA 02139, USA\nAndrew Cross, Graeme Smith and John Smolin are with IBM T.J. Watson\nResearch Center, Yorktown Heights, NY 10598, USA\nBei Zeng is with the Department of Physics, Massachusetts Institute of\nTechnology, Cambridge, MA 02139, USA\nGS was partially supported by the UK Engineering and Physical Sciences\nResearch Council, JAS was supported by ARO contract DAAD19-01-C-0056.\n\nwe describe below and, indeed, served as motivation for our\nstudies of the generality of such a construction. Our codes are\nfully described by two objects: a single stabilizer state |Si,\nand a classical code that generates the basis vectors of our\ncode from |Si. The stabilizer is chosen such that it maps all\nPauli errors onto only Z errors, though this may increase their\nweight. In this way we map the problem of finding a quantum\ncode to that of finding a classical code that corrects an unusual\nerror model. We have thus unified stabilizer and nonadditive\ncodes and rendered both in a form that gives insight into the\nclassical nature of quantum error-correction.\nOur approach is related to the description of nonadditive\ncodes given in [11] in terms of Boolean functions Our codeword operators, codeword stabilizer, and effective classical\nerrors correspond, respectively, to a Boolean function f , a\nmatrix Af , and the \"Zset\" in the language of that work. Their\napproach is essentially dual to ours-in the language we use\nhere it amounts to first choosing a classical code and trying to\ndesign a stabilizer state whose induced error model is corrected\nby the chosen code. From this perspective, the approach of [11]\nseems somewhat unnatural, which is perhaps the reason it has\nnot proved useful for finding new codes. Both approaches are\nclosely related to the work of [12], [13].\nWe describe codes on n qubits that encode K dimensions\nwith distance d (traditionally written ((n, K, d))). In this\nframework we find the original nonadditive ((5, 6, 2)) code of\n[8] and the family it generates, the simple family of distance\n2 codes found in [9], the ((9, 12, 3)) code of [10], as well as\nnew ((10, 18, 3)) and ((10, 20, 3)) codes.\nII. G ENERAL\n\nCONSTRUCTION AND\n\nP ROPERTIES\n\nAn ((n, K)) code will be described by two objects-S, a\n2n element abelian subgroup of the Pauli group not containing\nminus the identity, which we call the word stabilizer, together\nwith a family of K n-qubit Pauli elements, W = {wl }K\nl=1 ,\nwhich we call the word operators. There is a unique state |Si\nstabilized by S, i.e. |Si satisfies s|Si = |Si for all s \u2208 S. Our\ncode will be spanned by basis vectors of the form\n|wl i \u2261 wl |Si.\n\n(1)\n\nSince the code vectors should all be different, at most one wl\ncan be in S. Typically we will choose w1 = I and later we will\nprove this can be done without loss of generality. Note that\n|wl i is an eigenvector of all s \u2208 S with eigenvalue \u03bbs = \u00b11,\nbut |wl i is not stabilized by S unless wl \u2208 S. Each |wl i is\nstabilized by a different stabilizer wl Swl\u2020 .\nWe would now like to understand the error correction\ncapabilities of such a codeword stabilized (CWS) code. An\n((n, K, d)) code is an ((n, K)) code capable of detecting Pauli\nerrors of weight up to d \u2212 1, but not d, and is said to have\n\n\f2\n\nminimum distance d. A distance d code can also be used to\ncorrect errors up to weight \u230a(d \u2212 1)/2\u230b. The conditions for\nerror correction were found in [14], [15]. The error correction\nconditions for a general code with basis vectors |wl i are that,\nin order to detect errors from a set E, it is necessary and\nsufficient to have\nhci |E|cj i = cE \u03b4ij\n\n(2)\n\n1\n\nZ\n\n2\n\n6\n\n7\n\nZ\n\nfor all E \u2208 E. For a code of the form described above, this\nbecomes\nhS|wi\u2020 Ewj |Si = cE \u03b4ij .\n(3)\nTo correct errors on a fixed number of qubits, it is sufficient\nto study errors of the form Z v X u with bounded weight since\nthese form a basis [14]. This leads to the necessary and\nsufficient conditions for detecting errors in E that for all E \u2208 E\n\u2200i 6= j wi\u2020 Ewj 6\u2208 \u00b1S\n\n(4)\n\nand\n\u0011\n\u2200i wi\u2020 Ewi 6\u2208 \u00b1S or\n\u0010\n\u0011\n\u2200i wi\u2020 Ewi \u2208 S or\n\u0011\n\u0010\n\u2200i wi\u2020 Ewi \u2208 \u2212S\n\n\u0010\n\n(5)\n\n(7)\n\nTheorem 1 An ((n, K)) codeword stabilized code with word\noperators W = {wl }K\nl=1 and codeword stabilizer S is locally\nClifford-equivalent to a codeword stabilized code with word\noperators wl\u2032 = Z cl and codeword stabilizer S \u2032 generated by\n\nProof: First note that S is local-Clifford equivalent to\na graph state due to [16],\nlocalNn[17], [18]so there is some\n\u2032\nClifford unitary C =\nl=1 Cl that maps S to S of the\nform (8). In the new basis the word operators are Cwl C \u2020 =\n\u00b1Z al X bl , and we have\nY\n(b )\n(Si\u2032 ) l i = \u00b1Z cl ,\n(9)\nCwl C \u2020\ni\n\nso that, letting\n\nX\n\n4\n\nZ\n\nFig. 1. Example of the induced error on a graph state: The state has stabilizer\ngenerators XZIIIZZ, ZXZIIII, IZXZIIZ, IIZXZII, IIZZXZZ,\nZIIIZXI, and ZIZIZIX. An X error applied to node 5 in the lower-left\nis translated by multiplying with the stabilizer element IIZZXZZ and turns\ninto Z errors on the nodes indicated.\n\nthrough the E in the error-correction conditions which can at\nworst pick up a sign depending only on E. The two conditions\nwith \u00b1S on the right are insensitive to this and the other two\nconditions at most change places.\nThis structure theorem gives rise to the following lemma,\nwhich is at the heart of our construction:\nLemma 2 A single qubit Pauli error Z, X or Y = ZX\nacting on a codeword w|Si of a CWS code in standard form is\nequivalent up to a sign to another (possibly multi-qubit) error\nconsisting only of Zs.\n\n(8)\n\nIn other words, any CWS code is locally equivalent to a\nCWS code with a graph-state stabilizer and word operators\nconsisting only of Zs. The set of rl s form the adjacency matrix\nof the graph. Moreover, the word operators can always be\nchosen to include the identity. We call this standard form.\n\nwl\u2032\n\n5\n\nZ\n\n(6)\n\nEq. (4) is the condition that two codewords should not be\nconfused after an error, while the final three conditions express\nthat each error must either be detected (Eq. (5)), or the code\nmust be \"immune\" to it\u2013i.e. the code is degenerate.\n\nSl\u2032 = Xl Z rl .\n\n3\n\ncl\n\n= Z , we have\n\nZ cl |S \u2032 i = \u00b1Cwl C \u2020 s\u2032 |S \u2032 i = \u00b1Cwl C \u2020 |S \u2032 i = \u00b1Cwl |Si.\nSince C consists of local Clifford elements, we see that the\nCWS code defined by S \u2032 and w\u2032 is locally Clifford equivalent\nto the original code.\nFinally, to ensure the codeword operators include the identity we can choose W\u0303 = {w\u0303l =wl\u2032 w1\u2032 } which always has\nw\u03031 = Identity. This can be seen by commuting the w1\u2032\n\nProof: Let the error Ei act only on the ith qubit. If it\nis a Z error the result is immediate. Otherwise use the fact\nthat Ei w|Si = \u00b1Ei Si w|Si, and take Si to be the generator\n{0,1}\nXi the X in Ei\nhaving X on bit i. Then since Ei = Zi\ncancels with the X from Si and we are left with the Zs from\nSi as well as a Zi if Ei was Zi Xi .\nLemma 2 allows us to construct CWS codes with a satisfying interpretation: X errors on any qubit are \"pushed\"\noutwards along the edges of the graph and transformed into\nZs. This is illustrated in figure 1. Similarly Y errors are pushed\nalong the edges, but also leave a Z behind at their original\nlocations. Since all errors become Zs, we can think of the\nerror model as classical, albeit consisting of strange multibit errors. We define this translation to classical errors by the\nfunction ClS (E \u2208 E) \u2192 {0, 1}n:\nClS (E = \u00b1Z v X u ) = v \u2295\n\nn\nM\n\n(u)l rl\n\n(10)\n\nl=1\n\nwhere rl is the lth row of the stabilizer's adjacency matrix\n(recall from Eq. (8) Sl = Xl Z rl defines rl ). The codeword\noperators wl = Z cl will be chosen to so that the cl s are a\nclassical code for this error model.\n\n\f3\n\nTheorem 3 A CWS code in standard form with stabilizer S\nand codeword operators {Z c }c\u2208C detects errors from E if and\nonly if C detects errors from ClS (E) and in addition we have\nfor each E,\nClS (E)\nci\n\nor \u2200i Z E\n\n6= 0\n\n= EZ\n\n(11)\nci\n\n.\n\n(12)\n\nThus, any CWS code is completely specified by a graph state\nstabilizer S and a classical code C.\nwi\u2020 Ewj\n\nProof: When i 6= j,\n6\u2208 \u00b1S is satisfied exactly when Z ci EZ cj 6\u2208 \u00b1S, which is in turn equivalent to\nZ ci Z ClS (E) Z cj 6\u2208 \u00b1S. In standard form, the only element of\nS without any X is the identity, so that this is satisfied exactly\nwhen ci \u2295 ClS (E) 6= cj . This is explicitly the classical errordetection condition.\nSimilarly, when i = j, we must satisfy Eqs. (5), (6) and (7),\nwhose three possibilities translate directly to\n\u2200c Z c EZ c 6\u2208 \u00b1S\nc\n\n(13)\n\nc\n\nor \u2200c Z EZ \u2208 S\nor \u2200c Z c EZ c \u2208 \u2212S.\n\n(14)\n(15)\n\nSince Z c = I for the c = 0 codeword, Eq. (13) is equivalent\nto E 6\u2208 \u00b1S and therefore to (11). If (11) (and therefore (13))\nis not satisfied, E \u2208 \u00b1S. If any Z c anticommutes with E we\nhave also E \u2208 \u2213S. Since no s \u2208 S is also in \u2212S this readily\nimplies the equivalence of (12) to (14) and (15).\nRemark A classical code expressed in quantum terms would\ntraditionally comprise computational basis vectors that are\neigenstates of Z, and therefore the operators mapping one\ncodeword to another would be of the form X c as these are\nthe only errors that have any effect. It then might seem odd\nthat standard form for CWS codes, the intuition of which is to\nmake everything classical, would employ word operators and\neffective errors consisting only of Zs. This choice is arbitrary\n(one could exchange Z and X and nothing in the formalism\nwould be affected) and is made since the usual form of a\ngraph state stabilizer is to have one X and some number of\nZs rather than the reverse. We hope this historical accident\ndoes not cause too much confusion going forward.\n\u2293\n\u2294\n\nProof: To see that this CWS code describes the original\ncode, note that the stabilizer state associated with S is |0\u0304 . . . 0\u0304i,\nwhile the codeword generated by Wv acting on |0\u0304 . . . 0\u0304i is\n|(v\u0304)1 . . . (v\u0304)k i.\nTheorem 5 If the word operators of an ((n, K)) CWS code\nare an abelian group W (not containing \u2212I), then the code\nis an [n, k = log2 K] stabilizer code.\nProof: The stabilizer S of the CWS code is a maximal\nabelian subgroup of the Paulis (not containing \u2212I) therefore it\nis isomorphic to the group S \u2032 = hX1 . . . Xn i and the mapping\nfrom S to S \u2032 is a Clifford operation C (not necessarily local).\nThis follows from the definition of the Clifford group as the\nautomorphisms of the Pauli group. Because this automorphism\ngroup allows one to achieve any bijective mapping that preserves commutation relations (see Chapter 4 of [6]), the map\ncan further be chosen to map W to W \u2032 = hZ1 . . . Zk i. Here\nwe have made use of the facts that all w \u2208 W anticommute\nwith at least one s \u2208 S (which implies S \u2229 W = {I}) and\nthat S \u2032 is maximal, which allows us to choose for W \u2032 any\norder K group made only of Zs we like (since all products\nof X's are in S \u2032 ). Note this nonlocal Clifford mapping is not\nthe same as the conversion to Zs used in Theorem 1.\nWe can now choose T \u2032 , X\u0304 \u2032 and Z\u0304 \u2032 as follows:\nX\u0304 \u2032 = W \u2032 = hZ1 . . . Zk i\nZ\u0304 \u2032 = hX1 . . . Xk i\nT \u2032 = hXk+1 . . . Xn i\n\n(18)\n(19)\n(20)\n\nThe inverse Clifford operation C \u2020 maps these to our stabilizer\ncode with stabilizer T , and logical operations X\u0304 = W and Z\u0304.\nIt remains to show this is the same as the CWS code we\nstarted with. T is by construction a subgroup of S (T \u2032 is\nexplicitly generated by a subset of the generators of S \u2032 ) and\ntherefore stabilizes |Si. T also stabilizes all x\u0304|Si, x\u0304 \u2208 X\u0304,\nsince T and X\u0304 commute. Using X\u0304 = W we see these states\nare exactly the basis states of the CWS code.\nIII. E XAMPLES\nWe now give some examples of our construction and\nincluding all known nonadditive codes with good parameters.\n\nA. Relation to Stabilizer codes\nThe CWS framework includes stabilizer codes, and allows\nthem to be understood in a new way. We now show that\nany stabilizer code is a CWS code, and give a method for\ndetermining if a CWS code is also a stabilizer code.\nTheorem 4 An [n, k] stabilizer code with stabilizer generators S1 , . . . , Sn\u2212k and logical operations X\u03041 . . . X\u0304k and\nZ\u03041 . . . Z\u0304k , is equivalent to the CWS code defined by\nS = S1 . . . Sn\u2212k , Z\u03041 . . . Z\u0304k\n\n(16)\n\nand word operators\n(v)1\n\nwv = X\u03041\nwhere v is a k-bit string.\n\n(v)k\n\n\u2297 . . . \u2297 X\u0304k\n\n(17)\n\nA. The [5, 1, 3] code\nThe celebrated [5, 1, 3] quantum code [14], [15] can be written as a CWS code using Eqs. (16) and (17) but another way\nof writing it demonstrates the power of the CWS framework.\nTake generators corresponding to a ring graph:\nSi = ZXZII and cyclic shifts.\n\n(21)\n\nThis induces effective errors as follows. Letting |R5i be the\ngraph state corresponding to the unique simultaneous +1\neigenvector of these generators, we have\nZi |R5i =\n\nXi |R5i =\nYi |R5i =\n\nZi |R5i\n\nZi\u22121 Zi+1 |R5i\nZi\u22121 Zi Zi+1 |R5i,\n\n(22)\n\n\f4\n\nwhere all additions and subtractions are taken modulo 5. The\ncorresponding 15 classical errors are:\nZ : 10000 01000 00100 00010 00001\nX : 01001 10100 01010 00101 10010\nY : 11001 11100 01110 00111 10011\n\n(23)\n\nWe then must choose wl = Z where the cl s form a classical\ncode capable of detecting pairs of these errors. Since no pair\nof these errors produces 11111 the codewords c0 = 00000 and\nc1 = 11111 will serve, and together with the stabilizer (21)\ncompletely define the code. Since the ((5, 2, 3)) code is known\nto be unique we need not otherwise check that our construction\nis equivalent to the traditional presentation of this code. We\nnote also that for n \u2265 7 a ring code with codeword operators\nI and \u2297nl=1 Zl gives a [n, 2, 3] code.\nB. The ((5, 6, 2)) code\nThe first nonadditive quantum code was found in [8],\nand encodes a six-dimensional space into five qubits with a\nminimum distance of two. This outperforms the best additive\nfive qubit distance two code, which can have an encoded\ndimension of at most four. The code was originally found\nas follows: It was known that the linear programming upper\nbound was exactly 6 for a blocklength 5 distance 2 code,\nand in fact it was possible to completely determine what the\nweight enumerator [19] of a code meeting this bound must\nbe. The authors of [8] then performed a numerical search for\nsuch a code, and managed to find one. The structure of the\nresulting code was mysterious, and generating larger codes in\na similar fashion seemed intractable (though [20] showed how\nto construct a ((5 + 2l, 22l+13, 2)) code from this code).\nAs a CWS code the ((5, 6, 2)) code of [8] becomes simple.\nWe again use the ring stabilizer (21) and will have to detect\nthe induced errors (23), but since we are seeking a distance-2\ncode we need only consider single errors rather than pairs.\nThe classical codewords cl , l = 0 . . . 5, are\n\nC. The SSW codes\nA family of distance two codes was found in [9], which\noutperforms the family of [20] for odd blocklengths of eleven\nor larger. The codes were originally described in terms of their\ncodewords as follows. If n = 1 mod 4, a basis of our code\nconsists of vectors of the form\n(25)\n\nwhere x ranges over all n-bit vectors of odd weight less than\n(n \u2212 1)/2 and x\u0304 is the complement of x, while if n = 3\nmod 4, we let x range over even weight vectors of weight\n\n(26)\n\nwith the corresponding stabilizer state being\n\u221a equivalent to a\nGHZ state, (|0i|+i\u2297n\u22121 + |1i|\u2212i\u2297n\u22121 )/ 2. The codeword\noperators are simply Wx = X (x)1 Z ((x)2 ,...(x)n ) for each\nallowed x, which can immediately be seen to generate, up\nto local unitaries, the same codewords as Eq. (25). Putting the\nstabilizer into standard form, we find that the graph state it\ndescribes corresponds to a star graph.\nD. The ((9, 12, 3)) code\nLike the ((5, 6, 2)) code, the codeword stabilizer is of the\nform\nSi = ZXZIIIIII and cyclic shifts\n(27)\nThe associated classical code correcting the induced errors is:\n000000000 100100100 010001100 110101000\n000110001 100010101 011001010 111101110\n001010011 101110111 011111111 111011011\n\n(28)\n\nIV. N EW C ODES\nA. Ring codes: ((10, 18, 3))\nIn light of the excellent performance of ring-stabilizers for\nCWS codes-the ((5, 6, 2)) and ((9, 12, 3)) are both of this\nform-we have studied larger blocklength codes based on this\nstabilizer. This leads to a new code that outperforms stabilizer\ncodes for blocklength 10.\nThe blocklength ten code has a codeword stabilizer generated by hZi\u22121 Xi Zi+1 i and has 18 word operators of the form\nZ cl , with cl taken from the list\n0000000000\n0000011111\n1000111110\n0001000110\n1001010111\n0101110010\n\n(24)\n\nand the code generated by |cR5 i and Wl = Z cl is locally\nClifford equivalent to the ((5, 6, 2)) code of [8]. The ((5 +\n2l, 22l+1 3, 2)) codes of [20] are also CWS codes whose graph\nstate is the union of the ring graph and l Bell pair graphs, and\nwhose classical codewords can be derived straightforwardly\nfrom the ((5, 6, 2)) classical codewords.\n\n|xi + |x\u0304i,\n\nWe now show that these are actually CWS codes. Indeed,\nthe codeword stabilizer of this code will be generated by\nhX1 Z2 . . . Zn , Z1 X2 , Z1 X3 , . . . , Z1 Xn i ,\n\ncl\n\n00000 11010 01101 10110 01011 10101\n\nless than\n1)/2,\n\u0013 leading to an encoded dimension of\n\u0012 (n \u2212\nn\u22121\n)\n((n\u22121)/2\nn\u22122\n.\n1 \u2212 2n\u22121\n2\n\n1101001100\n0010001001\n1100100101\n1010010010\n1011010001\n1110100011\n\n0011001010\n1111100000\n0101101101\n0100110100\n0110111000\n0111111011.\n\n(29)\n\nThat this code satisfies the required error correction conditions can be shown by the straightforward (if tedious) technique of verifying that the associated classical code corrects\nthe classical noise model induced by the ring stabilizer.\nB. A ((10, 20, 3)) Double Ring Code\nWe now consider a CWS code with a codeword stabilizer\nthat is not of the ring form. In particular, our stabilizer will\ncorrespond to the double ring, with generators\nS1\nS2\nS3\nS4\nS5\n\n=\n=\n=\n=\n=\n\nXZIIZZIIII\nZXZIIIZIII\nIZXZIIIZII\nIIZXZIIIZI\nZIIZXIIIIZ\n\nS6\nS7\nS8\nS9\nS10\n\n=\n=\n=\n=\n=\n\nZIIIIXZIIZ\nIZIIIZXZII\nIIZIIIZXZI\nIIIZIIIZXZ\nIIIIZZIIZX.\n\n(30)\n\n\f5\n\nThis leads to a |Si that is a [10, 0, 4] stabilizer state. Our\nclassical code C giving the codeword s operators is\n0000000000\n1001100100\n1001101111\n0101100000\n0000101001\n\n1100101101\n0111011011\n0111010000\n1011011111\n1110010110\n\n1100000100\n1101111110\n1111000101\n0101101011\n0001111010\n\n0010010010\n0010111011\n1011010100\n0011000001\n1110111111.\n\nV. E NCODING C IRCUITS\nThus far, we have focused on the existence and structure\nof CWS codes. We now address a question of fundamental\nimportance: What is the complexity of encoding a CWS code?\nThe answer we find is perhaps the strongest one could hope\nfor: a CWS code will have an efficient encoding circuit as\nlong as there is an efficient encoding circuit for the classical\ncode C.\nWe will use the fact [22] Q\nthat a graph state |Si whose graph\nhas edges E is equal to (j,k)\u2208E P(j,k) H \u2297n |0i\u2297n , where\nP(j,k) is the two qubit controlled phase gate, acting on qubits\nj and k: P |xi|yi = (\u22121)xy |xi|yi.\nTheorem 6 Let S and C define CWS code Q, C be a unitary\nencoding circuit for the classical code C, and Q be the unitary\nmapping |0i\u2297n to |Si. Then,\nU(Q,C) = QC\n\n(31)\n\nis an encoder for Q. In particular, since Q has complexity no\nmore than n2 , if C has complexity f (n), the complexity of our\nencoder is max(n2 , f (n)).\nProof: The ith quantum codeword |ci i is given by C|ii\nwhere ci is the ith codeword of C. So,\nY\n(32)\nP(j,k) H \u2297n X ci |0i\u2297n\nQC|ii =\n(j,k)\u2208E\n\n=\n\nZ ci\n\nY\n\n(j,k)\u2208E\n\n=\n\nP(j,k) H \u2297n |0i\u2297n\n\nZ ci |Si\n\n(33)\n(34)\n\nVI. D ISCUSSION\nWe have presented a new framework for quantum codes\nand shown how it encompasses stabilizer codes, elucidates the\nstructure of the known good nonadditive codes, as well as\ngenerates new nonadditive codes with excellent performance.\nIt should be noted, however, that there do exist quantum codes\noutside of our framework, for example those of [21].\nOur codeword stabilized codes are described by two objects:\nFirst, the codeword stabilizer that without loss of generality\ncan be taken to describe a graph state, and which transforms\nthe quantum errors to be corrected into effectively classical\nerrors. And second, a classical code capable of correcting the\ninduced classical error model. With a fixed stabilizer state,\nfinding a quantum code is reduced to finding a classical code\nthat corrects the (perhaps rather exotic) induced error model.\nWe also show that CWS codes include all stabilizer codes. This\n\nnew way of thinking of stabilizer codes may help to find new\ncodes with good properties. In fact, this method has since been\nused [23] to systematically categorize all codes of n \u2264 8 and\nto find a ((10, 24, 3)) code as well as slightly better distance-2\ncodes.\nIn a future work we hope to expand our work in several\nnew areas. We will give algorithms for finding codes (some of\nwhich were employed to find the new codes presented here)\nas well as bounds on the computational complexity of the\nalgorithms. We also hope to find more new codes, especially\nof distance higher than three.\nR EFERENCES\n[1] P. Shor, \"Algorithms for quantum computation: discrete logarithms and\nfactoring,\" Foundations of Computer Science, pp. 124\u2013134, 1994.\n[2] R. Feynman, \"Simulating physics with computers,\" Internation Journal\nof Theoretical Physics, vol. 21, pp. 467\u2013488, 1982.\n[3] --, \"Quantum mechanical computers,\" Foundations of Physics,\nvol. 16, no. 6, pp. 507\u2013531, 1986.\n[4] S. Lloyd, \"Universal quantum simulators,\" Science, no. 273, p. 1073,\n1996.\n[5] D. Aharonov and M. Ben-Or, \"Fault-tolerant quantum computation with\nconstant error,\" Proceedings of the twenty-ninth annual ACM symposium\non Theory of computing, pp. 176\u2013188, 1997.\n[6] D. Gottesman, \"Stabilizer codes and quantum error correction,\" Caltech\nPh.D. Thesis.\n[7] A. R. Calderbank, E. M. Rains, P. W. Shor, and N. Sloane, \"Quantum\nerror correction via codes over gf(4),\" IEEE Trans. Inf. Theory, vol. 44,\npp. 1369,1387, 1998, arXiv:quant-ph/9608006.\n[8] E. M. Rains, R. H. Hardin, P. W. Shor, and N. J. A. Sloane, \"A\nnonadditive quantum code,\" Phys. Rev. Lett., vol. 79, pp. 953\u2013954, 1997,\narXiv:quant-ph/9703002.\n[9] J. A. Smolin, G. Smith, and S. Wehner, \"A simple family of nonadditive\nquantum codes,\" arXiv:quant-ph/0701065.\n[10] S. Yu, Q. Chen, C. H. Lai, and C. H. Oh, \"Nonadditive quantum errorcorrecting code,\" arXiv:quant-ph/0704.2122.\n[11] V. Aggarwal and A. R. Calderbank, \"Boolean functions, projections\noperators and quantum error correcting codes,\" arXiv:cs/0610159.\n[12] V. Arvind, P. Kurur, and K. Parthasarathy, \"Nonstabilizer quantum codes\nfrom abelian subgroups of the error group,\" arXiv:quant-ph/0210097.\n[13] M. Grassl and T. Beth,\"A note on non-additive quantum codes,\"\narXiv:quant-ph/9703016.\n[14] C. H. Bennett, D. P. DiVincenzo, J. A. Smolin, and W. K. Wootters,\n\"Mixed state entanglement and quantum error correction,\" Phys.Rev. A.,\nvol. 54, pp. 3824\u20133851, 1996, arXiv:quant-ph/9604024.\n[15] E. Knill and R. Laflamme, \"Theory of quantum error-correcting codes,\"\nPhys. Rev. A, vol. 55, no. 2, pp. 900\u2013911, 1997.\n[16] D. Schlingermann, \"Stabilizer codes can be realized as graph codes,\"\nQuantum Information & Computation, vol. 2, no. 4, pp. 307\u2013323, 2002,\narXiv:quant-ph/0111080.\n[17] M. Grassl, A. Klappenecker, and M. R\u00f6tteler, \"Graphs, quadratic form,\nand quantum codes,\" 2002 IEEE International Symposium on Information Theory (ISIT), p. 45, 2002.\n[18] M. Van den Nest, J. Dehaene, and B. DE Moor, \"Graphical description\nof the action of local clifford transformations on graph states,\" Phys.\nRev. A., vol. 69, no. 022316, 2004.\n[19] E. Rains, \"Quantum shadow enumerators,\" IEEE Trans. Inf. Theory,\nvol. 45, no. 7, pp. 2361\u20132366, 1999, arXiv:quant-ph/9611001.\n[20] --, \"Quantum codes of minimum distance two,\" IEEE Trans. Inf.\nTheory, vol. 45, no. 1, pp. 266\u2013271, 1999, arXiv:quant-ph/9704043.\n[21] H. Pollatsek and M.B. Ruskai, \"Permutationally Invariant Codes for\nQuantum Error Correction,\" Lin. Alg. Appl. 392, pp. 255-258 (2004),\narXiv:quant-ph/0304153.\n[22] R. Raussendorf, D.E. Browne, H.J. Briegel, \"Measurement-based quantum computation with cluster states,\" Phys. Rev. A. 68, 022312 (2003)\n[23] S. Yu, Q. Chen and C.H. Oh, \"Graphical Quantum Error-Correcting\nCodes,\" arXiv:0709.1780.\n\n\f"}