{"id": "http://arxiv.org/abs/1104.3469v1", "guidislink": true, "updated": "2011-04-18T13:07:00Z", "updated_parsed": [2011, 4, 18, 13, 7, 0, 0, 108, 0], "published": "2011-04-18T13:07:00Z", "published_parsed": [2011, 4, 18, 13, 7, 0, 0, 108, 0], "title": "Probabilistic Analysis of Loss in Interface Adapter Chaining", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.5391%2C1104.4405%2C1104.3892%2C1104.3521%2C1104.3764%2C1104.0846%2C1104.0698%2C1104.4879%2C1104.0912%2C1104.2066%2C1104.4488%2C1104.4546%2C1104.3738%2C1104.0527%2C1104.1231%2C1104.2940%2C1104.3836%2C1104.4788%2C1104.2114%2C1104.3737%2C1104.0250%2C1104.3150%2C1104.3360%2C1104.0231%2C1104.4219%2C1104.4072%2C1104.0774%2C1104.1743%2C1104.2545%2C1104.1280%2C1104.2434%2C1104.4199%2C1104.3591%2C1104.0365%2C1104.4955%2C1104.1006%2C1104.4034%2C1104.5024%2C1104.0397%2C1104.0551%2C1104.0528%2C1104.1682%2C1104.4005%2C1104.1534%2C1104.5584%2C1104.5231%2C1104.2085%2C1104.1453%2C1104.3327%2C1104.0257%2C1104.2605%2C1104.3745%2C1104.4888%2C1104.4493%2C1104.0778%2C1104.4700%2C1104.2895%2C1104.4235%2C1104.0206%2C1104.5679%2C1104.2922%2C1104.5124%2C1104.1687%2C1104.2989%2C1104.4132%2C1104.3483%2C1104.2861%2C1104.3332%2C1104.1045%2C1104.0934%2C1104.0951%2C1104.1251%2C1104.5513%2C1104.0022%2C1104.2920%2C1104.5551%2C1104.4645%2C1104.4239%2C1104.4957%2C1104.1048%2C1104.0785%2C1104.3228%2C1104.0667%2C1104.0042%2C1104.2544%2C1104.5386%2C1104.5151%2C1104.4202%2C1104.4152%2C1104.3469%2C1104.5249%2C1104.2943%2C1104.4616%2C1104.5140%2C1104.3454%2C1104.4487%2C1104.0693%2C1104.3280%2C1104.4249%2C1104.4434%2C1104.3556&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Probabilistic Analysis of Loss in Interface Adapter Chaining"}, "summary": "Interface adapters allow applications written for one interface to be reused\nwith another interface without having to rewrite application code, and chaining\ninterface adapters can significantly reduce the development effort required to\ncreate the adapters. However, interface adapters will often be unable to\nconvert interfaces perfectly, so there must be a way to analyze the loss from\ninterface adapter chains in order to improve the quality of interface\nadaptation. This paper describes a probabilistic approach to analyzing loss in\ninterface adapter chains, which not only models whether a method can be adapted\nbut also how well methods can be adapted. We also show that probabilistic\noptimal adapter chaining is an NP-complete problem, so we describe a greedy\nalgorithm which can construct an optimal interface adapter chain with\nexponential time in the worst case.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.5391%2C1104.4405%2C1104.3892%2C1104.3521%2C1104.3764%2C1104.0846%2C1104.0698%2C1104.4879%2C1104.0912%2C1104.2066%2C1104.4488%2C1104.4546%2C1104.3738%2C1104.0527%2C1104.1231%2C1104.2940%2C1104.3836%2C1104.4788%2C1104.2114%2C1104.3737%2C1104.0250%2C1104.3150%2C1104.3360%2C1104.0231%2C1104.4219%2C1104.4072%2C1104.0774%2C1104.1743%2C1104.2545%2C1104.1280%2C1104.2434%2C1104.4199%2C1104.3591%2C1104.0365%2C1104.4955%2C1104.1006%2C1104.4034%2C1104.5024%2C1104.0397%2C1104.0551%2C1104.0528%2C1104.1682%2C1104.4005%2C1104.1534%2C1104.5584%2C1104.5231%2C1104.2085%2C1104.1453%2C1104.3327%2C1104.0257%2C1104.2605%2C1104.3745%2C1104.4888%2C1104.4493%2C1104.0778%2C1104.4700%2C1104.2895%2C1104.4235%2C1104.0206%2C1104.5679%2C1104.2922%2C1104.5124%2C1104.1687%2C1104.2989%2C1104.4132%2C1104.3483%2C1104.2861%2C1104.3332%2C1104.1045%2C1104.0934%2C1104.0951%2C1104.1251%2C1104.5513%2C1104.0022%2C1104.2920%2C1104.5551%2C1104.4645%2C1104.4239%2C1104.4957%2C1104.1048%2C1104.0785%2C1104.3228%2C1104.0667%2C1104.0042%2C1104.2544%2C1104.5386%2C1104.5151%2C1104.4202%2C1104.4152%2C1104.3469%2C1104.5249%2C1104.2943%2C1104.4616%2C1104.5140%2C1104.3454%2C1104.4487%2C1104.0693%2C1104.3280%2C1104.4249%2C1104.4434%2C1104.3556&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Interface adapters allow applications written for one interface to be reused\nwith another interface without having to rewrite application code, and chaining\ninterface adapters can significantly reduce the development effort required to\ncreate the adapters. However, interface adapters will often be unable to\nconvert interfaces perfectly, so there must be a way to analyze the loss from\ninterface adapter chains in order to improve the quality of interface\nadaptation. This paper describes a probabilistic approach to analyzing loss in\ninterface adapter chains, which not only models whether a method can be adapted\nbut also how well methods can be adapted. We also show that probabilistic\noptimal adapter chaining is an NP-complete problem, so we describe a greedy\nalgorithm which can construct an optimal interface adapter chain with\nexponential time in the worst case."}, "authors": ["Yoo Chung", "Dongman Lee"], "author_detail": {"name": "Dongman Lee"}, "author": "Dongman Lee", "arxiv_comment": "20 pages, 2 figures", "links": [{"href": "http://arxiv.org/abs/1104.3469v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1104.3469v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.2.12; F.2.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1104.3469v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1104.3469v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:1104.3469v1 [cs.SE] 18 Apr 2011\n\nProbabilistic Analysis of Loss in Interface\nAdapter Chaining\nYoo Chung\n\nDongman Lee\n\nOctober 8, 2018\nAbstract\nInterface adapters allow applications written for one interface to be\nreused with another interface without having to rewrite application code,\nand chaining interface adapters can significantly reduce the development\neffort required to create the adapters. However, interface adapters will\noften be unable to convert interfaces perfectly, so there must be a way\nto analyze the loss from interface adapter chains in order to improve\nthe quality of interface adaptation. This paper describes a probabilistic approach to analyzing loss in interface adapter chains, which not only\nmodels whether a method can be adapted but also how well methods can\nbe adapted. We also show that probabilistic optimal adapter chaining is\nan NP-complete problem, so we describe a greedy algorithm which can\nconstruct an optimal interface adapter chain with exponential time in the\nworst case.\n\n1\n\nIntroduction\n\nNetwork services are being developed all the time, along with the interfaces\nthat specify how these services should be accessed. Only a very small number\nof the interfaces to these services are standardized, and many interfaces can be\ndeveloped for different services which have very similar functionality. In order\nto access a different interface than a client was written for without rewriting the\nclient, interface adapters could be used to convert invocations in one interface to\nanother, which can also be chained to reduce the number of interface adapters\nthat must be created [6, 16, 7, 14, 11].\nHowever, it is unlikely that interface adaptation can be done perfectly, since\ninterfaces are usually developed independently of each other with no regard for\ncompatibility. Adaptation loss will usually result as certain methods cannot be\nadapted by the interface adapter, and the problem is only worse when adapters\nare chained. Even analyzing how much loss results from an interface adapter\nchain is not a trivial problem that can be modeled as a shortest path problem.\nOur previous work [11, 2] took the approach of assuming that a method in\na target interface could be implemented as long as all the prerequisite methods\n1\n\n\fin the source interface were available. However, a discrete approach such as\nthis ignores the possibility of partial adaptation of methods, where an adapted\nmethod may not be able to be invoked with all possible arguments because of\nlimitations with methods in a source interface. For a trivial example, negative numbers for a square root function cannot be handled if either the source\ninterface or target interface are unaware of imaginary numbers.\nWe describe a probabilistic approach to handling the partial adaptation of\nmethods, where the loss may occur not just due to missing functionality or methods, but also due to an interface adapter being unable to handle all arguments\ngiven for a method in a target interface. We first investigate how probabilities should be expressed, where independence assumptions are made so that we\ncan obtain a computational model that can be feasibly used in a real system.\nBased on this probabilistic model, we define how to express probabilistic loss\nin interface adaptation and how to model interface adapters, which can then\nbe used to probabilistically analyze loss in interface adapter chains. As in the\ndiscrete approach [2], probabilistic optimal adapter chaining is NP-complete, so\nwe describe a greedy algorithm which can construct an optimal adapter chain\nwith exponential run-time in the worst case.\nThis paper is structured as follows. In section 3, we describe elements from\nthe discrete approach which we use in developing the probabilistic approach. In\nsection 4, we formulate the probabilistic approach for analyzing loss in interface\nadapter chains. Section 5 shows that probabilistic optimal adapter chaining\nis NP-complete, and section 6 describes an algorithm which can construct an\noptimal adapter chain with exponential run-time in the worst case. We discuss\nrelated work in section 2, and section 7 concludes.\n\n2\n\nRelated work\n\nPonnekanti and Fox [15] suggests using interface adapter chaining for network\nservices to handle the different interfaces available for similar types of services.\nThey provide a way to query all services whose interfaces can be adapted to a\nknown interface. They also support lossy adapters, but the support is limited to\ndetecting whether a particular method and specific parameters can be handled\nat runtime. They do not provide a way to analyze the loss of an interface adapter\nchain, so they are unable to choose a chain with less loss when alternatives are\navailable.\nGschwind [7] allows components to be accessed through a foreign interface\nand implements an interface adaptation system for Enterprise JavaBeans [13].\nIt implements a centralized adapter repository that stores adapters, along with\nweights that mark the priority of an adapter. Dijkstra's algorithm [5] is used\nto construct the shortest interface adapter chain that adapts a source interface\ninto a target interface. While there is support for marking an adapter as lossy\nor not, it does not have the capability to properly analyze and compare the loss\nin interface adapter chains.\nVayssi\u00e9re [16] supports the interface adaptation of proxy objects for Jini [1].\n\n2\n\n\fThe goal is to enable clients to use services even when they have different interfaces than expected. It provides an adapter service which hooks into the\nlookup service, so that a client can use a proxy object without having to be\naware that any adaptation occurs. No consideration is spent on the possibility\nthat interface adapters may not be perfect.\nThere is also other work using chained interface adapters which focus on\nmaintaining backward compatibility as interfaces evolve [10, 8, 9]. Since these\nare applied to different versions of the same interface, they do not consider the\npossibility of adaptation loss, in contrast to other work where the focus is on\nadaptation between different interfaces with potentially irreconcilable incompatibilities.\n\n3\n\nPreliminaries\n\nIn this section, we describe the bare essentials from a discrete approach of\nanalyzing lossy interface adapter chaining [2], which are necessary for the probabilistic approach developed in section 4. In this section as well as in the rest of\nthe paper, a range convention for the index notation used to express matrixes\nand vectors will also be in effect [4].\nWe take the view that an interface is a specification of a collection of methods\n(which can also be called operations, methods, member functions, etc.) which\nspecify the concrete syntax and types for invoking actions on a service (which\ncan also be called an object, module, component, etc.) that conforms to the\ninterface.\nAn interface adapter transforms calls for one interface into calls for another.\nFor example, if one interface has a method setAudioProperties while another\ninterface has methods setVolume and setBalance, an interface adapter could\nhandle a call to setAudioProperty with the former interface using calls to setVolume and setBalance when the actual service conforms to the latter interface.\nAdapting interfaces using a chain of interface adapters means converting\ncalls to an interface to another using one interface adapter, then converting\nthem again to yet another interface with a subsequent interface adapter, and so\non until we can convert calls for a desired source interface to calls for a desired\ntarget interface.\nA method dependency matrix is used to express the methods in a source\ninterface necessary for providing methods in a target interface:\nDefinition 1. A method dependency matrix aji is a boolean matrix where:\n\u2022 a11 is true, while a1i is set to false for all i 6= 1.\n\u2022 If method j can always be implemented in the target interface, set aji to\nfalse for all i.\n\u2022 If method j can never be implemented given the source interface, set aj1\nto true, while aji is set to false for all i 6= 1.\n\n3\n\n\f\u2022 If method j depends on the availability of actual methods in the source\ninterface, then aj1 is false, while aji is true if and only if method j in the\ntarget interface can be implemented only if method i in the source interface\nis available.\nMethod dependency matrixes can be composed, which in effect models two\ninterface adapters chained together as a single equivalent adapter in terms of\nloss:\nDefinition 2. Given method dependency matrixes bkj and aji , the composition\noperator \u2297 of two method dependency matrixes is defined as:\n_\n(1)\nbkj \u2297 aji = (bkj \u2227 aji )\nj\n\nTheorem 1. The composition operator for method dependency matrixes is associative:\nclk \u2297 (bkj \u2297 aji ) = (clk \u2297 bkj ) \u2297 aji\nWe can also define an interface adapter graph, which is a directed graph\nwhere interfaces are nodes and adapters are edges. If there are interfaces I1 and\nI2 with an adapter A that adapts source interface I1 to target interface I2 , then\nI1 and I2 would be nodes in the interface adapter graph while A would be a\ndirected edge from I1 to I2 .\nDefinition 3. An interface adapter graph is a directed graph where interfaces\nare nodes and adapters are edges. The source node for an edge corresponds to\nthe source interface, while the target node for an edge corresponds to the target\ninterface.\n\n4\n\nProbabilistic analysis\n\nWhen an interface adapter translates a call to a method in the target interface\nto calls to a method in the source interface, it is possible that the translation\ncannot be done perfectly. If the source interface lacks certain capabilities, then\nthe adapter may not be able to properly process specific parameters received by\na method.\nFor example, there may be multiple video playback interfaces with adapters\nbetween them as in figure 1, where each interface is only able to handle a\nspecific set of video formats. For instance, if client code is written to access\ninterface Video2 but the actual service has interface Video1, then parameters\nto the playback method for Video2 with formats MOV and RMV cannot be handled\nproperly.1 In another situation where client code is written for Video3 but the\nactual service conforms to Video1, we would need an interface adapter chain\nfrom Video1 to Video3, and we would like to know if the chain that goes through\nVideo2 or the one that goes through Video4 is better.\n1 We\n\nignore the possibility that video conversion could be done by the adapter itself.\n\n4\n\n\fVideo2\n\nMOV OGM MKV\nMPG RMV MP4\n\nVideo1\n\nVideo3\n\nAVI OGM MKV\nMPG ASF MP4\n\nAVI OGM MKV\nMPG ASF RMV\n\nVideo4\n\nAVI OGM MKV\nMPG ASF MP4\n\nFigure 1: Adapting playback methods in video playback interfaces which support different video formats.\nWith the discrete approach, which only looks at whether methods are available or not, we must make a choice about what to do with methods that can\nbe only partially adapted. Conservatively treating such methods as being unavailable excludes the use of interface adapter chains that can do an imperfect\nbut mostly complete job of adapting such methods. On the other hand, optimistically treating such methods as being available could result in the selection\nof an interface adapter chain that is much worse than other chains in terms\nof how complete the adaptation is. In figure 1, Video3 could not be adapted\nfrom Video1 at all with the conservative treatment, while with the optimistic\ntreatment we would not be able to determine that the chain which goes through\nVideo4, which can support AVI, OGM, MKV, MPG, and ASF, is superior than the\none that goes through Video2, which can only support OGM, MKV, and MPG.\nThe probabilistic approach we introduce here takes into account that methods can be partially adapted, relaxing the binary limitation of only treating a\nmethod as available or not.\n\n4.1\n\nProbabilistically modeling interface adaptation\n\nWe develop a probabilistic approach by starting off with the most general form of\nexpressing the probabilities and adding assumptions until we have a probabilistic\nformula that is practical. Without additional assumptions, the probabilities\ncan only be expressed in a way that is useless for analyzing real systems. The\nadditional assumptions allow us to express the desired probabilities in a way\nthat they can be feasibly computed from a set of values that can be measured\n\n5\n\n\fVm,I (a)\n\nMethod m of interface I can properly handle argument a.\n\nVm,I\n\nMethod m of interface I can properly handle its argument.\n\nA\nCm\u2192m\n\u2032\n\nInterface adapter A can successfully convert an argument\nfor method m in the target interface to an argument for\nmethod m\u2032 in the source interface and convert back the\nresult.\nTable 1: Probabilistic events.\n\nin practice.2\nWe first describe the notation for expressing certain probabilistic events in\ntable 1. These events denote whether a method can handle a given argument, or\nwhether an interface adapter can convert an argument for a method in a target\ninterface to an argument for a method in the source interface and successfully\nconvert back the result. We assume that a method only accepts a single argument: this is not a problem since methods with multiple arguments can simply\nbe modeled as a method accepting a single tuple with multiple components. If a\nmethod does not need an argument, we treat it as receiving a dummy argument\nanyway.\nLet us say that we wish to adapt methods in source interface IS into method j\nin target interface IT . The most general form for expressing the probability that\na method could handle an argument is to sum the probabilities for every possible\nargument, where we must consider the probability of the method receiving a\nspecific argument and then the probability that the method can handle it:\nX\nP (Vj,IT ) =\n(2)\nP (Vj,IT (a))P (A = a)\na\n\nThe most general form for expressing the probability requires that we know\nthe probability distribution of arguments, which is not feasible except for the\nsimplest of argument domains. For example, the probability distribution for a\nsimple integer argument may require 232 or 264 probabilities to be expressed\nfor the typical computer architecture, and even measuring such a probability\ndistribution may not be feasible in the first place. It is also not feasible that\nwe already know the probabilities for how a method can handle each and every\npossible argument.\nFor this reason, we make the assumption that the probabilities do not depend on the specific arguments. Given this assumption, we can now express\nP (Vj,IT ) in terms of whether an argument can be converted and whether it can\nbe handled. More specifically, this means that for all methods in the source\ninterface that the interface adapter A requires to implement a method in the\n2 There is a more precise approach using abstract interpretation that does not rely on\nsuch assumptions, but it is much more difficult to set up and requires exponential space\ncomplexity [3].\n\n6\n\n\ftarget interface, it must be the case that the argument can be converted and\nthe method in the source interface can handle the converted argument. Using\nthe method dependency matrix aji for adapter A, P (Vj,IT ) can be expressed as:\n\uf8eb\n\uf8f6\n\\\n\u0001\nA\nP (Vj,IT ) = P \uf8ed\n(3)\nVi,IS \u2229 Cj\u2192i \uf8f8\naji\n\nThis is still too unwieldy an expression to be practical, since it is unclear how\ndependencies in the events for different methods in the source interface affect the\noverall probability. It would also be unclear how to measure the probabilities\nbeforehand without trying out every possible argument and configuration of\ninterface adapter chains, something that is clearly not feasible. Therefore we\nmake an additional assumption that the events for separate methods in the\nsource interface are independent.\nWith the additional assumption, P (Vj,IT ) can be expressed as:\nY\nA\n)\n(4)\nP (Vi,IS \u2229 Cj\u2192i\nP (Vj,IT ) =\naji\n\nHowever, equation (4) is still not appropriate for practical use. The reason\nis that it entangles the work done by the interface adapter and whether the\nmethod in the source interface can handle the converted argument. Basically,\nthe probabilities intrinsic to the interface adapter and the source interface are\nentangled. If the source interface itself is the result of adaptation through an\ninterface adapter chain, then we have the problem of a configuration-dependent\nevent being entangled with a configuration-independent event, and there is no\nsimple way to derive the required probabilities.\nThus we make one final additional assumption that the probability an interface adapter can successfully convert arguments and results is independent from\nthe probability that a method in the source interface can handle an argument.\nThis allows us to express P (Vj,IT ) as:\nY\nA\n)\n(5)\nP (Vi,IS )P (Cj\u2192i\nP (Vj,IT ) =\naji\n\nEquation (5) is finally in a form that can be used practically. The probability\nthat an interface adapter A can successfully convert an argument for method j\nin the target interface to an argument for method i in the source interface,\nA\nP (Cj\u2192i\n), is a value that is intrinsic to an interface adapter. In principle, it\ncould be measured empirically by exhaustively testing the interface adapter\nto see which arguments it can accept, although in practice more sophisticated\ntesting based on random samples would be used. It might even be possible to\nobtain the probabilities through analysis of the interface adapter code. The\nprobability that method mi in source interface IS can handle an argument,\nP (Vi,IS ), is also a value that can be obtained, either through analytical or\nempirical means similar to measuring probabilities from interface adapters if\n\n7\n\n\fIS is an interface to an actual service, or through a recursive application of\nequation (5) when IS is an adapted interface.\n\n4.2\n\nFormalizing adapter loss\n\nWe now have the basis for describing a framework similar to the one developed for the discrete chain approach. We define a method availability vector\nand a method dependency matrix, but in addition we also define a conversion\nprobability matrix.\nAs before, the method availability vector pi expresses how well a method\nis supported in an interface, and it is not intrinsic to an interface but rather\nrepresents the loss from interface adaptation. The components for a method\navailability vector in the probabilistic approach are probabilities. pi is defined\nas the probability that method i can handle an argument it receives, i.e. pi =\nP (Vi,I ).\nThe method dependency matrix is the same as defined in section 3 and is used\nin equation (5). Unlike for the discrete chain approach, however, the method\ndependency matrix does not suffice to describe the relevant information for an\nA\ninterface adapter. We also require a set of probabilities P (Cj\u2192i\n) for how well an\ninterface adapter converts an argument for a method in the target interface to\nthat for the relevant method in the source interface. The conversion probability\nA\nmatrix tji is defined in terms of these probabilities, where tji = P (Cj\u2192i\n).\nGiven method availability vector pi , method dependency matrix aji , and\nconversion probability matrix tji , we can now define the adaptation operator \u2297.\nInstead of just the method dependency matrix being applied to the method\navailability vector, the conversion probability matrix must also be applied in\nconjunction with the method dependency matrix:\nDefinition 4. Given method dependency matrix aji , conversion probability matrix tji , and method availability vector pi , the probabilistic adaptation operator\n\u2297 is defined as:\nY\ntji pi\n(6)\n(aji , tji ) \u2297 pi =\naji\n\nDefinition 5. A tuple (aji , tji ) of a method dependency matrix and a conversion\nprobability matrix is called a probabilistic adaptation factor. The probabilistic\nadaptation factor for an interface adapter A is denoted as depend (A).\nIt should be emphasized that equation (6) is only rigorously correct given\nthe following three assumptions. However, the three assumptions make it possible to feasibly compute P (Vi,I ) from values that can be feasibly measured or\nestimated a priori in a rigorously sound manner, instead of having to define\nan ad hoc computational framework where definitions are vague in their operational meaning. While it is not hard to see that the assumptions would not hold\nfor most real systems, it is an open question how closely the probabilistic approach based on these assumptions approximates actual losses due to interface\nadaptation.\n8\n\n\f\u2022 The probabilities do not depend on the specific arguments.\n\u2022 The events for separate methods in the source interface are independent.\n\u2022 The probability that an interface adapter can successfully convert arguments and results is independent from the probability that a method in\nthe source interface can handle an argument.\nIt should be noted that equation (6) is incomplete in that it is ambiguous\nwhat the result should be when no aji is true. If this is the case, it could be\nthat the method in the target interface can always be implemented regardless\nof availability of methods in the source interface, or it could be that the method\ncannot be implemented no matter what.\nThe workaround is simple: a dummy method is defined for each interface,\nwhere the method dependency matrixes follow the same rules. For the conversion probability matrix, setting tj1 to zero for all j would yield the expected results, given the usual convention that an empty product has a value of one [12].3\nWe will denote a method availability vector for interface I in which all methods\nare available and can handle all arguments by 1\u2032I , where all components have\nvalue one except for the component corresponding to the dummy method, which\nhas value zero.\n\n4.3\n\nAdapter composition\n\nWe would like to be able to derive a composite probabilistic adaptation factor\nfrom the composition of two probabilistic adaptation factors, which would be\nequivalent to describing the chaining of two interface adapters as if they were a\nsingle interface adapter.\nGiven interfaces I1 , I2 , and I3 , let the corresponding method availability\nvectors be pi , qj , and rk . In addition, let there be interface adapters A1 and A2 ,\nwhere A1 converts I1 to I2 and A2 converts I2 to I3 , with corresponding probabilistic adaptation factors (aji , tji ) and (bkj , ukj ), respectively. We would like\nto know how to derive the probabilistic adaptation factor (cki , vki ) that would\ncorrespond to an interface adapter equivalent to A1 and A2 chained together.\ncki is obviously derived in the same way as specified by the composition\noperator in section 3. As for vki , from equation (5) and our assumptions:\nrk\n\n=\n\nY\n\nukj qj\n\nbkj\n\n\uf8eb\n\n=\n\nY\n\n=\n\nYY\n\nbkj\n\n\uf8edukj\n\nY\naji\n\n\uf8f6\n\ntji pi \uf8f8\n\nukj tji pi\n\nbkj aji\n\n3 The\n\nvalues for t1i do not matter except for i = 1, so they can be arbitrarily set to zero.\n\n9\n\n\fY\n\n=\n\n(7)\n\nukj tji pi\n\nbkj \u2227aji\n\nWe want the above to be equivalent to the following:\nrk\n\n=\n\nY\n\nvki pi\n\ncki\n\n=\n\nW\n\nY\n\nvki pi\n\n(8)\n\nj (bkj \u2227aji )\n\nThe composition operator is derived by carefully considering the terms in\nequations (7) and (8), based on collecting the terms for fixed i.\nIf we collect the terms in equation (7) with fixed i, we have (9). It should be\nemphasized that (9) is not identical to (7): the former is a product over varying\nj with both i and k fixed, while the latter is a product over varying i and j with\nonly k fixed. Also note that if bkj \u2227 aji are all false for varying j, then no terms\naffect the result of (7). This would be equivalent to (9) having a value of one,\nwhich is expected from an empty product.\nY\nukj tji pi\n(9)\nbkj \u2227aji\n\nW\nOn the other hand, consider the term in equation (8) with fixed i. If j (bkj \u2227\naji ) is false, i.e. bkj \u2227 aji are all false for varying j, then the term is excluded\nfrom the product and is equivalent to multiplying by one, instead. If it is true,\non the other hand, then vki pi is the term that corresponds to the fixed i. So if\nwe set vki pi according to (10),4 then equations (8) and (7) end up having the\nexact same values.\nY\nukj tji\n(10)\nvki =\nbkj \u2227aji\n\nFrom this, we can conclude that the composition operator \u2297 for two probabilistic adaptation factors should be defined as in definition 6:\nDefinition 6. Given probabilistic adaptation factors (bkj , ukj ) and (aji , tji ), the\nprobabilistic composition operator \u2297 is defined as:\nY\nukj tji )\n(11)\n(bkj , ukj ) \u2297 (aji , tji ) = (bkj \u2297 akj ,\nbkj \u2227aji\n\nThe \u2297 operator is \"associative\" when applied to a probabilistic adaptation\nfactors and a method availability vector:5\n4 Remember\n\nthat only k is fixed in (7) and (8), but both k and i are fixed in (10).\nis technically not associative in this context since the \u2297 operator in (bkj , ukj )\u2297(aji , tji )\nis not the same as the \u2297 operator in (aji , tji ) \u2297 pi .\n5 It\n\n10\n\n\fTheorem 2. Applying the adaptation operator twice to a method availabiliy\nvector is the same as applying the composition operator and then applying the\nadaptation operator:\n(bkj , ukj ) \u2297 ((aji , tji ) \u2297 pi ) = ((bkj , ukj ) \u2297 (aji , tji )) \u2297 pi\nProof.\n(bkj , ukj ) \u2297 ((aji , tji ) \u2297 pi )\n\n= (bkj , ukj ) \u2297\n\nY\n\ntji pi\n\naji\n\nY\n\n=\n\nukj\n\ntji pi\n\naji\n\nbkj\n\n=\n\nY\n\nYY\n\nukj tji pi\n\nY\n\nukj tji pi\n\nbkj aji\n\n=\n\nbkj \u2227aji\n\n=\n\nW\n\nY\n\nj (bkj \u2227aji )\n\nY\n\n=\n\n\uf8eb\n\nbkj \u2297aji\n\n\uf8ed\n\nY\n\nY\n\nbkj \u2227aji\n\n= (bkj \u2297 aji ,\n\nukj tji pi\n\nbkj \u2227aji\n\nY\n\n\uf8f6\n\nukj tji \uf8f8 pi\nukj tji ) \u2297 pi\n\nbkj \u2227aji\n\n= ((bkj , ukj ) \u2297 (aji , tji )) \u2297 pi\n\nLikewise, probabilistic adaptation factor composition is associative:\nTheorem 3. The composition operator for probabilistic adaptation factors is\nassociative:\n(clk , vlk ) \u2297 ((bkj , ukj ) \u2297 (aji , tji )) = ((clk , vlk ) \u2297 (bkj , ukj )) \u2297 (aji , tji )\nW\nProof. Using the fact that bkj \u2297 aji = j (bkj \u2227 aji ) must be true if bkj \u2227 aji is\ntrue, we have:\n(clk , vlk ) \u2297 ((bkj , ukj ) \u2297 (aji , tji ))\nY\n= (clk , vlk ) \u2297 (bkj \u2297 akj ,\nukj tji )\nbkj \u2227aji\n\n= (clk \u2297 bkj \u2297 akj ,\n\nY\n\nvlk\n\nclk \u2227(bkj \u2297akj )\n\nY\n\n= (clk \u2297 bkj \u2297 akj ,\n\nY\n\nclk \u2227bkj \u2227aji \u2227(bkj \u2297akj )\n\n11\n\nukj tji )\n\nbkj \u2227aji\n\nvlk ukj tji )\n\n\fY\n\n= (clk \u2297 bkj \u2297 akj ,\n\nvlk ukj tji )\n\nclk \u2227bkj \u2227aji\n\nY\n\n= (clk \u2297 bkj \u2297 aji ,\n\nvlk ukj tji\n\n(clk \u2297bkj )\u2227clk \u2227bkj \u2227aji\n\n\uf8eb\n\nY\n\n= (clk \u2297 bkj \u2297 aji ,\n\n(clk \u2297bkj )\u2227aji\n\n= (clk \u2297 bkj ,\n\nY\n\n\uf8ed\n\nY\n\nclk \u2227bkj\n\n\uf8f6\n\nvlk ukj \uf8f8 tji\n\nvlk ukj ) \u2297 (aji , tji )\n\nclk \u2227bkj\n\n= ((clk , vlk ) \u2297 (bkj , ukj )) \u2297 (aji , tji )\n\nHowever, probabilistic adaptation factor composition is not commutative,\nas can be easily seen by considering the composition of probabilistic adaptation\nfactors whose components are not square matrixes.\nWe can also show a monotonicity property, which formalizes the notion that\nextending an interface adapter chain results in worse adaptation loss:\nTheorem 4. If A1 and A2 are interface adapters, where A1 converts I1 to\nI2 and A2 converts I2 to I3 , with (aji , tji ) = depend (A1 ) and (bkj , ukj ) =\ndepend (A2 ) where they follow the rules for the dummy method in sections 3,\nlet pk = (bkj , ukj ) \u2297 1\u2032I2 and p\u2032k = (bkj , ukj ) \u2297 (aji , tji ) \u2297 1\u2032I1 . Then\np\u2032k \u2264 pk\nProof. From our assumptions, we have:\np1 = p\u20321 = 0\npk =\n\nY\n\n(12)\n\nukj\n\nj6=1\u2227bkj\n\np\u2032k =\n\nY\n\ni6=1\u2227bkj \u2227aji\n\nukj tji =\n\nY Y\n\nukj tji =\n\nbkj i6=1\u2227aji\n\nY\nbkj\n\n\uf8eb\n\n\uf8edukj\n\nY\n\ni6=1\u2227aji\n\n\uf8f6\n\ntji \uf8f8\n\n(13)\n\nIf method k can never be implemented given the source interface, then bk1\nwill be true, and given that uk1 will be zero, p\u2032k will also have to be zero. Otherwise, bk1 will be false, so we can do a term by term comparison of equations (12)\nand (13), taking advantage of the fact that ukj and tji are probabilities so that\nthey are greater than or equal to zero and lesser than or equal to one:\nY\ntji \u2264 1\n0\u2264\ni6=1\u2227aji\n\n12\n\n\fVideo2\nplay:\nMOV OGM MKV\nMPG RMV MP4\n\nA2\n\nA1\nVideo1\n\nVideo3\n\nplayFile:\nAVI OGM MKV\nMPG ASF MP4\n\nplayVideo:\nAVI OGM MKV\nMPG ASF RMV\n\nA3\n\nA4\nVideo4\nselectVideo:\nAVI OGM MKV\nMPG ASF MP4\nstartPlayback:\n\nFigure 2: Adapting playback methods in video playback interfaces which support different video formats, expanded version of figure 1.\nukj\n\nY\n\ntji \u2264 ukj\n\ni6=1\u2227aji\n\n\u2234 p\u2032k \u2264 pk\n\n(14)\n\nThe definitions of the method dependency matrix and the method availability vector in section 4.1, along with the associativity rules proven in this section,\nprovide a succinct way to mathematically express and analyze the chaining of\nlossy interface adapters using a probabilistic approach.\n\n4.4\n\nAn example\n\nAs an example, we apply the probabilistic approach to analyzing lossy interface chaining to the interface adapter graph of figure 2, which is a slightly expanded version of figure 1. Instead of simply four interfaces each having a single\nplayback method, one of the interfaces, Video4, consists of two methods: the\nselectVideo method chooses a video file that should be played back, and the\nstartPlayback method actually begins video playback. As with the example\nin figure 1, each interface can handle different video formats.\nIn this hypothetical scenario, there is an application written for interface\nVideo3 which needs to use a video service that actually conforms to Video1.\nAn interface adapter chain from Video1 to Video3 would be required if the\napplication is to use the video service. Since there are two possible interface\n\n13\n\n\fadapter chains, one which goes through Video2 and another which goes through\nVideo4, we would want to use the chain that can support more video formats.\nThe interface adapter from Video1 to Video2 will be denoted A1 , the one\nfrom Video2 to Video3 will be denoted A2 , the one from Video1 to Video4 will\nbe denoted A3 , and the one from Video4 to Video3 will be denoted A4 . The\nmethod dependency matrix and conversion probability matrix for adapter Ak\nwill be denoted akji and tkji , respectively. For each interface adapter, we assume\nthat all methods in the target interface can be implemented in terms of all\nthe methods in the source interface. For simplicity, we will not define dummy\nmethods for any of the interfaces.\nSince the single method play of Video2 depends only on the single method\nplayFile of Video1 for A1 , a1ji only has a single true component. The same is\ntrue for a2ji . On the other hand, the selectVideo and startPlayback methods\nof Video4 both depend on the single method playFile of Video1 for A3 , so a3ji\nhas two rows corresponding to the methods in the target interface, each with\na single true component corresponding to the method in the source interface.\nThe playVideo method of Video3 depends on both methods of Video4, so a4ji\nhas a single row with two true components. The method dependency matrixes\nfor each interface adapter are shown below:\n\u0012 \u0013\n\u0001\n\u0001\n\u0001\nt\na4ji = t t\na3ji =\na2ji = t\na1ji = t\nt\nAs for the conversion probability matrixes, a way to estimate the necessary\nprobabilities is to compare the number of video formats each interface supports.6\nFor A1 , among the formats MOV, OGM, MKV, MPG, RMV, and MP4 that Video2 should\nbe able to support, the adapted interface can only support OGM, MKV, MPG, MP4\nsince these are supported by the source interface Video1, so the conversion\nprobability can be estimated as 64 . Assuming that startPlayback in Video4\nhas no arguments to be converted, the conversion probability matrixes can be\nset as in the following:\n\u0012\n\u0013\n\u0001\n\u0001 2\n\u0001 3\n1\n4\n4\n1\ntji = 6\ntji =\nt4ji = 56 1\ntji = 6\n1\nWe will first look at the interface adapter chain that starts from Video1,\npasses through Video2, and ends at Video3. Given a service conforming to\nVideo1 that is fully functional, i.e. supports all arguments it could receive, the\nsole component of the method availability vector corresponding to Video1 is a\nprobability of one. To see how the interface adapter chain formed from A1 and\nA2 adapts Video1 to Video3, i.e. the result of applying A1 to Video1 and then\napplying A2 , we can use the adaptation operator:\n(a2kj , t2kj ) \u2297 (a1kj , t1ji ) \u2297\n\n1\n\n\u0001\n\n=\n\n4\n9\n\n\u0001\n\n6 While this will not be accurate, it would be a relatively easy way to obtain a rough\nestimate that could be used for comparing the quality of different interface adapter chains.\n\n14\n\n\fWe can also do the same thing for the interface adapter chain that starts from\nVideo1, passes through Video4, and ends at Video3, i.e. the interface adapter\nchain formed from A3 and A4 :\n\u0001\n\u0001\n(a4kj , t4kj ) \u2297 (a3kj , t3ji ) \u2297 1 = 56\n\nThese results roughly estimate that when providing Video3 by adapting\nVideo1, the chain formed from A1 and A2 would allow the interface to handle\nabout 49 of the video files it is asked to play back, while the chain formed from\nA3 and A4 would allow the interface to handle about 56 of the video files it is\nasked to play back. This is consistent with how the former chain is worse in\nterms of only being able to handle OGM, MKV, and MPG, while the latter chain can\nhandle significantly more formats, specifically AVI, OGM, MKV, MPG, and ASF.7 In\ncontrast, the discrete approach would tell us that the two chains are exactly the\nsame.\nBy using probability estimates of how well each interface adapter can adapt\na source interface to a target interface, the probabilistic analysis scheme for\ninterface adapter chaining outlined in this paper can be used to compare the\nquality of an interface adapter chains where methods may not be adapted perfectly, in contrast to the discrete approach where methods are assumed to be\nadapted perfectly if they can be adapted at all.\n\n5\n\nProbabilistic optimal adapter chaining\n\nLike the optimal adapter chaining problem with the discrete chain approach,\nthe optimal adapter chaining problem with the probabilistic approach is NPcomplete as well. This is intuitively the case since the probabilistic approach\nshould be able to encompass the discrete approach, and we show this formally\nin this section.\nWe first formally define the optimal adapter chaining problem in the probabilistic approach, which we will call PROB-CHAIN. Let us have an interface\nadapter graph ({Ii }, {Ai }), where {Ii } is the set of interfaces and {Ai } is the\nset of interface adapters. Let f k be the probabilistic adaptation factor associated with adapter Ak . Let S \u2208 {Ii } be the source interface and T \u2208 {Ii } be\nthe target interface. Let {rm } be the relative\nP invocation probabilities for the\nmethods in the target interface such that m rm = 1. Then the problem is\nwhether there is an interface adapter chain [AP (1) , AP (2)\n(n) ] such that\nP, . . . , AP\nT\nis at least as\nthe source of AP (1) is S, the target of AP (n) is T , and m rm vm\nT\nP (n)\nP (2)\nP (1)\nlarge as some probability X, where v = f\n\u2297 ***\u2297 f\n\u2297f\n\u2297 1\u2032S .\nInformally, this is an optimization problem which tries to maximize the\nprobability that an argument can be handled by a method in a fixed target\ninterface, obtained by applying an interface adapter chain on a fully-functional\nservice which conforms to the source interface. {rm } would express how often\nmethods are invoked relative to each other.\n7 While the example here is simple enough that we can easily figure out exactly what types\nof arguments can be handled, it can be prohibitively difficult to do so in the general case [3].\n\n15\n\n\fTheorem 5. There is a reduction from the discrete approach to the probabilistic\napproach for analyzing loss in interface adapter chains.\nProof. Let there be a method availability vector pi and a method dependency\nmatrix aji as expressed in the discrete approach. We construct corresponding\nmethod availability vector p\u2032i , method dependency matrix a\u2032ji , and conversion\nprobability matrix t\u2032ji as expressed in the probabilistic approach as follows. If\npi is true, then set p\u2032i to one, else set p\u2032i to zero. a\u2032ji is just the same as aji . And\nset all t\u2032ji to one. Then we have:\naji \u2297 pi =\n\n^\n^\npi\n(aji \u2192 pi ) =\naji\n\nj\n\n(a\u2032ji , t\u2032ji ) \u2297 p\u2032i =\n\nY\n\nt\u2032ji p\u2032i =\n\na\u2032ji\n\nY\n\np\u2032i\n\naji\n\nand it is easy to see that a component of aji \u2297 pi is true if and only if the\ncorresponding component of (a\u2032ji , t\u2032ji )\u2297p\u2032i is one, and that a component of aji \u2297pi\nis false if and only if the corresponding component of (a\u2032ji , t\u2032ji ) \u2297 p\u2032i is zero.\nThis shows how an interface adapter graph for the discrete approach can be\nconverted to one for the probabilistic approach in a way that the adaptation\noperators in both approaches basically have the same behavior. Since all the\nmathematics for both approaches follow from the definition of the adaptation\noperators, we have just shown that the probabilistic approach can encompass\nthe discrete approach.\nNext, we formally describe the equivalent problem for the discrete approach,\nwhich we will call CHAIN and is NP-complete [2]. Let us have an interface\nadapter graph ({Ii }, {Ai }), where {Ii } is the set of interfaces and {Ai } is the\nset of interface adapters. Let ak be the method dependency matrix associated\nwith adapter Ak . Let S \u2208 {Ii } be the source interface and T \u2208 {Ii } be the\ntarget interface. Then the problem is whether there is an interface adapter\nchain [AP (1) , AP (2) , . . . , AP (m) ] such that the source of AP (1) is S, the target of\nAP (m) is T , and kv T k = kaP (m) \u2297 * * * \u2297 aP (2) \u2297 aP (1) \u2297 1\u2032S k is at least as large\nas some parameter N .\nTheorem 6. PROB-CHAIN is NP-complete.\nProof. Given M methods in the target interface, use the method described\nabove to convert an input for CHAIN\nto an input for PROB-CHAIN, where\nP\n1\nn\nT\nwe also set all rm to M\nwill be M\n. Then m rm vm\n, where n is the number\nof methods available from the interface adapter chain, so PROB-CHAIN with\nN\nwill solve CHAIN. Since CHAIN P\nis NP-complete and it is easy to\nX set to M\nT\nverify if an alternate chain results in smaller m rm vm\n, PROB-CHAIN must\nalso be NP-complete.\n\n16\n\n\f6\n\nA greedy algorithm\n\nAs shown in section 5, the problem of finding an optimal interface adapter chain\nmaximizing the probability of an argument being handled by a method in the\ntarget interface is an NP-complete problem. Short of developing a polynomialtime algorithm for an NP-complete problem, practical systems will have to use\na heuristic algorithm or an exponential-time algorithm with reasonable performance in practice.\nAlgorithm 1 is a greedy algorithm that finds an optimal interface adapter\nchain between a given source interface and a target interface. Given an interface\nadapter graph G, it works by looking at every possible acyclic adapter chain with\nan arbitrary source that results in the target interface t in order of increasing\nloss, taking advantage of equation (14), until we find a chain that starts with\nthe desired source interface s.\nIn this context, loss means the probability that a method in the target interface cannot handle an argument given a fully functional service with the source\ninterface, which is computed in algorithm 2, so the algorithm is guaranteed to\nfind the optimal interface adapter chain. In the worst case, however, the algorithm takes exponential time since there can be an exponential number of\nacyclic chains in an interface adapter graph.\nAlgorithm 1 A probabilistic greedy algorithm for interface adapter chaining.\nprocedure Prob-Greedy-Chain(G = (V, E), s, t, {rm })\nC \u2190 {[]}\n\u22b2 chains to extend\nM =\u2205\n\u22b2 discarded chains\nD \u2190 {[] 7\u2192 Idim(1\u2032t ) }\n\u22b2 method dependency matrixes\nwhile C 6= \u2205 do\nc \u2190 element of C minimizing Prob-Loss(c, D, {rm })\nif c 6= [] \u2227 source(c[1]) = s then\nreturn c\nelse if no acyclic chain not in C \u222a M extends c then\nC \u2190 C \u2212 {c}\nM \u2190 M \u222a {c}\nelse\nif c = [] then\nB \u2190 {[e] | e \u2208 E, target (e) = t}\nelse\nB \u2190 {e : c | e \u2208 E, target (e) = source(c[1])}\nend if\nremove cyclic chains from B\nC \u2190C \u222aB\nD \u2190 D \u222a {e : c 7\u2192 D[c] \u2297 depend (e) | e : c \u2208 B}\nend if\nend while\nend procedure\n\n17\n\n\fAlgorithm 2 Computing the probabilistic loss of an interface adapter chain.\nfunction Prob-Loss(c, D, {rm })\ns \u2190 source(c[1])\n\u2032\nv \u2190 D[c] \u2297 1P\ns\nreturn 1 \u2212 m rm vm\nend function\nAlgorithm 1 can be easily extended to support behavior similar to service\ndiscovery by checking whether the current source is among a potential set of\nsource interfaces instead of just checking against one, as is done with a similar\nalgorithm based on the discrete approach [2].\n\n7\n\nConclusions\n\nInterface adapters can allow code written to use one interface to use another interface, and chaining them together can substantially reduce the effort required\nto create interface adapters. Since interface adapters will often be unable to\nconvert interfaces perfectly, loss can be incurred during interface adaptation,\nand we need a rigorous mathematical framework for analyzing such loss. Instead of just analyzing whether or not a method in a target interface can be\nprovided, we have developed a probabilistic framework where partial adaptation\nof methods can also be handled.\nWe developed the probabilistic framework by first constructing a probabilistic model for interface adaptation. Based on this, we defined mathematical\nobjects and operations which probabilistically express loss in adapted interfaces and interface adapters, which were then used to prove that probabilistic\noptimal adapter chaining is NP-complete and to construct a greedy algorithm\nwhich can construct an optimal adapter chain with exponential time in the worst\ncase. These provide a more fine-grained approach to analyzing loss in interface\nadapter chains compared to a discrete approach.\nFuture avenues of research include alternate probabilistic approaches which\nrequire weaker and more realistic assumptions that can still be feasibly used\nin real interface adaptation systems. Another avenue of research is to find\ngood ways to derive the necessary probabilities from the interface adapters, either through empirical means where interface adapters are invoked on many\narguments to measure the probabilities or through analytical means which can\napproximate the probabilities based on program structure. Finally, there remains the design and implementation of an actual interface adaptation system\nwhich takes advantage of the probabilistic approach to analyzing loss in interface\nadapter chaining.\n\n18\n\n\fReferences\n[1] Ken Arnold, editor. The Jini Specifications. Addison-Wesley, 2nd edition,\nDecember 2000.\n[2] Yoo Chung and Dongman Lee. Mathematical basis for the chaining of lossy\ninterface adapters. IET Software, 4(1):43\u201354, February 2010.\n[3] Yoo Chul Chung. Formal Analysis Framework for Lossy Interface Adapter\nChaining. PhD thesis, KAIST, February 2010. Chapter 5.\n[4] M. Crampin and F. A. E. Pirani. Applicable Differential Geometry, chapter 0, pages 5\u20137. Number 59 in London Mathematical Society Lecture Note\nSeries. Cambridge University Press, March 1987.\n[5] E. W. Dijkstra. A note on two problems in connexion with graphs. Numerische Mathematik, 1:269\u2013271, June 1959.\n[6] Erich Gamma, Richard Helm, Ralph Johnson, and John M. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. AddisonWesley, November 1994.\n[7] Thomas Gschwind. Type based adaptation: An adaptation approach for\ndynamic distributed systems. In Proceedings of the Third International\nWorkshop on Software Engineering and Middleware, volume 2596 of Lecture\nNotes in Computer Science, pages 130\u2013143, May 2002.\n[8] Sven Moritz Hallberg. Eternal compatibility in theory. The Monad.Reader,\n2, May 2005. No longer online, available from the Internet Archive\nWayback Machine.\n[9] Piotr Kaminski, Marin Litoiu, and Hausi M\u00fcller. A design technique for\nevolving web services. In Proceedings of the 2006 Conference of the Center\nfor Advanced Studies on Collaborative Research, Toronto, Ontario, Canada,\nOctober 2006. ACM Press.\n[10] Ralph Keller and Urs H\u00f6lzle. Binary component adaptation. In Proceedings\nof the 12th European Conference on Object-Oriented Programming, volume 1445 of Lecture Notes on Computer Science, pages 307\u2013329. SpringerVerlag, July 1998.\n[11] Byoungoh Kim, Kyungmin Lee, and Dongman Lee. An adapter chaining\nscheme for service continuity in ubiquitous environments with adapter evaluation. In Proceedings of the Sixth IEEE International Conference on Pervasive Computing and Communications, pages 537\u2013542. IEEE Computer\nSociety Press, March 2008.\n[12] Serge Lang. Algebra, volume 211 of Graduate texts in mathematics, page 9.\nSpringer-Verlag, revised third edition, 2002.\n\n19\n\n\f[13] Vlada Matena, Sanjeev Krishnan, Linda DeMichiel, and Beth Stearns. Applying Enterprise JavaBeans: Component-Based Development for the J2EE\nPlatform. Addison-Wesley, second edition, May 2003.\n[14] Hamid Reza Motahari Nezhad, Boualem Benatallah, Axel Martens, Francisco Curbera, and Fabio Casati. Semi-automated adaptation of service\ninteractions. In Proceedings of the 16th International Conference on World\nWide Web, pages 993\u20131002. ACM Press, May 2007.\n[15] Shankar R. Ponnekanti and Armando Fox. Application-service interoperation without standardized service interfaces. In Proceedings of the First\nIEEE International Conference on Pervasive Computing and Communications. IEEE Computer Society Press, March 2003.\n[16] Julien Vayssi\u00e8re. Transparent dissemination of adapters in Jini. In Proceedings of the Third International Symposium on Distributed Objects and\nApplications, pages 95\u2013104, September 2001.\n\n20\n\n\f"}