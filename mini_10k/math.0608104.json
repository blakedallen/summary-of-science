{"id": "http://arxiv.org/abs/math/0608104v3", "guidislink": true, "updated": "2007-09-25T23:50:49Z", "updated_parsed": [2007, 9, 25, 23, 50, 49, 1, 268, 0], "published": "2006-08-03T18:50:55Z", "published_parsed": [2006, 8, 3, 18, 50, 55, 3, 215, 0], "title": "Search techniques for root-unitary polynomials", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=math%2F0608493%2Cmath%2F0608269%2Cmath%2F0608192%2Cmath%2F0608781%2Cmath%2F0608268%2Cmath%2F0608690%2Cmath%2F0608790%2Cmath%2F0608442%2Cmath%2F0608532%2Cmath%2F0608334%2Cmath%2F0608732%2Cmath%2F0608588%2Cmath%2F0608322%2Cmath%2F0608644%2Cmath%2F0608039%2Cmath%2F0608784%2Cmath%2F0608420%2Cmath%2F0608739%2Cmath%2F0608643%2Cmath%2F0608449%2Cmath%2F0608591%2Cmath%2F0608189%2Cmath%2F0608573%2Cmath%2F0608147%2Cmath%2F0608383%2Cmath%2F0608330%2Cmath%2F0608609%2Cmath%2F0608179%2Cmath%2F0608108%2Cmath%2F0608003%2Cmath%2F0608726%2Cmath%2F0608765%2Cmath%2F0608144%2Cmath%2F0608183%2Cmath%2F0608738%2Cmath%2F0608290%2Cmath%2F0608717%2Cmath%2F0608191%2Cmath%2F0608727%2Cmath%2F0608361%2Cmath%2F0608304%2Cmath%2F0608004%2Cmath%2F0608789%2Cmath%2F0608299%2Cmath%2F0608145%2Cmath%2F0608167%2Cmath%2F0608074%2Cmath%2F0608752%2Cmath%2F0608400%2Cmath%2F0608295%2Cmath%2F0608118%2Cmath%2F0608773%2Cmath%2F0608228%2Cmath%2F0608745%2Cmath%2F0608413%2Cmath%2F0608510%2Cmath%2F0608714%2Cmath%2F0608512%2Cmath%2F0608547%2Cmath%2F0608321%2Cmath%2F0608142%2Cmath%2F0608012%2Cmath%2F0608344%2Cmath%2F0608723%2Cmath%2F0608332%2Cmath%2F0608104%2Cmath%2F0608146%2Cmath%2F0608376%2Cmath%2F0608138%2Cmath%2F0608215%2Cmath%2F0608556%2Cmath%2F0608453%2Cmath%2F0608370%2Cmath%2F0608474%2Cmath%2F0608454%2Cmath%2F0608756%2Cmath%2F0608706%2Cmath%2F0608291%2Cmath%2F0608432%2Cmath%2F0608029%2Cmath%2F0608503%2Cmath%2F0608682%2Cmath%2F0608693%2Cmath%2F0608737%2Cmath%2F0608231%2Cmath%2F0608208%2Cmath%2F0608276%2Cmath%2F0608575%2Cmath%2F0608497%2Cmath%2F0608495%2Cmath%2F0608463%2Cmath%2F0608671%2Cmath%2F0608549%2Cmath%2F0608027%2Cmath%2F0608528%2Cmath%2F0608584%2Cmath%2F0608771%2Cmath%2F0608061%2Cmath%2F0608594%2Cmath%2F0608766%2Cmath%2F0608093&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Search techniques for root-unitary polynomials"}, "summary": "We give an anecdotal discussion of the problem of searching for polynomials\nwith all roots on the unit circle, whose coefficients are rational numbers\nsubject to certain congruence conditions. We illustrate with an example from a\ncalculation in p-adic cohomology made by Abbott, Kedlaya, and Roe, in which\n(using an implementation developed with Andre Wibisono) we recover the zeta\nfunction of a surface over a finite field.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=math%2F0608493%2Cmath%2F0608269%2Cmath%2F0608192%2Cmath%2F0608781%2Cmath%2F0608268%2Cmath%2F0608690%2Cmath%2F0608790%2Cmath%2F0608442%2Cmath%2F0608532%2Cmath%2F0608334%2Cmath%2F0608732%2Cmath%2F0608588%2Cmath%2F0608322%2Cmath%2F0608644%2Cmath%2F0608039%2Cmath%2F0608784%2Cmath%2F0608420%2Cmath%2F0608739%2Cmath%2F0608643%2Cmath%2F0608449%2Cmath%2F0608591%2Cmath%2F0608189%2Cmath%2F0608573%2Cmath%2F0608147%2Cmath%2F0608383%2Cmath%2F0608330%2Cmath%2F0608609%2Cmath%2F0608179%2Cmath%2F0608108%2Cmath%2F0608003%2Cmath%2F0608726%2Cmath%2F0608765%2Cmath%2F0608144%2Cmath%2F0608183%2Cmath%2F0608738%2Cmath%2F0608290%2Cmath%2F0608717%2Cmath%2F0608191%2Cmath%2F0608727%2Cmath%2F0608361%2Cmath%2F0608304%2Cmath%2F0608004%2Cmath%2F0608789%2Cmath%2F0608299%2Cmath%2F0608145%2Cmath%2F0608167%2Cmath%2F0608074%2Cmath%2F0608752%2Cmath%2F0608400%2Cmath%2F0608295%2Cmath%2F0608118%2Cmath%2F0608773%2Cmath%2F0608228%2Cmath%2F0608745%2Cmath%2F0608413%2Cmath%2F0608510%2Cmath%2F0608714%2Cmath%2F0608512%2Cmath%2F0608547%2Cmath%2F0608321%2Cmath%2F0608142%2Cmath%2F0608012%2Cmath%2F0608344%2Cmath%2F0608723%2Cmath%2F0608332%2Cmath%2F0608104%2Cmath%2F0608146%2Cmath%2F0608376%2Cmath%2F0608138%2Cmath%2F0608215%2Cmath%2F0608556%2Cmath%2F0608453%2Cmath%2F0608370%2Cmath%2F0608474%2Cmath%2F0608454%2Cmath%2F0608756%2Cmath%2F0608706%2Cmath%2F0608291%2Cmath%2F0608432%2Cmath%2F0608029%2Cmath%2F0608503%2Cmath%2F0608682%2Cmath%2F0608693%2Cmath%2F0608737%2Cmath%2F0608231%2Cmath%2F0608208%2Cmath%2F0608276%2Cmath%2F0608575%2Cmath%2F0608497%2Cmath%2F0608495%2Cmath%2F0608463%2Cmath%2F0608671%2Cmath%2F0608549%2Cmath%2F0608027%2Cmath%2F0608528%2Cmath%2F0608584%2Cmath%2F0608771%2Cmath%2F0608061%2Cmath%2F0608594%2Cmath%2F0608766%2Cmath%2F0608093&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We give an anecdotal discussion of the problem of searching for polynomials\nwith all roots on the unit circle, whose coefficients are rational numbers\nsubject to certain congruence conditions. We illustrate with an example from a\ncalculation in p-adic cohomology made by Abbott, Kedlaya, and Roe, in which\n(using an implementation developed with Andre Wibisono) we recover the zeta\nfunction of a surface over a finite field."}, "authors": ["Kiran S. Kedlaya"], "author_detail": {"name": "Kiran S. Kedlaya"}, "author": "Kiran S. Kedlaya", "arxiv_comment": "11 pages; v3: final version. Minor changes from v2 (but significant\n  from v1)", "links": [{"href": "http://arxiv.org/abs/math/0608104v3", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/math/0608104v3", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "math.NT", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "math.NT", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "26C10, 12D10", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/math/0608104v3", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/math/0608104v3", "journal_reference": null, "doi": null, "fulltext": "SEARCH TECHNIQUES FOR ROOT-UNITARY POLYNOMIALS\n\narXiv:math/0608104v3 [math.NT] 25 Sep 2007\n\nKIRAN S. KEDLAYA\nAbstract. We give an anecdotal discussion of the problem of searching for polynomials\nwith all roots on the unit circle, whose coefficients are rational numbers subject to certain\ncongruence conditions. We illustrate with an example from a calculation in p-adic cohomology made by Abbott, Kedlaya, and Roe, in which we recover the zeta function of a surface\nover a finite field.\n\nIntroduction\nIn this note, we give an anecdotal discussion of the problem of searching for polynomials\nwith roots on a prescribed circle whose coefficients are rational numbers subject to certain\ncongruence conditions. We were led to this problem by the use of p-adic cohomology to\ncompute zeta functions of varieties over finite fields; in that context, one is looking for\ncertain Weil polynomials (monic integer polynomials with complex roots all on a circle of\nradius pi/2 , for some prime number p and some nonnegative integer i), and the cohomology\ncalculation imposes congruence conditions on the coefficients. In fact, the main purpose of\nthis note is to show that in a particular example from [1], the conditions obtained from the\ncohomology calculation indeed suffice to uniquely determine the zeta function being sought.\nWe also illustrate with a larger example provided by Alan Lauder.\n1. Definitions\nA polynomial P (z) =\nwith |u| = 1 such that\n\n(1.1)\n\nPn\n\ni=0\n\nai z i \u2208 C[z] of degree n is self-inversive if there exists u \u2208 C\nai = uan\u2212i\n\n(i = 0, . . . , n);\n\nit is equivalent to require the roots of P to be invariant, as a multiset, under inversion\nthrough the unit circle. It appears that the class of self-inversive polynomials first occurs\nin a theorem of Cohn [3, 5]; it occurs naturally in the study of the locations of roots of\npolynomials and their derivatives, as in the Schur-Cohn-Marden method [13, p. 150].\nWe will call a polynomial root-unitary if its roots all lie on the unit circle; this clearly\nimplies self-inversivity. This class of polynomials has been widely studied, but does not\nseem to have a standard name: the term \"unimodular polynomial\" refers to a polynomial\nwhose coefficients lie on the unit circle, while \"unitary polynomial\" is often read as a synonym\nfor \"monic polynomial\" (particularly by speakers of French, in which a monic polynomial is\nstandardly a \"polyn\u00f4me unitaire\").\nDate: September 25, 2007.\n2000 Mathematics Subject Classification. 26C10, 12D10.\nThe author was supported by NSF grant DMS-0400747 (including the purchase of dwork), NSF CAREER\ngrant DMS-0545904, and a Sloan Research Fellowship. Andre Wibisono's research project was supported\nduring the spring 2006 semester by MIT's Undergraduate Research Opportunities Program.\n1\n\n\fLet P (z) \u2208 R[z] be a real root-unitary polynomial; then (1.1) must hold with either u = +1\nor u = \u22121, in which case we say P is reciprocal or antireciprocal, respectively. (The terms\npalindromic and antipalindromic are also sometimes used.) If deg(P ) is odd, then P must be\ndivisible by z + 1 or z \u2212 1, depending on whether P is reciprocal or antireciprocal. If deg(P )\nis even and P is antireciprocal, then P must be divisible by (z + 1)(z \u2212 1). This allows\nreduction of many questions about real root-unitary polynomials to the reciprocal case.\n2. The basic problem\nThe basic problem is to identify rational polynomials with roots on a prescribed circle,\ngiven a few initial coefficients and a congruence condition on the remaining coefficients. One\ncan renormalize in order to talk about root-unitary polynomials; as noted above, there is no\nreal harm in only looking at reciprocal root-unitary polynomials. In any case, here is the\nprecisely formulated question we will consider.\nProblem 2.1. Fix positive integers n, k, q with n \u2265 k. Also fix positive integers m0 , . . . , m2n\nsuch that mj divides mi for 0 \u2264 i \u2264 j \u2264 n, and mi = m2n\u2212i for 0 \u2264 i \u2264 2n. Given integers\na0 , . . . , a2n with ai = q n\u2212ia2n\u2212i for 0 \u2264 i \u2264 2n, and a2n 6= 0, find all polynomials P (z) with\n\u221a\nall roots on the circle |z| = q of the form\nP (z) =\n\n2n\nX\n\n(ai + ci mi )z i ,\n\ni=0\n\nwhere the ci \u2208 Z must satisfy ci = q n\u2212ic2n\u2212i for 0 \u2264 i \u2264 2n, and ci = 0 for i \u2265 2n \u2212 k.\nThe fact that Problem 2.1 is a finite problem follows easily from the estimates\n\u0012 \u0013\n2n i/2\nq |a2n |\n(i = 0, . . . , 2n);\n|ai + ci mi | \u2264\ni\nwhen n is small, these estimates carry most of the information from the condition that\n\u221a\nP (z q) must be root-unitary. However, for n large, this is quite far from true. Indeed, by\n[7, Proposition 2.2.1] (see also [16] for a generalization in the context of Mahler measures),\nthe space of monic root-unitary reciprocal polynomials of degree 2n has volume\n\u0013n+1\u2212j\n2\nn \u0012\nn\n2n Y\n2j\n2n Y n+1\u2212j 2(n +3n)/2\n2\n=\n\u2264\nn! j=1 2j \u2212 1\nn! j=1\nn!\nwhereas the\u0001 space of monic reciprocal polynomials of degree 2n whose coefficient of z i has\nnorm \u2264 2n\nfor i = 0, . . . , 2n \u2212 1 has volume\ni\n\u0012 \u0013 Y\nj\u22121\nj\u22121\nn\nn\nn\nY\nY\n2n \u2212 i Y Y\n2n\n2\n2 = 2(n +3n)/2 .\n\u2265\n2\n=\n2\n2\nj\u2212i\nj\nj=1 i=0\nj=1 i=0\nj=1\n\nFor n large, these are wildly discrepant, so one expects the restriction of root-unitarity to\ncarry much more information than the simple bound on the size of coefficients.\n2\n\n\f3. Exhaustion over a tree\nWe now describe our basic approach to Problem 2.1, starting with a change of variable\nalso used in [7]. Define a polynomial Q(z) \u2208 Z[z] of degree n by the formula\nP (z) = z n Q(z + q/z).\n\nThen for i = 0, . . . , n, the coefficients of z n\u2212i , . . . , z n of Q are obtained from a2n\u2212i , . . . , a2n by\nan invertible linear transformation over Z. We can thus reformulate Problem 2.1 as follows.\nProblem 3.1. Fix positive integers n, k, q with n \u2265 k. Also fix positive integers m0 , . . . , mn\nsuch that mj divides mi for 0 \u2264 i \u2264 j \u2264 n. Given integers b0 , . . . , bn with bn 6= 0, find all\n\u221a \u221a\npolynomials Q(z) \u2208 Z[z] with all roots real and lying in the interval [\u22122 q, 2 q], such that\nQ(z) =\n\nn\nX\n\n(bi + di mi )z i\n\ni=0\n\nfor some di \u2208 Z with di = 0 for i \u2265 n \u2212 k.\n\nOur approach to Problem 3.1 is via enumeration of a certain rooted tree.\nProposition 3.2. Fix notation as in Problem 3.1. Then there exist sets Sj \u2286 Zj for j =\n0, . . . , n \u2212 k satisfying the following conditions.\n(a) The set S0 consists of the empty 0-tuple.\n(b) For 0 < j \u2264 n \u2212 k, if (dn\u2212k\u22121, . . . , dn\u2212k\u2212j ) \u2208 Sj , then (dn\u2212k\u22121 , . . . , dn\u2212k\u2212j+1) \u2208 Sj\u22121 .\nP\nP\ni\n(c) For 0 \u2264 j \u2264 n\u2212k, if (dn\u2212k\u22121, . . . , dn\u2212k\u2212j ) \u2208 Sj , then Q0 (z) = ni=0 bi z i + n\u2212k\u22121\ni=n\u2212k\u2212j di mi z\n\u221a \u221a\n(n\u2212k\u2212j)\nhas the property that Q0\nhas all roots in [\u22122 q, 2 q].\nP\nP\ndi mi z i has all roots\n(d) Every tuple (dn\u2212k\u22121, . . . , d0 ) \u2208 Zn\u2212k such that ni=0 bi z i + n\u2212k\u22121\ni=0\n\u221a \u221a\nin [\u22122 q, 2 q] belongs to Sn\u2212k .\nProof. Create Sn\u2212k by taking all solutions of Problem 3.1, then let Sj be the set of initial\nsegments of length j occurring among elements of Sn\u2212k . Property (c) holds by Rolle's\ntheorem.\n\u0003\nWe may identify a system of sets as in Proposition 3.2 with a rooted tree, where the\nchildren of a j-tuple in Sj are its extensions to a (j + 1)-tuple in Sj+1. To solve Problem 3.1\nin practice, we perform a depth-first enumeration of such a tree, and read off the solutions of\nProblem 3.1 as the elements of Sn\u2212k . To describe such a tree and its enumeration, it suffices\nto describe how to compute the list of children of a given node. (One could also perform\na breadth-first exhaustion, but in practice this seems to be inferior because of increased\noverhead.)\nNote that if one wishes to decide as soon as possible whether the number of solutions is 0,\n1, or more than 1, it may be advantageous to visit the children of a given node in \"inside-out\norder\" rather than in ascending or descending order. For instance, if a given tuple can be\nextended by 5, 6, 7, 8, 9, we would visit these extensions in the order 7, 6, 8, 5, 9.\n4. First approach: root-finding\nWe now describe our first algorithmic approach to Problem 3.1, and its implementation\n[12] in the case where q = 1. (See Section 8 for comments on the remaining cases.) The\n3\n\n\fimplementation, based on an undergraduate research project with Andre Wibisono, uses the\ncomputer algebra system SAGE [15], and relies in particular on the following components.\n\u2022 We use the PARI C library [14] for polynomial manipulations over Q, including\nthe function polsturm to count roots of a polynomial in an interval using Sturm\nsequences. (This routine requires the polynomial to be squarefree and nonvanishing\nat the left endpoint of the interval; one must write a wrapper function to lift these\nrestrictions.)\n\u2022 We use the GNU Scientific Library (GSL) [9] for computing approximations of roots\nof polynomials over R.\n\u2022 We use Cython [6] for migrating some critical routines into compiled C code.\nAdditional components we tried out, but did not ultimately use, include Maple (commercial,\ncompiled), Numpy (interpreted Python), and Singular (compiled, but its library rootsur\nfor Sturm sequences is interpreted at runtime); one side benefit of SAGE is that it makes it\neasy to experiment with many other systems in this manner. Alan Lauder has done some\nfurther experiments using Magma.\nIn this approach, we take the tree in Proposition 3.2 to be as large as possible, by including\nall tuples not forbidden by (c). This reduces to solving the following problem.\nProblem 4.1. Let R(z) \u2208 Q[z] be a polynomial with positive leading coefficient, such that\n\u221a \u221a\nR\u2032 (z) has all roots real and in [\u22122 q, 2 q]. Find all c \u2208 Z such that R(z) + c has all roots\n\u221a \u221a\nreal and in [\u22122 q, 2 q].\n\u221a\nLet x1 \u2264 * * * \u2264 xd\u22121 be the roots of R\u2032 counted with multiplicity, and put x0 = \u22122 q\n\u221a\nand xd = 2 q. For i = 0, . . . , d, put yi = R(xi ). Then the values of c we want are those for\nwhich\nyd\u22122i + c \u2265 0 (i = 0, . . . , \u230ad/2\u230b)\n\nyd\u22121\u22122i + c \u2264 0 (i = 0, . . . , \u230a(d \u2212 1)/2\u230b).\n\n\u221a \u221a\nOne can interpret this more geometrically by drawing the graph of R over [\u22122 q, 2 q]. The\nvalues of c are the negatives of the integral y-values between the highest local minimum and\n\u221a\nthe lowest local maximum of R (inclusive), provided that we treat 2 q as a local maximum,\n\u221a\nand treat \u22122 q as a local maximum or minimum depending on whether d is even or odd.\nOur principal method for treating Problem 4.1 is to compute numerical approximations to\nthe xi and yi . We throw an exception if these approximations are not sufficiently accurate,\nunless xi = xi+1 for some i; we can both detect and resolve this case using exact arithmetic.\nAlgorithm 4.2. Consider inputs as in Problem 4.1, together with a positive integer p. Using\nGSL, compute numerical approximations x\u03031 \u2264 * * * \u2264 x\u0303d\u22121 to the roots of R\u2032 , presumed (but\nnot guaranteed) correct to within 2\u2212p . For i = 1, . . . , d \u2212 1, put ri = \u230ax\u0303i 2p\u22121 \u2212 1\u230b2\u2212p+1\n\u221a\n\u221a\nand si = ri + 2\u2212p+3; also put r0 = s0 = \u22122 q and rd = sd = 2 q. If any of the following\nconditions occur for some i \u2208 {1, . . . , d \u2212 1}:\n\u2022 si \u2265 ri+1 ;\n\u2022 (\u22121)d\u2212i R\u2032\u2032 (ri ) > 0;\n\u2022 R\u2032 (ri ) and R\u2032 (si ) have the same sign;\nthen abort or return according as Algorithm 4.4 aborts or returns. If none of the conditions\noccur, put l = \u2212\u221e and u = +\u221e. For i = d, d \u2212 1, . . . , 0 in turn:\n4\n\n\f\u2022 if ri = si , put t = R(ri );\n\u2022 if ri < si and d \u2212 i is even, let t be the value computed by applying Algorithm 4.3\nwith [r, s] = [ri , si ] and t0 = \u2212l, then replace l by max{\u2212t, l};\n\u2022 if ri < si and d \u2212 i is odd, let t be the value computed by applying Algorithm 4.3\nwith [r, s] = [ri , si ] and t0 = u after replacing R by \u2212R, then replace u by min{t, u};\n\u2022 if now l > u, return the empty set.\nReturn the range Z \u2229 [l, u]; this solves Problem 4.1 if not aborted.\nProof. The only thing that needs to be noted here is that failure to invoke Algorithm 4.4\nensures that the intervals [r1 , s1 ], . . . , [rd\u22121 , sd\u22121 ] are disjoint and contain one root of R\u2032\napiece, so the input to Algorithm 4.3 is valid.\n\u0003\nIn order to determine the roundings of the yi , we use exact arithmetic as follows.\nAlgorithm 4.3. Let R(z) \u2208 Q[z] be a polynomial such that R\u2032 has all roots real and distinct.\nLet r, s \u2208 Q be such that R\u2032\u2032 (r) \u2264 0, and the interval [r, s] contains a local maximum of R\nand no other roots of R\u2032 . Let t0 \u2208 Z \u222a {+\u221e}. Compute\nt = \u230aR(r)\u230b\n\nu = \u230aR(r) + (s \u2212 r)R\u2032 (r)\u230b.\n\nIf t \u2265 t0 , then return t0 (this can be checked before computing u). Otherwise, while t 6= u,\nrepeat the following: for v = \u2308 t+u\n\u2309, if R\u2212v has any roots in [r, s] as determined by polsturm,\n2\nthen replace t by v, otherwise replace u by v \u2212 1. Return t; then for x the unique root of R\u2032\ncontained in [r, s], either t \u2265 t0 or t = \u230aR(x)\u230b.\nProof. Since R\u2032 has all roots real and distinct, x must be an isolated root of R\u2032 . Since x is a\nlocal maximum for R, R\u2032 must undergo a sign crossing at x from positive to negative. Since\nR\u2032 has no other roots in [r, s], R\u2032 must be positive in [r, x) and negative in (x, s].\nThe roots of R\u2032\u2032 interlace those of R\u2032 by Rolle's theorem, so in (r, x] we have either zero\nor one root of R\u2032\u2032 . The root occurs if and only if there is a sign crossing; since R\u2032\u2032 (x) < 0\nand R\u2032\u2032 (r) \u2264 0, we deduce that there is no root, and R\u2032\u2032 (z) < 0 for all z \u2208 (r, x].\nThis implies that R\u2032 (r) \u2265 R\u2032 (z) for z \u2208 [r, x]; since R\u2032 (r) > 0,\nZ x\nR(x) = R(r) +\nR\u2032 (z) dz \u2264 R(r) + (x \u2212 r)R\u2032 (r) \u2264 R(r) + (s \u2212 r)R\u2032 (r).\nr\n\nThis yields the claim.\n\n\u0003\n\nNote that to a certain extent, taking p small in Algorithm 4.2 is beneficial to Algorithm 4.3,\nbecause it keeps the heights of the rationals ri , si small. However, it may happen that if p is\ntoo small, then the gap between the initial values of t and u in Algorithm 4.3 may be quite\nlarge, and a great deal of time may be wasted narrowing the gap.\nRecall that Algorithm 4.2 does not treat cases of Problem 4.1 in which R\u2032 has repeated\n\u221a\n\u221a\nroots, or R\u2032 (\u22122 q)R\u2032 (2 q) = 0; here is a simple treatment. In practice, these cases seems\nto be exceedingly rare; for instance, they do not occur at all in the example of Section 6.\nAlgorithm 4.4. Consider inputs as in Problem 4.1. Put T = gcd(R\u2032 , (z 2 \u2212 4q)R\u2032\u2032 ); if T\nis constant, then abort. Otherwise, let S1 , . . . , Sk denote the distinct irreducible factors of\ngcd(R\u2032 , (z 2 \u2212 4q)R\u2032\u2032 ). Determine whether the quotients upon dividing R by each Si are all\nequal to a single integer \u2212c. If so, use polsturm to check whether R(z) + c has all roots real\n5\n\n\f\u221a \u221a\nand in [\u22122 q, 2 q]; if so, return the singleton set {c}. In all other cases, return the empty\nset. This solves Problem 4.1 if not aborted.\n\u221a \u221a\nProof. Suppose that T is nonconstant and R(z) + c has all roots real and in [\u22122 q, 2 q].\n\u221a\nLet r be a root of T . If r = \u22122 q, then by Rolle's theorem, R(z) + c has a root less than\n\u221a\n\u221a\n\u221a\n\u221a\nor equal to \u22122 q, hence R(\u22122 q) + c = 0. Similarly, if r = 2 q, then R(2 q) + c = 0. If\n\u221a\n\u221a\n\u22122 q < r < 2 q, then r is a root of R\u2032\u2032 and so must be a multiple root of R\u2032 ; by Rolle's\ntheorem, r must be a root of R(z) + c. This proves the claim.\n\u0003\n5. Second approach: power sums\nInspection of the enumeration of the maximal tree in some examples suggests that it\nis rather bushy, in the sense of having many vertices with many children but few deep\ndescendants. This in turn suggests that a more refined tree construction might be able to\nachieve substantial runtime improvements. Our second approach, implemented in [11] using\nSAGE and components as in the previous section (but again restricted to the case q = 1),\ndoes this; it is based on estimations of power sums, as in the work of Boyd [4] and subsequent\nauthors (most notably [8]) on searching\nfor polynomials with small Mahler measure.\nP\nGiven a polynomial R(z) = ni=0 ci z i with cn 6= 0, with roots r1 , . . . , rn , the power sums\nof R are defined as\nsj = r1j + * * * + rnj\n(j = 0, 1, . . . ).\nThey are related to the coefficients of R via the Newton identities:\njcn\u2212j +\n\nj\u22121\nX\n\ncn\u2212i sj\u2212i = 0\n\n(j = 1, . . . , n).\n\ni=0\n\nIn particular, given cn , one can recover cn\u22121 , . . . , cn\u2212j from s1 , . . . , sj via an invertible linear\nPn\u2212j \u2032 i\nci z equals sj \u2212jc\u2032n\u2212j /cn .\ntransformation over Q. Moreover, the j-th power sum of R(z)+ i=0\nNote that PARI provides a routine polsym to generate the power sums of a polynomial.\nIn this tree enumeration, we will generate some nodes which do not actually belong to\nthe tree, because they do not satisfy (c); hence our first step when considering a proposed\nnode will be to check (c) using polsturm. (Profiling data in some examples suggests that\nthis step is a bottleneck in the computation; some improvement may be derived by instead\nusing Sturm-Habicht sequences, as described in [2], or perhaps even using real root isolation\ntechniques. We plan to investigate this further.) If (c) is satisfied, and the node is not at\nmaximum depth, we enumerate its children by generating and solving an instance of the\nfollowing problem.\nP\nProblem 5.1. Given a polynomial R(z) = ni=0 ci z i with cn 6= 0, and an integer 1 \u2264 j \u2264 n,\nPn\u2212j\nfind l, u \u2208 Z such that for any real numbers dn\u2212j , . . . , d0 with dn\u2212j \u2208 Z and R(z) + i=0\ndi z i\n\u221a \u221a\nhaving roots in [\u22122 q, 2 q], we have dn\u2212j \u2208 [l, u].\n\nNote that this problem is somewhat open-ended: if li , ui is a solution of Problem 5.1 for\ni = 1, . . . , k, then so is l, u for l = maxi {li }, u = mini {ui }. It thus P\nsuffices to exhibit a list\nof inequalities satisfied by the coefficients of a polynomial R(z) = ni=0 ci z i with all roots\n\u221a \u221a\nin [\u22122 q, 2 q]; equivalently, we may exhibit inequalities satisfied by the power sums si of\nR. Here are some convenient ones; adding additional inequalities should provide even better\nresults, although at some point adding a new inequality will eliminate so few cases that it\n6\n\n\fwill not be worth the time required to check it. (The linear programming approach in [8]\nmay prove helpful in finding good compact systems of inequalities.)\n(1) For i even,\nsi \u2212 4qsi\u22122 \u2264 0\n(i \u2265 2).\nPi\n\u221a\nk\n(2) Let Ti (z) =\nk=0 ti,k z be the polynomial of degree i for which Ti (2 q cos \u03b8) =\n\u221a\n2 q cos i\u03b8 (a rescaled Chebyshev polynomial of the first kind); then\ni\nX\nk=0\n\ni\u22122\nX\nk=0\n\n(3) Put\n\ns\u2032i\n\n=\n\n(4) Put s\u2032\u2032i =\n\nPi\n\ni\nk=0 k\n\nPi\n\nk=0\n\n\u221a\nti,k sk \u2264 2n q\n\n(i \u2265 0)\n\n\u221a\nti\u22122,k (sk+2 \u2212 2qsk ) \u2264 4nq q\n\n\u0001 \u221a i\u2212k\n(2 q) sk ; then\n\n(i \u2265 2).\n\ns\u2032i s\u2032i\u22122 \u2212 (s\u2032i\u22121 )2 \u2265 0\n\u221a\ns\u2032i \u2212 4 qs\u2032i\u22121 \u2264 0\n\n(i \u2265 2)\n\ns\u2032\u2032i s\u2032\u2032i\u22122 \u2212 (s\u2032\u2032i\u22121 )2 \u2265 0\n\u221a\ns\u2032\u2032i \u2212 4 qs\u2032\u2032i\u22121 \u2264 0\n\n(i \u2265 2)\n\n(i \u2265 1).\n\n\u0001 \u221a i\u2212k\ni\n(2 q) (\u22121)k sk ; then\nk\n\n(i \u2265 1).\n\n6. An example\nHere is an example of the basic problem, excerpted from [1, \u00a74.2], and some results obtained\nusing the algorithms and implementations described above.\nConsider the smooth quartic surface X in the projective space over the finite field F3\ndefined by the homogeneous polynomial\nx4 \u2212 xy 3 + xy 2 w + xyzw + xyw 2 \u2212 xzw 2 + y 4 + y 3 w \u2212 y 2 zw + z 4 + w 4 .\n\n(As described in [1], this polynomial was chosen essentially at random except for a skew\ntowards sparseness.) Since X is a K3 surface, the Hodge diamond of X is\n1\n0\n1\n\n0\n20\n\n0\n\n1\n0\n\n1\nand the Hodge polygon of primitive middle cohomology has vertices (0, 0), (1, 0), (20, 19), (21, 21).\nConsequently, the zeta function of X has the form\n!\n\u221e\nn\nX\n1\nT\n\u03b6X (T ) = exp\n#X(F3n ) =\n,\nn\n(1 \u2212 T )(1 \u2212 3T )(1 \u2212 9T )R(T )\nn=1\n\nwhere R(T ) \u2208 Z[T ] is a polynomial of degree 21 such that R(0) = 1, the complex roots of\nR lie on the circle |T | = 3\u22121 , and (by an inequality of Mazur) the Newton polygon of R lies\nabove the Hodge polygon. In particular, the polynomial S(T ) = 3R(T /3) is root-unitary\nand has integral coefficients.\n7\n\n\fDefine\nS0 (T ) = 3T 21 + 5T 20 + 6T 19 + 7T 18 + 5T 17 + 4T 16 + 2T 15 \u2212 T 14 \u2212 3T 13 \u2212 5T 12\n\n\u2212 5T 11 \u2212 5T 10 \u2212 5T 9 \u2212 3T 8 \u2212 T 7 + 2T 6 + 4T 5 + 5T 4 + 7T 3 + 6T 2 + 5T + 3;\n\none easily checks that S0 is root-unitary. By explicitly enumerating X(Fqn ) for n \u2264 5, one\nfinds\nS(T ) \u2261 S0 (T ) (mod T 6 );\nby a 3-adic cohomology computation described in [1], one finds\nS(T ) \u2261 S0 (T ) (mod 35 ).\n\nHaving performed these computations, one wants to verify whether these restrictions suffice\nto ensure S(T ) = S0 (T ). Moreover, one also wants to know to what extent they can be\nweakened while still forcing S(T ) = S0 (T ), as the enumeration and cohomology calculations\nbecome significantly more cumbersome as the strength of their results is forced to increase.\nThe result obtained here is that already the conditions that S(T ) \u2208 Z[T ], S(T ) is rootunitary, and\nS(T ) \u2261 S0 (T ) (mod 32 T 1 )\nforce S = S0 . Note that already the congruence S(T ) \u2261 S0 (T ) (mod 3) implies that S must\nbe reciprocal rather than antireciprocal, so we may as well put\nP (T ) = S(T )/(T + 1),\n\nP0 (T ) = S0 (T )/(T + 1).\n\nThen the conditions we are interested in are that P (T ) \u2208 Z[T ], P (T ) is root-unitary and\nreciprocal, and\nP (T ) \u2261 P0 (T ) (mod 3i T j )\n\n(6.1)\n\nfor various i, j. The asserted result is that these conditions for i = 2, j = 1 force P = P0 .\n(It turns out that i = 1 does not suffice even with j = 10.)\nWe checked the sufficiency of the conditions for i = 2, 3, 4, 5 and j = 1, 2, 3, 4, 5 by running the implementation [12] on one Opteron 246 CPU (64-bit, 2 GHz) of the computer\ndwork.mit.edu. The machine has 2GB of RAM.\nThe timings and sizes of the computations for various initial constraints are summarized\nin Table 1 (using root-finding, as in Section 4, with rounding precision p = 32) and Table 2\n(using power sums, as in Section 5). Each entry consists of the number of CPU seconds\nfor the calculation, rounded up to the nearest tenth of a second, followed by the number of\nleaves (terminal nodes) in the tree over which we exhausted. Note the significant savings\nachieved by the second approach. (We did some additional experiments combining the two\napproaches, but the power sum method by itself seemed to outperform hybrid methods.)\nTable 1. Timings for recovery of P given (6.1), using root-finding.\nT1\nT2\nT3\nT4\nT5\n\n32\n33\n34\n35\n564.2/1011788 2.2/3858 0.1/38 0.1/2\n267.9/501620 2.2/3784 0.1/38 0.1/2\n4.3/4714\n0.1/63\n0.1/6 0.1/1\n1.8/1838\n0.1/51\n0.1/6 0.1/1\n0.7/612\n0.1/32\n0.1/5 0.1/1\n8\n\n\fTable 2. Timings for recovery of P given (6.1), using power sums.\n1\n\nT\nT2\nT3\nT4\nT5\n\n32\n1.9/1157\n0.6/347\n0.3/117\n0.2/53\n0.1/23\n\n33\n0.1/6\n0.1/2\n0.1/1\n0.1/1\n0.1/1\n\n34\n0.1/1\n0.1/1\n0.1/1\n0.1/1\n0.1/1\n\n35\n0.1/1\n0.1/1\n0.1/1\n0.1/1\n0.1/1\n\n7. Another example\nThe previous example shows the superiority of the power sum method over the root-finding\nmethod. This suggests trying a larger example to test the limits of the power sum method;\nhere is an example provided by Alan Lauder.\nThe reciprocal polynomial\nP (T ) = 2401T 56 \u2212 343T 55 \u2212 5439T 54 \u2212 1050T 53 + 7156T 52 + 5043T 51 \u2212 5829T 50 \u2212 7990T 49\n+1437T 48 + 6348T 47 + 2115T 46 \u2212 332T 45 \u2212 1756T 44 \u2212 4639T 43 \u2212 1802T 42 + 3938T 41\n+4762T 40 + 16T 39 \u2212 3366T 38 \u2212 2658T 37 \u2212 2051T 36 + 1572T 35 + 5810T 34 + 2097T 33\n\u22125558T 32 \u2212 3955T 31 + 2598T 30 + 1931T 29 \u2212 831T 28 + 1931T 27 + * * *\n\nis root-unitary; it arises from a 7-adic cohomology calculation of the primitive middle cohomology of an elliptic surface over F7 with Hodge diamond\n1\n0\n4\n\n0\n49\n\n0\n\n4.\n0\n\n1\nAs in the previous example, we ask whether a reciprocal root-unitary polynomial P0 (T )\nsatisfying\n(7.1)\n\nP (T ) \u2261 P0 (T ) (mod 7i T j )\n\nnecessarily equals P (T ). In the following, each expression (A/B) indicates that the indicated\ncomputation required A CPU seconds and encountered B terminal nodes.\n\u2022 For i = 2, P0 = P is not forced for j = 28 (0.7/15).\n\u2022 For i = 3, P0 = P is forced for j = 25 (336.2/355435) but not for j = 24\n(711.7/755544).\n\u2022 For i = 4, P0 = P is forced for j = 16 (331304.0/196405710). We were unable to\nfind any value of j for which P0 = P is not forced. (For comparison, the complexities for j = 17, 18, 19, 20 were 61787.7/36665858, 12464.5/7334642, 2275.5/1349860,\n392.6/232783.)\n\u2022 For i = 5, P0 = P is forced for j = 1 (93.7/13513).\nOne can explain this behavior heuristically by imposing only the condition that (in the\nP\nnotation of Section 5) | ik=0 ti,k sk | \u2264 2n for i \u2265 0. This restriction constrains the coefficient\n9\n\n\fof T j to a range of size (4 * 28)/(74 * j). Once i is big enough that this range typically takes\nonly a few elements, we can expect to be able to force P0 = P .\n8. The case of nonsquare q\nAs noted earlier, our implementations so far have only covered the case q = 1. It is easy\nto reduce to this case from any case in which q is a square. For q not a square, there are\nseveral ways to proceed; we do not know which of these is best.\n\u2022 One may repeat the methods as written above, but using exact arithmetic in the\n\u221a\nquadratic field Q( q).\n\u221a\n\u2022 One may replace q by an upper approximation by a rational number s and look for\npolynomials with roots in [\u22122s, 2s], then screen out those which do not have roots\n\u221a \u221a\nin [\u22122 q, 2 q].\n\u2022 One may consider the polynomial S defined by S(z 2 ) = R(z)R(\u2212z).\n9. Further comments\nNote that SAGE runs primarily in the interpreted language Python, although many of\nits components either are compiled libraries, or have been migrated to C using Cython.\n(Indeed, the latter progress has been ongoing, and this can be detected in the runtimes\nof our algorithms under different versions of SAGE.) It is thus fair to ask whether some\nadditional optimization could be achieved by porting everything to a compiled environment.\nWe have already built in some savings by performing most polynomial manipulation in PARI\nwith limited conversions to/from SAGE, and by porting some key subroutines into Cython;\nit is not clear how much more room there is for improvement on this front.\nOur depth-first search is implemented using a queue rather than recursion; this has the\nadvantage of making it easily amenable to parallelization. Although quite sophisticated\nstrategies have been devised for scheduling in the context of tree traversal (e.g., [17]), even\nimplementing some simple scheduling mechanisms, such as work-stealing, would be helpful\nin a multiprocessor environment. Starting with version 2.0, SAGE includes a subsystem\ncalled DSAGE (Distributed SAGE ), which may facilitate this sort of simple parallelization.\nOne can use similar search techniques for polynomials with roots bounded in a convex\nsubset of the complex plane, since the Gauss-Lucas theorem asserts that this property is\nalso preserved by taking derivatives. We have not experimented with this in any detail.\nAcknowledgments\nThanks to Alan Lauder and Chris Davis for feedback on early versions of this paper, and\nto Josh Kantor, William Stein, and Carl Witty for implementation advice.\nReferences\n[1] T.G. Abbott, K.S. Kedlaya, and D. Roe, Bounding Picard numbers of surfaces using p-adic cohomology, arXiv preprint math/0601508v2 (2007), to appear in Arithmetic, Geometry and Coding Theory (AGCT 2005), Societ\u00e9 Math\u00e9matique de France. Associated Magma code available at\nhttp://math.mit.edu/~kedlaya/papers.\n[2] S. Basu, R. Pollack, and M.-F. Roy, Algorithms in real algebraic geometry, second edition, SpringerVerlag, Berlin, 2006.\n[3] F.F. Bonsall and M. Marden, Zeros of self-inversive polynomials, Proc. Amer. Math. Soc. 3 (1952),\n471\u2013475.\n10\n\n\f[4] D. Boyd, Reciprocal polynomials having small measure, Math. Comp. 35 (1980), 1361\u20131377.\n[5] A. Cohn, \u00dcber die Anzahl der Wurzeln einer Algebraischen Gleichung in einer Kreise, Math. Zeit. 14\n(1922), 110\u2013148.\n[6] Cython, version 0.9.6.6 (2007), http://www.cython.org.\n[7] S.A. DiPippo and E.W. Howe, Real polynomials with all roots on the unit circle and abelian varieties\nover finite fields, J. Number Theory 73 (1998), 426\u2013450; corrigendum, ibid. 83 (2000), 182.\n[8] V. Flammang, G. Rhin, and J.-M. Sac-\u00c9p\u00e9e, Integer transfinite diameter and polynomials with small\nMahler measure, Math. Comp. 75 (2006), 1527\u20131540.\n[9] GNU Scientific Library (GSL), version 1.9 (2007), http://www.gnu.org/software/gsl/.\n[10] K.S. Kedlaya, Search techniques for root-unitary polynomials (original version), arXiv preprint\nmath/0608104v1 (2006).\n[11] K.S. Kedlaya, SAGE, PARI code available at http://math.mit.edu/~kedlaya/papers.\n[12] K.S.\nKedlaya\nand\nA.\nWibisono,\nSAGE,\nPARI,\nGSL\ncode\navailable\nat\nhttp://math.mit.edu/~kedlaya/papers.\n[13] M. Marden, The geometry of the zeros of a polynomial in a complex variable, Math. Surveys 3, Amer.\nMath. Soc., 1949.\n[14] PARI/GP, version 2.3.2 (2007), http://pari.math.u-bordeaux.fr/.\n[15] SAGE, version 2.7.3 (2007), http://www.sagemath.org/.\n[16] C.D. Sinclair, Special functions and the range of multiplicative functions on C[x], R[x], and Z[x], arXiv\npreprint math/0509591v1 (2005).\n[17] H. Zhou, M. D. Jennings, T. M. Conte, Tree traversal scheduling: a global scheduling technique for\nVLIW/EPIC processors, The 14th Annual Workshop on Languages and Compilers for Parallel Computing (LCPC'01), Lecture Notes in Comp. Sci. 2624, Springer, 2003, 223\u2013238.\nDepartment of Mathematics, Massachusetts Institute of Technology, 77 Massachusetts\nAvenue, Cambridge, MA 02139\nE-mail address: kedlaya@mit.edu\nURL: http://math.mit.edu/~kedlaya\n\n11\n\n\f"}