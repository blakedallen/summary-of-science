{"id": "http://arxiv.org/abs/hep-ph/0311111v1", "guidislink": true, "updated": "2003-11-09T21:02:17Z", "updated_parsed": [2003, 11, 9, 21, 2, 17, 6, 313, 0], "published": "2003-11-09T21:02:17Z", "published_parsed": [2003, 11, 9, 21, 2, 17, 6, 313, 0], "title": "Parallel Computation of Feynman diagrams with DIANA", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=hep-ph%2F0311176%2Chep-ph%2F0311367%2Chep-ph%2F0311250%2Chep-ph%2F0311293%2Chep-ph%2F0311308%2Chep-ph%2F0311149%2Chep-ph%2F0311234%2Chep-ph%2F0311118%2Chep-ph%2F0311120%2Chep-ph%2F0311246%2Chep-ph%2F0311340%2Chep-ph%2F0311232%2Chep-ph%2F0311364%2Chep-ph%2F0311225%2Chep-ph%2F0311267%2Chep-ph%2F0311114%2Chep-ph%2F0311026%2Chep-ph%2F0311139%2Chep-ph%2F0311357%2Chep-ph%2F0311171%2Chep-ph%2F0311152%2Chep-ph%2F0311351%2Chep-ph%2F0311040%2Chep-ph%2F0311185%2Chep-ph%2F0311365%2Chep-ph%2F0311158%2Chep-ph%2F0311279%2Chep-ph%2F0311358%2Chep-ph%2F0311165%2Chep-ph%2F0311043%2Chep-ph%2F0311337%2Chep-ph%2F0311212%2Chep-ph%2F0311222%2Chep-ph%2F0311213%2Chep-ph%2F0311249%2Chep-ph%2F0311143%2Chep-ph%2F0311057%2Chep-ph%2F0311063%2Chep-ph%2F0311356%2Chep-ph%2F0311145%2Chep-ph%2F0311154%2Chep-ph%2F0311233%2Chep-ph%2F0311011%2Chep-ph%2F0311247%2Chep-ph%2F0311259%2Chep-ph%2F0311070%2Chep-ph%2F0311056%2Chep-ph%2F0311323%2Chep-ph%2F0311332%2Chep-ph%2F0311102%2Chep-ph%2F0311307%2Chep-ph%2F0311071%2Chep-ph%2F0311348%2Chep-ph%2F0311140%2Chep-ph%2F0311092%2Chep-ph%2F0311002%2Chep-ph%2F0311119%2Chep-ph%2F0311027%2Chep-ph%2F0311330%2Chep-ph%2F0311201%2Chep-ph%2F0311061%2Chep-ph%2F0311237%2Chep-ph%2F0311180%2Chep-ph%2F0311220%2Chep-ph%2F0311100%2Chep-ph%2F0311173%2Chep-ph%2F0311302%2Chep-ph%2F0311281%2Chep-ph%2F0311033%2Chep-ph%2F0311354%2Chep-ph%2F0311075%2Chep-ph%2F0311001%2Chep-ph%2F0311078%2Chep-ph%2F0311014%2Chep-ph%2F0311131%2Chep-ph%2F0311077%2Chep-ph%2F0311280%2Chep-ph%2F0311164%2Chep-ph%2F0311121%2Chep-ph%2F0311031%2Chep-ph%2F0311239%2Chep-ph%2F0311126%2Chep-ph%2F0311167%2Chep-ph%2F0311263%2Chep-ph%2F0311248%2Chep-ph%2F0311335%2Chep-ph%2F0311311%2Chep-ph%2F0311312%2Chep-ph%2F0311111%2Chep-ph%2F0311018%2Chep-ph%2F0311284%2Chep-ph%2F0311129%2Chep-ph%2F0311041%2Chep-ph%2F0311159%2Chep-ph%2F0311106%2Chep-ph%2F0311148%2Chep-ph%2F0311084%2Chep-ph%2F0311314%2Chep-ph%2F0311034%2Chep-ph%2F0311081%2Chep-ph%2F0311128&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Parallel Computation of Feynman diagrams with DIANA"}, "summary": "Co-operation of the Feynman DIagram ANAlyzer (DIANA) with the underlying\noperational system (UNIX) is presented. We discuss operators to run external\ncommands and a recent development of parallel processing facilities and an\nextension in the spirit of a component model.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=hep-ph%2F0311176%2Chep-ph%2F0311367%2Chep-ph%2F0311250%2Chep-ph%2F0311293%2Chep-ph%2F0311308%2Chep-ph%2F0311149%2Chep-ph%2F0311234%2Chep-ph%2F0311118%2Chep-ph%2F0311120%2Chep-ph%2F0311246%2Chep-ph%2F0311340%2Chep-ph%2F0311232%2Chep-ph%2F0311364%2Chep-ph%2F0311225%2Chep-ph%2F0311267%2Chep-ph%2F0311114%2Chep-ph%2F0311026%2Chep-ph%2F0311139%2Chep-ph%2F0311357%2Chep-ph%2F0311171%2Chep-ph%2F0311152%2Chep-ph%2F0311351%2Chep-ph%2F0311040%2Chep-ph%2F0311185%2Chep-ph%2F0311365%2Chep-ph%2F0311158%2Chep-ph%2F0311279%2Chep-ph%2F0311358%2Chep-ph%2F0311165%2Chep-ph%2F0311043%2Chep-ph%2F0311337%2Chep-ph%2F0311212%2Chep-ph%2F0311222%2Chep-ph%2F0311213%2Chep-ph%2F0311249%2Chep-ph%2F0311143%2Chep-ph%2F0311057%2Chep-ph%2F0311063%2Chep-ph%2F0311356%2Chep-ph%2F0311145%2Chep-ph%2F0311154%2Chep-ph%2F0311233%2Chep-ph%2F0311011%2Chep-ph%2F0311247%2Chep-ph%2F0311259%2Chep-ph%2F0311070%2Chep-ph%2F0311056%2Chep-ph%2F0311323%2Chep-ph%2F0311332%2Chep-ph%2F0311102%2Chep-ph%2F0311307%2Chep-ph%2F0311071%2Chep-ph%2F0311348%2Chep-ph%2F0311140%2Chep-ph%2F0311092%2Chep-ph%2F0311002%2Chep-ph%2F0311119%2Chep-ph%2F0311027%2Chep-ph%2F0311330%2Chep-ph%2F0311201%2Chep-ph%2F0311061%2Chep-ph%2F0311237%2Chep-ph%2F0311180%2Chep-ph%2F0311220%2Chep-ph%2F0311100%2Chep-ph%2F0311173%2Chep-ph%2F0311302%2Chep-ph%2F0311281%2Chep-ph%2F0311033%2Chep-ph%2F0311354%2Chep-ph%2F0311075%2Chep-ph%2F0311001%2Chep-ph%2F0311078%2Chep-ph%2F0311014%2Chep-ph%2F0311131%2Chep-ph%2F0311077%2Chep-ph%2F0311280%2Chep-ph%2F0311164%2Chep-ph%2F0311121%2Chep-ph%2F0311031%2Chep-ph%2F0311239%2Chep-ph%2F0311126%2Chep-ph%2F0311167%2Chep-ph%2F0311263%2Chep-ph%2F0311248%2Chep-ph%2F0311335%2Chep-ph%2F0311311%2Chep-ph%2F0311312%2Chep-ph%2F0311111%2Chep-ph%2F0311018%2Chep-ph%2F0311284%2Chep-ph%2F0311129%2Chep-ph%2F0311041%2Chep-ph%2F0311159%2Chep-ph%2F0311106%2Chep-ph%2F0311148%2Chep-ph%2F0311084%2Chep-ph%2F0311314%2Chep-ph%2F0311034%2Chep-ph%2F0311081%2Chep-ph%2F0311128&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Co-operation of the Feynman DIagram ANAlyzer (DIANA) with the underlying\noperational system (UNIX) is presented. We discuss operators to run external\ncommands and a recent development of parallel processing facilities and an\nextension in the spirit of a component model."}, "authors": ["M. Tentyukov", "J. Fleischer"], "author_detail": {"name": "J. Fleischer"}, "author": "J. Fleischer", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1016/j.cpc.2004.03.005", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/hep-ph/0311111v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/hep-ph/0311111v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "23 pages, Latex using psfig, epsf and alltt, 3 figures", "arxiv_primary_category": {"term": "hep-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "hep-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/hep-ph/0311111v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/hep-ph/0311111v1", "journal_reference": "Comput.Phys.Commun. 160 (2004) 167-186", "doi": "10.1016/j.cpc.2004.03.005", "fulltext": "BI-TP 2003/17\nSFB/CPP-03-27\n\nParallel Computation of Feynman diagrams with\nDIANA\n\narXiv:hep-ph/0311111v1 9 Nov 2003\n\nM. Tentyukova\n\nb \u2020 \u2021\n\nand J. Fleischerb\n\na) Institut f\u00fcr Theoretische Teilchenphysik, Universit\u00e4t Karlsruhe, Germany\nb)Fakult\u00e4t f\u00fcr Physik, Universit\u00e4t Bielefeld, Germany\n\u2020) On leave from Joint Institute for Nuclear Research, Dubna, Russia\n\u2021) Supported by DFG under FL 241/4-2\nAbstract\nCo-operation of the Feynman DIagram ANAlyzer (DIANA) with the underlying\noperational system (UNIX) is presented. We discuss operators to run external\ncommands and a recent development of parallel processing facilities and an extension\nin the spirit of a component model.\n\n1\n\nIntroduction\n\nWe have developed the program DIANA (DIagram ANAlyser), which allows to calculate\nFeynman diagrams as 'input' for further formulae manipulating languages (mainly FORM\n[1]) [2], [3] (see also http://www.physik.uni-bielefeld.de/\u223ctentukov/diana.html). Meanwhile there exists a series of applications [4], which would not have been possible without\nDIANA.\nThe problem is that in order to cope with the high precision experiments of presentday high energy accelerators, the corresponding calculations within the 'Standard Model'\n(SM) of elementary particle physics must be of similar precision. This means, e.g., for\n1-loop approximations even for 2 \u2192 2 processes the calculation of the order of several\nhundred diagrams. This number increases rapidly with the number of external legs and/or\nthe number of loops such that one is easily forced to calculate a number of diagrams of\nthe order of thousands. For this one needs an automation to generate the diagrams and\nthis is what DIANA does.\nHaving produced the FORM 'input' for each of the diagrams, in a next step the\nexecution of the FORM program has to run for each diagram separately and the analytic\nresult of all the separate calculations has to be summed up. In many cases like e.g. 1-loop\n2 \u2192 2 calculations the execution time of the FORM jobs is still relatively short and one\ncan just run the corresponding jobs one after the other (e.g. in terms of 'folders'). In\nmore complicated cases, however, not only the number of diagrams increases but also the\nanalytic calculation of the single diagrams gets more and more time consuming. Here it\npays to distribute the essentially independent calculations of the separate diagrams over\n1\n\n\fdifferent computers. In the project described here we have extended DIANA to be able\nto perform this task and we give detailed hints for potential users of how to apply it.\nThe program DIANA, written in C, contains two ingredients:\n1. Analyzer of diagrams.\n2. Interpreter of a special text manipulating (TM) language.\nThe analyzer reads QGRAF [5] output and passes the necessary information to the interpreter. For each diagram the interpreter performs the TM program, producing input\nfor further evaluation (e.g. by means of FORM) of the diagram. The TM language is a\nTeX-like language. The main goal of the language is the creation of text files.\nSimilar to the TeX language, each command has to begin with an escape (\"\\\") character. All lines without escape - characters are simply typed to the output file. Some\nof the TM commands are built-in TM operators while some are user-defined functions\n(returning a value) written in the TM language itself.\nThe main goal of parallel processing is to reduce wall-clock time1 which is the users\nwaiting time. Parallelism doesn't come for free; always it has some overhead with respect\nto serial execution, but it can significantly reduce the wall-clock time.\nNot every problem can be divided into parallel tasks. An example of a parallelizable\nproblem is the multiplication of two matrices. An example of a non-parallelizable problem\nis the calculation of the Fibonacci series (1,1,2,3,5,. . . ) by means of the formula F (k+2) =\nF (k + 1) + F (k).\nComputations in perturbative Quantum Field Theory involve the calculation of Feynman diagrams. DIANA is used to produce the input for their further analytic evaluation.\nIn fact DIANA needs a \"model file\" produced by the user and then generates the \"input\"\nin terms of formally defined vertices and propagators and of coupling parameters [3]. This\ngeneration of Feynman diagrams itself is not a good parallelizable problem. Moreover,\nthe time DIANA spends to produce such input is negligible with respect to the time used\nfor the diagram evaluation. Thus the present approach consists in generating input for\neach diagram sequentially, with the possibility to parallelize the further evaluation.\nAfter the diagrams are generated, DIANA may be used as a \"control center\" for\nfurther evaluations (in parallel) by invoking the corresponding programs and providing\nthem the generated input. To avoid a cluster/processor overloading, each time only one\njob per node/processor is actually running while all the rest is queued. Such an approach\nis known as a Batch Queueing System (BQS). There exist a lot of such systems, both\nfree and commercial [6]. Usually, these systems are aimed to deal with a big number of\ndifferent isolated tasks, while in our case we have a huge number of nearly even tasks.\nThere are two kinds of optimization of BQS available. The first is for the case when\nthe average number of jobs is much larger than the number of nodes. In this case BQS\nusually provides various complicated methods for scheduling, message pasting, job runtime quotas and resource management in order to distribute computational resources\namong various tasks of all kinds. In our case all these mechanisms are not needed.\nSecondly, if the average number of jobs is comparable with the number of nodes, which is\n1\n\nThe elapsed time between start and finish of a process.\n\n2\n\n\ftypical for parallel computation, a BQS should provide load balancing, process migration\nmechanisms and some others.\nCompared to that, DIANA has to implement parallelism in terms of job queueing, and\nthe typical situation consists of a long queue of nearly even tasks with the same priority.\nEvidently, we need not any load balancing. Indeed, the best procedure is to send a new\ntask to a node immediately when the node becomes free. Thus, the real problem in our\ncase is the problem of synchronization. Traditionally, this problem is ignored in BQS\nsince all jobs are assumed to be completely independent. The synchronization problem\narises in true parallel systems. Since we use queueing in order to implement a parallelism,\nthe problem is of immediate interest in our case.\nThe TM language contains several groups of operators permitting DIANA to make a\nfine co-operation with the underlying operational system (UNIX). The operators \\system()\nand \\asksystem() execute an external command synchronously (see sect. 2), i.e. they\nwait for the command to be completed. The operator \\pipe() (sect. 3) starts the external command opening an input-output channel for it, and can be used in order to extend\nDIANA in the spirit of a component model (sect. 3.4). The term \"component model\"\n(see, e.g., [7]) means that a software system is built from \"components\". Components\nare high level aggregations of smaller software pieces, and provide a \"black box\" building\nblock approach to software construction.\nLet us now suppose that we use a cluster with disk space shared by means of NFS2 ,\nand all results must be collected into one resulting file log.all, while every job produces\na file log.# where # is the order number of the job. Since jobs are running and completing\nindependently of each other, we can only collect all log.# into log.all after all the jobs\nare finished. This leads to producing a lot of files log.# at an intermediate step, which\ncan overload a file system.\nThe simple solution is to allow some of the newly started jobs to be synchronized\nwith all previously started jobs. Indeed, in this case after each job we can start another\n\"slave\" job, which appends the log.# file containing the result of the \"master\" job to\nthe file log.all. To obtain a correct order of the file log.all, this copying job must be\nperformed only after all earlier jobs are finished.\nAnother problem with cluster computations is that the optimal placement of the resulting file log.# is usually a /tmp directory which is local with regard to the current\nnode, on which the job \"number #\" is performed. But to do this, the \"slave\" copying job\nhas to \"stick\" to the \"master\" job, i.e. it must be performed on the same node as the\n\"master\" job.\nBoth above mentioned problems are solved by means of so-called job attributes, see\nsect. 4.2.\nYet another problem is the transaction problem, which in our case means whether\na job group should be restarted on failure, and what the failure/success conditions are.\nSometimes it is necessary to perform some complicated job with many unreliable intermediate steps (e.g., breakdown of some connection) and at the end return the exit code\ndepending on the status of the whole transaction. In such cases it is useful to have a\npossibility to restart the job many times. But for conventional jobs consisting of one\n2\n\nNetwork File System\n\n3\n\n\fexternal program the number of restarts must not be too large in order to permit the user\nto kill jobs which failed.\nConditions on which a job is assumed to have failed may be rather complicated, too.\nFor example, the above mentioned copying \"slave\" job is just a quick system command\n\"cp\". The probability of its failure is very low, less then the probability of some network\nconnection failure during the commands initiation. If started, such a job, most probably,\nwill be completed successfully independently of the DIANA client/server status. That\nis why it is reasonable to assume that the job is successful if it is started by the server.\nOn the other hand, the \"master\" job is expected to return some exit code, but not to be\nkilled by some signal. For the solution of these problems see sect. 4.2 as well.\nThe operator \\_exec() and companions can be used to define several macros and\nTM functions in order to create a BQS which meets our requirements; for a simplified\nexample see sect. 4.4. There is the possibility to build a really powerful BQS based on\nthe \\_exec() family combined with external components communicating with DIANA\nthrough the operator \\pipe(). A simplified version of this is demonstrated.\n\n2\n\nRunning external commands\n\nThe operator \\system(command) executes the external command and returns the exit\ncode. Usually, 0 means that the invoked program was executed successfully. Example:\n\\system(ls) types to the screen the content of the current directory and returns 0.\nThe operator \\asksystem(command,text) executes the external command, using the\nsecond argument as its \"standard input\". It reads the first line of the external command output and stores it. Then the external command is terminated, and the stored\nline is returned. For example, \\asksystem(cat,Hello!) returns the text \"Hello!\", but\n\\asksystem(cat,One!\\eol()Two!) returns the text \"One!\" (\\eol() is the DIANA command ending the line).\nAnother example:\n\\offleadingspaces\n* Host: \\asksystem(hostname,); \\asksystem(date,)\nin the TM program has led to the following line in the produced output:\n* Host: phya24; Fri May\n\n3\n\n30 22:51:38 CET 2003\n\nDialog with an external program\n\n3.1\n\nStarting a pipe\n\nThe operator \\asksystem() is used to \"ask\" a single question from the command, as\ndescribed above. In order to organize a dialog with an external program, the operator\n\\pipe(command) can be used. It starts the command, swallowing its standard input and\noutput. It returns an integer number, a PID3 of a newly started process, or an empty\n3\n\nProcess IDentifier\n\n4\n\n\fstring, if it fails. Further, the returned PID can be used in order to send some text to the\nprogram, or to read program output.\nAfter the operator \\pipe() returns the control to the TM program, the program\ninitiated by command continues to run. Its standard input and output references are stored\nby DIANA. Both input and output are not connected with any terminal device. The\nrunning external program is visible from the TM program as a duplex \"pipe\" identified\nby the PID of the external program.\nThe operator \\closepipe(rpipe) (here rpipe is the PID of the external program returned by \\pipe()) terminates the external program. It closes the programs' IO channels,\nsends to the program a KILL signal and waits for the command to be finished.\n\n3.2\n\nReading and writting with the pipe\n\nThere are two operators to write to the pipe. One is \\topipe(rpipe,text), and another is\n\\linetopipe(rpipe,text). The latter appends a new line symbol to the text placed into\nthe pipe while the former sends text to the pipe as it is. The necessity of two operators\ncomes from the fact that most of interactive programs have line-oriented input/output.\nThe program reads from the terminal a whole line and will not continue until the line\nis completed. On the other hand, sometimes it is necessary to use character-oriented\ninput/output.\nThe\ncorresponding\nreading\noperators\nare\n\\frompipe(rpipe)\nand\n\\linefrompipe(rpipe). The operator \\linefrompipe() reads from the pipe and returns a whole line. The operator is fast, but it is aimed to read only lines. In contrast,\nthe operator \\frompipe() can be used in order to read parts of lines. It stops reading\nif the line is completed, at an end-of-file condition or if there are no more data available in the pipe. The operator \\frompipe() reads from the pipe character-by-character,\ntherefore it is much slower then the operator \\linefrompipe()4 .\nIt is not allowed to mix \\frompipe() and \\linefrompipe(). The result may be\nunpredictable and probably not what one expects.\nThese operators may be used to deal with the DIANA standard input/output. If the\nfirst argument, rpipe, is \u2264 0, the operators \\topipe(rpipe,text) and\n\\linetopipe(rpipe,text) will output their second argument to the terminal. The same\nwith \\frompipe() and \\linefrompipe(): if their arguments are \u2264 0, these operators\nread from the keyboard.\n\n3.3\n\nRelated operators\n\nThe operators \\frompipe() and \\linefrompipe() block the TM program until some\ndata will be available from the pipe. Sometimes this is not acceptable. In order to solve\nthis problem, the user can apply the operator \\ispipeready(rpipe) (is-pipe-ready).\nThe operator returns ok if there are data available for the \\frompipe() operator. If\n4\n\nThe operator \\linefrompipe() makes bufferred reading. It reads some block from the pipe, and\nthen returns the part of the block corresponding the first whole line. After the operator is performed,\nsome piece of the text corresponding to the beginning of the next line is also transferred from the pipe\ninto an internal buffer.\n\n5\n\n\f\\ispipeready() returns an empty string, the operator \\frompipe() invoked afterwards\nwill block the TM program and wait for some data to be available.\nThe operator \\ispipeready() may be used only in combination with\n\\frompipe(). The operator \\linefrompipe() may still return some text immediately\neven if the operator \\ispipeready() has returned an empty string.\nThe operator \\checkpipe(rpipe,signum) sends the signal \"signum\" (an integer number) to the external program initiated by \\pipe(). If the signal is delivered successfully,\nthe operator returns ok. If the signal cannot be delivered, e.g. if the external program\nwas terminated, then the operator returns an empty string. If the first argument, rpipe,\nis \u2264 0, the operator does nothing and returns ok since DIANA assumes that the user\nchecks the standard input/output. If the second argument, signum, is < 1, it is assumed\nto be 0. It must be an integer number, symbolic names are not accepted. The primary\npurpose of the operator is to send the signal 0 to the pipe: this signal will not affect the\nprogram but all checking will be performed.\n\n3.4\n\nExtension of DIANA by means of external components\n\nThe operator \\pipe() can be used to add some functionality to DIANA in the spirit of\na component model (see Introduction).\nLet us suppose that we need to deal with high precision arithmetic. Under UNIX,\nthere exists the command \"dc\" \u2013 a standard desk calculator which supports unlimited\nprecision arithmetic. It reads arguments from the standard input as so-called \"reversepolish notation\"5 and types the answer to the standard output.\nThe following function \\fdiv(a,b) returns the quotient a/b with 10 fraction digits:\n\\function fdiv a,b;\\modesave()\\\\if not exist\"_dc\"then\n\\if\"\\export(_dc,\\pipe(dc))\"eq\"\"then\n\\killexp(_dc)\n\\moderestore()\\return()\n\\endif\n\\linetopipe(\\import(_dc),\\(10 k))\n\\endif\n\\let(a,\\tr(-,_,\\get(a)))\n\\let(b,\\tr(-,_,\\get(b)))\n\\linetopipe(\\import(_dc),\\(c )\\get(a)\\( )\\get(b)\\( / p))\n\\moderestore()\\return(\\linefrompipe(\\import(_dc)))\n\\end\nThis is a very simple demo version, it is non-optimal and does not contain exception\nhandling.\n5\n\nReverse Polish Notation is an arithmetic formula notation, introduced in 1920 by the Polish mathematician Jan Lukasiewicz. In this notation, the operands precede the operators, thus dispensing the need\nof parentheses. For example, the expression 3 * ( 4 + 7) would be written as 3 4 7 + *.\n\n6\n\n\fFirst, if dc is not running, the function starts dc, swallowing its input-output channels\n(it assumes that the external program dc is started if the global variable _dc is defined).\nThen it sets the precision 10, sending the line \"10 k\" to dc.\nIt replaces possible signs \"-\" in both a and b by the symbol \"_\": the input dc language\nrequires negative numbers to be preceded by \"_\"; the sign \"-\" cannot be used for this,\nsince it is a binary operator for subtraction.\nThen the function sends the line \"c |a| |b| / p\" to the running dc command. The\ncalculator clears previous results (command c), evaluates the quotient and puts the result\nto the standard output (command p).\nIn this example it is possible to use the operator\n\\asksystem(dc, 10 k |a| |b| / p)\ninstead:\n\\function fdiv a,b;\\modesave()\\\\let(a,\\tr(-,_,\\get(a)))\n\\let(b,\\tr(-,_,\\get(b)))\n\\moderestore()\\return(\n\\asksystem(dc, \\(10 k )\\get(a)\\( )\\get(b)\\( / p))\n)\n\\end\nFor each call of \\fdiv(a,b) it would start dc, evaluate and return the result. The\ntime consumed by such a function will be about 100 times larger than the variant with\n\\pipe(), but it is possible in principle.\nAnother example illustrates the \"real\" dialog with the component used to organize\nsome simple GUI6 . Let's suppose some Tcl/Tk7 script is placed into the executable file\nguiDemo (see appendix A; this example is available at\nhttp://www.physik.uni-bielefeld.de/\u223ccomponent model.tar.gz).\na)\n\nc)\n\nb)\n\nFigure 1: Simple demo of GUI for DIANA. During initialization, a TM program starts\nthe Tcl/Tk script \"guiDemo\". The dialog appears asking the user to start executions, or\nto quit the program (a). The user starts execution (b), and after a short period stops\nexecution. The dialog is waiting for the further user reaction (c).\nThis small \"widget\" with two buttons, \"Run/Stop\" and \"Quit\" represents a simple\ndialog (see Fig. 1). Every time the user clicks the \"Run/Stop\" checkbutton, the script\n6\n7\n\nGraphical User Interface\nA popular scripting language intended primarily for creating GUI, see http://www.tcl.tk/scripting\n\n7\n\n\ftypes to the standard output 0 or 1 (supposed to be swallowed by DIANA), depending on\nthe state of the button, and reads the window header from the standard input. If the user\nclicks the \"Quit\" button, then the script outputs the line Quit to the standard output,\nand exits.\nThe script is started by means of the operator \\pipe(./guiDemo) during initialization\nof a TM program:\n\\Begin(initialization)\n. . .\n\\export(guiDemo,\\pipe(./guiDemo))\n\\topipe(\\import(guiDemo),Start/Quit?\\eol())\n\\if\"\\frompipe(\\import(guiDemo))\"ne\"1\"then\n\\exit(-1)\n\\endif\n\\topipe(\\import(guiDemo),Run\\( )0...\\eol())\n\\End(initialization)\nAt this point the window appears with the title \"Start/Quit?\" (Fig. 1 a)) , and the\nexecution of the TM program will be suspended since it is blocked while waiting for the\ndata from the pipe.\nIf the user clicks on the \"Quit\" button, the TM program will be finished. If the user\nswitches on the \"Run/Stop\" button, the TM program starts to run (Fig. 1 b)).\nEach time the user clicks one of the buttons (or closes the window), the script emits\nsome text, which becomes available for \\frompipe().\nIn the beginning of the \"regular\" section there is the following TM code:\n\\section(regular)\n\\if\"\\ispipeready(\\import(guiDemo))\"eq\"ok\"then\n\\beginlabels\n\\label(_start)\n\\goto(_\\frompipe(\\import(guiDemo)))\n\\label(_0)\n\\topipe(\\import(guiDemo),Stop\\( )\\currentdiagramnumber()\\eol())\n\\goto(_start)\n\\label(_)\n\\label(_Quit)\n\\exit(-1)\n\\label(_1)\n\\topipe(\\import(guiDemo),Run\\( )\\currentdiagramnumber()...\\eol())\n\\endlabels\n\\endif\nIf the user switches off the \"Run/Stop\" button, this code suspends the execution of the\nTM program (Fig. 1 c)). The number of the current diagram will be typed into the title.\nThe user can continue (checking the \"Run/Stop\" button), or interrupt the TM program by means of the \"Quit\" button.\n8\n\n\f4\n4.1\n\nRunning external commands asynchronously\nParallelization, local and remote jobs and synchronization\n\nThe operator \\system() executes commands synchronously, i.e. it waits for them to\nbe completed and returns an exit code. In contrast, the operator \\_exec() executes\ncommands in the background8 . Similar to the operator \\pipe(), it does not wait for the\ncommand to be completed. It returns an empty string on success, or some diagnostics on\nfailure. This operator may be used to parallelyze the evaluation of a process by running\nmore than one job simultaneously.\nAll jobs started by the operator \\_exec() are running independently of the TM program invoking them. To synchronize the TM program with all these jobs, there is an operator \\_waitall(). It suspends execution of the TM program until timeout is expired,\nor until all jobs started by the \\_exec() operator are completed (for further options see\nSect. 4.3). It returns the number of jobs which are not yet finished, or an empty string,\nif there are no jobs anymore. The single argument of the operator \\_waitall() is a\ntimeout in milliseconds. E.g., \\_waitall(1000) will return in one second the number of\nremaining jobs. If the user wants to know how many jobs are not yet finished, he may\nuse the operator \\_waitall(0).\nTo avoid overloading of a processor, by default at each time only one job is actually\nrunning while all the rest is waiting in the queue. The operator \\_exec() just queues\njobs.\nOn SMP9 computers, the optimal number of simultaneously running jobs is the number\nof processors. This number can be changed by means of the option -smp. Thus, -smp 8\ntells DIANA to run on the computer 8 jobs simultaneously while all the rest is queued.\nIn case of a cluster of computers with a current directory shared by means of NFS\ne.g., the operator \\_exec() can use DIANA servers running on other computers. To run\nDIANA as a server, the user may use one of the following two options: the option -s tells\nDIANA to run a server listening to some port, and the option -d forces DIANA to fork\nout a \"daemon\" running in the background and listening to the port instead of DIANA.\nThus, each computer on which the user has executed the command (possibly automized,\nsee macro STARTSERVERS below)\ndiana -d 1 -q\nbecomes available to perform the commands queued by the operator \\_exec() (we assume\nthat the current directory is shared by NFS among all computers in the cluster). Here\n-d 1 tells DIANA to run a daemon accepting only one connection, and the option -q\nterminates the father DIANA process. For SMP computers the optimal argument for the\n-d (or -s) option is the number of processors.\nRunning jobs are controlled by means of \"handlers\". These can be understood as\ncommunication channels between running jobs and DIANA. Their number is the highest\n8\nOn UNIX, the background jobs are programs which are executing in such a way that they return\nthe shell prompt while they continue to operate. Here we use the term \"background\" in a more general\nsense.\n9\nSymmetric MultiProcessing\n\n9\n\n\fpossible number of simultaneously running jobs. By default, the operator \\_exec() will\ngive priority to local handlers, i.e. if the two possibilities occur simultaneously to run a\njob locally or on a remote server, the job will be started on the local computer. When\nDIANA starts a new job, it tries to use one of the free handlers with minimal nice. The\nnice is an integer number which is set for each handler. By default, the local handler has\nnice 0, while the remote handler has nice 1.\nThe nice of local handlers can be set by an optional parameter for the option -smp,\nseparated by a comma from the mandatory parameter. Thus, -smp 8 tells DIANA to run\non the computer 8 jobs simultaneously with nice 0 while -smp 8,2 tells DIANA to run\nthese 8 jobs with nice 2.\nThe same with the remote server: -d 2 (or -s 2) tells DIANA to run a daemon\n(server) accepting two connections with nice 1, and -d 2,0 (or -s 2,0) tells DIANA to\nrun a daemon (server) accepting two connections with nice 0.\n\n4.2\n\nJob attributes and exact syntax of operators\n\nTwo operators \\_exec() and _waitall() permit the user to organize a simple parallel\nsession for evaluations on SMP computers and/or clusters of independent computers with\nshared disk space. But very often this is not enough (see Introduction). Therefore, each\njob started by the operator \\_exec() must have further attributes (for a complete list\nsee the end of the present section). The first one is the \"sync\" attribute; if it is set,\nthe job will be started to run only after all previously started jobs are completed. The\nsecond attribute is the \"sticky\" attribute. This attribute requires a parameter, which\ngives reference to the \"master\" job to which the \"slave\" (getting this parameter) has to\nstick. If this attribute is set, the \"slave\" will be performed on the same node as the\n\"master\" job was running.\nIf the \"master\" job fails before the \"sticky\" \"slave\" job was started, the latter will fail\ntoo if a third attribute is set; otherwise it will be performed independently of the result\nof the \"master\" job. Let's call this attribute \"stickyfail\".\nThere are some other attributes, which will be explained further down. The total\nnumber of attributes is 32, but at present many of them are merely reserved for future\ndevelopments.\nThe operator \\_execattr(attr,param) is used to change default job attributes. attr\nis a string of length 32 in general. The position of each character corresponds to one of\nthe attributes. The first character corresponds to the \"sync\" attribute, the second one\nto the \"sticky\" attribute, etc. If the corresponding character is 0, then the attribute is\ncleared, if 1, the attribute is set; any other character means that the attribute will not be\nchanged. If the string attr is longer than 32, all extra characters will be ignored. If it is\nshorter, all remaining attributes will not be changed. Examples:\n\\_execattr(00000000000000000000000000000000,)\nclears all attributes.\n\\_execattr(1,)\n\n10\n\n\fsets the \"sync\" attribute.\nThe second argument, param, is used to attach a parameter to attributes which require\nit. Parameters are attached consecutively only to those attributes which require them and\nonly to attributes which are set. If more than one parameter is specified, they have to\nbe separated by the end-of-file symbol (EOF), which can be obtained by the operator\n\\eof(). If less parameters than set attributes are specified, they will be cycled over all\nset attributes requiring a parameter.\nEach job started by \\_exec() has a unique name, provided by the user (see below) or\ndefined automatically. The parameter for sticky attributes is the name of the \"master\"\njob. It is not allowed to stick to jobs which are not yet queued. The name of the last\nqueued job can be obtained by the operator \\lastjobname(). So, the operator\n\\_execattr(!10,\\lastjobname())\ndoes not change the \"sync\" attribute, raises the \"sticky\" attribute to stick the new job\nto the job queued just before, and clears the \"stickyfail\" attribute.\nAnother example:\n\\_execattr(111,\\lastjobname())\nThe newly created job will be executed firstly after the \"master\" job and all previously\nqueued jobs are finished, secondly, on the same node10 on which the \"master\" job was\nperformed, and thirdly only if the \"master\" job was successful.\nIf the parameter for the \"sticky\" attribute is an empty string, the last job name will\nbe used and the above example is equivalent to\n\\_execattr(111,).\nThe operator \\_exec() queues jobs defined by commands with arbitrary number of\ncommand line arguments. The command and the arguments must be pushed into a stack\nin natural order by means of the operator \\push(). E.g., in order to execute a command\n\"ls -l\", the user has to prepare the stack by means of the following set of operators:\n\\push(\\eof())\n\\push(ls)\n\\push(-l)\nand then invokes the operator \\_exec(). The command line arguments appear in the\nstack in reverse order, reading from top to bottom, i.e. in the stack the EOF is situated\non the bottom. The \\_exec() operator reverses the command line arguments from the\nstack such that they appear in natural order again. The exact syntax of the \\_exec()\noperator is as follows:\n\\_exec(name, attr, param).\n10\n\nDIANA assumes the \"node\" to be the IP address of a server, so the conception of \"nodes\" is actually\nsupported only for clusters. For SMP, the whole computer is assumed to be a single node.\n\n11\n\n\fHere name is the unique job name. If it is left empty, which is recommended in general,\nit will be assigned automatically.\nThe second and third argument have the same meaning as described above in connection with the \\_execattr() operator. Here they are considered as local arguments and\nthe default ones are not overwritten by the \\_exec().\nBesides these most important attributes we describe two more useful ones. They are\n\"successcondition\" and \"restart\".\nIf the job is sent to a server, DIANA waits for an answer from it. The server reports\nsuccess/failure of starting the job, and after the job is completed, the server reports the\nstatus of the job returned by the system.\nBy default, the job is assumed to be successful if the server reports the status. However,\nsometimes it is useful to investigate the status returned by the system, or assume that\nthe job is successful if it is started by the server (see the discussion in the Introduction).\nThe \"successcondition\" attribute (the fourth one) can accept a parameter which can\ntake the following values:\n\u2022 -2 \u2013 the job is successful if it is started by the server;\n\u2022 -1 \u2013 the same like without the attribute. The job is successful if the server reports\nthe status returned by the system.\n\u2022 from 0 to 255 \u2013 the job is successful if the external program initiated by the job has\nbeen completed and returned the exit code less or equal to the specified number.\nAnother problem with success/failure conditions is the question how many times the\njob should be restarted when it fails. By default, the job is not restarted at all on failure.\nTo change this behaviour, a fifth attribute can be set. We call it the \"restart\" attribute.\nThe corresponding parameter is the number of restarts, which must be an unsigned integer\nfrom 0 to 255.\nHere is the synopsis of all attributes actually used by DIANA for the time being:\nNo\nAttribute\n1\nsync\n2\nsticky\n3\nstickyfail\n4 successcondition\n5\nrestart\n\n4.3\n\nParameter\n\u2013\njob name (text)\n\u2013\n-2. . . 255\n0. . . 255\n\nRelated operators\n\nAs described in Sect. 4.1, the operator \\_waitall() returns control if there are no more\nrunning jobs or if the timeout is expired. As third possibility the operator will return\ncontrol if some data are available on a definite pipe. This pipe must be set by means of\nthe operator \\setpipeforwait(rpipe), where rpipe is the PID returned by the operator\n\\pipe(), or 0. In the latter case the operator \\_waitall() will return control if there is\nsomething typed on the keyboard.\n12\n\n\fIf control is returned due to available data from the pipe, the number returned by the\noperator \\_waitall() is preceded by a minus sign. If all jobs finish simultaneously with\ndata occurring in the pipe only a minus sign is returned.\nThe operator \\getpipeforwait() returns the PID of the pipe which has been set by\n\\setpipeforwait(rpipe) or an empty string if there is no active pipe for \\_waitall().\n\\pingServer(ip) checks if a DIANA server is available on a given IP address. The\nargument ip is the IP address in standard dot notation. The operator returns alive if\nthe server responds, or an empty string if the server cannot be found or does not respond.\n\\killServer(ip) kills the DIANA server running on the specified IP address. The\nargument ip is again the IP address in standard dot notation. The operator returns ok\non success, or an empty string on failure.\n\\killServers() kills all running DIANA servers. It returns an empty string on\nsuccess, or none on failure.\n\\lastjobname() returns the name of the last job started by the operator \\_exec().\n\\lastjobnumber() returns the number of the last job started by the operator \\_exec().\n\\whichIP(jobname) returns the IP address as 8 hexadecimal digits or an empty string\non failure.\n\\whichPID(jobname) returns the PID as a hexadecimal number or an empty string\non failure.\n\\getnametostick(jobname) returns the name of the \"master\" job to which the specified \"sticky\" job jobname has to stick. On failure it returns an empty string.\n\\jobtime(jobname) returns 8 hexadecimal digits, the job running time in milliseconds. If the job is not yet running, the operator returns \"00000000\".\n\\jobstime(jobname) returns 8 hexadecimal digits, the job starting time in milliseconds. The starting time is counted from the moment of the DIANA job queuing mechanism being activated till the time the job starts to run. If the job is not yet started, it\nreturns \"00000000\".\n\\jobftime(jobname) returns 8 hexadecimal digits, the job finishing time in milliseconds. The finishing time is counted from the moment of the DIANA job queuing mechanism being activated till the job is completed. If the job is not yet finished, it returns\n\"00000000\".\n\\rmjob(jobname) removes the named job. If the job is running, the related external\nprograms will automatically be killed by the signal SIGKILL. The operator returns an\nempty string independently of the result.\n\\clearjobs() clears all jobs. It returns an empty string on success, or the string\n\"Client is dead.\"\n\\jobstatus(jobname) returns the status of a specified job. The status is given in\nterms of 8 hexadecimal digits. The first two digits stand for the exit() argument of the\nexternal program if the program exited normally, otherwise they are \"00\". The third and\nfourth digits are the following: \"00\" \u2013 normal exit, \"01\" \u2013 exit because of non-caught\nsignal, \"02\" \u2013 the job was not run, \"03\" \u2013 no such job, \"04\" \u2013 job is finished, but its\nstatus is lost (often occurs after the debugger being detached); otherwise \u2013 \"ff\". If the\njob was removed by the operator \\rmjob(), the third digit will not be \"0\" but \"1\".\nThe last 4 digits stand for the number of the signal that caused the external program\nto terminate if the fourth digit was \"1\", otherwise \"0000\".\n13\n\n\f\\startjobtimeout(timeout) sets the timeout for attempts to start jobs (milliseconds). After the timeout is expired and the job is not yet running, it will be moved to\nanother handler if the total number of the timeout hits is less then 10. If the number of\ntimeout hits is 10, the job fails. Time is counted from the moment of the job being sent\nto the remote (or local) server. The operator returns the previous value of the timeout\nor an empty string on failure.\n\\gconnecttimeout() sets the timeout for the connection with a remote server (milliseconds). It returns the previous value of the timeout, or an empty string on failure.\n\\jobhits(jobname) returns 6 hexadecimal digits. The first two digits stand for the\nnumber of times the job was restarted due to the start timeout expiration. The third and\nfourth digits stand for the number of times the job was restarted after failures and the\nlast two digits represent the current placement of the job: \"01\" \u2013 the job is in the main\nqueue, \"02\" \u2013 the job is in the synchronous queue, \"03\" \u2013 the job is finished, \"04\" \u2013 the\njob failed, \"05\" \u2013 the job runs, \"06\" \u2013 the job is ready to run11 as a non-sticky job, \"07\"\n\u2013 the job is ready to run as a sticky job.\n\\failedN() returns number of failed jobs, or an empty string, on failure.\n\\hex2sig(sig) converts DIANA's internal signals' hexadecimal representation to local system ones (decimal numbers).\n\\sendsig(jobname,signal) sends a signal to the external program which was initiated by the specified job. Note, the signal will be sent to all external programs initiated\nby the job12 . It expects that the signal is either a symbolic name SIG. . . (the SIG\nprefix may be omitted), or a number. All possible symbolic names are (a subset from\nthe conventional UNIX signal identifiers): SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGFPE SIGKILL SIGSEGV SIGPIPE SIGALRM SIGTERM SIGUSR1 SIGUSR2\nSIGCHLD SIGCONT SIGSTOP SIGTSTP SIGTTIN SIGTTOU SIGBUS SIGPOLL\nSIGPROF SIGSYS SIGTRAP SIGURG SIGVTALRM SIGXCPU SIGXFSZ SIGIOT\nSIGEMT SIGSTKFLT SIGIO SIGCLD SIGPWR SIGINFO SIGLOST SIGWINCH. If\nthe signal is specified by a number, the signal will be sent as it is. If the signal is specified\nby a symbolic name, DIANA will convert it into an internal representation transferred to\nthe remote server. This may be useful if the numerical representation of signals on the\nremote system differs from the local one. The operator returns an empty string on success;\non failure it returns: \"10\" \u2013 job is not run, \"20\" \u2013 can't read a signal from DIANA; less\nthen 10: \"01\" \u2013 an invalid signal was specified, \"02\" \u2013 the pid or process group does not\nexist, \"03\" \u2013 the process does not have permission to send the signal, \"04\" \u2013 unknown\nerror.\n\\getJobInfo(jobn, format) returns information about the job number jobn, formatted according to format. The latter is a string of type n1/w1:...:nn/wn', where\nn# is a field number and w# is its width. If w# > 0, the text in the field will be right\njustified and padded on the left with blanks. If w# < 0, then the text in the field will be\nleft justified and padded on the right with blanks. If w#=0, then the width of the field\nwill be of the text length. Here is a complete list of all available fields:\n11\nI.e. all conditions to start the job are fulfilled and the job will be started as soon as some proper\nhandler becomes available.\n12\nThe external program initiated by the job runs in a new session (UNIX - specific term). Actually,\nthe signal will be sent to the process group corresponding to the initial external program.\n\n14\n\n\f1. current placement, see above;\n2. return code, 8 hexadecimal digits, see above;\n3. IP address (in dot notation);\n4. PID (decimal number);\n5. attributes (decimal integer);\n6. timeout hits (decimal number), see above;\n7. fail hits (decimal number), see above;\n8. max fail hits (decimal number), see above;\n9. errorlevel (decimal number), see above;\n10. the job name;\n11. number of command line arguments;\n12. all command line arguments starting from a second one (spaces separated);\n13. all command line arguments starting from a third one (spaces separated);\n14. all command line arguments starting from a fourth one (spaces separated).\nIf n# is zero or negative its absolute value is interpreted as the position of a single\ncommand line argument.\nExample: \\getJobInfo(1, 4/10:3/15) returns the PID of the external program of\nthe first job and the IP address of the computer on which the job runs. PID will be\nreturned as a decimal number padded by spaces on the left to fit a field of width 10, and\nIP will be returned in dot notation padded by spaces on the left to fit a field of width 15.\n\\tracejobson(filename) starts jobs tracing (for details see\ninto\nfiles\nhttp://www.physik.uni-bielefeld.de/\u223ctentukov/parallel demo.tar.gz)\n(\"filename.var\" and \"filename.nam\"), returns an empty string.\n\\tracejobsoff() ceases tracing. It returns an empty string. After it has stopped,\ntracing cannot be continued until all jobs are cleared by means of the operator\n\\clearjobs().\n\n4.4\n\nExample of high-level usage of parallel processing facilities\n\nVery often the external program may run in a subshell as a conventional UNIX command.\nFor such cases the following high-level TM function \\exec(command) can be defined:\n\\function exec cmd;\n\\push(\\eof())\n\\push(sh)\n\\push(-c)\n15\n\n\f\\push(\\get(cmd))\n\\return(\\_exec(,00011,255\\eof()4))\n\\end\nThe function starts the job consisting of some (maybe composed) standard UNIX command. The job will be successful if the command returns some exit code (under UNIX\nthere is no possibility to have an exit code higher then 255). On failure the job will be\nrestarted up to four times (the number 4 after \\eof()).\nThe function \\stick(command):\n\\function stick cmd;\n\\push(\\eof())\n\\push(sh)\n\\push(-c)\n\\push(\\get(cmd))\n\\return(\\_exec(,11110,\\eof()-2))\n\\end\nperforms the command cmd only after all earlier jobs are completed (the first 1 of the\nsecond argument of \\exec()). This function in general is used to collect all produced\nfiles. That is why it performs cmd on the same computer as the preceding job (the second\n1; since the job name to stick to is an empty string, the last job name will be used). The\njob started by this function is successful if it is started by the server (the fourth 1, and\nthe corresponding parameter is \"-2\"). The job will not be restarted on failure (the last\n0).\nThe function \\wait(timeout):\n\\function wait to;\n\\while\"\\let(r,\\_waitall(\\get(to)))\"ne\"\"do\n\\message(\\get(r)\\( jobs are not finished))\n\\loop\n\\end\nsuspends execution of the TM program until all jobs are completed. Each \"timeout\"\nmilliseconds the function reports the number of jobs which are not yet finished.\nThese three functions can be used to organize a simple parallel session with proper\nsynchronization. As an example, let us consider the following script runf, which is used\nto run FORM jobs in parallel after the FORM input has been produced in a folder (see\n[1], p. 158):\n#!diana -smp 1 -c runpar.tml\n\\STARTSERVERS(phya25,phya26,phya27,phya28)\n\\system(echo > log.all)\n\\REPEAT(N)\n\\exec(form -d i=\\get(N) do.frm > /tmp/log.\\get(N))\n\\stick(cat /tmp/log.\\get(N) >> log.all)\n\\stick(rm /tmp/log.\\get(N))\n\\ENDREPEAT()\n\\wait(2000)\n\n16\n\n\fThe user enters: runf 186 200 , and the system executes:\ndiana -smp 1 -c runpar.tml runf 186 200.\nThe file runpar.tml (see Appendix B) contains definitions of various TM functions\nand some settings; in particular it redefines the comment character as #. The following\nis the structure of the file runpar.tml:\nmessages disable\nesc character = \\\ncomment character = #\noutput file =\"\"\ndebug off\nonly interpret\n\\begin translate\nDefinitions various functions and macros, in\nparticular \\exec(), \\wait(),\n\\REPEAT(),\n\\ENDREPEAT()\nand\n\\STARTSERVERS()\n\\program\n\\\\SET(_CMDLN)(\\CMDLINE(1))\n\\RMARG(1)\n\\{\\include(\\GET(_CMDLN))\\\\setout(null)\n\\}\n\\end translate\nThe main program switches off the output (by means of the directive \\-), switches\noff \"hash\" regime for arguments by means of the directive \"\\{\" (see below), stores the first\ncommand\nline\nargument\n(\"\\SET(_CMDLN)(\\CMDLINE(1))\"), removes it (\"\\RMARG(1)\") and includes the file the\nname of which is the first command line argument\n(\"\\include(\\GET(_CMDLN))\").\nBy default, DIANA provides for the function and operator arguments some special\n\"hash\" regime: all spaces and ends of line are ignored. The directive \"\\{\" cancels this\nregime, the directive \"\\}\" activates it again. Without this directive all commands with\nspaces must be quoted by the quotation operator \"\\()\" which is not convenient for a\nscript.\nThe macro \\STARTSERVERS(list) checks if each server from list is working and if\nnot starts the server by means of the ssh. For example, for the host phya26 the following\ncommand will be performed:\nssh phya26 cd CD ; diana -d 1 -q\nwhere \"CD\" is a current directory, e.g. /home/user/jobs.\nThe operator \\system(echo > log.all) is used to produce an empty file\n\"log.all\".\n17\n\n\fAll the instructions between \\REPEAT(N) ... \\ENDREPEAT() are cycled with\nN=186,...,200. We assume that there is some folder file, say, tt.in with FORM input for each diagram. The FORM program do.frm evaluates a diagram by virtue of\nincluding a fold from the folder tt.in via an instruction like #include tt.in # n'i'.\nThe macro definition i comes from the command line form -d i=\\get(N) do.frm, where\n\\get(N) runs from 186 to 200. Each FORM job saves the result to the local directory,\nbut the corresponding concatenation is performed by \\stick(cat ...) on the same computer. At the end, all results will be collected in the file log.all, and all intermediate\nfiles \\tmp\\log.# will be removed.\nAfter all jobs are queued, the function \\waitall(2000) will report every 2 seconds\nhow many jobs are not yet completed.\nThis example is available at\nhttp://www.physik.uni-bielefeld.de/\u223ctentukov/parallel demo.tar.gz.\nIn the archive there are two directories: demo1 and demo2. The example is situated in demo1; see the Readme file for details of installation. For a more realistic (and\ncomplicated) example containing jobs controlling and monitoring facilities see demo2.\n\nAcknowlegement\nM. Tentukov is grateful for financial suuport by the DFG under project no. FL 241/4-2\n\nAppendix\nA\n\nThe listing of the Tcl/Tk script guiDemo\n\nThe following Tcl/Tk script is supposed to be placed into the executable file guiDemo:\n#! /bin/sh\n#\\\nexec wish \"$0\" \"$@\" -geometry +200+300\n# catches destroy window event:\nwm protocol .WM_DELETE_WINDOW {puts \"Quit\";exit 0}\nlabel .title\npack .title\n# create relief canvas:\nframe .buttons -bd 10 -relief raised\n#Button \"Run/Stop\":\nglobal checkb\nframe .buttons.run\ncheckbutton .buttons.run.run -text \"Run/Stop\"\\\n18\n\n\f-command {puts \"$checkb\"; flush stdout;\\\n.title configure -text [gets stdin]}\\\n-variable checkb\npack .buttons.run.run\npack .buttons.run -side left\n#Button \"Quit\"\nframe .buttons.quit\nbutton .buttons.quit.quit -text \"Quit\" -command\\\n{puts \"Quit\";exit 0}\npack .buttons.quit.quit\npack .buttons.quit -side left\npack .buttons\n# Read initial header:\n.title configure -text [gets stdin]\n#End:\nThe script creates a window with two buttons. The check button \"Run/Stop\" has two\nstates, \"selected\" and \"deselected\". The global variable checkb is set to indicate whether\nor not this button is selected. Every time the user clicks the \"Run/Stop\" checkbutton,\nthe script types to the standard output the value of checkb and reads the window header\nfrom the standard input. The \"Quit\" button, when pressed, outputs the line \"Quit\" to\nthe standard output and exits from the script. The same occurs when the user closes the\nwindow.\n\nB\n\nThe listing of the file \"runpar.tml\"\n\nThe following listing is typed in typewriter while comments are typed using italic.\nPreamble:\nmessages disable\nesc character = \\\ncomment character = #\noutput file =\"\"\ndebug off\nonly interpret\n\\begin translate\nThe function returns true if\nthe argument is a number:\n\\function isnumber str;\n\\if\"\\get(str)\"eq\"\"then\n\\let(res,)\n\\else\n\\let(sk,\\getcheck())\n\\setcheck(0123456789)\n\\let(res,\\check(\\get(str)))\n\n19\n\n\f\\setcheck(\\get(sk))\n\\endif\n\\return(\\get(res))\n\\end\n\\function wait to;\n\\while\"\\let(r,\\_waitall(\\get(to)))\"ne\"\"do\n\\message(\\get(r)\\( jobs are not finished))\n\\loop\n\\end\nBegin macrodefinition of the\nREPEAT environment\n\\DEF(REPEAT)\n\\IFSET(__REP)\n\\ERROR(Nested REPEAT!)\n\\ENDIF\n\\SET(__REP)(1)\nChecking command line arguments:\n\\if\"\\exist(__From)\"eq\"false\"then\n\\let(__From,\\cmdline(1))\n\\endif\n\\if\"\\exist(__To)\"eq\"false\"then\n\\let(__To,\\cmdline(2))\n\\endif\n\\beginlabels\n\\label(again)\n\\while\"\\isnumber(\\get(__From))\"ne\"true\"do\n\\let(__From,\\read('\\get(__From)'\n\\( is not an integer, enter new FROM:)))\n\\loop\n\\while\"\\isnumber(\\get(__To))\"ne\"true\"do\n\\let(__To,\\read('\\get(__To)'\n\\( is not an integer, enter new TO:)))\n\\loop\n\\if\"\\numcmp(\\get(__From),\\get(__To))\"eq\">\"then\n\\message(\\get(__From)>\\get(__To)!)\n\\let(__From,)\\let(__To,)\n\\goto(again)\n\\endif\n\\endlabels\nPre-processor SCAN is used since macro argument \\#(1)\ncannot be used in \\if operator:\n\\SCAN(\\if\"\\#(1)\"eq\"\"then)\n\\let(_iND,_index) Default iterator\n\\else\n\\let(_iND,\\#(1)) Use argument as iterator\n\\endif\n\\let(\\get(_iND),\\get(__From))\n\n20\n\n\f\\do Start the main loop\n\\ENDDEF\nEnd macrodefinition of the\nREPEAT environment\nMacrodefinition of the ENDREPEAT\nenvironment, rather simple:\n\\DEF(ENDREPEAT)\nEnd of the main loop\n\\while\"\\numcmp(\\inc(\\get(_iND),1),\\get(__To))\"ne\">\"loop\n\\UNSET(__REP)\n\\ENDDEF\n\\function exec cmd;\n\\push(\\eof())\n\\push(sh)\n\\push(-c)\n\\push(\\get(cmd))\n\\return(\\_exec(,00011,255\\eof()4))\n\\end\n\\function stick cmd;\n\\push(\\eof())\n\\push(sh)\n\\push(-c)\n\\push(\\get(cmd))\n\\return(\\_exec(,11110,\\eof()-2))\n\\end\nAttention! The following macro assumes that\nthe executable file ''diana\" is availavle\nfrom the system path set in the PATH variable,\nand the current directory is shared by NFS:\n\\DEF(STARTSERVERS)\n\\let(_cmd,\\( 'cd )\\asksystem(pwd,)\\( ; diana -m d -d 1,1 -q'))\n\\FOR(_srv)(\\*) Loop on all arguments\nRemove possible spaces from the server name:\n\\let(_n,\\delete(\\_srv(),\\( )))\n\\let(_ip,)\n\\if\"\\get(_n)\"ne\"\"then\nGet IP address:\n\\let(_ip,\\getip(\\get(_n)))\n\\endif\n\\if\"\\get(_ip)\"ne\"\"then\nIs the server alive?:\n\\if\"\\pingServer(\\get(_ip))\"eq\"\"then\nNot yet. Start it:\n\\message(\\(Starting server at )\\get(_ip)...)\n\\system(\\(ssh )\\get(_ip)\\get(_cmd))\n\\endif\n\\endif\n\\ENDFOR\nServers may be started successfully, but\nnetwork connection establishing may take some time.\n\n21\n\n\fSo try to ping servers, and if it does not respond,\nwait one second:\n\\FOR(_srv)(\\*)\n\\let(_n,\\delete(\\_srv(),\\( )))\n\\let(_ip,)\n\\if\"\\get(_n)\"ne\"\"then\n\\let(_ip,\\getip(\\get(_n)))\n\\endif\n\\if\"\\get(_ip)\"ne\"\"then\n\\if\"\\pingServer(\\get(_ip))\"eq\"\"then\n\\system(sleep 1)\n\\endif\n\\endif\n\\ENDFOR\n\\ENDDEF\nMain program:\n\\program\n\\- Switch off output\nStore first command line argument:\n\\SET(_CMDLN)(\\CMDLINE(1))\n\\RMARG(1)\\ Remove it\nNow command line arguments available\nfrom the script are counted in correct order\nInclude a script body:\n\\{\\include(\\GET(_CMDLN))\\Switch off output and close output\npossibly opened by the script:\n\\setout(null)\n\\}\n\\killServers() Kill all servers\n\\end translate\n\nReferences\n[1] J. A. M. Vermaseren, Symbolic manipulation with FORM (Amsterdam, Computer\nAlgebra Nederland, 1991).\n[2] L. Avdeev, J. Fleischer, M. Y. Kalmykov, and M. Tentyukov, \"Towards automatic analytic evaluation of massive Feynman diagrams\", Nucl. Instrum. Meth. A389 (1997)\n343; L. V. Avdeev, J. Fleischer, M. Y. Kalmykov, and M. N. Tentyukov, \"Towards\nautomatic analytic evaluation of diagrams with masses\", Comput. Phys. Commun.\n107 (1997) 155\u2013166.\n[3] M. Tentyukov and J. Fleischer, \"A Feynman diagram analyzer DIANA\",\nComput. Phys. Commun. 132:124-141,2000, see also http://www.physik.unibielefeld.de/\u223ctentukov/diana.html.\n[4] J. Fleischer et al., Phys. Lett. B459 (1999) 625; J. Fleischer, O. V. Tarasov\nand M. Tentyukov, Nucl. Phys. Proc. Suppl. 89 (2000) 112; F. Jegerlehner,\n\n22\n\n\fM. Y. Kalmykov and O. Veretin, Nucl. Phys. B641 (2002) 285; J. Fleischer et al., hepph/0202109; A. Onishchenko and O. Veretin, hep-ph/0209010 and hep-ph/0211280;\nM. Awramik et al., hep-ph/0209084.\n[5] P. Nogueira, J. Comput. Phys. 105 (1993), 279.\n[6] Kaplan, J. A., Nelson M. L.: A Comparison of Queuing, Cluster and Distributed\nComputing Systems. Technical Report TM-109025, NASA Langley Research Center,\nJune 1994.\n[7] C. Szyperski, Component Software, Beyond Object-Oriented Programming. AddisonWesley, ACM Press, New York, 1998.\n\n23\n\n\f"}