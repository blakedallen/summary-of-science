{"id": "http://arxiv.org/abs/1203.3092v1", "guidislink": true, "updated": "2012-03-14T14:08:12Z", "updated_parsed": [2012, 3, 14, 14, 8, 12, 2, 74, 0], "published": "2012-03-14T14:08:12Z", "published_parsed": [2012, 3, 14, 14, 8, 12, 2, 74, 0], "title": "gcodeml: A Grid-enabled Tool for Detecting Positive Selection in\n  Biological Evolution", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.5175%2C1203.1286%2C1203.5294%2C1203.6327%2C1203.3992%2C1203.0560%2C1203.0186%2C1203.0301%2C1203.5350%2C1203.0254%2C1203.1049%2C1203.2015%2C1203.3092%2C1203.5982%2C1203.4929%2C1203.6179%2C1203.6268%2C1203.5392%2C1203.1018%2C1203.6427%2C1203.0874%2C1203.4742%2C1203.1166%2C1203.2011%2C1203.1618%2C1203.3547%2C1203.3989%2C1203.5858%2C1203.2093%2C1203.5112%2C1203.0007%2C1203.4931%2C1203.0042%2C1203.6526%2C1203.2608%2C1203.3198%2C1203.3707%2C1203.5493%2C1203.3688%2C1203.1517%2C1203.6722%2C1203.5485%2C1203.2939%2C1203.6624%2C1203.1732%2C1203.1310%2C1203.0829%2C1203.5746%2C1203.3899%2C1203.5072%2C1203.1959%2C1203.6583%2C1203.5039%2C1203.6585%2C1203.2394%2C1203.3847%2C1203.2638%2C1203.0547%2C1203.3838%2C1203.4708%2C1203.3183%2C1203.0783%2C1203.5328%2C1203.5005%2C1203.2639%2C1203.4034%2C1203.0427%2C1203.4243%2C1203.6588%2C1203.0821%2C1203.3488%2C1203.3160%2C1203.6196%2C1203.3236%2C1203.1218%2C1203.3333%2C1203.5437%2C1203.1094%2C1203.2749%2C1203.1003%2C1203.2537%2C1203.6533%2C1203.3724%2C1203.4316%2C1203.6058%2C1203.0733%2C1203.2242%2C1203.3297%2C1203.4662%2C1203.1342%2C1203.1983%2C1203.4453%2C1203.6320%2C1203.5602%2C1203.0348%2C1203.5971%2C1203.0715%2C1203.2732%2C1203.3486%2C1203.0098%2C1203.5665&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "gcodeml: A Grid-enabled Tool for Detecting Positive Selection in\n  Biological Evolution"}, "summary": "One of the important questions in biological evolution is to know if certain\nchanges along protein coding genes have contributed to the adaptation of\nspecies. This problem is known to be biologically complex and computationally\nvery expensive. It, therefore, requires efficient Grid or cluster solutions to\novercome the computational challenge. We have developed a Grid-enabled tool\n(gcodeml) that relies on the PAML (codeml) package to help analyse large\nphylogenetic datasets on both Grids and computational clusters. Although we\nreport on results for gcodeml, our approach is applicable and customisable to\nrelated problems in biology or other scientific domains.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.5175%2C1203.1286%2C1203.5294%2C1203.6327%2C1203.3992%2C1203.0560%2C1203.0186%2C1203.0301%2C1203.5350%2C1203.0254%2C1203.1049%2C1203.2015%2C1203.3092%2C1203.5982%2C1203.4929%2C1203.6179%2C1203.6268%2C1203.5392%2C1203.1018%2C1203.6427%2C1203.0874%2C1203.4742%2C1203.1166%2C1203.2011%2C1203.1618%2C1203.3547%2C1203.3989%2C1203.5858%2C1203.2093%2C1203.5112%2C1203.0007%2C1203.4931%2C1203.0042%2C1203.6526%2C1203.2608%2C1203.3198%2C1203.3707%2C1203.5493%2C1203.3688%2C1203.1517%2C1203.6722%2C1203.5485%2C1203.2939%2C1203.6624%2C1203.1732%2C1203.1310%2C1203.0829%2C1203.5746%2C1203.3899%2C1203.5072%2C1203.1959%2C1203.6583%2C1203.5039%2C1203.6585%2C1203.2394%2C1203.3847%2C1203.2638%2C1203.0547%2C1203.3838%2C1203.4708%2C1203.3183%2C1203.0783%2C1203.5328%2C1203.5005%2C1203.2639%2C1203.4034%2C1203.0427%2C1203.4243%2C1203.6588%2C1203.0821%2C1203.3488%2C1203.3160%2C1203.6196%2C1203.3236%2C1203.1218%2C1203.3333%2C1203.5437%2C1203.1094%2C1203.2749%2C1203.1003%2C1203.2537%2C1203.6533%2C1203.3724%2C1203.4316%2C1203.6058%2C1203.0733%2C1203.2242%2C1203.3297%2C1203.4662%2C1203.1342%2C1203.1983%2C1203.4453%2C1203.6320%2C1203.5602%2C1203.0348%2C1203.5971%2C1203.0715%2C1203.2732%2C1203.3486%2C1203.0098%2C1203.5665&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "One of the important questions in biological evolution is to know if certain\nchanges along protein coding genes have contributed to the adaptation of\nspecies. This problem is known to be biologically complex and computationally\nvery expensive. It, therefore, requires efficient Grid or cluster solutions to\novercome the computational challenge. We have developed a Grid-enabled tool\n(gcodeml) that relies on the PAML (codeml) package to help analyse large\nphylogenetic datasets on both Grids and computational clusters. Although we\nreport on results for gcodeml, our approach is applicable and customisable to\nrelated problems in biology or other scientific domains."}, "authors": ["S\u00e9bastien Moretti", "Riccardo Murri", "Sergio Maffioletti", "Arnold Kuzniar", "Bris\u00e9\u00efs Castella", "Nicolas Salamin", "Marc Robinson-Rechavi", "Heinz Stockinger"], "author_detail": {"name": "Heinz Stockinger"}, "author": "Heinz Stockinger", "arxiv_comment": "10 pages, 4 figures. To appear in the HealthGrid 2012 conf", "links": [{"href": "http://arxiv.org/abs/1203.3092v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1203.3092v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "q-bio.PE", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1203.3092v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1203.3092v1", "journal_reference": null, "doi": null, "fulltext": "gcodeml: A Grid-enabled Tool for Detecting\nPositive Selection in Biological Evolution\nS\u00e9bastien MORETTIa,c, Riccardo MURRIb , Sergio MAFFIOLETTIb, Arnold\nKUZNIARa, Bris\u00e9\u00efs CASTELLAa, Nicolas SALAMINa, Marc ROBINSON-RECHAVIa,\nand Heinz STOCKINGER c,1\na\nDepartment of Ecology and Evolution, University of Lausanne and SIB Swiss Institute\nof Bioinformatics, Lausanne, Switzerland\nb\nGrid Computing Competence Center (GC3), University of Zurich, Switzerland\nc\nVital-IT Group, SIB Swiss Institute of Bioinformatics, Lausanne, Switzerland\n1 Heinz.Stockinger@isb-sib.ch\n\nAbstract. One of the important questions in biological evolution is to know if\ncertain changes along protein coding genes have contributed to the adaptation of\nspecies. This problem is known to be biologically complex and computationally\nvery expensive. It, therefore, requires efficient Grid or cluster solutions to overcome\nthe computational challenge. We have developed a Grid-enabled tool (gcodeml) that\nrelies on the PAML (codeml) package to help analyse large phylogenetic datasets on\nboth Grids and computational clusters. Although we report on results for gcodeml,\nour approach is applicable and customisable to related problems in biology or other\nscientific domains.\nKeywords. bioinformatics, phylogeny, positive selection, Grid, cluster, ARC.\n\n1 Introduction\nUnderstanding the evolution of species is one of the main questions in biology. To\naddress this question, it is necessary to develop mathematical models to estimate how\ndifferent biological processes could have resulted in the current diversity of life. In\nparticular, there is a strong interest to assess whether a certain feature or function could\nbe involved in the adaptation of organisms to their environment. The force that promotes\nsuch adaptation is generally known as positive or Darwinian selection (named after the\nbiologist Charles Darwin [2]), and the current increase of genomic data makes it possible\nto study the processes of adaptation at the molecular level (reviewed in [1], [4], [6]).\nSelectome [14] (http://selectome.unil.ch) is a database that provides information on\nsuch positive selection events. It is provided as an on-line resource that can be easily\nused by life science researchers. However, the underlying computational steps are\ncomplex and require large amounts of computational resources. In brief, the\ncomputationally intensive parts are based on the phylogenetic software package called\nPAML [18] and in particular the codeml application. The focus of our work is to provide\na suitable computational engine that efficiently and reliably executes thousands of\ncodeml jobs on both Grid and cluster environments.\nGiven that multiple codeml jobs are independent of each other, despite sharing parts\nof the input data sets, the application is embarrassingly parallel and therefore suitable for\ncluster, cloud and Grid environments. Previous production runs have been done on the\ncomputational cluster of Vital-IT (http://www.vital-it.ch), the High Performance\n\n\fComputing Center of the SIB Swiss Institute of Bioinformatics (http://www.isb-sib.ch).\nHowever, the computational needs of Selectome cannot be fully met by the Vital-IT\ninfrastructure without seriously limiting the remaining user groups. Consequently, in a\nprevious study we also looked into cloud solutions [10] and recently developed a\nsolution for a Grid environment.\nIn the following article we present gcodeml, a grid-enabled version of codeml that\nruns on the ARC-based Swiss Multi-Science Computing Grid (SMSCG,\nhttp://www.smscg.ch) [17] infrastructure. Internally, the tool makes use of GC3Pie [13],\na Python framework that provides the basic building blocks for high-throughput\napplications on both Grids (based on the Advanced Resource Connector - ARC [3]) and\nclusters (e.g. Sun/Oracle Grid Engine - SGE). gcodeml is a fault-tolerant solution that\nmakes use of ARC's Run Time Environment (RTE) feature to execute pre-installed\ncodeml applications at several sites of the SMSCG infrastructure. The underlying\nsoftware system takes care of job (re)-submission and automatically corrects for most\nerrors in case of problems with the Grid infrastructure. The latter is enabled via\ncustomised pre- and post-processing steps that follow the actual execution on remote\nsites. The GC3Pie framework has also been used successfully in computational\nchemistry\n[11],\nmolecular\nmodelling\nand\ncryptography;\nsee\nhttp://gc3pie.googlecode.com for a list of already supported use cases.\n2 Related Work\nAddressing embarrassingly parallel applications with a cluster, cloud or Grid\napproach has been done for many years using various approaches and many different\nGrid solutions for different application domains: computational phylogeny [16],\nsequence search and analysis [15] as well as cryptography [9]. However, most of the\nexisting solutions have been developed around a single use case or type of infrastructure.\nExtending or generalising these tools often results in the same level of complexity as\ndeveloping a complete end-to-end solution. Additionally, even if Grid technologies are\n(slowly but progressively) reaching maturity for implementing large-scale highthroughput computational use cases, it is still required to maintain a fine-grained control\nof the underlying Grid services and to optimise the access to the resources. Service\ninvocation, data transfer, fault-tolerant execution and supervision are only a few themes\nthat have to be addressed efficiently when dealing with large-scale data analysis.\nIn the last few years, within the SMSCG project, we had the opportunity to identify\nseveral key high-throughput usage and scalability patterns common to many different\nscientific use cases. Writing end-to-end solutions for these patterns using existing tools\nand adopting them within the SMSCG infrastructure would have required a substantial\nre-engineering effort: solutions such as GANGA [12], SAGA [8] or MOTEUR [5] do not\nprovide up-to-date interfaces to the ARC middleware, on which the SMSCG\ninfrastructure is built. Moreover, GANGA is centered on an execution and data handling\nmodel that is more adequate to high energy physics than life science applications,\nmaking it complex to generalise.\nSolutions like P-GRADE (http://portal.p-grade.hu) or WISDOM [7], despite being\ngeneric high-throughput submission engines, still require implementing the majority of\nthe control logic (i.e., the pre- and post-processing steps). We then considered the\nGC3Pie framework, a Python library, to declare and supervise the execution of large\n\n\fapplication campaigns. Since GC3Pie is already available and used on the SMSCG\ninfrastructure, it was chosen for implementing the high-level, application-specific control\nlogic for codeml. Further details and background information on the GC3Pie framework\nwill be given in Section 4.2.\n3 Biological Background and Computational Requirements\n3.1 The codeml Application\nThe codeml application is one of the software tools included in the PAML\n(Phylogenetic Analysis by Maximum Likelihood) package [18], which enables\nphylogenetic analyses of DNA and protein sequences using a maximum likelihood\napproach.\nSome background: while DNA sequences are drawn from an alphabet of four\ndifferent nucleotides (bases), proteins are built from 20 different amino acids. Each\nnucleotide triplet (e.g., AAC) is called a \"codon\" (cf. Figure 1) and is then translated into\na unique amino acid. In brief, in order to synthesise proteins, the four-letter DNA code is\ntranslated into the 20-letter code of proteins (several codons map to the same amino\nacid). Therefore, the name \"codeml\", since it takes aligned codons as input, and\nestimates the probability of an event of positive selection in the history of the specific\nprotein coding sequence. This is done by using the phylogenetic tree of related\nsequences, and then estimating the probabilities of transitions between an ancestral and\ndescendent codon (cf. Figure 1). For instance, in an ancient species the codon TAC might\nhave been TAT. Additionally, this change might have had a positive effect on descending\nspecies. In order to detect such changes, protein coding sequences of different species\nsuch as human, mouse or chimpanzee are compared.\n\nFigure 1. Input data for codeml: aligned codon sequences of five species (A-E) (left), a phylogenetic tree\nof the five species (right) inferred from the second column (codons) of the alignment.\n\nIn simple words, the aim of codeml is to detect positive selection events (resulting in\nimproved biological functions) in the history of species. In many cases, changes within\ncodons do not lead to positive selection events. This represents the null hypothesis (H0)\nthat we want to test against the assumption of a positive selection event, also referred to\nas the alternative hypothesis (H1), using the maximum likelihood ratio test. The codeml\nprogram evaluates both hypotheses separately using a maximum likelihood approach.\n\n\fThe detailed description of the algorithm is beyond the scope of this article (cf. [18] for\nfurther details) but the important feature is that different protein coding sequences and\nbranches can be analysed in parallel, which results in an embarrassingly parallel\nexecution of codeml.\n\nFigure 2. Overview of codeml's dataflow using data from the Ensembl database (sequence alignments\nand phylogenetic trees as shown in Figure 1).\n\nThe overview of the codeml execution is shown in Figure 2: a single codeml run\ntakes a sequence alignment file, the corresponding phylogenetic tree, as well as several\nparameters stored in a control file (cf. top part of Figure 2). A specific interior branch of\nthe tree is selected to test for positive selection. Then, codeml is run twice, once for H0\nand once for H1. Finally, data from several runs (i.e., all possible branches for each gene\ntree) are gathered to produce final codeml results, by the use of likelihood tests for each\npair H0/H1, and of a Bayesian inference of selected codons.\nThe runtime of codeml usually increases with the size of the tree (i.e., the number of\nleaves/genes) and the length of the sequences (i.e., the number of codons). On average, a\nsingle run for a single branch of a 30-gene tree takes about 20-30 minutes to compute.\n3.2 The Selectome Database\nGiven the computational costs of individual codeml runs, it is reasonable to precalculate the data for many different species and protein coding genes. In fact, this is a\ntypical approach in bioinformatics to avoid redundant calculations done repeatedly by\nmany groups. For positive selection, the database \"Selectome\" has been created as a\nresource for researchers in biological evolution. However, since new biological data\nbecome available with very high speed (the Ensembl database provides new releases\n\n\fevery 2 months), Selectome needs to be regularly updated to cope with changes and new\nbiological insights.\nThe results presented in Selectome are not based on simply running codeml: a\ncomplex workflow is involved to first prepare, then analyse, and finally to correctly\ndisplay the information on a web site. For details, refer to [14] and the documentation on\nthe Selectome web page (http://selectome.unil.ch/cgi-bin/methods.cgi). However,\nrunning codeml is by far the most compute-intensive part, and can only be done with\nlarge computational resources.\n3.3 Requirements\nThe basic requirements for the computational engine of Selectome (i.e., the efficient\nexecution of codeml jobs) are as follows:\n\u2022\nAccess to large computing resources. Ensembl version 66 from February 2012\nhas more than 50 vertebrate species. About 20,000 phylogenetic trees are\navailable as primary data for Selectome. This represents almost 2,000,000 jobs\nand 100 CPU years. The number of species sequenced increases exponentially,\nhence, increasing the size of the trees.\n\u2022\nFault-tolerant execution. Given that tens of thousands of jobs need to be\nexecuted, a fault-tolerant execution system is required that detects potential\nissues and corrects them automatically: if individual jobs fail, resubmit them or\nretry them on other machines. The system must not lose or omit jobs (codeml\nexecutions) but it is free to execute them in any order.\n\u2022\nNo human intervention to compute data: due to the scale of the problem that is\ndirectly proportional to the data size, it is necessary that the computational\nengine runs smoothly without human intervention, i.e., the person that launches\nthe codeml runs should not need to supervise each single execution but only\nintervene if major technical problems occur.\n4 Architectural and Technical Details\nIn the following section we describe how gcodeml, a client-side Grid and cluster\ntool, has been designed and implemented to meet the requirements. Note that gcodeml is\nnot necessarily a tool that will be used by many different users but mainly by selected\n\"production managers\", such as the one that needs to provide data for the computational\nengine of Selectome. This is an important requirement for the design and\nimplementation.\n4.1 Architectural Overview\ngcodeml is a client-side tool that uses the GC3Pie framework to manage codeml\ncomputational jobs, i.e., while GC3Pie provides a general job submission and execution\nframework (cf. Section 4.2), gcodeml is the application-specific code that establishes the\ninterface between the scientist and the Grid. Similarly to the standard codeml program,\ngcodeml requires a set of sequence alignments, phylogenetic trees and codeml parameter\nfiles. Given a set of directories containing these input files, gcodeml creates one\ncomputational job for each pair of corresponding H0 and H1 data sets; then it submits the\n\n\fjobs, monitors them and retrieves output results until all jobs have been successfully\nexecuted (cf. Figure 3).\nAlthough GC3Pie can manage jobs on a variety of batch-oriented systems, we have\nonly used the ARC back-end to distribute jobs on the SMSCG infrastructure. In order to\nensure maximum processing performance, the codeml application has been pre-installed\nat each site in SMSCG using the best available compilation options. By making use of\nARC's Run Time Environment (RTE) feature, codeml wrapper scripts can be executed in\nthe same way on each cluster without knowing the installation details of codeml at the\nclient side. Additionally, jobs are only scheduled to sites that have the codeml RTE\ninstalled and functional.\n\nFigure 3. Overview of gcodeml's workflow: (1) input folder is provided as input argument. (2) For each\nvalid sub-folder, an instance of CodemlApplication is created. (3) Each Application is added to a gc3libs\nexecution engine in parallel. (4) gc3libs.engine executes jobs in bulk on the SMSCG infrastructure. (5)\nwhen a CodemlApplication is finished, its terminated() method is called for post-processing (6). Once\nall CodemlApplication have terminated successfully, gcodeml ends and results are available on\nspecified destination (7).\n\n4.2 GC3Pie and gcodeml\nGC3Pie is a library of Python classes for running large job campaigns on diverse\nbatch-oriented execution environments. At the heart of the GC3Pie model is a generic\nApplication object which provides a high-level description of a computational job\n(including a list of input/output files, resource requirements and limits, etc.). GC3Pie\ntranslates this information into the job description format needed by the actual execution\nback-end selected, e.g., xRSL for ARC-based Grids, or a submission script for SGE.\nApplication objects can be adapted to provide behaviour customised to a specific use\ncase. For instance, the CodemlApplication object used in gcodeml knows how to locate\nthe phylogenetic trees and sequence alignment files given the main codeml input file; in\naddition, it implements the post-processing hook that is run after the codeml job has\nfinished and determines whether the run has been successful or not (cf. Figure 3).\n\n\fGC3Pie provides composition operators that allow treating a collection of jobs as a\nsingle whole [13]: this makes it easy to implement the \"embarrassingly parallel\" job\nscheme needed by gcodeml by simply bundling all jobs into a single collection with no\ndependencies.\n4.3 Specific Features of gcodeml\ngcodeml is a command-line tool which scans the directory recursively for input files\nand creates corresponding computational jobs. Then, it manages the jobs all the way\nthrough to successful completion and retrieves output results. Processing the set of\ncodeml computational jobs requires the following steps which are transparent to the\ngcodeml user except for the data organisation.\n1.\n\nInput data needs to be organised such that files (sequence alignments,\nphylogenetic trees and parameter files for both H0 and H1) are located in the\nsame directory. Hierarchies of directories are allowed with multiple input sets\nper directory in order to bundle several codeml runs.\n2. H0 and H1 need to be computed on the same computational node in order to\navoid spurious statistical deviations that might be due to different machine\narchitectures. Therefore, corresponding H0 and H1 input files are bundled into a\nsingle codeml job.\n3. Once the job has finished, result files are downloaded to the gcodeml client host\nor stored on a Grid Storage Element (using the GridFTP protocol). After the\nfiles have been downloaded, a post-processing step is executed: it checks that\nall required output files are present and parses them for specific tags to\ndetermine if codeml has run through the end. Sometimes, ARC might report\nerrors although all files have been successfully processed and/or downloaded.\nIn such cases, gcodeml over-writes the actual job status and corrects it.\n4. If a job has failed, gcodeml retries it at different execution sites until it is\ncorrectly executed (i.e., the post-processing step returns an \"OK\" status).\n5. The status of all submitted jobs is periodically monitored, and new jobs are\n(re)submitted until all jobs have terminated successfully.\nGC3Pie takes a polling approach to managing a collection of jobs: \"live\" jobs (i.e.,\njobs that are in running or submitted/scheduled state) are checked regularly, and an\nappropriate action is taken depending on their status. Output from finished jobs is\nretrieved, and new jobs are submitted to replace the older ones. The polling interval can\nbe set by a command-line option but, due to the ARC information system update delays,\nit is not useful to choose an interval shorter than 60 seconds.\nIn order to prevent the SMSCG infrastructure from overflow, one can specify the\ngcodeml limits for both the number of \"live\" jobs and the duration of a single job (which\nis also a safeguard against runaway codeml computations). The default limits are set to\n50 concurrent \"live\" jobs of 8 hours each.\nFor performance reasons, gcodeml relies on ARC's RTE to locate clusters with preinstalled codeml applications. However, not each site might have codeml installed (this\nmight be true for local cluster environments accessible with SGE). In such cases, the\nlocation of the codeml executable can be specified as a command-line argument, and\ncodeml will be submitted with the actual jobs. This is also a useful feature to test new\nversions of codeml.\n\n\fGiven that gcodeml builds on ARC, standard X.509 user certificates (either longlived ones or based on SLCS - http://www.switch.ch/grid/slcs/) are required. The GC3Pie\nframework (hence, gcodeml) takes care of proxy certificate management: if valid\ncertificate and proxy are not available at the start of a session, users are prompted for the\npass phrase; the proxy certificate is then automatically renewed when needed.\n5 Experimental Results\nA gcodeml client is installed on a machine at Vital-IT (within the network domain of\nthe University of Lausanne) and is accessible for bioinformaticians who update the\nSelectome database. The installation uses CentOS 5.6, ARC 0.8.3, and GC3Pie 1.1 with\nPython 2.4, and relies on the ARC servers installed at several sites in the SMSCG\ninfrastructure. Currently, ARC servers are installed at more than 10 sites in Switzerland,\noffering access to more than 7,000 CPU cores (only a subset of CPU cores is available\nfor gcodeml).\nIn order to test both the efficiency and the reliability of our approach, we used a real\ndataset from the Ensembl database consisting of 1,000 gene families with 12,636\nindividual Grid jobs. Each job executes 2 codeml runs, one for H0 and one for H1. In our\nSMSCG infrastructure we have currently five sites that have the codeml RTE available\nand are therefore candidates for participating in the experiment. One of the sites (EPFL)\nconsists of a Condor environment and uses a desktop Grid approach whereas all other\nfour sites (SIB/Vital-IT (Lausanne), University of Zurich, WSL (Zurich) and HES-SO\nGeneva) have dedicated clusters that are accessible on a 24x7 schedule. In total, the four\nsites have 2,164 CPU cores but only a fraction of that is available to a single user. The\nexact number depends on usage and varies over time.\nThe aim of the experimental runs it to show that gcodeml fulfills the requirements of\nsuccessfully executing all 12,636 codeml jobs in a \"reasonable\" amount of time (this\ncorresponds to the CPU-intensive \"Step 2\" in Figure 2). It is particularly important that\ngcodeml automatically corrects for errors and delivers reliable results. Overall, we\nconducted the experiment three times on SMSCG (using 50, 120 and 240 \"live\" Grid\njobs, respectively \u2013 a single Grid job can either be in running or submitted/scheduled\nstate) as well as once on the Vital-IT cluster using 240 jobs in parallel with all data\navailable on a parallel file system (no overhead for data transfer of input nor output). In\nall three Grid runs, gcodeml has corrected for all Grid errors and resubmitted jobs\n(between 17 and 118 errors were corrected) when necessary, to finally have all results\ncorrectly downloaded and stored on a client machine at Vital-IT. In the Vital-IT cluster\ncase using LSF, no errors have occurred. Detailed performance numbers (including the\nnumber of jobs and of sites involved) are shown in Figure 4.\nDuring one of the experiments (SMSCG 50S in Figure 4), the SLCS server (proxy\ncertificate management server) was upgraded and, therefore, had a down-time of a few\nhours. However, gcodeml correctly recovered from this issue and demonstrated a robust\nsubmission/execution system. Due to gcodeml's feature of adding new jobs and\nresubmitting failed jobs, gcodeml can also handle instances when a client's proxy\ncertificate expires.\nIn summary, the gcodeml system works very reliably on several sites of the SMSCG\nGrid, and delivers correct results with 100% success rates. This is due to the built-in error\nrecovery (resubmission) system. The results show that a local cluster with a parallel file\n\n\fsystem performs certainly better in terms of speed but the overall user-perceived quality\nof results is the same for cluster and Grid infrastructures. On both infrastructures, all test\nruns for detecting positive selections have been completed successfully.\n\nFigure 4. Performance of codeml jobs. On the left, the overall run time of all jobs is shown (including\nscheduling, and data transfer overhead). On the right, the individual wall times of the 12,636 codeml\njobs are shown.\n\n6 Conclusion\nOur proposed system is ready to be put into production to serve an actively used\nbiological database. The experimental runs have been successful and show that the Grid\napproach of gcodeml will allow us to recalculate Selectome for a new release based on\nthe Ensembl database. In the future, we also aim to use the European Grid infrastructure\noffered by EGI either through native EMI client integration in ARC or by providing a\nnew GC3Pie back-end for gLite Computing Elements (which are operated by many other\nsites in Europe, namely those participating in the WLCG Grid).\nA few more technical improvements are necessary to further ease the use of the\nsystem. For instance, support for long-running jobs needs to be added based on automatic\nrenewal of proxy certificates. Additionally, some further work is on-going with respect to\nhandling of job status information: currently, job states are stored in the file system\nwhereas we gain better performance with our current prototype based on a SQLite\ndatabase (not yet included in gcodeml). This also improves access times for job status\ninformation.\nAlthough the codeml algorithm is currently supporting an embarrassingly parallel\napproach, codeml does not yet make use of data-parallel features to allow for better\nperformance of single runs. In a related project (http://www.hp2c.ch/projects/selectome/)\nwe are currently improving both the algorithm and the implementation of the codon\nmodel used in Selectome. If the run-time of the codeml executable is improved, this also\n\n\fhas a positive impact on the number of Grid and/or cluster calculations that are required\nto produce new versions of Selectome since many nodes are now multi-core.\nAcknowledgments\nWe thank Manohar Jonnalagedda for his help in installing and configuring a first version of\nGC3Pie. Additionally, thanks to Volker Flegel for his support with hardware and system\nsoftware. Finally, thanks to all system administrators in SMSCG for installing and supporting the\ncodeml RTE. This work was supported by the projects UNIL.5 (Grid/Selectome) and SMSCG\n(with computational infrastructure and support) as part of the \"AAA/SWITCH \u2013 e-infrastructure\nfor e-science\" programme under the leadership of SWITCH, the Swiss NREN, and has been\nsupported by funds from the State Secretariat for Education and Research, the Federal Office for\nProfessional Education and Technology and ETH Board. Parts of the computations were\nperformed at the Vital-IT Center for high-performance computing of the SIB.\n\nReferences\n[1] Anisimova M and Liberles DA. The quest for natural selection in the age of comparative genomics.\nHeredity, 99:567-579, 2007.\n[2] Darwin C. On the Origin of Species by Means of Natural Selection, or the Preservation of Favoured\nRaces in the Struggle for Life London: John Murray. ISBN 1-4353-9386-4, 1859.\n[3] Ellert M, et al. Advanced Resource Connector middleware for lightweight computational Grids. Future\nGeneration Computer Systems, 23(2):219\u2013240, 2007.\n[4] Eyre-Walker A. The genomic rate of adaptive evolution. Trends in Ecol & Evol, 21:569-75, 2006.\n[5] Glatard T, Montagnat J, Lingrand D, Pennec X. Flexible and efficient workflow deployment of dataintensive applications on grids with MOTEUR. IJHPCA, 22(3):347-360, 2008.\n[6] Hurst LD. Fundamental concepts in genetics: Genetics and the understanding of selection. Nat Rev\nGenet, 10:83-93, 2009.\n[7] Jacq N, et al. Grid-enabled Virtual Screening Against Malaria. J Grid Computing, 6(1):29-43, 2008.\n[8] Jha S, Kaiser H, Merzky A, Weidner O. Grid Interoperability at the application level using SAGA. IEEE\nInternational Conference on e-Science and Grid Computing. Washington DC, 2007.\n[9] Kleinjung T, et al. A heterogeneous computing environment to solve the 768-bit RSA challenge. Cluster\nComputing, 15(1):53-68, 2012.\n[10] Kraut A, Moretti S, Robinson-Rechavi M, Stockinger H, Flanders D. Phylogenetic code in the cloud can it meet the expectations? Studies in Health Technology and Informatics, 159:55-63, 2010.\n[11] Maffioletti S, Murri R, Packard M, Reumann T. Enabling High-Throughput Computational Chemistry\non the Grid. Poster presented at the EGI User Forum 2011, Vilnius, Lithuania, Apr. 11-14, 2011.\n[12] Moscicki J, et al. Ganga: A tool for computational-task management and easy access to Grid resources.\nComputer Physics Communications, 180(11): 2303-2316, 2009.\n[13] Murri R, Maffioletti S, et al. Computational workflows with GC3Pie. Poster at EuroSciPy - Annual\nEuropean Conference for Scientists using Python, Paris, France, Aug. 25-28, 2011.\n[14] Proux E, Studer RA, Moretti S, Robinson-Rechavi M. Selectome: a database of positive selection.\nNucleic Acids Research, 37:D404-7 Database issue, 2009.\n[15] Stockinger H, et al. Grid Approach to Embarrassingly Parallel CPU-Intensive Bioinformatics Problems.\nIEEE Int. Conf. on e-Science and Grid Computing, Amsterdam, The Netherlands, Dec. 4-6, 2006.\n[16] Stockinger H, et al. Large-Scale Co-Phylogenetic Analysis on the Grid. International Journal of Grid and\nHigh Performance Computing, 1(1):39-54, 2009.\n[17] Stockinger H, et al. The Swiss National Grid Association and its Experience on a National Grid\nInfrastructure. Austrian Grid Symposium, 2009.\n[18] Yang Z. PAML 4: Phylogenetic Analysis by Maximum Likelihood. Molecular Biology and Evolution,\n24(8):1586-1591, 2007.\n\n\f"}