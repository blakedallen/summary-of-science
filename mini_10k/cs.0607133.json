{"id": "http://arxiv.org/abs/cs/0607133v1", "guidislink": true, "updated": "2006-07-27T17:55:16Z", "updated_parsed": [2006, 7, 27, 17, 55, 16, 3, 208, 0], "published": "2006-07-27T17:55:16Z", "published_parsed": [2006, 7, 27, 17, 55, 16, 3, 208, 0], "title": "Self-Replication and Self-Assembly for Manufacturing", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Self-Replication and Self-Assembly for Manufacturing"}, "summary": "It has been argued that a central objective of nanotechnology is to make\nproducts inexpensively, and that self-replication is an effective approach to\nvery low-cost manufacturing. The research presented here is intended to be a\nstep towards this vision. We describe a computational simulation of nanoscale\nmachines floating in a virtual liquid. The machines can bond together to form\nstrands (chains) that self-replicate and self-assemble into user-specified\nmeshes. There are four types of machines and the sequence of machine types in a\nstrand determines the shape of the mesh they will build. A strand may be in an\nunfolded state, in which the bonds are straight, or in a folded state, in which\nthe bond angles depend on the types of machines. By choosing the sequence of\nmachine types in a strand, the user can specify a variety of polygonal shapes.\nA simulation typically begins with an initial unfolded seed strand in a soup of\nunbonded machines. The seed strand replicates by bonding with free machines in\nthe soup. The child strands fold into the encoded polygonal shape, and then the\npolygons drift together and bond to form a mesh. We demonstrate that a variety\nof polygonal meshes can be manufactured in the simulation, by simply changing\nthe sequence of machine types in the seed.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "It has been argued that a central objective of nanotechnology is to make\nproducts inexpensively, and that self-replication is an effective approach to\nvery low-cost manufacturing. The research presented here is intended to be a\nstep towards this vision. We describe a computational simulation of nanoscale\nmachines floating in a virtual liquid. The machines can bond together to form\nstrands (chains) that self-replicate and self-assemble into user-specified\nmeshes. There are four types of machines and the sequence of machine types in a\nstrand determines the shape of the mesh they will build. A strand may be in an\nunfolded state, in which the bonds are straight, or in a folded state, in which\nthe bond angles depend on the types of machines. By choosing the sequence of\nmachine types in a strand, the user can specify a variety of polygonal shapes.\nA simulation typically begins with an initial unfolded seed strand in a soup of\nunbonded machines. The seed strand replicates by bonding with free machines in\nthe soup. The child strands fold into the encoded polygonal shape, and then the\npolygons drift together and bond to form a mesh. We demonstrate that a variety\nof polygonal meshes can be manufactured in the simulation, by simply changing\nthe sequence of machine types in the seed."}, "authors": ["Robert Ewaschuk", "Peter D. Turney"], "author_detail": {"name": "Peter D. Turney"}, "author": "Peter D. Turney", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1162/artl.2006.12.3.411", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/cs/0607133v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0607133v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "Java code available at http://purl.org/net/johnnyvon/", "arxiv_primary_category": {"term": "cs.MA", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.MA", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "I.6.3; I.6.8; J.2; J.3", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0607133v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0607133v1", "journal_reference": "Artificial Life, (2006), 12, 411-433", "doi": "10.1162/artl.2006.12.3.411", "fulltext": "Self-Replication and Self-Assembly for Manufacturing\nRobert Ewaschuk* and Peter D. Turney\u2020 (corresponding author)\nSubmitted to: Artificial Life; Category: Article; Date: April 26, 2005\n\nAbstract\nIt has been argued that a central objective of nanotechnology is to make products\ninexpensively, and that self-replication is an effective approach to very low-cost\nmanufacturing. The research presented here is intended to be a step towards this vision.\nWe describe a computational simulation of nanoscale machines floating in a virtual\nliquid. The machines can bond together to form strands (chains) that self-replicate and\nself-assemble into user-specified meshes. There are four types of machines and the\nsequence of machine types in a strand determines the shape of the mesh they will build.\nA strand may be in an unfolded state, in which the bonds are straight, or in a folded\nstate, in which the bond angles depend on the types of machines. By choosing the\nsequence of machine types in a strand, the user can specify a variety of polygonal\nshapes. A simulation typically begins with an initial unfolded seed strand in a soup of\nunbonded machines. The seed strand replicates by bonding with free machines in the\nsoup. The child strands fold into the encoded polygonal shape, and then the polygons\ndrift together and bond to form a mesh. We demonstrate that a variety of polygonal\nmeshes can be manufactured in the simulation, by simply changing the sequence of\nmachine types in the seed.\n\nKeywords: self-replication, self-assembly, nanotechnology, virtual physics, continuous\nspace automata, manufacturing, polygonal meshes.\n\n*\n\nInstitute for Information Technology, National Research Council of Canada, Ottawa, Ontario,\nCanada, K1A 0R6, rob@infinitepigeons.org\n\u2020\n\nInstitute for Information Technology, National Research Council of Canada, Ottawa, Ontario,\nCanada, K1A 0R6, peter.turney@nrc-cnrc.gc.ca, (613) 993-8564 (corresponding author)\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n1 Introduction\nResearchers have argued that one of the main objectives of nanotechnology is to\nmanufacture products inexpensively, and that this goal can be effectively achieved by\nself-replication [2], [8], [9]. We believe that it is useful to develop computational\nsimulations of self-replicating nanotechnology, as engineering tools to assist in the\ndesign of actual self-replicating machines.\nIn our earlier work with JohnnyVon 1.0, we developed a computational simulation of\nmachines that join to form self-replicating strands (chains of machines linked by flexible\nbonds) [17]. These machines drifted about in a virtual liquid, simulated as a twodimensional continuous space with Brownian motion and viscosity. There were two\ntypes of machines, which enabled a strand to encode an arbitrary bit string, by\ndesignating one type of machine as representing 0 and the other as 1. Although strand\nreplication faithfully preserved the encoded bit strings, the information in the strings\nplayed no functional role in JohnnyVon 1.0. In effect, the simulation had genotypes\n(genetic code) without phenotypes (bodies). From the perspective of potential\napplications in manufacturing, the absence of phenotypes was a major limitation of\nJohnnyVon 1.0.\nThis paper introduces JohnnyVon 2.0, which builds on its predecessor by adding\nphenotypes to the simulation. The design of JohnnyVon 2.0 was partly inspired by the\nwork of Seeman on building nanometer-scale structures with DNA [14], [15]. In living\norganisms, replication is based on DNA (the genotype) and the information encoded in\nDNA is used to build proteins (the major structural material of the phenotype). Seeman\nhas shown that DNA can serve both as a device for self-replication (genotype) and\n(surprisingly) as a building material for nanoscopic structures and tools (phenotype). By\nchoosing the appropriate sequence of codons, DNA can be programmed to selfassemble into a wide variety of structures, such as cubes, octahedra, one-dimensional\nstrands, two-dimensional meshes, and three-dimensional arrays. Seeman discusses a\nvariety of potential nanotechnological applications for these structures. For example, a\nthree-dimensional DNA array could facilitate x-ray crystallography, by serving as a\nscaffolding for holding molecular samples in a regular lattice [15].\nIn JohnnyVon 2.0, there are four types of machines, drifting in a two-dimensional\ncontinuous space with Brownian motion and viscosity (i.e., a simulated liquid). The\n\n2\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nmachines exert spring-like attractive and repulsive forces on each other, but internally\nthey are finite state machines. The input to each state machine is based on the presence\nor absence of bonds with neighbouring machines and on the internal states of bonded\nneighbours. The internal states govern when bonds are formed or broken and the angles\nat which bonded machines are joined, and thus determine whether a strand will form a\nstraight line or fold into a specific polygonal shape.\nFollowing the hint of Seeman's work, a strand in JohnnyVon 2.0 serves as both a\ngenotype and a phenotype, at different stages in its career [14], [15]. Like living\norganisms (but unlike von Neumann's strategy [21]), JohnnyVon 2.0 takes a templatebased approach to self-replication. A strand begins its career as a genotype. While\nacting as a genotype, the strand is approximately straight, so that it can provide a good\ntemplate for replication. Brownian motion and interactions with other machines will cause\nthe strand to bend slightly, because the bonds between the machines are flexible, but\nthe system is designed so that forces will tend to straighten the strand. Later in its\ncareer, the strand may become a phenotype. When this happens, the bonding forces\nchange, causing the bonding angles to alter, and the strand folds. This folding is\n(approximately) analogous to the way that proteins fold. A folded strand acts as a\nstructural element and is no longer capable of replication.\nA typical run of a JohnnyVon 2.0 simulation begins with a soup of unbonded machines\nand an initial unfolded seed strand of bonded machines. Free (unbonded) machines\nconnect to the seed strand, eventually forming a double strand (two parallel strands).\nWhen the new strand is complete, the two strands break apart, and thus we have selfreplication. A strand will continue to self-replicate until unbonded machines become\nscarce. When a strand has not encountered an unbonded machine for a relatively long\nperiod of time, the strand stops replicating and folds. The shape that it folds into\ndepends on the types of machines in the strand and their sequential ordering. Folded\nstrands drift in the virtual liquid and bond with each other, forming a mesh. The user can\nspecify the shape of the holes in the final mesh by selecting the sequence of machine\ntypes that compose the initial seed strand.\nIn Section 2, we discuss related work with von Neumann's universal constructor, selfreplicating loops, and artificial chemistry. The details of JohnnyVon 2.0's design are\nexplained in Section 3, including the changes that have been made from JohnnyVon 1.0\n[17]. We present our experiments in Section 4. Each experiment is a run of the\n\n3\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nsimulation with an initial seed strand. We demonstrate that a variety of polygonal\nmeshes can be manufactured by varying the initial seed. Section 5 examines limitations\nof JohnnyVon 2.0 and discusses problems and projects for future work. Potential\napplications are suggested in Section 6 and we conclude in Section 7.\n\n2 Related Work\nSipper provides a good survey of research on self-replication [16]. Some of the research\ninvolves actual mechanical devices and some is based on organic chemistry, but we\nrestrict our discussion here to computer simulations of self-replication. We briefly review\nvon Neumann's universal constructor [21], self-replicating loops [6], [10], [11], [12], [13],\n[18], [19], and artificial chemistry [4], [5].\n2.1\n\nUniversal Constructor\n\nVon Neumann's approach to self-replication was to design a universal constructor, which\ncould build anything, and therefore could build itself as a special case [21]. He described\nfive different models (i.e., five different kinds of simulations), with varying levels of\nrealism and concreteness. The design of the universal constructor was only worked out\nin detail for the cellular automata model, which was the most abstract of the five models.\nIn von Neumann's cellular automata model, the universal constructor was composed of\na group of several thousand cells that begin in a specific configuration of initial states.\nAnother line of cells acts as a kind of tape, which is read by the universal constructor.\nFor any given finite configuration of cell states, there is a tape that can cause the\nuniversal constructor to build the given configuration. As a special case, there is a tape\nthat can cause the universal constructor to build a copy of itself, thereby self-replicating.\n2.2\n\nSelf-Replicating Loops\n\nLangton demonstrated self-replication in a cellular automata model that was much\nsimpler than von Neumann's model [6]. He achieved this simplification by designing a\nconstructor that could construct only itself, instead of trying to make a universal\nconstructor. His cellular automata model had eight states instead of twenty-nine and his\nconstructor was composed of a group of about a hundred cells in a specific initial\nconfiguration, instead of a group of several thousand cells.\n\n4\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nIn Langton's model, the cells of the constructor are arranged in a loop. The states of the\ncells in the loop go through a cycle, periodically creating a copy of the original loop.\nStarting from the initial loop, increasing numbers of copies spread across the grid.\nThe idea of self-replicating loops in cellular automata models has since been developed\nfurther by many researchers [11], [12], [13], [19]. Self-replicating loops have exhibited\nmany interesting behaviours, including evolution [11], [13] and self-repair [19]. Tempesti\nhas described a self-replicating cellular automata model that can perform computations\nand build structures [18]. Morita and Imai have shown how a self-replicating cellular\nautomata model can encode a variety of shapes of loops, beyond the usual square loops\n[10].\n2.3\n\nArtificial Chemistry\n\nHutton introduced self-replication in an artificial chemistry simulation, using a templatebased approach [4]. A chain of molecules forms a template against which other\nmolecules bond, similar in concept to JohnnyVon 1.0 [17]. A run of the simulation begins\nwith a seed chain in a soup of free molecules. By a series of chemical reactions, a\nparallel chain of molecules forms next to the seed chain. When the parallel chain is\ncomplete, it separates from the seed chain and the process repeats.\nHutton's first approach was a cellular automata model [4], but the discrete space\nconstrained the mobility of the simulated molecules, hence Hutton's second approach\nused a continuous space [5], like JohnnyVon 1.0 [17]. In Hutton's second model,\nmolecules move in a continuous two-dimensional space, following linear trajectories until\nan obstacle (e.g., the container wall or another molecule) is encountered (i.e., the motion\nis a billiard ball model). When molecules make contact with each other, they undergo a\nchemical reaction that bonds them together, according to the rules of the artificial\nchemistry.\nIn Hutton's first model [4], the molecules only replicate, but in his second model [5], they\nalso build a circular barrier, suggestive of a cell wall. Each time a chain replicates, the\nnew chain builds a wall around itself.\nThe basic objects in Hutton's system (\"molecules\") are simpler than the basic objects in\nJohnnyVon (\"machines\"), which makes Hutton's system more computationally efficient.\nHowever, JohnnyVon has a richer virtual physics, including Brownian motion, attractive\nand repulsive fields, momentum, and viscosity. Hutton's molecules are points, with no\n\n5\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\ndirectional orientation, whereas JohnnyVon's machines are shapes with angular\norientation, which can rotate, experience twisting forces, and have angular momentum.\nThe richer virtual physics in JohnnyVon may be useful for simulations of manufacturing.\n\n3 JohnnyVon 2.0\nWe first give an overview of JohnnyVon 2.0 and then describe the system in detail. We\nencourage the reader to begin by viewing Figure 5 in Section 4.1. This figure should\nmake it easier to understand the following discussion.\n3.1\n\nOverview\n\nThe basic objects in the JohnnyVon simulation are called machines. There are four\ntypes of machines, numbered 1 through 4. All four types are shaped like a plus sign '+'\nand appear visually identical in the simulation (see Figure 5). Each machine has five\narms, but two of the arms overlap, so the figures seem to show four arms. In the figures,\nthe arms are represented by black lines.\nThe machines are mobile and can rotate at any angle, but it is convenient to describe\nthem when they are rotated into a standard reference position, which we call the\ncanonical position. In the canonical position, the shortest arm points down, the two\nlongest arms point right and left, and the medium-length arm points up. Another short\narm points up in canonical position, but it is hidden by the medium-length arm that points\nup. (The three machines labeled B, D, and F in Figure 1 are in canonical position. The\nfourth machine is upside-down.)\nThe two longest arms, pointing left and right when the machine is in canonical position,\nare called the left and right arms. When machines bond to form a strand, adjacent\nmachines in the strand are bonded to each other at the tips of their left and right arms.\nThe up arm is the longer of the two arms that point up when the machine is in canonical\nposition. When a strand replicates by forming a mirror strand, the machines in the mirror\nstrand are bonded to their neighbours in the original strand at the tips of their up arms.\nAlso, when the strands fold into polygons and join to form a mesh, the polygons bond to\neach other at the tips of their up arms.\nThe shorter of the two arms that point up, when the machine is in canonical position, is\nthe repellor arm. This arm overlaps the up arm in the figures, so it is not visible. When a\nstrand has completely replicated, repulsive fields are briefly activated at the tips of the\n\n6\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nrepellor arms. This splits the original strand from the mirror strand and pushes the two\nstrands apart.\nThe short arm that points down in canonical position is the overlap detector arm. This\narm is used to detect when two folded strands (e.g., polygons) overlap in a mesh.\nMachines move about in a two-dimensional continuous space, bounded by a grey box.\nThe centers of the machines are confined to the interior of the grey box. This space is\ncalled the container. A virtual liquid fills the container. The trajectory of a machine is\ndetermined by Brownian motion (random drift due to the liquid) and by interaction with\nother machines and the walls of the container. The liquid has a viscosity that dampens\nthe momentum of the machines. When there are machines suspended in the liquid, we\ncall it a soup.\nThe arms of the machines have attractive or repulsive fields. The range of a field is\nbounded by a circle. In addition to attracting or repelling, a field can also exert a bending\nforce, which twists the machines to form a particular angle. A field's interaction (attract,\nrepel, twist, or ignore) with another field is determined by many factors, including the\ntype and state of each machine. The fields behave somewhat like springs. The center of\nevery field is always at the tip (the outer end) of an arm.\nThe point at which the five arms meet is called the middle of the machine. This is not the\nmachine's geometrical center, but it is treated as the center of mass in the simulation.\nFor example, a rotational force will cause a machine to rotate about its middle.\nAlthough the space is two-dimensional, machines can slide over one another, as if they\nwere floating in a thin film of liquid. Machines interact with each other through their fields,\nrather than by direct contact. They do not experience direct collisions, but their fields can\ncollide.\nMachines can bond together when the field of one machine intersects the field of\nanother. Not all fields can bond. This is described in detail later. The machine that is\nbonded to the up (left, right) arm of a given machine is called the up (left, right)\nneighbour. A chain of machines joined by left arm to right arm bonds forms a strand.\nDuring replication, the bond angles are such that the replicating strand tends to be\nstraight. Brownian motion and other forces perturb the strand, so it cannot be perfectly\nstraight, but twisting forces in the bonding fields tend to straighten the strand, so it is\n\n7\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nrarely far from being straight. We call these approximately straight strands unfolded\nstrands or genes (a strand in its genotype state).\nUnder specific circumstances (described in Section 3.4.1), each bond in a strand will\nchange its angle, causing the strand to fold. Such strands are called folded strands or\nphenes (a strand in its phenotype state). A phene will fold to form a closed loop. A group\nof phenes can bond together, forming a mesh.\nA machine with no bonds is called a free machine. A typical simulation begins with a\nsoup of free machines and a single seed gene. The seed gene is an unfolded strand that\ninitiates the process of self-replication. The first child of the seed gene forms the seed\nphene, which acts as a starting point for the growth of the mesh. This ensures that one\nseed phene will yield only one mesh.\nA left-neighbour-to-right-neighbour bond is a sideways bond. Machines in a strand (both\nphenes and genes) are joined by sideways bonds. An up-neighbour-to-up-neighbour\nbond is an up bond. Phenes in a mesh are joined by up bonds. During replication, a\nparent gene is joined to its partially constructed child gene by up bonds.\nThe JohnnyVon simulation proceeds in a sequence of discrete time steps. The initial\nconfiguration is called step 0 or time 0. The state of a machine is the combination of\ninternal information (counters, bonds, and other state variables) and external\nrelationships (position, rotation, and velocity) that determines the behaviour of a\nmachine. A counter is a special piece of information stored in each machine that\nnormally increments during each time step. Each machine has several counters. States\nare described in more detail in Section 3.3.\nEach bond has a desired angle (which changes when a strand folds). The two machines\nthat participate in each bond have a tolerance for the difference between the current\nangle and the desired angle. Forces can push bonds out of tolerance. Bonds that are\nconsistently out of tolerance can break.\nOne of our main design objectives was to make JohnnyVon 2.0 programmable by the\nuser, by specifying the initial configuration of the simulation, without making any changes\nto the rules of the virtual physics or the behaviours of the machines. By selecting the\ntypes of machines in the seed gene and specifying their sequential order, the user can\nprogram JohnnyVon to make a variety of polygonal meshes. In a manufacturing\napplication, we envision the user selecting the desired machines from four bins, joining\n\n8\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nthem together to make a seed gene, and then dropping the seed into a vat of free\nmachines. The user would be able to manufacture a variety of products without making\nany modifications to the individual machines.\nWith only one type of machine, the user would be able to program the simulation only by\nspecifying the length of the seed gene. With two types of machines (as in JohnnyVon 1.0\n[17]), programs can use more efficient binary coding. In principle, two types of machines\nwould be sufficient for programming mesh construction, but we found that four types\nprovide a good balance of simplicity and programmability. Four types are enough to\nencode a variety of shapes (see Table 6 in Section 3.4.2 and the experiments in Section\n4), yet four types are not so many that the system is unwieldy. The four types of\nmachines are somewhat analogous to the four amino acids in DNA (adenine, thymine,\nguanine, and cytosine), which encode programs for building proteins.\n3.2\n\nBasic Modifications\n\nThis subsection describes the core changes in the simulation that were made from\nJohnnyVon 1.0 to JohnnyVon 2.0. (Sections 3.3 and 3.4 discuss new features, as\nopposed to modified features.)\n3.2.1\n\nVariable Field Sizes\n\nBonds between machines are formed by spring-like attractive fields. Part of the\nmechanism that was in place to support mutation in JohnnyVon 1.0 was a variable field\nsize. In certain circumstances, the field would be small, permitting rare accidental bonds,\nwhile other times it would be large, to strengthen intentional bonds. The accidental\nbonds were a cause of mutation (replication errors), whereas the intentional bonds were\npart of faithful replication.\nIn JohnnyVon 2.0, field sizes do not change. Fields attract, repel, or ignore other fields,\nbut they have a constant circle of influence. In situations where the original version has\nsmall fields, the new version has inactive fields. This modification substantially reduces\nthe likelihood of mutations.1\n\n1\n\nMutations are desirable when modeling biological life, but may be undesirable when modeling\nmanufacturing processes.\n\n9\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n3.2.2\n\nPhysical Constants\n\nThe physical constants for viscosity, Brownian motion, and motion dampening were\nchanged to suit the new requirements. The values of these constants were\nexperimentally tuned to achieve our design objectives while maximizing the speed\n(computation efficiency) of the simulation.\n3.2.3\n\nArms and the Machine\n\nIn JohnnyVon 1.0, each machine was shaped like a capital letter 'T'. Each machine had\nfour arms, but two of the arms overlapped (along the vertical bar of the T), so the figures\nin the paper seem to show three arms [17]. Each arm had an attractive or repulsive field\nwith a circular shape, centered on the tips of the arms. The fields were colour coded,\nand we named the arms according to the colours of their associated fields.\nIn JohnnyVon 2.0, each machine is shaped like a plus sign '+' (see Figure 5 in Section\n4.1). Each machine now has five arms, but two of the arms overlap, so the figures seem\nto show four arms. It is no longer convenient to refer to the arms by the colours of their\nfields. We now refer to the arms by their relative positions (up, left, right), when the\nmachine is rotated into a canonical position. The lengths of the arms have been modified\nto facilitate building meshes.\n3.3\n\nMachine States\n\nThe state of a machine is represented by a vector. The vector elements that represent\ninternal aspects of the machine are all discrete. The vector elements that represent\nexternal relationships between machines are mostly continuous. The discrete, internal\nelements are governed by state transition rules that are applied in discrete timesteps.\nThe continuous, external elements are governed by the laws of the virtual physics. The\nphysical laws are inherently continuous, but they are necessarily approximated\ndiscretely in any computational simulation.\nInternal state information includes various flags, counters, and state variables, as\nsummarized in Table 1. External state information includes spatial location and\norientation, angular velocity, linear velocity, the presence or absence of bonds with other\nmachines, and bonding angles, as given in Table 2. Some derived variables are shown\nin Table 3. The derived variables are calculated from state variables.\nInsert Table 1 here.\n\n10\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nInsert Table 2 here.\n\nInsert Table 3 here.\n\nMachines that are directly bonded together can sense each other's states. This is\nanalogous to cells in cellular automata, which can sense the states of their immediate\nneighbours in the grid. The state transition rules and the virtual physics are local, in the\nsense that there is no global control structure. No machine can directly sense the state\nof another machine unless they are directly connected, although state information can\nbe passed neighbour-to-neighbour along a strand. No machine can directly exert a force\non another machine unless the circular boundaries of their fields overlap, although\nforces can be passed neighbour-to-neighbour along a strand.\nMost of the state transition rules and physical laws in JohnnyVon 2.0 are carried over\nfrom JohnnyVon 1.0 without change. The details of JohnnyVon 1.0 are fully described\nelsewhere [17]. The changes we made in JohnnyVon 2.0 were outlined above, in\nSection 3.2.\n3.4\n\nNew Rules\n\nThe following subsections describe the rules that are new in JohnnyVon 2.0.\n3.4.1\n\nFolding\n\nThe leftmost machine in an unfolded strand determines when the strand will fold. A\nmachine knows it is leftmost when it has a right-neighbour but no left-neighbour. As part\nof its internal state, each machine maintains a fold-counter. After a strand has replicated\nand split, the fold-counter in each machine in the newly formed strand starts counting.\nWhen a machine gains an up-neighbour, it triggers a reset-counter signal. This signal is\npassed to the left-neighbour, down the strand, until it reaches the leftmost machine.\nWhen the leftmost machine receives the signal, it resets its fold-counter to 0. This is\nillustrated in Figure 1. In this way, as long as a replicating strand continues to receive\nnew up-neighbours, it will not fold up. If the strand successfully replicates, the leftmost\nfold-counter in each of the two strands (the child strand and the parent strand) is set to\n0.\n\n11\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nInsert Figure 1 here.\n\nOnce the fold-counter in the leftmost machine hits a fixed upper limit, that machine\ntriggers a fold-now signal. This signal is passed down the strand, setting the folded flag\nas it goes. This causes the strand to fold up according to the types of each of the two\nmachines involved in a sideways bond.\nWhen a strand folds, there are typically some up-neighbours attached to the folding\nstrand, as the folding strand has usually partially replicated itself. Machines with an upneighbour, but having a false (0) replicated flag, monitor their up-neighbour's folded flag.\nIf this flag becomes true (1), then such a machine will set its own shatter flag to true, and\nthus release all its bonds. (Shattering is described in detail in 3.4.7.)\nMachines with the seed-gene flag set to 1 never fold, thus the initial seed strand is\nalways available, to continue replicating as soon as there is a supply of free machines of\nthe right types. This is a safeguard against situations in which a temporary scarcity of\nfree machines persists for longer than the fixed upper limit on fold-counter.\n3.4.2\n\nAngles and Bonds\n\nIn contrast to JohnnyVon 1.0, we now have four types of machines instead of two types,\nand the type of a machine affects its behaviour in both genes and phenes. In genes, the\ntypes govern bonding during replication, where the rule is simply, \"Likes attract, others\nare ignored.\" More formally, the bonding rule for up bonds in genes is given in Table 4.\nInsert Table 4 here.\n\nThis rule implies that each replicated strand is a mirror of its parent, rather than an exact\ncopy. For example, a strand of types 1-2-3, reading left to right, in canonical position, will\nreplicate as 3-2-1. The phenes that we demonstrate here (in Section 4) have this simple\nsymmetry (i.e., the strands and their mirror images both fold into the same polygonal\nshapes), so this is not a problem.\nThe rules for up bonds in genes are different from the rules for up bonds in phenes. In\nphenes, only certain combinations of types will bond on their respective up arms, as\ngiven in Table 5.\n\n12\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nInsert Table 5 here.\n\nAny type of machine can form a sideways bond with any other type, in both genes and\nphenes, but a left arm must bond with a right arm (i.e., no left-left nor right-right bonding\nis allowed). In phenes, the types on each side of a sideways bond govern the angle the\nbond will take when the strands have folded, as specified in Table 6. This means that the\ntypes involved in each bond control the shape that the folded strand will take.\nInsert Table 6 here.\n\nTable 6 shows the sideways bond angle formed by each pair of machine types, when a\nstrand is in its phenotype state; that is, when folded is set to 1 (true). When a strand is in\nits genotype state (folded is 0 for all machines in the strand), the sideways bond angles\nare all 0\u00b0 (straight). Up bond angles are always 0\u00b0 ( ignoring random perturbations, from\nBrownian motion, for example).\nThe blank cells in Table 6 represent combinations of types for which we have not yet\nfound a use. From Table 5, it can be seen that a type-3 machine cannot form an up bond\nwith another type-3 machine when they are in phenes. Therefore we could control the\nshape of a 3-3-...-3 phene by specifying any desired value for the angle of 3-3 bonds in\nTable 6, but the resulting phenes would not be able to form a mesh. Similarly, we could\ncontrol the shape of a 3-4-3-4-...-3-4 phene by giving any desired value for the angles of\n3-4 and 4-3 bonds in Table 6, but the resulting phenes can form up bonds in multiple\nways (3-4, 4-3, and 4-4; see Table 5). Thus we have limited control over the shape of\nthe mesh that the phenes will form.\nIn Table 6, it can be seen that all sideways bonds involving type-1 machines are straight.\nThis allows us to expand the size of a phene, without changing its shape, by inserting a\nsequence of type-1 machines along each edge (see Figure 2). However, it does not\nallow polygons with exactly two machines on each side, since expansion requires at\nleast one type-1 machine inserted between two other machines.\nInsert Figure 2 here.\n\n13\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nGiven the angles that are available to us in Table 6, some polygons (e.g., octagons and\nsquares) require two types of machines, while others (e.g., triangles and hexagons)\ninvolve only one type. We chose to restrict the JohnnyVon 2.0 to four types of machines,\nin order to demonstrate that a small number of components can be combined to build a\nvariety of structures (like Lego blocks). The angles that we chose make it easy to build\ntriangular meshes. It may seem inconvenient to require two types of machines to build\noctagonal meshes, but in fact, having two types of machines is helpful with octagons. An\noctagonal mesh has both octagonal holes and square holes (see Image 4 in Figure 6 in\nSection 4.2). With two types of machines, we can prevent octagonal phenes from filling\nin the square holes in the mesh.\nA single type of machine would be sufficient to create squares, but using two types\npermits rectangles that will mesh correctly. With two types of machines, the long and\nshort sides of the rectangle can be distinguished by type, so that two sides will bond\ntogether only if they have the same machine type, and thus the same length (see Figure\n3).\nInsert Figure 3 here.\n\nThough they could use two types, hexagons will form a mesh faster with only one type.\nFurthermore, in order to get the desired behaviour with four machine types, exactly one\nof the squares or hexagons had to use only one machine type, and the other had to use\ntwo. While it would be possible to have an irregular hexagon, this seems much less\nnatural than a rectangle.2\nTable 5 shows how machine types control phene bonding in meshes. The bonding rules\nin Table 5 were designed so that octagonal meshes will form correctly. They prevent\noctagonal phenes from filling square holes in the mesh.\nAdditional rules were created to support expansion of the size of a phene, without\nchanging its shape, by inserting a sequence of type-1 machines along each edge. These\nrules are based on the derived variable bend-location. In a phene, a given machine can\nhave either a straight (type 1) or bending (types 2, 3 or 4) machine bonded to its left or\nright arm. By looking at its neighbours, it can determine where it is in the context of the\n\n2\n\nIn a regular polygon, all sides have the same length. Rectangles are irregular.\n\n14\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nphene, and hence it can calculate the value of bend-location. Certain values of bendlocation can override the rules in Table 5 and disallow a bond that would otherwise be\npermitted. Table 7 explains the meaning of the different values of bend-location. Table 8\nshows how bend-location affects bonding.\nInsert Table 7 here.\n\nInsert Table 8 here.\n\nWhen the up field of a machine in one phene overlaps with the up field of a machine in\nanother phene, the rules in both Table 5 and Table 8 must be satisfied before the up\nfields can bond. If there are no type 1 machines in the phene (i.e., all sideways bonds\nare bent; the shape is not expanded), then bend-location must have the value 3 for all\nmachines, and thus (by Table 8) up bonds depend only on the machine types (Table 5).\nIn Table 7, we are assuming that the phene forms a closed loop. The error correction\nsystem will destroy open loops (Section 3.4.4). When a machine has no left or right\nneighbour (because it is at the end of an open strand), we treat the missing neighbour as\nif it were a bending type.\n3.4.3\n\nOverlap Detection\n\nBecause of flexibility in the mesh, and in individual phenes, two phenes can sometimes\njoin a mesh in such a way that their desired positions overlap. This can be most easily\nseen by imagining a mesh of hexagons that is complete except for a single gap.\nSuppose that two hexagons jostle (by Brownian motion) into the gap, with slightly\ndifferent alignments. At roughly the same time, one forms a bond with the phene above\nthe gap, and one with the phene below the gap. As they straighten towards their ideal\nposition (due to twisting forces on their up bonds), each phene may pick up new bonds\naround the edge of the former gap (see Figure 4).\nInsert Figure 4 here.\n\nIf ignored, this problem spreads, since there are now unbonded up arms on each of the\ntwo overlapping hexagons, which permit new hexagons to join the mesh, overlapping\n\n15\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nthose around the former gap, and each of these hexagons in turn can bring in more\noverlapping hexagons.\nTo address this problem, an arm was added to the machines (new since JohnnyVon\n1.0), called the overlap detector arm. In a folded strand, it points towards the center, and\nwill only bond with other overlap detector arms. Both machines must be oriented in the\nsame direction (up to a fixed degree of tolerance), and both machines must have their\nin-mesh flag set to true.\nWhen an overlap detector bond is formed between two machines (necessarily in two\ndifferent phenes), one machine (chosen arbitrarily) sets its unfold signal to true. This\nsignal propagates to its left and right neighbours, setting folded to false as it goes. It also\nbreaks the overlap bond that triggered it. The resulting unfolded strand behaves exactly\nlike a newly replicated strand. It tries to replicate until fold-counter exceeds its limit, and\nthen it folds up again.\nIn summary, when two phenes compete for the same gap in a mesh, one of them is\nforced to become a gene. Converting one of the phenes to a gene, instead of leaving it\nas a detached phene, allows time for it to drift away from the problematic area, or for the\nremaining phene to fill up the open bonds in the mesh.\n3.4.4\n\nStress Detection\n\nAnother type of error can occur in a mesh, again due to the flexibility of the mesh. In this\ncase, we can imagine five triangles bonding to form a pie shape, missing only one more\ntriangle to form a hexagon. However, instead of a new triangle coming in to fill the gap,\nthe two triangles on either side of the gap jostle together, forming a stressed pentagon\nrather than a hexagon. This pentagonal mesh may be part of a larger mesh, and thus\nsome of the stress may be distributed through the larger mesh. This problem can be\npartially addressed by increasing the strength of some of the fields and decreasing the\ntolerance of some of the bonding angles, but it becomes increasingly hard to prevent as\nthe mesh grows.\nTo detect this kind of problem, each machine maintains a stress-counter, which\nincrements each time interval when the machine is not in-tolerance, and is reset\nwhenever the machine is in-tolerance. This counter can be used to detect cases in which\nthe mesh is stressed because phenes have bonded incorrectly. When the counter\nexceeds a fixed maximum, it causes the stressed phene to unfold, by setting its unfold\n\n16\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nsignal to true. The signal propagates to left and right neighbours, setting folded to false\nand dropping up bonds as it spreads through the neighbours.\nThe in-tolerance variable is purely local. Its state depends only on the relation between a\nmachine and its immediate neighbours. Likewise, the unfold variable is purely local, but\nthe information that it conveys can spread through each machine in a phene. When one\nmachine's unfold variable becomes true, its immediate neighbours sense this, and then\nset their unfold variables to true.\n3.4.5\n\nSeeding the Mesh\n\nIn the initial seed gene, seed-gene is set to true, but it will be set to false for all of the\nchild genes. If a machine has a true seed-gene, it will never trigger the fold-now signal.\nSince the initial seed gene will never fold, there will always be a strand that can continue\nreplicating whenever free machines become available.3\nThe first child of the seed gene, and only the first child of the seed gene, becomes the\nseed phene. When the seed-phene flag is set to true in a strand, it does not mean that\nthe given strand is the seed phene; it means that the next child of the given strand will\nbecome the seed phene. In the initial seed gene, seed-phene is set to true. When the\nseed gene first replicates, its child examines its parent's seed-phene flag and observes\nthat it is set to true. The child then sets it in-mesh flag and its folded flag to true and it\nimmediately folds to become the seed phene. The parent (the initial seed gene) then\nsets its seed-phene flag to false, so that its future children cannot become seed phenes.\n(When we say that a strand sets a flag to a value, it is a shorthand way of saying that\nevery machine in the strand sets the flag to the value. Strands do not have flags of their\nown, other than the flags of their component machines.)\nEvery other gene, created after the first child, will begin its career with its in-mesh flag\nset to false. If two phenes meet with their in-mesh flags set to false, they cannot bond\n3\n\nWhen the seed gene replicates, all of the information that it encodes, by the sequential order of\n\nthe machine types in the strand, is also replicated. However, the child strand will have its seedgene flags set to false, so it might be argued that the seed gene has not fully self-replicated, in a\nvery strict sense. The purpose of the seed-gene flag is merely to ensure that replication will\ncontinue after a hiatus in the supply of free machines. This is not essential to the simulation. We\ncould remove this flag without causing any major problems. Therefore full self-replication, in a\nvery strict sense, is readily attainable, if desired, by a minor modification to JohnnyVon.\n\n17\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\ntogether. A phene can only bond to another phene if the other phene has its in-mesh flag\nset to true. When a machine (in a phene) with a false in-mesh flag meets a machine (in a\nsecond phene) with a true in-mesh flag, they bond (assuming they meet all the\nconditions in Section 3.4.2), and a signal propagates through the first phene, setting all\nof the in-mesh flags to true (but the signal only propagates from one machine to its\nsideways neighbour when their bond is in-tolerance; see Section 3.4.4). This ensures\nthat the mesh can only grow from the seed phene.\n3.4.6\n\nTolerances\n\nEach machine will only form up bonds if all existing bond angles are within a certain\ntolerance. That is, if a machine's sideways bonds are at angles significantly different\nfrom the desired angles (i.e., the angles given by the rules in Section 3.4.2), then no up\nbonds will form during the current timestep. This prevents unintended up bonds during\nvulnerable times, such as during splitting or folding.\n3.4.7\n\nShattering\n\nThere are a number of ways that a gene or phene can break. For example, during\nsplitting, the phase of self-replication when two genes are pushed apart by their repellor\narms, if one of them hits the wall of the container at an angle, it puts significant strain on\nthe whole strand. As another example, an error in a mesh can eventually lead to enough\nstrain to pull a phene apart (see Section 3.4.4).\nIf a machine loses a bond unexpectedly (which is any time other than when splitting or\nunfolding), or if it notices that its neighbour has folded, then the shatter flag is set to true.\nWhen a machine observes that its neighbour's shatter flag is true, the machine may\nrespond by setting its own shatter flag to true. We say that the first machine is the\nsource of a shatter signal that was received by the second machine.\nThe shatter signal always propagates through sideways bonds, setting the shatter flag to\ntrue in left-neighbours and right-neighbours. The shatter signal may also propagate to an\nup-neighbour, but only if the source machine has replicated but not folded. If the\nneighbouring machine has replicated, something went wrong with the split (two\nreplicated machines should not be bonded before they're both folded); on the other\nhand, if the neighbour's replicated flag is false, then it may be part of an incomplete\ncopy, and thus should be abandoned.\n\n18\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nWhen a machine's shatter flag is true, it drops all of its bonds (the discrete timesteps\nensure that the state is propagated, even if the bonds are broken during that time step,\nsince machines consult their neighbours' states as they were at the beginning of the\nstep). When the bonds have been dropped, it then sets folded, seed-gene, and\nreplicated flags to false and becomes a free machine.\nThe shatter mechanism is not a subtle way to handle errors, but we have found it to be\neffective. In our simulations, shattering is relatively rare. This error correction mechanism\nis similar to Sayama's method for handling errors in self-replicating loops [12], [13].\n3.5\n\nImplementation\n\nJohnnyVon 2.0 builds directly on the original JohnnyVon 1.0. Both systems are written in\nJava and their source code is available under the GNU General Public License (GPL) at\nhttp://purl.org/net/johnnyvon/.\n\n4 Experiments and Discussion\nIn our first experiment, we demonstrate the construction of a small mesh of triangles,\nhighlighting several important points in the replication and assembly. In the next set of\nexperiments, we demonstrate replication and assembly of meshes built from each of the\nsupported polygons, with one machine per side. We then show a mesh of polygons with\nmore than one machine per side, a 3\u00d71 rectangle and a triangle with three machines per\nside. Finally, to demonstrate scalability, we show a large mesh of triangles.\nIn the following figures, the inner grey square represents the container. The middle of a\nmachine must stay inside the grey square. (It takes less computation to check whether\nthe middles are within bounds than to check all of the arms.)\n4.1\n\nSelf-Replication and Self-Assembly\n\nIn Figure 5, the images show a typical run of JohnnyVon 2.0. The run starts with a soup\nof 54 free type-2 machines and a seed gene of the form 2-2-2, and it ends with a\ntriangular mesh.\nImage 1: This shows the initial configuration. Each of the free machines is in a random\nposition and the seed gene is in the center (it is the strand of three machines, forming a\nstraight line).\n\n19\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nImage 2: After 2,385 steps, the first replication is complete. We see two genes,\nimmediately after they have split and their repellor arms have pushed them apart.\nImage 3: The first child of the seed gene is folding up, to become the seed phene. The\nseed gene has already begun a second copy.\nImage 4: By time 44,235, nearly all of the free machines are now attached to genes.\nSince there are so few free machines left, most of these genes cannot complete selfreplication. As some of the incomplete strands' fold-counters hit their upper limit, they\nwill fold and release free machines, allowing other genes to complete self-replication.\nImage 5: We can see the second phene forming. In this image, it has not completely\nfolded; the triangle has a small gap at the top.\nImage 6: Slightly more than 3,000 timesteps later, the new phene has bonded with the\nseed phene.\nImage 7: Now many more triangles have folded and joined the mesh. Two triangles\nhave not yet joined (one is in the lower left corner and the other is near the center).\nImage 8: The mesh is almost complete. In the bottom on the right, there is a pentagonal\narrangement of five triangles. This would eventually be corrected (by one of the triangles\nreleasing and unfolding; see Section 3.4.4), although the container is just barely large\nenough to hold a mesh that includes all of the machines, and thus errors may continue\nto form even as they are corrected. In a situation where the container constrains the\nmesh, it is possible for a machine to get attached to a mesh in such a way that it can\nnever reach an equilibrium where all of its bonds are in tolerance, since the conditions\nfor accepting new bonds are much looser than the conditions for detecting stress.\nInsert Figure 5 here.\n\nIn this simulation, the container is relatively small, and therefore Brownian motion is\nrelatively strong. With strong Brownian motion, free machines are quickly distributed\nthroughout the container, thus a replicating strand has a steady supply of free machines.\nThe small container also means that the phenes never have far to go to join the mesh,\nand will quickly be bumped into the right position. In a larger container, replicating\nstrands will consume the machines in their local area, and then replication slows until\ndiffusion replenishes the supply. It also takes longer for phenes to find a place where\n\n20\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nthey can join the mesh. We could speed up the action in a larger container by increasing\nthe Brownian motion (i.e., turning up the heat), but that could damage the mesh.\n4.2\n\nSimple Polygonal Meshes\n\nIn Figure 6, we show assembled mesh structures. Four different regular polygonal\nmeshes are shown, all with sides that are one machine in length. Each of these four\nsimulations was started with a single seed strand and was executed until the mesh was\nwell developed. The scale of the images in Figure 6 is different from the scale of the\nimages in Figure 5. These simulations use a container about nine times larger in area\nthan the simulations in Figure 5. Table 9 summarizes the four simulations in Figure 6.\nInsert Figure 6 here.\n\nInsert Table 9 here.\n\n4.3\n\nFancy Meshes\n\nIn Figure 7, Image 1 (timestep 691,900) shows a mesh built of rectangles, rather than\nregular polygons. Because squares and rectangles use two types of machines (see\nSection 3.4.2), the rectangles only join the mesh if they are correctly oriented. The seed\nfor Image 1 was 2-4-2-1-2-4-2-1.\nImage 2 (timestep 78,800) shows large triangles. The seed was 2-1-2-2-1-2-2-1-2. The\nbonds between type-2 machines fold to form the corners, while the type-1 machines\nprovide the extension to make these triangles larger. In principle, each phene can be\nmade arbitrarily large using this approach.\nInsert Figure 7 here.\n\n4.4\n\nLarge Mesh\n\nThe image in Figure 8 demonstrates that meshes can grow correctly beyond a small\nnumber of triangles. The seed was 2-2-2. The mesh contains 234 triangles.\nInsert Figure 8 here.\n\n21\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n4.5\n\nDiscussion\n\nThe above experiments demonstrate that four types of machines are sufficient to enable\nthe user to program a variety of meshes. By specifying the seed gene, the user can\ncreate triangular, square, hexagonal, or octagonal meshes (Section 4.2). The\nexperiments in Section 4.3 show that the sizes of the holes in the mesh are infinitely\nadjustable (in principle; in practice, there will be computational limits). For rectangular\nmeshes, an infinite number of shapes are possible, by adjusting the ratios of the lengths\nof the sides (Section 4.3).\nTo program JohnnyVon to build a mesh, the most important information is in Table 6.\nLooking at this table, the user can easily predict the shape that will be produced by any\ngiven seed. For example, consider the seed 2-4-2-1-2-4-2-1. Take eight sticks of equal\nlength and put them on a flat surface. Reading the seed from left to right, let the first\nstick be \"2\". Place the second stick end-to-end with the first stick, and let it be \"4\".\nArrange the two sticks so that their angle is 90\u00b0, as gi ven in Table 6. Continue in this\nmanner until all eight sticks are arranged. The resulting shape will be a rectangle (see\nFigure 3).\nWhen programming a mesh, note that some seeds will not form a closed shape, which\nwill trigger the stress detection (Section 3.4.4). This may be viewed as a bug in the\nuser's program or as a limitation of JohnnyVon 2.0.\n\n5 Limitations and Future Work\nJohnnyVon 2.0 has several minor limitations. For example, phenes must be closed for\nthe system to work correctly. Although a hexagon composed of five machines and a gap\nin the sixth side can form a mesh, the error correction system would destroy the resulting\nmesh. Because closure of the phenes increases their rigidity, a mesh built of open\nphenes would be more flexible, and there may be other interesting effects.\nThe variety of phenes in JohnnyVon 2.0 is also somewhat limited. Our original goal, to\nsupport all regular polygons that tile the plane (triangles, squares and hexagons), is\nsatisfied. JohnnyVon 2.0 also supports partial tiling with octagons (square gaps are left\nin the mesh), and full tiling with rectangles. However, we would now like to support\nconcave shapes (e.g., stars), as well as more general polygons. It would be interesting\nto enable Penrose tilings and Kepler tilings [3].\n\n22\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nThe replication phase takes much longer with two (or more) types of machines than it\ndoes with one, since each free machine has fewer places to bond correctly (equivalently,\neach machine in the strand has fewer free machines available with which it can bond).\nSupplying two (or more) times as many machines increases the computation per\ntimestep (roughly quadratically). However, JohnnyVon 2.0 should be parallelizable. This\nis another area for future work.\nLike JohnnyVon 1.0, version 2.0 still runs on a standard desktop computer, thanks in\npart to improvements in hardware since the development of version 1.0. However, there\nwere many experiments we wanted to try (e.g., polygons with 4 or 5 machines per side)\nthat were not practical, given our available hardware and our patience. This problem can\nbe addressed by improving the efficiency of our implementation, converting the code to a\nmore efficient language than Java (which is likely to make it much less portable),\nparallelizing the code, or obtaining better hardware.\nThe computational complexity of the simulation increases with the size of the phenes,\nsince each phene must be jostled to a place near where it belongs, and larger phenes\nmove more slowly. Meshes of large phenes require many timesteps to be constructed.\nThe problem may be alleviated by increasing the Brownian motion or decreasing the\nviscosity of the simulated liquid, but each of these solutions presents new problems. We\nhave tuned the physical parameters, in an effort to balance these conflicting concerns.\nThe current settings of the physical parameters appear to strike a good balance, but\nthere is likely room for further improvements.\nJohnnyVon would benefit from increased realism and increased programmability.\nAlthough JohnnyVon 2.0 provides a moderate level of programmability, it is not as\nprogrammable as we would like. One problem is that the mesh grows without control.\nSometimes the mesh is relatively dense (as in Image 2 of Figure 6) while at other times\nit has many gaps (as in Figure 8). We would like to add a programmable mechanism for\ncontrolling the final size and shape of the mesh, and for avoiding meshes with large\ngaps (or for deliberately creating gaps, which may be useful for some applications).\nThe growth of a mesh from a seed phene may be viewed as a type of dendrite growth,\nsuch as is observed in Diffusion-Limited Aggregation (DLA) models (a class of fractal\ngrowth models) [22]. The literature on fractal growth models may suggest some useful\nmethods for preventing dendrite growth and encouraging the formation of a filled mesh\n[20]. It may be possible to modify JohnnyVon so that the user can specify the desired\n23\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nfractal dimension of the mesh. A filled mesh (in the current two-dimensional simulation)\nwould have a fractal dimension of 2, and a dendritic mesh would have a fractal\ndimension somewhere between 1 and 2.\nIn the context of JohnnyVon's virtual physics, it may be meaningful to define a universal\nconstructor (see Section 2.1). For example, we might say that a universal constructor\nwould be capable of building any two-dimensional structure that can be constructed from\na finite number of machines, such that up arms are bonded to up arms and left arms are\nbonded to right arms. The design for the structure should be encoded in a seed gene.\nIdeally, the seed would contain many fewer machines than the final structure, although\nthis may not be possible when the final structure lacks a regular pattern. Much further\nwork is required to make a universal constructor in the JohnnyVon model.\nJohnnyVon 2.0 also provides a moderate level of realism, but again it is not as realistic\nas we would like. Our attractive and repulsive forces are somewhat unlike electrical or\nmagnetic attraction and repulsion. The JohnnyVon simulation also does not attempt to\nmodel conservation of energy. Arbesman has recently done some interesting work on\ncomputational simulation of artificial life with conservation of energy [1].\nOther steps towards increased realism would be to extend the simulation to three\ndimensions and to model the physics of the internal operations of the machines.\nCurrently the external relations between machines are governed by a simple virtual\nphysics, but the internal operations are described by abstract finite automata. However,\nboth of these steps to realism would involve a significant increase in computational\ncomplexity.\n\n6 Applications\nIn our previous work, we suggested that JohnnyVon 1.0 provided a plausible mechanism\nfor nanoscale manufacturing [17]. A vat of liquid containing free machines would be\nseeded with a single strand, soon resulting in a vat full of copies of the seed strand.\nJohnnyVon 2.0 takes this application one step further, beyond self-replication to\nprogrammable construction of meshes. Since the user has some control over the size\nand shape of the holes in the mesh, we can imagine these meshes being produced for\nfiltration, insulation, or simply as a kind of cloth.\n\n24\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nIf we can create a mechanism for controlling the size and shape of the mesh, more\napplications become possible. Since the system is accurate and self-correcting, pieces\nof cloth could be created exactly to specification, down to the size of a single machine.\nThe design of the individual machines in JohnnyVon is too complex to be implemented\nat the nanoscale, given the current state of the art of nanotechnology. However, the\nmachines appear to be less complex than typical virsuses, which range in size from\nabout 20 to 250 nanometers. Nanoscale is generally defined as about 1 to 100\nnanometers. As mentioned earlier, JohnnyVon 2.0 was partly inspired by Seeman's work\nwith DNA [14], [15]. A single DNA molecule is about 2 nanometers wide. JohnnyVon's\ndesign is somewhat different from Seeman's work, so it would not be accurate to\ndescribe his work as an implementation of JohnnyVon, but it does seem reasonable to\nsay that JohnnyVon could be implemented at the nanoscale, given improvements in the\nstate of the art.\nOn the other hand, it would not be difficult to implement JohnnyVon at the human scale,\nwith current technology, using small robots (such as the Khepera robot) to implement the\nfour types of machines.4 This might be useful for research purposes, to test designs at a\nlevel between software simulation and nanoscale hardware.\n\n7 Conclusion\nJohnnyVon 1.0 demonstrated self-replication in a continuous two-dimensional space\nwith virtual physics. JohnnyVon 2.0 goes beyond its predecessor by introducing a userprogrammable phenotype, consisting of a variety of meshes. JohnnyVon 2.0 is more\nrealistic than cellular automata models [6], [10], [11], [12], [13], [18], [19], more\nprogrammable than artificial chemistry models [4], [5], and more computationally\ntractable than von Neumann's universal constructor [21]. However, there is still much\nroom for improvement in the degree of physical realism of the simulation and in the\ndegree of programmability of the phenotype.\nLike its predecessor, JohnnyVon 2.0 is a local model. There is no global data structure\nthat represents strands or meshes; these are emergent entities that arise from the\ninteractions of the basic elements (the machines). Each machine is autonomous and can\nonly sense its immediate neighbours. Control is local, distributed, and parallel.\n\n4\n\nhttp://www.k-team.com/robots/khepera/khepera.html\n\n25\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFrom four different types of machines, JohnnyVon can produce four different polygonal\nmeshes, with an infinite number of possible sizes (as per Section 4.3). The user can\nspecify the mesh that will be produced by encoding the desired size and shape in the\ninitial seed, without making any changes to the physics of the simulation. Errors in\nreplication and in mesh formation are automatically detected and corrected, using purely\nlocal mechanisms.\nJohnnyVon 2.0 also avoids the \"grey goo\" scenario of self-replicating nanobots run\namok. Replication and assembly are inherently limited by the supply of machines; when\nthe free machines have all bonded, the process stops.\n\nAcknowledgements\nThanks to Arnold Smith for starting us down this path, with JohnnyVon 1.0. Thanks to\nthe anonymous reviewers of Artificial Life for their helpful comments.\n\nReferences\n[1] Arbesman, S. (2004). Erg: A Computational Energetics as an Approach to the Study\nof the Origins of Life. Senior Thesis, Computer Science Department, Brandeis\nUniversity.\n[2] Drexler, K.E. (1992). Nanosystems: Molecular Machinery, Manufacturing, and\nComputation. New York: Wiley.\n[3] Grunbaum, B., and Shephard, G.C. (1986). Tilings and Patterns. W.H. Freeman.\n[4] Hutton, T.J. (2002). Evolvable self-replicating molecules in an artificial chemistry.\nArtificial Life, 8, 341-356.\n[5] Hutton, T.J. (2004). A functional self-reproducing cell in a two-dimensional artificial\nchemistry. In J. Pollack et al., eds., Proceedings of the Ninth International\nConference on the Simulation and Synthesis of Living Systems (ALIFE9), 444-449.\n[6] Langton, C.G. (1984). Self-reproduction in cellular automata. Physica D, 10, 134144.\n[7] Maynard Smith, J., and Szathmary, E. (1995). The Major Transitions in Evolution.\nOxford University Press.\n\n26\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n[8] Merkle, R.C. (1992). Self replicating systems and molecular manufacturing. Journal\nof the British Interplanetary Society, 45, 407-413.\n[9] Merkle, R.C. (1994). Self replicating systems and low cost manufacturing. In The\nUltimate Limits of Fabrication and Measurement, M.E. Welland, J.K. Gimzewski,\neds., Dordrecht: Kluwer, pp. 25-32.\n[10] Morita, K., and Imai, K. (1997). A simple self-reproducing cellular automaton with\nshape-encoding mechanism. In C.G. Langton and K. Shimohara, eds., Artificial Life\nV: Proceedings of the Fifth International Workshop on the Synthesis and Simulation\nof Living Systems, 489-496. Cambridge, MA: MIT Press.\n[11] Reggia, J.A., Lohn, J.D., and Chou, H.-H. (1998). Self-replicating structures:\nEvolution, emergence and computation. Artificial Life, 4, 283-302.\n[12] Sayama, H. (1998). Introduction of structural dissolution into Langton's selfreproducing loop. In C. Adami, R.K. Belew, H. Kitano, and C.E. Taylor, eds.,\nArtificial Life VI: Proceedings of the Sixth International Conference on Artificial Life,\n114-122. Los Angeles, CA: MIT Press.\n[13] Sayama, H. (1999). A new structurally dissolvable self-reproducing loop evolving in\na simple cellular automata space. Artificial Life, 5, 343-365.\n[14] Seeman, N.C. (2003). DNA in a material world. Nature, 421 (January 23), 427-431.\n[15] Seeman, N.C. (2004). Nanotechnology and the double helix. Scientific American,\n290 (6) (June), 65-75.\n[16] Sipper, M. (1998). Fifty years of research on self-replication: An overview. Artificial\nLife, 4 (3), 237-257.\n[17] Smith, A., Turney, P., and Ewaschuk, R. (2003). Self-replicating machines in\ncontinuous space with virtual physics. Artificial Life, 9, 21-40.\n[18] Tempesti, G. (1995). A new self-reproducing cellular automaton capable of\nconstruction and computation. In F. Moran, A. Moreno, J.J. Morelo, and P. Chacon,\neds., Advances in Artificial Life: Proceedings of the Third European Conference on\nArtificial Life (ECAL95), 555-563. Berlin: Springer-Verlag.\n[19] Tempesti, G., Mange, D., and Stauffer, A. (1998). Self-replicating and self-repairing\nmulticellular automata. Artificial Life, 4, 259-282.\n\n27\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n[20] Vicsek, T. (1992). Fractal Growth Phenomena. Second Edition. Singapore: World\nScientific.\n[21] von Neumann, J. (1966). Theory of Self-Reproducing Automata. Edited and\ncompleted by A.W. Burks. Urbana, IL: University of Illinois Press.\n[22] Witten, T.A., and Sander, L.M. (1981). Diffusion-limited aggregation, a kinetic critical\nphenomenon, Physical Review Letters, 47, (Issue 19-9), 1400-1403.\n\n28\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 1. Variables for elements of the state vector that represent internal aspects of the machine.\nVariable name\ntype\n\nRange\n{1, 2, 3, 4}\n\nid\n\n{0, 1, 2, ...}\n\nfold-counter\nrepel-counter\n\n{0, 1, 2, ...}\n{0, 1, 2, ...}\n\nstress-counter\nstrand-position\n\n{0, 1, 2, ...}\n{1, 2, 3}\n\nsplit-state\n\n{1, 2, 3, 4}\n\nreset-counter\nfold-now\n\n{0, 1}\n{0, 1}\n\nunfold\n\n{0, 1}\n\nseed-gene\n\n{0, 1}\n\nseed-phene\nin-mesh\nreplicated\n\n{0, 1}\n{0, 1}\n{0, 1}\n\nshatter\n\n{0, 1}\n\nfolded\n\n{0, 1}\n\nDescription\n\u2022 type of machine\n\u2022 static for a given machine\n\u2022 unique identifier for machine\n\u2022 static for a given machine\n\u2022 used to decide when the strand should fold\n\u2022 during splitting, controls how long the repellor arms of a\nstrand are active\n\u2022 counts the time since a machine was last in-tolerance\n\u2022 used to decide where a machine is in a replicating strand\n\u2022 described in detail elsewhere [17]\n\u2022 used to determine when to split\n\u2022 described in detail elsewhere [17], except that split-state\nnow has a fourth value, indicating that shatter should be\nset to 1 (true)\n\u2022 indicates that the fold-counter should be reset\n\u2022 indicates that each machine in the strand should set its\nfolded flag\n\u2022 indicates that a phene should unfold\n\u2022 this occurs when one phene overlaps another in a mesh\n\u2022 flag for identifying the seed gene\n\u2022 the seed gene never folds, in case more free machines\nbecome available for replication\n\u2022 flag for making the seed phene\n\u2022 indicates whether this machine is connected to the mesh\n\u2022 1 (true) if and only if the machine has been through a\nsuccessful replication.\n\u2022 in particular, machines in the seed gene have not\nreplicated at the start of a simulation\n\u2022 indicates that the machine should break all bonds and\nreturn to being a free machine.\n\u2022 if 1, the machine tries to form angular bonds with its left\nand right neighbours\n\u2022 if 0, the machine tries to form straight bonds with its left\nand right neighbours\n\n29\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 2. Variables for elements of the state vector that represent external relations.\nVariable name\nx-position\ny-position\nangle\nx-velocity\ny-velocity\nangular-velocity\nleft-neighbour\nright-neighbour\nup-neighbour\n\nRange\nR\nR\n[0, 2\u03c0]\nR\nR\n[0, 2\u03c0]\n{0, 1, 2, ...}\n{0, 1, 2, ...}\n{0, 1, 2, ...}\n\nDescription\n\u2022 state of the machine with respect to the container\n\u2022 vary due to Brownian motion, viscosity, and forces from\ninteractions between fields\n\n\u2022 identifier of the machine (if any) bonded to the named\narm\n\n30\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 3. Derived variables that are calculated from state variables.\nVariable name\nin-tolerance\n\nRange\n{0, 1}\n\nbend-location\n\n{1, 2, 3, 4}\n\nDescription\n\u2022 indicates whether each existing bond is within a certain\n(fixed) tolerance of the desired angle\n\u2022 used to help avoid making bonds when the machine is in\na potentially unstable situation.\n\u2022 indicates where a machine is located in a phene\n\n31\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 4. Pairs of machine types that will permit an up bond when in genes.\nBond\n1\n2\n3\n4\n\n1\n+\n\n2\n\n3\n\n4\n\n+\n+\n+\n\n32\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 5. Pairs of machine types that will permit an up bond when in phenes.\nBond\n1\n2\n3\n4\n\n1\n\n2\n\n3\n\n4\n\n+\n\n+\n+\n\n+\n\n33\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 6. Folding angles for sideways bonds between two machine types when in phenes.\nAngle\n1\n2\n3\n4\n\n1\n0\u00b0\n0\u00b0\n0\u00b0\n0\u00b0\n\n2\n0\u00b0\n120\u00b0\n45\u00b0\n90\u00b0\n\n34\n\n3\n0\u00b0\n45\u00b0\n\n4\n0\u00b0\n90\u00b0\n60\u00b0\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 7. The meaning of the different values of bend-location.\nValue\n1\n2\n3\n4\n\nMeaning of value\nright of bend: right neighbour is straight (1) and left neighbour is bending (2, 3, 4)\nleft of bend: left neighbour is straight (1) and right neighbour is bending (2, 3, 4)\nin bend: both left and right neighbours are bending types (2, 3, 4)\nextender: both left and right neighbours are straight types (1)\n\n35\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 8. Pairs of bend-location values that will permit an up bond when in phenes.\nbend-location\n1\n2\n3\n4\n\n1\n\n2\n+\n\n3\n\n+\n+\n\n36\n\n4\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nTable 9. Some basic observations about each image in Figure 6.\nImage\n1\n2\n3\n4\n\nPhenes\nTriangles\nSquares\nHexagons\nOctagons\n\nSeed gene\n\nTimestep\n\n2-2-2\n4-2-4-2\n4-4-4-4-4-4\n2-3-2-3-2-3-2-3\n\n246,000\n498,600\n448,600\n1,107,400\n\n37\n\nInitial free\nmachines\n201\n200\n160\n120\n\nPhenes in\nmesh\n50\n24\n20\n9\n\nGenes\nremaining\n5\n1\n1\n2\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFigure 1. This diagram shows how fold-counter resets when a new machine joins a partially\nreplicated gene. A free machine attaches to a machine in the strand (A), triggering the resetcounter signal and resetting fold-counter in the machine to which it attaches (B). The signal\npropagates (C) to the left neighbour (D), triggering its reset-counter signal and causing it to reset\nits fold-counter. In turn, the signal passes (E) to the next machine in the strand (F). The\npropagation stops at the leftmost machine (F).\n\n38\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFigure 2. This diagram demonstrates the mechanism used to expand the size of a polygon.\nMachines of type 1 are inserted along the edges.\n\n39\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFigure 3. In this diagram, we can see why it is useful to have two types of machines for\nrectangles (types 2 and 4), in addition to type 1, for expanding size. The top phene is oriented\nincorrectly, relative to the mesh formed by the bottom two phenes. However, the top phene will\nnot join at (A) or (B), because the types do not match (see Table 5). It will only join the mesh\nwhen it is oriented correctly.\n\n40\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFigure 4. In this diagram, two phenes join a mesh, both trying to fill the same gap. Phene 1 has\njoined at (A) and (C). Phene 2 has joined at (B). Because these two phenes both have their inmesh flags set to 1 (true), their overlap detector arms become active, and the two machines at\n(D) briefly bond their overlap detector arms. The machines then decide arbitrarily which one will\nset its unfold flag to true, causing the phene to which it belongs to unfold. The remaining phene\nwill then pick up the bonds that were released by the unfolded phene.\n\n41\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nImage:\n1\n\nImage:\n2\n\nTime:\n0\n\nTime:\n2,385\n\nImage:\n3\n\nImage:\n4\n\nTime:\n3,295\n\nTime:\n44,235\n\nImage:\n5\n\nImage:\n6\n\nTime:\n46,340\n\nTime:\n49,780\n\nImage:\n7\n\nImage:\n8\n\nTime:\n85,810\n\nTime:\n294,075\n\nFigure 5. These images illustrate the experiment described in Section 4.1. The eight images are\nconsecutive screenshots from a typical run of JohnnyVon, selected to show interesting stages in\nthe simulation. The first image shows a seed gene in a soup of free machines and the last image\npresents a nearly completed mesh of triangles.\n\n42\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n1\n\n2\n\n3\n\n4\n\nFigure 6. These screenshots illustrate the resulting meshes for each of the four supported regular\npolygons. The images show the final stages of four separate simulations, each using a different\nseed gene, as described in Section 4.2 and Table 9.\n\n43\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\n1\n\n2\n\nFigure 7. Image 1 shows a rectangular mesh and Image 2 is a mesh of expanded triangles.\nThese are screenshots from the final stages of two separate simulations (see Section 4.3). They\ndemonstrate that it is possible to vary the lengths of the sides of the polygons, by encoding the\ndesired lengths in the seed gene.\n\n44\n\n\fSelf-Replication and Self-Assembly for Manufacturing\n\nFigure 8. This screenshot shows a mesh of 234 triangles, as discussed in Section 4.4. This\ndemonstrates that JohnnyVon can scale up to larger meshes.\n\n45\n\n\f"}