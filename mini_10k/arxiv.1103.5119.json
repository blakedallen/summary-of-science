{"id": "http://arxiv.org/abs/1103.5119v1", "guidislink": true, "updated": "2011-03-26T10:12:40Z", "updated_parsed": [2011, 3, 26, 10, 12, 40, 5, 85, 0], "published": "2011-03-26T10:12:40Z", "published_parsed": [2011, 3, 26, 10, 12, 40, 5, 85, 0], "title": "A protocol for a message system for the tiles of the heptagrid, in the\n  hyperbolic plane", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1103.0389%2C1103.1936%2C1103.1486%2C1103.5927%2C1103.3719%2C1103.0419%2C1103.2132%2C1103.2073%2C1103.5383%2C1103.3318%2C1103.0977%2C1103.1813%2C1103.1288%2C1103.4370%2C1103.1698%2C1103.1544%2C1103.5274%2C1103.0039%2C1103.2957%2C1103.3940%2C1103.2287%2C1103.2243%2C1103.2862%2C1103.1593%2C1103.1642%2C1103.5652%2C1103.4108%2C1103.3712%2C1103.2136%2C1103.2388%2C1103.3150%2C1103.4218%2C1103.5876%2C1103.3069%2C1103.1367%2C1103.3860%2C1103.5095%2C1103.5156%2C1103.5660%2C1103.4274%2C1103.2560%2C1103.1670%2C1103.3600%2C1103.0145%2C1103.5408%2C1103.0393%2C1103.4507%2C1103.3157%2C1103.2604%2C1103.4557%2C1103.5426%2C1103.1193%2C1103.3685%2C1103.5119%2C1103.1682%2C1103.0088%2C1103.0751%2C1103.1740%2C1103.4119%2C1103.4934%2C1103.0187%2C1103.0297%2C1103.5192%2C1103.5182%2C1103.4303%2C1103.3662%2C1103.3071%2C1103.2153%2C1103.5844%2C1103.2359%2C1103.4964%2C1103.2710%2C1103.2276%2C1103.3454%2C1103.0087%2C1103.5813%2C1103.2985%2C1103.5076%2C1103.0468%2C1103.4083%2C1103.0794%2C1103.1812%2C1103.1196%2C1103.4537%2C1103.5367%2C1103.2496%2C1103.4316%2C1103.2226%2C1103.0830%2C1103.6073%2C1103.0299%2C1103.5573%2C1103.3560%2C1103.0874%2C1103.0764%2C1103.1380%2C1103.6220%2C1103.5776%2C1103.4327%2C1103.6151%2C1103.0106&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A protocol for a message system for the tiles of the heptagrid, in the\n  hyperbolic plane"}, "summary": "This paper introduces a communication system for the tiles of the heptagrid,\na tiling of the hyperbolic plane. The method can be extended to other tilings\nof this plane. The paper focuses on an actual implementation at the programming\nstage with a short account of two experiments.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1103.0389%2C1103.1936%2C1103.1486%2C1103.5927%2C1103.3719%2C1103.0419%2C1103.2132%2C1103.2073%2C1103.5383%2C1103.3318%2C1103.0977%2C1103.1813%2C1103.1288%2C1103.4370%2C1103.1698%2C1103.1544%2C1103.5274%2C1103.0039%2C1103.2957%2C1103.3940%2C1103.2287%2C1103.2243%2C1103.2862%2C1103.1593%2C1103.1642%2C1103.5652%2C1103.4108%2C1103.3712%2C1103.2136%2C1103.2388%2C1103.3150%2C1103.4218%2C1103.5876%2C1103.3069%2C1103.1367%2C1103.3860%2C1103.5095%2C1103.5156%2C1103.5660%2C1103.4274%2C1103.2560%2C1103.1670%2C1103.3600%2C1103.0145%2C1103.5408%2C1103.0393%2C1103.4507%2C1103.3157%2C1103.2604%2C1103.4557%2C1103.5426%2C1103.1193%2C1103.3685%2C1103.5119%2C1103.1682%2C1103.0088%2C1103.0751%2C1103.1740%2C1103.4119%2C1103.4934%2C1103.0187%2C1103.0297%2C1103.5192%2C1103.5182%2C1103.4303%2C1103.3662%2C1103.3071%2C1103.2153%2C1103.5844%2C1103.2359%2C1103.4964%2C1103.2710%2C1103.2276%2C1103.3454%2C1103.0087%2C1103.5813%2C1103.2985%2C1103.5076%2C1103.0468%2C1103.4083%2C1103.0794%2C1103.1812%2C1103.1196%2C1103.4537%2C1103.5367%2C1103.2496%2C1103.4316%2C1103.2226%2C1103.0830%2C1103.6073%2C1103.0299%2C1103.5573%2C1103.3560%2C1103.0874%2C1103.0764%2C1103.1380%2C1103.6220%2C1103.5776%2C1103.4327%2C1103.6151%2C1103.0106&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "This paper introduces a communication system for the tiles of the heptagrid,\na tiling of the hyperbolic plane. The method can be extended to other tilings\nof this plane. The paper focuses on an actual implementation at the programming\nstage with a short account of two experiments."}, "authors": ["Maurice Margenstern"], "author_detail": {"name": "Maurice Margenstern"}, "author": "Maurice Margenstern", "arxiv_comment": "30 pages, 5 figures", "links": [{"href": "http://arxiv.org/abs/1103.5119v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1103.5119v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "68M12, 68M10", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "C.2.2; C.2.1; F.2.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1103.5119v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1103.5119v1", "journal_reference": null, "doi": null, "fulltext": "A protocol for a message system for the tiles of\nthe heptagrid, in the hyperbolic plane\n\narXiv:1103.5119v1 [cs.DM] 26 Mar 2011\n\nMaurice Margenstern\nprofessor emeritus of Universit\u00e9 Paul Verlaine \u2212 Metz\nLITA, EA 3097, UFR-MIM, and CNRS, LORIA\nCampus du Saulcy, 57045 Metz, C\u00e9dex, France\ne-mail: margens@univ-metz.fr\nAbstract. This paper introduces a communication system for the tiles\nof the heptagrid, a tiling of the hyperbolic plane. The method can be\nextended to other tilings of this plane. The paper focuses on an actual\nimplementation at the programming stage with a short account of two\nexperiments.\n\nKeywords: hyperbolic tilings, cellular automata, applications.\n\n1\n\nIntroduction\n\nIn this paper, we present a protocol to manage communications between tiles of a\ntiling of the hyperbolic plane. Why the hyperbolic plane? Because the geometry\nof this space allows to implement there any tree structure. The reason for that is\nthat the simplest tilings defined in this plane are spanned by a tree. We refer to\nthe author's papers and books on this topic, see [5,6]. Tree structures are already\nintensively used in computer science, especially by operating systems. But the\nfact that trees are naturally embedded in this geometrical space, especially on\ntilings living there, was never used. This paper proposes to take advantage of\nthis property.\nIn Section 2, we remind what is needed of hyperbolic geometry in order the\nreader could understand the content of the paper.\nIn Section 2, we remind what is needed of hyperbolic geometry in order\nthe reader could understand the content of the paper. In Section 3, we sketchily\ndescribe the navigation technique with a new aspect which was not used in [7]. In\nSection 4, we present the protocol which allows us to improve the system briefly\nmentioned in [7]. In Section 5, we give an account of the simulation program\nand in Section 6 we present the experiment which was performed by running the\nsimulation program. In Section 7, we conclude with further possible development\nof the scenario implemented by the protocol.\n\n\f2\n\nHyperbolic geometry and its tilings\n\nOur first sub-section reminds the Poincar\u00e9's disc model which allows us to\nhave a partial visualization of the hyperbolic plane. Our second sub-section defines the simplest tilings which can there be defined, allowing us to construct\ngrids. In our third sub-section, we focus on the tiling on which our proposal is\nbased, the tiling {7, 3} of the hyperbolic plane which we call the heptagrid.\n2.1\n\nHyperbolic geometry\n\nHyperbolic geometry appeared in the first half of the 19th century, proving the\nindependence of the parallel axiom of Euclidean geometry. This was the end\nof a search during two thousand years in order to prove that the well known\naxiom about parallels in Euclid's treatise is a consequent of his other axioms.\nThe search is by itself a very interesting story, full of deep teachings of high\nprice for the philosophy of sciences, we recommend the interested reader to have\na look at [1]. Hyperbolic geometry was the first issue of the notion of axiomatic\nindependence. But also, it raised the first doubts on the absolute power of our\nabstract mind. It opened the way to the foundational works of mathematical\nlogics, so that computer science, the daughter of logics, appears to be a grandchild of hyperbolic geometry. The paper hopes to show that this kind of relations\nholds not only on a philosophical ground.\nThe search failed. This was proved in the second third of the 19th century by\nthe discovery of hyperbolic geometry. In this new geometry, all the non-parallel\naxioms of Euclidean old and, from a point A out of a line l and in the plane\ndefined by l and A there are two parallels to l passing through A. Around forty\nyears after the discovery, models of the new geometry in the Euclidean one were\nfound. Presently, we turn to the most popular model of the hyperbolic plane\nnowadays, Poincar\u00e9's model.\n\n2.2\n\nThe Poincar\u00e9's disc model\n\nThis model is represented by Figure 1. In the model, the points of the hyperbolic plane are represented by the points of an open disc fixed in advance called\nthe unit disc. The circle which is the boundary of the disc is called the set of\npoints at infinity and we denote it by \u2202U . These points do not belong to the\nhyperbolic plane, but they play an important role in this geometry. The lines of\nthe hyperbolic plane are represented by the trace in the disc of its diameters or\nby the trace in the disc of circles which are orthogonal to \u2202U . It is not difficult to\nsee that the lines are also characterized in the models by their points at infinity\nas diameters of the disc and circles orthogonal to \u2202U meet \u2202U twice exactly.\n\n\fn\n\nM\n\nq\ns\np\nm\nQ\nP\n\nFigure 1: Poincar\u00e9's disc model. We can see that in the model, both lines p and q\npass through A and that they are parallel to l: p and q touch m in the model at P\nand Q, points at infinity.\nThe figure also shows us an important feature of the new plane: outside\nparallel and secant lines to a given line l, passing through a point A not on l,\nthere are also lines passing through A which do not cut l, neither inside the disc,\nnor on \u2202U and nor outside the disc: they are called non-secant lines. A last\nbut not least property of the new plane is that there are no similarity: a figure\nof this plane cannot be re sized at another scale. Resizing necessarily changes\nthe shape of the figure.\n2.3\n\nThe tilings {p, q} of the hyperbolic plane\n\nConsider the following process. We start from a convex regular polygon P . We\nreplicate P in its sides and, recursively, the images in their sides. If we cover the\nplane without overlapping, then we say that P tiles the plane by tessellation.\nWe shall often say for short that P tiles the plane, here, the hyperbolic plane.\nA theorem proved by Poincar\u00e9 in 1882 tells us that if P has p sides and if its\n2\u03c0\ninterior angle is\n, then P tiles the hyperbolic plane, provided that:\nq\n1\n1 1\n+ < .\np q\n2\n\n(1)\n\nThe numbers p and q characterize the tiling which is denoted {p, q} and the\ncondition says that the considered polygons live in the hyperbolic plane. This\ninequality entails that there are infinitely many tessellations of the hyperbolic\nplane. The tessellation attached to p and q satisfying the inequality is denoted\nby {p, q}.\nNote that we find the well known Euclidean tessellations if we replace < by =\nin the above expression. We get, in this way, {4, 4} for the square, {3, 6} for the\nequilateral triangle and {6, 3} for the regular hexagon.\n\n\fIn [5,6], the author provides the reader with a uniform treatment of these\ntessellations. The basic feature is that each tessellations is spanned by a tree\nwhose structure obeys well defined properties. We shall illustrate these points in\nour next sub-section where we focus on a particular tessellation: the tiling {7, 3}\nof the hyperbolic plane which we call the heptagrid.\n2.4\n\nThe heptagrid\n\nThe heptagrid is illustrated by Figure 2. The figure is very symmetric, but at\nthis stage, it is difficult to identify each tile of the figure, especially for the tiles\nwhich are outside the first two rings around the central cell.\nThe tiles look very much the hexagonal tiles of the corresponding tessellation\nof the Euclidean plane,but the global organization is very different. It seems to\nus that this figure indicates that we need something to locate the tiles. We turn\nto this point in Section 3\n\nFigure 2 The heptagrid: an illustrative representation.\n\n3\n\nNavigation in the heptagrid\n\nWe have seen on the heptagrid that it is not easy to locate the tiles of this tiling,\nespecially as we go further and further from the centre of the disc.\nThis is the point to draw the attention of the reader on two points. The disc\nmodel may be misleading if we forget that we are in the Euclidean plane and\nthat some symmetries of the figure have no counter part in hyperbolic geometry.\nAs an example, the central tile seems to play an important role, in particular\nits centre. However, the hyperbolic plane has no central point as well as the\nEuclidean plane has no such point. We decide to fix an origin when we define\ncoordinates in the Euclidean plane. This is the same here. The central tile is\nsimply a tile which we decide to be the origin of our coordinate system. The\n\n\fsecond point is that Poincar\u00e9's disc model gives us a local picture only. We\nsee the immediate neighbourhood of a point which we decided to place at the\ncentre of the disc. The models looks like a small window on the hyperbolic plane\nwhose central part only is well observable. From this lens effect, we conclude\nthat walking on the hyperbolic plane, we are in the situation of the pilot of a\nplane flying with instruments only.\nAnd so, what are our instruments?\nThe first two pictures of Figure 3 represent them. On the left-hand side of\nthe figure, we can seen the mid-point lines defined by the following property:\nthe line which joins the mid-points of two consecutive sides of a heptagon cuts\na heptagon of the tiling at the mid-point of a side only. If we consider two rays\nissued from the meeting point of two secant mid-point lines and defined by the\nsmallest angle, we can define a set of tiles for which all vertices but possibly\none or two lie inside this angle. We call this the restriction of the tiling to a\nsector. The remarkable property is that the restriction of the tiling to a sector\nis spanned by a tree, the tree which is illustrated by the right-hand side of the\nfigure. In the middle of the figure, we can see that the whole tiling can exactly\nbe split into a central cell and seven sectors dispatched around the central tile.\n\nFigure 3 Left-hand side: the mid-point lines. This tool which shows how a sector\nspanned by the tree is defined in the heptagrid.\nMiddle: first part of the splitting, around a central tile, fixed in advance, seven\nsectors. Each of them is spanned by the tree represented in the right-hand side.\nRight-hand side: the tree which spans the tiling.\nThe tree which spans the tiling can be generated by very simple rules indicating the exact connection between a node and its sons. There are two kind of\nnodes, the black and the white ones. The rules are, in self-explaining notations:\nB \u2192 BW ,\n\nW \u2192 BW W\n\n(2)\n\nFrom these rules, it can be proved that the number of nodes which are on the\nlevel n of the tree is f2n+1 where {fn }n\u2208IN is the Fibonacci sequence defined by\nf0 = f1 = 1 and the induction equation fn+2 = fn+1 + fn . For this reason, the\ntree is called the Fibonacci tree.\n\n\fIt is known that natural numbers can be represented as sums of distinct\nk\nX\nai fi , with ai \u2208 {0, 1}, ak =\n6 0 if\nterms of the Fibonacci sequence: n =\ni=0\n\nn 6= 0. This representation is not unique, but it can be made unique by requiring\nk to be maximal in the above representation. This is the greedy Fibonacci\nrepresentation of n. It is characterized by the fact that considering the ai 's in\ntheir order as a word on {0, 1}\u2217, there are no contiguous 1's in the word.\nPresently, number the nodes of the tree level by level and, on each level, from\nthe left to the right, starting from the root which receives 1 as its number. Next,\ncall coordinate of a node \u03bd the greedy Fibonacci representation of its number.\nThen the coordinates of the nodes of the tree have this striking property. If [\u03bd] is\nthe coordinate of \u03bd, among the sons of \u03bd there is a single node whose coordinate\nis [\u03bd]00, which is called the preferred son. Also, we can rewrite (2) as (3)\nB \u2192 BW ,\n\nW \u2192 BW W\n\n(3)\n\nwhere the bar indicates the position of the preferred son.\nA path between a tile A and a tile B is a sequence {Ti }i\u2208[0..n] with T0 = A,\nTn = B and, for each i \u2208 [1..n], Ti\u22121 and Ti have a common side. We say that\nn is the length of the path and we note that from this definition, the path is\noriented: its source is the tile T0 and its target is the tile Tn . We also say that\nthe path goes from A to B. Clearly, a path from B to A is obtained by reversing\nthe numbering of the Ti 's defining the path from A to B.\nFor complexity reasons, it is convenient to take a shortest path between A\nand B: it is a path between A and B whose length is minimal. Note that in\ngeneral there is no unique shortest path but, by the very definition, such a path\nexists. An important particular case is when both tiles are on the same branch\nof a tree: this part of the branch is a shortest path between the tiles.\nFrom the properties of the preferred son, we obtain:\nTheorem 1 (see[3,5]) There is an algorithm which computes the path from a\nnode of the Fibonacci tree to the root from the coordinate of the node which is\nlinear in the size of the coordinate.\nFrom this algorithm, it is easy to compute a path between two nodes which\nis most often almost a shortest path between the nodes: first, go from the nodes\nto the root and connect the two paths at the root. Moreover, the computation\nis linear in the size of the two coordinates. However, in certain situations, this is\nnot the shortest way. Now, in [6], we proved a refinement of Theorem 1. In order\nto state it properly, we have to define coordinates for the tiles of the heptagrid.\nTo do this, we look at the middle picture of Figure 3. We increasingly number\nthe sectors from 1 up to 7 by counter-clockwise turning around the central cell,\nfixing the sector which receives number 1 once and for all. Now, the coordinate\nof a tile is defined by 0 for the central tile and, for any other tile T , by the\ncouple (\u03c3, \u03bd) where \u03c3 \u2208 {1..7} defines the sector which contains the tile and\nwhere \u03bd is the coordinate of T in the tree which spans the sector.\nNow, we can state the result:\n\n\fTheorem 2 (see[6]) There is an algorithm which computes a shortest path between two tiles of the heptagrid which is linear in the size of the coordinates of\nthe tiles.\nAnother consequence of Theorem 1 is the computation of the coordinates of\nthe neighbours of a tile, where a neighbour of the tile T is a tile N which shares\na side with T . Clearly, T is also a neighbour of T and we shall often say that N\nand T are neighbours.\nThe computation of the coordinates of the neighbours relies on two functions\nof n, the number of a tile: f (n) which is the number of the father of the tile\nand \u03c3(n) which is the number of the preferred son of the tile. According to the\nprevious notations, it is also interesting to consider the function [f ] such that\n[f ]([n]) = [f (n)] and the function [\u03c3] such that [\u03c3]([n]) = [\u03c3(n)]. From the proof\nof Theorem 1, there is an algorithm which allows to compute [f ] and [\u03c3] which\nis linear in the size of [n]. However, note that in the computation of the path\nthe application of the algorithm at one step is in fact a constant. With the help\nof this function, the coordinates of the neighbours of a tile are given by Tables 1\nand 2. In the table, the neighbours of a tile T are increasingly numbered from 1\nto 7 while counter-clockwise turning around T . Neighbour 1 is the father of T .\nThe father of a root is the central tile. For the central tile, the neighbour i is\nthe tile associated to the root of the tree in the sector i. If i is the number of\na neighbour of T , we say that the side shared by T and this neighbour is also\nnumbered by i.\nTable 1: The numbers of the neighbours for a tile \u03bd which is inside the tree. The tile\nmay be black or white.\n\n\u03c4\n\nblack\n\nwhite\n\n1\n2\n3\n4\n5\n6\n7\n\nf (\u03bd)\nf (\u03bd)\u22121\n\u03bd\u22121\n\u03c3(\u03bd)\n\u03c3(\u03bd)+1\n\u03c3(\u03bd)+2\n\u03bd+1\n\nf (\u03bd)\n\u03bd\u22121\n\u03c3(\u03bd)\u22121\n\u03c3(\u03bd)\n\u03c3(\u03bd)+1\n\u03c3(\u03bd)+2\n\u03bd+1\n\nTable 1 considers the general case, when the node associated to the tile is\ninside the tree. This means that the corresponding node always has its father\nin the tree and that all its neighbours are also in the tree. In Table 2, we have\nthe exceptional cases. The nodes on the leftmost branch, the root excepted, and\nthose which are on the rightmost branch, the root excepted. The nodes of the\nrightmost branch are white and the root is also white. The nodes on the leftmost\nbranch, the root excepted, are black.\n\n\fIt remains to indicate that in the case of a heptagon H which is on the leftor the rightmost branch, it is easy to define the number of the sector to which\nbelongs the neighbours which do not belong to the tree of H. Indeed, let \u03c3 be\nthe number of the sector in which H lies. If H is a black node, its neighbours 2\nand 3 are in the sector \u03c3 \u22961, where \u03c3 \u22961 = \u03c3\u22121 when i > 1 and 1\u22961 = 7. If H is\na white node, its neighbours 6 and 7 are in the sector \u03c3 \u2295 1 with \u03c3 \u2295 1 = \u03c3+1\nwhen i < 7 and 7 \u2295 1 = 1. Note that for the root of the sector \u03c3, its neighbour 2\nis in the sector \u03c3 \u2296 1 and its neighbour 1 is the central cell which is outside all\nthe sectors.\nTable 2: The numbers of the neighbours for a tile \u03bd which is either the root of the\ntree, or which belongs to an extremal branch the leftmost or the rightmost ones. The\nnumbers are given in the columns root, left and right respectively.\n\u03c4\n\nleft\n\nright\n\nroot\n\n1\n2\n3\n4\n5\n6\n7\n\nf (\u03bd)\n\u03bd\u22121\n\u03c3(\u03bd)\u22121\n\u03c3(\u03bd)\n\u03c3(\u03bd)+1\n\u03c3(\u03bd)+2\n\u03bd+1\n\nf (\u03bd)\n\u03bd\u22121\n\u03c3(\u03bd)\u22121\n\u03c3(\u03bd)\n\u03c3(\u03bd)+1\n\u03bd+1\nf (\u03bd)+1\n\n0\n1\n\u03c3(\u03bd)\u22121\n\u03c3(\u03bd)\n\u03c3(\u03bd)+1\n\u03bd+1\n1\n\nBoth Theorems 1 and 2 give an algorithm to compute new coordinates if we\nchange the place of the central tile to another tile. In Section 5, we briefly give\nan explicit pseudo code implementing an algorithm satisfying Theorem 2.\nThe computation of the functions f and \u03c3 used in the computation of the\ncoordinates of the neighbours of a tile are also used for this purpose and based\non these considerations and on the previous results we have that:\n\nTheorem 3 (see [6]) Consider a system of coordinate and a tile T . Assume that\nwe take T as the central tile and that we fix its new side 1. There is an algorithm\nwhich, for each tile T \u2032 computes the coordinates of T \u2032 in the new system in linear\ntime in the size of the coordinate in the initially given system.\n\nIt is important to remark that in order to obtain the linearity of the algorithm, we do not compute the functions f and \u03c3 but [f ] and [\u03c3] applied to [n].\nThis means that in order to compute \u03c3(n)\u22121 for instance, we need an algorithm\nfor computing [m\u22121] from [m]. A similar remark holds for [m+1]. The needed\nalgorithms can be found in [5].\n\n\f4\n\nThe communication protocol\n\nIn Section 1, we mentioned that in [7], we already proposed a communication\nprotocol for the tiles of the heptagrid. This protocol was based on a specific\nsystem of coordinates, inherited from [4,6]. For the convenience of the reader,\nwe briefly describe this system in Sub-section 4.1. Then, in Sub-section 4.2 we\ndefine the new protocol.\n4.1\n\nAbsolute and relative systems\n\nThe absolute system is based on a numbering of the sides tiles of the heptagrid.\nFor each tile, we number the sides from 1 to 7 in this order while counterclockwise turning around the tile. Now, how to fix side 1? We again take the\nsituation of the left-hand side of Figure 3: a central cell surrounded by seven\nsectors, each one spanned by a copy of the Fibonacci tree. Now, side 1 is fixed\nonce and for all for the central tile. For the other tiles, side 1 is the side shared\nby the tile and its father, considering that the central cell is the father of the\nroot for each copy of the Fibonacci tree spanning the sectors.\nNow, a side always belongs to two tiles and so it receives two numbers. This\nis why this numbering is called local. However, the association between both\nnumbers is not arbitrary. There is a correspondence between them although it\nis not one to one. When one number is known, the status of the tile and the\nfact that the corresponding node whether lies or not on an extremal branch of\nthe tree are also needed to determine the other number. This correspondence is\ngiven by Table 3 and Table 4 lists all the couples used by the sides: note that\nwe are far from using all possible couples.\nThe absolute system consists in first fixing the local numbering once and\nfor all. Table 3 will still be used to determine the two numbers of a side of a\nheptagon.\nTable 3: Correspondence between the numbers of a side shared by two heptagons, H\nand K. Note that if H is white, the other number of side 1 may be 4 or 5 when K is\nwhite and that it is always 5 when K is black.\n\nblack H\nin H\n1\n2\n3\n4\n5\n6\n7\n\nwhite H\n\nin K\n3\n\nwK\n\n,4\n6\n7\n1\n1\n2\n2\n\nbK\n\nin H\n\nin K\n\n1\n2\n3\n4\n5\n6\n7\n\n4wK , 5\n7\n1\n1\n1\n2\nwK\n2 , 3bK\n\n\fNext, we remark that the local numbering gives a way to encode a path\nbetween two tiles A and B. Let {Ti }i\u2208[0..n] be a shortest path from A to B\nand denote by si the side shared by Ti and Ti+1 for i \u2208 [0..n\u22121]. Let ai be the\nnumber of si in Ti and bi be its number in Ti+1 . Then we say that the sequence\n{(ai , bi )}i\u2208[0..n\u22121] is an address of B from A. The reverse sequence gives an\naddress of A from B. However, on the just above sequence, we do not know from\nthe sequence itself that (an , bn ) is the last side. In order to do this, we change\na bit the association of the numbers: for Ti belonging to the path, we denote\nby eni the side shared with Ti\u22121 and by exi the side shared with Ti+1 . For T0 ,\nas en0 cannot be defined as the number of a neighbour of T0 , we put en0 = 0.\nThis time we say that the sequence {(eni , exi )}i\u2208[O..n] is the coordinate of B\nfrom A. Similarly, the sequence {(exn\u2212i , enn\u2212i )}i\u2208[0..n] is the coordinate of A\nfrom B. And so, the correspondence between the address and the coordinate is\neasy: ai = exi and bi = eni+1 for i \u2208 [0..n\u22121] which contains the definitions\nof ex0 and enn .\nNow, how to define a shortest path between A and B?\nThere are two ways: the first way is given by Theorem 2. We apply the\nalgorithm defined in Section 5 in order to find the coordinate of A from B.\nThe second way consists in the following. If A sends messages to every tile,\nit considers itself as the central tile, taking its own number 1 as the number 1\nof the central cell. Remember that all tiles have the same size, the same shape\nand the same area, this is why each tile may feels 'equal' to the others. When\nit sends the message to its neighbours, it also send them the information that\nit is the central cell and it sends (0, i) to its neighbour i. And so, the neighbour\nreceives its coordinate from A. By induction, we assume that each tile T which\nreceives the message from A also receives its coordinate from A and its status\nin the relative tree to A in which T is. From this information, and as T knows\nfrom which neighbour it receives the message, T know which of its neighbours\nare its relative sons and so, it can append the element (enT , exT ) to the address\nit conveys to the corresponding son together with the relative status of the son.\nAnd so, we proved that each tile receiving a message from A also receives its\naddress from A and its relative status with respect to A. In fact, we have an\nimplementation of the local numbering attached to A as a central tile. This\nlocal numbering is called the relative system. Now, from its coordinate from A,\nT may computes the coordinate of A from T in a linear time in the size of the\ncoordinate, as follows from what we already have noticed. And so, if T wishes to\nreply to the message sent by A it can do it easily. Moreover, from the properties\nwe have seen in Section 3, we can see that, proceeding in the just described way,\na public message is sent to every tile once exactly, which is an important feature.\n4.2\n\nThe protocol\n\nWe have now the tools to describe the protocol of communication between the\ntiles.\nFor this protocol, we distinguish two types of messages, public ones and\nprivate ones. By definition, a public message is a message sent by a tile to all\n\n\fthe other tiles. A private message is a message sent by a tile to a single other\none. This distinction belongs to the sender of the message. In this protocol, we\nassume that we have a global clock defining a discrete time and that a message\nleaving a tile T at time t can reach only a neighbour of T at time t+1. We say\nthat the maximal speed for a message is 1.\nThe public message makes use of the relative system of the sender. However,\nin the coordinates which are constructed by the tiles which relay the message,\nthe numbers eni and exi computed by the relaying tile are defined according to\nthe absolute system as the tile does not know where is the sender and as its own\nlocal numbering is defined by the absolute system.\nA private message is either a reply to a message, either public or private,\nor a message sent to a single tile according to the following procedure. Each\ntile T has a direct access to a the system. Given the coordinates of a tile N\nas defined in Section 3, the central cell being that of the absolute system, the\nmanaging system gives to T a shortest path from T to N which is a coordinate\nof N from T . And so, a private message is defined by the fact that it has the\naddress of the receiver.\nTable 4: The pairs (i, j) of numbers of a side of a heptagon. It is assumed that the\nfirst number denotes the side\n1\n\n2\n3\n\n(1,3)\n(1,4)\n(1,5)\n(2,6)\n(2,7)\n(3,7)\n(3,1)\n\n4\n5\n6\n7\n\n(4,1)\n(5,1)\n(6,2)\n(7,2)\n(7,3)\n\nIn order to deliver the information efficiently, a private message from A to B\nstores the coordinate of B as two stacks a and r. The stack a is for the direct run\nfrom A to B, the stack b is for the way back. Each tile T on the path conveys\nthe message to the next one N on the path, in the direction from A to B. To\nperform this, T reads the top of a, say (en, ex). It knows that ex is the number\nof N from itself. Just before sending N the message and the stacks, T pops\nthe top (en, ex) of a and pushes (ex, en) on the top of r. In this way, T knows\nthat it is the receiver if ex = 0. When this is the case, T pops the top (en, ex)\nof a, pushes (ex, en) on r but does nothing else. Note that at this moment a is\nempty. When T is ready to answer, it exchange a and r and so, the same process\nallows the message to reach A together with a coordinate of B from A. This is\nillustrated by Figure 4 on a toy example.\nIt is easy to see that this process is linear in time with respect to the coordinate of the receiver, assuming that all messages travel at maximal speed 1.\n\n\fNow, we shall see that in the process of a public message, the computation by\nthe relaying tile of the new information which it has to append to the message is\neasily computed. Here two, we have two stacks, but the stack r is always empty.\nConsider a relaying tile T . Let (en0 , ex0 ) be the top of the stack a. By construction, ex0 is the side of the neighbour N through which T received the\nmessage. In order to facilitate the computation, T also receives the number en1\nin T of the side numbered ex0 in N . Let s be the number of the relative son\nof T in the relative tree. We know that s \u2208 [3..5] if T is white in the relative tree\nand that s \u2208 [4, 5] if T is black in the relative tree. This index corresponds to\na position of the father at the absolute index 1. Now, the absolute index ex1 of\nthe son defined by s is given by:\nex1 = 1 + ((en1 \u22121) + s\u22121) mod 7,\n\n(4)\n\nOnce ex1 is known, the other absolute number of the side defined by ex1 , say\nen2 , may be determined by Table 4. Now, we know that when ex1 \u2208 {1, 2, 3, 7},\nen2 is not uniquely defined. The value of en2 depends on the absolute status\nof T . The simplest solution is to assume that all pairs (i, j) for i \u2208 {1..7} are\nknown for each tile T in a table output which is a sub-table of Table 4, see\nSection 5 for the implementation of this important point. Then we have:\nen2 = output(ex1 ).\nFor implementation, note that the root of the relative sector 1 for a sender is\nits absolute neighbour 1. Also note that formula (4) is different from the formula\ngiven in [6]. In formula (4), we do not need to know the relative status of the tile,\ncontrarily to the formula used in [6]. This is automatically given by the relative\nindices used for the relative sons.\n\nBob\n41\n51\n51\n51\n\n31\n\n41\n\n41\n\n51\n\n51\n31\n51\n\n51\n\n41\n\nAlice\nFigure 4 Illustration of the protocol of communication between tiles of the pentagrid\nor of the heptagrid. The circled tiles indicate a shortest path from Alice to Bob. Note the\nnumbering of the sides shared by two tiles according to the definition of this sub-section.\nHowever, we cannot assume that all tiles send messages at any time. This\nwould not be realistic. Also, we cannot assume that public messages are sent for\never to cover the whole plane which would also not be realistic. Indeed, in case\n\n\fof public messages sent without stopping, the number of messages at any tile at\neach time would increase to infinity at an exponential rate with time.\nIn order to limit the scope of a public message, we define a radius of its\npropagation. This means that if a public message is sent from A, it will reach\nany tile whose distance from A is at most the radius. The distance between two\ntiles A and B is the length of a shortest path between A and B. Of course, the\nmessage could also bring with it the delay which could be decremented by 1\neach time it reaches a new tile, and the message would destroy itself when the\ndelay would be 0. The defect of this solution is that we have to transport the\ndelay to all tiles within the radius and that at each time, we have to perform\nthis decrementing at each tile.\nThere is another solution. When A sends a public message with radius r, the\n1\nmessage is not sent at maximal speed 1 but at a speed . As we have a global\n2\nclock, we shall distinguish between odd and even times. A public message travels\nat odd times and remains on the tile at even times. Consider the message \u03bc sent\nfrom A at time 1. Now, A must remember \u03bc and this is implemented as another\nmessage \u03bce which is not sent immediately. The new message has the minimal\ninformation. It has to destroy \u03bc and only \u03bc. To this purpose, all messages are\nidentified by a unique number given by the system. And so, \u03bce contains the\nnumber of \u03bc. Next, A keeps \u03bce during r tops of the clock. In fact, \u03bce also keeps\na delay which is r when \u03bce is created and which is decremented at each top\nof the clock. When the delay is 0, \u03bce is sent to all tiles, according to the same\nprocess as a public message, but at speed 1. Also, another important difference\nis that \u03bce does not need to transport a stack as it is not sent in order to get any\nreply. As \u03bce travels at speed 1, at time 2r, it reaches \u03bc and it destroys it. Later\non we shall say that \u03bce is an erasing message.\nWith this, we completed the description of the process concerning public\nmessages. Private messages always travel at speed 1.\nA last point for the simulation: as a tile does not send a message at any\ntime, we have to decide when it sends a message. For this purpose, we use a\nPoisson generator, both for the decision of sending a message and, in the case of\na public message, for defining the radius of the propagation of the message. For\neach parameter, we use a different coefficient for the generator. We shall see the\nvalues in Section 6.\n\n5\n\nThe simulation program\n\nAs usual for the implementation of a theoretical model, the simulation program\nresults from many choices decided by the programmer for the implementation of\nvarious features, in particular, the structure representing the space of the simulation, we shall see this point in Subsection 5.1. Subsection 5.2 is devoted to auxiliary computations connected with the implementation of the basic algorithms.\nSubsection 5.3 describes the exact implementation of the scenario described in\nSection 4.2. The simulation program was written in ADA95. When this is the\ncase, we mention facilities given by the programming language.\n\n\f5.1\n\nData structures\n\nIn a first stage of the experiments described in Section 6, the heptagrid was\nimplemented as a table space with two entries: one in 0..7 and the other in\n0..maxsize, where maxsize is the number of tiles of a sector represented by the\nsimulation, the sector i, with i \u2208 [1..7] being represented by space(i,*). From\nsection 3, it is not difficult to compute that up to the level n, the number of tiles\nin a sector is f2n+2 \u22121.\nThe elements of the table are a small table of 8 records indexed from 0\nto 8. Record 0 represents the tile space(i, j): it is the tile T of coordinate (i, j)\nwith i \u2208 [1..7] and j \u2208 [1..maxsize]. Record v, with v \u2208 [1..7] represents the\nneighbour v of T . The fields of the record contain the information needed to\nminimize the computation time. Except the coordinate of the tile and of its\nneighbours, the record is assumed to contain an information of constant size.\nPresently, in order to overcome a quick overflow by the manipulation of the\ntable, the space of the experiment is implemented by stacks. There is a basic table\nspace with a single entry in 0..7 which represents the central cell and the roots of\nthe Fibonacci trees. Each element of the table is a pointer, addresstile which\npoints at a tile. The pointer in space(0) points at the central cell, space(i), with\ni \u2208 1..7 points at the root of the sector i. The tiles themselves are represented\nby a record whose fields are:\nnum: the number of the node in its tree,\nsect: the number of the sector,\nneighbour: a table of seven pointers, neighbour(i) pointing\nat the neighbour i of the tile,\nassociate: a table of seven numbers, the absolute number\nof side i in the neighbour i,\nbranch, with the self-explaining values about the position\nof the tile with respect to the borders of the sector:\nleft, right middle, root and centre,\nstatus, the status of the tile: central, white or black,\nouter, boolean: says if the considered neighbour is outside\nthe simulation space,\nborder, boolean: says if the tile is on the border of the simulation space,\nmessage stack0, message stack1: two pointers on the stack\nof messages,\nlast message0, last message1: two pointers at the last element of the stack, i.e. the most recent message.\nThe stack of messages contains what is needed for the communication system.\nEach element of the stack holds a record with the following fields:\nnext : pointer for handling the stack,\nrelative father, an integer in 1..7, 0 if not defined,\nrelative status, with the values: black, white, centre,\nnumber, an integer: the number given to the message,\n\n\fthe type, with the values: public, private, erasing,\nwait, an integer: the counter for an erasing message,\ndirect, wayback, pointers of messages.\nNow, why two pointers at the stack of messages?\nThis is to perform the simulation in the following way. At each tile, we\nrepresent the stack of messages by two disjoint stacks: stack0, accessed through\nmessage stack0 and last message0, and stack1, accessed through the pointers\nmessage stack1 and last message1. We consider that stack0 represents the\nstack at the tile at the time t while stack1 represents the stack at the same\ntile but at the time t+1. The disjunction of stack0 with respect to stack1\navoid any confusion of pointers. And this disjunction is needed as a tile possibly\nreceives contributions from its neighbours and this is performed sequentially by\nthe simulation, whence the distinction between the two configurations of the\nsame stack at the time t and at the time t+1: the same tile receives contribution\nfrom its neighbours at different steps of the sequential process within the steps\nof computation which represent the turning from the time t to the time t+1.\n5.2\n\nAuxiliary computations\n\nThe computation of the shortest path is given by a simple algorithm which hides\nmore involved computations, although they remain within a linear estimate with\na small coefficient, see 1. Among the shortest paths from the tile A to the tile B,\nthere are two extremal ones: if we consider the A as the central cell, B lies in\na sector i and the the path from A to B which passes through the root of the\nsector and going along the branch of the tree from the root to B is one of these\nextremal paths: there is no other shortest path on the left-hand side of this path\nwhile looking at B and the root with B below the root. If we start from B\nas the central cell, we get the other extremal path: no shortest to the righthand side of this one. Now, when we have at our disposal a shortest path \u03c0, say\nfrom A to B, it is possible to define the leftmost shortest path from A to B. This\npath is computed thanks to the procedure measure which computes the distance\nbetween two paths. It also relies on a function pathroot which computes the\npath from a node to the root from the coordinate of the node. It uses a function\nleftmost which computes the leftmost shortest path when it is given a shortest\npath.\nThe function pathroot is a significantly improved version of the algorithm\ngiven in [6], giving a much simpler proof of Theorem 1. The key point was to\nnotice that there is a kind of propagation of the carry when for the first time to\ncontiguous 1's are detected: test in the else-branch of the main if of the loop.\nWhen starting the execution of function shortest, both paths start from\nthe central cell as indicated by the instructions which initialize Lcursor and\nRcursor. As suggested by the identifiers, Lcursor points at the leftmost tiles\nbetween tile1 and tile2. The function theleftmost looks whether the points\nbelong to the same sector of not. If not, the absolute difference between the\nindices of the sectors allows us to know the leftmost tile. If they are in the same\n\n\fsector, then the function follows both paths from the root to the nodes until\nthe paths diverge as we assume that the tiles are distinct. At the tile which is\nthe point where both paths diverge, it is easy to determine which tile is on the\nleft-hand side of the other.\nAlgorithm 1 The computation of the shortest path. Given tile1 and tile2 with the\nassumption that tile1 6= tile2, tile1 6= \u2205 and tile2 6= \u2205 as well.\n\nLtile := theleftmost(tile1,tile2);\nif tile1 = Ltile\nthen Rtile := tile2;\nelse Rtile := tile1;\nend if;\nLcursor := chain translation(pathroot(Ltile));\nRcursor := chain translation(leftmost(pathroot(Rtile)));\nloop\nmeasure(distance,Lcursor,RcursoR);\nif Lcursor.next = null then exit; end if;\nif Rcursor.next = null then exit; end if;\nexit when distance > 1;\nLcursor := Lcursor.next;\nRcursor := Rcursor.next;\nend loop;\n-- we go out of the loop when distance \u2265 2\n-- the distance is between Lcursor.next et Rcursor.next\nladresse := connect (Lcursor,Rcursor);\nreturn ladresse;\nWhen the leftmost tile is determined, then the function first computes the\npath from Ltile to the central cell and then the leftmost path from Rtile\nto the central cell. In this way, we already know that the distance between\nthe paths is at most 1 as long as possible. In the loop which starts form the\ncentral tile, the distance between the tiles of the path at the current stage is\nmeasured by the procedure measure which updates distance which outputs\nthe computed distance. If one path is completely traversed or if the distance is\nnow bigger than 1, the loop is completed and both pointers point at the furthest\ntile from the central tile where the distance is at most 1. Then the function\nconnect establishes the necessary path in order to join both remaining parts of\nthe paths in the shortest way: it is a finite selection of cases in each of which the\nconstruction is easy. This point raises no difficulty.\nThe procedure measure is detailed by Algorithm 3. It takes into account\nthat the leftmost path which joins the central cell to the rightmost tile may lie\non the left-hand side of the path joining the leftmost tile. This is why we have\nthis selection of cases into three of them denoted by equal, when the distance\nis 0, normal when the distance is 1 and the tile on Lmark is on the left-hand\nside of the tile on Rmark, and opposite when the distance is 1 and the tile on\nLmark is on the right-hand side of the tile on Rmark. Such cases do happen. Note\nthat the case opposite is structurally very similar to the case normal. The only\n\n\fdifference is that in the former case, we look at Rmark.status while in the latter\nwe look at Lmark.status. The reason is that in both cases, we have to consider\nthe status of the rightmost tile.\nAlgorithm 2 The computation of the path from the root to a node of the tree. shortest\npath. Given tile = (tile(0),tile(1)), the number of the sector and the number of the\nnode respectively. Also, representation = [tile(1)] is an array of 0's and 1's indexed\nfrom 0. The index cursor starts from 1 and it is on the lowest digit.\nstage := new T pairs;\nstage.next := thepath;\nstage.ingate := 1;\nstage.outgate := 0; -- characterizes an end\nthepath := letape;\nwhile cursor < representation'last\nloop\nstage := new T pairs;\nstage.next := thepath;\nstage.ingate := 1;\nif cursor+1 > representation'last\nthen\nstage.outgate := 4 + representation(cursor);\nelse\nstage.outgate := 4 - representation(cursor+1)\n+ representation(cursor);\nif representation(cursor+1) = 1\nthen if cursor+2 <= representation'last\nthen representation(cursor+2) := 1;\nend if;\nend if;\nend if;\nthepath := letape;\ncursor := cursor+2;\nend loop;\n-- finalization :\nstage := new T pairs;\n-- inversion\nstage.sortie := tile(0);\nstage.entree := 0;\nstage.next := thepath;\nthepath := stage;\nreturn thepath;\n\nThis allows us to briefly mention that the function leftmost works in a\nsimilar way, also based on the computation of the distance between the given\npath and the constructed one which should be the leftmost one. During the\nconstruction, the algorithm tries to keep the distance between the current tile\non the given path and the current tile of the constructed path exactly equal to 1.\nAs long as this is possible, the algorithm goes on in this way. If it can hold the\ncondition until the last connection to the target of the path, we are done. But\n\n\fit may happen, and this indeed does happen, that at the next step after the\ncurrent path, the distance must be at least 2. This means that the constructed\npath went to much to the left and that it is needed to resume the computation\nAlgorithm 3 The computation of the distance between two tiles, assuming that the\ndistance between their fathers is at most 1. Given Lmark,Rmark, two pointers on the\nconsidered paths.\ndistance0 := distance;\ncase side is\nwhen equal => -- distance = 0\nif Lmark.ingate = 0 then -- initialisation\nmaxim := maxi(Lmark.outgate,Rmark.outgate);\nminim := mini(Lmark.outgate,Rmark.outgate);\necart1 := maxim - minim;\necart2 := minim + 7 - maxim;\necart := mini(ecart1,ecart2);\nelse -- ordinary situation: distance0 = 0\nif (Lmark.outgate /= 0) and (Rmark.outgate /= 0) then\ndistance := maxi(Lmark.outgate,Rmark.outgate)\n- mini(Lmark.outgate,Rmark.outgate);\nelse distance := distance0;\nend if;\nend if;\nif Lmark.outgate /= Rmark.outgate then\nif Lmark.outgate = theleftmost(Lmark.outgate,\nRmark.outgate) then\nside := normal;\nelse side := opposite;\nend if;\nend if;\nwhen normal => -- distance0 = 1\nif (Lmark.outgate /= 0) and (Rmark.outgate /= 0) then\ndistance := 5 - Lmark.outgate + Rmark.outgate - 3;\nif Rmark.status = white then\ndistance := distance+1;\nend if;\nif distance = 0 then side := equal; end if;\nelse distance := distance0;\nend if;\nwhen inverse =>\nif (Lmark.outgate /= 0) and (Rmark.outgate /= 0) then\ndistance := 5 - Lmark.outgate + Rmark.outgate - 3;\nif Lmark.status = white then\ndistance := distance+1;\nend if;\nif distance = 0 then side := equal; end if;\nelse distance := distance0;\nend if;\nend case;\n\n\ffrom a previously reached tile. If it were needed to go back to the central time\neach time the computation has to be resumed, the algorithm would be quadratic.\nFortunately, a careful analysis of the construction shows that it is possible\nto find key tiles so that each time we have to resume the computation, we have\nto go back to the last fixed key tiles so that adding all the traversed parts of\nthe path lead to a total length which is at most twice the length of the given\npath. The length of this part of the program exceeds the room for this paper.\nHowever, the overall computation of the function leftmost is still linear in time\nwith respect to the length of the given path.\nAs a last auxiliary function, we just remind the algorithm for the Poisson\ngenerator, taking from [2]. We can rewrite it as follows:\nAlgorithm 4 The Poisson generator for an integer valued function. Here, random is\na uniform random integer-valued variable in the range 0..p rand. The function random\nis an algorithmic random generator. It can be constructed as indicated also in [2].\ncompte : integer := 0;\npois\n: double := 1.0;\nbegin\nloop\npois := pois*double(random)/double(p rand);\nexit when pois < exp(-lambda);\ncompte := compte+1;\nend loop;\nreturn compte;\nend;\n\n5.3\n\nImplementing the protocol\n\nThe simulation is controlled by the procedure execute, see Algorithm 5. As there\nare many variables to collect partial results for later analysis, we use records in\norder to make the program more readable. The partial results concern the various\nkinds of messages, so that the fields of the records are public, reply, write,\nnonpublic, erase.\nThe function init config initializes the table space. In particular, for each\ntile, it provides the information about the number of the tile, its sector, as well\nas the similar information for its seven neighbours. It also computes the table\nassociates of the numbers of the sides of tile in the neighbour sharing this side.\nIn Algorithm 5, note that we perform addition on records thanks to the\nfacility given by ADA to overload the usual signs of operation '+', '\u2212', '\u00d7' as\nwell as relations, '=' and '>=' as an example.\nWe develop the function transition in Algorithm 6.\nThe actual content of the function transition is performed by the procedure action in which implements the exact choices of the simulation, see\nAlgorithm 7.\n\n\fAs indicated in Section 4, public messages are sent and conveyed at odd times.\nDue to the copying process fromstack0 onto stack1 on which the execution is\nbased, the information about a public message has to be copied on stack1 at\neven times: otherwise, the message would be erased. This is what the procedure\nreplicate performs. The same procedure is also used for the erasing messages\nduring the delay they observe at the tile which emitted a public message. Of\ncourse, at each replication, the delay is decreased by 1, until the delay reaches 1.\nAt this moment, it is sent to catch the emitted message.\nAlgorithm 5 The procedure execute.\nauxil := init config;\ncollect(auxil,0,collect at t,nb max msg t);\ntotals := collect at t;\nthe max msg := nb max msg t;\nthemax at t := collect at t;\nfor t in 1..duration\nloop\nspace := transition(auxil,t);\nauxil := space;\ncollect(auxil,t,collect at t,nb max msg t);\ntotals := totals + collect at t;\nthemax at t := maxi(themax at t,collect at t);\nthe max msg := maxi(the max msg,nb max msg t);\nend loop;\n\nAlgorithm 6 The function transition.\n-- central tile:\naction in(0,0);\n-- the other tiles:\nfor sect in 1..space'last(1)\nloop\nfor i in 1..space'last(2)\nloop\naction in(sect,i);\nend loop;\nend loop;\nreturn copy(new space);\nLet us describe this procedure with more details. Let \u03bc be a public message\nissued at time 2t\u22121, with t > 0 by the procedure send. At the same time, the procedure send creates an erasing message \u03bce with the same number as \u03bc. In send,\nthe Poisson random generator is called with the parameter poisson radius in\norder to define the radius of propagation of \u03bc. This initializes the field wait\nattached to \u03bc0 . By construction, the radius is always positive. Note that there\nis no condition on the time for the management of an erasing message. As long\nas its delay is greater than 1, the erasing message remains in the tile T where\n\n\fit was created. When the delay is 1, it is sent to the neighbours with its field\nwait set to 0. The procedure convey transmits the erasing message as its delay\nis now always 0, called at each time by action in, see Algorithm 7.\nAlgorithm 7 The procedure action in.\ncursor := space(sect,i)(0).message stack;\nwhile (cursor /= null)\nloop\ncase cursor.the type is\nwhen public =>\nif (time mod 2) /= 0 then\nif cursor.direct = null then\nsend(from => (sect,i), cursor => cursor);\nelse convey (from => (sect,i), cursor => cursor);\nend if;\nelse -- even time:\nreplicate(cursor, ontile => tile1);\nif poissonrandom(poisson reply) > 0 then\nreply(from => (sect,i), place => cursor,\nnum => cursor.number);\nend if;\nend if;\nwhen nonpublic =>\nconvey (from => (sect,i), cursor => cursor);\nwhen erasing => -- cursor.direct = null, always\nif cursor.wait = 1 then\nsend(from => (sect,i), cursor => cursor);\nelsif cursor.wait = 0 then\nconvey (from => (sect,i), cursor => cursor);\nelse -- cursor.wait > 1\nreplicate(cursor, ontile => tile1);\ntile1.last message.wait := cursor.wait-1;\nend if;\nend case;\ncursor := cursor.next;\ncompte := compte+1;\nend loop;\nif poissonrandom(poisson write) > 0 then\nwrite (from => (sect,i));\nend if;\nif (time mod 2) = 0 then\nif poissonrandom(poisson public) > 0 then\ninit cell(sect,i,new space,public);\nend if;\nend if;\n\nIt is not difficult to see that if \u03bc is sent at the time t and \u03bce is sent at the\ntime t+r, then \u03bc and \u03bce are at the same tile at the time t+2r.\nMore precisely, \u03bc and \u03bce are present on the same tile at an even time: t+2r\nhas the same parity as t which is odd and when \u03bc is sent, but \u03bce is sent when\n\n\fwait = 1. And so, the coincidence is detected by the procedure convey at the\ntime t+2r+1: at this time, \u03bc, which reached the tile \u03c4 at t+2r is still there at\nt+2r+1. The situation is given in a schematic way by Table 8 and it is illustrated\nby Figure 5.\nAlgorithm 8 The procedure action in.\n--- sector\n-- tile\n-- wait\n--0\n-1\n-2\n-3\n-4\n-5\n-6\n-7\n-8\n-9\n-10\n-11\n-12\n--\n\n1\n7\n0\n\n1\n3\n1\n\n1\n1\n2\n\n0\n3\n\n5\n1\n4\n\n5\n9\n5\n\n5\n24\n6\n\nX\nX\nX\nX\nX\nX\nX\n\no\no\n\nX\nX\n\no\no\n\no\n\nX\nX\no\n\nX\nZ\n\n6\n5\n4\n3\n2\n1\n0\n0\n0\n0\n0\n0\n\nFigure 5 The emission of a public message and of its erasing signal.\n\n\fIn the program, the cancellation of a message reached by its erasing signal is\nperformed by the procedure convey. When dealing with a public message, the\nfirst task of the procedure is to scan the stack in order to possibly detect an\nerasing signal with the same number as the message. When this happens, the\nmessage, which is scanned in stack0 is simply not copied onto stack1. When\nthe procedure examine an erasing signal, it performs a similar scanning: if a\npublic message bears the same number as the signal, the signal is not copied\nonto stack1. As the cancellation has to occur when both signals are present,\nthis simple way is enough to perform this action and there is no need to connect\nthe two decisions of not copying the information onto stack1. This is guaranteed\nby the disjunction between stack0 and stack1.\n\n6\n\nThe experiment\n\nThe experiment was performed by the running the program on a simple laptop.\nThe laptop is a Lenovo one, with two Intel processors, both working at 2 GHz,\nand Linux Mandriva as operating system. The used ADA-compiler belongs to\nthe gnu-family, version 4.4.1. In the first sub-section, we describe the experiment\nand we give an account of the results. In the second sub-section, we give an\ninterpretation of the results.\n6.1\n\nDescription of the experiment and of the results\n\nThe program was run for six value of the depth of the Fibonacci tree, ranging\nfrom 5 to 10. Denote by S the observation space. The size of S is defined by\nthe depth of the Fibonacci tree which spans the seven sectors displayed around\nthe central cell. We consider the tiles whose level in the tree is at most depth\nwhich takes values in [5..10] in our experiments. This means that S contains\n1625 tiles when depth = 5 and 200593 tiles when depth = 10. Increasing the\ndepth by 1 means\nmultiplying the number of tiles by a coefficient which quickly\n\u221a\n3+ 5\ntends to\n\u2248 2.618034. This factor of a bit more than 2.6, can be observed\n2\nin Table 5 which indicates the number of tiles of S for the different values of\ndepth.\nThe second parameter which we also changed is the radius of propagation of\nthe public messages. As indicated in Section 4, the radius is an integer valued\nrandom variable following a Poisson law. The coefficient is fixed to 5 in one series\nof experiments and to 10 in the second one. The range of the variable is in mean\nthis coefficient. However, the value may range from 0 to twice the coefficient\nwith, from time to time, bigger values. Table 5 indicates the number of messages\nemitted in the observed area under these conditions. The remaining parameters\nare the following. Each tile is given the possibility to emit a message. Again\nwe assume that the probability of such an event is given by a Poisson law. The\ncoefficient is 0,005 for a public message, taking into account that such messages\nare emitted at odd times only. Also, the tiles which are on the border of the\n\n\fspace and which are the more numerous, more than 60% of the overall number\nof tiles in S, are given an additional possibility with again a Poisson law whose\ncoefficient is 0.0025. This is also to reflect the possibility for the tiles of S to\nreceive messages from outside S. Now, for private messages, they are caused\neither as a reply to a public message, or as a single message sent to a particular\ntile via the consultation of the directory. These events are also following a Poisson\nlaw and the coefficient is 0.0025 for the reply to a public message, and 0.001 for\nthe consultation of a directory. In the case of a message sent after consulting\nthe directory, it is assumed that the coordinate of the tile given by the directory\nfalls within S and that both numbers constituting the coordinate are uniformly\ndistributed in their respective ranges.\nTable 5 The number of tiles and the total number of messages. The number after sent\nis the radius of propagation. The time lines indicate the number of iterations during\nwhich the program was executed. Under the line indicating the time for radius 5, we\nindicate the ratio between the number of messages for consecutive depths as long as\nthe overall duration is the same. The lines mean indicate the mean of the number of\nmessages up to t divided by t for t \u2208 [1..T ] where T is indicated by the line time.\n\ndepth\n5\n6\n7\n8\n9\n10\ntiles\n1625\n4264\n11173\n29261\n76616\n200593\nsent, 5\n1101\n3308\n8636\n21797\n49295\u2217\n60453\u2217\ntime, 5\n168\n168\n168\n168\n142\n69\nratio\n3.00454\n2.61064\n2.52396\nmean, 5 6.81949 19.13115 50.10053 128.31127 342.79960 877.83673\nratio\n2.80536\n2.61879\n2.56108\n2.67162\n2.56079\nsent, 10\n2173\n8289\n13687\u2217\n13784\u2217\n19167\u2217\n30164\u2217\ntime, 10\n168\n168\n92\n41\n30\n24\nmean, 10 11.21332 40.57043 101.35430 197.08219 405.77815 965.53752\nratio\n3.618057 2.50356\n1.94449 2.058929 2.37947\n\nTable 6 The number of tiles and the total number of messages at time 24. The conventions are those of Table 5. Under each line indicating the number of messages sent\nat time 24, we have the ratio between two consecutive numbers.\n\ndepth\ntiles\nsent, 5\nratio\nsent, 10\nratio\n\n5\n6\n7\n8\n9\n10\n1625\n4264\n11173\n29261\n76616\n200593\n169\n423\n1158\n3017\n7888\n20556\n2.50296\n2.73759\n2.60535\n2.61452\n2.60599\n204\n582\n1538\n4509\n11413\n30164\n2.85294\n2.64261\n2.94129\n2.53116\n2.64295\n\nAnother important feature regarding private messages is that in the experiment, it was assumed that once a communication has started it goes on endlessly:\n\n\fif A replies to a message sent by B, either public or private, then B replies to A\nwhich again replies to B and this process goes on periodically. Moreover, the\nreply was always assumed to be immediate.\nTable 5 indicates the number of messages issued during the whole time of\nthe simulation, measured by the number of iterations of the procedure execute.\nThe number of iterations is also given by the table. It can be noticed that this\nnumber is always 168 for small values. This number was fixed for the experiment\nand it can be noticed that 168 = 7\u00d724. For a fixed value of the mean radius of\npropagation, we notice that the number of iteration becomes lower and lower.\nThis is a limitation caused by the system and the machine under which the\nprogram was run. It can be noticed that the decay of the number of the iterations\ncorresponds to the increase of the number of tiles. Accordingly, this alters the\nnumber of messages which were issued.\nTable 5 indicates the ratio between the numbers of messages sent when the\nradius of propagation is 5 and when the depth of the Fibonacci tree is 5, 6 and 7\nas for these depths, we have the same duration 168. In Table 6, we indicate the\noverall number of sent messages at time 24 as we have data for each depth of the\nexperiment. This allows us to compute the ratio between numbers associated to\nconsecutive depths.\nTable 7 The number of tiles and the maximal number of messages passing through a\ntile at a time during the interval of observation. The number after max is the radius of\npropagation. The rest of the conventions are those of Table 5.\ndepth\ntiles\nmax, 5\nratio\ntime, 5\nmax, 10\ntime, 10\n\n5\n6\n7\n8\n1625\n4264\n11173\n29261\n18\n39\n58\n104\n2.16667\n1.48718\n1.79310\n168\n168\n168\n168\n63\n169\n204\u2217\n197\u2217\n168\n168\n92\n41\n\n9\n76616\n232\u2217\n\n10\n200593\n192\u2217\n\n142\n315\u2217\n30\n\n69\n694\u2217\n24\n\nTable 8 The number of tiles and the maximal number of messages at time 24. The\nconventions are those of Table 5. Under each line indicating the maximal number of\nmessages passing through a tile at time 24, we have the ratio between two consecutive\nnumbers.\n\ndepth\ntiles\nsent, 5\nratio\nsent, 10\nratio\n\n5\n6\n7\n8\n9\n10\n1625\n4264\n11173\n29261\n76616\n200593\n11\n16\n25\n34\n54\n91\n1.45455\n1.56250\n1.36000\n1.58824\n1.68519\n17\n30\n61\n140\n315\n694\n1.76471\n2.03333 2.295082 2.25000\n2.20317\n\n\fTable 5 also reports another measurement performed by the program: if nt\nis the number of messages emitted up to the time t with t \u2208 [1..T ], where T\nis the duration of the experiment, i.e. the number of iterations, then the lines\nnt\nmean give the mean value of the numbers\n. These values are computed when\nt\nthe propagation radius is 5 and when it is 10.\nAnother interesting information is the maximal number of messages passing\nthrough a tile. The data are given in Table 7, in the same conditions as in Table 5.\nThe data are summarized in Tables 7 and 8.\nBelow, Tables 9 and 10 give an information on the decomposition of the\nnumber of emitted messages between the public messages and the private ones\nTable 9 This table is a refinement of Table 5. It indicates how the number of messages\nemitted in S are distributed between the public and the private messages and, among\nthe latter ones, between the replies to a public message or a direct message to a single\ntile via the directory. This table gives the data for radiuses 5 and 10 for the propagation\nof the public messages, upper and lower halves of the table, respectively.\n\ndepth\n\ntime\n\npublic\n\nreply\n\nwrite\n\ntotal\n\n5\nratio\n6\nratio\n7\nratio\n8\nratio\n9\nratio\n10\nratio\n\n168\n\n636\n0.577\n1840\n0.556\n4669\n0.541\n11982\n0.550\n27099\n0.550\n34536\n0.571\n\n211\n0.192\n783\n0.237\n2285\n0.264\n5295\n0.243\n12488\n0.253\n13467\n0.223\n\n254\n0.231\n685\n0.207\n1682\n0.195\n4520\n0.207\n9708\n0.197\n12450\n0.206\n\n1101\n\n5\nratio\n6\nratio\n7\nratio\n8\nratio\n9\nratio\n10\nratio\n\n168\n\n654\n0.301\n1791\n0.217\n2472\n0.181\n3094\n0.224\n6107\n0.318\n12935\n0.429\n\n1281\n0.589\n5848\n0.705\n10279\n0.751\n9603\n0.697\n10937\n0.571\n12954\n0.429\n\n238\n0.110\n650\n0.078\n936\n0.068\n1087\n0.079\n2123\n0.111\n4275\n0.142\n\n168\n168\n168\n142\n69\n\n168\n92\n41\n30\n24\n\n3308\n8636\n21797\n49295\n60453\n\n2173\n8289\n13687\n13784\n19167\n30164\n\n\fand, among the latter, between replies to a public message and direct messages\nto a tile whose coordinates are delivered by the directory.\nAs for Table 5, Table 9 gives the information for each area of S defined by the\ndepth of the Fibonacci tree. The upper half of the table concerns a propagation\nof the public messages characterized by radius 5, while, the lower half concerns\nradius 10.\nTable 10 This table is a refinement of Table 6. It indicates how the number of messages emitted in S are distributed between the public and the private messages and,\namong the latter ones, between the replies to a public message or a direct message to\na single tile via the directory. All data are taken at iteration 24. In the upper half of\nthe table, the radius of propagation for the public messages is 5. In the lower half, the\nradius is 10.\ndepth\n\npublic\n\nreply\n\nwrite\n\ntotal\n\n5\nratio\n6\nratio\n7\nratio\n8\nratio\n9\nratio\n10\nratio\n\n109\n0.577\n277\n0.556\n738\n0.541\n1856\n0.550\n5021\n0.550\n13026\n0.571\n\n24\n0.192\n53\n0.237\n200\n0.264\n504\n0.243\n1268\n0.253\n3181\n0.223\n\n36\n0.231\n93\n0.207\n220\n0.195\n657\n0.207\n1599\n0.197\n4349\n0.206\n\n169\n\n5\nratio\n6\nratio\n7\nratio\n8\nratio\n9\nratio\n10\nratio\n\n98\n0.480\n273\n0.469\n672\n0.437\n1919\n0.426\n5010\n0.439\n12935\n0.429\n\n78\n0.382\n205\n0.352\n614\n0.399\n1945\n0.431\n4720\n0.414\n12954\n0.429\n\n28\n0.138\n104\n0.179\n252\n0.164\n645\n0.143\n1683\n0.147\n4275\n0.142\n\n423\n1158\n3017\n7888\n20556\n204\n582\n1538\n4509\n11413\n30164\n\nIn Table 10, the data are attached to the same time, defined by 24 iterations.\nThis gives a direct comparison between all the data but it does not concern a\nlong enough time period.\n\n\fWe turn to the next sub-section where we try to extract a general information\nfrom these data and from a few other ones we have not the room to give in this\npaper.\n6.2\n\nInterpretation\n\nSeveral conclusions can be drawn from the results presented in Subsection 6.1.\nThe first one concerns the ratios between the number of messages for consecutive depths of the Fibonacci trees. These ratios are close to the ratio between\nthe area of S for consecutive values of the depth of the spanning tree. It seems\nthat we may conclude that these experimental data support Assumption 1.\nAssumption 1 For any t, the number of messages issued at the time t in S is\nproportional to the number of tiles belonging to S.\nIndeed, the coefficient of the Poisson law is a kind of mean of the random variable indicating whether a message is sent or not. According to the homogeneous\nnature of the space and as the decision of one tile is independent from that of its\nneighbours, it can be expected that the observed number of issued messages is\nproportional to the area. This conclusion is strengthened by the following consideration. As the actual radius of propagation of the public messages is bounded,\nthe contribution of far tiles is ruled out, starting from a certain distance from\na tile and this distance can be uniformly bounded for all the tiles. The values\nof the radius exceeding say twice the mean of the radius as a random variable\nwhich we assumed to follow a Poisson law can be considered as an event of very\nsmall probability so that an infinite repetition of exceptionally long radiuses can\nbe considered as an event of probability 0. The same remark apply if we relax a\nbit the conditions on the coordinates provided by the directory. We may assume\nthat the number of the sector is uniformly distributed and that the number of\nthe tile in the tree is an integral random variable following a Poisson law with a\nradius of the same size as that of S. And so, relaxing a bit the condition on the\ndirectory as just suggested does not alter the argument in favor of Assumption 1.\nNo clear statement can be inferred from Tables 7 and 8, except the fact that\nthe maximal number of messages passing through S seems to be increasing with\nthe time. This can also be seen on the experiment for each depth: as the number\nof iteration increases, the maximal number of messages passing at a tile also\nincreases.\nIt is also interesting to look at where the maximal number of messages appear.\nWe have not the room to give the relevant information computed by the program.\nFor each iteration, the program indicates a tile at which the number of passing\nmessages is maximal. It also splits the information in looking at where is obtained\nthe maximal number of passing public messages or private messages replying to\na public message or private messages written to a single tile. It is interesting\nto notice that most often the tiles are not the same for the different kinds of\nmessages. Also, the position of this maximum is generally the central tile or one\n\n\fof its neighbours. However, for the emission of the pubic message, the maximal\nnumber of passages at a tile may be obtained a bit further from the central tile,\nwhile the replies to these messages seem to be maximal most often at the central\ntile or its immediate neighbours.\nTables 9 and 10 show a very interesting difference between the cases when the\nradius of propagation of the public messages is 5 and when it is 10. In both tables,\nwe can see that the proportion of public messages is higher when the radius is 5.\nThis is particularly striking in Table 9, but it is already noticeable in Table 10\nshowing that this difference appears quickly and that it tends to increase a bit\nwith the time. It is also interesting to see that the relative 'loss' of the public\nmessages 'benefit' to their replies. Indeed, in both tables, the proportion of direct\nmessages to a single tile is not improved when the depth of the Fibonacci tree\nis increasing. Of course, the Poisson coefficient for triggering a public message\nis 0.005, while that of a reply is 0.0025 and that of a direct private message is\n0.001. However, the public messages are triggered at odd times only and the\nreplies occur only at even time while the direct private messages can be sent at\nany time. There should be no big difference between direct private messages and\nreplies to a public message. In fact the explanation lies in the geometry of the\nspace. Indeed, the reply is proposed to any tile visited by the propagation wave\nwhich covers all the tiles within the radius fixed at the time when the public\nmessage was emitted. This additional solicitation explains the importance of the\nreplies.\nAt this point, we can also indicate why we have chosen a Poisson law to\nmodel this message system. The reason is that we have to take into account the\ngeometry of the space. A uniform distribution would give much more weight to\ndistant tiles by the simple fact that their number increases exponentially: the\nfarther they are the more message they would send to the centre. This is also\nthe reason why we decided to limit the propagation of the public messages. If\nno limitation would be put, the number of messages received at any point would\ngrow exponentially with time by the just mentioned argument. Accordingly, the\nlimitation restricts this possibility. Now, the Poisson law also gives the possibility\nto obtain big values with respect to the mean value. Simply these extremal are\nvery rare, the more rare they are higher values.\n\n7\n\nConclusion\n\nIt is the place here to discuss how these results can be interpreted in a more\nqualitative way. The number of iterations suggests that the unit of time is an\nhour. The tiles can be interpreted either as individuals or as groups of individuals\nin a given constant area, the one defined by the area of a tile. Remember that in\nthe space we consider, all tiles have the same area. The limitation of the public\nmessages can be interpreted as a natural limit due to the conditions in which\nthe message is sent and also depending on the intentions of the sender.\nTwo important points should be noted. The first one is the property of the\npublic messages to cover all the tiles of a given area for each tile to receive the\n\n\fmessage once exactly. The second point is the mechanism to limit the propagation of a public message. This mechanism needs no centralization. It is monitored\nby the sender and, a priori, each tile can be a sender. To be a sender is defined\nby a probability which is the same for every tile. The third point is that in some\nsense, the indicated scenario is a worse case one with respect to the traffic load\nsupported by each tile. Indeed, the fact that once a communication is established\nbetween two tiles goes on endlessly contributes to increase the traffic with the\ntime. There is room here to tune the modeling by introducing various ways to\ndelay answers or to limit the number of contacts of a tile with others: here also\nwe could consider that this number is a Poisson random variable whose mean\ncan be fixed uniformly or depending on other criteria which we have not considered here. A last point is the possible improvement of the program in order to\nobtain more data and to go further in the exploration of the simulation space.\nNote that the file which records all the communications when the depth is 5 and\nthe radius of propagation is 10 and the number of iterations is 168 has a size\nof around 164 megabytes. As mentioned in Section 6, increasing the depth by 1\nmultiplies the area by around 2.618. Accordingly, the depth which defines the\narea of S cannot be extent very much. Already depth 10 with radius 10 requires\na machine more powerful than a simple laptop.\nWe are convinced that there is further work ahead to better analyze the data\nalready obtained, to improve the program in order to go further in the exploration of the simulation space. There is also room to tune the basic parameters\nin order to get a picture closer to real networks as, for instance, social networks.\n\nReferences\n1. R. Bonola, Non-Euclidean Geometry, Dover, 0-486-60027-0, New-York, 389p.\n2. D. Knuth, The Art of Computer Programming, Volume 2, Seminumerical Algorithms, Addison-Wesley, Reading, Massachusetts, (1997), third edition, 724p.\n3. M. Margenstern, Implementing Cellular Automata on the Triangular Grids of the\nHyperbolic Plane for New Simulation Tools, ASTC'2003, (2003), Orlando, March,\n29- April, 4.\n4. M. Margenstern, On the communication between cells of a cellular automaton on\nthe penta- and heptagrids of the hyperbolic plane, Journal of Cellular Automata\n1(3), (2006), 213-232.\n5. M. Margenstern, Cellular Automata in Hyperbolic Spaces, Volume 1, Theory, OCP,\nPhiladelphia, (2007), 422p.\n6. M. Margenstern, Cellular Automata in Hyperbolic Spaces, Volume 2, Implementation and computations, OCP, Philadelphia, (2008), 360p.\n7. M. Margenstern, Possible Applications of Navigation Tools in Tilings of the Hyperbolic Plane, Lecture Notes in Electrical Engineering, 70, (2011), 217-229.\n\n\f"}