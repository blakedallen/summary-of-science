{"id": "http://arxiv.org/abs/quant-ph/0111030v1", "guidislink": true, "updated": "2001-11-06T00:24:00Z", "updated_parsed": [2001, 11, 6, 0, 24, 0, 1, 310, 0], "published": "2001-11-06T00:24:00Z", "published_parsed": [2001, 11, 6, 0, 24, 0, 1, 310, 0], "title": "Multi-party Quantum Computation", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0111131%2Cquant-ph%2F0111057%2Cquant-ph%2F0111063%2Cquant-ph%2F0111023%2Cquant-ph%2F0111085%2Cquant-ph%2F0111080%2Cquant-ph%2F0111040%2Cquant-ph%2F0111165%2Cquant-ph%2F0111037%2Cquant-ph%2F0111132%2Cquant-ph%2F0111124%2Cquant-ph%2F0111043%2Cquant-ph%2F0111149%2Cquant-ph%2F0111020%2Cquant-ph%2F0111112%2Cquant-ph%2F0111140%2Cquant-ph%2F0111118%2Cquant-ph%2F0111039%2Cquant-ph%2F0111144%2Cquant-ph%2F0111114%2Cquant-ph%2F0111028%2Cquant-ph%2F0111036%2Cquant-ph%2F0111071%2Cquant-ph%2F0111137%2Cquant-ph%2F0111156%2Cquant-ph%2F0111079%2Cquant-ph%2F0111044%2Cquant-ph%2F0111070%2Cquant-ph%2F0111005%2Cquant-ph%2F0111111%2Cquant-ph%2F0111048%2Cquant-ph%2F0111102%2Cquant-ph%2F0111016%2Cquant-ph%2F0111030%2Cquant-ph%2F0111128%2Cquant-ph%2F0111153%2Cquant-ph%2F0111049%2Cquant-ph%2F0111067%2Cquant-ph%2F0111139%2Cquant-ph%2F0111117%2Cquant-ph%2F0111026%2Cquant-ph%2F0111160%2Cquant-ph%2F0111009%2Cquant-ph%2F0111084%2Cquant-ph%2F0111155%2Cquant-ph%2F0111013%2Cquant-ph%2F0111101%2Cquant-ph%2F0111099%2Cquant-ph%2F0111152%2Cquant-ph%2F0111125%2Cquant-ph%2F0111010%2Cquant-ph%2F0111162%2Cquant-ph%2F0111143%2Cquant-ph%2F0111105%2Cquant-ph%2F0111024%2Cquant-ph%2F0111054%2Cquant-ph%2F0111095%2Cquant-ph%2F0111161%2Cquant-ph%2F0111066%2Cquant-ph%2F0111076%2Cquant-ph%2F0111145%2Cquant-ph%2F0111130%2Cquant-ph%2F0111017%2Cquant-ph%2F0111029%2Cquant-ph%2F0111115%2Cquant-ph%2F0111096%2Cquant-ph%2F0111073%2Cquant-ph%2F0111075%2Cquant-ph%2F0111031%2Cquant-ph%2F0111167%2Cquant-ph%2F0111154%2Cquant-ph%2F0111003%2Cquant-ph%2F0111077%2Cquant-ph%2F0111053%2Cquant-ph%2F0111126%2Cquant-ph%2F0111074%2Cquant-ph%2F0111025%2Cquant-ph%2F0111157%2Cquant-ph%2F0111058%2Cquant-ph%2F0111032%2Cquant-ph%2F0111021%2Cquant-ph%2F0111083%2Cquant-ph%2F0111052%2Cquant-ph%2F0111142%2Cquant-ph%2F0111061%2Cquant-ph%2F0111033%2Cquant-ph%2F0111092%2Cquant-ph%2F0111062%2Cquant-ph%2F0111163%2Cquant-ph%2F0111116%2Cquant-ph%2F0111108%2Cquant-ph%2F0111094%2Cquant-ph%2F0111158%2Cquant-ph%2F0111041%2Cquant-ph%2F0111122%2Cquant-ph%2F0111091%2Cquant-ph%2F0111147%2Cquant-ph%2F0111034%2Cquant-ph%2F0111127%2Cquant-ph%2F0111113%2Cquant-ph%2F0111123&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Multi-party Quantum Computation"}, "summary": "We investigate definitions of and protocols for multi-party quantum computing\nin the scenario where the secret data are quantum systems. We work in the\nquantum information-theoretic model, where no assumptions are made on the\ncomputational power of the adversary. For the slightly weaker task of\nverifiable quantum secret sharing, we give a protocol which tolerates any t <\nn/4 cheating parties (out of n). This is shown to be optimal. We use this new\ntool to establish that any multi-party quantum computation can be securely\nperformed as long as the number of dishonest players is less than n/6.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0111131%2Cquant-ph%2F0111057%2Cquant-ph%2F0111063%2Cquant-ph%2F0111023%2Cquant-ph%2F0111085%2Cquant-ph%2F0111080%2Cquant-ph%2F0111040%2Cquant-ph%2F0111165%2Cquant-ph%2F0111037%2Cquant-ph%2F0111132%2Cquant-ph%2F0111124%2Cquant-ph%2F0111043%2Cquant-ph%2F0111149%2Cquant-ph%2F0111020%2Cquant-ph%2F0111112%2Cquant-ph%2F0111140%2Cquant-ph%2F0111118%2Cquant-ph%2F0111039%2Cquant-ph%2F0111144%2Cquant-ph%2F0111114%2Cquant-ph%2F0111028%2Cquant-ph%2F0111036%2Cquant-ph%2F0111071%2Cquant-ph%2F0111137%2Cquant-ph%2F0111156%2Cquant-ph%2F0111079%2Cquant-ph%2F0111044%2Cquant-ph%2F0111070%2Cquant-ph%2F0111005%2Cquant-ph%2F0111111%2Cquant-ph%2F0111048%2Cquant-ph%2F0111102%2Cquant-ph%2F0111016%2Cquant-ph%2F0111030%2Cquant-ph%2F0111128%2Cquant-ph%2F0111153%2Cquant-ph%2F0111049%2Cquant-ph%2F0111067%2Cquant-ph%2F0111139%2Cquant-ph%2F0111117%2Cquant-ph%2F0111026%2Cquant-ph%2F0111160%2Cquant-ph%2F0111009%2Cquant-ph%2F0111084%2Cquant-ph%2F0111155%2Cquant-ph%2F0111013%2Cquant-ph%2F0111101%2Cquant-ph%2F0111099%2Cquant-ph%2F0111152%2Cquant-ph%2F0111125%2Cquant-ph%2F0111010%2Cquant-ph%2F0111162%2Cquant-ph%2F0111143%2Cquant-ph%2F0111105%2Cquant-ph%2F0111024%2Cquant-ph%2F0111054%2Cquant-ph%2F0111095%2Cquant-ph%2F0111161%2Cquant-ph%2F0111066%2Cquant-ph%2F0111076%2Cquant-ph%2F0111145%2Cquant-ph%2F0111130%2Cquant-ph%2F0111017%2Cquant-ph%2F0111029%2Cquant-ph%2F0111115%2Cquant-ph%2F0111096%2Cquant-ph%2F0111073%2Cquant-ph%2F0111075%2Cquant-ph%2F0111031%2Cquant-ph%2F0111167%2Cquant-ph%2F0111154%2Cquant-ph%2F0111003%2Cquant-ph%2F0111077%2Cquant-ph%2F0111053%2Cquant-ph%2F0111126%2Cquant-ph%2F0111074%2Cquant-ph%2F0111025%2Cquant-ph%2F0111157%2Cquant-ph%2F0111058%2Cquant-ph%2F0111032%2Cquant-ph%2F0111021%2Cquant-ph%2F0111083%2Cquant-ph%2F0111052%2Cquant-ph%2F0111142%2Cquant-ph%2F0111061%2Cquant-ph%2F0111033%2Cquant-ph%2F0111092%2Cquant-ph%2F0111062%2Cquant-ph%2F0111163%2Cquant-ph%2F0111116%2Cquant-ph%2F0111108%2Cquant-ph%2F0111094%2Cquant-ph%2F0111158%2Cquant-ph%2F0111041%2Cquant-ph%2F0111122%2Cquant-ph%2F0111091%2Cquant-ph%2F0111147%2Cquant-ph%2F0111034%2Cquant-ph%2F0111127%2Cquant-ph%2F0111113%2Cquant-ph%2F0111123&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We investigate definitions of and protocols for multi-party quantum computing\nin the scenario where the secret data are quantum systems. We work in the\nquantum information-theoretic model, where no assumptions are made on the\ncomputational power of the adversary. For the slightly weaker task of\nverifiable quantum secret sharing, we give a protocol which tolerates any t <\nn/4 cheating parties (out of n). This is shown to be optimal. We use this new\ntool to establish that any multi-party quantum computation can be securely\nperformed as long as the number of dishonest players is less than n/6."}, "authors": ["Adam Smith"], "author_detail": {"name": "Adam Smith"}, "author": "Adam Smith", "arxiv_comment": "Masters Thesis. Based on Joint work with Claude Crepeau and Daniel\n  Gottesman. Full version is in preparation", "links": [{"href": "http://arxiv.org/abs/quant-ph/0111030v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/quant-ph/0111030v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/quant-ph/0111030v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/quant-ph/0111030v1", "journal_reference": null, "doi": null, "fulltext": "Multi-party Quantum Computation\nby\n\nAdam Smith\n\narXiv:quant-ph/0111030v1 6 Nov 2001\n\nB.Sc. Mathematics and Computer Science\nMcGill University, 1999.\nSubmitted to the Department of Electrical Engineering and Computer\nScience\nin partial fulfillment of the requirements for the degree of\nMaster of Science in Electrical Engineering and Computer Science\nat the\nMASSACHUSETTS INSTITUTE OF TECHNOLOGY\nSeptember 2001\nc Massachusetts Institute of Technology 2001. All rights reserved.\n\nAuthor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nDepartment of Electrical Engineering and Computer Science\nAugust 22, 2001\nCertified by . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nMadhu Sudan\nAssociate Professor\nThesis Supervisor\n\nAccepted by . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nArthur C. Smith\nChairman, Department Committee on Graduate Students\n\n\f2\n\n\fMulti-party Quantum Computation\nby\nAdam Smith\nSubmitted to the Department of Electrical Engineering and Computer Science\non August 22, 2001, in partial fulfillment of the\nrequirements for the degree of\nMaster of Science in Electrical Engineering and Computer Science\n\nAbstract\nWe investigate definitions of and protocols for multi-party quantum computing in\nthe scenario where the secret data are quantum systems. We work in the quantum\ninformation-theoretic model, where no assumptions are made on the computational\npower of the adversary. For the slightly weaker task of verifiable quantum secret\nsharing, we give a protocol which tolerates any t < n/4 cheating parties (out of n).\nThis is shown to be optimal. We use this new tool to establish that any multi-party\nquantum computation can be securely performed as long as the number of dishonest\nplayers is less than n/6.\nThis thesis is based on joint work with Claude Cr\u00e9peau and Daniel Gottesman.\nThesis Supervisor: Madhu Sudan\nTitle: Associate Professor\n\n3\n\n\f4\n\n\fAcknowledgements\nThanks to my co-authors, Claude Cr\u00e9peau and Daniel Gottesman, for their invaluable\nhelp with this research. Thanks to my eternally patient supervisor, Madhu Sudan.\nThanks also to the many students, family mmbers, faculty and friends who provided\nencouragement, support and advice.\n\n5\n\n\f6\n\n\fContents\n1 Introduction\n1.1 Previous Work . . . . . . . . . . . . . . . . . . . . . .\n1.2 Definitions . . . . . . . . . . . . . . . . . . . . . . . . .\n1.2.1 \"Real\" Model for Protocols . . . . . . . . . . .\n1.2.2 \"Ideal\" Model For Protocols . . . . . . . . . . .\n1.2.3 Protocol Equivalence . . . . . . . . . . . . . . .\n1.2.4 Static versus Adaptive Adversaries . . . . . . .\n1.2.5 Multi-party Quantum Computation . . . . . . .\n1.2.6 Verifiable Quantum Secret Sharing . . . . . . .\n1.3 Mathematical Preliminaries . . . . . . . . . . . . . . .\n1.3.1 Quantum Error-Correction . . . . . . . . . . . .\n1.3.2 Sharing Quantum Secrets and (No) Cloning . .\n1.3.3 Tools from Fault-Tolerant Quantum Computing\n1.4 Neighborhoods of Quantum Codes . . . . . . . . . . . .\n1.4.1 Well-Definedness of Decoding for States in CB .\n2 Distributed Protocols for Quantum Computers\n2.1 Subspace Projection . . . . . . . . . . . . . . . . .\n2.1.1 Completeness . . . . . . . . . . . . . . . . .\n2.1.2 Soundness . . . . . . . . . . . . . . . . . . .\n2.1.3 Dual Subspace Projection . . . . . . . . . .\n2.2 Vqss Protocol: Two-Level Quantum Sharing . . . .\n2.2.1 Sharing Shares: 2-good Trees . . . . . . . .\n2.2.2 Classical Vss . . . . . . . . . . . . . . . . .\n2.2.3 Vqss Protocol . . . . . . . . . . . . . . . .\n2.2.4 (Informal) Soundness . . . . . . . . . . . . .\n2.2.5 (Informal) Completeness . . . . . . . . . . .\n2.2.6 Simulatability . . . . . . . . . . . . . . . . .\n2.2.7 Round and Communication Complexity . .\n2.2.8 Additional Properties of Two-Level Sharing\n2.3 Impossibility of vqss when t \u2265 n4 . . . . . . . . . .\n2.4 Multi-party Quantum Computation . . . . . . . . .\n2.4.1 Level 3 Sharing Protocol . . . . . . . . . . .\n2.4.2 Distributed Computation . . . . . . . . . . .\n7\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n11\n14\n18\n18\n19\n19\n20\n21\n21\n23\n24\n27\n28\n31\n33\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n35\n35\n36\n37\n39\n40\n40\n42\n42\n45\n49\n49\n52\n53\n54\n55\n55\n58\n\n\f3 Open Questions\n\n61\n\nA More on Neighborhoods of Quantum Codes\n\n63\n\n8\n\n\fList of Figures\n1-1 Protocol 1 (Multi-party Quantum Computation-Ideal Model) . . . .\n1-2 Protocol 2 (Verifiable Quantum Secret Sharing-Ideal Model) . . . .\n\n21\n22\n\n2-1\n2-2\n2-3\n2-4\n2-5\n2-6\n2-7\n2-8\n2-9\n\n36\n41\n43\n44\n45\n51\n56\n58\n59\n\nProtocol 3 (Subspace Projection) . . . . . . . . .\nAlgorithm 1 (Reconstruction for a 2-good tree) .\nProtocol 4 (Modified vss protocol from [CCD88])\nProtocol 5 (vqss-Sharing Phase) . . . . . . . . .\nProtocol 6 (vqss-Reconstruction Phase) . . . .\nAlgorithm 2 (Simulation for vqss) . . . . . . . .\nProtocol 7 (Top-Level Sharing) . . . . . . . . . .\nProtocol 8 (Ideal Secret Sharing) . . . . . . . . .\nProtocol 9 (Multi-party Quantum Computation) .\n\n9\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n\f10\n\n\fChapter 1\nIntroduction\nSecure distributed protocols have been an important and fruitful area of research for\nmodern cryptography. In this setting, there is a group of participants who wish to\nperform some joint task, despite the fact that some of the participants in the protocol\nmay cheat in order to obtain additional information or corrupt the outcome. When\nwe approach distributed cryptography from the perspective of quantum computing,\na number of natural questions arise:\n\u2022 Do existing classical protocols remain secure when the adversary has access to a\nquantum computer?\n\u2022 Can we use quantum computing and communication to find new, more secure or\nfaster protocols for classical tasks?\n\u2022 What new, quantum cryptographic tasks can we perform?\nThis research is inspired by the last of these questions. We propose to investigate\na quantum version of an extensively studied classical problem, secure multi-party\ncomputation (or secure function evaluation), first introduced by [GMW87]. In this\nscenario, there are n players in a network. Each player i has an input xi , and the\nplayers want to run a protocol to collectively compute some joint function f (x1 , ..., xn ).\nThe challenge is that all players would like this function evaluation to be secure.\nInformally, this means:\n1. Soundness and Completeness: At the end of the protocol, all honest players should\nlearn the correct function value f (x1 , ..., xn ).\n2. Privacy: Cheating players should learn nothing at all beyond what they can deduce\nfrom the function output and their own inputs.\nMulti-party Quantum Computation For this thesis, we consider an extension of\nthis task to quantum computers. A multi-party quantum computing (mpqc) protocol\nallows n participants P1 , P2 , . . . , Pn to compute an n-input quantum circuit in such a\nway that each party Pi is responsible for providing one (or more) of the input states.\n11\n\n\fThe output of the circuit is broken in n components H1 \u2297 . . . \u2297 Hn such that Pi\nreceives the output Hi . Some components Hi may be empty.\nNote that the inputs to this protocol are arbitrary quantum states-the player\nproviding an input need only have it in his possession, he does not need to know\na classical description of it1 . Moreover, unlike in the classical case, we cannot assume without loss of generality that the result of the computation will be broadcast.\nInstead, each player in the protocol receives some part of the output.\nInformally, we require two security conditions as before. On one hand, no coalition\nof t or fewer cheaters should be able to affect the outcome of the protocol beyond\nwhat influence they have by choosing their inputs. On the other hand, no coalition\nof t or fewer cheaters should be able to learn anything beyond what they can deduce\nfrom their initial knowledge of their input and from the systems Hi to which they\nhave access. We formalize this notion in Section 1.2.\nVerifiable Quantum Secret Sharing In order to construct mpqc protocols, we\nconsider a subtask which we call verifiable quantum secret sharing. In classical cryptography, a verifiable secret sharing scheme [CGMA85] is a two-phase protocol with\none player designated as the \"dealer\". After the first phase (commitment), the dealer\nshares a secret amongst the players. In the second phase (recovery), the players reconstruct the value publicly. When the dealer passes the first phase of the protocol,\nthen\n\u2022 Soundness: There is a uniquely defined value s which will be reconstructed in the\nsecond phase, regardless of any interventions by an adversary who can control no\nmore than t players.\n\u2022 Completeness: If the dealer is honest, then he always passes the commitment phase\nand the value s recovered in the second phase is the secret he intended to share.\n\u2022 Privacy: If the dealer is honest, no coalition of t players can learn any information\nabout s.\nThe natural quantum version of this allows a dealer to share a state \u03c1 (possibly\nunknown to him but nonetheless in his possession). Because quantum information is\nnot clone-able, we cannot require that the state be reconstructed publicly; instead,\nthe recovery phase also has a designated player, the reconstructor R. We require\nthat, despite any malicious actions by a coalition of up to t players:\n\u2022 Soundness: As long as R is honest and the dealer passes the commitment phase\nsuccessfully, then there is a unique quantum state which can be recovered by R.\n\u2022 Completeness: When D is honest, then he always passes the commitment phase.\nMoreover, when R is also honest, then the value recovered by R is exactly D's\ninput \u03c1.\n1\n\nFor quantum information, merely having a state in one's possession in not the same as knowing\na description of it, since one cannot completely measure an unknown quantum state\n\n12\n\n\f\u2022 Privacy: When D is honest, the adversaries learn no information about his input\nuntil the recovery phase.\nNote that the privacy condition in this informal definition is redundant, by the\nproperties of quantum information: any information adversaries could obtain about\nthe shared state would imply some kind of disturbance (in general) of the shared\nstate, which would contradict the completeness requirement. A formal definition of\nsecurity is given in Section 1.2.\nContributions The results of this thesis are based on unpublished joint work with\nClaude Cr\u00e9peau and Daniel Gottesman [CGS01]. In this thesis:\n\u2022 We give a protocol for verifiable quantum secret sharing that tolerates any number\nt < n/4 of cheaters.\n\u2022 We show that this is optimal, by proving that vqss is impossible when t \u2265 n/4.\n\u2022 Based on techniques from fault-tolerant quantum computing, we use our vqss\nprotocol to construct a multi-party quantum computation protocol tolerating any\nt < n/6 cheaters.\nOur protocols run in time polynomial in both n, the number of players, and k, the\nsecurity parameter. The error of the protocols (to be defined later) is exponentially\nsmall in k.\nBeyond these specific results, there are a number of conceptual contributions of\nthis thesis to the theory of quantum cryptographic protocols.\n\u2022 We provide a simple, general framework for defining and proving the security of\ndistributed quantum protocols in terms of equivalence to an ideal protocol involving a third party. This follows the definitions for classical multi-party protocols,\nwhich have been the subject of considerable recent work [GL90, Bea91, MR91,\nCan00, DM00, CDD+ 01, PW00, Can01, vdG97].\n\u2022 The analysis of our protocols leads us to consider various notions of local \"neighborhoods\" of quantum states, and more generally of quantum codes. We discuss\nthree notions of a neighborhood. The notion most often used for the analysis\nof quantum error-correction and fault-tolerance is insufficient for our needs, but\nwe show that a very natural generalization-specific to so-called \"css\" codes, is\nadequate for our purposes.\n\u2022 Along the way, we provide modified versions of the classical sharing protocols\nof [CCD88]. The key property these protocols have is that dealers do not need\nto remember the randomness they use when constructing shares to distribute to\nother players. This allows them to replace a random choice of coins with the\nsuperposition over all such choices.\n13\n\n\fOrganization The thesis is organized as follows. Chapter 1 contains the material\nnecessary for understanding the protocols of this thesis as well as their context. Section 1.1 describes the previous work on the topics in this thesis, with emphasis on\nthe works whose results we use directly. In Section 1.2, we present a framework for\ndefining security of a distributed quantum protocol which involves interaction with a\ntrusted third party. We use this framework to formally define both verifiable quantum secret sharing and multi-party quantum computation. Section 1.3 contains the\nmathematical background for understanding our protocols, as well as results we use\nfrom the existing literature. In Section 1.4, we introduce three definitions of the local\n\"neighborhoods\" of a quantum code, in order to help the reader understand exactly\nwhat properties our protocols guarantee and what properties are needed in our security analyses. Some additional relations between these three notions are shown in\nAppendix A.\nThe protocols which are the main focus of this thesis are presented in Chapter 2.\nOne of the main proof techniques we use is a \"quantum-to-classical reduction\" (terminology due to [LC99]). In Section 2.1, we illustrate this technique with a simple\nprotocol which achieves vqss for a small number of cheaters (t < n/8), and whose\nanalysis will prove insightful for the sequel. Section 2.2 uses a similar technique, but\napplied to a modified version of the classical \"verifiable blob\" protocol of [CCD88],\nto construct a vqss protocol secure against t < n/4 cheaters. In Section 2.3, we show\nthis is optimal by relating vqss protocols to error-correcting codes and applying the\nquantum Singleton bound. Finally, we use our sharing scheme to contruct mpqc\nprotocol which tolerates any t < n/6 cheaters.\nWe conclude with some open questions related to our results (Chapter 3).\n\n1.1\n\nPrevious Work\n\nClassical mpc Most of the work on classical distributed protocols is based on secret\nsharing, in which a message is encoded and shared amongst a group of players such\nthat no coalition of t players gets any information at all about the encoded secret, but\nany group of t + 1 or more players can recover the secret exactly. The prototypical\nand most commonly used solution to this is the polynomial sharing scheme due to\nShamir [Sha79]: choose a random polynomial p of degree at most t over Zp (for some\nprime p > n) subject to p(0) = s, where s is the secret being shared. The share\ngiven to player i is value p(i), for i = 1, ..., n. Note that for normal secret sharing we\nassume that the shares are prepared honestly.\nThis assumption was removed in subsequent work: Multi-party computing, in\nwhich no player may be assumed to be honest, was first treated explicitly by Goldreich et al. [GMW87], although the subtask of verifiable secret sharing had been\ninvestigated previously by Chor et al. [CGMA85]. Goldreich et al. [GMW87] proved\nthat under computational assumptions, secure multi-party evaluation of any function\nwas possible tolerating any minority of cheating players, i.e. for any t < n2 .\nSubsequently, Ben-Or et al. [BGW88] and Chaum et al. [CCD88] independently\nproved that tolerating up to t < n3 was possible without computational assumptions,\n14\n\n\fprovided that one assumed that every pair of participants was connected by a secure\nchannel. Moreover, this bound is tight due to the impossibility of even agreeing\non a single bit when t \u2265 n3 (see Lynch [Lyn96], for example). The main difference\nbetween the results of [CCD88] and those of [BGW88] is that the former allow a small\nprobability of error (exponentially small in the complexity of the protocol).\nThe bound of n3 for information-theoretically secure mpc was broken by Rabin\nand Ben-Or [RB89] and Beaver [Bea89], who showed that assuming the existence of\na secure broadcast channel, then one can in fact tolerate any minority (t < n2 ) of\ncheaters without computational assumptions. Their protocols introduce a small error\nprobability, which is provably unavoidable [RB89]. The results of [RB89, Bea89] were\nextended to the model of adaptive adversaries by Cramer et al. [CDD+ 99].\nAll of these protocols rely on verifiable secret sharing. Our solution draws most\nheavily on the techniques of [CCD88]. The essential idea behind their vss protocol\nis to share the secret using a two-level version of the basic scheme of Shamir (above),\nand then use a cut-and-choose zero-knowledge proof to allow the dealer to convince\nall players that the shares he distributed were consistent with a single polynomial\np(x).\nBeyond these basic protocols, a line of work has focused on coming up with proper\ndefinitions of multi-party computing [GL90, Bea91, MR91, Can00, DM00, CDD+ 01,\nPW00, Can01]. Both [Can01] and [CDD+ 01] provide summaries of that literature.\nMost of the research has focused on finding definitions which allow composability of\nprotocols, mainly focusing on multi-party computing (often referred to, more precisely, as secure function evaluation). In this work, we adopt a simple definition\n(based on the initial definitions of Canetti). We do not prove any composition protocols, but simply ensure that the definition captures our intuition of security and is\nprovably achieved by our protocols. See Section 1.2 for further discussion.\nMulti-party Quantum Protocols Relatively little work exists on multi-party\ncryptographic protocols for quantum computers. Secret sharing with a quantum\nsecret was first studied by Cleve, Gottesman and Lo [CGL99]. They suggested a\ngeneralization of the Shamir scheme, which is also used by Aharonov and Ben-Or\n[AB99] as an error-correcting code. One of the contributions of [CGL99] was that to\npoint out the strong connection between secret sharing and error-correcting codes in\nthe quantum setting (see Section 1.3.2). Our vqss protocol is based on the [CGL99]\nscheme, using a modification of the techniques of [CCD88] to ensure the consistency\nof distributed shares.\nThere were some additional works on distributed quantum protocols. Gottesman\n[Got00] showed that quantum states could be used to share classical secrets more\nefficiently than is possible in a classical scheme. Chau [Cha00] proposed a scheme\nfor speeding up classical multi-party computing using quantum techniques; [Cha00]\nalso mentions the problem of verifiable quantum secret sharing as an open question.\nThe dissertation of van de Graaf [vdG97] discusses defining the security of classical\ndistributed protocols with respect to a quantum adversaries, but contains no constructions.\n15\n\n\fFault-tolerant Quantum Computing In our proposed solution, we also use techniques developed for fault-tolerant quantum computing (ftqc). The challenge of\nftqc is to tolerate non-malicious faults occurring within a single computer. One\nassumes that at every stage in the computation, every qubit has some probability p\nof suffering a random error, i.e. of becoming completely scrambled (this corresponds\nto the classical notion of random bit flips occurring during a computation). Moreover, errors are assumed to occur independently of each other and of the data in the\ncomputation.\nOne can view multi-party computation as fault-tolerant computing with a different\nerror model, one that is suited to distributed computing. On one hand, the mpqc\nmodel is weaker in some respects since we assume that errors will always occur in the\nsame, limited number of positions, i.e. errors will only occur in the systems of the t\ncorrupted players.\nOn the other hand, the error model of mpqc is stronger in some respects: in\nour setting errors may be maliciously coordinated. In particular, they will not be\nindependently placed, and they may in fact depend on the data of the computation-\nthe adversaries will use any partial information known about the other players' data,\nas well as information about their own data to attempt to corrupt the computation.\nFor example, several ftqc algorithms rely on the fact that at certain points in the\ncomputation, at most one error is likely to occur. Such algorithms will fail in a model\nof adversarially placed errors.\nTechniques from ftqc are nonetheless useful for multi-party computing. Considerable research has been done on ftqc. We rely mainly on the techniques of\nAharonov and Ben-Or [AB99], which were based on those of Shor [Sho96]. Using\n\"css\" quantum error-correcting codes, Shor showed that fault-tolerance was possible\nso long as the error rate in the computer decreased logarithmically with the size of the\ncomputation being performed. Aharonov and Ben-Or showed that by using concatenated coding, one could in fact tolerate a constant error rate. They also introduced\ngeneralized css codes in which the individual pieces of a codeword are assumed to be\nhigher-dimensional systems, such as collections of several qubits (this corresponds to\nusing larger alphabets in classical coding theory).\nProvably Secure (and Insecure) Quantum Protocols While quantum cryptographic protocols have existed for some time, many of them have been proven secure\nonly recently. The first proofs of security appeared in the context of entanglement\npurification protocols [BBP+ 96, DEJ+ 96, LC99]. In a different line of work, Mayers\n[May98] provided a notoriously difficult proof that the Bennett-Brassard key distribution scheme was secure. Unifying these two lines of research, Shor and Preskill\n[SP00] proved the correctness of the Bennett-Brassard [BB84] key distribution protocol, based on a previous proof of a purification-based protocol due to Lo and Chau\n[LC99]. The main insight of [LC99] was that in certain situations, proving the security of a quantum protocol could be reduced to classical probability arguments, since\none could assume without loss of generality that the adversary followed one of a finite\nnumber of classical cheating strategies (a so-called \"quantum-to-classical reduction\").\n16\n\n\fA similar technique is used in [BCG+ 01] to prove the correctness of a scheme for authenticating quantum transmission. This technique will also be useful for proving the\nsoundness of our protocol, as it will allow us deal with possible entanglement between\ndata and errors by \"reducing\" them to classical correlations.\nNote that for protocols where the adversary is one of the participants in the\nsystem and not an outside eavesdropper, much less is known. Some proofs were\nalso attempted for tasks such as bit commitment [BCJL93], but those proofs were\nlater discovered to be flawed, since bit commitment was proven impossible [May96,\nLC97a, May97, LC96, LC97b, BCMS98]. There have also been several works on\nquanutm coin-tossing. Although arbitrarily small error is known to be impossible,\nseveral works have focused on reducing the error as much as possible [LC96, MS99,\nATVY00, Amb01]. Yet another line of work has focused on how to achieve certain twoparty tasks using computional assumptions, i.e. assuming that there exist (quantum)\none-way permutations [DMS00, CLS01].\n\n17\n\n\f1.2\n\nDefinitions\n\nThis section describes a simple framework for proving the security of distributed\nquantum cryptographic protocols. The defintions are based on the initial framework\nof Canetti [Can00], as well as on discussions in the dissertation of van de Graaf\n[vdG97]. We describe two models for protocols. The first one\u2013the \"real\" model-\ndescribes the environment we ultimately expect our protocols to run in. The second\nmodel is idealized model in which players can interact with an incorruptable outside\nparty. We will prove our \"real-model\" protocols secure by showing that they are\nequivalent to a simple protocol for the ideal model which captures our notion of what\nsecurity means for a given task.\nWe provide no general composition theorems in this work. Instead, we simply\nprove the security of our composed protocols directly.\n\n1.2.1\n\n\"Real\" Model for Protocols\n\nFor the protocols in this paper, we assume that every pair of players is connected\nby perfect (i.e. authenticated, secret) quantum and classical channels. Moreover, we\nassume that there is a classical authenticated broadcast channel to which all players\nhave access. Because we will consider settings where t < n4 < n3 , we can also assume\nthat players can perform classical multi-party computations [BGW88, CCD88]2 .\nThe adversary is an arbitrary quantum algorithm (or family of circuits) A. We\nmake no assumptions about the computational power of the adversary; he is limited\nonly by the number of players t that he can corrupt.\nThe initial configuration for the protocol is the joint state \u03c1 of n + 2 quantum\nsystems: an input system Ii for each player in the protocol (i = 1, ..., n), as well\nas the adversary's auxiliary input system Iaux and an outside reference system Iref\n(which will remain untouched throughout the protocol). Note that the input can be\nan arbitrary quantum state, possibly entangling all these systems.\nA run of a \"real model\" protocol begins with all players receiving their input\nsystem Ii and the adversary receiving the state Iaux . The adversary then chooses\na subset C of size at most t of players to corrupt. From then on, the adversary\nhas access to the state of the players in C and controls what they send over the\nchannels. The adversary may cause the cheaters' systems to interact arbitrarily. His\nonly restriction is that he has no access to the state of the honest players, and cannot\nintercept their communication. The reference system Iref is untouched during this\nprocess.\nAt the end of the protocol, all players produce an output (for honest players, this\nis the output specified by the protocol). The system output by player i is denoted Oi .\nMoreover, the adversary outputs an additional system Oaux . The output configuration\nfor the run of the protocol is the joint state of O1 , ..., On , the adversary's state Oaux\nand the reference system Iref . This state depends on the adversary A and the initial\n2\n\nIn fact, even the assumption of a broadcast channel is unnecessary but (since t <\nfor simplicity.\n\n18\n\nn\n3)\n\nbut is made\n\n\fconfiguration \u03c1, and is denoted Real(A, \u03c1). Note that this configuration does not\ninclude any ancillary states or workspace used by honest players, only the output\nspecified by the protocol (i.e. all other parts of the honest players' systems are\n\"traced out\").\n\n1.2.2\n\n\"Ideal\" Model For Protocols\n\nThe main difference of the ideal model from the real model is that there is a trusted\nthird party (denoted T T P) who helps the players in the execution of some protocol.\nThe communications model is the same as before, except that every player is connected to T T P via a perfect (i.e. authentic, secret) quantum channel. There is no\nneed to assume a broadcast channel since players can simply give a classical value to\nT T P and ask that it be re-sent to all players.\nAs before, the initial configuration consists of n systems Ii containing the players'\ninputs as well as the two systems Iaux and Iref . The T T P gets no input. The\nprotocol proceeds as in the real model, except that players may interact with the\nT T P, who may not be corrupted by the adversary. Finally, the output configuration\nis the same as before. The final state of the T T P is not included in the output\nconfiguration. The output configuration for adversary A and initial configuration \u03c1\nis denoted Ideal(A, \u03c1).\n\n1.2.3\n\nProtocol Equivalence\n\nSuppose we have a protocol \u03c0 which is supposed to implement some ideal functionality\nf , that is f is an ideal model protocol and \u03c0 is an attempt to implement it in the\nreal model.\nInformally, we say \u03c0 implements f if the input/output behavior of \u03c0 cannot be\ndistinguished from that of f . Formally:\nDefinition 1 (Perfect security). A protocol \u03c0 is considered perfectly secure if for\nall adversaries A1 , there exists an adversary A2 , running in time polynomial in that\nof A1 , such that for all input configurations \u03c1 (possibly mixed or entangled), we have:\nReal(A1 , \u03c1) = Ideal(A2 , \u03c1)\nThe protocols we design do not in fact achieve this strong notion of security.\nInstead, they take a security parameter k as input. All players receive the classical\nstring 1k as part of their input (in the ideal model, so does the T T P). Moreover, the\ninputs may additionally depend on k (in particular, we allow the adversary's auxiliary\ninput to depend on k). Since honest players should be polynomial-time quantum\ncircuits, the protocol will run in time polynomial in k, although the adversary need\nnot.\nDefinition 2 (Statistical security). A protocol \u03c0 is considered statistically secure\nif for all adversaries A1 , there exists an adversary A2 , running in time polynomial in\n19\n\n\fthat of A1, such that for all sequences of input configurations {\u03c1k } (possibly mixed\nor entangled), we have:\n\u0001\nF Real(1k , A1 , \u03c1k ), Ideal(1k , A2 , \u03c1k ) \u2265 1 \u2212 2\u2212k ,\n\nwhere F denotes the fidelity of two quantum density matrices.\n\nSimulators Our definition asks us to construct a new adversary A2 for every real\nadversary A1 . To do so, we will follow the standard cryptographic paradigm of\nconstructing a simulator S who uses A1 as a black box. Thus we can write A2 = S A1 .\nWe can view S as an \"interface\" between the real-world adversary and the ideal-model\nprotocol [vdG97]: S exchanges messages with A1 , but must also control the corrupted\nparties in the ideal-model protocol.\nWhen A2 is constructed in this way, then the definition above can be restated:\nSuppose that at the end of the protocol the adversary gains access to the outputs of\nthe honest players. There should not exist a real-world adversary A1 that can tell\nthe difference between (a) a run of the real protocol and (b) a run of the ideal-model\nprotocol with S as an interface. We will construct simulators for our protocols in\nSection 2.2.6 and Section 2.4.2.\n\n1.2.4\n\nStatic versus Adaptive Adversaries\n\nIn this thesis, we consider only static adversaries, who choose the parties they will\ncorrupt before the beginning of the protocol and remain with that choice. On the\nother hand, an adaptive adversary chooses which players to corrupt as the protocol is\nprogressing. The set of corrupted parties is still monotone-we do not allow a player\nto become honest again once he has been corrupted3 -but the adversary can base his\ndecision on the message he is seeing in the protocol. For example, if the players were\nto elect a small group of participants to make some decision amongst themselves, an\nadaptive adversary could wait until the selection had been made and then corrupt the\nmembers of that small group. Proving protocols secure against adaptive adversaries\nhas been problematic even in the classical setting [CFGN96, CDD+ 99].\nChoosing to handle only static adversaries simplifies the definitions and proofs\nconsiderably, and offers no real loss of intuition. Nonetheless, we believe that the\nprotocols we describe here are secure against adaptive adversaries, assuming that the\nenvironment in which the protocol is running somehow records which parties were\ncorrupted and in what order (it is unclear what adaptivity even means without such\nan assumption). In Section 2.1.2, we discuss briefly how some of the proofs could be\nextended to handle adaptivity (see Remark 4, p. 38).\n\n3\n\nAn adversary who corrupts players dynamically is called a mobile adversary, and protocols for\nhandling such adversaries are called pro-active.\n\n20\n\n\f1.2.5\n\nMulti-party Quantum Computation\n\nWe define multi-party quantum computation by giving an ideal-model protocol for\nthat task. Simply put, all players hand their inputs to the trusted party, who runs the\ndesired circuit and hands back the outputs. Note that the only kind of cheating which\nis possible is that cheaters may choose their own input. In particular, cheaters cannot\nforce the abortion of the protocol. One possible extension of this work is to consider\nprotocols where cheaters may not compromise the correctness of the computation but\nmight force the protocol to stop before completion (see Open Questions, Chapter 3).\n\nProtocol 1 (Multi-party Quantum Computation-Ideal Model).\nPre: All players agree on a quantum circuit U with n inputs and n outputs(for simplicity,\nassume that the ith input and output correspond to player i).\nInput: Each player gets an input system Si (of known dimension, say p).\n1. (Input Sharing) For each i, player i sends Si to T T P. If T T P does not receive\nanything, then he broadcasts \"Player i is cheating\" to all players. Otherwise, T T P\nbroadcasts \"Player i is OK.\"\n2. (Computation) T T P evaluates the circuit U on the inputs Si . For all i who cheated,\nT T P creates Si in a known state (say |0i).\n3. (Output)\n(a) T T P sends ith output to player i.\n\n(b) Player i outputs the system he receives from T T P.\n\nFigure 1-1: Protocol 1 (Multi-party Quantum Computation-Ideal Model)\n\n1.2.6\n\nVerifiable Quantum Secret Sharing\n\nProviding a definition verifiable quantum secret sharing is trickier than it is for multiparty computing. The idea of the ideal protocol is simple. In the sharing phase, the\ndealer gives his secret system to the trusted party. In the reconstruction phase, the\nT T P sends the secret system to the reconstructor R.\nHowever, a problem arises because vqss is a two phase task, and the formalism we\nestablished in the preceding sections only describes one-phase protocols, which have\na simpler input/output behaviour. For example, if all we required of vqss is that\nthe reconstructor's output be the same as the dealer's input, we could simply have\nD send his secret system to R without violating the definition-a clear indication\nthat such a definition would be insufficient. For the purposes of this thesis, we adopt\na simple modification of the definition of the preceding sections which allows us to\n21\n\n\fdescribe vqss: instead of giving all inputs to the parties at the beginning of the run\nof the protocol, some inputs are not given to the parties until the beginning of the\nreconstruction phase.\nSpecifically, two of the inputs are delayed. First, players learn the identity of the\nreconstructor R only at the beginning of the reconstruction phase (note that this\ndoesn't stop the adversary from knowing R since the definition requires security for\nall adversaries and input sequences). Second, the adversary also receives a second\n(2)\nauxiliary input Iaux at the beginning of the reconstruction. This allows us to capture\nany side information gained by the adversary during interactions which occur between\nthe end of the sharing phase and the beginning of the reconstruction phase.\nThe ideal-model protocol we obtain is given in Figure 1-2. The definition of\nsecurity we will use for this two-phase model is essentially the same as for the onephase model. An input configuration \u03c1 consists of player identities D and R, a\n(2)\nsecret system S and the two auxiliary inputs Iaux and Iaux . We require that for\nall adversaries A1 , there exists an adversary A2 such that for all sequences of input\nconfigurations {\u03c1k }k\u2208N , the fidelity of the output of the real protocol to the output of\nthe ideal protocol is exponentially close to 1.\n\nProtocol 2 (Verifiable Quantum Secret Sharing-Ideal Model).\n\u2022 Sharing Phase:\n1. Inputs: All players get D's identity. Dealer D gets a qupit S (i.e. a p-dimensional\nsystem, where p is a publicly agreed-upon integer).\n(Adversary also gets his auxiliary input Iaux .)\n\n2. D sends the p-dimensional system S to T T P. If D fails to send S, then T T P\nbroadcasts \"D is cheating\" to all players. Otherwise, T T P broadcasts \"OK\".\n\u2022 Reconstruction Phase:\n1. Inputs: All players get R's identity.\n(2)\n(Adversary also gets his second auxiliary input Iaux .)\n\n2. If D did not cheat in the sharing phase, T T P sends S to the receiver R.\n\nFigure 1-2: Protocol 2 (Verifiable Quantum Secret Sharing-Ideal Model)\n\n22\n\n\f1.3\n\nMathematical Preliminaries\n\nWe assume that the reader is familiar with the basic notation and formalism of quantum computing. For an introduction, the reader should refer to a textbook such as\nNielsen and Chuang [NC00].\nFor most of this paper, we will work with \"qupits\", that is p-dimensional quantum\nsystems, for some prime p. It is natural to view the elements of the field F = Zp as\na basis for the state space of a qupit.\nIn our settings, it will be useful to choose p so that n < p. We need not choose p\nvery big for this, since there is always a prime between n and 2n. However, all of our\nprotocols will remain polynomial time even when p is exponential in n. That is, the\ncomplexity of the protocols will be polynomial in log |F | = log p.\nJust as for the case of qubits, there are a few natural operators on qupits which\nwe will use extensively in this paper.\nThe shift and phase operators for qupits (sometimes denoted \u03c3x , \u03c3z ) are defined\nanalogously to the case of qubits:\nX|ai 7\u2192 |a + 1\n\nmod pi and Z|ai 7\u2192 \u03c9 a |ai,\n\nwhere \u03c9 = e2\u03c0i/p . These two operators generate the Pauli group. Since they have a\nsimple commutation relation (XZ = \u03c9ZX), any element of the group is proportional\nto some product X x Z z for x, z \u2208 {0, ..., p \u2212 1}. As for qubits, the p2 operators X x Z z\nform a basis for the space of p \u00d7 p complex matrices, and so any unitary operator on\nqupits can be written as a linear combination of Pauli matrices. In particular, this\nis useful since means that correcting Pauli errors in a quantum code is sufficient for\ncorrecting arbitrary errors. In the context of errors, X is called a shift error and Z\nis a phase error.\nFor registers of qupits, the Pauli matrices are tensor products of Pauli matrices\nacting on individual qupits. If x = (x1 , ..., xn ) and y = (y1 , ..., yn ) are vectors in\nZnp , then X x Z z denotes X x1 Z z1 \u2297 * * * \u2297 X xn Z zn . These form a basis for the space of\noperators on the register. The set of positions on which a Pauli matrix does not act\nas the identity is called its support, and is equal to the union of the supports of x and\nz. The number of such positions is called the weight of the operator.\nFourier Rotations Another transformation which arises often is the Fourier transform on qupits, which generalizes the Hadamard rotation on qubits.\nX\n\u03c9 ab |bi\nF |ai 7\u2192\nb\u2208Zp\n\nThis is called a Fourier rotation since its effect on the p-dimensional vector of coefficients of the state of a qupit is exactly that of the Fourier transform over the group\nZp . Consequently, phase changes become shifts in this new basis, and conversely:\nF X = ZF\n\nand F Z = X \u22121 F\n23\n\n\fA useful property of the Fourier transform is that linear transformations remain\nlinear after the change of basis. Specifically, let V be an invertible n \u00d7 n matrix over\nZp . Let V denote the corresponding unitary operator on a register of n qupits, i.e\nVe |xi = |Vxi. Then in the Fourier basis, this looks like a different linear map, given\n\u22121 )\u22a4 ).\nby the matrix (V \u22121 )\u22a4 . That is F Ve F \u22121 = (V^\nThe main feature we will use is simply that the transformation remains a linear\npermutation of the basis vectors. There is one very useful special case. For controlled\naddition (denoted c-X), which maps |a, bi 7\u2192 |a, a + bi, conjugating by a Fourier\nrotation yields another controlled-addition, applied in the opposite direction and with\na scaling factor of \u22121 (i.e. |a, bi 7\u2192 |a \u2212 b, bi).\n\n1.3.1\n\nQuantum Error-Correction\n\nA quantum error-correcting code is a way of encoding redundancy into quantum\ninformation to allow correction of errors which occur during transmission or storage.\nAn [[n, k, d]] quantum code encodes k qubits into n qubits (for n \u2265 k) and corrects any\n(arbitrary) error which affects less than d2 positions in the code. The most resilient\nquantum codes actually work over higher-dimensional subspaces, i.e. each \"position\"\nin the code consists of a qupit. Recall that we work with qupits of dimension p, where\np is some prime greater than n.\nCss Codes An important family of quantum codes are the css codes (due to\nCalderbank-Shor [CS96] and Steane [Ste96]). A css code over n qupits is defined\nby two classical linear codes V and W over Zp , both of length n. They are chosen\n\u22a5\nsuch that V P\n\u2286 W , where V \u22a5 is the dual of V with respect to the standard dot product v * w = ni=1 vi wi . Note that we automatically also have W \u22a5 \u2286 V . The quantum\ncode C is then the set of states |\u03c8i which would yield a codeword of V if they were\nmeasured in the computational basis ({|0i, |1i, ..., |p \u2212 1i}), and yield a codeword of\nW if they were measured in the Fourier basis ({F |0i, ..., F |p \u2212 1i}).\nNow for any given system of n qupits and any linear subspace W \u2264 F n , we define\nW (q) = span{|wi : w \u2208 W }.\nIf we denote by F \u2297n the parallel application of F to all qubits of an n-qubit register,\nthen we have:\nC = V (q) \u2229 F W (q)\nThe dimension of C as a code, i.e. number of qupits it can encode, is simply\ndim(V /W \u22a5 ) = dim V \u2212 dim W \u22a5 . For convenience, we will denote V0 = W \u22a5 and\nW0 = V \u22a5 , and so the formula for the number of qupits encoded becomes dim V \u2212\ndim V0 = dim W \u2212 dim W0 .\nMinimum Distance To correct an arbitrary error on a subset A of positions (A \u2286\n{1, ..., n}), it turns out that it is sufficient (and necessary) to be able to correct Pauli\nerrors, i.e. compositions of shift and phase errors applied to the qupits in A. Thus,\n24\n\n\fto correct errors on any t positions it suffices to correct all Pauli errors of weight at\nmost t. A sufficient condition is that the spaces {EC} be mutually orthogonal, where\nE ranges over all Pauli operators of weight at most t. In such a case, one can correct\nany of these errors E on a codeword |\u03c8i by performing a measurement that identifies\nwhich of these subspaces contains the corrupted codeword E|\u03c8i, and then applying\nthe correction E \u22121 . This can be rephrased: for all Pauli operators of weight at most\n2t, EC and C should be orthogonal spaces. The minimum distance of a quantum code\nC is thus the weight of the smallest Pauli operator for which this is not true.\nDefinition 3. The minimum distance of a quantum code C is the weight of the smallest Pauli operator such that C and EC are not orthogonal.\nBy the previous discussion, a code with distance d can correct arbitrary errors\non any \u230a(d \u2212 1)/2\u230b positions. For css codes, there is a simple way to calculate the\nminimum distance:\nFact 1.1. Let V, W be classical codes with minimum distances d1 and d2 such that\nV \u22a5 \u2286 W . Then the quantum css code C = V (q) \u2229 F W (q) has minimum distance at\nleast min(d1 , d2 ). 4\nSyndromes and Error Correction Given a classical linear code V of dimension\nk, the syndrome for V is a linear function from n bits to n \u2212 k bits that indicates\nwhich coset of V contains its argument. If V has distance at least 2t + 1 and a\ncodeword v \u2208 V is altered in t or fewer positions, then the syndrome of the corrupted\nword v + e allows one to compute the correction vector \u2212e. We will let V -syndrome\ndenote the syndrome with respect to V . Note that computing the V -syndrome is\neasy. Fix a basis {v1 , ..., vn\u2212k } of the dual code V \u22a5 . The V -syndrome of w is the\nvector (v1 * w, ..., vn\u2212k * w).\nThis is the basis for the error correction procedure for css codes. Suppose that\nE = X x Z z , and both x and z have support on at most t positions. Let |\u03c8i \u2208 C. Since\n|\u03c8i lies in V (q) , measuring the V -syndrome of E|\u03c8i (in the computational basis) allows\none to compute the vector x, and apply the correction X \u2212x . Similarly, measuring\nthe W -syndrome in the Fourier basis allows one to compute z and apply Z \u2212z , thus\nrecovering |\u03c8i. The two measurements commute, so in fact it does not really matter\nwhich one is applied first.\nThe pair of measurement results used, namely the V -syndrome in the computational basis and the W -syndrome in the Fourier basis, are referred to together as the\nquantum syndrome. If the syndromes are s1 and s2 pits long respectively, then there\nn\nare ps1 +s2 possible quantum syndromes. This divides the whole space CZp into ps1 +s2\northogonal subspaces indexed by the set of equivalence classes of Pauli operators.\nThat is, two Pauli operators E, E \u2032 are deemed equivalent if EC = E \u2032 C; and the space\nn\nCZp can be written as the direct sum of the orthogonal spaces {Ej C}j\u2208J , where J is\n4\n\nIn fact, the minimum distance of C is the minimum of the weights of the lightest vectors in\nV \u2212 V0 and W \u2212 W0 . These are bounded below by the minimum distances d1 , d2 , and the bound is\ntight for the codes used in this paper.\n\n25\n\n\fa set of indices which contains exactly one element from each equivalence class. For\n\u2032\n\u2032\na css code, two Pauli operators X x Z z and X x Z z will be equivalent if and only if x\nand x\u2032 are in the same coset of V , and z and z\u2032 are in the same coset of W .\nNote that the dimension of the code can also be written as n \u2212 s1 \u2212 s2 .\nQuantum Reed-Solomon Codes In this work we will use a family of css codes\nknown as \"quantum polynomial codes\" or \"quantum Reed-Solomon codes\". These\nwere introduced by Aharonov and Ben-Or [AB99], and generalize classical ReedSolomon codes.\nIn this paper, we will specify a quantum RS code by a single parameter \u03b4 <\n(n \u2212 1)/2, which represents the degree of the polynomials used in\u0004the\n\u0005 code. The\n\u03b4\ncorresponding code C will encode a single qupit and correct t = 2 errors. For\nsimplicity, choose \u03b4 = 2t. We will always choose the number n of players to be either\n2\u03b4 + 1 or 3\u03b4 + 1.\nIf n is the number of players, choose any p such that p > n (5 ). We will work\nover the field F = Zp . The classical Reed-Solomon code V \u03b4 is obtained by taking the\nvectors\nq\u0302 = (q(1), q(2), . . . , q(n))\nfor all univariate polynomials q of degree at most \u03b4. The related code V0\u03b4 is the subset\nof V \u03b4 corresponding to polynomials which interpolate to 0 at the point 0. That is:\nV \u03b4 = {q\u0302 : q \u2208 F [x] : deg(q) \u2264 \u03b4}\nV0\u03b4 = {q\u0302 : deg(q) \u2264 \u03b4 and q(0) = 0} \u2286 V \u03b4\nThe code V \u03b4 has minimum distance d = n\u2212\u03b4. Moreover, errors (up to \u230a(n \u2212 \u03b4 \u2212 1)/2\u230b\nof them) can be corrected efficiently, given the syndrome of the corrupted word.\nNote that by the non-singularity of the Vandermonde matrix (i.e. polynomial\ninterpolation), there exists a vector d = (d1 , . . . , dn ) \u2208 F n such that d\u22a4 f\u0302 = f (0) for\nany f \u2208 F [x] and deg(f ) < n.\nFact 1.2. Let \u03b4 \u2032 = n \u2212 \u03b4 \u2212 1. The duals of the codes V \u03b4 , V0\u03b4 are\n\u2032\n\nW \u03b4 = (V0\u03b4 )\u22a5 = {(d1 q(1), ..., dn q(n)) : deg(q) \u2264 \u03b4 \u2032 }\n\u2032\nW0\u03b4 = (V \u03b4 )\u22a5 = {(d1 q(1), ..., dn q(n)) : deg(q) \u2264 \u03b4 \u2032 and q(0) = 0}\nThus the dual of a Reed-Solomon code of degree \u03b4 is another RS code with degree \u03b4 \u2032 ,\nbut where each component has been \"scaled\" according to some constant di . One can\nalso show that di 6= 0 for all i.\nThe code C for parameter \u03b4 (occasionally written C \u03b4 ) is the css code obtained\n\u2032\nfrom codes V = V \u03b4 and W = W \u03b4 . As mentioned before, it encodes a single qupit\nsince dim V = \u03b4 + 1 and dim W \u22a5 = \u03b4. Moreover, the minimum distance of V is n \u2212 \u03b4\nand the minimum distance of W is \u03b4 + 1. Thus, for \u03b4 < (n \u2212 1)/2 we get that the\nminimum distance of C is at least \u03b4 + 1, and it corrects at least t = \u03b4/2 errors.\n5\n\nIn fact, the construction can be changed to allow p = n.\n\n26\n\n\f\u03b4\nThe encoding we obtain can be described explicitly. Let\nP Va = {q\u0302 : deg(q) \u2264\n\u03b4 and q(0) = a}. Then for any qupit in a pure state |\u03c8i = a\u2208F \u03b1a |ai, the encoded\nversion is (ignoring normalization constants):\nX\nX\nX\nX\nX\nE|\u03c8i =\n\u03b1a E|ai =\n\u03b1a\n|vi =\n\u03b1a\n|q(1), ..., q(n)i\na\n\na\n\na\n\nv\u2208Va\u03b4\n\nq:deg(q)\u2264\u03b4, q(0)=a\n\nNote that the circuit for encoding is very simple: consider the linear map which\ntakes the coefficients of a polynomial of degree at most \u03b4 and maps it to the vector\nq(1), ..., q(n). Then placing |\u03c8i in the position of the constant\ncoefficient and iniP\ntializing all other coefficients to the equal superposition a |ai will yield the output\nE|\u03c8i.\nCorrection, Detection and Erasures As mentioned above, the classical RS codes\nhave efficient decoding algorithms for identifying and decoding the maximum number\nof errors which is information-theoretically possible, i.e. t where d = 2t + 1 is the\nminimum distance. Consequently, so do the quantum polynomial codes, since for css\ncodes one simply corrects errors in each of the two bases.\nThey can also detect up to 2t errors, at the expense of correction. Simply measure\na received codeword to see if its syndrome is 0. If a non-zero Pauli operator of weight\nless than d has been applied to the word, the syndrome will be non-zero, and the\nerror will be detected. For an arbitrary error of weight less than d, the projection of\nthe corrupted word onto the code will be exactly the original codeword.\nRemark 1. In some of our protocols, we will want to detect a large number of errors,\nbut still be able to correct a small number. Suppose that we have identified b positions\nwhich are known to be corrupted (for example, say they have been erased). Then the\nquantum polynomial code will be able to identify t further errors, and will able to\ncorrect them if there are at most t \u2212 b.\n(That is, the punctured code (i.e. restricted to the n \u2212 b non-erased positions)\nhas distance 2t + 1 \u2212 b. Given a corrupted word, one can tell if it is within t \u2212 b of a\ncodeword, and correct such errors. If it is not within distance t\u2212b of a codeword, then\nmore errors occurred. However, as long as less than t errors occurred, the corrupted\nword will not be within t \u2212 b of anything but the correct codeword, since t + (t \u2212 b)\nis less than the new minimum distance).\n\n1.3.2\n\nSharing Quantum Secrets and (No) Cloning\n\nOne of the fundamental theorems of quantum information theory is that an arbitrary\nquantum state cannot be cloned. In fact, one can say more: if there is a process with\none input and two outputs, then if one of the outputs is a copy of the input, the\nother output must be independent of the input. We're not sure to whom this result is\nattributable but it has certainly become folklore.\n27\n\n\fFact 1.3 (No cloning, folklore). Let U : Hm \u2297 HW \u2212\u2192 HA \u2297 HB (6 ) be a unitary\ntransformation such that for all |\u03c8i \u2208 Hm :\nU(|\u03c8i \u2297 |W i) = |\u03c8i \u2297 |\u03c6|\u03c8i i\nwhere |W i is some fixed auxiliary state (work bits). Then |\u03c6|\u03c8i i does not depend on\n|\u03c8i.\nAn important consequence of this was first pointed out by Cleve, Gottesman and\nLo [CGL99]: any quantum code is a scheme for sharing quantum secrets: A distance d\ncode can correct d \u2212 1 erasures, and so access to any n \u2212 d + 1 (uncorrupted) positions\nsuffice to recover the encoded state; on the other hand, that means that any set of\nd \u2212 1 positions must reveal no information at all about the encoded state. That is,\nthe density matrix of any d \u2212 1 positions is completely independent of the data.\nNote that this phenomenon has no simple classical analogue: any position of a\nclassical error-correcting code will leak information about the data unless the encoding\nprocess is randomized. This additional step is not necessary in the quantum setting\nsince the randomness is somehow \"built in.\"\n\n1.3.3\n\nTools from Fault-Tolerant Quantum Computing\n\nIn our proposed solution, we also use techniques developed for fault-tolerant quantum computing (ftqc). The challenge of ftqc is to tolerate non-malicious faults\noccurring within a single computer. One assumes that at every stage in the computation, every qubit has some probability p of suffering a random error, i.e. of becoming\ncompletely scrambled (this corresponds to the classical notion of random bit flips occurring during a computation). Moreover, errors are assumed to occur independently\nof each other and of the data in the computation. See Section 1.1 for a discussion\nof the difference between ftqc and mpqc. In this section, we review a number of\nuseful results from ftqc. These come from [Sho96, AB99, GC99].\nUniversal Sets of Gates The usual technique behind fault-tolerant computing\n(both classical and quantum) is to design procedures for applying one of a small\nnumber of gates to logical (i.e. encoded) values, without having to actually decode\nthe values and then re-encode them. That is, given the encoding state |\u03c8i, we want\na simple procedure which returns the encoding of state U|\u03c8i.\nThus, it is useful to find a small set of gates which is universal, i.e which suffices\nto implement any desired function7 . One can then simply design fault-tolerant procedures for implementing these gates, and compose them to obtain a fault-tolerant\nprocedure for any particular function.\n6\n\nNote that in fact the mW system and the AB system are one and the same. The two labelings\nsimply reflect a different partitioning of the system.\n7\nIn fact, it is impossible to find a finite set which can implement any unitary operation perfectly.\nHowever, one can approximate any unitary operation on a constant number of qubits to accuracy \u01eb\nusing O(poly log 1\u01eb ) gates from a \"universal\" set, i.e. one which generates a group which is dense in\nthe space of all unitary operators.\n\n28\n\n\fFor qupits of prime dimension p, Aharonov and Ben-Or [AB99] showed that the\nfollowing set of gates is universal:\n1. Generalized NOT (a.k.a. X): \u2200 c \u2208 F , |ai 7\u2212\u2192 |a + ci,\n2. Generalized CNOT (Controlled Addition): |a, bi 7\u2212\u2192 |a, a + bi,\n3. Swap |ai|bi 7\u2212\u2192 |bi|ai,\n\n4. Multiplication gate: 0 6= c \u2208 F : |ai 7\u2212\u2192 |aci,\n\n5. Phase Shift (a.k.a. Z): \u2200c \u2208 F |ai 7\u2212\u2192 w ca|ai,\n6. Generalized Hadamard (Fourier Transform): |ai 7\u2212\u2192\n\n7. Generalized Toffoli: |ai|bi|ci 7\u2212\u2192 |ai|bi|c + abi,\n\n\u221a1\np\n\nP\n\nb\u2208F\n\nw rab |bi, \u22000 < r < p.\n\nBeyond these, in order to simulate arbitrary quantum circuits one should also be\nable to introduce qupits in some known state (say |0i), as well as to discard qupits.\nNote that these are sufficient for simulating measurements, since one can simply apply\na controlled-not with a state |0i as the target and then discard that target.\nTransversal Operations Fortunately, several of these gates can be applied transversally, that is using only \"qupit-wise\" operations. These are important since they\ncorrespond to operations performed locally by the players in a multi-party protocol,\nif each player shares has one component of an encoded state.\nFor example: in any css code, the linear gate |a, bi 7\u2212\u2192 |a, a + cbi can be applied\nto two encoded qupits by applying the same gate \"qupit-wise\" to the two codewords.\nFor any css code, the gates 1 through 5 from the set above can be implemented\ntransversally [Sho96, AB99].\nRemark 2. Another operation which can almost be performed transversally is measurement in the computational basis. The encoding of a classical state |si in a css\ncode is the equal superposition of all the words in some particular coset of V0 = W \u22a5\nwithin V . Thus, measuring all the qupits of the encoding of |si will always yield\naPcodeword from that coset. Similarly, measuring all the qupits of the encoding of\n2\ns \u03b1s |si will yield a word from the coset corresponding to s with probability |\u03b1s | .\nThis operation is not quite transversal since after the qupit-wise measurement, the\nclassical information must be gathered together in order to extract the measurement\nresult. Nonetheless, the quantum part of the processing is transversal, and this will\nbe good enough for our purposes.\nTransversal Fourier Transforms and the Dual Code In general, applying the\nFourier transform transversally to a codeword from a css code C does not yield a\n \u0303 If C is\nword from that code. Instead, one obtains a word from the \"dual code\" C.\ndefined by the classical codes V and W , then C \u0303 is the css code obtained using the\ncodes W and V . A natural choice of encoding for the dual code yields the following\nrelation:\nF \u2297n EC |\u03c8i = EC \u03b4\u2032 (F |\u03c8i)\n29\n\n\f\u2032\n\nwhere EC and EC \u03b4\u2032 are the encoding operators for C and C \u03b4 respectively.\nFor polynomial codes of degree \u03b4, recall that there is related degree \u03b4 \u2032 = n \u2212 \u03b4 \u2212 1.\n\u2032\n\u2032\nAs one can observe from the dual codes W \u03b4 , W0\u03b4 , the dual code Ce\u03b4 is a \"mangled\"\n\u2032\nversion of the code C \u03b4 . In fact, by scaling each Fourier transform with the (non-zero)\nfactor di , one obtains:\nF d EC \u03b4 |\u03c8i = EC \u03b4\u2032 (F |\u03c8i)\n\u2032\n\nNote that when n is exactly 2\u03b4 + 1, the codes C \u03b4 and C \u03b4 are the same, and so the\nFourier transform on encoded data can in fact be applied transversally: F d EC \u03b4 |\u03c8i =\nEC \u03b4 (F |\u03c8i).\n\nTransversal Reductions to Degree Reduction for \u03b4 < n/3 As mentioned\nabove, the only operations that cannot, in general, be performed transversally on\nReed-Solomon codes are the Fourier transform and Toffoli gate. However, when \u03b4 is\nless than n/3, [AB99] reduces both of them to the problem of degree reduction, which\ninvolves mapping the encoding of |\u03c8i under the dual code C\u03b4\u2032 to the encoding of |\u03c8i\nunder the original code C\u03b4 .\nFor the Fourier transform, the reduction is obvious: we showed above that by performing (scaled) Fourier transforms transversally to EC\u03b4 |\u03c8i, one obtains EC\u03b4\u2032 (F |\u03c8i).\nThus, performing degree reduction would produce EC\u03b4 (F |\u03c8i), which is the desired\nresult.\nFor the Toffoli gate, note that \u03b4 < n/3 implies that \u03b4 \u2032 = n \u2212 \u03b4 \u2212 1 is at least\n2\u03b4. The underlying idea is simple: suppose we have three polynomials p, q, r of\ndegree such that p(0) = a, q(0) = b and r(0) = c. Take the polynomial r \u2032 given by\nr \u2032 (i) = r(i) + p(i)q(i) for all i = 1, ..., n. First, note that if p, q have degree at most \u03b4\nand r has degree at most \u03b4 \u2032 \u2265 2\u03b4, then deg(r \u2032 ) < \u03b4 \u2032 . Moreover, if p, q, r are random\npolynomials subject to the above constraints, then p, q, r \u2032 will also form a random\ntriple of polynomials, which interpolate to the values a, b, c + ab.\nTo map this to a procedure for implementing the Toffoli gate, suppose that we\nhave the encodings of |ai and |bi using the code C \u03b4 . Suppose that we also have the\n\u2032\nencoding of |ci using the related code C \u03b4 . By applying the Toffoli gate qupit-wise,\nwe obtain the encoding of c + ab under the related code:\nEC \u03b4 |aiEC \u03b4 |biEC \u03b4\u2032 |ci 7\u2212\u2192 EC \u03b4 |aiEC \u03b4 |biEC \u03b4\u2032 |c + abi\nThus, to implement the Toffoli gate fault-tolerantly it is sufficient to have an\nimplementation of the two maps EC \u03b4 |\u03c8i 7\u2212\u2192 EC \u03b4\u2032 |\u03c8i and EC \u03b4\u2032 |\u03c8i 7\u2212\u2192 EC \u03b4 |\u03c8i. Note\nthat this is equivalent to having a procedure for just one map EC \u03b4\u2032 |\u03c6i 7\u2212\u2192 EC \u03b4 |\u03c6i,\nsince one can simply apply the Fourier transform first and its inverse afterwards to\nreverse the direction.\nImplementing Degree Reduction The circuit we use for degree reduction is due\nto Gottesman and Bennett [Got] (based on [GC99]), and is much more efficient than\nthe original one proposed in [AB99]. Begin with the state to be transformed (call this\nsystem H1 ) and an ancilla in state EC \u03b4 |0i (called H2 ).\n30\n\n\f1. Apply controlled addition from H1 to H2 .\n2. Apply the scaled Fourier transform transversally to H1 .\n3. Measure H1 in the computational basis, obtaining b.\n4. Apply a conditional phase shift with scaling factor \u2212b to H2 .\nThe effect of this on the basis state EC |ai (for a \u2208 Zp ) is:\nX\nEC |aiEC \u0303|0i 7\u2192 EC |aiEC \u0303|ai 7\u2192\n\u03c9 ab EC |biEC \u0303|ai\nb\nab\n\n7\u2192 \u03c9 EC \u0303|ai(with b known) 7\u2192 EC \u0303|ai\n\nThis procedure in fact works for arbitrary linear combinations (intuitively, this is\nbecause the measurement result b yields no information about a).\nNote that this entire procedure can be performed transversally except for the\nmeasurement step. However, as noted above (Remark 2), measurement requires only\nclassical communication between the components (namely, each component is mea\u2032\nsured and the classical decoding algorithm for the code V \u03b4 is applied to the result).\n\n1.4\n\nNeighborhoods of Quantum Codes\n\nOne of the ideas behind classical multi-party computing protocols is to ensure that\ndata is encoded in a state that remains \"close\" to a codeword, differing only on those\npositions held by cheaters, so that error correction and detection can be used to\ncorrect any tampering, or at least detect it and identify its origin.\nFor classical codes, the notion of closeness is clear: the set of positions on which\na real word v differs from a codeword provides a lot of information; in particular, the\nsize of this set is the Hamming distance of v from the code. As long as the minimum\ndistance of the code is at least 2t, ensuring that v differs from a codeword only on\nthe positions held by cheaters means that any errors introduced by cheaters will be\ncorrectable.\nGiven a set B of cheaters (B \u2286 {1, ..., n}), we define:\nWB = {v : \u2203w \u2208 W s.t. supp(v \u2212 w) \u2208 B}\n= {v : \u2203w \u2208 W s.t. v differs from w only on positions in B}\nEquivalently, one can define WB as the set of words obtained by distributing a\n(correct) codeword to all players, and then having all players send their shares to\nsome (honest) receiver/reconstructor.\nRemark 3. VB is a linear code, and its dual is exactly the set of words in V \u22a5 which\nhave support included in the complement of C (say A = {1, ..., n} \\ B). In particular,\nthis means that if one wants to measure the VB -syndrome, one only needs access to\npositions in A.\n31\n\n\fFor quantum codes, the situation is more complex. For a css code C, there is\nmore than one natural definition of the neighborhood corresponding to a set B of\npositions. Let H = H1 \u2297 * * * \u2297 Hn be partitioned according to two sets A, B, so that\nH = HA \u2297 HB . We consider three definitions of an \"B-neighborhood\" of C. Let \u03c1 be\nan arbitrary state of H.\nFor a mixed state given by density matrix \u03c1\u2032 , we say \u03c1\u2032 is \"in\" C if all states in the\nmixture lie in C (no matter how the mixture is written). Algebraically, this is given\nby the condition Tr(PC \u03c1\u2032 ) = 1 where PC is the projector onto the subspace C.8\n1. \u03c1 differs from a state in C only by some super-operator local to B:\nNB (C) = {\u03c1 : \u2203\u03c1\u2032 in C, \u2203O super-operator, acting only on HB s.t. \u03c1 = O(\u03c1\u2032 )}\n2. \u03c1 is cannot be distinguished from a state in C by looking only at positions in A.\nAlgebraically, this is captured by requiring that the density matrix obtained by\n\"tracing out\" the positions in B be the same as for some state in the code (the\nnotation ST stands for \"same trace\"):\nSTB (C) = {\u03c1 : \u2203\u03c1\u2032 in C s.t. TrB (\u03c1) = TrB (\u03c1\u2032 )}\n3. Specifically for css codes, one could simply require that the state \u03c1 pass checks on\nA in both bases, i.e. that measuring either the VB -syndrome in the computational\nbasis, or the WB -syndrome in the Fourier basis, would yield the result 0. The set\nof states which pass this test is:\n(q)\n\n(q)\n\nCB = VB \u2229 F \u2297n WB .\nThese notions form a hierarchy, namely NB (C) \u2286 STB (C) \u2286 CB . (The first inclusion holds since super-operators local to B do not change the density matrix of the\ncomponents in A. The second inclusion holds since the outcome distribution of any\ntests local to A is determined entirely by TrB (\u03c1).) However, the three notions are\ndistinct and in fact only one of them-notion (3)-always describes a linear subspace\nof H. We discuss these three notions further in Appendix A.\nIn the analysis of quantum error-correction and fault-tolerance protocols, it is\nsufficient to consider notion (1). This stems from two reasons. On one hand, one\nstarts from a correctly encoded state. On the other hand, the errors introduced by\nthe environment will be independent of the encoded data (and in fact they must be\nfor error-correction to be possible at all in that context).\nIn our setting, however, we cannot make such assumptions, since the cheaters\nmight possess states which are entangled with the data in the computation, and so\nthe errors they introduce will not be independent of that data. Instead, the main\nP\nP\nTo see why this is the case, write \u03c1\u2032 = i pi |\u03c8i ih\u03c8i | with h\u03c8i |\u03c8j i = \u03b4ij and i pi = 1. Then all\nthe |\u03c8i i's are in C if and only if h\u03c8i |PC |\u03c8i i = 1. Taking the trace over the matrix PC \u03c1 yields 1 if and\nonly if this condition holds.\n8\n\n32\n\n\fcontribution of this paper is the construction of protocols which guarantee conditions\nsimilar to (3) above. In Section 2.1, we illustrate the ideas with a simple protocol,\ndubbed subspace projection, which is sufficient for vqss and mpqc when t < n/8.\nIn Section 2.2, we give a vqss protocol tolerating t < n/4, and we show that this\ntolerance is optimal in Section 2.3. Finally, in Section 2.4, we show how to ensure\ncondition (3) above and how the techniques from fault-tolerant computing can then\nbe used to achieve multi-party computation of an arbitrary quantum circuit when\nt < n/6.\n\n1.4.1\n\nWell-Definedness of Decoding for States in CB\n\nIn this section we prove a property of CB which will be useful in the proof of security\n(and hopefully also provide some intuition for our construction).\nSuppose that the minimum distance of C is d > 2t + 1, and B is restricted in size:\n|B| < t. Then applying the usual decoding circuit for C without knowing exactly\nwhere B is yields the same result as applying an ideal interpolation circuit which first\ndiscards positions in B and then reconstructs the logical data as if it was handling\na regular codeword. Formally, there are two natural \"reconstruction operators\" for\nextracting the secret out of a state which has been shared among several players.\n1. D is the decoding operator for the error-correcting code C. For any operator Ej\nof weight less than t and for any state |\u03c6\u0304i in C, we have DEj |\u03c6i = |\u03c6i \u2297 |ji (i.e.\nthe error is not only corrected but also identified). It will then discard the system\ncontaining the syndrome information |ji.\n\n2. RI is the \"ideal recovery operator\", defined by identifying the set B of cheaters and\napplying the simple interpolation circuit to a set of n \u2212 2t good players' positions.\nProposition 1.4. For any state \u03c1 in CB where |B| \u2264 t, the state RI (\u03c1) is well-defined\nand is equal to D(\u03c1).\nWe give the proof of this below. For now, note that Proposition 1.4 means that no\nchanges made only to the components in B-no matter how they might be made to\ninteract with outside systems entangled with the data-will change the reconstructed\nstate.\nIn order to prove Proposition 1.4, we characterize CB algebraically:\n(q)\n\n(q)\n\nLemma 1.5. Suppose that \u03c1 has fidelity 1 to CB = VB \u2229 F \u2297n WB . Then we can\nwrite\nP\n\u03c1 = i pi |\u03c8i ih\u03c8i |\nP\n|\u03c8i i = j cij Ej |\u03c6ij i\nwhere Ej are Pauli operators on B and |\u03c6ij i \u2208 C.\n\n(q)\n\nRecall that given a state \u03c1, testing if \u03c1 is in VB is easily described: For each\nelement of (a basis of) the dual space VB\u22a5 , we measure the corresponding linear\n33\n\n\fcombination of the qupits of \u03c1 in the computational basis, and check that it is 0.\n(q)\nRecall that the vectors of the dual space VB have support only on A (since arbitrary\nchanges to positions in B should not affect whether or not a word is in VB ), and so one\nneed not have access to the components in A in order to perform the measurement.\n(q)\nSimilarly, to check if \u03c1 is in F \u2297n WB , we rotate into the Fourier basis and measure\nthe linear combinations corresponding to a basis of WB\u22a5 .\nNote that since VB\u22a5 \u2286 V \u22a5 and WB\u22a5 \u2286 W \u22a5 , and since measuring the V -syndrome\nin the computational basis commutes with measuring the W -syndrome in the Fourier\nbasis, we know that the following four measurements commute:\n1. VB -syndrome in the computational basis\n2. V -syndrome in the computational basis\n3. WB -syndrome in the Fourier basis\n4. W -syndrome in the Fourier basis\nProof (of Lemma 1.5): As was just mentioned, to check if \u03c1 is in CB , we measure\nthe VB -syndrome in the computational basis and the WB -syndrome in the Fourier\nbasis. But by the remarks above, the distribution on this outcome measurement\nwill not change if we first measure the V and W syndromes, i.e. if we first make\na measurement which projects \u03c1 into one of the subspaces Ej C (i.e. \u03c1 maps to\n\u03c1\u2032 = Pj \u03c1Pj with probability Tr (Pj \u03c1), where Pj is the projector for the space Ej C).\nThe new state \u03c1\u2032 lies completely in one of the spaces Ej . However, Ej C is either\ncontained in CB (if there is an operator equivalent to Ej which acts only on B) or\northogonal to CB (if no such operator exists).\nThus, for \u03c1 to have fidelity 1 with CB , it must be that Tr (Pj \u03c1) = 0 for all Ej\nwhich act on more than B. Hence \u03c1 is a mixture of states |\u03c8i i each of which is a\nlinear combination of elements of the spaces {Ej C}, where Ej acts only on B. \u2737\nProof (of Proposition 1.4): Consider a particular basis state Ej E|ai. The decoding\noperator D will produce the state |ai|ji, since errors of weight at most t can be\nidentified uniquely. The ideal operator RI will extract the encoded state |ai. Without\nloss of generality, the ideal recovery operator will replace |ai with |0i, the final output\n|ai \u2297 Ej E|0i.\nIn both cases, the output can be written as |ai tensored with some ancilla whose\nstate depends only on the syndrome j (and which identifies j uniquely). Once that\nstate is traced out, the outputs of both operators will be identical. Another way to\nsee this is that the ideal operator can simulate the real operator: one can go from the\noutput of the ideal operator to that of the real operator by applying a transformation\nwhich only affects thePancilla. For a state \u03c1 expressed as in Lemma 1.5, the final\noutcome will be \u03c1\u2032 = ij pi |cij |2 |\u03c6ij ih\u03c6ij |. \u2737\n\n34\n\n\fChapter 2\nDistributed Protocols for Quantum\nComputers\n2.1\n\nSubspace Projection\n\nBefore presenting the main vqss protocol, we describe a protocol for a simpler task\nthat we call subspace projection, which illustrates the key ideas in the vqss protocol.\nNamely, we first modify a classical protocol of [CCD88] so that the dealer does not\nhave to remember the random bits he used in sharing his secret. Second, we apply\nthis protocol both in the computational and Fourier bases. We use a \"quantum-toclassical\" argument to show that this garantees that the joint state shared by the\nplayers satisfies condition (3) from the discussion on neighborhoods, i.e. that the\njoint state passes certain local checks in both bases.\nRecall that for any given system of n qupits and any linear subspace W of F n = Znp ,\nwe define\nW (q) = span{|wi : w \u2208 W }.\nFor this protocol, W can be any code with minimum distance 2t + 1 and an efficient\ndecoding algorithm. However, for concreteness, let W be the RS code V \u03b4 , where\nn = 4t + 1 and \u03b4 = 2t.\nLet H0 , . . . , Hk be separate quantum systems consisting of n qupits each, and let\nH = H0 \u2297 * * * \u2297 Hk . Say the dealer prepares H in some state and gives the ith qupit\nof each subsystem Hj to player i. He wants to prove to the group that in fact the\nfidelity of H0 to the space W (q) is close to 1 1 , without revealing any information\nbeyond that to the other players. What we achieve in this first step is not quite that\nstrong: at the end of the protocol, there will be a publicly known set B of \"apparent\ncheaters\" such that the shares of the honest players not in B will all agree with W\n(q)\nin the computational basis, i.e. will have high fidelity to the space WB\u222aC .\nWe obtain a \"cut-and-choose\" protocol, also similar to the \"random hashing\"\n1\n\nIt would be desirable to be able to prove that the fidelity is in fact exactly 1. This remains\nan interesting open question. This corresponds to the classical difference between zero-error and\nsmall-error protocols.\n\n35\n\n\ftechnique used in purification protocols (Protocol 3, Figure 2-1). Note that vss and\nbroadcast of classical data are not a problem since t < n4 < n3 ([BGW88, CCD88,\nLyn96]).\n\nProtocol 3 (Subspace projection).\n1. Sharing The dealer D prepares H0 as any state (pure or mixed) in W (q) andP\ndistributes\nit to the players. He then prepares H1 , . . . , Hk in the equal superposition of w\u2208W |wi,\nand distributes those to the players also.\n2. Verification Using classical vss, every player commits to k field elements picked uniformly at random. These commitments are then opened and their sum is taken to obtain\nk field elements b1 , . . . , bk (these are completely unpredictable to the dealer, even if he\nis cheating).\n3. For l = 1, . . . , k, players apply the linear operation (x, y) 7\u2192 (x, y+bl x) to the subsystems\nH0 and Hl . All players then measure their shares of H1 , . . . , Hk in the computational\nbasis and broadcast the result.\n4. Each of the broadcasted words w1 , . . . , wk is decoded using classical error-correction of\nthe code W : for each wl , we obtain either that it was at distance more than t from a\nword in W or we obtain an error vector with support Bl \u2208 {1, ..., n} of size less than t\non which wl differs from a word in W .\nThe dealer\nis rejected if any of the broadcasted words was at distance more than t or if\nS\nB = kl=1 Bl has size greater than t. Otherwise, the dealer is accepted.\n\nFigure 2-1: Protocol 3 (Subspace Projection)\n\n2.1.1\n\nCompleteness\n\nLemma 2.1. When the dealer D is honest, he will pass the protocol. Moreover, we\nwill have B \u2286 C, i.e. only real cheaters will be accused of cheating.\nProof: P\nIf the dealer is honest, he will use some H0 in W (q) and will have all Hl 's\nin state w\u2208W |wi. Consider some round l. Now no matter what the value of bl is,\napplying (c-X bl ) to all of the shares is equivalent to the identity on H0 \u2297 Hl , since\nfor all v \u2208 W , we have:\nX\nX\nX\n(c-X bl )|vi\n|wi = |vi\n|w + bl vi = |vi\n|wi\nw\u2208W\n\nw\n\nw\n\nOf course, in the protocol we can only guarantee that honest players will apply\nto their shares of H0 and Hl . Nonetheless, the result is the same as applying the\nidentity to the honest players' shares. Consequently, the values broadcast at Step 3\n\n(cbXl )\n\n36\n\n\fby the honest players will all be consistent with some w \u2208 W . Since we've assumed\nthat the distance of the code W is at least 2t + 1, any false values broadcast by\ncheaters will be identified as such. Thus, the set B will only contain cheaters, and\nthe dealer will pass the protocol. Moreover, the honest players' shares of H0 will also\n(q)\nbe preserved, so H0 will remain in WC . \u2737\n\n2.1.2\n\nSoundness\n\nLemma 2.2. Let B\u0303 = B \u222a C. At the end of the protocol above, the fidelity of the\nsystem to the statement \"either H0 is in (WB\u0303 )(q) or the dealer has been rejected\" is\nexponentially close to 1 in k.\nTo prove this, we will employ a \"quantum to classical\" reduction, as in [LC99].\nLemma 2.3. Consider the subspace projection protocol above. Then the behavior of\nthe protocol is the same in each of the two following experiments:\nExperiment 1 at the end of the whole protocol, all honest players measure their\nshares of H0 in the computational basis, or\nExperiment 2 at the end of the sharing phase, all honest players measure their\nshares of H0 and H1 in the computational basis, and then run the verification\nphase.\nMoreover, the distribution on the results of the measurement of H0 is the same in\nboth cases.\nProof: The actions of the honest players on their shares in the original protocol can\nbe seen as the composition of k super-operators, each of which is comprised of two\noperations: a controlled-addition gate from H0 to Hl followed by measurement of Hl .\nDenote the controlled-addition gate by (c-X b )l , where b is the scaling factor for the\ncontrolled-addition. Second, denote measurement of Hl in the computational basis\nby Ml .\nConsider what happens in the lth verification step in Experiment 1. Because the\ncontrolled-addition gate is a permutation of the basis states of the computational\nbasis, measuring the systems in that basis before the gate is applied will not change\nthe outcome of measurements made after the gate is applied. Thus we can write\nMl M0 (c-X bl )l = Ml M0 (c-X bl )l Ml M0 , and the distribution of the measurements\nmade after the gate is applied will not change.\nBut now notice that measuring the system M0 afterwards is completely redundant. Because the controlled-addition gate does not change the first component of any\nbasis vectors, measuring M0 after the application of the gate will yield the same result\nas measuring it before. Hence, we can write Ml M0 (c-X bl )l = Ml (c-X bl )l Ml M0 .\nHowever, this is exactly the sequence of operations performed by honest players in\nExperiment 2: first they measure both systems, then apply the addition gate and\nmeasure the target.\n37\n\n\fThus, the measurement outcomes will be the same in both experiments will be\nthe same. Moreover, the cheaters can see no difference between the two experiments,\nand so their behavior will not change. \u2737\nIn other words, we can imagine two situations. In the first one, just after the\nsharing phase of the protocol, an outsider comes in and secretly measures honest\nplayers' shares of H0 , . . . , Hk in the computational basis. In the second, the outsider\nperforms this secret measurement after the protocol is completed. The statement\nis that exactly when he makes his measurement will not change the behavior of the\nprotocol.\nBut recall that our original statement of the correctness of the protocol is that,\nat the end of the protocol, either the dealer has been caught or the shares of players\n(q)\n(q)\nare in WB\u0303 . Since fidelity to WB\u0303 is the same as the probability that measuring in\nthe computational basis gives a word in WB\u0303 (i.e. agrees with W when truncated to\npositions neither in B nor C), Lemma 2.3 allows us to restrict ourselves to thinking\nabout situations in which the shares of the systems H0 , . . . , Hk sent to honest players\nwere in fact classical states.\nNow consider the classical protocol corresponding to the subspace projection protocol: the dealer distributes k + 1 codewords w0 , . . . , wk . At each step, a random\nmultiple of w0 is added to one of the other codewords and the result is broadcast. At\nthe end, players compute B as above and decide whether or not to reject the dealer.\n(This is the blob protocol of [CCD88], modified so as not to require the involvement\nof the dealer beyond the sharing stage).\nLemma 2.4 (Soundness of Modified Blobs from [CCD88]). At the end of classical protocol, let A be the set of honest players not in B. The event \"either the players\nin A have consistent shares or the dealer was caught\" occurs with probability at least\n1 \u2212 2n\u2212k , even when the adversary is adaptive.\nProof: Note that this statement is the same as Pr(the players in A do not have\nconsistent shares and the dealer was not caught)< 2n\u2212k .\nRecall that the adversary is adaptive, and can choose which set of players to\ncorrupt on the fly. Nonetheless, the adversary's strategy can be reduced to choosing\nthe set A of players who will be neither corrupted (\u2208 C) nor accused (\u2208 B), but\nsuch that w0 is not consistent on A, while the broadcast vectors wl + bl w0 are all\nconsistent.\nFix any particular set A. If the shares of w0 are not consistent on A, then there is\nat most a single value bl \u2208 F such that the shares of wl + bl w0 broadcast by players\nin A will be consistent, since the set of consistent vectors is a subspace. Thus, the\nprobability of the dealer passing the tests with that set A is at most |F1|k . Overall,\nthere are at most 2n choices for the subset A, and so the adversary's total probability\nof being able to find a subset A of honest players for which cheating is possible is\nn\nbounded above by |F2 |k \u2264 2n\u2212k . \u2737\nThis completes the proof of Lemma 2.2.\n\n38\n\n\fRemark 4. As mentioned in the Definitions, we do not handle adaptive adversaries\nexplicitly in this thesis. However, we believe that our protocols are secure against\nan adaptive adversary, and the previous proof gives some flavor of how the classical arguments can be used. In this case, a union bound argument was sufficient.\nFor proving the security of the quantum protocols, a more sophisticated version of\nthe quantum-to-classical reduction above (Lemma 2.3) would be necessary (and, we\nbelieve, sufficient).\n\n2.1.3\n\nDual Subspace Projection\n\nConsider a \"dual\" version of the subspace projection protocol above. It is the same\nas the original protocol, with three changes:\n1. Before proceeding to the verification phase all players apply the Fourier transform\nto all their shares.\n2. At the end all players apply the inverse Fourier transform to their shares of H0 .\n3. (When D is honest) D prepares theP\nancillas H1 , ..., Hk as a superposition over all\nwords from the dual code W \u22a5 (i.e. w\u2208W \u22a5 |wi).\nP\nP\nNow the state w\u2208W \u22a5 |wi is the image of w\u2208W |wi under transversal Fourier\ntransforms. Thus, we can use the same analysis as in the previous section. At the\nend of this \"dual\" protocol, the fidelity of the system to the statement \"either the\n(q)\ndealer is caught or H0 is in the space F \u2297n WB\u0303 \" is high.\nBut recall that conjugating by Fourier rotations maps linear gates to linear gates\n(see Section 1.3). In particular, controlled addition gates simply have their direction\nreversed, i.e. source and target are swapped. Thus, the modifications to the original\nsubspace projection protocol can be restated as follows:\n1. the controlled addition gates are performed from Hl to H0 ;\n2. the measurements are made in the rotated (Fourier) basis;\n3. (When D is honest) D prepares theP\nancillas H1 , ..., Hk as a superposition over all\nwords from the dual code W \u22a5 (i.e. w\u2208W \u22a5 |wi).\n\n\"One-Level\" Sharing and vqss for t < n/8 Now suppose that there is some\nother code V such that before the protocol begins, all the systems H0 , . . . , Hk are\n(q)\nin VB\u0303 . Then that property will not be affected by the protocol since the addition\ngates will not affect it. Thus, at the end of the protocol the shares of H0 would be in\n(q)\n(q)\nCB\u0303 = VB\u0303 \u2229 F \u2297n WB\u0303 .\nThis leads to a first pass at a quantum sharing protocol: Have the dealer distribute\nk + 1 groups of k + 1 systems. In each group, use k of the systems to prove that\n(q)\nthe remaining system lies in VB\u0303 using the subspace projection protocol. Next, take\nthe k + 1 resulting systems, and use k of them to prove that one of them is also in\n(q)\nF \u2297n WB\u0303 using the \"dual\" protocol.\n39\n\n\fIntuitively, this combination of the subspace projection protocol and the dual\nprotocol achieves vqss when t < n/8: since both the sets of apparent cheaters and of\nreal cheaters have size at most t, the protocol allows the dealer to guarantee that the\nshared state is in CB\u0303 where |B\u0303| < n/4. Since the decoding operator is well-defined on\nsuch states (Proposition 1.4), the dealer is essentially committed to a unique value\nregardless of any changes the players make subsequently.\nIn the next section, we extend the ideas of this section, combining them with\nthe classical vss protocol of [CCD88] to obtain a vqss protocol which is secure for\nt < n/4. We also show how to prove equivalence of that protocol to the ideal-model\nprotocol of Section 1.2.6.\n\n2.2\n\nVqss Protocol: Two-Level Quantum Sharing\n\nIn this section we define a two-tiered protocol for vqss. It is based on the vqss\nprotocols of [CCD88] as well as on the literature on quantum fault-tolerance and\nerror-correction, most notably on [AB99].\nWe first define the classical notion of \"correctness\" of a sharing used in [CCD88],\nand give a modified version of the [CCD88] vss protocol that does not require the\ndealer's participation. We then describe our vqss protocol (Section 2.2) and prove its\nsecurity (Section 2.2.4\u2013Section 2.2.6). Finally, we state the round and communication\ncomplexity of our protocol (Section 2.2.7) and some additional useful properties of\nthe sharings it generates (Section 2.2.8).\n\n2.2.1\n\nSharing Shares: 2-good Trees\n\nIn the vss protocol of [CCD88], the dealer D takes his secret, splits it into n shares\nand gives the ith component to player i. Player i then shares this secret by splitting\nit into n shares and giving player j the j th share to player j. Thus, there are n2 total\nshares, which can be thought of as the leaves of a tree with depth 2 and fan-out n:\neach leaf is a share; the ith branch corresponds to the shares created by player i, and\nthe root corresponds to the initial shares created by the dealer. Thus player j holds\nthe j th leaf in each branch of this tree.\nWe will run a cut-and-choose protocol similar to the subspace projection protocol\nabove, in order to guarantee some kind of consistency of the distributed shares.\nDuring the protocol we accumulate n + 1 sets of apparent cheaters: one set B for\nthe dealer (this corresponds to a set of branches emanating from the root), and one\nset Bi for each player i (this corresponds to a subset of the leaves in branch i). These\nsets all have size at most t.\nN.B.: Since the dealer is one of the players in the protocol, we can in fact identify\nB with Bi , where the dealer is player i. However, by ignoring this fact we lose\nno correctness and gain some simplicity in the exposition and security proof of the\nprotocol.\nAt the end of the protocol, we want to guarantee certain invariants:\n\n40\n\n\fDefinition 4 (2-good trees). We say a tree of n2 field elements is 2-good with\nrespect to the code V and the sets B, B1 , ..., Bn if:\n1. For each i 6\u2208 C (corresponding to an honest player), we have Bi \u2286 C, i.e. all\napparent cheaters are really cheaters.\n2. For each branch i 6\u2208 B, the shares held by the honest players not in Bi should all\nbe consistent with some polynomial of degree \u2264 d, i.e. with some codeword in V .\nThat is, the vector of all shares should be in VBi \u222aC , where C is the set of cheating\nplayers.\nN.B.: Because there are at most t players in Bi and at most t cheaters, there are\nat least d + 1 \u2264 n \u2212 2t honest players remaining, and so the polynomial above is\nuniquely defined. This guarantees that for each branch i 6\u2208 B, there is a unique\nvalue ai \u2208 F which is obtained by interpolating the shares of the honest players not\nin Bi .\n3. For i 6\u2208 B, the values ai defined by the previous property are all consistent with a\ncodeword of V (i.e. the vector (a1 , ..., an ) is in VB ).\nWe will abbreviate this as 2-goodV , when the sets B, B1 , ..., Bn are clear from the\ncontext.\nWhy is this a useful property to guarantee? It turns out that this ensures the\nsoundness of a sharing protocol. Suppose that all players broadcast their shares of a\ngiven 2-good tree. Call the vector of shares in the ith branch vi , so that player j holds\nthe values vi (j) for all i. Consider the reconstruction procedure Recover (Figure 2-2).\n\nAlgorithm 1. Recover(T, V, B, B1 , ..., Bn )\nInput: a tree T which is 2-good with respect to the code V and the sets B, B1 , ..., Bn .\nOutput: a \u2208 F\n1. For each branch i 6\u2208 B: Let b = |Bi |. If i is honest, then we expect the truncated\nword vi |B\u0304i to be within distance t \u2212 b of a codeword in the truncated code V |B\u0304i .\nNow this truncated code has distance 2t + 1 \u2212 b: it can detect up to t errors and\ncorrect them when there are at most t \u2212 b of them.\nIf the truncated word vi |B\u0304i is at distance at most t \u2212 b from a real codeword, then\ncorrect the error and let ai be the interpolated value for that codeword. Otherwise\noutput a null value ai =\u22a5.\n\n2. Take any set of d + 1 indices i such that i 6\u2208 B and ai 6=\u22a5. Find the unique\npolynomial p such that p(i) = ai . Output a = p(0) as the reconstructed secret.\nFigure 2-2: Algorithm 1 (Reconstruction for a 2-good tree)\n\n41\n\n\fLemma 2.5. Suppose that a sharing is 2-good. If all players broadcast their shares,\nthen the same value a will always be reconstructed for the root of the tree (i.e. regardless of the values broadcast by the cheaters).\nWe omit this proof here, since it is essentially re-proven in our analysis of the\nquantum protocol (see Lemma 2.11). We note that the protocols (and proofs) of\n[CCD88] used this lemma implicitly, but did not use the recovery algorithm as stated\nhere. Instead, they required players to remember what shares they had distributed\nto other players.\n\n2.2.2\n\nClassical Vss\n\nBased on the discussion of the previous section, we give a modified version of the\nvss protocol of [CCD88]. The main difference is that the original protocol required\na dealer to remember the values of the shares sent in the first phase, and cooperate\nlater on during the verification phase. However, this does not generalize well to\nthe quantum world, and so we compensate by exploiting the efficient decodability of\nReed-Solomon codes. The protocol is given in Figure 2-3. Note that as before, the\nerror-correcting code we use is V \u03b4 , where n = 4t + 1 and \u03b4 = 2t.\nRemark 5. In the description of the protocol (and subsequent protocols), we assume\nfor simplicity that there is a source of public randomness. This is not a problem in\nour setting as good random bits can be generated using classical vss protocols, and\nit simplifies the analysis of the protocols. However, it is not necessary (and is not\nmade in [CCD88, RB89]). See Section 2.2.7 for further discussion.\nThe correctness and soundness of this protocol are stated here. They follow from\nthe properties of 2-good trees and from cut-and-choose analysis.\nFact 2.6. If D is honest, he will pass the protocol with probability 1, and the shares\nv0,i (j) will form a 2-good tree which interpolates to the original input a.\nFact 2.7. With probability 1 \u2212 2\u03a9(k) , either the shares v0,i (j) form a 2-good tree or\nthe dealer is caught during the protocol.\n\n2.2.3\n\nVqss Protocol\n\nGiven the previous protocol, and the observation that Subspace Projection can work\nsimultaneously in both bases (Section 2.1.3), it is natural to attempt to run the\nclassical vss to check for errors in both bases. The resulting protocol is described\nin Figure 2-4 (Sharing Phase) and Figure 2-5 (Reconstruction Phase). Intuitively, it\nguarantees that a tree of quantum shares would yield a 2-good tree of classical values\nif measured in either the computational basis or the Fourier basis. Note that we use\n\u2032\n\u2032\nthe codes V = V \u03b4 = V \u03b4 and W = W \u03b4 = W \u03b4 (again with n = 4t + 1, \u03b4 = \u03b4 \u2032 = 2t),\nalthough there is in fact no need to do this: the protocol will work for any css code\nwith distance at least 2t + 1, so long as the code is efficiently decodable.\n42\n\n\fProtocol 4 (Modified Classical vss from [CCD88]). The dealer D has input a \u2208 F .\n\u2022 Sharing:\n1. D picks a random codeword v0 \u2208 V such that v0 interpolates to a. D also picks k\nrandom codewords v1 , ..., vk \u2208 V (i.e. k sharings of random values).\n\n2. D gives player i the ith component of each of these vectors: vl (i) for l = 0, ..., k.\n\n3. Player i shares each of these values with random vectors v0,i , ..., vk,i which interpolate\nto v0 (i), ..., vk (i), respectively. He sends the values vl,i (j) to player j (for l = 0, ..., k).\n\u2022 Verification: Get k previously unknown public random values b1 , ..., bk . For l = 1, ..., k:\n1. For all i, player j broadcasts vl,i (j) + bl v0,i (j).\n(i.e. player j broadcasts his share of vl,i + bl v0,i ).\n2. For each i \u2208 {1, ..., n}, players update the set Bi based on the broadcast values, as in\nthe subspace projection protocol. If there are too many errors, then they add i to the\nglobal set B.\n3. Furthermore, players do the same at the branch level: for all i 6\u2208 B, there is an\ninterpolated value ai which corresponds to the decoded codeword from the previous\nstep. Players also decode the codeword (a1 , ..., an ) and update B accordingly (i.e. by\nadding any positions where errors occur to B).\n\u2022 The dealer is disqualified if B is ever larger than t.\n\u2022 If the dealer passes, the values v0,i (j) are taken to be the shares of the dealer's secret.\n\u2022 Reconstruction:\n1. Player j broadcasts his shares v0,i (j) for all i.\n2. Let T be the tree defined by these values. All players output the value given by\nRecover(T, V, B, B1 , ..., Bn ).\n\nFigure 2-3: Protocol 4 (Modified vss protocol from [CCD88])\n\n43\n\n\fProtocol 5 (vqss-Sharing Phase). Dealer D gets as input a quantum system S to\nshare.\n\u2022 Sharing:\n1. The dealer D prepares (k + 1)2 systems of n qupits each, called Sl,m (for l = 0, ..., k\nand m = 0, ..., k):\n(a) Encodes S using C in S0,0 .\nP\nP\n(b) Prepares k systems S0,1 , ..., S0,k in the state a\u2208F EC |ai = v\u2208V |vi.\n(c) Prepares\nP k(k + 1) systems Sl,m, for l = 1, ..., k and m = 0, ..., k, each in the state\n|0\u0304i = v\u2208V0 |vi.\n(i)\n\n(d) For each of the (k + 1)2 systems Sl,m , D sends the ith component (denoted Sl,m )\nto player i.\n2. Each player i, for each l, m = 0, ...k:\n(i)\n\n(a) Encodes the received system Sl,m using C into an n qupit system Sl,m,i .\n(j)\n\n(b) Sends the j-th component Sl,m,i to player j.\n\u2022 Verification:\n1. Get public random values b1 , ..., bk \u2208R F . For each l = 0, ..., k, m = 1, ..., k, each\nplayer j:\n(a) Applies the controlled-addition gate (c-X bj ) to his shares of the systems Sl,0,i\nand Sl,m,i .\n(b) Measures his share of Sl,m,i and broadcasts the result\n(i.e. each player broadcasts k(k + 1)n values).\n(c) Updates sets B and B1 , ..., Bn as in the classical vss protocol.\n2. All players apply the Fourier transform F to their shares.\n\n3. Get public random values b\u20321 , ..., b\u2032k \u2208R F . For l = 1, ..., k, each player j:\n\u2032\n\n(a) Applies the controlled-addition gate (c-X bj ) to his shares of the systems S0,0,i\nand Sl,0,i .\n(b) Measures his share of Sl,0,i and broadcasts the result\n(i.e. each player broadcasts kn values).\n(c) Updates sets B and B1 , ..., Bn as in classical vss protocol. Note that for all l,\nwe use code W = V0\u22a5 .\n[Note: the sets B and B1 , ..., Bn are cumulative throughout the protocol.]\n\n4. All players apply the inverse transform F \u22121 to their shares of S0,0 .\n\u2022 The remaining shares (i.e. the components of the n systems S0,0,i ) form the sharing of\nthe state \u03c1.\n\nFigure 2-4: Protocol 5 (vqss-Sharing Phase)\n\n44\n\n\fProtocol 6 (vqss-Reconstruction Phase). Player j sends his share of each of the\nsystems S0,0,i to the receiver R, who runs the following decoding algorithm:\n1. For each branch i: determine if there is a set B\u0303i such that Bi \u2286 B\u0303i , B\u0303i \u2264 t and the\nshares of S0,0,i lie in CB\u0303i .\nIf not, add i to B.\nOtherwise, correct errors on B\u0303i and decode to obtain a system Si\u2032 .\n2. Apply interpolation to any set of n \u2212 2t points not in B. Output the result S \u2032 .\n\nFigure 2-5: Protocol 6 (vqss-Reconstruction Phase)\n\nWhy is this a secure vqss protocol? We want to show that the protocol is equivalent to the \"ideal model\", where at sharing time the dealer sends his secret system\nS to a trusted outside party, and at reveal time the trusted party sends S to the\ndesignated receiver. To do that, we will use two main technical claims:\n\u2022 Soundness: At the end of the protocol, if the dealer passes all tests then there is\na unique state which will be recovered by the receiver, regardless of any changes\nmade by the cheating players.\n\u2022 Completeness (simplistic version): If the dealer is honest, then he will pass all tests\nand the state recovered by the receiver will be exactly the dealer's input system\nS.\nAt first, it may not be clear that the claim above for completeness is really sufficient, since it does not explicitly rule out the adversary learning any information\nabout the secret system S. In fact, at some intuitive level it is sufficient, since any information the adversary was able to learn would cause a disruption of S (in general).\nNonetheless, a formal proof of security requires a more sophisticated argument. We\ngive the more formal proof, based on simulation, in Section 2.2.6.\n\n2.2.4\n\n(Informal) Soundness\n\nLemma 2.8. The system has high fidelity to the following statement: \"Either the\ndealer is caught or measuring all shares in the computational (resp. Fourier) basis\nwould yield a 2-good tree with respect to the code V (resp. W ).\"\nProof: The proof of this lemma follows the ideas outlined in the proof of soundness\nfor the subspace projection protocol. First, a quantum-to-classical reduction allows us\nto use the soundness of the modified classical protocol from Section 2.2.2: this gives us\nthat at the end of Step 1, either D would get caught or all the systems Sl,0 would yield\n2-goodV trees if measured in the computational basis. After applying the Fourier\n45\n\n\ftransformations in Step 2, all the systems will be 2-goodV in the Fourier basis.\nSubsequent application of linear gates will not change that, since they correspond\nto linear gates in the Fourier basis. Finally, applying a second quantum-to-classical\nreduction shows that at the end of Step 3, the system S0,0 will be 2-goodW in the\ncomputational basis. Since it is also 2-goodV in the Fourier basis, the final rotation\nin Step 4 will leave it 2-goodV in the computational basis and 2-goodW in the\nFourier basis. \u2737\nLet E denote the operator used to encode a state using C. Let J be a set of indices\nj such that the error operators {Ej }j\u2208J run over all the syndromes of the code C (i.e.\nJ contains one representative from each equivalence class of error operators, and the\nn\nspaces {Ej C}j\u2208J are orthogonal and span Cp ). Note that |J| = pn\u22121 since the code\nis 1-dimensional.\n2\n\nFact 2.9. The following set is an orthonormal basis of pn -dimensional Hilbert space\nn2\nCp (where p is the size of F ):\no\nn\n(1)\n(n) \u2297n\nEj1 * * * Ejn E Ej0 E|ai : j0 , ..., jn \u2208 J, a \u2208 F\nwhere the superscript\n\n(i)\n\non Eji indicates that it acts on the ith block of n qupits.\n\nProof: First, notice that these vectors are indeed pairwise orthogonal: for a pair of\nvectors, if any of the indices ji \u2208 J differ for i \u2265 1, we can distinguish the two states\nby measuring the syndrome of the ith block of qubits. If none of the ji differ but the\nindices j0 differ, then we can distinguish the two states by correcting all the errors\n(i)\nEji , decoding the resulting blocks and measuring the syndrome of the final codeword.\nFinally, if the two states differ only by the choice of a \u2208 F , we can distinguish them by\ncorrecting all errors, decoding and measuring the resulting qupit in the computational\nbasis.\nOn the other hand, there are pn\u22121 choices for each of the n+ 1 indices j0 , ..., jn \u2208 J\n2\nn+1\nand p choices for a \u2208 F . Thus the total number of states is (pn\u22121 )\np = pn , and so\nn2\nthe states must span all of Cp . \u2737\nProposition 2.10 (Characterizing 2-good trees). The space of trees of qupits\nwhich are 2-goodV in the computational basis and 2-goodW in the Fourier basis is\nspanned by the states\n(1)\n(n)\nEj1 * * * Ejn E \u2297n Ej0 E|ai where\n\u2022 Ej0 (or something in its equivalence class) acts only on B and\n\u2022 For each i 6\u2208 B, Eji (or something in its equivalence class) acts only on Bi \u222a C.\n(Recall that for i corresponding to honest players not in B, we have Bi \u2286 C and\nso in those cases the condition is that Eji act only on C.)\nProof: Given any state of n2 qupits, we can write it as a mixture of linear combinations of basis vectors from the basis in the previous discussion (Fact 2.9). Now for any\n46\n\n\fone of these basis states given by j0 , ..., jn and a, it will pass a test of 2-good-ness in\nboth bases if and only if the conditions of the proposition are satisfied: j0 should be\nthe syndrome of some error which acts only on B and each ji should be equivalent to\nan error on Bi \u2229 C. Thus, any state which passes the test with probability 1 can in\nfact be written only in terms of those basis vectors which pass the test. \u2737\nNote that in the case of the basis vectors of the previous proposition, there is\nno entanglement between the data and the errors, since the data is a pure state (in\nfact, we can also think of the errors as being described by a pure state |j0 , ..., jn i).\nHowever, one can get arbitrary superpositions of these basis vectors and so in general\nthere will be not only correlation, but indeed entanglement between the data and the\nerrors.\nIdeal Reconstruction In order to prove soundness carefully, we define an ideal\ninterpolation circuit RI for 2-good trees: pick the first n \u2212 2t honest players not in\nB, say i1 , ..., in\u22122t . For each ij , pick n \u2212 2t honest players not in Bij and apply the\nnormal interpolation circuit (i.e. erasure-recovery circuit) for the code to their shares\nto get some qupit Rij . This will yield n \u2212 2t qupits total. Applying the interpolation\ncircuit again, we extract some system S which we take to be the output of the ideal\ninterpolation. For simplicity, we assume that the interpolation circuit extracts the\nencoded state and replaces it with an encoding of |0i, i.e. it maps E|ai 7\u2212\u2192 |ai \u2297 E|0i.\nLemma 2.11. Given a tree of qupits which is 2-good in both bases, the output of\nthe ideal interpolation and the real recovery operators are the same. In particular,\nthis means that no changes made by cheaters to their shares of a 2-good tree can\naffect the outcome of the recovery operation.\nNote that this is not necessarily true for a \"one level\" sharing (Section 2.1.3),\nunless t < n/8: by entangling errors with the shared data, the cheaters could arrange\nthings so that more than t errors are detected only for certain possible values of the\ndata, creating an entanglement between the data and the success or failure of the\nrecovery.\nProof (of Lemma 2.11): Both the decoding and recovery operators produce an output\nqubit as well as an ancilla. We show that there is a unitary map which can be applied\nto the ancilla of the interpolation operator so that the joint state of the output and\nthe ancilla are the same as when the decoding operator is applied.\nIt is sufficient to prove this for some basis of the space of 2-good trees; the rest\nfollows by linearity. The natural basis is given by Proposition 2.10. Consider a basis\n(n)\n(1)\nvector Ej1 * * * Ejn E \u2297n Ej0 E|ai which satisfies the conditions of Proposition 2.10.\nEffect of ideal recovery Let I be the set of n\u22122t indices not in either B or C, and\nsuppose for simplicity that I = {1, ..., n \u2212 2t} (the same argument works regardless\nof the particular values in I). Applying the ideal recovery operator to the branches\nin I, we obtain n \u2212 2t encodings of |0i with errors j1 , ..., jn\u22122t , and an encoding\n47\n\n\fof |ai whose first n \u2212 2t positions are untouched and whose last 2t positions are\nthemselves encoded and possibly arbitrarily corrupted. This can be written:\n\u0001\n\u0001\n(n\u22122t+1)\n(n)\n(Ej1 E|0i) \u2297 * * * \u2297 Ejn\u22122t E|0i \u2297 Ejn\u22122t+1 * * * Ejn I\u2297(n\u22122t) E \u22972t Ej0 E|ai\n\nwhere I is the identity. Applying ideal recovery again to the first n \u2212 2t positions\nof the encoding of |ai, we extract |ai and leave a corrupted encoding of |0i:\n\u0011\n\u0010\n\u0001\n\u0001\n(n\u22122t+1)\n(n)\n|ai \u2297 (Ej1 E|0i) \u2297 * * * \u2297 Ejn\u22122t E|0i \u2297 Ejn\u22122t+1 * * * Ejn I\u2297(n\u22122t) E \u22972t Ej0 E|0i\nEffect of real reconstruction Now consider the effect of the decoding operator,\nwhich must be applied without knowledge of the positions which are corrupted.\nThe first operation to be performed is to attempt to decode each branch i 6\u2208 B.\nThis means copying the syndrome ji for each branch into an ancilla state |ji i.\nWhenever Eji acts on a set B\u0303i such that |B\u0303i \u222a Bi | \u2264 t, then Eji can be identified\nand corrected. When Eji acts on too many positions, then it cannot be identified\nuniquely and the decoding procedure will simply leave that branch untouched.\nLet I be the set of indices not in B which had few enough errors to correct. At\nthe end of this first phase the input basis state will become:\n!\nY (i) \u0001\nO\nEji E \u2297n Ej0 E|ai \u2297\n|ji i\ni\u2208I\n\ni6\u2208I\n\nWe know that all the honest players not in B are in I (by assumption of 2-goodness) and so I contains at least n \u2212 2t positions. Decoding each of these circuits\nand applying the interpolation operator to the resulting qupits, we can extract the\nstate |ai and replace it with |0i in the top-level sharing. This yields\n!\nO\nY (i) \u0001\nEji E \u2297n Ej0 E|0i \u2297\n|ji i\n|ai \u2297\ni\u2208I\n\ni6\u2208I\n\nIn both cases, the output can be written as |ai tensored with some ancilla whose\nstate depends only on the syndromes j0 , j1 , ..., jn . Once that state is traced out, the\noutputs of both operators will be identical. Another way to see this is that the ideal\noperator can simulate the real operator: one can go from the output of the ideal\noperator to that of the real operator by applying a transformation only to the ancilla.\n\u2737\nLemma 2.8 and Lemma 2.11 together imply that there is essentially a unique state\nwhich will be recovered in the reconstruction phase when the receiver R is honest.\nThus, the Protocol 5 is sound, in the informal sense of Section 2.2.3.\n\n48\n\n\f2.2.5\n\n(Informal) Completeness\n\nAs discussed earlier, the protocol is considered complete if when the dealer is honest,\nthe state that is recovered by an honest reconstructor is exactly the dealer's input\nstate.\nLemma 2.12. When the dealer D is honest, the effect of the verification phase on\nthe shares which never pass through cheaters' hands is the identity.\nProof: This follows essentially by inspection:\nP for any codeword v of a linear code\nW , applying a controlled addition to |vi \u2297 w\u2208W |wi results in the identity. Since\nthis operation is transversal, the shares which never go through cheaters' hands will\nbehave as if the identity gate was applied. \u2737\nConsider the case where the dealer's input is a pure state |\u03c8i. On one hand, we\ncan see by inspection that an honest dealer will always pass the protocol. Moreover,\nsince the shares that go through honest players' hands only remain unchanged, it\nmust be that if some state is reconstructed, then that state is indeed |\u03c8i, since the\nideal reconstruction operator uses only those shares. Finally, we know that since the\ndealer passed the protocol the overall tree must be 2-good in both bases, and so some\nvalue will be reconstructed. Thus, on input a pure state |\u03c8i, an honest reconstructor\nwill reconstruct |\u03c8i. We have proved:\n\nLemma 2.13. If D and R are honest, and the dealer's input is a pure state |\u03c8i, then\nR will reconstruct a state \u03c1 with fidelity 1 \u2212 2\u2212\u03a9(k) to the state |\u03c8i.\nNot surprisingly, this lemma also guarantees the privacy of the dealer's input. By\na strong form of the no cloning theorem (Section 1.3.2) , any information the cheaters\ncould obtain would cause some disturbance, at least for a subset of the inputs. Thus,\nthe protocol is in fact also private.\n\n2.2.6\n\nSimulatability\n\nThe previous two sections prove that the protocol satisfies an intuitive definition of\nsecurity, namely that it is complete, sound and private. In this section, we sketch\na proof that the protocol satisfies a more formal notion: it is equivalent to a simple\nideal model protocol. The equivalence is statistical (Definition 2), that is the outputs\nof the real and ideal protocols may not be identical, but have very high fidelity to\none another.\nAn Ideal Model Protocol Now, it is fairly simple to give an ideal protocol for\nvqss: in the sharing phase, the dealer D sends his system S to T T P. If D does\nnot cooperate or sends an invalid message, T T P broadcasts \"D is a cheater\" to all\nplayers. In the reconstruction phase, T T P sends the system S to the designated\nreceiver R. This protocol is in fact given in Protocol 2 (p. 22).\nIntuitively, this is the most we could ask from a secret sharing protocol: that it\nfaithfully simulates a lock box into which the dealer drops the system he wishes to\nshare.\n49\n\n\fIn order to show equivalence of our protocol to the ideal protocol, we will give\na transformation that takes an adversary A1 for our protocol and turns it into an\nadversary A2 for the ideal protocol. To give the transformation, we exhibit a simulator\nS which acts as an intermediary between A1 and the ideal protocol, making A1 believe\nthat it is in fact interacting with the real protocol.\nSimulation Outline\nWe give a sketch of the simulation procedure in Algorithm 2 (Figure 2-6).\nWhy does this simulation work?\n\u2022 When D is cheating:\n\u2013 When R is cheating, the simulation is trivially faithful, since there is no difference between the simulation and the real protocol: S runs the normal sharing\nprotocol, then runs the interpolation circuit, sending the result to TTP. In the\nreconstruction phase, S gets the same state back from TTP, and runs the interpolation circuit backwards. Thus, the two executions of the interpolation circuit\ncancel out.\n\u2013 When R is honest, the faithfulness of the simulation comes from Lemma 2.11:\nin the real protocol, R outputs the result of the regular decoding operator. In\nthe simulation, R gets the output of the ideal interpolation. Since the shared\nstate has high fidelity to a 2-good tree (by Lemma 2.8), the outputs will be\nessentially identical in both settings (i.e. they will have high fidelity).\n\u2022 When D is honest:\n\u2013 To see that the simulation works when D is honest, we must show that two\nversions of the protocol are equivalent: in the first version, S gets S after having\nsimulated the sharing phase with A1 , and so he \"swaps\" it in by first running\nthe ideal interpolation circuit, exchanging the system S for the shared state |0i,\nand then running the interpolation circuit backwards.\nIn the second version, he gets the system S from T T P before running the\nsimulated sharing phase, and so he simply runs it with S as the input for the\nsimulated dealer D \u2032 .\nTo see that the two versions are equivalent, view the \"swap\" as an atomic\noperation, i.e. view the application of the interpolation, switching out the |0i\nstate and replacing it with S, and reapplying the interpolation backwards, as a\nsingle step. Now consider moving the swap backwards through the steps of the\nprotocol. Because each of the verification steps acts as the identity on the shares\nof the honest players, we can move the swap backwards through all verifications\n(Note: the verification acts as the identity only when the dealer is honest, but\nthat is indeed the case here). Finally, one can see by inspection that sharing\na |0i and then swapping is the same as sharing the system S. Thus the two\nversions of the protocol are equivalent, and so the simulation is faithful when D\nis honest.\n50\n\n\fAlgorithm 2. Simulation for vqss (Protocol 5)\nSharing/Verification phase\n\u2022 If D is a cheater, S must extract some system to send to T T P:\n\n1. Run Sharing and Verification phases of Protocol 5, simulating honest players. If\nD is caught cheating, send \"I am cheating\" from D to T T P.\n2. Choose n \u2212 2t honest players not in B and apply ideal interpolation circuit to\nextract a system S.\n3. Send S to T T P.\n\n\u2022 If D is honest, S does not need to send anything to T T P, but must still simulate the\nsharing protocol.\n\n1. Simulate an execution of the Sharing and Verification phases of Protocol 5, using\n|0i as the input for the simulated dealer D \u2032 .\n2. Choose n \u2212 2t honest players (they will automatically not be in B since they are\nhonest) and apply the ideal interpolation circuit to extract the state |0i.\n3. The honest D will send a system S to T T P.\nNote: Regardless of whether D is honest or not, at the end of the sharing phase of the\nsimulation, the joint state of the players' shares is a tree that is (essentially) 2-good in\nboth bases, and to which the ideal interpolation operator has been applied. Let I be the\nset of n \u2212 2t honest players (not in B or C) who were used for interpolation.\nReconstruction phase\n\u2022 If R is a cheater, S receives the system S from T T P. He runs the interpolation circuit\nbackwards on the positions in I, with S in the position of the secret. He sends the\nresulting shares to R.\n\u2022 If R is honest, the cheaters send their corrupted shares to S. These are discarded by\nS.\nIn both cases, S outputs the final state of A1 as the adversary's final state.\n\nFigure 2-6: Algorithm 2 (Simulation for vqss)\n\n51\n\n\fWe have essentially proved:\nTheorem 2.14. Protocol 5 is a statistically secure implementation of verifiable quantum secret sharing (Protocol 2).\n\n2.2.7\n\nRound and Communication Complexity\n\nIn this section we show how to reduce the complexity of the protocol. For now, we\nwill continue to assume that all public coins are generated using classical vss: all\nplayers commit to a random value, then open all their values and take the sum to be\nthe public coin. We discuss removing this assumption below.\nReducing the Number of Ancillas The first observation is that with these cutand-choose protocols, it easy to check many trees at once for 2-good-ness, so long\nas they were all generated by the same dealer. Suppose that we want to verify l\ntrees of quantum shares for 2-good-ness in a certain basis.P The dealer distributes\nthe trees, and then creates k sharings of the ancilla state\n|ai (as in the original\nprotocol). In the original protocol, for each ancilla we chose a random coefficient\nb \u2208 F and performed the gate (x, y) 7\u2192 (x, y + bx). In the new protocol, we add a\nrandom linear combination of all l states to be checked into the ancilla: each challenge\nconsists of l coefficients b1 , ..., bP\nl chosen publicly at random. We apply the linear gate\n(x1 , ..., xl , y) 7\u2192 (x1 , ..., xl , y + bj xj ) to the l trees and the ancilla. The resulting\nstate is then measured in the computational basis and all players broadcast their\nshares.\nTo ensure good soundness, we can run this protocol k times in parallel, i.e. using\nk different ancillas and k * l random coefficients (i.e. k challenges of l coefficients).\nEssentially the same analysis as in the previous sections shows that at the end of this\nprotocol (with high fidelity) the dealer will have been caught or the shared states will\nall be 2-good in the computational basis.\nWe can use this observation to improve the efficiency of our vqss protocol. The\ndealer shares his secret S and also shares 2k ancillas. He uses the first k ancillas to\ncheck both the target state and the remaining k ancillas for consistency in the Fourier\nbasis. He then uses the remaining ancillas to check the target state in the computational basis. The number of ancillas now scales linearly (instead of quadratically)\nbut the protocol still requires a quadratic number of public values.\nGeneration of Public Values In the preceding discussion we assumed that public\nvalues were truly random. Such truly random coins can be implemented in our model\nusing classical vss, but in fact they need not be. As pointed out in [CCD88, RB89],\nit is sufficient to have players take turns generating challenges.\nSuppose that each player broadcasts nk random challenges, and all players apply\nthe challenge and measure and broadcast the result, as before. Then we are guarchallenges will be chosen truly at random. Thus,\nanteed that at least k \u2032 = k n\u2212t\nn\nn\nby increasing k by a factor of n\u2212t we get the same soundness as before, and avoid\nexpensive vss protocols.\n52\n\n\fThe final protocol takes three rounds, two of which use the broadcast channel.\nEach player sends and receives kn log |F | qubits. Moreover, the broadcast channel\ngets used k times to send challenges of (roughly) k log |F | bits. It is also used to\nbroadcast k responses of n log |F | bits. To have soundness \u01eb, we must have the\nnumber of truly random challenges be k \u2032 \u2265 n+O(loglogn)+log(1/\u01eb)\n.\n|F |\n\u0010\n\u0011\n(n+log 1\u01eb )2\nn\nSince n\u2212t is constant, we get quantum communication complexity O n log |F |\n\u0010\n\u0011\nn+log 1\nper player and overall broadcast complexity O (n + log 1\u01eb )(n + n log |F\u01eb| ) . This is\nn+log\n\n1\n\noptimized when each player broadcasts only a single challenge, i.e. log |F | = n \u01eb .\nIn that case, we get quantum communication\u0001complexity O(n + log 1\u01eb ) per player and\noverall broadcast complexity O n(n + log 1\u01eb ) .\n\n2.2.8\n\nAdditional Properties of Two-Level Sharing\n\nLevel 2 sharings produced by the same dealer (using the protocol above) have some\nadditional properties, which will be useful for multi-party computation. First of\nall, notice that there is no problem in tracking the sets B, B1 , ..., Bn across various\ninvocations of the protocol for the same dealer. Because set Bi corresponds to the\nset of players which player i has accused of cheating, we may take these sets as\ncumulative, and simply declare that a player is cheating whenever the union of all\nthe set Bi (for the same i) is greater than t. Similarly for the set B. Thus, in the\ndiscussion below we assume that the sets B, B1 , ..., Bn are the same for all invocations\nwith a particular dealer.\n\u2032\n1. Say the systems Si,j , Si,j\nform valid two-level sharings of states \u03c1, \u03c1\u2032 respectively\n(where Sij corresponds to player j's share of branch i).\n\u2032\nThen applying the linear operation (x, y) \u2192 (x, y + bx) to the systems Si,j \u2297 Si,j\nresults in valid two-level sharings of the states obtained by applying the gate to\nthe state \u03c1 \u2297 \u03c1\u2032 .\n\nIn other words, if we denote the reconstruction procedure by R and the controlledaddition by c-X b , we get that\n(c-X b )R\u22972 = R\u22972 (c-X b )\u2297n\n\n2\n\n(at least when restricted to the subspace of valid sharings).\n2. Say the systems Si,j form valid two-level sharings of state \u03c1 with respect to the\ncodes V, W . Then applying F to each of the shares results in a valid sharing of\nthe state F \u03c1F \u2020 with respect to the codes W, V .\nThat is, if RV,W is the reconstruction procedure which uses code V in the computational basis and W in the Fourier basis, then when we restrict to the subspace\nof valid sharings we get:\n2\nF RV,W = RW,V F \u2297n\n53\n\n\f3. If all players measure their shares in a valid sharing of \u03c1 and then apply classical\nreconstruction, then they will obtain the same result as if they had sent their shares\nto an honest reconstructor and asked him to broadcast the result of measuring \u03c1.\n4. The dealer can use the protocol to additionally prove to all players that the system\nhe is sharing is the exactlyPthe state |0i: the ancillas he uses in this case will all be\nsharings of |0i (instead of |ai). The verification step is the same as before, except\nnow players verify that the reconstructed codeword at the top level interpolates to\n0.\nP\nSimilarly, the dealer can prove that he is sharing a state a |ai by ensuring that all\nancillas used for verification in the Fourier basis are in state |0i, and again asking\nplayers to verify that the reconstructed codeword at the top level interpolates to\n0 for the checks in the Fourier basis.\nThis last point is worth stressing:\nby tailoring the protocol, the dealer can verP\nifiably share states |0i and a |ai. This will be useful for sharing ancillas in the\nmulti-party computation protocol.\n\n2.3\n\nImpossibility of vqss when t \u2265\n\nn\n4\n\nLemma 2.15. No vqss scheme exists for 4 players which tolerates one cheater.\nBefore proving this, we need a result from quantum coding theory, on the relation\nbetween error-correction and erasure-correction:\nFact 2.16 (t-error correction and 2t-erasure correction). Suppose that a quantum code with n components, and dimension at least 2 can correct errors on any t\npositions. Then in fact C can correct erasures on any 2t positions.\nNote that this holds regardless of the dimensions of the individual components of\nthe code. It also holds when the code in question is a \"mixed state\" code, i.e. some\npure states are nonetheless encoded as mixed states by the encoding procedure.\nIt's an interesting and useful property of quantum information that it cannot be\ncloned, i.e. there is no procedure which takes an arbitrary, unknown pure state |\u03c8i\nand replaces it with two exact copies |\u03c8i \u2297 |\u03c8i (see Section 1.3.2). A corollary of\nthis is that no quantum code with n components can withstand the erasure of \u2308n/2\u2309\ncomponents. If it could, then one could always separate the codeword into two halves\nand reconstruct a copy of the encoded data with each half, yielding a clone of the\nencoded data. By the equivalence of t-error-correction and 2t-erasure-correction, this\nmeans that there is no quantum code that can correct errors on any \u2308n/4\u2309 positions.\nThis is a special case of the quantum Singleton bound, also called the Knill-Laflamme\nbound.\nProof (of Lemma 2.15): Suppose such a scheme exists. Consider a run of the protocol\nin which all players behave perfectly honestly until the end of the sharing phase. At\nthat point, their joint state can be thought of as a (possibly mixed-state) encoding\n54\n\n\fof the secret that was shared. In particular, an honest \"receiver\" Ruth, if she were\ngiven access to the state of all players, must be able to recover the shared state.\nMoreover, she must be able to do so even if one player suddenly decides to start\ncheating and introduces arbitrary errors into his state. Thus, the joint state of all\nplayers constitutes a four-component qecc correcting one error. However, no such\ncode exists, not even a mixed-state one, by the quantum Singleton bound. \u2737\nCorollary 2.17. No vqss scheme exists tolerating an adversary structure that contains four sets which cover all players.\nProof: Suppose there exist four disjoint sets A, B, C, D such that A\u222aB \u222aC \u222aD = P ,\nand a vqss scheme tolerating any adversary that can corrupt any one of those sets.\nThen we can construct a four player protocol tolerating one cheater by having each\nplayer simulate the players in one of the four sets. \u2737\nThe optimality of our vqss scheme is also an immediate corollary:\nTheorem 2.18. No vqss scheme for n players exists which tolerates all coalitions\nof \u2308n/4\u2309 cheaters.\nNote that we have only proved the impossibility of perfect vqss protocols. However, both the no cloning theorem and the equivalence of t-error-correction and 2terasure-correction hold when exact equality is replaced by approximate correctness,\nand so in fact even statistical vqss schemes are impossible when t \u2265 n/4.\n\n2.4\n\nMulti-party Quantum Computation\n\nIn this section we show how to use the vqss protocol of the previous section to\nconstruct a multi-party quantum computing scheme.\nFirst, we give a modified vqss protocol. At the end of the protocol, all players\nhold a single qupit. With high fidelity, either the dealer will be caught cheating or the\nshares of all honest players will be consistent in both the computational and Fourier\nbases, i.e. there is no set B of \"apparent cheaters\".\n\n2.4.1\n\nLevel 3 Sharing Protocol\n\nUntil now, we have used protocols for tolerating t < n/4 cheaters. However, we are\nnow interested in tolerating t < n/6 cheaters. Thus, we take n = 6t + 1 for simplicity,\nand as before we set \u03b4 = 2t (thus \u03b4 \u2032 = 4t). We will work with the css code C given by\n\u2032\nV = V \u03b4 and W = W \u03b4 . Recall that this is the css code for which we have the simple,\nnearly-transversal fault-tolerant procedures of Section 1.3.3. Our goal is to share a\n(q)\n(q)\nstate so that at the end all shares of honest players lie in CC = VC \u2229 F \u2297n WC .\nThe new scheme is given in Protocol 7 (Figure 2-7). The idea is that the previous\nvqss scheme allows distributed computation of linear gates and Fourier transforms\non states shared by the same dealer. It also allows verifying that a given shared state\n55\n\n\fProtocol 7 (Top-Level Sharing). Dealer D takes as input a qupit S to share.\n\u2022 Sharing\n1. (Distribution) The dealer D:\n(a) Runs the level 2 vqss protocol on input S.\n(b) For i = 1, ..., \u03b4:\nP\nRuns level 2 sharing protocol to share state a |ai (see Remark 4 in Section 2.2.8)\n(c) For i = 1, ..., n \u2212 \u03b4 \u2212 1:\nRuns level 2 sharing protocol to share state |0i (see Remark 4 in Section 2.2.8)\n\nDenote the n shared\nsystems by S1 , ..., Sn (i.e. S1 corresponds to S, S2 , ..., S\u03b4+1\nP\ncorrespond to\n|ai\nand S\u03b4+2 , ..., Sn correspond to |0i). Note that each Si is a\na\ntwo-level tree, and thus corresponds to n components in the hands of each player.\n\n2. (Computation) Collectively, the players apply the Vandermonde matrix to their\nshares of S1 , ..., Sn .\n(If D is honest then system Si now encodes the i-th component of an encoding of the\ninput system S).\n3. For each i, all players send their shares of Si to player i.\n\u2022 Quantum Reconstruction Input to each player i is the share Si and the identity of\nthe receiver R.\n1. Each player i sends his share Si to R.\n2. R outputs D(S1 , ..., Sn ) and discards any ancillas.\n\nFigure 2-7: Protocol 7 (Top-Level Sharing)\n\n56\n\n\fP\nis either |0i or\n|ai. The players will use this to perform a distributed computation\nof the encoding gatePfor the code C. Thus, the dealer will share the secret system S,\nas well as \u03b4 states\n|ai and n \u2212 \u03b4 \u2212 1 states |0i. Players then apply the (linear)\nencoding gate, and each player gets sent all shares of his component of the output.\nLemma 2.19. At the end of Step 2, the system has high fidelity to \"either the dealer\nis caught or measuring all n trees in the computational (resp. Fourier) basis yields a\nforest of n 2-goodV (resp. 2-goodW ) trees whose implicitly defined classical values\nv1 , ..., vn lie in V (resp. W ).\nProof: This follows from the linearity of the sharings generated by the vqss scheme.\n\u2737\nCorollary 2.20 (Soundness of Top-Level Protocol). At the end of the sharing\nphase (i.e. after Step 3), the system has high fidelity to \"either the dealer is caught\nor the n shares of players S1 , ..., Sn lie in CC \".\nProof: This is because the \"rolling back\" of the shares (i.e reconstruction of their\nrespective components by all players) preserves measurement statistics in both bases.\n\u2737\nLemma 2.21 (Completeness of Top-Level Protocol). When D is honest, on input a pure state |\u03c8i, the shared state will lie in span {E|\u03c8i}C , i.e. will differ from an\nencoding of \u03c8 only by a local operation on the cheaters' shares.\nNotice that the dealer can also prove to all players that he has shared a |0i state\nby simply proving that the system he is placing in the input position is in state |0i.\nSimulatability and Ideal Secret Sharing The top-level protocol (Protocol 7) is\na simulatable vqss protocol, just as was the original protocol. As before, the idea\nis that there is no perceivable difference between (a) running the protocol on input\n|0i and having the simulator \"swap in\" the real shared system S and (b) running the\nprotocol honestly.\nHowever, the top-level protocol is also a simulatable implementation of a different\n(and stronger) one-phase ideal task, which we call \"ideal secret sharing\" (Figure 2-8).\nIn it, the dealer D sends his system S to the T T P, and the T T P encodes it using\nthe quantum error-correcting code C and sends the i-th component to player i.\nThe details of the simulation are substantially similar to those of Section 2.2.6.\nWe get:\nTheorem 2.22. The top-level protocol (Protocol 7) is a statistically secure real-world\nimplementation of ideal secret sharing (Protocol 8), for any t < n/4 (and thus in\nparticular for t < n/6).\n57\n\n\fProtocol 8 (Ideal Secret Sharing). Input: Dealer D gets a qupit S.\n1. D sends the |F |-dimensional system S to T T P. If D fails to do this, T T P broadcasts\n\"D is cheating\" to all players.\n2. T T P encodes D in C. That is:\nP\n(a) T T P creates \u03b4 states a |ai and n \u2212 \u03b4 \u2212 1 states |0i.\n\n(b) T T P runs the linear encoding circuit (given by the n \u00d7 n Vandermonde matrix) on\nS and the n \u2212 1 ancillas.\n\n3. T T P sends the ith component of the encoding to Player i.\n4. For all i: Player i outputs either the qupit received from T T P or the message \"D is\ncheating\".\n\nFigure 2-8: Protocol 8 (Ideal Secret Sharing)\n\n2.4.2\n\nDistributed Computation\n\nGiven the protocol of the previous section, and given the ftqc techniques described\nin Section 1.3.3, there is a natural protocol for multi-party computation of a circuit:\nhave all players distribute their inputs via the top-level sharing (Protocol 7); apply\nthe gates of U one-by-one, using the (essentially) transversal implementation of the\ngates described in Section 1.3.3; then have all players send their share of each output\nto the appropriate receiver. For completeness, we give this protocol in Figure 2-9\n(p. 59).\nOne difficulty in the analysis of this protocol is the measurement results which\nare broadcast in the computation phase during Degree Reduction. If the errors occurring in the measured ancilla were somehow correlated or entangled with errors in\nthe real data, one could imagine that measuring and broadcasting them might introduce further entanglement. However, this will not be a problem: on one hand, any\nerrors will occur only in the cheaters shares, and so provide nothing beyond what the\ncheaters could learn themselves; on the other hand, the honest players will discard\nall the information from the broadcast except the decoded measurement result (each\nhonest player performs the decoding locally based on the broadcast values, so all\nhonest players obtain the same result). Again, the cheaters can do this themselves.\nA full proof of security is somewhat tedious; instead, we sketch the main ideas in the\nremainder of this section.\nLemma 2.23. Suppose that all inputs and ancillas are shared at the beginning via\nstates in CC . Then the result of applying the protocol for a given circuit U, and then\nsending all states to an honest decoder R is the same as sending all states to R and\nhaving R apply U to the reconstructed states.\n58\n\n\fProtocol 9 (Multi-party Quantum Computation).\nPre: All players agree on a quantum circuit U with n inputs and n outputs (for simplicity,\nassume that the ith input and output correspond to player i). The circuit they agree on\nshould only use gates from the universal set in Section 1.3.3.\nInput: Each player gets an input system Si (of known dimension p).\n1. Input Phase:\n(a) For each i, player i runs Top-Level Sharing with input Si .\n(b) If i is caught cheating, then some player who has not been caught cheating yet\nruns Top-Level Sharing (Protocol 7), except this time with the one-dimensional code\nspan{EC |0i} (i.e. he proves that the state he is sharing is |0i. If the sharing protocol\nfails, then another player who has not been caught cheating runs the protocol. There\nwill be at most t iterations since an honest player will always succeed.\n(c) For each ancilla state |0i needed for the circuit, some player who has not been caught\ncheating yet runs Top-Level\nSharing (Protocol 7), with the one-dimensional code\n\b\nspan{EC \u03b4 |0i} or span EC \u03b4\u2032 |0i , as needed. If the protocol fails, another player performs the sharing, and so forth.\n2. Computation Phase: For each gate g in the circuit, players apply the appropriate\nfault-tolerant circuit, as described in Section 1.3.3. Only the measurement used in Degree\nReduction is not transversal. To measure the ancilla:\n(a) Each player measures his component and broadcasts the result in the computational\nbasis.\n(b) Let w be the received word. Players decode w (based on the scaled Reed-Solomon\n\u2032\ncode W \u03b4 ), and obtain the measurement result b.\n3. Output Phase: For the ith output wire:\n(a) All players send their share of the output wire to player i.\n(b) Player i applies the decoding operator for C and outputs the result. If decoding fails\n(this will occur only with exponentially small probability), player i outputs |0i.\n\nFigure 2-9: Protocol 9 (Multi-party Quantum Computation)\n\n59\n\n\fProof: Any state in CC can be written as a mixture of linear combinations of basis\nstates Ej E|\u03c8i (see Lemma 1.5). The works on fault-tolerant computing show that\nthe above procedures work correctly on such basis states. More importantly, they\nproduce no new entanglement: the only opportunity to do so would come from the\ninteraction in the measurement step of Degree Reduction. However, the resulting\nleftover ancilla is independent of the data in the computation, and hence provides no\nnew information or entanglement. \u2737\nTheorem 2.24. For any circuit U, Protocol 9 is a statistically secure real-world implementation of multi-party quantum computation (Protocol 1) as long as t < n/6.\nProof: The proof of this is by simulation, as before. The key observation is that\nwhen the simulator S is controlling the honest players, the adversary cannot tell the\ndifference between the regular protocol and the following ideal-model simulation:\n1. S runs the input phase as in the protocol, using |0i as the inputs for honest players.\nIn this phase, if any dealer is caught cheating, S sends \"I am cheating\" to the T T P\non behalf of that player.\n2. S \"swaps\" the cheaters' inputs with bogus data |0i, and sends the data to the\nT T P. That is, he applies the interpolation circuit to honest players' shares to get\nthe various input systems Si (for i \u2208 C), and then runs the interpolation circuit\nbackwards, with the state |0i replacing the original data.\n3. S now runs the computation protocol with the adversary on the bogus data. (Because no information is revealed on the data, the adversary cannot tell this from\nthe real protocol.)\n4. S receives the true computation results destined to cheating players from T T P.\n\n5. S \"swaps\" these back into the appropriate sharings, and sends all shares of the ith\nwire to player i (again, he does this only for i \u2208 C).\nThe proof that this simulation succeeds follows straightforwardly from the security of\nthe top-level sharing protocol and the previous discussion on fault-tolerant procedures.\n\u2737\n\n60\n\n\fChapter 3\nOpen Questions\nWe conclude briefly with some open questions based on this research:\n\u2022 Perhaps the most obvious question, given the results of this thesis, is to determine\nthe true threshold for multi-party quantum computing, i.e. is it possible to tolerate\nup to \u230a(n \u2212 1)/4\u230b cheaters? We conjecture that it can indeed be done, but the\ntechniques we use here are clearly not sufficient.\nOne approach to this problem is to find a fault-tolerant Toffoli procedure for the\ncode C \u03b4 for n = 2\u03b4 + 1, which tolerates t errors at any point in the computation.\nThe best known procedure for that code is a straightforward generalization of\nShor's procedure for binary css codes [Sho96, AB99]. However, there is one point\nin that procedure at which at most one error can be tolerated. Such a procedure\nwill fail when t = \u03b4/2 errors can be placed adversarially.\n\u2022 A more subtle question is whether or not it is possible to remove the error probability from the protocols for verifiable quantum secret sharing. Given an error-free\nimplementation of Ideal Secret Sharing, error-free multi-party computation is easy.\nHowever, attaining error-free vqss seems difficult. Although we tried and failed\nto adapt the error-free classical techniques of Ben-Or, Goldwasser and Wigderson [BGW88], we conjecture that it is nonetheless possible to achieve error-free\nquantum computation.\n\u2022 A potentially much more difficult question is what tasks are achievable when we\nallow cheating players to force the abortion of the protocol. That is, extend the\nideal model so that the cheaters can, at any time, simply ask the trusted third\nparty to stop the protocol entirely. In that setting vqss becomes largely irrelevant\nsince an essential aspect of vqss is that the honest players be able to reconstruct\nthe secret without the cheaters help. Thus, the bound of n/4 no longer seems hard;\nin fact, we conjecture some improvement is possible, possibly even up to tolerating\nany minority of cheating players.\n\n61\n\n\f62\n\n\fAppendix A\nMore on Neighborhoods of\nQuantum Codes\nNote that the notions NB (C) and STB (C) make sense for any subspace C of H. On\nthe one hand, we always have NB (C) \u2286 STB (C) since local operations do not affect\nthe density matrix of other components. If we restrict our attention to pure states,\nthen NB (C) and STB (C) are in fact identical. Specifically, define:\nn\nNBpure (C) =\n|\u03c8i \u2208 H : \u2203|\u03c6i \u2208 C, \u2203U unitary, acting only on HB\no\nsuch that |\u03c8i = (IA \u2297 U)|\u03c6i\nn\no\nSTBpure(C) =\n|\u03c8i \u2208 H : \u2203|\u03c6i \u2208 C, TrB (|\u03c8ih\u03c8|) = TrB (|\u03c6ih\u03c6|)\nProposition A.1. For any subspace C: NBpure (C) = STBpure (C)\nProof: We must only prove NBpure (C) \u2287 STBpure(C), since the other inclusion is trivial.\nTake any state |\u03c8i \u2208 STBpure (C). Let |\u03c6i be the P\ncorresponding state in C and\nP let \u03c1 =\nTrB (|\u03c8ih\u03c8|) = TrB (|\u03c6ih\u03c6|). We can write \u03c1 = i pi |ai ihai | with pi > 0, i pi = 1,\nand the vectors |ai i orthonormal.\nBy the Schmidt decomposition, we know that we can write\nX\u221a\n|\u03c8i =\npi |ai i \u2297 |bi i\ni\n\nwith the vectors |bi i orthonormal. Similarly, there is some other set of orthonormal\nvectors |b\u2032i i such that we can write\nX\u221a\n|\u03c6i =\npi |ai i \u2297 |b\u2032i i\ni\n\nNow consider any unitary matrix U on HB which maps |b\u2032i i to |bi i. Such a matrix\nalways exists since the sets of vectors are orthonormal. Then we have |\u03c8i = (IA \u2297\nUB )|\u03c6i as desired. \u2737\n63\n\n\fThis equality does not hold once we relax our definition and consider mixed states.\nNamely:\nProposition A.2. There exist subspaces C for which NB (C)\n\nSTB (C).\n\nProof: Many quantum codes have this property, for an appropriate partition of the\ncode word into parts A and B. Take C to be a quantum RS code with n = 2\u03b4 + 1.\nEncode 1/2 of an EPR pair. Now get \u03c1 by appending the other half of the EPR pair\nto the end of the codeword (say there is space left over in position n, for example).\nOn one hand, \u03c1 is clearly in STB as long as B includes position n. However, it is not\nin NB (C) since the only state \"in\" C which has the same trace as \u03c1 on A is a mixed\nstate. \u2737\n(q)\n\n(q)\n\nFor the case of css codes, we can additionally define CB = VB \u2229F \u2297n WB . Again,\nthere is a trivial inclusion: STB (C) \u2286 CB . This inclusion also holds when we restrict\nour attention to pure states. However, the inclusion is strict, even for pure states:\nProposition A.3. There exist subspaces C for which STB (C)\n\nCB .\n\nProof: Again, consider the quantum RS code with n = 2\u03b4+1. Take A = {1, ..., \u03b4 + 1}\nand B = {n \u2212 \u03b4 + 1, ..., n}. Both VB and WB cover the entire space Znp , so in fact CB\nis the entire Hilbert space. However, any state \u03c1 in STB (C) must yield \u03c1\u2032 \u2297 I{2,...,\u03b4+1}\nwhen the interpolation operator is applied to the positions of \u03c1 in A. Thus, not all\nstates, pure or mixed, are in STB (C). \u2737\nIt should be noted that neither NB (C) nor STB (C) are subspaces. Moreover, for\ncss codes, CB is the subspace generated by the vectors in NB (C).\nCorrespondence to an Idealized Experiment One interesting property of STB (C)\nis that it is exactly the set of states which will arise in an idealized experiment in\nwhich cheaters introduce errors which are entangled with the data. Specifically, allow\nthe cheaters to choose an arbitrary joint state |\u03c8i for two systems L and Aux (L is\nthe logical data, Aux is auxiliary workspace). Now encode L using C, and allow the\ncheaters to apply any operator which affects only Aux and the components of the\nencoding contained in B. Finally, trace out Aux so that only the components of the\n(corrupted) codeword are left.\nProposition A.4. The set of possible states of the corrupted codeword system in the\nprevious experiment is exactly STB (C).\nProof: We can assume w.l.o.g. that the adversary provides a pure state as input,\nsince we can always purify the state with an ancilla and have him simply ignore the\npure\nancilla. Now, we are in the situation of considering NB\u222aAux\n(C \u2032 ), where C \u2032 is the code\nconsisting of C when restricted to the codeword positions (and no restrictions on the\npure\nAux). By Proposition A.1 this is equal to STB\u222aAux\n(C \u2032 ). But we have STB (C) =\npure\nSTB\u222aAux (C \u2032 ), i.e. once we trace out everything but A, there is no difference between\nC and C \u2032 . \u2737\n64\n\n\fBibliography\n[AB97]\n\nDorit Aharonov and Michael Ben-Or. Fault tolerant quantum computation with constant error. In Proceedings of the Twenty-Ninth Annual\nACM Symposium on Theory of Computing, pages 176\u2013188, El Paso,\nTexas, 4\u20136 May 1997. This is a preliminary version of [AB99].\n\n[AB99]\n\nDorit Aharonov and Michael Ben-Or. Fault tolerant quantum computation with constant error rate. Los Alamos eprint quant-ph/9906129.\nJournal version of [AB97] (submitted to SIAM J. Comp.), June 1999.\n\n[ACM88]\n\nProceedings of the Twentieth Annual ACM Symposium on Theory of\nComputing, Chicago, Illinois, 2\u20134 May 1988.\n\n[Amb01]\n\nAndris Ambainis. A new protocol and lower bounds for quantum coin flipping. In 42nd Annual Symposium on Foundations of Computer Science,\nLas Vegas, Nevada, October 2001. IEEE.\n\n[ATVY00] Dorit Aharonov, Amnon Ta-Shma, Umesh V. Vazirani, and Andrew C.\nYao. Quantum bit escrow. pages 705\u2013714, 21\u201323May 2000.\n[BB84]\n\nCharles Bennett and Gilles Brassard. Quantum cryptography: Public key\ndistribution and coin tossing. In Proceedings of the IEEE International\nConference on Computers, Systems and Signal Processing, pages 175\u2013?,\nBangalore, India, 1984. IEEE.\n\n[BBP+ 96] Charles Bennett, Gilles Brassard, Sandu Popescu, Benjamin Schumaker,\nJohn Smolin, and William Wooters. Purification of noisy entanglement\nand faithful teleportation via noisy channels. Physical Review Letters,\n76:722\u2013725, 1996. Available as e-print quant-ph/9511027.\n[BCG+ 01] Howard Barnum, Claude Cr\u00e9peau, Daniel Gottesman, Alain Tapp, and\nAdam Smith. Authentication of quantum messages. Manuscript, 2001.\n[BCJL93]\n\nGilles Brassard, Claude Cr\u00e9peau, Richard Jozsa, and Denis Langlois. A\nquantum bit commitment scheme provably unbreakable by both parties.\nIn 34th Annual Symposium on Foundations of Computer Science, pages\n362\u2013371, Palo Alto, California, 3\u20135 November 1993. IEEE.\n65\n\n\f[BCMS98] Gilles Brassard, Claude Cr\u00e9peau, Dominic Mayers, and Louis Salvail.\nDefeating classical bit commitments with a quantum computer. quantph/9806031, June 1998.\n[Bea89]\n\nDonald Beaver. Multiparty protocols tolerating half faulty processors. In\nG. Brassard, editor, Advances in Cryptology-CRYPTO '89, volume 435\nof Lecture Notes in Computer Science, pages 560\u2013572. IACR, SpringerVerlag, 1990, 20\u201324 August 1989.\n\n[Bea91]\n\nDonald Beaver. Foundations of secure interactive computing. In Feigenbaum [Fei91], pages 377\u2013391.\n\n[BGW88]\n\nMichael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness\ntheorems for non-cryptographic fault-tolerant distributed computation\n(extended abstract). In ACM [ACM88], pages 1\u201310.\n\n[Can00]\n\nRan Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143\u2013202, 2000.\n\n[Can01]\n\nRan Canetti. A unified framework for analyzing security of protocols.\nManuscript, preliminary version available at eprint.iacr.org/2000/067.\nSome versions of the manuscript are titled \"Universal Composability.\",\n2001.\n\n[CCD88]\n\nDavid Chaum, Claude Cr\u00e9peau, and Ivan Damg\u00e5rd. Multiparty unconditionally secure protocols (extended abstract). In ACM [ACM88], pages\n11\u201319.\n\n[CDD+ 99] Ronald Cramer, Ivan Damg\u00e5rd, Stefan Dziembowski, Martin Hirt, and\nTal Rabin. Efficient multiparty computations with dishonest minority. In\nJacques Stern, editor, Advances in Cryptology-EUROCRYPT 99, volume 1592 of Lecture Notes in Computer Science. IACR, Springer-Verlag,\n1999.\n[CDD+ 01] Ran Canetti, Ivan Damgrd, Stefan Dziembowski, Yuval Ishai, and Tal\nMalkin. On adaptive vs. non-adaptive security of multiparty protocols.\nIn Advances in Cryptology-EUROCRYPT 2001 [IAC01], pages 262\u2013279.\n[CFGN96] Ran Canetti, Uriel Feige, Oded Goldreich, and Moni Naor. Adaptively\nsecure multi-party computation. In Proceedings of the Twenty-Eigth Annual ACM Symposium on the Theory of Computing, pages 639\u2013648, 1996.\n[CGL99]\n\nRichard Cleve, Daniel Gottesman, and Hoi-Kwong Lo. How to share a\nquantum secret. Physical Review Letters, 83:648\u2013651, 1999.\n\n[CGMA85] Benny Chor, Shafi Goldwasser, Silvio Micali, and Baruch Awerbuch. Verifiable secret sharing and achieving simultaneity in the presence of faults\n66\n\n\f(extended abstract). In 26th Annual Symposium on Foundations of Computer Science, pages 383\u2013395, Portland, Oregon, 21\u201323 October 1985.\nIEEE.\n[CGS01]\n\nClaude Cr\u00e9peau, Daniel Gottesman, and Adam Smith. Verifiable quantum secret sharing and multi-party quantum computation. Manuscript,\n2001.\n\n[Cha00]\n\nH. F. Chau. Quantum-classical complexity-security tradeoff in secure\nmultiparty computations. Physical Review A, 61, March 2000.\n\n[CLS01]\n\nClaude Cr\u00e9peau, Fr\u00e9d\u00e9ric L\u00e9gar\u00e9, and Louis Salvail. How to convert\nthe flavor of a quantum bit commitment. In Advances in Cryptology-\nEUROCRYPT 2001 [IAC01], pages 60\u201377.\n\n[CS96]\n\nA. R. Calderbank and Peter W. Shor. Good quantum error-correcting\ncodes exist. Physical Review A, 54(2):1098\u20131106, 1996.\n\n[DEJ+ 96]\n\nDavid Deutsch, Artur Ekert, Richard Jozsa, Ciara Macchiavello, Sandu\nPopescu, and Anna Sanpera. Quantum privacy amplification and the\nsecurity of quantum cryptography over noisy channels. Physical Review\nLetters, (77):2818\u20132821, 1996. Erratum: ibid. 80 (1998) 2022-2022. Also\nLos Alamos e-print quant-ph/9604039.\n\n[DM00]\n\nYevgeniy Dodis and Silvio Micali. Parallel reducibility for informationtheoretically secure computation. In Mihir Bellare, editor, CRYPTO,\nvolume 1880 of Lecture Notes in Computer Science, pages 74\u201392. IACR,\nSpringer, 2000.\n\n[DMS00]\n\nPaul Dumais, Dominic Mayers, and Louis Salvail. Perfectly concealing\nquantum bit commitment from any quantum one-way permutation. volume 1807 of Lecture Notes in Computer Science, pages 300\u2013315. IACR,\nSpringer, 2000.\n\n[Fei91]\n\nJ. Feigenbaum, editor. Advances in Cryptology-CRYPTO '91, volume\n576 of Lecture Notes in Computer Science. IACR, Springer-Verlag, 1992,\n11\u201315 August 1991.\n\n[GC99]\n\nDaniel Gottesman and Isaac Chuang. Quantum teleportation is a universal computational primitive. Nature, November 1999.\n\n[GL90]\n\nShafi Goldwasser and Leonid A. Levin. Fair computation of general functions in presence of immoral majority. In A. J. Menezes and S. A. Vanstone, editors, Advances in Cryptology-CRYPTO '90, volume 537 of\nLecture Notes in Computer Science, pages 77\u201393. IACR, Springer-Verlag,\n1991, 11\u201315 August 1990.\n67\n\n\f[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority.\nIn Proceedings of the Nineteenth Annual ACM Symposium on Theory of\nComputing, pages 218\u2013229, New York City, 25\u201327 May 1987.\n[Got]\n\nDaniel Gottesman. Personal communication. 2001.\n\n[Got00]\n\nDaniel Gottesman. On the theory of quantum secret sharing. Physical\nReview A, 61, 2000.\n\n[IAC01]\n\nIACR. Advances in Cryptology-EUROCRYPT 2001, volume 2045 of\nLecture Notes in Computer Science. Springer-Verlag, 2001.\n\n[LC96]\n\nHoi-Kwong Lo and H. F. Chau. Why quantum bit commitment and\nideal quantum coin tossing are impossible. In Proceedings of the Fourth\nWorkshop on Physics and Computation, page 76, New England Complex\nSys. Inst., 1996. Also available as quant-ph/9605026.\n\n[LC97a]\n\nHoi-Kwong Lo and H. F. Chau. Is quantum bit commitment really possible? Physical Review Letters, 78(17):3410\u20133413, April 1997. Updated\nversion available at quant-ph/9603004.\n\n[LC97b]\n\nHoi-Kwong Lo and H. F. Chau. Making an empty promise with a quantum computer. quant-ph/9709053. Also published in Fortschritte der\nPhys., October 1997.\n\n[LC99]\n\nHoi-Kwong Lo and H. F. Chau. Unconditional security of quantum key\ndistribution over arbitrarily long distances. Science, 283(5410):2050\u2013\n2056, 26 March 1999.\n\n[Lyn96]\n\nNancy Lynch. Distributed Algorithms, chapter 6. Addison-Wesley, 1996.\n\n[May96]\n\nDominic Mayers. The trouble with quantum bit commitment. quantph/9603015, March 1996.\n\n[May97]\n\nDominic Mayers. Unconditionally secure quantum bit commitment is impossible. Physical Review Letters, 78:3414\u20133417, 1997. quant-ph/9605044.\n\n[May98]\n\nDominic Mayers. Unconditional security in quantum cryptography.\nquant-ph/9802025, Updated September 1998.\n\n[MR91]\n\nSilvio Micali and Phillip Rogaway. Secure computation (abstract). In\nFeigenbaum [Fei91], pages 392\u2013404.\n\n[MS99]\n\nDominic Mayers and Louis Salvail. Unconditionally secure quantum coin\nflipping. quant-ph/9806031, April 1999.\n\n[NC00]\n\nMichael Nielsen and Isaac Chuang. Quantum Computation and Quantum\nInformation. Cambridge University Press, 2000.\n68\n\n\f[PW00]\n\nBirgit Pfitzmann and Michael Waidner. Composition and integrity preservation of secure reactive systems. In ACM Conference on Computer and\nCommunications Security 2000, pages 245\u2013254, 2000.\n\n[RB89]\n\nTal Rabin and Michael Ben-Or. Verifiable secret sharing and multiparty\nprotocols with honest majority (extended abstract). In Proceedings of the\nTwenty First Annual ACM Symposium on Theory of Computing, pages\n73\u201385, Seattle, Washington, 15\u201317 May 1989.\n\n[Sha79]\n\nAdi Shamir. How to share a secret. Communications of the ACM, 22:612\u2013\n613, 1979.\n\n[Sho96]\n\nPeter W. Shor. Fault-tolerant quantum computation. In 37th Annual\nSymposium on Foundations of Computer Science, pages 56\u201365, Burlington, Vermont, 14\u201316 October 1996. IEEE.\n\n[SP00]\n\nPeter W. Shor and John Preskill. Simple proof of security of the bb84\nquantum key distribution protocol. Physical Review Letters, 85:441\u2013444,\n2000.\n\n[Ste96]\n\nAndrew Steane. Simple quantum error correcting codes. Physical Review\nA, 54, 1996.\n\n[vdG97]\n\nJeroen van de Graaf. Towards a formal defintion of security for quantum\nprotocols. PhD thesis, Universit\u00e9 de Montr\u00e9al, Canada, December 1997.\nAvailable from http://www.cenapad.ufmg.br/ \u0303jvdg/.\n\n69\n\n\f"}