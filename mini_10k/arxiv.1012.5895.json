{"id": "http://arxiv.org/abs/1012.5895v1", "guidislink": true, "updated": "2010-12-29T09:27:44Z", "updated_parsed": [2010, 12, 29, 9, 27, 44, 2, 363, 0], "published": "2010-12-29T09:27:44Z", "published_parsed": [2010, 12, 29, 9, 27, 44, 2, 363, 0], "title": "Homophonic Coding Design for Communication Systems Employing the\n  Encoding-Encryption Paradigm", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1012.4899%2C1012.3552%2C1012.4258%2C1012.5476%2C1012.2009%2C1012.0700%2C1012.5535%2C1012.4454%2C1012.4417%2C1012.5465%2C1012.4413%2C1012.0908%2C1012.0208%2C1012.1386%2C1012.1639%2C1012.0630%2C1012.2728%2C1012.2149%2C1012.5029%2C1012.2337%2C1012.1174%2C1012.2930%2C1012.4012%2C1012.0987%2C1012.4770%2C1012.5434%2C1012.2367%2C1012.0884%2C1012.1206%2C1012.5950%2C1012.2982%2C1012.5099%2C1012.1824%2C1012.1823%2C1012.0838%2C1012.5335%2C1012.1976%2C1012.0557%2C1012.3998%2C1012.1643%2C1012.2170%2C1012.4854%2C1012.1663%2C1012.6031%2C1012.5890%2C1012.1454%2C1012.1246%2C1012.5747%2C1012.3048%2C1012.5757%2C1012.4577%2C1012.1960%2C1012.3319%2C1012.1699%2C1012.1802%2C1012.4868%2C1012.0138%2C1012.3078%2C1012.1285%2C1012.2650%2C1012.3922%2C1012.2954%2C1012.1075%2C1012.4706%2C1012.3652%2C1012.4851%2C1012.0867%2C1012.4723%2C1012.3753%2C1012.1965%2C1012.3071%2C1012.1016%2C1012.5594%2C1012.4680%2C1012.2108%2C1012.5763%2C1012.0841%2C1012.1779%2C1012.4499%2C1012.4252%2C1012.1052%2C1012.4982%2C1012.1614%2C1012.0240%2C1012.4638%2C1012.2394%2C1012.5095%2C1012.5376%2C1012.3894%2C1012.0282%2C1012.1340%2C1012.3873%2C1012.3897%2C1012.0317%2C1012.0336%2C1012.5895%2C1012.4103%2C1012.5761%2C1012.4060%2C1012.4194%2C1012.5407&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Homophonic Coding Design for Communication Systems Employing the\n  Encoding-Encryption Paradigm"}, "summary": "This paper addresses the design of a dedicated homophonic coding for a class\nof communication systems which, in order to provide both reliability and\nsecurity, first encode the data before encrypting it, which is referred to as\nthe encoding-encryption paradigm. The considered systems employ\nerror-correction coding for reliability, a stream cipher for encryption, and\nhomophonic coding to enhance the protection of the key used in the stream\ncipher, on which relies the security of all the system transmissions. This\npaper presents a security evaluation of such systems from a computational\ncomplexity point of view, which serves as a source for establishing dedicated\nhomophonic code design criteria. The security evaluation shows that the\ncomputational complexity of recovering the secret key, given all the\ninformation an attacker could gather during passive attacks he can mount, is\nlower bounded by the complexity of the related LPN (Learning Parity in Noise)\nproblem in both the average and worst case. This gives guidelines to construct\na dedicated homophonic encoder which maximizes the complexity of the underlying\nLPN problem for a given encoding overhead. Finally, this paper proposes a\ngeneric homophonic coding strategy that fulfills the proposed design criteria\nand thus both enhances security while minimizing the induced overhead.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1012.4899%2C1012.3552%2C1012.4258%2C1012.5476%2C1012.2009%2C1012.0700%2C1012.5535%2C1012.4454%2C1012.4417%2C1012.5465%2C1012.4413%2C1012.0908%2C1012.0208%2C1012.1386%2C1012.1639%2C1012.0630%2C1012.2728%2C1012.2149%2C1012.5029%2C1012.2337%2C1012.1174%2C1012.2930%2C1012.4012%2C1012.0987%2C1012.4770%2C1012.5434%2C1012.2367%2C1012.0884%2C1012.1206%2C1012.5950%2C1012.2982%2C1012.5099%2C1012.1824%2C1012.1823%2C1012.0838%2C1012.5335%2C1012.1976%2C1012.0557%2C1012.3998%2C1012.1643%2C1012.2170%2C1012.4854%2C1012.1663%2C1012.6031%2C1012.5890%2C1012.1454%2C1012.1246%2C1012.5747%2C1012.3048%2C1012.5757%2C1012.4577%2C1012.1960%2C1012.3319%2C1012.1699%2C1012.1802%2C1012.4868%2C1012.0138%2C1012.3078%2C1012.1285%2C1012.2650%2C1012.3922%2C1012.2954%2C1012.1075%2C1012.4706%2C1012.3652%2C1012.4851%2C1012.0867%2C1012.4723%2C1012.3753%2C1012.1965%2C1012.3071%2C1012.1016%2C1012.5594%2C1012.4680%2C1012.2108%2C1012.5763%2C1012.0841%2C1012.1779%2C1012.4499%2C1012.4252%2C1012.1052%2C1012.4982%2C1012.1614%2C1012.0240%2C1012.4638%2C1012.2394%2C1012.5095%2C1012.5376%2C1012.3894%2C1012.0282%2C1012.1340%2C1012.3873%2C1012.3897%2C1012.0317%2C1012.0336%2C1012.5895%2C1012.4103%2C1012.5761%2C1012.4060%2C1012.4194%2C1012.5407&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "This paper addresses the design of a dedicated homophonic coding for a class\nof communication systems which, in order to provide both reliability and\nsecurity, first encode the data before encrypting it, which is referred to as\nthe encoding-encryption paradigm. The considered systems employ\nerror-correction coding for reliability, a stream cipher for encryption, and\nhomophonic coding to enhance the protection of the key used in the stream\ncipher, on which relies the security of all the system transmissions. This\npaper presents a security evaluation of such systems from a computational\ncomplexity point of view, which serves as a source for establishing dedicated\nhomophonic code design criteria. The security evaluation shows that the\ncomputational complexity of recovering the secret key, given all the\ninformation an attacker could gather during passive attacks he can mount, is\nlower bounded by the complexity of the related LPN (Learning Parity in Noise)\nproblem in both the average and worst case. This gives guidelines to construct\na dedicated homophonic encoder which maximizes the complexity of the underlying\nLPN problem for a given encoding overhead. Finally, this paper proposes a\ngeneric homophonic coding strategy that fulfills the proposed design criteria\nand thus both enhances security while minimizing the induced overhead."}, "authors": ["Miodrag J. Mihaljevic", "Frederique Oggier", "Hideki Imai"], "author_detail": {"name": "Hideki Imai"}, "author": "Hideki Imai", "arxiv_comment": "16 pages, 1 figure", "links": [{"href": "http://arxiv.org/abs/1012.5895v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1012.5895v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1012.5895v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1012.5895v1", "journal_reference": null, "doi": null, "fulltext": "Homophonic Coding Design for Communication Systems\nEmploying the Encoding-Encryption Paradigm\n\narXiv:1012.5895v1 [cs.CR] 29 Dec 2010\n\nMiodrag J. Mihaljevi\u0107, Fr\u00e9d\u00e9rique Oggier and Hideki Imai\n\n\u2217\n\nNovember 13, 2018\n\nAbstract\nThis paper addresses the design of a dedicated homophonic coding for a class of communication\nsystems which, in order to provide both reliability and security, first encode the data before encrypting\nit, which is referred to as the encoding-encryption paradigm. The considered systems employ errorcorrection coding for reliability, a stream cipher for encryption, and homophonic coding to enhance the\nprotection of the key used in the stream cipher, on which relies the security of all the system transmissions.\nThis paper presents a security evaluation of such systems from a computational complexity point of\nview, which serves as a source for establishing dedicated homophonic code design criteria. The security\nevaluation shows that the computational complexity of recovering the secret key, given all the information\nan attacker could gather during passive attacks he can mount, is lower bounded by the complexity of the\nrelated LPN (Learning Parity in Noise) problem in both the average and worst case. This gives guidelines to construct a dedicated homophonic encoder which maximizes the complexity of the underlying\nLPN problem for a given encoding overhead. Finally, this paper proposes a generic homophonic coding\nstrategy that fulfills the proposed design criteria and thus both enhances security while minimizing the\ninduced overhead.\nKeywords: (wireless) communications systems, homophonic coding, error-correction coding, stream ciphers, randomness, security evaluation, LPN problem.\n\n1\n\nIntroduction\n\nMost communication systems take into account not only the reliability but also the security of the data\nthey transmit. This is particularly true in wireless environments, where the data is inherently more sensible\nto security threats. Consequently, the system design needs to include both coding schemes for providing\nerror-correction and ciphering algorithms for encryption-decryption. It is common practice to first encrypt\nthe data to ensure the security, and then to encode for reliability purposes. In this paper, we focus on those\ncommunication systems which adopt the reverse approach: they first encode the data, and then encrypt\nit, which we call the encoding-encryption paradigm. A famous illustrative example is the most widespread\nstandard for mobile telephony GSM, standing for \"Global System for Mobile Communications\" (see [4] and\n[3], for the coding, respectively security details).\nIn the considered system, encryption-decryption is done through a stream cipher, since the receiver\nneeds to first decrypt the data despite the noise, before performing the decoding, which cannot be done\nthrough block ciphers. Consequently the security of the system relies crucially on the private key used in the\n\u2217 Miodrag Mihaljevi\u0107 is with Mathematical Institute, Serbian Academy of Sciences and Arts, Belgrade, Serbia, and with\nResearch Center for Information Security (RCIS), Institute of Advanced Industrial Science and Technology (AIST), Tokyo,\nJapan. Fr\u00e9d\u00e9rique Oggier is with Division of Mathematical Sciences, School of Physical and Mathematical Sciences, Nanyang\nTechnological University, Singapore. Hideki Imai is with Faculty of Sciences and Engineering Chuo University, Tokyo, and with\nResearch Center for Information Security (RCIS), Institute of Advanced Industrial Science and Technology (AIST), Tokyo,\nJapan. Email: miodragm@turing.mi.sanu.ac.rs., frederique@ntu.edu.sg\n\n1\n\n\fstream cipher and thus when we refer to the security of systems using the encoding-encryption paradigm,\nwe implicitly mean the security of the keystream generator and the users' secret key.\nMotivation for the Work. Homophonic coding (see [8] and [9]) is a natural technique to enhance the security\nof systems employing the encoding-encryption paradigm, since it injects extra randomness in the system,\nwhich increases the confusion of a possible adversary by amplifying the channel noise that he experiences.\nThis idea has been recently exploited in [11] and [12], where it was shown from an information-theoretic point\nof view that with the aid of a dedicated homophonic encoder, the amount of uncertainty that the adversary\nmust face about the secret key given all the information he could gather during different passive or active\nattacks he can mount, is a decreasing function of the samples available for cryptanalysis. This means that\nthere is a threshold before which the homophonic encoding indeed provides a certain level of unconditional\nsecurity, but after a large sample is collected, the uncertainty tends to zero, entering a regime in which a\ncomputational security analysis is needed for estimating the resistance against the secret key recovery. This\npaper addresses this computational complexity security evaluation, and highlights how the computational\nsecurity is related to the homophonic coding design.\nSummary of the Results. This paper proposes a homophonic code design derived from a security evaluation of\nthe secret key recovery which shows that the security of systems using the encoding-encryption approach can\nbe related to the complexity of solving certain LPN (Learning Parity with Noise) problems. It follows from\nthis analysis that the dedicated homophonic encoding plays a role in securing the system, and that a careful\ndesign makes the underlying LPN problem heavily more complex in the average case. This gives guidelines for\nthe design of a dedicated homophonic encoder, that comprises five conditions, two related to the information\ntheoretical security, two regarding the computational security, and one concerning implementation costs. We\nfinally propose a homophonic coding strategy which fulfills all the given criteria.\nOrganization of the Paper. Section 2 introduces the background for the problem addressed in this paper.\nSection 3 contains the security evaluation from a computational complexity point of view. Implications of\nthe security evaluation on the design of a dedicated homophonic coding are discussed in Section 4, where the\ncode design criteria are established, while the code constructions are given in Section 5. Concluding remarks\nincluding some directions for future work are given in Section 6.\n\n2\n\nBackground\n\nWe consider a class of communication systems which, in order to provide both reliability and security,\nemploys the encoding-encryption paradigm, namely: the message is first encoded employing error-correction\ncoding for the purpose of reliability and then encrypted using a stream ciphering. It has been shown in\n[11] and [12] via an information-theoretic analysis that the use of a dedicated homophonic/wiretap encoding\nenhances the security of such systems. This section summarizes the reported design and the results of its\ninformation-theoretic security evaluation.\n\n2.1\n\nSystem Model\n\nIn systems employing the encoding-encryption paradigm (as shown in Figure 1), a stream cipher is used, on\nwhich relies the security of the whole system. It is thus crucial to focus on the security of its private key.\nThe system reported and analyzed in [11] and [12] aims at increasing the security of the private key against\nboth passive and active attacks by introducing a dedicated homophonic/wire-tap encoder which involves\nextra randomness as follows. Let k be the private key, let CH (*) denote a homophonic encoder, added at\nthe transmitter, and let\nm\u2212l\nu = [ui ]m\u2212l\ni=1 \u2208 {0, 1}\n\n2\n\n\fTransmitter\n\nKeystream\nGenerator\n\nsecret key\n\n{xi}\n{ai}\nmessage\n\nHomophonic /\nWire-tap Channel\nEncoding\n\n{yi}\n\nError-Correction\nEncoding\n\nencryption\n\nBSC\n\nSource of\nRandomness\n\nReceiver\n\n{ai}\nmessage\n\n{zi}\n\nHomophonic /\nWire-tap Channel\nDecoding\n\n{bi}\n\nError-Correction\nDecoding\n\ndecryption\n\nBinary\nSymmetric Channel\n\n{bi}\n\n{ui}\n\n{xi}\nKeystream\nGenerator\n\nsecret key\n\nFigure 1: Considered communication system model including homophonic coding.\n\nbe a vector of pure randomness1 where each ui is the realization of a random variable Ui with distribution\nPr(Ui = 1) = Pr(Ui = 0) = 1/2. The homophonic encoder is positioned before the error-correcting encoder\nCECC (*), thus out of the m bits of data to be sent, m \u2212 l are replaced by random data, letting actually only\nl bits\na = [ai ]li=1 \u2208 {0, 1}l\nof plaintext, to get\ny = y(k) = CECC (CH (a||u)) \u2295 x\n\n(1)\n\nas codeword to be sent, where x = x(k) is the output of the keystream generator. We assume that both\nhomophonic and error-correction encoding are linear operations, so that\nCH (a||u) = [a||u]GH ,\n\n(2)\n\nwhere GH is an m \u00d7 m matrix, and thus\nCECC (CH (a||u))\n\n=\n\nCECC ([a||u]GH )\n\n=\n=\n\n[a||u]GH GECC\n[a||u]G\n\n(3)\n\nwhere GECC is an m \u00d7 n binary generator matrix corresponding to CECC (*), and G = GH GECC is an\nm \u00d7 n binary matrix summarizing the two successive encodings at the transmitter. This homophonic/wiretap approach is a natural candidate for security enhancement, since homophonic (resp. wire-tap) coding is a\nwell-known technique to create confusion while performing source (resp. channel coding): on the one hand,\nhomophonic coding [9] provides (i) multiple substitutions of a given source vector via randomness so that\nthe coded versions of the source vectors appear as realizations of a random source; (ii) recoverability of the\nsource vector based on the given codeword without knowledge of the randomization. On the other hand,\n1 Although it is assumed for simplicity of presentation, the randomness involved does not need to be \"perfect\" because the\nrole of randomness is just to enhance security of the employed keystream generator and not to perform encryption itself. In other\nwords, the randomness involved does not need to fulfill all the requirements as the randomness for one-time pad encryption,\nand accordingly implementation issues become substantially simpler.\n\n3\n\n\fthe main goals of wire-tap channel coding (see [14] and [13] when the main channel is error-free) are: (i)\namplification of the noise difference between the main and wire-tap channel via randomness; (ii) a reliable\ntransmission in the main channel and at the same time to provide a total confusion of the wire-tapper who\nobserves the communication in the main channel via a noisy channel (wire-tap channel).\nIn this paper we assume that transmission occurs via a binary symmetric channel (BSC)2 with known\ncrossover probability p, so that the receiver obtains\nz = z(k) = y \u2295 v = CECC (CH (a||u)) \u2295 x \u2295 v\n\n(4)\n\nwhere v = [vi ]ni=1 \u2208 {0, 1}n and vi is the realization of a binary random variable Vi such that Pr(Vi = 0) =\n1 \u2212 p and Pr(Vi = 1) = p. Since he knows the private key, the receiver starts with the decryption\ny = (CECC (CH (a||u)) \u2295 x \u2295 v) \u2295 x = CECC (CH (a||u)) \u2295 v\nand then decodes\nCH (a||u).\n\u22121\nIf the decoding is successful, a is recovered using CH\nand the receiver informs the transmitter via a feedback\nlink that he could decode. Otherwise he informs the transmitter that retransmission is required.\nIn the meantime, the adversary keeps on listening and collects over time samples {z(t) }\u03c4t=1 such that\n\nz(t) = CECC (CH (a(t) ||u(t) )) \u2295 x(t) \u2295 v(t) , t = 1, 2, ..., \u03c4 .\n\n(5)\n\n(t)\n\n(t)\n\nemploying the notation a(t) = [ai ]li=1 for the plain text, u(t) = [ui ]m\u2212l\ni=1 for the pure randomness used in\n(t)\n(t) n\n(t)\n(t)\nthe homophonic encoder, v = [vi ]i=1 for the channel noise, and z = [zi ]ni=1 for the received signal.\nThe main feature of the dedicated homophonic coding used in [11]-[12] is that the encoding is based\non randomness and that the legitimate receiver who shares a secret key with the transmitter can perform\ndecoding without knowledge of the randomness employed for the encoding, as shown above. As a result, the\ndecoding complexity without knowledge of the secret key employed in the system approaches the complexity\nof the exhaustive search for the secret key. The encoding-encryption paradigm for secure and reliable communications enjoys the following desirable properties: (i) when the decryption is performed by bitwise XORing\nthe keystream to the ciphertext, an error in a bit before decryption causes an error in the corresponding bit\nafter decryption, without any error-propagation, and (ii) provides non-availability of the error-free keystream\nwhen the communication channel is a noisy one.\n\n2.2\n\nInformation-Theoretic Security Evaluation\n\nIt has been shown in [11] and [12] that from an information-theoretic point of view, it is enough to use\na generic wire-tap encoder to increase the security of the system. Namely, under the assumptions that\nthe homophonic encoding matrix GH defined in (2) (i) is invertible, so that the receiver can decode the\nhomophonic encoding, and (ii) maps [a||u] so that in the resulting vector each bit of ciphertext z is affected\nby at least one random bit from u, to make sure that each bit of ciphertext is protected, then the homophonic\n(wire-tap channel) encoding increases the security of the private key k under both passive and active attacks,\nwhere the attacker can modify the ciphertext and learn the effects of these modifications through the feedback\nlink. More precisely\nTheorem 1 Let\nZ(t) = CECC (CH (A(t) ||U(t) )) \u2295 f (t) (K) + V(t) , t = 1, 2, ..., \u03c4 ,\n\n(6)\n(t)\n\nbe the samples available for cryptanalysis obtained over a period of \u03c4 times, where A(t) = [Ai ]li=1 , U(t) =\n(t)\n(t)\n(t)\n(t)\n= [Vi ]ni=1 and Z(t) = [Zi ]ni=1 , are random variables with entropy H(A), H(U ), H(V )\n[Ui ]m\u2212l\ni=1 , V\nand H(Z), representing respectively the data to be sent, pure randomness involved in the wire-tap encoder,\n2A\n\nmore general class of binary channels was discussed in [11] and [12].\n\n4\n\n\frandom noise, and signals seen by the attacker. Let K be a binary vector random variable uniformly chosen\nrepresenting the key, such that H(K) = |K|, and f (j) (*), j = 1, 2, ..., t, are given deterministic functions\ndescribing the keystream generator, that is, X(t) = f (t) (K). When Pr(Vij = 0) 6= Pr(Vij = 1) 6= 1/2,\ni = 1, 2, ..., n, j = 1, 2, ..., t, we have:\n\u001a\n> 0 for \u03c4 < \u03c4min\nH(K|A, Z)\n(7)\n\u2192 0 for \u03c4 \u2265 \u03c4min\nfor A = [A(1) ||A(2) ||...||A(\u03c4 ) ] and Z = [Z(1) ||Z(2) ||...||Z(\u03c4 ) ].\nThis theorem statement is interpreted as follows. The uncertainty on the key, measured by the equivocation of the key assuming a known plaintext attack implies, an information-theoretic security assuming that\na limited sample only is available for cryptanalysis. This information-theoretic security appears as a consequence of the randomness involved via the homophonic coding as well as the communication channel noise.\nIt has been shown in [11]-[12] that the randomness introduced via homophonic coding has a heavy impact on\nproviding the information-theoretic security. On the other hand, the theorem statement also points out that\nthe information-theoretic security does not hold anymore if an attacker can collect an enough large sample\nfor cryptanalysis, i.e., if the parameter \u03c4 is large enough the equivocation reduces to zero which implies that\nthe secret key is recoverable assuming availability of certain computational power. Accordingly, as long as\n\u03c4 < \u03c4thresh , the key is protected by the randomness of the homophonic encoder and of the noisy channel in\nan information-theoretic manner, but that protection cannot last forever if the adversary collects too much\ndata. This does not say that it is easy for the adversary to recover the key, as will be discussed below, but\nonly that the information-theoretic security does not hold anymore.\n\n3\n\nComputational Complexity Security Evaluation\n\nThis section analyzes the security of the proposed scheme from a computational complexity point of view in\nthe chosen plaintext attacking (CPA) scenario. In this case, the security evaluation consists of establishing\nhow hard it is to find the secret key based on the algebraic representation of the encryption. We will show in\nour complexity analysis that the hardness of recovering the key relies on the hardness of the LPN problem\n(see [2],[5], [7], for example). The analysis will pinpoint the features that the homophonic encoder should\nhave so as to create an increased complexity of the underlying LPN problem in the average case.\n\n3.1\n\nPreliminaries\n\nWe consider the scenario where enough large samples {z(t) }\u03c4t=1 have been recorded by an attacker, who can\nnow try to find the employed secret key k contained in xt = x(t) (k) using from (5)\nz(t) = CECC (CH (a(t) ||u(t) )) \u2295 x(t) \u2295 v(t) , t = 1, 2, ..., \u03c4 ,\nsince he has a probability of error in recovering the key which now tends to zero.\nFor the simplicity of exposition, we assume from now on that |K| = n. We further perform the security\nevaluation under the following two assumptions:\n\u2022 x(t) = f (t) (k) = kSt , t = 1, 2, ..., \u03c4 , where S = [si,j ]ni=1\n(t)\n\n(t)\n\nn\nj=1 ,\n\nis a binary matrix, and\n\nSt = [S1 , S2 , ..., S(t)\nn ]\n(t)\n\n(8)\n\nwhere each Si , i = 1, 2, ..., n, denotes a column of the tth power of the matrix S; note that usually\nf (t) (*) is a heavily nonlinear function, and its consideration as a linear one actually implies a scenario\nfor evaluation of a lower bound of the complexity for the secret key recovery;\n\n5\n\n\f\u2022 we consider the chosen plaintext attack where the data is the whole zero vector, i.e. a(t) = 0, for each\nt.\nUnder the above assumptions, and recalling from (3) that both CECC and CH are linear encoders, we\ncan write\nkSt \u2295 [0||u(t) ]G = z(t) \u2295 v(t) ,\nfrom which we obtain an algebraic representation of the recovery problem in terms of a noisy system of linear\nequations, as seen by the adversary:\n\uf8ee\n\uf8f9 \uf8ee\n\uf8f9 \uf8ee (t) \uf8f9 \uf8ee (t) \uf8f9\n(t)\n(t)\nkS1\nz1\nv1\n[0||u\n]G\n1\n\u0002\n\u0003\n\uf8ef\n\uf8ef (t) \uf8fa \uf8ef (t) \uf8fa\n(t) \uf8fa\n(t)\n\uf8ef\n\uf8fa\nG2 \uf8fa \uf8ef z2 \uf8fa \uf8ef v2 \uf8fa\n\uf8ef kS2 \uf8fa \uf8ef 0||u\n\uf8ef . \uf8fa\u2295\uf8ef\n\uf8ef\n\uf8fa\n(9)\n\uf8fa=\uf8ef\n..\n.. \uf8fa\n\uf8ef . \uf8fa \uf8f0\n\uf8fa \u2295 \uf8ef .. \uf8fa , t = 1, 2, ..., \u03c4,\n\uf8fb \uf8ef\n.\n\uf8f0 . \uf8fb\n\uf8f0\n\uf8fb\n\uf8f0\n\uf8fb\n.\n.\n\u0002\n\u0003\n(t)\n(t)\n(t)\n0||u(t) Gn\nkSn\nzn\nvn\n(t)\n\nwhere u(t) = [ui ]m\u2212l\ni=1 and Gi denotes the ith column of G.\n\u0002\n\u0003\nRemark 1 Note that in the set { 0||u(t) Gi }ni=1 all the elements could be split into two non-overlapping\nsubsets such that a subset contains k linearly independent elements, k at most m \u2212 l, and the other subset\n\u0002contains\n\u0003 n \u2212 k elements each of which is a linear combination of the elements from the first set, since\n0||u(t) G only involves the lower part of G, which is an (m \u2212 l) \u00d7 n matrix, which has thus at most m \u2212 l\nlinearly independent columns, and the other columns can be obtained as linear combinations.\nThe problem of solving a system of linear equations in the presence of noise is related to the so-called\nLNP problem, defined formally as follows.\nDefinition - The LPN Problem. Let h*|*i denote the binary inner product. Let s be a random n-bit\nvector, let \u01eb \u2208]0, 1/2[ be a constant noise parameter, let Ber\u01eb be the Bernoulli distribution with parameter \u01eb\n(so if \u03bd \u2190 Ber\u01eb then Pr(\u03bd = 0) = \u01eb and Pr(\u03bd = 0) = 1 \u2212 \u01eb), and let As,\u01eb be the distribution defined as\n{a \u2190 {0, 1}n; \u03bd \u2190 Ber\u01eb : (a, hs|ai \u2295 \u03bd)}\nLet As,\u01eb denote an oracle which outputs independent samples according to the above distribution. An\nalgorithm M is said to (q, t, m, \u03b8)-solve the LPNn,\u01eb problem if\nPr[s \u2190 {0, 1}n : MAs ,\u01eb (1n ) = s] \u2265 \u03b8 ,\n\nand furthermore M runs in time at most t, memory at most m, and makes at most q queries to its oracle.\nWhat the LPN problem captures is that, given a security parameter k, a secret vector x, and g1 , ..., gn\nrandomly chosen binary vectors of length n = O(k), it is possible knowing yi = hx|gi i and {gi }ni=1 to solve\nfor x using standard linear-algebraic techniques as long as there is no noise. However, when each yi is flipped\n(independently) with probability p, finding x becomes much more difficult. The problem of learning x in\nthis latter case is refereed to as the learning parity in noise (LPN) problem.\nFinally note that the LPN problem is equivalent to the problem of decoding of a general linear block code\nand it is known that this problem is NP-complete [1], and that relating security of an encryption technique to\nthe LPN problem has been employed for security evaluation of certain stream ciphers (see [10], for example).\n\n3.2\n\nComplexity Evaluation\n\nA systematic way to solve a system of linear equations, with or without noise, is to perform a Gaussian\nelimination. If the system furthermore contains unknowns that we are not interested in finding, it is natural\nto start by removing them, so as to obtain a system with a smaller number of equations, where only the\nunknowns we would like to find are left. We will now show how such a strategy changes the noise present in\nthe system of equations.\n6\n\n\fLemma 1 Consider the following system of N equations over the binary field GF (2) to be solved for\nx1 , . . . , xL , L \u2264 N :\nL\nM\n(i)\n\u03b1j xj ) \u2295 yi = zi \u2295 ei , i = 1, 2, ..., M ,\n(\nj=1\n\nL\nM\n\n(\n\nj=1\n\nM\nM\n(i)\n(i)\n\u03b2j yj ) = zi \u2295 ei , i = M + 1, M + 2, ..., N ,\n\u03b1j xj ) \u2295 (\n\n(10)\n\nj=1\n\n(i)\n\n(i)\n\nM N\nL\nM\nN\nL\nN\nwhere {zi }N\ni=1 , {\u03b1j }j=1 i=1 and {\u03b2j }j=1 i=1 are known, {xj }j=1 , {yj }j=1 and {ei }i=1 are unknown, and\neach ei is a realization of a random variable Ei such that Pr(Ei = 1) = p < 1/2, i = 1, 2, ..., N . If\n(i)\n\n(i)\n\n1. the Hamming weight of each vector [\u03b21 , . . . , \u03b2M ] is greater or equal to some parameter w, for i =\nM + 1, M + 2, ..., N ,\nLM (k)\n2. and no\nj=1 \u03b2j yj , k \u2208 {M + 1, M + 2, . . . , N }, is a linear combination of any other w or less\nLM (i)\nLM (i)\nj=1 \u03b2j yj\nj=1 \u03b2j yj , i \u2208 {M +1, M +2, . . . , N }, i.e., there are at least w linearly independent sums\namong those i \u2208 {M + 1, . . . , N },\nthen, the problem of recovering the unknown x1 , x2 , . . . , xL is the problem of solving the following system of\nequations:\nM\nL\nM\nL\nM\nM\nM\nM\n(i)\n(i)\n(k)\n(i)\n\u03b2k zk ) \u2295 e\u2217i , i = M + 1, M + 2, ..., N ,\n\u03b1j xj ) = zi \u2295 (\n\u03b1j xj )) \u2295 (\n(\n\u03b2k (\nk=1\n\nj=1\n\nj=1\n\n(11)\n\nk=1\n\nwhere e\u2217j is a realization of a random variable Ej\u2217 such that Pr(Ej\u2217 = 1) > pw =\n\n1\u2212(1\u22122p)w+1\n.\n2\n\nProof. For every i \u2208 {M + 1, M + 2, ..., N }, adding the following linear combination of the first M equations\nM\nM\nM\nL\nM\nM\nM\nM\n(i)\n(i)\n(k)\n(i)\n\u03b2k y k ) =\n\u03b2k (zk \u2295 ek ) ,\n\u03b1j xj )) \u2295 (\n(\n\u03b2k (\nk=1\n\nj=1\n\nk=1\n\n(12)\n\nk=1\n\nto the ith equations of the system yields:\nM\nM\nL\nM\nL\nM\nM\nM\nM\nM\n(i)\n(i)\n(i)\n(k)\n(i)\n\u03b2k z k ) \u2295 e i \u2295 (\n\u03b2k e k ) .\n\u03b1j xj ) = zi \u2295 (\n\u03b1j xj )) \u2295 (\n(\n\u03b2k (\nk=1\n\nj=1\n\nj=1\n\nk=1\n\n(13)\n\nk=1\n\nWe are left to compute the probability Pr(Ei\u2217 = 1), where\nM\nM\n(i)\nEi\u2217 = Ei \u2295 (\n\u03b2k Ek ), i = M + 1, . . . , N.\nk=1\n\n(i)\n\nSince i \u2265 M + 1, Ei is independent of \u03b2k Ek for every 1 \u2264 k \u2264 M . We are thus summing the components\nof the vector\n(i)\n(i)\n[Ei , E1 \u03b21 , . . . , EM \u03b2M ]\nand\nPr(Ei\u2217 = 1) =\n=\n\n1 \u2212 Pr(Ei\u2217 = 0)\nM\nM\n(i)\n\u03b2k Ek = 0)).\n1 \u2212 Pr(Ei \u2295 (\nk=1\n\n7\n\n\fNow the probability that an even number of digits are 1 in a sequence of M + 1 independent binary digits\nis [6, Lemma 1]\n1 + (1 \u2212 2p)M+1\n2\nif p is the probability that every digit is 1. Since\n1 + (1 \u2212 2p)M+1\n1 + (1 \u2212 2p)M\n>\n, p < 1/2,\n2\n2\nwe have that\n\n1 + (1 \u2212 2p)M\n1 + (1 \u2212 2p)M+1\n<1\u2212\n,\n2\n2\n\n1\u2212\nand\nPr(Ei\u2217\n\nM\nM\n(i)\n= 1) = 1 \u2212 Pr(Ei \u2295 (\n\u03b2k Ek = 0))\nk=1\n\n1 + (1 \u2212 2p)w+1\n> 1\u2212\n2\n1 \u2212 (1 \u2212 2p)w+1\n=\n2\n(i)\n\n(i)\n\nsince by assumption 1., the weight of each vector of [\u03b21 , . . . \u03b2M ] is at least w, and according to the assumption\n2., there is no linear combination of the equations which can reduce the corruption noise value lower bounded\nby pw (i.e., it cannot be reduced via any further linear processing of the system of equations).\n\u0004\nThis leads to the main evaluation result:\nTheorem 2 The complexity of recovering the secret key k based on the algebraic representation of the scheme\nw+1\nand n, w and p\nis lower bounded by the complexity of solving the LPNn,\u01eb problem where, \u01eb = 1\u2212(1\u22122p)\n2\nare the parameters of the scheme, representing resp. the length of the key, a parameter of the homophonic\nencoder and the probability of the BSC.\nProof. From (9), we have the following system of \u03c4 n overdefined consistent but probabilistic equations over\nthe binary field GF (2):\n(t)\n\n(t)\n\n(t)\n\nkS1\n(t)\nkS2\n..\n.\n\n\u2295\n\u2295\n\n[0||u(t) ]G1\n[0||u(t) ]G2\n\n=\n=\n\nz1 \u2295 v1\n(t)\n(t)\nz2 \u2295 v2\n\n(t)\n\n\u2295\n\n[0||u(t) ]Gn\n\n=\n\nzn \u2295 vn\n\nkSn\n\n(t)\n\n,\n\nt = 1, 2, ..., \u03c4 ,\n\n(14)\n\n(t)\n\nwhere each equation is correct with probability equal to p, 0 is a l-dimensional vector of all zeroes, and\n(t)\nu(t) = [ui ]m\u2212l\ni=1 .\nThe above system of equations fits the setting of Lemma 1, since we have N = \u03c4 n equations, for\nLL\n(t)\n(k)\nL = n unknown, where j=1 \u03b1j xj , k = 1, . . . , N correspond to kSi , i = 1, . . . , n, t = 1, . . . , \u03c4 , and yj ,\nLM (k)\n(t)\nj = 1, . . . , M together with\nj=1 \u03b2j yj for k = M + 1, . . . , N correspond to [0||u ]Gi , i = 1, . . . , M ,\nt = 1, . . . , \u03c4 , since according to Remark 1, we can indeed separate the {[0||u(t) ]Gi }ni=1 for every t into one\nset of linear independent vectors, and another set which is obtained as linear combinations of the first set\n(M is then \u03c4 k, where k is at most m \u2212 l).\nNote that the above system of \u03c4 n equations contains only n + \u03c4 (m \u2212 l) unknown variables, and that our\n(t)\ngoal is to recover k only, i.e., we do not have any interest in recovering {ui }m\u2212l\ni=1 , t = 1, 2, ..., \u03c4 . Thus, via\n8\n\n\f(t)\n\nGaussian elimination, we can remove the \u03c4 (m \u2212 l) unknown {ui }m\u2212l\ni=1 , t = 1, 2, ..., \u03c4 , and obtain \u03c4 (n \u2212 m + l)\nequations where only k is unknown. This transforms the initial system of \u03c4 n equations into the following\none with \u03c4 (n \u2212 m \u2212 l) equations (in total) and n unknowns k:\n(k)\n\n(v)\n\n(t)\n\n(t)\n\n=\n=\n\nL1 ([zi ]ni=1 ) \u2295 L1 ([vi ]ni=1 )\n(v)\n(t)\n(z)\n(t)\nL2 ([zi ]ni=1 ) \u2295 L2 ([vi ]ni=1 )\n\n(k)\n\n=\n\nLn\u2212m+l ([zi ]ni=1 ) \u2295 Ln\u2212m+l ([vi ]ni=1 )\n\nLn\u2212m+l (k)\n(k)\n\n(z)\n\nL1 (k)\n(k)\nL2 (k)\n..\n.\n\n(z)\n\n(z)\n\n(v)\n\n(t)\n\n,\n\nt = 1, 2, ..., \u03c4 ,\n\n(15)\n\n(t)\n\n(v)\n\nwhere Lj (*), Lj (*) and Lj (*), j = 1, 2, ..., n\u2212m+l, are linear functions, all of them specified by the matrix\n(k)\n\nG and the Gaussian elimination used to remove the random bits u(t) , while Lj (*) further depends on the\n(t)\n\nmatrix St . Note that the Gaussian elimination of the variables {ui }m\u2212l\ni=1 , can be performed independently\nfor each t, implying that the entire complexity (for t = 1, 2, ..., \u03c4 ) is upper-bonded by \u03c4 O(n2.7 ) assuming\nemployment of the most efficient algorithm for the Gaussian processing.\nLemma 1 and its underlying assumptions provide that each equation in (15) is correct with some probability lower than 1 \u2212 pw , where\n1 \u2212 (1 \u2212 2p)w+1\n,\npw =\n2\n(v)\n\n(v)\n\n(t)\n\n(t)\n\n\u2217\n)(t) = Ln\u2212m+l ([vi ]ni=1 ) has coefficients that are the\nsince the noise (v1\u2217 )(t) = L1 ([vi ]ni=1 ), . . . , (vn\u2212m+l\n\nrealization of a random variable which takes value 1 with probability greater than pw =\nabove system of \u03c4 (n \u2212 m + l) equations can consequently be rewritten as:\n(z)\n\nThe\n\n(1)\n\nL\u22171 ([ki ]ni=1 )\nL\u22172 ([ki ]ni=1 )\n..\n.\n\n=\n=\n\nL1 ([zi ]ni=1 )\n(1)\n(z)\nL2 ([zi ]ni=1 )\n\nL\u2217n\u2212m+l ([ki ]ni=1 )\nL\u2217n\u2212m+l+1 ([ki ]ni=1 )\nL\u2217n\u2212m+l+2 ([ki ]ni=1 )\n..\n.\n\n=\n=\n=\n\nLn\u2212m+l ([zi ]ni=1 )\n(z)\n(2)\nL1 ([zi ]ni=1 )\n(z)\n(2)\nL2 ([zi ]ni=1 )\n\nL\u2217\u03c4 (n\u2212m+l) ([ki ]ni=1 ) =\n\nLn\u2212m+l ([zi ]ni=1 )\n\n(z)\n\n(z)\n\n(1)\n\nhk|cn\u2212m+l i\nhk|cn\u2212m+l+1 i\nhk|cn\u2212m+l+2 i\n..\n.\n\n=\n=\n=\n\ndm\u2212n+l\ndm\u2212n+l+1\ndm\u2212n+l+2\n\nhk|c\u03c4 (n\u2212m+l) i\n\n= d\u03c4 (m\u2212n+l)\n\n(16)\n\n(\u03c4 )\n\nwhere each equation is incorrect with probability greater than pw =\n1, 2, ..., \u03c4 (n \u2212 m + l), are linear functions.\nWe finally get:\nhk|c1 i\n=\nd1\nhk|c2 i\n=\nd2\n..\n.\n\n1\u2212(1\u22122p)w+1\n,\n2\n\nand where L\u2217j , j =\n\n,\n\nwhere each equation is correct with a probability upper-bounded by 1 \u2212 pw = 1 \u2212\n\u03c4 (n\u2212m+l)\n\u03c4 (n\u2212m+l)\nare known.\nand {dj }j=1\nthe n-dimensional binary vectors {cj }j=1\n9\n\n1\u2212(1\u22122p)w+1\n.\n2\n\n(17)\n\n1\u2212(1\u22122p)w+1\n,\n2\n\nand where\n\n\fAccording to the definition of the LPN problem and the above representation, the problem of recovering\nw+1\nthe secret key is at least as hard as the LPNn,\u01eb problem with \u01eb = 1\u2212(1\u22122p)\n, which concludes the proof of\n2\nthe theorem.\n\u0004\n\n4\n\nHomophonic Encoder Design Criteria\n\nFrom the above computational security evaluation, it is clear that the design of the homophonic encoder\ninfluences the computational complexity of cryptanalysis. In this section, we explicit code design criteria for\nhomophonic coding, taking into account not only the computational and information theoretical security,\nbut also the implementation complexity. Requirements can be expressed either as a function of GH given\nGECC , or as a joint function of GH and GECC .\nIndeed, the latter holds in the case of a design of the encoding-encryption system from scratch, where the\ndesign should include a coding box which performs the concatenation of homophonic and error-correction\ncoding in a manner which fits the rate of the concatenated code to the given constraints. The former on\nthe other hand applies when upgrading existing systems employing the encoding-encryption paradigm, in\nwhich case, the implementation assumption is that the employed, already existing, binary linear block errorcorrection code (m, n) which encodes m bits into a codeword from GF (2n ), could be replaced with a binary\nblock code (m\u2032 , n) with the same error correction capability but with m\u2032 > m. Accordingly, m\u2032 \u2212 m random\nbits can be concatenated with m information bits and mapped into the new m\u2032 -bits via a homophonic\nencoder. The obtained output from the homophonic encoder is the input for the error-correcting one.\nWe recall first that the basic requirements on the matrix GH , as far as information theoretical security\nis concerned, are [11, 12]:\n\u2022 Invertibility. The matrix GH should be an invertible matrix, so that the receiver can decode the\nhomophonic encoding.\n\u2022 Security. The matrix GH should map [a||u] so that in the resulting vector each bit of data from a\nis affected by at least one random bit from u (to provide a background that each bit of cipheretext is\naffected by at least one bit of u).\n\n4.1\n\nComputational complexity design criteria\n\nRecall from (3) that\nCECC (CH (a||u))\n\n=\n\n[a||u]GH GECC\n\n=\n\n[a||u]G\n\nn\nwhere G = [gi,j ]m\ni=1 j=1 is an m\u00d7n matrix containing both the homophonic and the error correction encoding.\nThe basic design requirements for a suitable homophonic encoder, i.e., the matrix GH , are pointed\nout above, and this section contains additional guidelines to design a dedicated homophonic encoding which\nprovides maximum complexity of the underlying LPN problem for given implementation and communications\noverhead.\nIt is well known that the hardness of the LPNn,\u01eb problem in the average case, heavily depends on the\nparameter \u01eb (see [5] and [7], for example). On the other hand, Theorem 2 implies that the parameter \u01eb\ndepends on the minimal value of the basic equations which should be linearly combined in order to eliminate\nthe random variables from each equation of the system. Accordingly, Theorem 2 implies the following design\ncriteria for construction of the matrix GH .\n\n10\n\n\f\u2022 Weight. For a given error-correcting code generator matrix GECC , specify the homophonic code\n(H)\nm\nmatrix GH so that the resulting matrix GH = [gij ]m\ni=1 j=1 satisfies:\nm\u2212l\nX\n\n(H)\n\ngl+i,m\u2212l+j \u2265 w , j = 1, m \u2212 l + 2, . . . , l ,\n\ni=1\n\nwhere w is a parameter.\n\u2022 Dependability. According to (14)-(16), the sub-matrix of the matrix G consisting of its m \u2212 l last\nrows should be such that any of the columns is a linear combination of at least w other columns.\nConsider thus the sub-matrix G\u2217 determined by the rows m \u2212 l + 1, m \u2212 l + 2, . . . , m and columns\n1, 2, . . . , n of the matrix G. We require that no column of the matrix G\u2217 is equal to a linear combination\nof w or less other columns of G\u2217 . This can be rephrased by asking\nrank(G\u2217 ) \u2265 w + 1.\n\n4.2\n\nImplementation design criteria\n\nOn the sender side, both the homophonic and error-correcting encodings are performed via a single vectormatrix multiplication employing the matrix G = GH GCEE .\nOn the receiver side the error-correction decoding and the homophonic decoding should be performed\nindependently. First the errors should be corrected by the error-correction decoding, because the homophonic\ndecoding requires error-free decoding input.\nThis implies that in order to minimize the implementation complexity, a desirable property is sparseness\nof the related matrices GH , G and G\u22121\nH .\n\u2022 Sparsity. For a given error-correcting code generator matrix GECC , and a given security parameter w,\nspecify the homophonic encoding matrix GH in such a manner that either it is sparse or the resulting\nmatrix G is sparse to provide minimization of the implementation complexity on the sender side, and\nat the same time the matrix G\u22121\nH is sparse in order to avoid too high computation overhead for the\nreceiver.\n\n5\n\nHomophonic Code Constructions\n\nLet us first write the m \u00d7 m wire-tap matrix GH and the m \u00d7 n error-correcting matrix GECC as\n\"\n\"\n#\n#\n(2)\n(1)\n(1)\nGH GH\nGECC\nGH =\n, GECC =\n(4)\n(2)\nIm\u2212l GH\nGECC\n(1)\n\n(2)\n\n(18)\n\nwhere GH is an l \u00d7 (m \u2212 l) matrix, GH is an l \u00d7 l matrix, Im\u2212l denotes the (m \u2212 l) \u00d7 (m \u2212 l) identity\n(4)\nmatrix, GH is an (m \u2212 l) \u00d7 l matrix written as\n\uf8ee\n\n\uf8ef\n\uf8ef\n(4)\nGH = \uf8ef\n\uf8ef\n\uf8f0\n\n(H)\n\ngl+1,m\u2212l+1\n(H)\ngl+2,m\u2212l+1\n..\n.\n(H)\ngm,m\u2212l+1\n\n(H)\n\ngl+1,m\u2212l+2\n(H)\ngl+2,m\u2212l+2\n..\n.\n(H)\ngm,m\u2212l+2\n\n11\n\n(H)\n\n. . . gl+1,m\n(H)\n. . . gl+2,m\n..\n...\n.\n(H)\n. . . gm,m\n\n\uf8f9\n\n\uf8fa\n\uf8fa\n\uf8fa,\n\uf8fa\n\uf8fb\n\n\f(2)\n\n(1)\n\nGECC is an (m \u2212 l) \u00d7 n matrix and finally GECC is an l \u00d7 n matrix, so that\nG =\n\nGH GECC\n\"\n#\"\n#\n(2)\n(1)\n(1)\nGH GH\nGECC\n(4)\n(2)\nIm\u2212l GH\nGECC\n#\n\"\n(1) (1)\n(2) (2)\nGH GECC + GH GECC\n.\n(4) (2)\n(1)\nGECC + GH GECC\n\n=\n=\n\n5.1\n\nA generic construction\n\nWe now give a general construction method for the matrix GH . Choose first\n(1)\n\n(2)\n\nGH = 0l\u00d7(m\u2212l) , GH = Il .\nLet us check that we already satisfy the information theoretical requirements.\n\u2022 Invertibility. Since GH is a square matrix, we can rephrase its invertibility using its determinant by\nasking\ndet(GH ) 6= 0.\nUsing Schur complement, this is equivalent to\n(1)\n\n(2)\n\n(4)\n\ndet(GH \u2212 GH GH ) 6= 0.\n(1)\n\n(2)\n\nThe above choice of GH and GH gives det(Il ) 6= 0 which always holds, so that the invertibility\ncondition is taken care of.\n\u2022 Security. The matrix GH should map [a||u] so that in the resulting vector each bit of data from a is\naffected by at least one random bit from u. Since\n\u0015\n\u0014\n0l\u00d7(m\u2212l)\nIl\n(4)\n= [u, a + uGH ],\n[a||u]\n(4)\nIm\u2212l\nGH\n(4)\n\nit is enough that GH has no column with only zeroes to get that indeed each bit of data from a is\naffected by at least one random bit from u.\nWe next look at the conditions coming from computational security. The weight condition can be\n(4)\nrephrased as requiring that each column of GH has Hamming weight at least w, which automatically\n(4)\nmakes sure that GH has no column with only zeroes.\nThe dependability condition relates to the sub-matrix G\u2217 determined by the rows m\u2212l+1, m\u2212l+2, . . ., m\nand columns 1, 2, . . . , n of the matrix G. Since m \u2212 l counts the number of random bits, it is reasonable to\nassume that\nm \u2212 l \u2264 l \u21d0\u21d2 m \u2264 2l,\nthat is we use at most as many random bits as data bits. Since\n#\n\u0015 \" (1) # \"\n\u0014\n(2)\n0l\u00d7(m\u2212l)\nIl\nGECC\nGECC\n=\nG = GH GECC =\n(4)\n(1)\n(4) (2)\n(2)\nIm\u2212l\nGH\nGECC + GH GECC\nGECC\nwith, assuming w.l.o.g that GECC is in systematic form,\n\uf8f9\n\uf8ee (ECC)\n(ECC)\n(ECC)\n. . . g1,n\ng1,2\ng1,1\n\uf8ef (ECC)\n(ECC) \uf8fa\n(ECC)\n. . . g2,n\ng2,2\n\uf8fa \u0002\n\uf8ef g2,1\n(1)\n\uf8fa = Im\u2212l\n\uf8ef\nGECC = \uf8ef\n..\n..\n..\n\uf8fa\n\uf8fb\n\uf8f0\n.\n.\n...\n.\n(ECC)\n(ECC)\n(ECC)\ngm\u2212l,1 gm\u2212l,2 . . . gm\u2212l,n\n12\n\n0(m\u2212l)\u00d7l\n\nP(m\u2212l)\u00d7(n\u2212m)\n\n\u0003\n\n\fand\n\n(ECC)\n\n\uf8ee\n\ngm\u2212l+1,1\n(ECC)\ngm\u2212l+2,1\n..\n.\n(ECC)\ngm,1\n\n\uf8ef\n\uf8ef\n(2)\nGECC = \uf8ef\n\uf8ef\n\uf8f0\n\n(ECC)\n\n(ECC)\n\ngm\u2212l+1,2\n(ECC)\ngm\u2212l+2,2\n..\n.\n(ECC)\ngm,2\n\n. . . gm\u2212l+1,n\n(ECC)\n. . . gm\u2212l+2,n\n..\n...\n.\n(ECC)\n. . . gm,n\n\n\uf8f9\n\n\uf8fa\n\uf8fa \u0002\n\uf8fa = 0l\u00d7(m\u2212l)\n\uf8fa\n\uf8fb\n\nIl\n\nQl\u00d7(n\u2212m)\n\n\u0003\n\n,\n\nwe can write the l \u00d7 n matrix G\u2217 as\n\uf8ee (ECC)\n\uf8f9\n(ECC)\n(ECC)\ng2m\u22122l+1,1\ng2m\u22122l+1,2\n. . . g2m\u22122l+1,n\n\uf8ef\n\uf8fa\n..\n..\n..\n\uf8ef\n\uf8fa\n\u2217\n.\n.\n.\n.\n.\n.\n\uf8ef\n\uf8fa\nG = \uf8ef\n\uf8fa\n(ECC)\n(ECC)\n(ECC)\n\uf8f0 gm,1\n\uf8fb\ngm,2\n...\ngm,n\n(1)\n(4) (2)\nGECC\n+GH GECC\n\u0015\n\u0014\n0(2l\u2212m)\u00d7(2m\u22123l)\nI2l\u2212m 0(2l\u2212m)\u00d7l\nP\u2032 (2l\u2212m)\u00d7(n\u2212m)\n.\n=\n(1)\n(4) (2)\nGECC + GH GECC\nNow\n\n(4)\n\n(2)\n\n(4)\n\n(4)\n\nGH GECC = GH [0l\u00d7(m\u2212l) Il Ql\u00d7(n\u2212m) ] = [0m\u2212l GH\n\n(4)\n\nGH Ql\u00d7(n\u2212m) ]\n\nso that finally\n\u2217\n\nG =\n\n\u0014\n\n0(2l\u2212m)\u00d7(2m\u22123l) I2l\u2212m\nIm\u2212l\n\n0(2l\u2212m)\u00d7l\n(4)\nGH\n\nP\u2032 (2l\u2212m)\u00d7(n\u2212m)\n(4)\nGH Ql\u00d7(n\u2212m) + P(m\u2212l)\u00d7(n\u2212m)\n\n\u0015\n\n.\n\nThe requirement is that\nrank(G\u2217 ) \u2265 w + 1.\nSince l \u2264 m < n, the rank of G\u2217 is at most l, and it is enough to look at the rank of the l \u00d7 m submatrix\n\u0014\n\u0015\n0(2l\u2212m)\u00d7(2m\u22123l) I2l\u2212m 0(2l\u2212m)\u00d7l\n(19)\n(4)\nIm\u2212l\nGH\nwhich varies from m \u2212 l to l since the first m \u2212 l columns are linearly independent. Thus if w + 1 \u2264 m \u2212 l,\n(4)\nthe dependency condition is satisfied naturally. Otherwise, we need to build GH such that k of its columns,\nk = 1, . . . , 2l \u2212 m are linearly independent from the m \u2212 l first columns of the above matrix. To do so, it is\n(4)\nenough to consider the 2l \u2212 m first columns of GH , and we consider the truncated matrix (19)\n\u0014\n\u0015\n0(2l\u2212m)\u00d7(2m\u22123l) I2l\u2212m 0(2l\u2212m)\u00d72l\u2212m\nIm\u2212l\nA\n(4)\n\nwhere A contains the 2l \u2212 m first columns of GH . Let us further write\n\u0015\n\u0014\nA1\n,\nA=\nA2\n\nwhere A1 is a (2m \u2212 3l) \u00d7 (2l \u2212 m) matrix, and A2 is a square 2l \u2212 m matrix. To control the rank of G\u2217 ,\nwe set A1 = 0 and we get\nrank(G\u2217 ) = m \u2212 l + k\nwhere k is the number of columns of A2 which are linearly independent from the the matrix\n\u0014\n\u0015\n0(2l\u2212m)\u00d7(2m\u22123l) I2l\u2212m\n.\nIm\u2212l\n\n(20)\n\nSetting A2 to zero makes this computation easier. Indeed, to get k such columns, it is enough to pick k\ncolumns from the 2l \u2212 m identity matrix. This might give some columns with zero or very few ones, which\nlooks like contradicting the weight condition. However, columns with higher Hamming weight can be easily\nobtained by taking linear combinations of the columns which will not change the rank.\n13\n\n\f\u2022 Dependability and Weight. Since\nrank(G\u2217 ) = m \u2212 l + k\n(4)\n\nwhere k is the number of columns of the sub-matrix of GH formed by taking its first 2m \u2212 l columns\nand last 2m \u2212 l rows which are linearly independent from (20), it is enough to ask for\nk \u2265 w + 1 + l \u2212 m.\n(4)\n\nTo ensure that each column of GH has Hamming weight w, it is enough to take linear combinations\nof the columns.\n(2)\n\n(1)\n\n\u2022 Sparsity. The choice of GH = 0l\u00d7(m\u2212l) and GH = Il makes the l first rows of GH as sparse as\npossible, since removing any zero would make the matrix non-invertible anymore. Furthermore, the\nway the dependability condition is constructed is also optimal in the sense that it starts with the least\nnumber of 1 to get the wanted rank, and then obtains the desired Hamming weight of each column by\nlinear combinations.\n\n5.2\n\nExamples of Constructions\n\nTake m = 2l so that m \u2212 l = l, and\nGH =\n\n\"\n\n#\n\n(2)\n\n(1)\n\nGH\n(4)\nGH\n\nGH\nIl\n\n=\n\n\u0014\n\n0l\nIl\n\n\u0015\n\nIl\nIl\n\n.\n(4)\n\nThe matrix GH is clearly invertible. The Hamming weight of each column of GH is 1, thus w must be\n(2)\ntaken to be 0 or 1. The matrix GH is chosen to be zero for increasing the sparsity of GH .\nAs a toy example, let us consider the (7, 4) Hamming code with\n\uf8eb\n\uf8f6\n1 0 0 0 1 1 0\n\uf8ec 0 1 0 0 1 0 1 \uf8f7\n\uf8f7\nGECC = \uf8ec\n\uf8ed 0 0 1 0 0 1 1 \uf8f8,\n0 0 0 1 1 1 1\nand\n\nGH\nWe have that\nGH GECC\nThe matrix G\u2217 is thus\nG\u2217 =\n\n\uf8eb\n\n0\n\uf8ec 0\n=\uf8ec\n\uf8ed 1\n0\n\uf8eb\n\n0\n\uf8ec 0\n=\uf8ec\n\uf8ed 1\n0\n\u0012\n\n1\n0\n\n0\n0\n0\n1\n0\n0\n0\n1\n\n0 1\n1 0\n\n1\n0\n1\n0\n\n0\n1\n0\n1\n\n0 1\n1 0\n\nSince the requirement is that the rank of G\u2217 is at least\nthat\n\uf8eb\n1 0\n\uf8ec\n\uf8ec 0 1\nG\u22121\nH =\uf8ed 1 0\n0 1\n14\n\n\uf8f6\n0\n1 \uf8f7\n\uf8f7.\n0 \uf8f8\n1\n\n1\n0\n1\n0\n\n0\n1\n1\n0\n\n1\n1\n0\n1\n\n0 1\n1 0\n\n\uf8f6\n1\n1 \uf8f7\n\uf8f7.\n1 \uf8f8\n0\n\u0013\n\n.\n\nw, this is clearly satisfied here since w = 1. Note\n\uf8f6\n1 0\n0 1 \uf8f7\n\uf8f7,\n0 0 \uf8f8\n0 0\n\n\fand the cost of encoding and decoding the homophonic code is the same.\nIn order to increase w, we could alternatively take\n\uf8eb\n\uf8f6\n0 0 1 0\n\uf8ec 0 0 0 1 \uf8f7\n\uf8f7\nGH = \uf8ec\n\uf8ed 1 0 1 1 \uf8f8,\n0 1 1 1\n\nfor which w can be taken to be 2. Then, continuing with\n\uf8eb\n0 0 1\n\uf8ec 0 0 0\nGH GECC = \uf8ec\n\uf8ed 1 0 1\n0 1 1\nwhere\n\n\u2217\n\nG =\nhas rank w = 2 as required. This time\n\n\u0012\n\nG\u22121\nH\n\n1 0\n0 1\n\uf8eb\n\n1\n\uf8ec 1\n=\uf8ec\n\uf8ed 1\n0\n\nthe (7, 4) Hamming code, we get\n\uf8f6\n0 0 1 1\n1 1 1 1 \uf8f7\n\uf8f7,\n1 0 1 0 \uf8f8\n1 0 0 1\n\n1 1\n1 1\n1\n1\n0\n1\n\n0 1\n0 0\n1\n0\n0\n0\n\n0\n1\n\n\u0013\n\n\uf8f6\n0\n1 \uf8f7\n\uf8f7,\n0 \uf8f8\n0\n\nand as expected, increasing w correspondingly decreases the sparsity of GH and its inverse.\n\n6\n\nConclusion\n\nThe paper addresses the problem of design of a homophonic code for certain enhanced encoding-encryption\nbased communication systems, reported and analyzed from information-theoretic point of view in [11]-[12].\nThe design is based on the guidelines implied by security evaluation from the computational complexity\npoint of view. Accordingly, this paper yields the following: (i) security evaluation of the considered system\nfrom the computational complexity point of view; (ii) guidelines for design of a dedicated homophonic coding\nimplied by the performed security evaluation; (iii) proposal of a dedicated homophonic code which provides\nthe desired level of security and at the same time provides low implementation overhead.\nThe security evaluation of the employed encryption is considered by hardness of recovering the secret key\nbased on the algebraic representation of the encryption in CPA scenario. It is shown that the addressed secret\nkey recovery is at least as hard as the LPN problem when, assuming an appropriate design, the corrupting\nw+1\nand p < 0.5 and w are the system parameters. Note that the in the average\nnoise is \u01eb = 1\u2212(1\u22122p)\n2\ncomplexity consideration, the LPN problem corresponding to the parameter \u01eb is much harder than the one\nwith the parameter p. Accordingly, assuming that the parameters of the scheme are appropriately selected,\nthe complexity of the secret key recovery based on the algebraic representation appears approximately as\nhard as the exhaustive search over all possible secret keys.\nThe results of security evaluation are considered as guidelines for design of a dedicated homophonic\nencoder which provides a desired security level and minimize the implementation complexity. Assuming\nthat the homophonic code should be a linear one, beside the basic requirement on the invertibility and\nthe mixing properties of the generator matrix, the following three additional criteria are pointed out and\nspecified in Sections 4.1 and 4.2: (a) Weight on columns of the generator matrix; (b) rank of the generator\nmatrix; (c) sparsity of the generator matrix. The criteria (a) and (b) appear as an implication of the security\nrequirements, and the criterion (c) is related to minimization of the implementation overhead. The previous\ndesign criteria are employed for design of a dedicated homophonic code. A generic design of the homophonic\ncoding dedicated to the considered security enhanced communication system is proposed and it is shown\nthat the design fulfills all the given criteria.\n15\n\n\fAcknowledgments\nThe research of F. Oggier is supported in part by the Singapore National Research Foundation under Research\nGrant NRF-RF2009-07 and NRF-CRP2-2007-03, and in part by the Nanyang Technological University under\nResearch Grant M58110049 and M58110070. This work was done partly while M. Mihaljevi\u0107 was visiting the\ndivision of mathematical sciences, Nanyang Technological University, Singapore, and partly while F. Oggier\nwas visiting the Research Center for Information Security, Tokyo. M. Mihaljevi\u0107 is partly supported via the\nProject # 174008.\n\nReferences\n[1] E.R. Berlekamp, R.J. McEliece, and H.C.A. van Tilborg, \"On the Inherent Intractability of Certain\nCoding Problems\", IEEE Trans. Info. Theory, vol. 24, pp. 384-386, 1978.\n[2] A. Blum, A. Kalai and H. Wasserman, \"Noise-Tolerant Learning, the Parity Problem, and the Statistical\nQuery Model\", Journal of the ACM, vol. 50, no. 4, pp. 506-519, July 2003.\n[3] GSM Technical Specifications: European Telecommunications Standards Institute (ETSI), Digital cellular telecommunications system (Phase 2+); Physical layer on the radio path; General description, TS\n100 573 (GSM 05.01), http://www.etsi.org.\n[4] GSM Technical Specifications: European Telecommunications Standards Institute (ETSI), Digital cellular telecommunications system (Phase 2+); Channel Coding, TS 100 909 (GSM 05.03),\nhttp://www.etsi.org.\n[5] M. Fossorier, M.J. Mihaljevi\u0107, H. Imai, Y. Cui and K. Matsuura, \"An Algorithm for Solving the LPN\nProblem and its Application to Security Evaluation of the HB Protocols for RFID Authentication\",\nINDOCRYPT 2006, Lecture Notes in Computer Science, vol. 4329, pp. 48-62, Dec. 2006.\n[6] R. G. Gallager, \"Low-density parity-check codes,\" IRE Trans. Inf. Theory, vol. IT-8, no. 1, pp. 21-28,\nJan. 1968.\n[7] E. Levieil and P.-A. Fouque, \"An Improved LPN Algorithm\", SCN 2006, Lecture Notes in Computer\nScience, vol. 4116, pp. 348-359, 2006.\n[8] H.N. Jendal, Y.J.B. Kuhn, and J.L. Massey, \"An information-theoretic treatment of homophonic substitution\", EUROCRYPT'89, Lecture Notes in Computer Science, vol. 434, pp. 382-394, 1990.\n[9] J. Massey, \"Some Applications of Source Coding in Cryptography\", European Transactions on Telecommunications, vol. 5, pp. 421-429, July-August 1994.\n[10] M.J. Mihaljevi\u0107 and H. Imai, \"An approach for stream ciphers design based on joint computing over\nrandom and secret data\", Computing, vol. 85, no. 1-2, pp. 153-168, June 2009.\n[11] M.J. Mihaljevi\u0107 and F. Oggier, \"A Wire-tap Approach to Enhance Security in Communication Systems\nusing the Encoding-Encryption Paradigm\", 2010 IEEE 17th Int. Conf. on Telecommunications - ICT\n2010, Proceedings, pp. 484-489, April 2010.\n[12] F. Oggier and M.J. Mihaljevi\u0107, \"An Information-Theoretic Analysis of the Security of Communication\nSystems Employing the Encoding-Encryption Paradigm\", available as CoRR abs/1008.0968, Aug. 2010.\n[13] A. Thangaraj, S. Dihidar, A.R. Calderbank, S.W. McLaughlin, and J.-M. Merolla, \"Applications of\nLDPC Codes to the Wiretap Channel\", IEEE Trans. Information Theory, vol. 53, no. 8, pp. 2933-2945,\nAugust 2007 .\n[14] A.D. Wyner, \"The wire-tap channel\", Bell Systems Technical Journal, vol. 54, pp. 1355-1387, Oct. 1975.\n\n16\n\n\f"}