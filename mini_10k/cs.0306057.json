{"id": "http://arxiv.org/abs/cs/0306057v1", "guidislink": true, "updated": "2003-06-12T17:31:32Z", "updated_parsed": [2003, 6, 12, 17, 31, 32, 3, 163, 0], "published": "2003-06-12T17:31:32Z", "published_parsed": [2003, 6, 12, 17, 31, 32, 3, 163, 0], "title": "IceCube's Development Environment", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0306070%2Ccs%2F0306009%2Ccs%2F0306097%2Ccs%2F0306127%2Ccs%2F0306047%2Ccs%2F0306022%2Ccs%2F0306038%2Ccs%2F0306085%2Ccs%2F0306062%2Ccs%2F0306094%2Ccs%2F0306010%2Ccs%2F0306080%2Ccs%2F0306076%2Ccs%2F0306102%2Ccs%2F0306130%2Ccs%2F0306107%2Ccs%2F0306131%2Ccs%2F0306136%2Ccs%2F0306045%2Ccs%2F0306052%2Ccs%2F0306029%2Ccs%2F0306128%2Ccs%2F0306055%2Ccs%2F0306110%2Ccs%2F0306091%2Ccs%2F0306090%2Ccs%2F0306061%2Ccs%2F0306124%2Ccs%2F0306030%2Ccs%2F0306065%2Ccs%2F0306036%2Ccs%2F0306093%2Ccs%2F0306037%2Ccs%2F0306088%2Ccs%2F0306082%2Ccs%2F0306120%2Ccs%2F0306066%2Ccs%2F0306075%2Ccs%2F0306024%2Ccs%2F0306084%2Ccs%2F0306032%2Ccs%2F0306060%2Ccs%2F0306039%2Ccs%2F0306048%2Ccs%2F0306072%2Ccs%2F0306064%2Ccs%2F0306017%2Ccs%2F0306014%2Ccs%2F0306083%2Ccs%2F0306112%2Ccs%2F0306031%2Ccs%2F0306028%2Ccs%2F0306106%2Ccs%2F0306098%2Ccs%2F0306074%2Ccs%2F0306049%2Ccs%2F0306095%2Ccs%2F0306096%2Ccs%2F0306135%2Ccs%2F0306057%2Ccs%2F0306113%2Ccs%2F0306108%2Ccs%2F0306034%2Ccs%2F0306081%2Ccs%2F0306086%2Ccs%2F0306105%2Ccs%2F0306033%2Ccs%2F0306114%2Ccs%2F0306125%2Ccs%2F0306011%2Ccs%2F0306005%2Ccs%2F0306043%2Ccs%2F0306021%2Ccs%2F0306089%2Ccs%2F0306092%2Ccs%2F0306053%2Ccs%2F0306059%2Ccs%2F0306035%2Ccs%2F0306058%2Ccs%2F0306115%2Ccs%2F0306025%2Ccs%2F0306018%2Ccs%2F0607100%2Ccs%2F0607082%2Ccs%2F0607049%2Ccs%2F0607021%2Ccs%2F0607020%2Ccs%2F0607036%2Ccs%2F0607059%2Ccs%2F0607096%2Ccs%2F0607045%2Ccs%2F0607057%2Ccs%2F0607136%2Ccs%2F0607129%2Ccs%2F0607128%2Ccs%2F0607113%2Ccs%2F0607023%2Ccs%2F0607043%2Ccs%2F0607145%2Ccs%2F0607005%2Ccs%2F0607014&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "IceCube's Development Environment"}, "summary": "When the IceCube experiment started serious software development it needed a\ndevelopment environment in which both its developers and clients could work and\nthat would encourage and support a good software development process. Some of\nthe key features that IceCube wanted in such a environment were: the separation\nof the configuration and build tools; inclusion of an issue tracking system;\nsupport for the Unified Change Model; support for unit testing; and support for\ncontinuous building. No single, affordable, off the shelf, environment offered\nall these features. However there are many open source tools that address\nsubsets of these feature, therefore IceCube set about selecting those tools\nwhich it could use in developing its own environment and adding its own tools\nwhere no suitable tools were found. This paper outlines the tools that where\nchosen, what are their responsibilities in the development environment and how\nthey fit together. The complete environment will be demonstrated with a walk\nthrough of single cycle of the development process.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0306070%2Ccs%2F0306009%2Ccs%2F0306097%2Ccs%2F0306127%2Ccs%2F0306047%2Ccs%2F0306022%2Ccs%2F0306038%2Ccs%2F0306085%2Ccs%2F0306062%2Ccs%2F0306094%2Ccs%2F0306010%2Ccs%2F0306080%2Ccs%2F0306076%2Ccs%2F0306102%2Ccs%2F0306130%2Ccs%2F0306107%2Ccs%2F0306131%2Ccs%2F0306136%2Ccs%2F0306045%2Ccs%2F0306052%2Ccs%2F0306029%2Ccs%2F0306128%2Ccs%2F0306055%2Ccs%2F0306110%2Ccs%2F0306091%2Ccs%2F0306090%2Ccs%2F0306061%2Ccs%2F0306124%2Ccs%2F0306030%2Ccs%2F0306065%2Ccs%2F0306036%2Ccs%2F0306093%2Ccs%2F0306037%2Ccs%2F0306088%2Ccs%2F0306082%2Ccs%2F0306120%2Ccs%2F0306066%2Ccs%2F0306075%2Ccs%2F0306024%2Ccs%2F0306084%2Ccs%2F0306032%2Ccs%2F0306060%2Ccs%2F0306039%2Ccs%2F0306048%2Ccs%2F0306072%2Ccs%2F0306064%2Ccs%2F0306017%2Ccs%2F0306014%2Ccs%2F0306083%2Ccs%2F0306112%2Ccs%2F0306031%2Ccs%2F0306028%2Ccs%2F0306106%2Ccs%2F0306098%2Ccs%2F0306074%2Ccs%2F0306049%2Ccs%2F0306095%2Ccs%2F0306096%2Ccs%2F0306135%2Ccs%2F0306057%2Ccs%2F0306113%2Ccs%2F0306108%2Ccs%2F0306034%2Ccs%2F0306081%2Ccs%2F0306086%2Ccs%2F0306105%2Ccs%2F0306033%2Ccs%2F0306114%2Ccs%2F0306125%2Ccs%2F0306011%2Ccs%2F0306005%2Ccs%2F0306043%2Ccs%2F0306021%2Ccs%2F0306089%2Ccs%2F0306092%2Ccs%2F0306053%2Ccs%2F0306059%2Ccs%2F0306035%2Ccs%2F0306058%2Ccs%2F0306115%2Ccs%2F0306025%2Ccs%2F0306018%2Ccs%2F0607100%2Ccs%2F0607082%2Ccs%2F0607049%2Ccs%2F0607021%2Ccs%2F0607020%2Ccs%2F0607036%2Ccs%2F0607059%2Ccs%2F0607096%2Ccs%2F0607045%2Ccs%2F0607057%2Ccs%2F0607136%2Ccs%2F0607129%2Ccs%2F0607128%2Ccs%2F0607113%2Ccs%2F0607023%2Ccs%2F0607043%2Ccs%2F0607145%2Ccs%2F0607005%2Ccs%2F0607014&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "When the IceCube experiment started serious software development it needed a\ndevelopment environment in which both its developers and clients could work and\nthat would encourage and support a good software development process. Some of\nthe key features that IceCube wanted in such a environment were: the separation\nof the configuration and build tools; inclusion of an issue tracking system;\nsupport for the Unified Change Model; support for unit testing; and support for\ncontinuous building. No single, affordable, off the shelf, environment offered\nall these features. However there are many open source tools that address\nsubsets of these feature, therefore IceCube set about selecting those tools\nwhich it could use in developing its own environment and adding its own tools\nwhere no suitable tools were found. This paper outlines the tools that where\nchosen, what are their responsibilities in the development environment and how\nthey fit together. The complete environment will be demonstrated with a walk\nthrough of single cycle of the development process."}, "authors": ["S. Patton", "D. Glowacki"], "author_detail": {"name": "D. Glowacki"}, "author": "D. Glowacki", "arxiv_comment": "Talk from the 2003 Computing in High Energy and Nuclear Physics\n  (CHEP03), La Jolla, Ca, USA, March 2003, 6 pages, 9 Figures, LaTeX. PSN\n  MONT001", "links": [{"href": "http://arxiv.org/abs/cs/0306057v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0306057v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.2.6", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0306057v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0306057v1", "journal_reference": null, "doi": null, "fulltext": "CHEP03, La Jolla, March 24-28, 2003\n\nIceCube's Development Environment.\nS. Patton\nLBNL, Berkeley, CA 94720, USA\n\nD. Glowacki\n\narXiv:cs/0306057v1 [cs.SE] 12 Jun 2003\n\nSpace Science and Engineering Center, University of Wisconsin, Madison, WI 53706, USA\n\nWhen the IceCube experiment started serious software development it needed a development environment\nin which both its developers and clients could work and that would encourage and support a good software\ndevelopment process. Some of the key features that IceCube wanted in such a environment were: the separation\nof the configuration and build tools; inclusion of an issue tracking system; support for the Unified Change Model;\nsupport for unit testing; and support for continuous building. No single, affordable, off the shelf, environment\noffered all these features. However there are many open source tools that address subsets of these feature,\ntherefore IceCube set about selecting those tools which it could use in developing its own environment and\nadding its own tools where no suitable tools were found. This paper outlines the tools that where chosen, what\nare their responsibilities in the development environment and how they fit together. The complete environment\nwill be demonstrated with a walk through of single cycle of the development process.\n\n1. Introduction\n1.1. IceCube Overview\nThe IceCube experiment is a neutrino telescope in\nwhich 1 km3 of ice is instrumented with Digital Optical Modules (DOMs), i.e. light detectors. The experiment is comprised of around 150 collaborators from\nall over Europe and America, but it is located at the\nSouth Pole. This location provides some fairly unique\nproblems such as the following:\n\u2022 For 8 months of the year the Pole is manned\nby \"Winter-overs\" only and there is no outside\naccess.\n\u2022 These \"Winter-overs\" are not usually the same\npeople who develop the experiment's software.\n\u2022 The satellite connection to the Pole is limited\nand can also be intermittent.\nGiven these conditions not only is software reliability a major asset to the experiment, but it is also\nessential for the \"Winter-overs\" to be able to handle\nany software issue that arise during the 8 months that\nthe Pole is shut. Therefore it is important for IceCube\nto have a software development environment that can\nhelp mitigate these issues.\n\n2. Software Development Environment\n2.1. Requirements\nThe software reliability issue led IceCube to make\nthe decision that one of its key requirements for its\nsoftware development environment is that it must support and encourage industry proven \"good practices\".\nThis was considered to be one of the best ways to mitigate the risk to the whole project contributed by the\nMONT001\n\nsoftware reliability issue. This led to the environment\nneeding to provide tools which covered the following\npractices:\nWork Space Management This includes support\nfor some version of the \"Unified Change Management\" model [1].\nCode Building This is separate for the work space\nmanagement, as this tools will have language\ndependent portions, whereas work space management should be language neutral.\nUnit Testing This helps capture the requirements of\nthe software in a concrete form. It also means\nthat software units can be replaced provided\nthat the new code passes these tests.\nContinuous integration This covers the repeated\nbuilding, testing and reporting of any new code\nadditions, so that errors can be found early in\nthe development process.\nIssue Tracking This provides an institutional memory for the experiment as there is expected to\nbe significant turnover of personnel due to the\nlong lifetime of the experiment.\nAnother decision, that also addressed reliability\nrisk, was that as much software as possible at the Pole\nshould be written in Java as this was a found to be a\nmore robust language than C++. However the physicists required that their online filter code be written\nin C++ so that they would be able to exploit the resources provided by the ROOT package [2]. Similarly,\nDOM programming is best done in C, due to the nature of the hardware. This meant the the development\nenvironment needed multi-language support.\n\n1\n\n\f2\n\nCHEP03, La Jolla, March 24-28, 2003\n\nRebaseline\n\nIntegrate\n\nInitialize\n\nDevelop\n\nTest\n\nDeliver\n\nFigure 1: The work space management cycle as defined by the Unified Change Management model.\n\n2.2. Implementation\nNo single, affordable, off the shelf product was\nfound that fulfilled all these requirements. Meanwhile\nit was observed that there were many open source\ntools that addressed subsets of these requirements.\nTherefore IceCube decided to create its own development environment by selecting those open source\ntools which it could exploit and develop its own tools\nin those areas where no open source solution existed.\nIn the end this turned out to be only one area, work\nspace management.\n2.2.1. Work Space Management\n\nFigure 1 illustrates the basic ideas behind the work\nspace management cycle as defined by the Unified\nChange Management model. A developer enters the\ncycle by initializing an area to be a work space to\ntack a specified issue. Once the space is established,\nthe developer is free to work on the code and its test,\nincluding adding new code and new tests if the issue is\nan enhancement request. Eventually the point should\nbe reached when the change is notional complete. At\nthis point in time the code should pass all of its unit\ntests. Once this requirement has been satisfied the\ncode is then delivered, ready for integration with the\nrest of the software product.\nThe exact results of code delivery depends a great\ndeal on the size of the product. For small products\ndelivery may simply be inclusion of the new and modMONT001\n\nified code in the next continuous integration test of\nthe product. Large projects, on the other hand, will\nbe broken down into hierarchical subsystems and \"delivery\"\" will mean that the new and modified code is\npassed on to an integrator who will bring together all\nthe changes in that subsystem, test that they work\ntogether and then pass the resulting code base on to\nthe next level of the hierarchy.\nAs noted above, no open source tool was found to\nhandle these responsibilities so the bfd tool has been\ncreated. This initializes work spaces with the files and\nsoft links they need to be able to work. It also adds a\nlayer of policy on top of a code archive system, in IceCube's case this is CVS, that handles code checkout,\ncheckin and tagging.\n2.2.2. Code Building\n\nAs the core of the IceCube software system will\nwritten be in Java, it was decided that ant [3] would\nbe the best choice as the main build tool for the environment. This tool is already the standard build tool\nfor many Java products. One of the major benefits\nis that it is written in Java which means that it can\nexecute anywhere you expect Java code to execute.\nAlso, by being written in Java, ant easily extensible although there are already plenty of \"tasks\" for\nhandling the more common duties associated with\ncode building such as; skeleton processing; running\nJUnit (see below); integration with other tools such\nas JDepend [4] - a metric calculation program.\n\n\fCHEP03, La Jolla, March 24-28, 2003\nMain targets:\nclean\ncompile\ncreateClass\ncreateInterface\ncreatePackage\ndocs\njavadocs\nlib\nreport\ntest\n\nClean all directories and files built for this project\nCompile this project\nCreate new .java files for a class an its matching test\nCreate new .java files for an interface an its matching\ntest\nCreate a new package\nCreate API and test documents for this project\nCreate the Javadocs for this project\nCreate the library for this project\nCreate the report on the tests run for this project\nRun the tests for this project\n\nFigure 2: The public targets for the standard build.xml file for a project.\n\nThe execution of ant is driven by a build.xml file,\ntherefore a standard build.xml file is provided for\neach project within the IceCube software system. Figure 2 shows the public targets for the standard file.\nSimilarly a standard build.xml file is provided for\neach work space. This file contains call downs to the\npublic targets of each project contained in a work\nspace, as well as extra targets that handle work space\nlevel issues. e.g. creation of deployment tar-balls.\n2.2.3. Unit Testing\n\nThe model adopted for unit testing in IceCube is\nthe XUnit framework [5]. The Java implementation of\nthis framework is called JUnit [6]. In this framework\na set of test for a particular unit (at the base level\nthis is a class) are created and grouped together in a\n\"TestCase\" for that unit. Each test codifies one of the\nrequirements that has been specified for that unit.\nA skeleton for the TestCase for a class is generated\nby ant when ant is used to generate the class skeleton. Thus, for the simpler classes the developer simply\nneeds to provide a set of implementations that test all\nrequirements and the job is complete.\nJUnit provides both a GUI and text based interface\nfor testing. However ant also provides its own interface and this is the one used by IceCube. The ant\ninterface generates an XML file as well as providing a\nsummary of the execution of the tests. A further ant\ntask can be used to convert this XML file into a set of\nHTML frames that can easily be viewed to see which\ntests succeeded and which failed and why.\n\nmatch to the rest of the IceCube system. Builds are\ncurrently executed every time a change committed to\nthe CVS archive and a build is not in progress. Work\nis in progress to also allow builds to be scheduled, e.g.\nevery night.\nThe results of a build can be readily made available\non the Web, along with the results of the unit test.\nAs well as the standard CruiseControl output, the\nresults can be passed to the Tinderbox [8] program\nwhich can display a graphical of the current state of\nvarious different configurations of builds.\n2.2.5. Issue Tracking\n\nIn the initial incarnation of the IceCube development environment Issuezilla was chosen to handle issue tracking. This product was an outgrowth of the\nBugzilla product used by Netscape to track Mozilla\nissues. However the future of this product is unclear\nas its developers are now focused on a Java based replacement, Scarab, whose development appears to a\nstalled over the last half year of so.\nIn the meantime an open source development of the\nold SourceForge project, GForge [9], has recently announced its presence. This tool not only provides issue tracking facilities, but it can also act as a \"portal\" though which the entire software effort of IceCube\ncould be accessed.\nAll this means that the Issue tracking portion of\nthe IceCube development environment has yet to be\nfinally settled.\n\n2.2.4. Continuous integration\n\nThe earlier a problem can be discovered the sooner\nit can be fixed and the less impact it will have on\nthe overall development of a software product. To\nthat end it makes sense to continuously integrate all\nparts of a product to check that no change has broken\nanother part of the software. IceCube's solution to\nthis issue is to use the CruiseControl [7] software. This\ncan be integrated with ant build files so is a good\nMONT001\n\n3. Walk Through of a User Session\nIn this section of the paper we will see an example\nwalk through of the development environment highlighting many of the typical uses. Some features of\nthe environment, e.g. baselining, are not yet implemented and so are not included in this example.\n\n3\n\n\f4\n\nCHEP03, La Jolla, March 24-28, 2003\n[patton@glacier patton]$ mkdir work\n[patton@glacier patton]$ cd work\n[patton@glacier work]$ bfd init /home/icecube/tools\n... <output skipped> ...\n[patton@glacier work]$ ls -l\ntotal 24\n-rw-rw-r-1 patton\npatton\n297 Jun 9 15:31\n-rw-rw-r-1 patton\npatton\n5443 Jun 9 15:31\n-rw-rw-r-1 patton\npatton\n5065 Jun 9 15:31\ndrwxrwxr-x\n6 patton\npatton\n4096 Jun 9 15:31\n[patton@glacier work]$ source setup.sh\n\nbuild.xml\nsetup.csh\nsetup.sh\ntools\n\nFigure 3: An example of work space creation.\n\n3.1. Creating a Work Space\nFigure 3 shows an example of how a work space can\nbe initialized. It is fairly straightforward. A directory, which will be the work space, is creates and then\nbfd init is executed in that directory. This created\nthe necessary files and soft links. The example shows\nthe contents of the work space after it is initialized.\nThe final set of the example shows the \"sourcing\" of\nthe appropriate setup file that sets up the necessary\nenvironmental variables to use the work space. This\ncommand needs to be executed every time a session\nbegins work in the work space.\n\n3.2. Checking out and Building a Project\nFigure 4 shows how to checkout a project, in this\ncase the icebucket project, from the code archive and\nthen build it using the ant command. As you can see\nin the example two jar files are created, one holds\nthe project code, and the other holds the code and\nresources needed to run the unit tests of the project.\n\n3.3. Creating a New Project\nFigure 5 shows how the contents of a new project,\ngromit, can be created using ant. Dependencies of\none project on another are stored in the project.xml\nfile of project, thus the need to edit this file in the\nexample to include the fact that gromit is dependent\nupon icebucket.\n\nIt also shows how a JUnit test can be run outside ant.\n\n3.6. Delivering a Project\nFigure 8 shows how, once development of a class has\nbeen completed, it can be delivered and thus made\navailable to the next stage of integration.\n\n3.7. Cleaning up\nFigure 9 shows how you can clean up a work space\nonce its task has been accomplished. Using this command, rather than simply using a rm -rf, checks that\neverything has been safely stored in the code archive.\n\n4. Summary\nIceCube has created a development environment for\nits software based, where possible, on open source\ntools. The aim of this environment has been to simplify the developers work load by integrating \"good\npractices\" into the environment. So far these goals\nhave been achieved and early adopters of the environment have been pleased by the ease it has brought to\ntheir development process.\n\nReferences\n3.4. Creating a New Class\nFigure 6 shows how ant can be used to create new\nclass files. It also shows that the test file for a class is\nalso created at the same time as the class itself.\n\n3.5. Implementing a Class\nFigure 7 shows the steps that can now be taken to\nprovide an implementation of a class and its unit test.\nMONT001\n\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n[8]\n[9]\n\nhttp://www.rational.com/products/whitepapers/415.jsp\nhttp://root.cern.ch/\nhttp://ant.apache.org/\nhttp://www.clarkware.com/software/JDepend.html\nhttp://www.xprogramming.com/testfram.htm\nhttp://junit.org\nhttp://cruisecontrol.sf.net/\nhttp://www.mozilla.org/tinderbox.html\nhttp://www.gforge.org/\n\n\fCHEP03, La Jolla, March 24-28, 2003\n[patton@glacier work]$ bfd co icebucket\n... <output skipped> ...\n[patton@glacier work]$ cd icebucket\n[patton@glacier icebucket]$ ant\nBuildfile: build.xml\n... <output skipped> ...\nBUILD SUCCESSFUL\nTotal time: 9 seconds\n[patton@glacier icebucket]$ cd ..\n[patton@glacier work]$ ls -l lib\ntotal 8\n-rw-rw-r-1 patton\npatton\n3455 Jun\n-rw-rw-r-1 patton\npatton\n3004 Jun\n\n9 15:39 icebucket.jar\n9 15:39 icebucket-test.jar\n\nFigure 4: An example of checking out and building the icebucket project.\n\n[patton@glacier work]$ bfd co gromit\n... <output skipped> ...\n[patton@glacier work]$ ant -DPACKAGE=icecube.tools.examples \\\n>\n-DPROJECT=gromit createProject\nBuildfile: build.xml\n... <output skipped> ...\nBUILD SUCCESSFUL\nTotal time: 2 seconds\n[patton@glacier work]$ ls -l gromit\ntotal 16\n-rw-rw-r-1 patton\npatton\n397 Jun 9 15:45 build.xml\n-rw-rw-r-1 patton\npatton\n292 Jun 9 15:45 project.xml\ndrwxrwxr-x\n4 patton\npatton\n4096 Jun 9 15:45 resources\ndrwxrwxr-x\n3 patton\npatton\n4096 Jun 9 15:45 src\n[patton@glacier work]$ emacs gromit/project.xml\n... <add dependency on icebucket> ...\n[patton@glacier work]$ bfd uadd gromit\n\nFigure 5: An example of populating a new project with its default files.\n\n[patton@glacier work]$ cd gromit\n[patton@glacier gromit]$ ant -DCLASS=Counter2 createClass\n... <output skipped> ...\n[patton@glacier gromit]$ ls -lR src/icecube/tools/examples/\nsrc/icecube/tools/examples/:\ntotal 12\n-rw-rw-r-1 patton\npatton\n1008 Jun 9 15:50 Counter2.java\n-rw-rw-r-1 patton\npatton\n575 Jun 9 15:45 package.html\ndrwxrwxr-x\n2 patton\npatton\n4096 Jun 9 15:50 test\nsrc/icecube/tools/examples/test:\ntotal 8\n-rw-rw-r-1 patton\npatton\n-rw-rw-r-1 patton\npatton\n\n2178 Jun\n424 Jun\n\n9 15:50 Counter2Test.java\n9 15:45 package.html\n\nFigure 6: An example of creating a skeleton file for a new class and its tests\n\nMONT001\n\n5\n\n\f6\n\nCHEP03, La Jolla, March 24-28, 2003\n[patton@glacier gromit]$ cd src/icecube/tools/examples/\n[patton@glacier examples]$ emacs test/Counter2Test.java\n... <write tests> ...\n[patton@glacier examples]$ emacs Counter2.java\n... <implement class> ...\n[patton@glacier examples]$ cd ../../../..\n[patton@glacier gromit]$ ant lib\n... <output skipped> ...\n[patton@glacier gromit]$ cd ..\n[patton@glacier work]$ java -cp lib/gromit-test.jar \\\n> junit.textui.TestRunner icecube.tools.examples.test.Counter2Test\n.....\nTime: 0.159\nOK (5 tests)\n\nFigure 7: An example showing the steps used to implement a new class and its tests.\n\n[patton@glacier work]$ bfd uadd gromit\n... <output skipped> ...\n[patton@glacier work]$ bfd archive -m \"New example project\" gromit\n... <output skipped> ...\n[patton@glacier work]$ bfd deliver -j gromit\nAre you sure you want to deliver \"gromit\" with tag V01-00-00\ny/n: y\nV01-00-00 of \"gromit\" has been delivered.\n\nFigure 8: An example delivering a project after its modifications have been completed.\n\n[patton@glacier work]$ bfd dispose gromit\nNo files have been added to, or modified in, \"gromit\".\nThere are no unknown files in, \"gromit\".\nDisposed of \"gromit\"\n[patton@glacier work]$ bfd dispose\nAre you sure you want to dispose of the entire workspace?\ny/n: y\nNo files have been added to, or modified in, \"icebucket\".\nThere are no unknown files in, \"icebucket\".\nDisposed of \"icebucket\"\nDisposed of workspace files...anything left is your own problem.\n[patton@glacier work]$ ls -l\ntotal 0\n\nFigure 9: An example of cleaning up a work space once its task has been accomplished.\n\nMONT001\n\n\f"}