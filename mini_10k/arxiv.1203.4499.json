{"id": "http://arxiv.org/abs/1203.4499v1", "guidislink": true, "updated": "2012-03-20T16:44:27Z", "updated_parsed": [2012, 3, 20, 16, 44, 27, 1, 80, 0], "published": "2012-03-20T16:44:27Z", "published_parsed": [2012, 3, 20, 16, 44, 27, 1, 80, 0], "title": "Extended Report: The Implicit Calculus", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.3996%2C1203.4143%2C1203.5144%2C1203.6481%2C1203.4009%2C1203.6522%2C1203.4232%2C1203.4797%2C1203.3580%2C1203.0268%2C1203.0873%2C1203.5851%2C1203.5683%2C1203.2267%2C1203.2258%2C1203.6354%2C1203.6306%2C1203.3656%2C1203.3754%2C1203.6656%2C1203.4979%2C1203.4665%2C1203.1464%2C1203.2767%2C1203.4387%2C1203.4547%2C1203.2565%2C1203.0541%2C1203.3128%2C1203.2543%2C1203.1797%2C1203.2403%2C1203.1137%2C1203.6134%2C1203.4750%2C1203.0917%2C1203.2765%2C1203.4141%2C1203.3998%2C1203.1405%2C1203.3679%2C1203.0419%2C1203.1301%2C1203.1116%2C1203.0079%2C1203.5227%2C1203.6389%2C1203.2194%2C1203.6468%2C1203.5661%2C1203.4499%2C1203.3691%2C1203.0129%2C1203.3003%2C1203.3729%2C1203.2268%2C1203.2847%2C1203.2706%2C1203.4869%2C1203.3937%2C1203.3015%2C1203.0971%2C1203.6556%2C1203.5188%2C1203.1821%2C1203.3359%2C1203.6625%2C1203.5625%2C1203.1064%2C1203.3810%2C1203.5018%2C1203.3606%2C1203.3818%2C1203.0101%2C1203.3383%2C1203.2947%2C1203.5385%2C1203.0334%2C1203.3977%2C1203.2308%2C1203.1437%2C1203.6746%2C1203.3217%2C1203.5517%2C1203.4354%2C1203.0523%2C1203.0048%2C1203.2861%2C1203.2685%2C1203.5208%2C1203.4549%2C1203.2452%2C1203.3877%2C1203.0032%2C1203.6335%2C1203.3108%2C1203.1122%2C1203.4202%2C1203.3733%2C1203.4895%2C1203.0342&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Extended Report: The Implicit Calculus"}, "summary": "Generic programming (GP) is an increasingly important trend in programming\nlanguages. Well-known GP mechanisms, such as type classes and the C++0x\nconcepts proposal, usually combine two features: 1) a special type of\ninterfaces; and 2) implicit instantiation of implementations of those\ninterfaces.\n  Scala implicits are a GP language mechanism, inspired by type classes, that\nbreak with the tradition of coupling implicit instantiation with a special type\nof interface. Instead, implicits provide only implicit instantiation, which is\ngeneralized to work for any types. This turns out to be quite powerful and\nuseful to address many limitations that show up in other GP mechanisms.\n  This paper synthesizes the key ideas of implicits formally in a minimal and\ngeneral core calculus called the implicit calculus, and it shows how to build\nsource languages supporting implicit instantiation on top of it. A novelty of\nthe calculus is its support for partial resolution and higher-order rules (a\nfeature that has been proposed before, but was never formalized or\nimplemented). Ultimately, the implicit calculus provides a formal model of\nimplicits, which can be used by language designers to study and inform\nimplementations of similar mechanisms in their own languages.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.3996%2C1203.4143%2C1203.5144%2C1203.6481%2C1203.4009%2C1203.6522%2C1203.4232%2C1203.4797%2C1203.3580%2C1203.0268%2C1203.0873%2C1203.5851%2C1203.5683%2C1203.2267%2C1203.2258%2C1203.6354%2C1203.6306%2C1203.3656%2C1203.3754%2C1203.6656%2C1203.4979%2C1203.4665%2C1203.1464%2C1203.2767%2C1203.4387%2C1203.4547%2C1203.2565%2C1203.0541%2C1203.3128%2C1203.2543%2C1203.1797%2C1203.2403%2C1203.1137%2C1203.6134%2C1203.4750%2C1203.0917%2C1203.2765%2C1203.4141%2C1203.3998%2C1203.1405%2C1203.3679%2C1203.0419%2C1203.1301%2C1203.1116%2C1203.0079%2C1203.5227%2C1203.6389%2C1203.2194%2C1203.6468%2C1203.5661%2C1203.4499%2C1203.3691%2C1203.0129%2C1203.3003%2C1203.3729%2C1203.2268%2C1203.2847%2C1203.2706%2C1203.4869%2C1203.3937%2C1203.3015%2C1203.0971%2C1203.6556%2C1203.5188%2C1203.1821%2C1203.3359%2C1203.6625%2C1203.5625%2C1203.1064%2C1203.3810%2C1203.5018%2C1203.3606%2C1203.3818%2C1203.0101%2C1203.3383%2C1203.2947%2C1203.5385%2C1203.0334%2C1203.3977%2C1203.2308%2C1203.1437%2C1203.6746%2C1203.3217%2C1203.5517%2C1203.4354%2C1203.0523%2C1203.0048%2C1203.2861%2C1203.2685%2C1203.5208%2C1203.4549%2C1203.2452%2C1203.3877%2C1203.0032%2C1203.6335%2C1203.3108%2C1203.1122%2C1203.4202%2C1203.3733%2C1203.4895%2C1203.0342&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Generic programming (GP) is an increasingly important trend in programming\nlanguages. Well-known GP mechanisms, such as type classes and the C++0x\nconcepts proposal, usually combine two features: 1) a special type of\ninterfaces; and 2) implicit instantiation of implementations of those\ninterfaces.\n  Scala implicits are a GP language mechanism, inspired by type classes, that\nbreak with the tradition of coupling implicit instantiation with a special type\nof interface. Instead, implicits provide only implicit instantiation, which is\ngeneralized to work for any types. This turns out to be quite powerful and\nuseful to address many limitations that show up in other GP mechanisms.\n  This paper synthesizes the key ideas of implicits formally in a minimal and\ngeneral core calculus called the implicit calculus, and it shows how to build\nsource languages supporting implicit instantiation on top of it. A novelty of\nthe calculus is its support for partial resolution and higher-order rules (a\nfeature that has been proposed before, but was never formalized or\nimplemented). Ultimately, the implicit calculus provides a formal model of\nimplicits, which can be used by language designers to study and inform\nimplementations of similar mechanisms in their own languages."}, "authors": ["Bruno C. d. S. Oliveira", "Tom Schrijvers", "Wontae Choi", "Wonchan Lee", "Kwangkeun Yi"], "author_detail": {"name": "Kwangkeun Yi"}, "author": "Kwangkeun Yi", "arxiv_comment": "13 pages, extended report of paper accepted at PLDI 2012", "links": [{"href": "http://arxiv.org/abs/1203.4499v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1203.4499v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1203.4499v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1203.4499v1", "journal_reference": null, "doi": null, "fulltext": "Extended Report: The Implicit Calculus\n\narXiv:1203.4499v1 [cs.PL] 20 Mar 2012\n\nA New Foundation for Generic Programming\nBruno C. d. S. Oliveira\n\nTom Schrijvers\n\nWontae Choi\n\nSeoul National University\nbruno@ropas.snu.ac.kr\n\nUniversiteit Gent\ntom.schrijvers@ugent.be\n\nSeoul National University\nwtchoi@ropas.snu.ac.kr\n\nWonchan Lee\n\nKwangkeun Yi\n\nSeoul National University\nwclee@ropas.snu.ac.kr\n\nSeoul National University\nkwang@ropas.snu.ac.kr\n\nAbstract\nGeneric programming (GP) is an increasingly important trend in\nprogramming languages. Well-known GP mechanisms, such as\ntype classes and the C++0x concepts proposal, usually combine\ntwo features: 1) a special type of interfaces; and 2) implicit instantiation of implementations of those interfaces.\nScala implicits are a GP language mechanism, inspired by type\nclasses, that break with the tradition of coupling implicit instantiation with a special type of interface. Instead, implicits provide only\nimplicit instantiation, which is generalized to work for any types.\nThis turns out to be quite powerful and useful to address many limitations that show up in other GP mechanisms.\nThis paper synthesizes the key ideas of implicits formally in\na minimal and general core calculus called the implicit calculus\n(\u03bb\u21d2 ), and it shows how to build source languages supporting implicit instantiation on top of it. A novelty of the calculus is its support for partial resolution and higher-order rules (a feature that has\nbeen proposed before, but was never formalized or implemented).\nUltimately, the implicit calculus provides a formal model of implicits, which can be used by language designers to study and inform\nimplementations of similar mechanisms in their own languages.\nCategories and Subject Descriptors D.3.2 [Programming Languages]: Language Classifications-Functional Languages, ObjectOriented Languages; F.3.3 [Logics and Meanings of Programs]:\nStudies of Program Constructs\nGeneral Terms\n\nLanguages\n\nKeywords Implicit parameters, type classes, C++ concepts, generic\nprogramming, Haskell, Scala.\n\n1. Introduction\nGeneric programming (GP) [23] is a programming style that decouples algorithms from the concrete types on which they operate. Decoupling is achieved through parametrization. Typical forms\nof parametrization include parametrization by type (for example:\nparametric polymorphism, generics or templates) or parametrization by algebraic structures (such as a monoid or a group).\nA central idea in generic programming is implicit instantiation of generic parameters. Implicit instantiation means that, when\ngeneric algorithms are called with concrete arguments, the generic\narguments (concrete types, algebraic structures, or some other form\nof generic parameters) are automatically determined by the compiler. The benefit is that generic algorithms become as easy to use\n\nas specialized algorithms. To illustrate implicit instantiation and its\nbenefits consider a polymorphic sorting function:\nsort [\u03b1] : (\u03b1 \u2192 \u03b1 \u2192 Bool ) \u2192 List \u03b1 \u2192 List \u03b1\nwith 3 parameters: the type of the elements in the list (\u03b1); the\ncomparison operator; and the list to be compared. Instantiating\nall 3 parameters explicitly at every use of sort would be quite\ntedious. It is likely that, for a given type, the sorting function is\ncalled with the same, explicitly passed, comparison function over\nand over again. Moreover it is easy to infer the type parameter \u03b1.\nGP greatly simplifies such calls by making the type argument and\nthe comparison operator implicit.\nisort : \u2200\u03b1.(\u03b1 \u2192 \u03b1 \u2192 Bool ) \u21d2 List \u03b1 \u2192 List \u03b1\nThe function isort declares that the comparison function is implicit\nby using \u21d2 instead of \u2192. It is used as:\nimplicit {cmpInt : Int \u2192 Int \u2192 Bool } in\n(isort [2, 1, 3], isort [5, 9, 3])\nThe two calls of isort each take only one explicit argument: the list\nto be sorted. Both the concrete type of the elements (Int) and the\ncomparison operator (cmpInt) are implicitly instantiated.\nThe element type is automatically inferred from the type of\nthe list. More interestingly, the implicit comparison operator is\nautomatically determined in a process called resolution. Resolution\nis a type-directed process that uses a set of rules, the implicit\nenvironment, to find a value that matches the type required by\nthe function call. The implicit construct extends the implicit\nenvironment with new rules. In other words, implicit is a scoping\nconstruct for rules similar to a conventional let-binding. Thus, in\nthe subexpression (isort [2, 1, 3], isort [5, 9, 3]), cmpInt is in the\nlocal scope and available for resolution.\n1.1 Existing Approaches to Generic Programming\nThe two main strongholds of GP are the C++ and the functional\nprogramming (FP) communities. Many of the pillars of GP are\nbased on the ideas promoted by Musser and Stepanov [23]. These\nideas were used in C++ libraries such as the Standard Template\nLibrary [24] and Boost [1]. In the FP community, Haskell type\nclasses [42] have proven to be an excellent mechanism for GP,\nalthough their original design did not have that purpose. As years\npassed the FP community created its own forms of GP [14, 10, 21].\nGarcia et al.'s [9] comparative study of programming language\nsupport for GP was an important milestone for both communi-\n\n\fties. According to that study many languages provide some support for GP. However, Haskell did particularly well, largely due to\ntype classes. A direct consequence of that work was to bring the\ntwo main lines of work on GP closer together and promote crosspollination of ideas. Haskell adopted associated types [4, 3], which\nwas the only weak point found in the original comparison. For the\nC++ community, type classes presented an inspiration for developing language support for concepts [23, 11, 34].\nSeveral researchers started working on various approaches to\nconcepts (see Siek's work [33] for a historical overview). Some researchers focused on integrating concepts into C++ [7, 11], while\nothers focused on developing new languages with GP in mind.\nThe work on System F G [34, 35] is an example of the latter approach: Building on the experience from the C++ generic programming community and some of the ideas of type classes, Siek and\nLumsdaine developed a simple core calculus based on System F\nwhich integrates concepts and improves on type classes in several\nrespects. In particular, System F G supports scoping of rules1 .\nDuring the same period Scala emerged as new contender in the\narea of generic programming. Much like Haskell, Scala was not\noriginally developed with generic programming in mind. However\nScala included an alternative to type classes: implicits. Implicits\nwere initially viewed as a poor man's type classes [26]. Yet, ultimately, they proved to be quite flexible and in some ways superior\nto type classes. In fact Scala turns out to have very good support\nfor generic programming [28, 29].\nA distinguishing feature of Scala implicits, and a reason for\ntheir power, is that resolution works for any type. This allows Scala\nto simply reuse standard OO interfaces/classes (which are regular\ntypes) to model concepts, and avoids introducing another type of\ninterface in the language. In contrast, with type classes, or the\nvarious concept proposals, resolution is tightly coupled with the\ntype class or concept-like interfaces.\n1.2 Limitations of Existing Mechanisms\nTwenty years of programming experience with type classes gave\nthe FP community insights about the limitations of type classes.\nSome of these limitations were addressed by concept proposals.\nOther limitations were solved by implicits. However, as far as we\nknow, no existing language or language proposal overcomes all\nlimitations. We discuss these limitations next.\nGlobal scoping: In Haskell, rules2 are global and there can be\nonly a single rule for any given type [18, 2, 6, 8]. Locally scoped\nrules are not available. Several researchers have already proposed to\nfix this issue: with named rules [18] or locally scoped ones [2, 6, 8].\nHowever none of those proposals have been adopted.\nBoth proposals for concepts and Scala implicits offer scoping of\nrules and as such do not suffer from this limitation.\nSecond class interfaces: Haskell type classes are second-class\nconstructs compared to regular types: in Haskell, it is not possible\nto abstract over a type class [13]. Yet, the need for first-class\ntype classes is real in practice. For example, L\u00e4mmel and Peyton\nJones [21] desire the following type class for their GP approach:\nclass (Typeable \u03b1, cxt \u03b1) \u21d2 Data cxt \u03b1 where\ngmapQ :: (\u2200\u03b2.Data cxt \u03b2 \u21d2 \u03b2 \u2192 r ) \u2192 \u03b1 \u2192 [r ]\nIn this type class, the intention is that the ctx variable abstracts\nover a concrete type class. Unfortunately, Haskell does not support\ntype class abstraction. Proposals for concepts inherit this limitation\nfrom type classes. Concepts and type classes are usually interpreted\nas predicates on types rather than types, and cannot be abstracted\n1 In\n\nthe context of C++ rules correspond to models or concept maps.\n2 In the context of Haskell rules correspond to type-class instances.\n\nover as regular types. In contrast, because in Scala concepts are\nmodeled with types, it is possible to abstract over concepts. Oliveira\nand Gibbons [28] show how to encode this example in Scala.\nNo higher-order rules: Finally type classes do not support\nhigher-order rules. As noted by Hinze and Peyton Jones [12], nonregular Haskell datatypes like:\ndata Perfect f \u03b1 = Nil | Cons \u03b1 (Perfect f (f \u03b1))\nrequire type class instances such as:\ninstance (\u2200\u03b2.Show \u03b2 \u21d2 Show (f \u03b2), Show \u03b1) \u21d2\nShow (Perfect f \u03b1)\nwhich Haskell does not support, as it restricts instances (or rules) to\nbe first-order. This rule is higher-order because it assumes another\nrule, \u2200\u03b2.Show \u03b2 \u21d2 Show (f \u03b2), that contains an assumption\nitself. Also note that this assumed rule is polymorphic in \u03b2.\nBoth concept proposals and Scala implicits inherit the limitation\nof first-order rules.\n1.3 Contributions\nThis paper presents \u03bb\u21d2 , a minimal and general core calculus for\nimplicits and it shows how to build a source language supporting\nimplicit instantiation on top of it. Perhaps surprisingly the core\ncalculus itself does not provide implicit instantiation: instantiation of generic arguments is explicit. Instead \u03bb\u21d2 provides two key\nmechanisms for generic programming: 1) a type-directed resolution\nmechanism and 2) scoping constructs for rules. Implicit instantiation is then built as a convenience mechanism on top of \u03bb\u21d2 by combining type-directed resolution with conventional type-inference.\nWe illustrate this on a simple, but quite expressive source language.\nThe calculus is inspired by Scala implicits and it synthesizes\ncore ideas of that mechanism formally. In particular, like Scala\nimplicits, a key idea is that resolution and implicit instantiation\nwork for any type. This allows those mechanisms to be more widely\nuseful and applicable, since they can be used with other types in\nthe language. The calculus is also closely related to System F G ,\nand like System F G , rules available in the implicit environment\nare lexically scoped and scopes can be nested.\nA novelty of our calculus is its support for partial resolution and\nhigher-order rules. Although Hinze and Peyton Jones [12] have discussed higher-order rules informally and several other researchers\nnoted their usefulness [40, 30, 28], no existing language or calculus\nprovides support for them. Higher-order rules are just the analogue\nof higher-order functions in the implicits world. They arise naturally once we take the view that resolution should work for any\ntype. Partial resolution adds additional expressive power and it is\nespecially useful in the presence of higher-order rules.\nFrom the GP perspective \u03bb\u21d2 offers a new foundation for\ngeneric programming. The relation between the implicit calculus\nand Scala implicits is comparable to the relation between System\nF G and various concept proposals; or the relation between formal\ncalculi of type classes and Haskell type classes: The implicit calculus is a minimal and general model of implicits useful for language\ndesigners wishing to study and inform implementations of similar\nGP mechanisms in their own languages.\nIn summary, our contributions are as follows.\n\u2022 Our implicit calculus \u03bb\u21d2 provides a simple, expressive and\n\ngeneral formal model for implicits. Despite its expressiveness,\nthe calculus is minimal and provides an ideal setting for the\nformal study of implicits and GP.\n\u2022 Of particular interest is our resolution mechanism, which is\n\nsignificantly more expressive than existing mechanisms in the\nliterature. It is based on a simple (logic-programming style)\n\n\fquery language, works for any type, and it supports partial\nresolution as well as higher-order rules.\n\u2022 The calculus has a polymorphic type system and an elaboration\n\nsemantics to System F. This also provides an effective implementation of our calculus. The elaboration semantics is proved\nto be type-preserving, ensuring the soundness of the calculus.\n\u2022 We present a small, but realistic source language, built on top\n\nof \u03bb\u21d2 via a type-directed encoding. This language features\nimplicit instantiation and a simple type of interface, which\ncan be used to model simple forms of concepts. This source\nlanguage also supports higher-order rules.\n\u2022 Finally, both \u03bb\u21d2 and the source language have been imple-\n\nmented and the source code for their implementation is available at http://ropas.snu.ac.kr/~ bruno/implicit.\nOrganization Section 2 presents an informal overview of our calculus. Section 3 shows a polymorphic type system that statically\nexcludes ill-behaved programs. Section 4 shows the elaboration\nsemantics of our calculus into System F and correctness results.\nSection 5 presents the source language and its encoding into \u03bb\u21d2 .\nSection 6 discusses comparisons and related work. Section 7 concludes.\n\n2. Overview of the Implicit Calculus \u03bb\u21d2\nOur calculus \u03bb\u21d2 combines standard scoping mechanisms (abstractions and applications) and types \u00e0 la System F, with a logicprogramming-style query language. At the heart of the language\nis a threefold interpretation of types:\n\u223c propositions =\n\u223c rules\ntypes =\nFirstly, types have their traditional meaning of classifying terms.\nSecondly, via the Curry-Howard isomorphism, types can also be\ninterpreted as propositions \u2013 in the context of GP, the type proposition denotes the availability in the implicit environment of a value\nof the corresponding type. Thirdly, a type is interpreted as a logicprogramming style rule, i.e., a Prolog rule or Horn clause [19]. Resolution [20] connects rules and propositions: it is the means to show\n(the evidence) that a proposition is entailed by a set of rules.\nNext we present the key features of \u03bb\u21d2 and how these features\nare used for GP. For readability purposes we sometimes omit redundant type annotations and slightly simplify the syntax.\nFetching values by types: A central construct in \u03bb\u21d2 is a query.\nQueries allow values to be fetched by type, not by name. For\nexample, in the following function call\nfoo ?Int\nthe query ?Int looks up a value of type Int in the implicit environment, to serve as an actual argument.\nConstructing values with type-directed rules: \u03bb\u21d2 constructs\nvalues, using programmer-defined, type-directed rules (similar to\nfunctions). A rule (or rule abstraction) defines how to compute,\nfrom implicit arguments, a value of a particular type. For example,\nhere is a rule that computes an Int \u00d7 Bool pair from implicit Int\nand Bool values:\n(|(?Int + 1, \u00ac ?Bool ) : {Int , Bool } \u21d2 Int \u00d7Bool|)\nThe rule abstraction syntax resembles a type-annotated expression:\nthe expression (?Int +1, \u00ac ?Bool ) to the left of the colon is the rule\nbody, and to the right is the rule type {Int , Bool } \u21d2 Int \u00d7Bool.\nA rule abstraction abstracts over a set of implicit values (here\n{Int , Bool }), or, more generally, over rules to build values.\nHence, when a value of type Int \u00d7 Bool is needed (expressed\nby the query ?(Int \u00d7Bool)), the above rule can be used, provided\n\nthat an integer and a boolean value are available in the implicit\nenvironment. In such an environment, the rule returns a pair of the\nincremented Int value and negated Bool value.\nThe implicit environment is extended through rule application\n(analogous to extending the environment with function applications). Rule application is expressed as, for example:\n(|(?Int + 1, \u00ac ?Bool ) : {Int , Bool } \u21d2 Int \u00d7Bool |)\nwith {1, True }\nWith syntactic sugar similar to a let-expression, a rule abstractionapplication combination is denoted more compactly as:\nimplicit {1, True } in (?Int + 1, \u00ac ?Bool )\nwhich returns (2, False).\nHigher-order rules: \u03bb\u21d2 supports higher-order rules. For example, the rule\n(|?(Int \u00d7Int) : {Int , {Int } \u21d2 Int \u00d7Int } \u21d2 Int \u00d7Int|),\nwhen applied, will compute an integer pair given an integer and\na rule to compute an integer pair from an integer. Hence, the\nfollowing rule application returns (3, 4):\nimplicit {3, (|(?Int , ?Int + 1) : {Int } \u21d2 Int \u00d7Int|)} in\n?(Int \u00d7Int)\nRecursive resolution: Note that resolving the query ?(Int \u00d7Int)\ninvolves applying multiple rules. The current environment does not\ncontain the required integer pair. It does however contain the integer\n3 and a rule (|(?Int , ?Int + 1) : {Int } \u21d2 Int \u00d7Int|) to compute\na pair from an integer. Hence, the query is resolved with (3, 4), the\nresult of applying the pair-producing rule to 3.\nPolymorphic rules and queries:\nFor example, the rule\n\n\u03bb\u21d2 allows polymorphic rules.\n\n(|(?\u03b1, ?\u03b1) : \u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1|)\ncan be instantiated to multiple rules of monomorphic types\n{Int } \u21d2 Int \u00d7Int, {Bool } \u21d2 Bool \u00d7Bool, . . .\nMultiple monomorphic queries can be resolved by the same rule.\nThe following expression returns ((3, 3), (True, True)):\nimplicit {3, True, (|(?\u03b1, ?\u03b1) : \u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1|)} in\n(?(Int \u00d7Int), ?(Bool \u00d7Bool))\nPolymorphic rules can also be used to resolve polymorphic queries:\nimplicit {(|(?\u03b1, ?\u03b1) : \u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1|)} in\n?(\u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1)\nCombining higher-order and polymorphic rules: The rule\n(|(?((Int \u00d7Int)\u00d7(Int \u00d7Int ))) : {Int , \u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1} \u21d2\n(Int \u00d7Int)\u00d7(Int \u00d7Int)|)\nprescribes how to build a pair of integer pairs, inductively from an\ninteger value, by consecutively applying the rule of type\n\u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1\ntwice: first to an integer, and again to the result (an integer pair).\nFor example, the following expression returns ((3, 3), (3, 3)):\nimplicit {3, (|(?\u03b1, ?\u03b1) : \u2200\u03b1.{\u03b1} \u21d2 \u03b1\u00d7\u03b1|)} in\n?((Int \u00d7Int)\u00d7(Int \u00d7Int))\n\n\fLocally and lexically scoped rules: Rules can be nested and resolution respects the lexical scope of rules. Consider the following\nprogram:\nimplicit {1} in\nimplicit {True, (| if ?Bool then 2 : {Bool } \u21d2 Int |)}\nin ?Int\nThe query ?Int is not resolved with the integer value 1. Instead the\nrule that returns an integer from a boolean is applied to the boolean\nTrue, because those two rules can provide an integer value and\nthey are nearer to the query. So, the program returns 2 and not 1.\nOverlapping rules: Two rules overlap if their return types intersect, i.e., when they can both be used to resolve the same query.\nOverlapping rules are allowed in \u03bb\u21d2 through nested scoping. The\nnearest matching rule takes priority over other matching rules. For\nexample consider the following program:\nimplicit {\u03bbx .x : \u2200\u03b1.\u03b1 \u2192 \u03b1} in\nimplicit {\u03bbn.n + 1 : Int \u2192 Int } in\n?(Int \u2192 Int ) 1\nIn this case \u03bbn.n + 1 : Int \u2192 Int is the lexically nearest match in\nthe implicit environment and evaluating this program results in 2.\nHowever, if we have the following program instead:\nimplicit {\u03bbn.n + 1 : Int \u2192 Int } in\nimplicit {\u03bbx .x : \u2200\u03b1.\u03b1 \u2192 \u03b1} in\n?(Int \u2192 Int ) 1\nThen the lexically nearest match is \u03bbx .x :\u2200\u03b1.\u03b1 \u2192 \u03b1 and evaluating\nthis program results in 1.\n\n3. The \u03bb\u21d2 Calculus\nThis section formalizes the syntax and type system of \u03bb\u21d2 .\n3.1 Syntax\nThis is the syntax of the calculus:\n(Simple) Types\nRule Types\nExpressions\n\n\u03c4\n\u03c1\ne\n\n::=\n::=\n::=\n|\n\n\u03b1 | Int | \u03c41 \u2192 \u03c42 | \u03c1\n\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\nn | x | \u03bbx : \u03c4.e | e1 e2\n?\u03c1 | (|e : \u03c1|) | e[~\u03c4 ] | e with e : \u03c1\n\nTypes \u03c4 are either type variables \u03b1, the integer type Int , function\ntypes \u03c41 \u2192 \u03c42 or rule types \u03c1. A rule type \u03c1 = \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\nis a type scheme with universally quantified variables \u03b1\n~ and an\n(implicit) context \u03c1\u0304. This context summarizes the assumed implicit\nenvironment. Note that we use ~o to denote an ordered sequence\no1 , . . . , on of entities and \u014d to denote a set {o1 , . . . , on }. Such\nordered sequences and sets can be empty, and we often omit empty\nuniversal quantifiers and empty contexts from a rule type. The base\ncase of rule types is when \u03c1\u0304 is the empty set (\u2200~\n\u03b1.{} \u21d2 \u03c4 ).\nExpressions include integer constants n and the three basic\ntyped \u03bb-calculus expressions (variables, lambda binders and applications). A query ?\u03c1 queries the implicit environment for a value of\ntype \u03c1. A rule abstraction (|e : \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 |) builds a rule whose\ntype is \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 and whose body is e.\nWithout loss of generality we assume that all variables x and\ntype variables \u03b1 in binders are distinct. If not, they can be easily\nrenamed apart to be so.\nNote that, unlike System F, our calculus does not have a separate\n\u039b binder for type variables. Instead rule abstractions play a dual\nrole in the binding structure: 1) the universal quantification of type\nvariables (which binds types), and 2) the context (which binds a\nrule set). This design choice is due to our interpretation of rules\n\nas logic programming rules3 . After all, in the matching process of\nresolution, a rule is applied as a unit. Hence, separating rules into\nmore primitive binders (\u00e0 la System F's type and value binders)\nwould only complicate the definition of resolution unnecessarily.\nHowever, elimination can be modularized into two constructs: type\napplication e[\u03c4\u0304 ] and rule application e with e : \u03c1.\nUsing rule abstractions and applications we can build the\nimplicit sugar that we have used in Sections 1 and 2.\ndef\n\nimplicit e : \u03c1 in e1 : \u03c4 = (|e1 : \u03c1 \u21d2 \u03c4 |) with e : \u03c1\nFor readability purposes, when we use implicit we omit the\ntype annotation \u03c4 . As we shall see in Section 5 this annotation can\nbe automatically inferred.\nFor brevity and simplicity reasons, we have kept \u03bb\u21d2 small. In\nexamples we may use additional syntax such as built-in integer\noperators and boolean literals and types.\n3.2 Type System\nFigure 1 presents the static type system of \u03bb\u21d2 . The typing judgment \u0393 | \u2206 \u22a2 e : \u03c4 means that expression e has type \u03c4 under type\nenvironment \u0393 and implicit environment \u2206. The auxiliary resolution judgment \u2206 \u22a2r \u03c1 expresses that type \u03c1 is resolvable with\nrespect to \u2206. Here, \u0393 is the conventional type environment that\ncaptures type variables; \u2206 is the implicit environment, defined as\na stack of contexts. Figure 1 also presents lookup in the implicit\nenvironment (\u2206h\u03c4 i) and in contexts (\u03c1\u0304h\u03c4 i).\nWe will not discuss the first four rules ((TyInt), (TyVar),\n(TyAbs) and (TyApp)) because they are entirely standard. For now\nwe also ignore the gray-shaded conditions in the other rules; they\nare explained in Section 3.3.\nRule (TyRule) checks a rule abstraction (|e : \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 |) by\nchecking whether the rule's body e actually has the type \u03c4 under the\nassumed implicit type context \u03c1\u0304. Rule (TyInst) instantiates a rule\ntype's type variables \u03b1\n~ with the given types ~\u03c4 , and rule (TyRApp)\ninstantiates the type context \u03c1\u0304 with expressions of the required rule\ntypes e : \u03c1. Finally, rule (TyQuery) delegates queries directly to the\nresolution rule (TyRes).\nResolution Principle The underlying principle of resolution in\n\u03bb\u21d2 originates from resolution in logic. Following the CurryHoward correspondence, we assign to each type a corresponding\nlogical interpretation with the (*)\u2020 function:\nDefinition 3.1 (Logical Interpretation).\n\u03b1\u2020\nInt \u2020\n(\u03c41 \u2192 \u03c42 )\u2020\n\n=\n=\n=\n\n(\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 )\u2020\n\n=\n\n\u03b1\u2020\nInt \u2020\n\u03c41\u2020 \u2192\u2020 \u03c42\u2020\n^ \u2020\n\u03c1 \u21d2 \u03c4\u2020\n\u2200~\n\u03b1\u2020 .\n\u03c1\u2208\u03c1\u0304\n\nHere, type variables \u03b1 map to propositional variables \u03b1\u2020 and the\nprimitive type Int maps to the propositional constant Int \u2020 . Unlike\nCurry-Howard, we do not map function types to logical implications; we deliberately restrict our implicational reasoning to rule\ntypes. So, instead we also map the function arrow to an uninterpreted higher-order predicate \u2192\u2020 . Finally, as already indicated, we\nmap rule types to logical implications.\nResolution in \u03bb\u21d2 then corresponds to checking entailment of\nthe logical interpretation. We postulate this property as a theorem\nthat constrains the design of resolution.\nTheorem 3.1 (Resolution Specification).\nIf \u2206 \u22a2r \u03c1, then \u2206\u2020 |= \u03c1\u2020 .\n3 In\n\nProlog these are not separated either.\n\n\f\u0393\n\u2206\n\nType Environments\nImplicit Environments\n\n::=\n::=\n\n* | \u0393; x : \u03c4\n* | \u2206; \u03c1\u0304\n\n\u0393|\u2206\u22a2e:\u03c4\n(TyInt)\n\n\u0393 | \u2206 \u22a2 n : Int\n\n(TyVar)\n\n(x : \u03c4 ) \u2208 \u0393\n\u0393|\u2206\u22a2x:\u03c4\n\n(TyAbs)\n\n\u0393; x : \u03c41 | \u2206 \u22a2 e : \u03c42\n\u0393 | \u2206 \u22a2 \u03bbx : \u03c41 .e : \u03c41 \u2192 \u03c42\n\n(TyApp)\n\n\u0393 | \u2206 \u22a2 e1 : \u03c42 \u2192 \u03c41\n\u0393 | \u2206 \u22a2 e2 : \u03c42\n\u0393 | \u2206 \u22a2 e1 e2 : \u03c41\n\u03c1 = \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\n\n(TyRule)\n\nInt ; \u2200\u03b1.{\u03b1} \u21d2 \u03b1 \u00d7 \u03b1 \u22a2r Int \u00d7 Int\n\nunambiguous(\u03c1)\n\n\u0393 | \u2206; \u03c1\u0304 \u22a2 e : \u03c4 \u03b1\n~ \u2229 ftv (\u0393, \u2206) = \u2205\n\u0393 | \u2206 \u22a2 (|e : \u03c1|) : \u03c1\n\n(TyInst)\n\n\u0393 | \u2206 \u22a2 e : \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\n\u0393 | \u2206 \u22a2 e[~\n\u03c4 ] : [~\n\u03b1 7\u2192 ~\n\u03c4 ](\u03c1\u0304 \u21d2 \u03c4 )\n\n(TyRApp)\n\n\u0393 | \u2206 \u22a2 e : \u03c1\u0304 \u21d2 \u03c4\n\u0393 | \u2206 \u22a2 ei : \u03c1i (\u2200ei : \u03c1i \u2208 e : \u03c1)\n\u0393 | \u2206 \u22a2 (e with e : \u03c1) : \u03c4\n\n(TyQuery)\n\n\u2206 \u22a2r \u03c1\n\nunambiguous(\u03c1)\n\n\u0393 | \u2206 \u22a2?\u03c1 : \u03c1\n\n\u2206 \u22a2r \u03c1\n(TyRes)\n\n\u2206h\u03c4 i = \u03c1\n\nResolution for Rule Types So far, so good. Apart from allowing\nany types, recursive querying for simple types is quite similar\nto recursive type class resolution, and \u03bb\u21d2 carefully captures the\nexpected behavior. However, what is distinctly novel in \u03bb\u21d2 , is that\nit also provides resolution of rule types, which requires a markedly\ndifferent treatment.\n\u2206h\u03c4 i = \u03c1\u0304 \u21d2 \u03c4\n(RuleRes)\n\u2206 \u22a2r \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\nHere we retrieve a whole rule from the environment, including its\ncontext. Resolution again performs a lookup based on a matching\nright-hand side \u03c4 , but subsequently also matches the context with\nthe one that is queried. No recursive resolution takes place.\nExample Consider a variant of the above query:\n\n\u03c1\u0304h\u03c4 i = \u03c1\n\nAgain lookup yields the second rule, instantiated to {Int} \u21d2\nInt \u00d7 Int. The context {Int } of this rule matches the context of\nthe queried rule. Hence, the query is resolved without recursive\nresolution.\n\nno overlap(\u03c1\u0304, \u03c4 )\n\n(\u2206; \u03c1\u0304)h\u03c4 i = \u03c1\n\n\u03c1 \u2208 \u03c1\u0304\n\n\u03c1 = \u2200~\n\u03b1\u2032 .\u03c1\u0304\u2032 \u21d2 \u03c4 \u2032\n\u03c1\u0304h\u03c4 i = \u03b8 \u03c1\u0304\u2032 \u21d2 \u03c4\n\n\u03b8\u03c4 \u2032 = \u03c4\n\nFigure 1. Type System\n\nResolution for Simple Types The step from the logical interpretation to the (TyRes) rule in Figure 1 is non-trivial. So, let us first\nlook at a simpler incarnation. What does resolution look like for\nsimple types \u03c4 like Int ?\n(SimpleRes)\n\nLookup yields the second rule, which produces a tuple, instantiated\nto {Int} \u21d2 Int \u00d7 Int with matching substitution \u03b8 = [\u03b1 7\u2192 Int].\nIn order to produce a tuple, the rule requires a value of the component type. Hence, resolution proceeds by recursively querying for\nInt. Now lookup yields the first rule, which produces an integer,\nwith empty matching substitution and no further requirements.\n\nInt; \u2200\u03b1.{\u03b1} \u21d2 \u03b1 \u00d7 \u03b1 \u22a2r {Int} \u21d2 Int \u00d7 Int\n\u2206h\u03c4 i = \u03c1\u0304\u2032 \u21d2 \u03c4\n\u2206 \u22a2r \u03c1i (\u2200\u03c1i \u2208 \u03c1\u0304\u2032 \u2212 \u03c1\u0304)\n\u2206 \u22a2r \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\n\n\u03c1\u0304h\u03c4 i = \u22a5 \u2206h\u03c4 i = \u03c1\n(\u2206; \u03c1\u0304)h\u03c4 i = \u03c1\n\n\u03c1\u0304h\u03c4 i = \u03c1\n\nbe instantiated to the queried \u03c4 using a matching unifier \u03b8. This rule\ntype is then returned in instantiated form.\nThe matching expresses that the looked-up rule produces a value\nof the required type. To do so, the looked-up rule may itself require\nother implicit values. This requirement is captured in the context\n\u03c1\u0304\u2032 , which must be resolved recursively. Hence, the resolution rule\nis itself a recursive rule. When the context \u03c1\u0304\u2032 of the looked-up rule\nis empty, a base case of the recursion has been reached.\nExample Consider this query for a tuple of integers:\n\n\u2206h\u03c4 i = \u03c1\u0304\u2032 \u21d2 \u03c4\n\u2206 \u22a2r \u03c1i (\u2200\u03c1i \u2208 \u03c1\u0304\u2032 )\n\u2206 \u22a2r \u03c4\n\nFirst, it looks up a matching rule type in the implicit environment by\nmeans of the lookup function \u2206h\u03c4 i defined in Fig. 1. This partial\nfunction respects the nested scopes: it first looks in the topmost\ncontext of the implicit environment, and, only if it does not find a\nmatching rule, does it descend. Within an environment context, the\nlookup function looks for a rule type whose right-hand side \u03c4 \u2032 can\n\nUnified Resolution The feat that our actual resolution rule (TyRes)\naccomplishes is to unify these seemingly disparate forms of resolution into one single inference rule. In fact, both (SimpleRes) and\n(RuleRes) are special cases of (TyRes), which provides some additional expressiveness in the form of partial resolution (explained\nbelow).\nThe first hurdle for (TyRes) is that types \u03c4 and rule types \u03c1 are\ndifferent syntactic categories. Judging from its definition, (TyRes)\nonly covers rule types. How do we get it to treat simple types\nthen? Just promote the simple type \u03c4 to its corresponding rule\ntype \u2200.{} \u21d2 \u03c4 and (TyRes) will do what we expect for simple\ntypes, including recursive resolution. At the same time, it still\nmatches proper rule types exactly, without recursion, when that is\nappropriate.\nChoosing the right treatment for the context is the second hurdle. This part is managed by recursively resolving \u03c1\u0304\u2032 \u2212 \u03c1\u0304. In the\ncase of promoted simple types, \u03c1\u0304 is empty, and the whole of \u03c1\u0304\u2032 is\nrecursively solved; which is exactly what we want. In the case \u03c1\u0304\u2032\nmatches \u03c1\u0304, no recursive resolution takes place. Again this perfectly\ncorresponds to what we have set out above for proper rule types.\nHowever, there is a third case, where \u03c1\u0304\u2032 \u2212 \u03c1\u0304 is a non-empty proper\nsubset of \u03c1\u0304\u2032 . We call this situation, where part of the retrieved rule's\ncontext is recursively resolved and part is not, partial resolution.\nExample Here is another query variant:\nBool; \u2200\u03b1.{Bool , \u03b1} \u21d2 \u03b1 \u00d7 \u03b1 \u22a2r {Int} \u21d2 Int \u00d7 Int\nThe first lookup yields the second rule, instantiated to {Bool , Int} \u21d2\nInt \u00d7 Int, which almost matches the queried rule type. Only Bool\n\n\fin the context is unwelcome, so it is eliminated through a recursive resolution step. Fortunately, the first rule in the environment is\navailable for that.\n\nIf there is a quantified type variable not in type \u03c4 , the type may\nyield ambiguous instantiations (e.g. \u2200\u03b1.{\u03b1} \u21d2 Int).\n\nSemantic Resolution Within the confines of the semantic constraint of Theorem 3.1 the rule (TyRes) implements a rather syntactic notion of resolution. In contrast, a fully semantic definition\nof resolution would coincide exactly with the semantic constraint\nand satisfy\n\n4. Type-Directed Translation to System F\n\n\u2206 \u22a2r \u03c1 iff \u2206\u2020 |= \u03c1\u2020\nFor instance, it would allow to resolve\nChar ; Char \u21d2 Int; Bool \u21d2 Int \u22a2r Int\nIn this example, resolution gets stuck using the topmost rule in the\nenvironment. However, by using the next one down, the query can\nbe resolved. The problem with supporting this semantic notion of\nresolution is that it requires backtracking. Because backtracking\neasily becomes a performance problem and because it is mentally\nhard to reason about for the programmer, we have decided against\nit.\nWe have considered another definition of resolution, that avoids\nbacktracking but is closer to the semantic notion:\n\u2206h\u03c4 i = \u03c1\u0304\u2032 \u21d2 \u03c4\n\u2206, \u03c1\u0304 \u22a2r \u03c1i (\u2200\u03c1i \u2208 \u03c1\u0304\u2032 )\n\u2206 \u22a2r \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\n\nHowever, we prefer our more syntactic definition of resolution,\nrule (TyRes), because it is much simpler: the environment does\nnot grow recursively, but stays the same throughout the whole\nrecursive resolution. We believe that this way it is more manageable\nfor the programmer to perform resolution mentally. Moreover, the\ninvariant environment in rule (TyRes) is much easier for deciding\ntermination.\n3.3 Additional Type System Conditions\nThe gray-shaded conditions in the type system are to check lookup\nerrors (no overlap) and ambiguous instantiations (unambiguous).\nTo prevent lookup failures, we have to\n\n\u2022 A lookup has no matching rule in the environment.\n\u2022 A lookup has multiple matching rules which have different rule\n\ntypes but can yield values of the same type (overlapping rules).\nThe former condition is directly captured in the definition of lookup\namong a set of rule types. The latter condition is captured in the\nno overlap property, which is defined as:\ndef\n\n\u2227\n\u2227\n\nFigure 2 presents the translation rules that convert \u03bb\u21d2 expressions\ninto ones of System F extended with the integer and unit types. This\nfigure essentially extends Figure 1 with the necessary information\nfor the translation, but for readability we have omitted the earlier\ngray-shaded conditions.\nThe syntax of System F is as follows:\nTypes\nExpressions\n\nT\nE\n\n::=\n::=\n\n\u03b1 | T \u2192 T | \u2200\u03b1.T | Int | ()\nx | \u03bb(x : T ).E | E E | \u039b\u03b1.E | E T | n | ()\n\n\u0393 | \u2206 \u22a2 e : \u03c4 ; E,\n\nChar ; Char \u21d2 Int; Bool \u21d2 Int \u22a2r Char \u21d2 Int\n\nno overlap({\u03c11 , . . . , \u03c1n }, \u03c4 ) =\n\u2200i, j.\n\u03c1i = \u2200\u03b1~i .\u03c1\u0304i \u21d2 \u03c4i\n\u2227\n\u03c1j = \u2200\u03b1~j .\u03c1\u0304j \u21d2 \u03c4j\n=\u21d2 i = j\n\n4.1 Type-Directed Translation\n\nThe main translation judgment is\n\nThis rule extends the environment \u2206 with the queried rule type's\ncontext \u03c1\u0304 for recursive resolution of the matching rule type's context \u03c1\u0304\u2032 . It resolves the following query that rule (TyRes) does not:\n\nAvoiding Lookup Errors\ncheck for two situations:\n\nIn this section we define the dynamic semantics of \u03bb\u21d2 in terms of\nSystem F's dynamic semantics, by means of a type directed translation. This translation turns implicit contexts into explicit parameters and statically resolves all queries, much like Wadler and Blott's\ndictionary passing translation for type classes [42]. The advantage\nof this approach is that we simultaneously provide a meaning to\nwell-typed \u03bb\u21d2 programs and an effective implementation that resolves all queries statically.\n\n\u2203\u03b8i .\u03b8i \u03c4i = \u03c4\n\u2203\u03b8j .\u03b8j \u03c4j = \u03c4\n\nwhich states that the translation of \u03bb\u21d2 expression e with type \u03c4\nis System F expression E, with respect to type environment \u0393 and\ntranslation environment \u2206. The translation environment \u2206 relates\neach rule type in the earlier implicit environment to a System F\nvariable x; this variable serves as value-level explicit evidence for\nthe implicit rule. Lookup in the translation environment is defined\nsimilarly to lookup in the type environment, except that the lookup\nnow returns a pair of a rule type and an evidence variable.\nFigure 2 also defines the type translation function | * | from \u03bb\u21d2\ntypes \u03c4 to System F types T. In order to obtain a unique translation\nof types, we assume that the types in a context are lexicographically\nordered.\nVariables, lambda abstractions and applications are translated\nstraightforwardly. Queries are translated by rule (TrQuery) using\nthe auxiliary resolution judgment \u22a2r , defined by rule (TrRes). Note\nthat rule (TrRes) performs the same process that rule (TyRes)\nperforms in the type system except that it additionally collects\nevidence variables.\nRule (TrRule) translates rule abstractions to explicit type and\nvalue abstractions in System F, and rule (TrInst) translates instantiation to type application. Finally, rule (TrRApp) translates rule\napplication to application in System F.\nExample We have that:\n* | * \u22a2 (|(?\u03b1, ?\u03b1) : \u2200\u03b1.{\u03b1} \u21d2 \u03b1 \u00d7 \u03b1|)\n; \u039b\u03b1.\u03bb(x : \u03b1).(x, x)\nand also:\n(Int : x1 ), (\u2200\u03b1.{\u03b1} \u21d2 \u03b1 \u00d7 \u03b1 : x2 ) \u22a2r Int \u00d7 Int\n; x2 Int x1\n\nAvoiding Ambiguous Instantiations We avoid ambiguous instantiations in the same way as Haskell does: all quantified type variables (~\n\u03b1) in a rule type (\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 ) must occur in \u03c4 . We use the\nunambiguous condition to check in (TyRule) and (TyQuery):\n\nFor brevity, Figure 2 omits the case where the context of a rule type\nis empty. To properly handle empty contexts, the translation of rule\ntype should include |{} \u21d2 \u03c4 | = () \u2192 |\u03c4 | and the translation\nrules (TrRule), (TrRApp) and (TrRes) should be extended in the\nobvious way.\n\nunambiguous(\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 ) = \u03b1\n~ \u2286 ftv (\u03c4 )\n\u2227 \u2200\u03c1i \u2208 \u03c1\u0304.unambiguous(\u03c1i ).\n\nTheorem 4.1 (Type-preserving translation). Let e be a \u03bb\u21d2 expression, \u03c4 be a type and E be a System F expression. If * | * \u22a2 e : \u03c4 ;\nE, then * \u22a2 E : |\u03c4 |.\n\n\finterface Eq \u03b1 = {eq : \u03b1 \u2192 \u03b1 \u2192 Bool }\nType Environments\nTranslation Environments\n\n\u0393\n\u2206\n\n::=\n::=\n\nlet (\u2261) : \u2200\u03b1. {Eq \u03b1} \u21d2 \u03b1 \u2192 \u03b1 \u2192 Bool = eq ? in\nlet eqInt1 : Eq Int = Eq {eq = primEqInt } in\nlet eqInt2 : Eq Int = Eq {eq = \u03bbx y.isEven x \u2227 isEven y } in\nlet eqBool : Eq Bool = Eq {eq = primEqBool } in\nlet eqPair : \u2200\u03b1 \u03b2. {Eq \u03b1, Eq \u03b2 } \u21d2 Eq (\u03b1, \u03b2) =\nEq {eq = \u03bbx y.fst x \u2261 fst y \u2227 snd x \u2261 snd y } in\nlet p1 : (Int , Bool ) = (4, True) in\nlet p2 : (Int , Bool ) = (8, True) in\nimplicit {eqInt1 , eqBool , eqPair } in\n\n* | \u0393; x : \u03c4\n* | \u2206; \u03c1 : x\n\n\u0393|\u2206\u22a2e:\u03c4 ;E\n(TrInt)\n\n\u0393 | \u2206 \u22a2 n : Int ; n\n\n(TrVar)\n\n(x : \u03c4 ) \u2208 \u0393\n\u0393|\u2206\u22a2x:\u03c4 ;x\n\n(TrAbs)\n\n\u0393; x : \u03c41 | \u2206 \u22a2 e : \u03c42 ; E\n\u0393 | \u2206 \u22a2 \u03bbx : \u03c41 .e : \u03c41 \u2192 \u03c42 ; \u03bbx : |\u03c41 |.E\n\nFigure 3. Encoding the Equality Type Class\n\n(TrApp)\n\n\u0393 | \u2206 \u22a2 e1 : \u03c42 \u2192 \u03c41 ; E1\n\u0393 | \u2206 \u22a2 e2 : \u03c42 ; E2\n\u0393 | \u2206 \u22a2 e1 e2 : \u03c41 ; E1 E2\n\nProof. (Sketch) We first prove4 the more general lemma \"if \u0393 |\n\u2206 \u22a2 e : \u03c4 ; E, then |\u0393|, |\u2206| \u22a2 E : |\u03c4 |\" by induction on the\nderivation of translation. Then, the theorem is trivially proved by\nit.\n\n(TrQuery)\n\n\u2206 \u22a2r \u03c1 ; E\n\u0393 | \u2206 \u22a2?\u03c1 : \u03c1 ; E\n\n(TrRule)\n\n\u03c1 = \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 \u03b1\n~ \u2229 ftv (\u0393, \u2206) = \u2205\n\u0393 | \u2206; \u03c1 : x \u22a2 e : \u03c4 ; E\nx\u0304 fresh\n\u0393 | \u2206 \u22a2 (|e : \u03c1|) : \u03c1 ; \u039b~\n\u03b1.\u03bb(~\nx : |~\n\u03c1|).E\n\n(p1 \u2261 p2 , implicit {eqInt2 } in p1 \u2261 p2 )\n\n4.2 Dynamic Semantics\nFinally, we define the dynamic semantics of \u03bb\u21d2 as the composition\nof the type-directed translation and System F's dynamic semantics.\nFollowing Siek's notation [34], this dynamic semantics is:\neval (e) = V\n\nwhere * | * \u22a2 e : \u03c4 ; E and E \u2192\u2217 V\n\n(TrInst)\n\n\u0393 | \u2206 \u22a2 e : \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 ; E\n\u0393 | \u2206 \u22a2 e[~\n\u03c4 ] : [~\n\u03b1 7\u2192 ~\n\u03c4 ](\u03c1\u0304 \u21d2 \u03c4 ) ; E |~\n\u03c4|\n\nwith \u2192\u2217 the reflexive, transitive closure of System F's standard\nsingle-step call-by-value reduction relation.\nNow we can state the conventional type safety theorem for \u03bb\u21d2 :\n\n(TrRApp)\n\n\u0393 | \u2206 \u22a2 e : \u03c1\u0304 \u21d2 \u03c4 ; E\n\u0393 | \u2206 \u22a2 ei : \u03c1i ; Ei (\u2200ei : \u03c1i \u2208 e : \u03c1)\n~\n\u0393 | \u2206 \u22a2 (e with e : \u03c1) : \u03c4 ; E E\n\nTheorem 4.2 (Type Safety). If * | * \u22a2 e : \u03c4 , then eval (e) = V for\nsome System F value V .\n\n\u2206 \u22a2r \u03c1 ; E\n\n5. Source Languages and Implicit Instantiation\n\u2206(\u03c4 ) (\n= \u03c1\u0304\u2032 \u21d2 \u03c4 : E\nx\u0304 fresh\n\u2206\n\u22a2\n\u03c1\n;\nE\n, \u03c1i 6\u2208 \u03c1\u0304\nr\ni\ni\n\u2200\u03c1i \u2208 \u03c1\u0304\u2032 :\nEi = xi\n, \u03c1i \u2208 \u03c1\u0304\n~\n\u2206 \u22a2r \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 ; \u039b~\n\u03b1.\u03bb(~\nx : |~\n\u03c1|).(E E)\n\n(TrRes)\n\nThe proof follows trivially from Theorem 4.1.\n\n\u2206h\u03c4 i = \u03c1 : E\n\n\u03c1 : xh\u03c4 i = \u03c1 : E\n(\u2206; \u03c1 : x)h\u03c4 i = \u03c1 : E\n\u03c1 : xh\u03c4 i = \u22a5 \u2206h\u03c4 i = \u03c1\n(\u2206; \u03c1 : x)h\u03c4 i = \u03c1\n\n\u03c1 : xh\u03c4 i = \u03c1 : E\n\n(\u03c1 : x) \u2208 \u03c1 : x\n\u03c1 = \u2200~\n\u03b1\u2032 .\u03c1\u0304\u2032 \u21d2 \u03c4 \u2032\n\u03b8\u03c4 \u2032 = \u03c4\n\u03b8 = [~\n\u03b1\u2032 7\u2192 ~\n\u03c4]\n\u03c1 : xh\u03c4 i = \u03b8 \u03c1\u0304\u2032 \u21d2 \u03c4 : x |~\n\u03c4|\n\n|\u03b1|\n|Int|\n\n=\n=\n\n\u03b1\nInt\n\n|\u03c41 \u2192 \u03c42 |\n\n=\n\n|\u03c41 | \u2192 |\u03c42 |\n\n|\u2200~\n\u03b1.{\u03c11 , * * * , \u03c1n } \u21d2 \u03c4 |\n|\u0393|\n\n=\n=\n\n\u2200~\n\u03b1.|\u03c11 | \u2192 * * * \u2192 |\u03c1n | \u2192 |\u03c4 |\n{(x : |\u03c4 |) | (x : \u03c4 ) \u2208 \u0393}\n\n|\u2206|\n\n=\n\n{(x : |\u03c1|) | (\u03c1 : x) \u2208 \u2206}\n\nFigure 2. Type-directed Translation to System F\n\nLanguages like Haskell and Scala provide a lot more programmer\nconvenience than \u03bb\u21d2 (which is a low level core language) because\nof higher-level GP constructs, interfaces and implicit instantiation.\nThis section illustrates how to build a simple source language on\ntop of \u03bb\u21d2 to add the expected convenience. We should note that\nunlike Haskell this language supports local and nested scoping, and\nunlike both Haskell and Scala it supports higher-order rules. We\npresent the type-directed translation from the source to \u03bb\u21d2 .\n5.1 Type-directed Translation to \u03bb\u21d2\nThe full syntax is presented in Figure 4. Its use is illustrated in\nthe program of Figure 3, which comprises an encoding of Haskell's\nequality type class Eq. The example shows that the source language\nfeatures a simple type of interface I T~ (basically records), which\nare used to encode simple forms of type classes. Note that we\nfollow Haskell's conventions for records: field names u are unique\nand they are modeled as regular functions taking a record as the\nfirst argument. So a field u with type T in an interface declaration\nI \u03b1\n~ actually has type \u2200\u1fb1.{} \u21d2 I \u03b1\n~ \u2192 T . There are also other\nconventional programming constructs (such as let expressions,\nlambdas and primitive types).\nUnlike the core language, we strongly differentiate between\nsimple types T and type schemes \u03c3 in order to facilitate type inference. Moreover, as the source language provides implicit rather\nthan explicit type instantiation, the order of type variables in a\nquantifier is no longer relevant. Hence, they are represented by a set\n4 in\n\nthe extra material of the submission\n\n\fTypes\nT ::=\n|\n|\n|\n\u03c3 ::=\n\n\u03b1\nInt\nI T~\nT \u2192T\n\u2200\u03b1. \u03c3 \u21d2 T\n\n::=\n\nG\n\nType Environments\n\nInterface Declarations\ninterface I \u03b1\n~ = u:T\n\n* | G, u : \u03c3 | G, x : T\n\nG\u22a2E:T ;e\nType Variables\nInteger Type\nInterface Type\nFunction\nRule Type\n\nExpressions\nE ::= n\n| x\n| \u03bbx.E\n| E1 E2\n| u\n| let u : \u03c3 = E1 in E2\n| implicit u in E2\n| ?\n| Iu=E\n\nInteger Literal\nLambda Variable\nAbstraction\nApplication\nLet Variable\nLet\nImplicit Scoping\nImplicit Lookup\nInterface Implementation\n\n(TyIntL)\n\nG \u22a2 n : Int ; n\n\n(TyVar)\n\nG(x) = T\nG\u22a2x:T ;x\n\n(TyAbs)\n\nG, x : T1 \u22a2 E ; e\nG \u22a2 \u03bbx.E : T1 \u2192 T2 ; \u03bbx : JT1 K.e\n\n(TyApp)\n\nG \u22a2 E1 : T1 \u2192 T2 ; e1\nG \u22a2 E2 : T1 ; e2\nG \u22a2 E1 E2 : T2 ; e1 e2\n\n(TyLVar)\n\nG(u) = \u2200\u03b1. \u03c3 \u21d2 T \u2032\n\u03b8 = [\u03b1 7\u2192 T ] T = \u03b8T \u2032\nqi = (?J\u03b8\u03c3i K) : J\u03b8\u03c3i K (\u2200\u03c3i \u2208 \u03c3)\nG \u22a2 u : T ; u[JT~ K] with q\n\n(TyLet)\n\n\u03c3 = \u2200\u03b1.\u03c3 \u21d2 T1\nG \u22a2 E1 : T1 ; e1\nG, u : \u03c3 \u22a2 E2 : T2 ; e2\nG \u22a2 let u : \u03c3 = E1 in E2 : T2 ;\n(\u03bbu : J\u03c3K.e2 ) (|e1 : J\u03c3K|)\n\n(TyImp)\n\nG\u22a2E:T ;e\nG(ui ) = \u03c3i qi = ui : J\u03c3i K (\u2200ui \u2208 u)\nG \u22a2 implicit u in E : T ;\n(|e : J\u03c3K \u21d2 JT K|) with q\n\n(TyIVar)\n\nG \u22a2? : T ; ?({} \u21d2 JT K) with {}\n\nFigure 4. Syntax of Source Language\n\n(\u2200\u1fb1). We also distinguish simply typed variables x from let-bound\nvariables u with polymorphic type \u03c3.\nFigure 5 presents the type-directed translation G \u22a2 E : T ; e\nof source language expressions E of type T to core expressions e,\nwith respect to type environment G. The type environment collects\nboth simply and polymorphic variable typings. The connection\nbetween source types T and \u03c3 on the one hand and core types \u03c4\nand \u03c1 on the other hand is captured in the auxiliary function J*K.\nNote that this function imposes a canonical ordering \u03b1\n~ on the set of\nquantifier variables \u1fb1 (based on their precedence in the left-to-right\nprefix traversal of the quantified type term). For the translation of\nrecords, we assume that \u03bb\u21d2 is extended likewise with records.\nlet and let-bound variables The rule (TyLet) in Figure 5 shows\nthe type-directed translation for let expressions. This translation\nbinds the variable u using a regular lambda abstraction in an expression e2 , which is the result of the translation of the body of the\nlet construct (E2 ). Then it applies that abstraction to a rule whose\nrule type is just the corresponding (translated) type of the definition\n(\u03c31 ), and whose body is the translation of the expression E1 .\nThe source language provides convenience to the user by inferring type arguments and implicit values automatically. This inference happens in rule (TyLVar), i.e., the use of let-bound variables.\nThat rule recovers the type scheme of variable u from the environment G. Then it instantiates the type scheme and fires the necessary\nqueries to resolve the context.\nQueries The source language also includes a query operator (?).\nUnlike \u03bb\u21d2 this query operator does not explicitly state the type;\nthat information is provided implicitly through type inference. For\nexample, instead of using p1 \u2261 p2 in Figure 5, we could have\ndirectly used the field eq as follows:\neq ? p1 p2\nWhen used in this way, the query acts like a Coq placeholder ( ),\nwhich similarly instructs Coq to automatically infer a value.\nThe translation of source language queries, given by the rule\n(TyIVar), is fairly straightforward. To simplify type-inference, the\nquery is limited to types, and does not support partial resolution (although other designs with more powerful queries are possible). In\nthe translated code the query is combined with a rule instantiation\nand application in order to eliminate the empty rule set.\n\n(TyRec)\n\n\u2200i :\n\n(\n\nG(ui ) = \u2200\u1fb1.{} \u21d2 I \u03b1\n~ \u2192 Ti\nG \u22a2 Ei : \u03b8Ti ; e \u03b8 = [~\n\u03b1 7\u2192 T~ ]\n~\nG\u22a2Iu=E:IT ;Iu=e\n\nJ\u03b1K\nJInt K\nJT1 \u2192 T2 K\nJI T~ K\nJ\u2200\u03b1.\u03c3 \u21d2 T K\n\n=\n=\n=\n=\n=\n\n\u03b1\nInt\nJT1 K \u2192 JT2 K\nI JT~ K\n\u2200J~\n\u03b1K.J\u03c3K \u21d2 JT K\n\nFigure 5. Type-directed Encoding of Source Language in \u03bb\u21d2\nImplicit scoping The implicit construct, which has been already informally introduced in Section 1, is the core scoping construct of the source language. It is used in our example to first introduce definitions in the implicit environment (eqInt1 , eqBool and\neqPair ) available at the expression\n(p1 \u2261 p2 , implicit {eqInt2 } in p1 \u2261 p2 )\nWithin this expression there is a second occurrence of implicit,\nwhich introduces an overlapping rule (eqInt2 ) that takes priority\nover eqInt1 for the subexpression p1 \u2261 p2 .\nThe translation rule (TyImp) of implicit into \u03bb\u21d2 also exploits\ntype-information to avoid redundant type annotations. For example,\nit is not necessary to annotate the let-bound variables used in\nthe rule set u because that information can be recovered from the\nenvironment G.\nHigher-order rules and implicit instantiation for any type The\nfollowing example illustrates higher-order rules and implicit instantiation working for any type in the source language.\n\n\flet show : \u2200\u03b1. {\u03b1 \u2192 String } \u21d2 \u03b1 \u2192 String = ? in\nlet showInt : Int \u2192 String = . . . in\nlet comma : \u2200\u03b1. {\u03b1 \u2192 String } \u21d2 [\u03b1] \u2192 String = . . . in\nlet space : \u2200\u03b1. {\u03b1 \u2192 String } \u21d2 [\u03b1] \u2192 String = . . . in\nlet o : {Int \u2192 String, {Int \u2192 String } \u21d2 [Int ] \u2192 String }\n\u21d2 String = show [1, 2, 3] in\nimplicit showInt in\n(implicit comma in o, implicit space in o)\nFor brevity, we have omitted the implementations of showInt ,\ncomma and space; but showInt renders an Int as a String\nin the conventional way, while comma and space provide two\nways for rendering lists. Evaluation of the expression yields\n(\"1,2,3\", \"1 2 3\"). Thanks to the implicit rule parameters, the\ncontexts of the two calls to o control how the lists are rendered.\nThis example differs from that in Figure 3 in that instead of\nusing a nominal interface type like Eq, it uses standard functions\nto model a simple concept for pretty printing values. The use of\nfunctions as implicit values leads to a programming style akin to\nstructural matching of concepts, since only the type of the function\nmatters for resolution.\n5.2 Extensions\nThe goal of our work is to present a minimal and general framework\nfor implicits. As such we have avoided making assumptions about\nextensions that would be useful for some languages, but not others.\nIn this section we briefly discuss some extensions that would be\nuseful in the context of particular languages and the implications\nthat they would have in our framework.\nFull-blown Concepts The most noticeable feature that was not\ndiscussed is a full-blown notion of concepts. One reason not to\ncommit to a particular notion of concepts is that there is no general\nagreement on what the right notion of concepts is. For example,\nfollowing Haskell type classes, the C++0x concept proposal [11]\nis based on a nominal approach with explicit concept refinement,\nwhile Stroustrup favors a structural approach with implicit concept\nrefinement because that would be more familiar to C++ programmers [37]. Moreover, various other proposals for GP mechanisms\nhave their own notion of interface: Scala uses standard OO hierarchies; Dreyer et al. use ML-modules [8]; and in dependently typed\nsystems (dependent) record types are used [36, 5].\nAn advantage of \u03bb\u21d2 is that no particular notion of interface is\nimposed on source language designers. Instead, language designers are free to use the one they prefer. In our source language, for\nsimplicity, we opted to add a very simple (and limited) type of interface. But existing language designs [29, 8, 36, 5] offer evidence\nthat more sophisticated types of interfaces, including some form of\nrefinement or associated types, can be built on top of \u03bb\u21d2 .\nType Constructor Polymorphism and Higher-order Rules Type\nconstructor polymorphism is an advanced, but highly powerful GP\nfeature available in Haskell and Scala, among others. It allows\nabstracting container types like List and Tree with a type variable\nf ; and applying the abstracted container type to different element\ntypes, e.g., f Int and f Bool .\nThis type constructor polymorhism leads to a need for higherorder rules: rules for containers of elements that depend on rules for\nthe elements. The instance for showing values of type Perfect f \u03b1\nin Section 1, is a typical example of this need.\nExtending \u03bb\u21d2 with type constructor polymorphism is not hard.\nBasically, we need to add a kind system and move from a System F\nlike language to System F\u03c9 like language.\nSubtyping Languages like Scala or C++ have subtyping. Subtyping would require significant adaptations to \u03bb\u21d2 . Essentially, instead of targetting System F, we would have to target a version of\n\nSystem F with subtyping. In addition, the notion of matching in the\nlookup function \u2206h\u03c4 i would have to be adjusted, as well as the\nno overlap condition. While subtyping is a useful feature, some\nlanguage designs do not support it because it makes the system\nmore complex and interferes with type-inference.\nType-inference Languages without subtyping (like Haskell or\nML) make it easier to support better type-inference. Since we\ndo not use subtyping, it is possible to improve support for typeinference in our source language. In particular, we currently require\na type annotation for let expressions, but it should be possible to\nmake that annotation optional, by building on existing work for the\nGHC Haskell compiler [32, 41].\n\n6. Related Work\nThroughout the paper we have already discussed a lot of related\nwork. In what follows, we offer a more detailed technical comparison of \u03bb\u21d2 versus System F G and Scala implicits, which are the\nclosest to our work. Then we discuss the relation with other work\nin the literature.\nSystem F G Generally speaking our calculus is more primitive\nand general than System F G . In contrast to \u03bb\u21d2 , System F G has\nboth a notion of concepts and implicit instantiation of concepts5 .\nThis has the advantage that language designers can just reuse that\ninfrastructure, instead of having to implement it. The language\nG [35] is based on System F G and it makes good use of these\nbuilt-in mechanisms. However, System F G also imposes important design choices. Firstly it forces the language designer to use\nthe notion of concepts that is built-in to System F G . In contrast \u03bb\u21d2\noffers a freedom of choice (see also the discussion in Section 5.2).\nSecondly, fixing implicit instantiation in the core prevents useful alternatives. For example, Scala and several other systems do provide\nimplicit instantiation by default, but also offer the option of explicit\ninstantiation, which is useful to resolve ambiguities [29, 18, 6, 8].\nThis cannot be modeled on top of System F G , because explicit\ninstantiation is not available. In contrast, by taking explicit instantiation (rule application) as a core feature, \u03bb\u21d2 can serve as a target\nfor languages that offer both styles of instantiation.\nThere are also important differences in terms of scoping and\nresolution of rules. System F G only formalizes a very simple\ntype of resolution, which does not support recursive resolution.\nFurthermore, scoping is less fine-grained than in \u03bb\u21d2 . For example,\nSystem F G requires a built-in construct for model expressions,\nbut in \u03bb\u21d2 implicit (which plays a similar role) is just syntactic\nsugar on top of more primitive constructs.\nScala Implicits Scala implicits are integrated in a full-blown language, but they have only been informally described in the literature [29, 27]. Our calculus aims at providing a formal model of\nimplicits, but there are some noteworthy differences between \u03bb\u21d2\nand Scala implicits. In contrast to \u03bb\u21d2 , Scala has subtyping. As discussed in Section 5.2 subtyping would require some adaptations to\nour calculus. In Scala, nested scoping can only happen through subclassing and the rules for resolution in the presence of overlapping\ninstances are quite ad-hoc. Furthermore, Scala has no (first-class)\nrule abstractions. Rather, implicit arguments can only be used in\ndefinitions. In contrast \u03bb\u21d2 provides a more general and disciplined\naccount of scoping for rules.\nType Classes Obviously, the original work on type classes [42]\nand the framework of qualified types [15] around it has greatly\ninfluenced our own work, as well as that of System FG and Scala.\n5 Note\n\nthat instantiation of type variables is still explicit.\n\n\fThere is a lot of work on Haskell type classes in the literature.\nNotably, there have been some proposals for addressing the limitations that arise from global scoping [18, 6]. However in those designs, type classes are still second-class and resolution only works\nfor type classes. The GHC Haskell compiler supports overlapping\ninstances [17], that live in the same global scope. This allows some\nrelief for the lack of local scoping. A lot of recent work on type\nclasses is focused on increasingly more powerful \"type class\" interfaces. Functional dependencies [16], associated types [4, 3] and\ntype families [31] are all examples of this trend. This line of work\nis orthogonal to our work.\nOther Languages and Systems Modular type classes [8] are a\nlanguage design that uses ML-modules to model type classes. The\nmain novelty of this design is that, in addition to explicit instantiation of modules, implicit instantiation is also supported. In contrast\nto \u03bb\u21d2 , implicit instantiation is limited to modules and, although\nlocal scoping is allowed, it cannot be nested.\nInstance arguments [5] are an Agda extension that is closely related to implicits. However, unlike most GP mechanisms, implicit\nrules are not declared explicitly. Furthermore resolution is limited\nin its expressive power, to avoid introducing a different computational model in Agda. This design differs significantly from \u03bb\u21d2 ,\nwhere resolution is very expressive and the scoping mechanisms\nallow explicit rule declarations.\nImplicit parameters [22] are a Haskell extension that allows\nnamed arguments to be passed implicitly. Implicit parameters are\nresolved by name, not by type and there is no recursive resolution.\nGP and Logic Programming The connection between Haskell\ntype classes and Prolog is folklore. Neubauer et. al. [25] also\nexplore the connection with Functional Logic Programming and\nconsider different evaluation strategies to deal with overlapping\nrules. With Constraint Handling Rules, Stuckey and Sulzmann [38]\nuse Constraint Logic Programming to implement type classes.\n\n7. Conclusion\nOur main contribution is the development of the implicit calculus\n\u03bb\u21d2 . This calculus isolates and formalizes the key ideas of Scala\nimplicits and provides a simple model for language designers interested in developing similar mechanisms for their own languages.\nIn addition, \u03bb\u21d2 supports higher-order rules and partial resolution,\nwhich add considerable expressiveness to the calculus.\nImplicits provide an interesting alternative to conventional GP\nmechanisms like type classes or concepts. By decoupling resolution\nfrom a particular type of interfaces, implicits make resolution more\npowerful and general. Furthermore, this decoupling has other benefits too. For example, by modeling concept interfaces as conventional types, those interfaces can be abstracted as any other types,\navoiding the issue of second class interfaces that arise with type\nclasses or concepts.\nUltimately, all the expressiveness offered by \u03bb\u21d2 offers a widerange of possibilities for new generic programming applications.\nAcknowledgements We are grateful to Ben Delaware, Derek\nDreyer, Jeremy Gibbons, Scott Kilpatrick, Phil Wadler, Beta Ziliani, the member of ROPAS and the anonymous reviewers for their\ncomments and suggestions. This work was partially supported by\nthe Engineering Research Center of Excellence Program of Korea Ministry of Education, Science and Technology (MEST) /\nKorea Science and Engineering Foundation (KOSEF) grant R112008-007-01002-0 and the Mid-career Researcher Program (20100022061) through NRF grant funded by the MEST. This work\nwas also partially supported by Singapore Ministry of Education\nresearch grant MOE2010-T2-2-073.\n\nReferences\n[1] The Boost C++ libraries. http://www.boost.org/, 2010.\n[2] C. Camar\u00e3o and L. Figueiredo. Type inference for overloading\nwithout restrictions, declarations or annotations. In FLOPS, 1999.\n[3] M. Chakravarty, G. Keller, and S. L. Peyton Jones. Associated type\nsynonyms. In ICFP, 2005.\n[4] M. Chakravarty, G. Keller, S. L. Peyton Jones, and S. Marlow.\nAssociated types with class. In POPL, 2005.\n[5] D. Devriese and F. Piessens. On the bright side of type classes:\nInstance arguments in agda. In ICFP, 2011.\n[6] A. Dijkstra and S. D. Swierstra. Making implicit parameters explicit.\nTechnical report, Utrecht University, 2005.\n[7] G. Dos Reis and B. Stroustrup. Specifying C++ concepts. In POPL\n'06, pages 295\u2013308, 2006.\n[8] D. Dreyer, R. Harper, M. Chakravarty, and G. Keller. Modular type\nclasses. In POPL, 2007.\n[9] R. Garcia, J. Jarvi, A. Lumsdaine, Jeremy Siek, and J. Willcock. A\ncomparative study of language support for generic programming. In\nOOPSLA, 2003.\n[10] J. Gibbons. Patterns in datatype-generic programming. In The Fun of\nProgramming, Cornerstones in Computing. Palgrave, 2003.\n[11] D. Gregor, J. J\u00e4rvi, J. G. Siek, B. Stroustrup, G. Dos Reis, and\nA. Lumsdaine. Concepts: linguistic support for generic programming\nin c++. In OOPSLA, 2006.\n[12] R. Hinze and S. L. Peyton Jones. Derivable type classes. Electronic\nNotes in Theoretical Computer Science, 41(1):5 \u2013 35, 2001.\n[13] J. Hughes. Restricted data types in Haskell. In Haskell, 1999.\n[14] P. Jansson and J. Jeuring. Polytypic programming. In AFP. SpringerVerlag, 1996.\n[15] M. P. Jones. Simplifying and improving qualified types. In FPCA,\n1995.\n[16] M. P. Jones. Type classes with functional dependencies. In ESOP,\n2000.\n[17] S. L. Peyton Jones, M. P. Jones, and E. Meijer. Type classes: exploring\nthe design space. In Haskell Workshop, 1997.\n[18] W. Kahl and J. Scheffczyk. Named instances for Haskell type classes.\nIn Haskell Workshop, 2001.\n[19] R. Kowalski. Predicate logic as a programming language. In\nProceedings of IFIP Congress, 1974.\n[20] R. Kowalski, Donald, and Kuehner. Linear resolution with selection\nfunction. Artificial Intelligence, 2, 1971.\n[21] R. L\u00e4mmel and S. L. Peyton Jones. Scrap your boilerplate with class:\nextensible generic functions. In ICFP, 2005.\n[22] J. Lewis, J. Launchbury, E. Meijer, and M. Shields. Implicit\nparameters: dynamic scoping with static types. In POPL, 2000.\n[23] D. Musser and A. Stepanov. Generic programming. In Symbolic and\nalgebraic computation: ISSAC 88, pages 13\u201325. Springer, 1988.\n[24] D. R. Musser and A. Saini. The STL Tutorial and Reference Guide:\nC++ Programming with the Standard Template Library. Addison\nWesley Longman Publishing Co., Inc., 1995.\n[25] M. Neubauer, P. Thiemann, M. Gasbichler, and M. Sperber.\nFunctional logic overloading. In POPL, 2002.\n\n[26] M. Odersky. Poor man's type classes. http://lamp.epfl.ch/~ odersky/talks/wg2\nJuly 2006.\n[27] M. Odersky. The Scala language specification, version 2.8, 2010.\n[28] B. C. d. S. Oliveira and J. Gibbons. Scala for generic programmers.\nJournal of Functional Programming, 20, 2010.\n[29] B. C. d. S. Oliveira, A. Moors, and M. Odersky. Type classes as\nobjects and implicits. In OOPSLA, 2010.\n\n\f[30] A. Rodriguez, J. Jeuring, P. Jansson, A. Gerdes, O. Kiselyov, and\nB. C. d. S. Oliveira. Comparing libraries for generic programming in\nhaskell. In Haskell, 2008.\n[31] T. Schrijvers, S. L. Peyton Jones, M. Chakravarty, and M. Sulzmann.\nType checking with open type functions. In ICFP, 2008.\n[32] T. Schrijvers, S. L. Peyton Jones, M. Sulzmann, and D. Vytiniotis.\nComplete and decidable type inference for GADTs. In ICFP, 2009.\n\nA. Termination of Resolution\nIf we are not careful about which rules are made implicit, the recursive resolution process may not terminate. This section describes\nhow to impose a set of modular syntactic restrictions that prevents\nnon-termination.\nAs an example of non-termination consider\n{{Char } \u21d2 Int, {Int } \u21d2 Char } \u22a2r Int\n\n[33] J. Siek. The C++0x Concepts Effort. http://ecee.colorado.edu/~ siek/concepts_effort.pdf ,\n2011.\nwhich loops, using alternatively the first and second rule in the\nimplicit environment.\n[34] J. G. Siek and A. Lumsdaine. Essential language support for generic\nThe problem of non-termination has been widely studied in the\nprogramming. In PLDI, 2005.\n[35] J. G. Siek and A. Lumsdaine. A language for generic programming\nin the large. Science of Computer Programming, 76(5), 2011.\n[36] M. Sozeau and N. Oury. First-class type classes. In TPHOLs, 2008.\n[37] B. Stroustrup. Simplifying the use of concepts. Technical report,\nTechnical Report N2906, ISO/IEC JTC 1 SC22 WG21, 2009.\n[38] P. J. Stuckey and M. Sulzmann. A theory of overloading. In ICFP,\n2002.\n[39] M. Sulzmann, G. Duck, S. L. Peyton Jones, and P. J. Stuckey.\nUnderstanding functional dependencies via Constraint Handling\nRules. Journal of Functional Programming, 17, 2007.\n\ncontext of Haskell's type classes, and a set of modular syntactic\nrestrictions has been imposed on type class instances to avoid nontermination [39]. Adapting these restrictions to our setting, we\nobtain the following termination condition.\nDefinition A.1 (Termination Condition). An implicit environment\n\u2206 satisfies the condition, denoted term(\u2206), iff term(\u03c1) for every\n\u03c1 = (\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 ) \u2208 dom(\u2206), where:\nterm(\u03c1)\n\n[40] V. Trifonov. Simulating quantified class constraints. In Haskell, 2003.\n[41] D. Vytiniotis, S. L. Peyton Jones, T. Schrijvers, and M. Sulzmann.\nO UTSIDE I N(x): Modular type inference with local assumptions.\nJournal of Functional Programming, 21(4\u20135):333\u2013412, 2011.\n[42] P. L. Wadler and S. Blott. How to make ad-hoc polymorphism less ad\nhoc. In POPL, 1989.\n\ndef\n\n\u21d4\n\nocc \u03b1 (\u03c4 \u2032 ) 6 occ \u03b1 (\u03c4 )\n~\u2032 .\u03c1\u0304\u2032 \u21d2 \u03c4 \u2032 ) \u2208 \u03c1\u0304, \u2200\u03b1 \u2208 ftv (\u03c4, \u03c4i )) \\ \u03b1\n(\u2200(\u2200\u03b1\n~ \u2032)\n\n\u2227\n\u2227\n\n|\u03c4i | < |\u03c4 | (\u2200\u03c4i \u2208 \u03c1\u0304)\nterm(\u03c1\u2032 ) (\u2200\u03c1\u2032 \u2208 \u03c1\u0304)\n\nwhere\nocc \u03b1 (Int )\nocc \u03b1 (\u03b1)\nocc \u03b1 (\u03b1\u2032 )\nocc \u03b1 (\u03c41 \u2192 \u03c42 )\n\n=\n=\n=\n=\n\nocc \u03b1 (\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 )\n\n=\n\n|Int|\n|\u03b1|\n|\u03c41 \u2192 \u03c42 |\n\n=\n=\n=\n\n|\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 |\n\n=\n\n0\n1\n0\n(\u03b1 6= \u03b1\u2032 )\nocc \u03b1 (\u03c41 ) + occ \u03b1 (\u03c42 )\nX\nocc \u03b1 (\u03c1)\nocc \u03b1 (\u03c4 ) +\n\u03c1\u2208\u03c1\u0304\n\n1\n1\n1 + |\u03c41 | + |\u03c42 |\nX\n|\u03c1|.\n1 + |\u03c4 | +\n\u03c1\u2208\u03c1\u0304\n\nB. Proofs\nThroughout the proofs we refer to the type system rules of System\nF listed in Figure 6.\nLemma B.1. If\n\u0393|\u2206 \u22a2 e : \u03c4 ; E\nthen\n|\u0393|, |\u2206| \u22a2 E : |\u03c4 |\nProof. By structural induction on the expression and corresponding\ninference rule.\n(TrInt)\n\n\u0393|\u2206 \u22a2 n : Int ; n\n\nIt follows trivially from (F-Int) that\n|\u0393|, |\u2206| \u22a2 n : Int\n\n(TrVar)\n\n\u0393|\u2206 \u22a2 x : \u03c4 ; x\n\n\f(F-Int)\n\n\u0393 \u22a2 n : Int\n\n(F-Var)\n\n(x : T ) \u2208 \u0393\n\u0393\u22a2x:T\n\n(F-Abs)\n\n\u0393, x : T1 \u22a2 E : T2\n\u0393 \u22a2 \u03bbx : T1 .E : T1 \u2192 T2\n\n(F-App)\n\n\u0393 \u22a2 E 1 : T2 \u2192 T1\n\u0393 \u22a2 E 2 : T2\n\u0393 \u22a2 E 1 E 2 : T1\n\n(F-TApp)\n\n\u0393 \u22a2 E : \u2200\u03b1.T2\n\u0393 \u22a2 E T1 : [\u03b1 7\u2192 T1 ]T2\n\n(TrQuery)\n\n\u0393|\u2206 \u22a2?\u03c1 : \u03c1 ; E\n\nFrom (TrQuery) we have\n\u2206\u22a2\u03c1;E\nBased on Lemma B.2 we then know\n|\u2206| \u22a2 E : |\u03c1|\nHence, because all variables are unique\n\n(F-TAbs)\n\n\u0393 \u22a2 E : T \u03b1 6\u2208 ftv (\u0393)\n\u0393 \u22a2 \u039b\u03b1.E : \u2200\u03b1.T\n\nFigure 6. System F Type System\n\n|\u0393|, |\u2206| \u22a2 E : |\u03c1|\n\n(TrRule)\n\n\u0393|\u2206 \u22a2 (|e : \u03c1|) : \u03c1 ; \u039b~\n\u03b1.\u03bb(~x : |~\n\u03c1|).E\n\nBased on (TrRule) and the induction hypothesis, we have\n|\u0393|, |\u2206|, ~x : |~\n\u03c1| \u22a2 E : |\u03c4 |\nwhere\n\u03c1 = \u2200\u1fb1.\u03c1\u0304 \u21d2 \u03c4\nThus, based on (F-Abs) we have\n|\u0393|, |\u2206| \u22a2 \u03bb(~x : |~\n\u03c1|).E : |\u03c11 | \u2192 . . . \u2192 |\u03c1n | \u2192 |\u03c4 |\n\nIt follows from (TrVar) that\n(x : \u03c4 ) \u2208 \u0393\n\nor, using the definition of | * |\n|\u0393|, |\u2206| \u22a2 \u03bb(~x : |~\n\u03c1|).E : |\u03c1\u0304 \u21d2 \u03c4 |\nMoreover, because of (TrRule), we know\n\nBased on the definition of | * | it follows\n(x : |\u03c4 |) \u2208 |\u0393|\nThus we have by (F-Var) that\n|\u0393|, |\u2206| \u22a2 x : |\u03c4 |\n\n\u03b1\n~ \u2229 ftv (\u0393, \u2206) = \u2205\nand hence\n\u03b1\n~ \u2229 ftv (|\u0393|, |\u2206|) = \u2205\nSo, finally, we may conclude from (F-TAbs) that\n|\u0393|, |\u2206| \u22a2 \u039b~\n\u03b1.\u03bb(~x : |~\n\u03c1|).E : \u2200~\n\u03b1.|\u03c1\u0304 \u21d2 \u03c4 |\n\n(TrAbs)\n\n\u0393|\u2206 \u22a2 \u03bbx : \u03c41 .e : \u03c41 \u2192 \u03c42 ; \u03bbx : |\u03c41 |.E\n\nand again with | * |\n|\u0393|, |\u2206| \u22a2 \u039b~\n\u03b1.\u03bb(~x : |~\n\u03c1|).E : |\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 |\n\nIt follows from (TrAbs) that\n\u0393; x : \u03c41 |\u2206 \u22a2 e : \u03c42 ; E\nand by the indution hypothesis that\n|\u0393|, x : |\u03c41 |, |\u2206| \u22a2 E : |\u03c42 |\nAs all variables are renamed unique, it is easy to verify that this\nalso holds:\n\n(TrInst)\n\nBy (TrInst) and the induction hypothesis, it follows that\n|\u0393|, |\u2206| \u22a2 E : |\u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4 |\nFrom which we have by definition of | * |\n\n|\u0393|, |\u2206|, x : |\u03c41 | \u22a2 E : |\u03c42 |\nHence, by (F-Abs) we have\n\n\u0393|\u2206 \u22a2 e[~\u03c4 ] : [~\n\u03b1 7\u2192 ~\u03c4 ](\u03c1\u0304 \u21d2 \u03c4 ) ; E |~\u03c4 |\n\n|\u0393|, |\u2206| \u22a2 E : \u2200~\n\u03b1.|\u03c1\u0304 \u21d2 \u03c4 |\nIt follows from (F-TApp) that\n\n|\u0393|, |\u2206| \u22a2 \u03bbx : |\u03c41 |.E : |\u03c41 \u2192 \u03c42 |\n\n|\u0393|, |\u2206| \u22a2 E |~\u03c4 | : [~\n\u03b1 7\u2192 |~\u03c4 |]|\u03c1\u0304 \u21d2 \u03c4 |\nwhich is easily seen to be equal to\n\n(TrApp)\n\n|\u0393|, |\u2206| \u22a2 E |~\u03c4 | : |[~\n\u03b1 7\u2192 ~\u03c4 ](\u03c1\u0304 \u21d2 \u03c4 )|\n\n\u0393|\u2206 \u22a2 e1 e2 : \u03c41 ; E1 E2\n\nBy the induction hypothesis, we have:\n|\u0393|, |\u2206| \u22a2 E1 : |\u03c42 \u2192 \u03c41 |\nand\n\n(TrRApp)\n\n~\n\u0393|\u2206 \u22a2 e with e : \u03c1 : \u03c4 ; E E\n\nFrom (TrApp) and the induction hypothesis we have:\n|\u0393|, |\u2206| \u22a2 E2 : |\u03c42 |\n\nThen it follows by (F-App) that\n|\u0393|, |\u2206| \u22a2 E1 E2 : |\u03c41 |\n\n|\u0393|, |\u2206| \u22a2 E : |\u03c1\u0304 \u21d2 \u03c4 |\nand\n|\u0393|, |\u2206| \u22a2 Ei : |\u03c1i |(\u2200i)\n\n\fHence, base on the definition of | * | the first of these means\n|\u0393|, |\u2206| \u22a2 E : |\u03c11 | \u2192 . . . \u2192 |\u03c1n | \u2192 |\u03c4 |\nHence, based on (F-App) we know\n~ : |\u03c4 |\n|\u0393|, |\u2206| \u22a2 E E\n\nLemma B.2. If\n\u2206\u22a2\u03c1;E\nthen\n|\u2206| \u22a2 E : |\u03c1|\nProof. By induction on the derivation.\nFrom (TrRes) we have\n~\n\u2206 \u22a2 \u03c1 ; \u039b~\n\u03b1.\u03bb(~x : |~\n\u03c1|).(E E)\nwhere\n\u03c1 = \u2200~\n\u03b1.\u03c1\u0304 \u21d2 \u03c4\nAlso from (TrRes) and the induction hypothesis, we have\n|\u2206| \u22a2 Ei : |\u03c1i | (\u03c1i \u2208 \u03c1\u0304\u2032 \u2212 \u03c1\u0304)\nAlso from (TrRes) and Lemma B.3, we have\n|\u2206| \u22a2 E : |~\n\u03c1\u2032 \u21d2 \u03c4 |\nAssembling these parts using (F-App), (F-Abs) and (F-TAbs)\nwe come to\n~\n|\u2206| \u22a2 \u039b~\n\u03b1.\u03bb(~x : |~\n\u03c1|).(E E)\n\nLemma B.3. If\n\u2206h\u03c4 i = \u03c1\u0304 \u21d2 \u03c4 : E\nthen\n|\u2206| \u22a2 E : |\u03c1\u0304 \u21d2 \u03c4 |\nProof. This follows trivially from Lemma B.4.\nLemma B.4. If\n\u03c1 : xh\u03c4 i = \u03c1\u0304 \u21d2 \u03c4 : E\nthen\n|\u03c1 : x| \u22a2 E : |\u03c1\u0304 \u21d2 \u03c4 |\nProof. From the definintion of lookup we know that iff\n\u03c1 : xh\u03c4 i = \u03b8\u03c1\u0304\u2032 \u21d2 \u03c4 : x |~\u03c4 |\nthen\n(\u03c1 : x) \u2208 \u03c1 : x\nHence, it trivially follows that\n(x : |\u03c1|) \u2208 |\u03c1 : x|\nHence, from (F-Var) we have that\n|\u03c1 : x| \u22a2 x : |\u03c1|\nFollowing the definition of | * | we also know\n\u03b1.|\u03c1\u0304\u2032 \u21d2 \u03c4 \u2032 |\n|\u03c1 : x| \u22a2 x : \u2200~\nSo\n|\u03c1 : x| \u22a2 x |ts| : |\u03b8(\u03c1\u0304\u2032 \u21d2 \u03c4 \u2032 )|\n\n\f"}