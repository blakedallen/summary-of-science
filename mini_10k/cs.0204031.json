{"id": "http://arxiv.org/abs/cs/0204031v1", "guidislink": true, "updated": "2002-04-12T18:01:32Z", "updated_parsed": [2002, 4, 12, 18, 1, 32, 4, 102, 0], "published": "2002-04-12T18:01:32Z", "published_parsed": [2002, 4, 12, 18, 1, 32, 4, 102, 0], "title": "A Dynamic Approach to Characterizing Termination of General Logic\n  Programs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0007003%2Ccs%2F0007004%2Ccs%2F0007030%2Ccs%2F0007039%2Ccs%2F0007040%2Ccs%2F0007007%2Ccs%2F0007026%2Ccs%2F0007015%2Ccs%2F0007034%2Ccs%2F0007036%2Ccs%2F0007020%2Ccs%2F0007032%2Ccs%2F0007023%2Ccs%2F0007021%2Ccs%2F0007011%2Ccs%2F0007012%2Ccs%2F0007017%2Ccs%2F0007005%2Ccs%2F0007027%2Ccs%2F0007013%2Ccs%2F0007024%2Ccs%2F0007022%2Ccs%2F0007043%2Ccs%2F0007035%2Ccs%2F0007037%2Ccs%2F0007041%2Ccs%2F0007038%2Ccs%2F0007009%2Ccs%2F0007019%2Ccs%2F0007031%2Ccs%2F0007002%2Ccs%2F0007042%2Ccs%2F0007008%2Ccs%2F0007006%2Ccs%2F0007044%2Ccs%2F0007029%2Ccs%2F0007001%2Ccs%2F0007018%2Ccs%2F0007014%2Ccs%2F0007010%2Ccs%2F0007025%2Ccs%2F0204016%2Ccs%2F0204030%2Ccs%2F0204047%2Ccs%2F0204028%2Ccs%2F0204032%2Ccs%2F0204009%2Ccs%2F0204007%2Ccs%2F0204027%2Ccs%2F0204049%2Ccs%2F0204004%2Ccs%2F0204055%2Ccs%2F0204001%2Ccs%2F0204014%2Ccs%2F0204035%2Ccs%2F0204013%2Ccs%2F0204040%2Ccs%2F0204015%2Ccs%2F0204039%2Ccs%2F0204042%2Ccs%2F0204054%2Ccs%2F0204051%2Ccs%2F0204045%2Ccs%2F0204005%2Ccs%2F0204052%2Ccs%2F0204033%2Ccs%2F0204023%2Ccs%2F0204011%2Ccs%2F0204034%2Ccs%2F0204002%2Ccs%2F0204041%2Ccs%2F0204019%2Ccs%2F0204003%2Ccs%2F0204026%2Ccs%2F0204025%2Ccs%2F0204018%2Ccs%2F0204029%2Ccs%2F0204056%2Ccs%2F0204048%2Ccs%2F0204031%2Ccs%2F0204053%2Ccs%2F0204038%2Ccs%2F0204037%2Ccs%2F0204020%2Ccs%2F0204022%2Ccs%2F0204024%2Ccs%2F0204044%2Ccs%2F0204046%2Ccs%2F0204012%2Ccs%2F0204006%2Ccs%2F0204010%2Ccs%2F0204043%2Ccs%2F0204050%2Ccs%2F0204008%2Ccs%2F0204021%2Ccs%2F0204017%2Ccs%2F0204036%2Ccs%2F0605066%2Ccs%2F0605039%2Ccs%2F0605048%2Ccs%2F0605115&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Dynamic Approach to Characterizing Termination of General Logic\n  Programs"}, "summary": "We present a new characterization of termination of general logic programs.\nMost existing termination analysis approaches rely on some static information\nabout the structure of the source code of a logic program, such as modes/types,\nnorms/level mappings, models/interargument relations, and the like. We propose\na dynamic approach which employs some key dynamic features of an infinite\n(generalized) SLDNF-derivation, such as repetition of selected subgoals and\nrecursive increase in term size. We also introduce a new formulation of\nSLDNF-trees, called generalized SLDNF-trees. Generalized SLDNF-trees deal with\nnegative subgoals in the same way as Prolog and exist for any general logic\nprograms.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0007003%2Ccs%2F0007004%2Ccs%2F0007030%2Ccs%2F0007039%2Ccs%2F0007040%2Ccs%2F0007007%2Ccs%2F0007026%2Ccs%2F0007015%2Ccs%2F0007034%2Ccs%2F0007036%2Ccs%2F0007020%2Ccs%2F0007032%2Ccs%2F0007023%2Ccs%2F0007021%2Ccs%2F0007011%2Ccs%2F0007012%2Ccs%2F0007017%2Ccs%2F0007005%2Ccs%2F0007027%2Ccs%2F0007013%2Ccs%2F0007024%2Ccs%2F0007022%2Ccs%2F0007043%2Ccs%2F0007035%2Ccs%2F0007037%2Ccs%2F0007041%2Ccs%2F0007038%2Ccs%2F0007009%2Ccs%2F0007019%2Ccs%2F0007031%2Ccs%2F0007002%2Ccs%2F0007042%2Ccs%2F0007008%2Ccs%2F0007006%2Ccs%2F0007044%2Ccs%2F0007029%2Ccs%2F0007001%2Ccs%2F0007018%2Ccs%2F0007014%2Ccs%2F0007010%2Ccs%2F0007025%2Ccs%2F0204016%2Ccs%2F0204030%2Ccs%2F0204047%2Ccs%2F0204028%2Ccs%2F0204032%2Ccs%2F0204009%2Ccs%2F0204007%2Ccs%2F0204027%2Ccs%2F0204049%2Ccs%2F0204004%2Ccs%2F0204055%2Ccs%2F0204001%2Ccs%2F0204014%2Ccs%2F0204035%2Ccs%2F0204013%2Ccs%2F0204040%2Ccs%2F0204015%2Ccs%2F0204039%2Ccs%2F0204042%2Ccs%2F0204054%2Ccs%2F0204051%2Ccs%2F0204045%2Ccs%2F0204005%2Ccs%2F0204052%2Ccs%2F0204033%2Ccs%2F0204023%2Ccs%2F0204011%2Ccs%2F0204034%2Ccs%2F0204002%2Ccs%2F0204041%2Ccs%2F0204019%2Ccs%2F0204003%2Ccs%2F0204026%2Ccs%2F0204025%2Ccs%2F0204018%2Ccs%2F0204029%2Ccs%2F0204056%2Ccs%2F0204048%2Ccs%2F0204031%2Ccs%2F0204053%2Ccs%2F0204038%2Ccs%2F0204037%2Ccs%2F0204020%2Ccs%2F0204022%2Ccs%2F0204024%2Ccs%2F0204044%2Ccs%2F0204046%2Ccs%2F0204012%2Ccs%2F0204006%2Ccs%2F0204010%2Ccs%2F0204043%2Ccs%2F0204050%2Ccs%2F0204008%2Ccs%2F0204021%2Ccs%2F0204017%2Ccs%2F0204036%2Ccs%2F0605066%2Ccs%2F0605039%2Ccs%2F0605048%2Ccs%2F0605115&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a new characterization of termination of general logic programs.\nMost existing termination analysis approaches rely on some static information\nabout the structure of the source code of a logic program, such as modes/types,\nnorms/level mappings, models/interargument relations, and the like. We propose\na dynamic approach which employs some key dynamic features of an infinite\n(generalized) SLDNF-derivation, such as repetition of selected subgoals and\nrecursive increase in term size. We also introduce a new formulation of\nSLDNF-trees, called generalized SLDNF-trees. Generalized SLDNF-trees deal with\nnegative subgoals in the same way as Prolog and exist for any general logic\nprograms."}, "authors": ["Yi-Dong Shen", "Jia-Huai You", "Li-Yan Yuan", "Samuel S. P. Shen", "Qiang Yang"], "author_detail": {"name": "Qiang Yang"}, "author": "Qiang Yang", "arxiv_comment": "To appear in ACM TOCL", "links": [{"href": "http://arxiv.org/abs/cs/0204031v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0204031v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.1.6;D.1.2;F.4.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0204031v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0204031v1", "journal_reference": "ACM Transactions on Computational Logic 4(4):417-430, 2003", "doi": null, "fulltext": "arXiv:cs/0204031v1 [cs.LO] 12 Apr 2002\n\nA Dynamic Approach to Characterizing\nTermination of General Logic Programs\nYI-DONG SHEN\nChongqing University\nJIA-HUAI YOU, LI-YAN YUAN and SAMUEL S. P. SHEN\nUniversity of Alberta\nand\nQIANG YANG\nSimon Fraser University\n\nWe present a new characterization of termination of general logic programs. Most existing termination analysis approaches rely on some static information about the structure of the source\ncode of a logic program, such as modes/types, norms/level mappings, models/interargument relations, and the like. We propose a dynamic approach which employs some key dynamic features of\nan infinite (generalized) SLDNF-derivation, such as repetition of selected subgoals and recursive\nincrease in term size. We also introduce a new formulation of SLDNF-trees, called generalized\nSLDNF-trees. Generalized SLDNF-trees deal with negative subgoals in the same way as Prolog\nand exist for any general logic programs.\nCategories and Subject Descriptors: D.1.6 [Programming Techniques]: Logic Programming;\nD.1.2 [Programming Techniques]: Automatic Programming; F.4.1 [Mathematical Logic\nand Formal Languages]: Mathematical Logic-logic programming\nGeneral Terms: Languages, Theory\nAdditional Key Words and Phrases: Termination analysis, dynamic characterization, Prolog\n\n1. INTRODUCTION\nFor a program in any computer language, in addition to having to be logically\ncorrect, it should be terminating. Due to frequent use of recursion in logic programming, however, a logic program may more likely be non-terminating than a\nprocedural program. Termination of logic programs then becomes an important\ntopic in logic programming research. Because the problem is extremely hard (undecidable in general), it has been considered as a never-ending story; see [Schreye\nAuthor's address: Yi-Dong Shen, Department of Computer Science, Chongqing University,\nChongqing 400044, China. Email: ydshen@cs.ualberta.ca. Jia-Huai You and Li-Yan Yuan, Department of Computing Science, University of Alberta, Edmonton, Canada T6G 2H1. Email:\n{you, yuan}@cs.ualberta.ca. Samuel S. P. Shen, Department of Mathematics, University of Alberta, Edmonton, Canada T6G 2H1. Email: shen@ualberta.ca. Qiang Yang, School of Computing\nScience, Simon Fraser University, Burnaby, BC, Canada V5A 1S6. Email: qyang@cs.sfu.ca.\nPermission to make digital/hard copy of all or part of this material without fee for personal\nor classroom use provided that the copies are not made or distributed for profit or commercial\nadvantage, the ACM copyright/server notice, the title of the publication, and its date appear, and\nnotice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish,\nto post on servers, or to redistribute to lists requires prior specific permission and/or a fee.\nc 20TBD ACM 1529-3785/20TBD/0700-0001 $5.00\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD, Pages 1\u201314.\n\n\f2\n\n*\n\nYi-Dong Shen et al.\n\nand Decorte 1993] for a comprehensive survey.\nThe goal of termination analysis is to establish a characterization of termination of a logic program and design algorithms for automatic verification. A lot of\nmethods for termination analysis have been proposed in the last decade. A majority of these existing methods are the norm- or level mapping-based approaches,\nwhich consist of inferring mode/type information, inferring norms/level mappings,\ninferring models/interargument relations, and verifying some well-founded conditions (constraints). For example, Ullman and Van Gelder [Ullman and Gelder\n1988] and Pl\u00fcmer [Plumer 1990b; 1990a] focused on establishing a decrease in term\nsize of some recursive calls based on interargument relations; Apt, Bezem and Pedreschi [Apt and Pedreschi 1993; Bezem 1992], and Bossi, Cocco and Fabris [Bossi\net al. 1994] provided characterizations of Prolog left-termination based on level\nmappings/norms and models; Verschaetse [Verschaetse 1992], Decorte, De Schreye and Fabris [Decorte et al. 1993], and Martin, King and Soper [Martin et al.\n1997] exploited inferring norms/level mappings from mode and type information;\nDe Schreye and Verschaetse [Schreye and Verschaetse 1995], Brodsky and Sagiv\n[Brodsky and Sagiv 1991], and Lindenstrauss and Sagiv [Lindenstrauss and Sagiv\n1997] discussed automatic inference of interargument/size relations; De Schreye,\nVerschaetse and Bruynooghe [Schreye et al. 1992] addressed automatic verification\nof the well-founded constraints. Very recently, Decorte, De Schreye and Vandecasteele [Decorte et al. 1999] presented an elegant unified termination analysis that\nintegrates all the above components to produce a set of constraints that, when\nsolvable, yields a termination proof.\nIt is easy to see that the above methods are compile-time (or static) approaches\nin the sense that they make termination analysis only relying on some static information about the structure (of the source code) of a logic program, such as\nmodes/types, norms (i.e. term sizes of atoms of clauses)/level mappings, models/interargument relations, and the like. Our observation shows that some dynamic\ninformation about the structure of a concrete infinite SLDNF-derivation, such as\nrepetition of selected subgoals and recursive increase in term size, plays a crucial\nrole in characterizing the termination. Such dynamic features are hard to capture\nby applying a compile-time approach. This suggests that methods of extracting\nand utilizing dynamic features for termination analysis are worth exploiting.\nIn this note, we present a dynamic approach by employing dynamic features of\nan infinite (generalized) SLDNF-derivation to characterize termination of general\nlogic programs. In Section 2, we introduce a notion of a generalized SLDNF-tree,\nwhich is the basis of our method. Roughly speaking, a generalized SLDNF-tree is\na set of standard SLDNF-trees augmented with an ancestor-descendant relation on\ntheir subgoals. In Section 3, we define a key concept, loop goals, which captures\nboth repetition of selected subgoals and recursive increase in term size of these subgoals. We then prove a necessary and sufficient condition for an infinite generalized\nSLDNF-derivation in terms of loop goals. This condition allows us to establish a\ndynamic characterization of termination of general logic programs (Section 4). In\nSection 5, we mention the related work, and in Section 6 we conclude the paper\nwith our future work.\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n3\n\n1.1 Preliminaries\nWe present our notation and review some standard terminology of logic programs\nas described in [Lloyd 1987].\nVariables begin with a capital letter, and predicate, function and constant symbols with a lower case letter. A term is a constant, a variable, or a function of the\nform f (T1 , ..., Tm ) where f is a function symbol and the Ti s are terms. An atom is\nof the form p(T1 , ..., Tm ) where p is a predicate symbol and the Ti s are terms. A\nliteral is of the form A or \u00acA where A is an atom. Let A be an atom/term. The\nsize of A, denoted |A|, is the number of occurrences of function symbols, variables\nand constants in A. By {Ai }ni=1 we denote a sequence A1 , A2 , ..., An . Two atoms,\nA and B, are said to be variants if they are the same up to variable renaming.\nLists are commonly used terms. A list is of the form [] or [T |L] where T is a\nterm and L is a list. For our purpose, the symbols [, ] and | in a list are treated as\nfunction symbols.\nDefinition 1.1. A (general) logic program is a finite set of clauses of the form\nA \u2190 L1 , ..., Ln\nwhere A is an atom and Li s are literals. When n = 0, the \"\u2190\" symbol is omitted.\nA is called the head and L1 , ..., Ln is called the body of the clause. If a general\nlogic program has no clause with negative literals like \u00acA in its body, it is called a\npositive logic program.\nDefinition 1.2. A goal is a headless clause \u2190 L1 , ..., Ln where each literal Li is\ncalled a subgoal. L1 , ..., Ln is called a (concrete) query.\nThe initial goal, G0 =\u2190 L1 , ..., Ln , is called a top goal. Without loss of generality,\nwe shall assume throughout the paper that a top goal consists only of one atom,\ni.e. n = 1 and L1 is a positive literal.\nDefinition 1.3. A control strategy consists of two rules, one for selecting a goal\nfrom among a set of goals and the other for selecting a subgoal from the selected\ngoal.\nThe second rule in a control strategy is usually called a selection or computation\nrule in the literature. To facilitate our presentation, throughout the paper we choose\nto use the best-known depth-first, left-most control strategy (used in Prolog) to\ndescribe our approach (It can be adapted to any other fixed control strategies). So\nthe selected subgoal in each goal is the left-most subgoal. Moreover, the clauses in\na logic program are used in their textual order.\nTrees are commonly used to represent the search space of a top-down proof\nprocedure. For convenience, a node in such a tree is represented by Ni : Gi where\nNi is the name of the node and Gi is a goal labeling the node. Assume no two\nnodes have the same name. Therefore, we can refer to nodes by their names.\n2. GENERALIZED SLDNF-TREES\nIn order to characterize infinite derivations more precisely, in this section we extend\nthe standard SLDNF-trees [Lloyd 1987] to include some new features. We first\ndefine the ancestor-descendant relation on selected subgoals. Informally, A is an\nancestor subgoal of B if the proof of A needs (or in other words goes via) the proof\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f4\n\n*\n\nYi-Dong Shen et al.\n\nof B. For example, let M :\u2190 A, A1 , ..., Am be a node in an SLDNF-tree, and\nN :\u2190 B1 , ..., Bn , A1 , ..., Am be a child node of M that is generated by resolving\nM on the subgoal A with a clause A \u2190 B1 , ..., Bn . Then A at M is an ancestor\nsubgoal of all Bi s at N . However, such relationship does not exist between A at M\nand any Aj at N . It is easily seen that all Bi s at N inherit the ancestor subgoals\nof A at M .\nThe ancestor-descendant relation can be explicitly expressed using an ancestor\nlist. The ancestor list of a subgoal A at a node M , denoted ALA@M , is of the\nform {(N1 , D1 ), ..., (Nl , Dl )} (l \u2265 0), where for each (Ni , Di ) \u2208 ALA@M , Ni is a\nnode name and Di a subgoal such that Di at Ni is an ancestor subgoal of A at\nM . For instance, in the above example, the ancestor list of each Bi at node N\nis ALBi @N = {(M, A)} \u222a ALA@M and the ancestor list of each Ai at node N is\nALAi @N = ALAi @M .\nLet Ni : Gi and Nk : Gk be two nodes and A and B be the selected subgoals in\nGi and Gk , respectively. We use A \u227aanc B to denote that A is an ancestor subgoal\nof B. When A is an ancestor subgoal of B, we refer to B as a descendant subgoal\nof A, Ni as an ancestor node of Nk , and Nk as a descendant node of Ni .\nAugmenting SLDNF-trees with ancestor lists leads to the following definition of\nSLDNF\u2217 -trees.\nDefinition 2.1 (SLDNF\u2217 -trees). Let P be a general logic program, Gr =\u2190 Ar\na goal with Ar an atom, and R the depth-first, left-most control strategy. The\nSLDNF\u2217 -tree TNr :Gr for P \u222a {Gr } via R is defined inductively as follows.\n(1) Nr : Gr is its root node, and the tree is completed once a node marked as\nLAST is generated or when all its leaf nodes have been marked as \u2737t , \u2737f or\n\u2737f l .\n(2) For each node Ni :\u2190 L1 , ..., Lm in the tree that is selected by R, if m = 0 then\n(1) Ni is a success leaf marked as \u2737t and (2) if ALAr @Nr 6= \u2205 then Ni is also\na node marked as LAST. Otherwise (i.e. m > 0), we distinguish between the\nfollowing three cases.\n(a) L1 is a positive literal. For each clause B \u2190 B1 , ..., Bn in P such that L1\nand B are unifiable, Ni has a child node\nNs :\u2190 (B1 , ..., Bn , L2 , ..., Lm )\u03b8\nwhere \u03b8 is an mgu (i.e. most general unifier) of L1 and B, the ancestor list\nfor each Bk \u03b8, k \u2208 {1, . . . , n}, is ALBk \u03b8@Ns = {(Ni , L1 )} \u222a ALL1 @Ni , and\nthe ancestor list for each Lk \u03b8, k \u2208 {2, . . . , m}, is ALLk \u03b8@Ns = ALLk @Ni .\nIf there exists no clause in P whose head can unify with L1 then Ni has a\nsingle child node \u2212 a failure leaf marked as \u2737f .\n(b) L1 = \u00acA is a ground negative literal. Let TNi+1 :\u2190A be an (subsidiary)\nSLDNF\u2217 -tree for P \u222a {\u2190 A} via R with ALA@Ni+1 = ALL1 @Ni . We have\nthe following four cases:\ni. TNi+1 :\u2190A has a success leaf. Then Ni has a single child node \u2212 a failure\nleaf marked as \u2737f .\nii. TNi+1 :\u2190A has no success leaf but has a flounder leaf. Then Ni has a\nsingle child node \u2212 a flounder leaf marked as \u2737f l .\niii. All branches of TNi+1 :\u2190A end with a failure leaf. Then Ni has a single\nchild node\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n5\n\nNs :\u2190 L2 , ..., Lm\nwith ALLk @Ns = ALLk @Ni for each k \u2208 {2, . . . , m}.\niv. Otherwise, Ni has no child node. It is the last node of TNr :Gr so that\nit is marked as LAST.\n(c) L1 = \u00acA is a non-ground negative literal. Then Ni has a single child node\n\u2212 a flounder leaf marked as \u2737f l .\nStarting from the root node Nr : Gr , we expand the nodes of the SLDNF\u2217 -tree\nTNr :Gr following the depth-first order. The expansion for TNr :Gr stops when either\na node marked as LAST is generated or all of its leaf nodes have been marked as\n\u2737t , \u2737f or \u2737f l .\nIn this paper we do not consider floundering \u2212 a situation where a non-ground\nnegative subgoal is selected by R (see the case 2c). See [Chan 1988] for discussion\non such topic.\nWe first prove the following.\nTheorem 2.2. Let TNi+1 :\u2190A be a subsidiary SLDNF\u2217 -tree built for proving a\nnegative subgoal L1 = \u00acA at a node Ni (see the case 2b). Then ALA@Ni+1 6= \u2205.\nProof. Note that ALA@Ni+1 = ALL1 @Ni . Since the subgoal L1 at Ni is negative, Ni cannot be the root node of the SLDNF\u2217 -tree that contains Ni . Therefore,\nL1 at Ni has at least one ancestor subgoal (i.e. the subgoal at the root node of the\ntree), which means ALA@Ni+1 6= \u2205.\nIn order to solve a top goal G0 =\u2190 A0 , we build an SLDNF\u2217 -tree TN0 :\u2190A0\nfor P \u222a {G0 } via R with ALA0 @N0 = \u2205. It is easy to see that TN0 :\u2190A0 is an\nenhancement of the standard SLDNF-tree for P \u222a {G0 } via R with the following\nthree new features.\n(1) Each node Ni is associated with an ancestor list ALLj @Ni for each Lj of its\nsubgoals. In particular, subgoals of a subsidiary SLDNF\u2217 -tree TNi+1 :\u2190A built\nfor solving a negative subgoal L1 = \u00acA at Ni inherit the ancestor list ALL1 @Ni\n(see the case 2b). This bridges the ancestor-descendant relationships across\nSLDNF\u2217 -trees and is especially useful in identifying infinite derivations across\nSLDNF\u2217 -trees (see Example 2.1). Note that a negative subgoal will never be\nan ancestor subgoal.\n(2) In a standard SLDNF-tree, to handle a ground negative subgoal L1 = \u00acA at Ni\na full subsidiary SLDNF-tree F T for P \u222a{\u2190 A} via R must be generated. In an\nSLDNF\u2217 -tree, however, the subsidiary SLDNF\u2217 -tree TNi+1 :\u2190A may not include\nall branches of F T because it will terminate at the first success leaf (see the\ncase 2 where by Theorem 2.2 ALA@Ni+1 6= \u2205). The intuition behind this is that\nit is absolutely unnecessary to exhaust the remaining branches of F T because\nthey would never generate any new answers for A (and \u00acA). Such a pruning\nmechanism embedded in SLDNF\u2217 -trees is very useful in not only improving the\nefficiency of query evaluation but also avoiding some possible infinite derivations\n(see Example 2.2). In fact, Prolog performs the same pruning by using a cut\noperator to skip the remaining branches of F T once the first success leaf is\ngenerated (e.g. see SICStus Prolog [ISLAB 1998]).\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f6\n\n*\n\nYi-Dong Shen et al.\n\n(3) A well-known problem with the standard SLDNF-tree approach (formally called\nSLDNF-resolution [Clark 1978; Lloyd 1987]) is that for some programs, such\nas P = {A \u2190 \u00acA} and G0 =\u2190 A, no SLDNF-trees exist [Apt and Doets 1994;\nKunen 1989; Martelli and Tricomi 1992]. The main reason for this abnormality\nlies in the fact that to solve a negative subgoal \u00acA it generates a subsidiary\nSLDNF-tree F T for P \u222a {\u2190 A} via R which is supposed either to contain a\nsuccess leaf or to consist of failure leaves. When F T neither contains a success\nleaf nor finitely fails by going into an infinite derivation, the negative subgoal\ncannot be handled.\nIn contrast, SLDNF\u2217 -trees exist for any general logic programs. A ground\nnegative subgoal \u00acA at a node Ni succeeds if all branches of the subsidiary\nSLDNF\u2217 -tree TNi+1 :\u2190A end with a failure leaf (see the case 2(b)iii), and fails\nif TNi+1 :\u2190A has a success leaf (see the case 2(b)i). Otherwise, the value of the\nsubgoal \u00acA is undetermined and thus Ni is marked as LAST, showing that it\nis the last node of the underlying SLDNF\u2217 -tree which can be finitely generated\n(see the case 2(b)iv).1 The tree is then completed here.\nFor convenience, we use dotted edges \"* * *\u22b2\u2032\u2032 to connect parent and child (subsidiary) SLDNF\u2217 -trees, so that infinite derivations across SLDNF\u2217 -trees can be\nclearly identified. Formally, we have\nDefinition 2.3. Let P be a general logic program, G0 a top goal and R the depthfirst, left-most control strategy. Let TN0 :G0 be the SLDNF\u2217 -tree for P \u222a {G0 } via\nR with ALA0 @N0 = \u2205. A generalized SLDNF-tree for P \u222a {G0 } via R, denoted\nGTG0 , is rooted at N0 : G0 and consists of TN0 :G0 along with all its descendant\nSLDNF\u2217 -trees, where parent and child SLDNF\u2217 -trees are connected via \"* * *\u22b2\u2032\u2032 .\nTherefore, a path of a generalized SLDNF-tree may come across several SLDNF\u2217 trees through dotted edges. Any such a path starting at the root node N0 : G0 is\ncalled a generalized SLDNF-derivation.\nThus, there may occur two types of edges in a generalized SLDNF-derivation,\nC\n\"\u2212\u2192\" and \" * * * \u22b2\u2032\u2032 . For convenience, we use \" \u21d2\u2032\u2032 to refer to either of them.\nMoreover, for any node Ni : Gi we use L1i to refer to the selected (i.e. left-most)\nsubgoal in Gi .\nExample 2.1. Let P1 be a general logic program and G0 a top goal, given by\nP1 :\nG0 :\n\np(X) \u2190 \u00acp(f (X)).\n\u2190 p(a).\n\nCp1\n\nThe generalized SLDNF-tree GT\u2190p(a) for P1 \u222a {G0 } is shown in Figure 1, where\n\u221e represents an infinite extension. Note that to expand the node N1 , we build a\n1 This case occurs when either T\n\u2217\nNi+1 :\u2190A or some of its descendant SLDNF -trees is infinite, or\nTNi+1 :\u2190A has an infinite number of descendant SLDNF\u2217 -trees. Note that LAST is used here\nonly for the purpose of formulating an SLDNF\u2217 -tree \u2212 showing that Ni is the last node of the\nSLDNF\u2217 -tree. In practical implementation of SLDNF\u2217 -trees, in such a case Ni will never be\nmarked by LAST since it requires an infinitely long time to build TNi+1 :\u2190A together with all of\nits descendant SLDNF\u2217 -trees. However, the SLDNF\u2217 -tree is always completed at Ni , whether Ni\nis marked by LAST or not, because (1) such a case occurs at most one time in an SLDNF\u2217 -tree\nand (2) it always occurs at the last generated node Ni .\n\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n7\n\nsubsidiary SLDNF\u2217 -tree TN2 :\u2190p(f (a)) . Since TN2 :\u2190p(f (a)) neither contains a success\nleaf nor finitely fails (i.e. not all of its leaf nodes are marked as \u2737f ), N1 is the last\nnode of TN0 :\u2190p(a) , marked as LAST. We see that GT\u2190p(a) is infinite, although all\nof its SLDNF\u2217 -trees are finite.\nN0 : \u2190 p(a)\nCp1\n\n\u2744\n\nN1 : \u2190 \u00acp(f (a))\n\n\u2732 N2 : \u2190 p(f (a))\n\n. . . . .\n\nCp1\n\nLAST\n\n\u2744\n\nN3 : \u2190 \u00acp(f (f (a)))\n\n\u2732 N4 : \u2190 p(f (f (a)))\n\n. . . . .\n\nCp1\n\nLAST\n\nFig. 1.\n\n\u2744\n\u221e\n\nThe generalized SLDNF-tree GT\u2190p(a) .\n\nExample 2.2. Consider the following general logic program and top goal.\np \u2190 \u00acq.\nq.\nq \u2190 q.\n\u2190 p.\n\nP2 :\n\nG0 :\n\nCp1\nCq1\nCq2\n\nThe generalized SLDNF-tree GT\u2190p for P2 \u222a{G0 } is depicted in Figure 2 (a). GT\u2190p\nconsists of two SLDNF\u2217 -trees, TN0 :\u2190p and TN2 :\u2190q , which are constructed as follows.\nInitially, TN0 :\u2190p has only the root node N0 :\u2190 p. Expanding the root node against\nthe clause Cp1 leads to the child node N1 :\u2190 \u00acq. We then build a subsidiary\nSLDNF\u2217 -tree TN2 :\u2190q for P2 \u222a {\u2190 q} via the depth-first, left-most control strategy,\nwhere the expansion stops right after the node N3 is marked as LAST. Since TN2 :\u2190q\nhas a success leaf, N1 gets a failure child node N5 . TN0 :\u2190p is then completed.\nFor the purpose of comparison, the standard SLDNF-trees for P2 \u222a {\u2190 p} are\nshown in Figure 2 (b). Note that Figure 2 (a) is finite, whereas Figure 2 (b) is not.\nN0 : \u2190 p\nCp1\n\n\u2744\n\nN1 : \u2190 \u00acq\n.\n\n.\n\n\u274f\u274f\n\u276b\n\n.\n\u2722\n.\n\nN5 : \u2737f\n\nN2 : \u2190 q\nCq1\n\n\u2722\u2721\n\u2721\n\nN3 : \u2737t\n\nC\n\nq2\n\u274f\u274f\n\u276b\n\nN2 : \u2190 q\n\nN0 : \u2190 p\n\nCq1\n\nCp1\n\n\u2744\n\n\u2721\n\u2722\u2721 \u274f\u274f\n\u276bCq2\n\nN3 : \u2737t N4 : \u2190 q\n\nN1 : \u2190 \u00acq\n\n\u2721\n\u2722\u2721 \u274f\u274f\n\u276bCq2\nN5 : \u2737t\n\u221e\nCq1\n\n\u2744\nN\u221e : \u2737f\n\nN4 : \u2190 q\n\nLAST\n\n(a)\n\n(b)\n\nFig. 2. The generalized SLDNF-tree GT\u2190p (a) and its two corresponding standard SLDNF-trees\n(b).\n\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f*\n\n8\n\nYi-Dong Shen et al.\n\n3. CHARACTERIZING AN INFINITE GENERALIZED SLDNF-DERIVATION\nIn this section we establish a necessary and sufficient condition for an infinite generalized SLDNF-derivation. We begin by introducing a few concepts.\nDefinition 3.1. Let T be a term or an atom and S be a string that consists\nof all predicate symbols, function symbols, constants and variables in T , which is\nobtained by reading these symbols sequentially from left to right. The symbol string\nof T , denoted ST , is the string S with every variable replaced by X .\nFor instance, let T1 = a, T2 = f (X, g(X, f (a, Y ))) and T3 = [X, a]. Then ST1 = a,\nST2 = f X gX f aX and ST3 = [X |[a|[]]]. Note that [X, a] is a simplified representation for the list [X|[a|[]]].\nDefinition 3.2. Let ST1 and ST2 be two symbol strings. ST1 is a projection of\nST2 , denoted ST1 \u2286proj ST2 , if ST1 is obtained from ST2 by removing zero or more\nelements.\nFor example, aX X bc \u2286proj f aX eX bX cd. It is easy to see that the relation \u2286proj\nis reflexive and transitive. That is, for any symbol strings S1 , S2 and S3 , we have\nS1 \u2286proj S1 , and that S1 \u2286proj S2 and S2 \u2286proj S3 implies S1 \u2286proj S3 .\nDefinition 3.3. Let A1 = p(.) and A2 = p(.) be two atoms. A1 is said to loop\ninto A2 , denoted A1 \u2740loop A2 , if SA1 \u2286proj SA2 . Let Ni : Gi and Nj : Gj be two\nnodes in a generalized SLDNF-derivation with L1i \u227aanc L1j and L1i \u2740loop L1j . Then\nGj is called a loop goal of Gi .\nThe following result is immediate.\nTheorem 3.4. (1 ) The relation \u2740loop is reflexive and transitive.\n(2 ) If A1 \u2740loop A2 then |A1 | \u2264 |A2 |.\n(3 ) If G3 is a loop goal of G2 that is a loop goal of G1 then G3 is a loop goal of\nG1 .\nObserve that since a logic program has only a finite number of clauses, an infinite\ngeneralized SLDNF-derivation results from repeatedly applying the same set of\nclauses, which leads to infinite repetition of selected variant subgoals or infinite\nrepetition of selected subgoals with recursive increase in term size. By recursive\nincrease of term size of a subgoal A from a subgoal B we mean that A is B with\na few function/constant/variable symbols added and possibly with some variables\nchanged to different variables. Such crucial dynamic characteristics of an infinite\ngeneralized SLDNF-derivation are captured by loop goals, as shown by the following\nprincipal theorem.\nTheorem 3.5. D is an infinite generalized SLDNF-derivation if and only if it\nis of the form\nN0 : G0 \u21d2 ...Ng1 : Gg1 \u21d2 ...Ng2 : Gg2 \u21d2 ...Ng3 : Gg3 \u21d2 ...\nsuch that for any j \u2265 1, Ggj+1 is a loop goal of Ggj .\nWe need Higman's Lemma to prove this theorem.2\n2 It\n\nis one of the anonymous reviewers who brought this lemma to our attention.\n\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n9\n\nLemma 3.6 (Higman's Lemma [Higman 1952; Bol 1991]). Let {Ai }\u221e\ni=1 be an\ninfinite sequence of strings over a finite alphabet \u03a3. Then for some i and k > i,\nAi \u2286proj Ak\nThe following result follows from Lemma 3.6.\nLemma 3.7. Let {Ai }\u221e\ni=1 be an infinite sequence of strings over a finite alphabet\n\u03a3. Then there is an infinite increasing integer sequence {ni }\u221e\ni=1 such that for all i\nAni \u2286proj Ani+1 .\nProof.\n\n3\n\nSuppose this is not true. Let us take a finite maximal subsequence\nAn1 \u2286proj An2 \u2286proj ... \u2286proj Ank1\n\nThe subsequence is maximal in the sense that for no i > nk1 do we have Ank1 \u2286proj\nAi . We know that such a subsequence with length at least 2 must exist from\nLemma 3.6 and the assumption that the assertion of the lemma does not hold\nfor the sequence {Ai }\u221e\ni=1 . Now look at the elements of the original sequence with\nindices larger than nk1 and take another such finite maximal subsequence from\nthem. Continuing in this way, we get infinitely many such maximal subsequences.\nLet {Anki }\u221e\ni=1 be the sequence of last elements of the maximal subsequences. By\nLemma 3.6, this sequence has two elements, Anki and Ankj with nki < nkj , such\nthat Anki \u2286proj Ankj . This contradicts the assumption that Anki is the last element\nof some finite maximal subsequence.\nThe following lemma is needed to prove Theorem 3.5.\nLemma 3.8. Let D be an infinite generalized SLDNF-derivation. Then there are\ninfinitely many goals Gg1 , Gg2 , ... in D such that for any j \u2265 1, L1j \u227aanc L1j+1 .\nProof. Let D be of the form\nN0 : G0 \u21d2 N1 : G1 \u21d2 ... \u21d2 Ni : Gi \u21d2 Ni+1 : Gi+1 \u21d2 ...\nC\n\nConsider derivation steps like Ni : Gi \u2212\u2192 Ni+1 : Gi+1 * * * \u22b2Ni+2 : Gi+2 , where L1i\nis a positive subgoal and L1i+1 = \u00acA a negative subgoal. So L1i+2 = A. We see that\nboth L1i and L1i+1 need the proof of L1i+2 . Moreover, given L1i+2 the provability\nof L1i does not depend on L1i+1 . Since L1i+1 has no descendant subgoals, removing\nit would affect neither the provability nor the ancestor-descendant relationships of\nother subgoals in D. Therefore, we delete L1i+1 by marking Ni+1 with #.\nC\n\nFor each derivation step Ni : Gi \u2212\u2192 Ni+1 : Gi+1 , where L1i is a positive subgoal\nand C = A \u2190 B1 , ...Bn such that A\u03b8 = L1i \u03b8 under an mgu \u03b8, we do the following:\n(1) If n = 0, which means L1i is proved at this step, mark node Ni with #.\n(2) Otherwise, the proof of L1i needs the proof of Bj \u03b8 (j = 1, ..., n). If all descendant\nnodes of Ni in D have been marked with #, which means that all Bj \u03b8 have\nbeen proved at some steps in D, mark node Ni with #.\nNote that the root node N0 will never be marked with #, for otherwise G0 would\nhave been proved and D should have ended at a success or failure leaf. After the\nabove marking process, let D become\n3 This\n\nproof is suggested by an anonymous reviewer.\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f10\n\n*\n\nYi-Dong Shen et al.\n\nN0 : G0 \u21d2 ... \u21d2 Ni1 : Gi1 \u21d2 ... \u21d2 Ni2 : Gi2 \u21d2 ... \u21d2 Nik : Gik \u21d2 ...\nwhere all nodes except N0 , Ni1 , Ni2 , ..., Nik , ... are marked with #. Since we use the\ndepth-first, left-most control strategy, for any j \u2265 0 the proof of L1ij needs the proof\nof L1ij+1 (let i0 = 0), for otherwise Nij would have been marked with #. That is,\nL1ij is an ancestor subgoal of L1ij+1 . Moreover, D must contain an infinite number\nof such nodes because if Nik : Gik was the last one, which means that all nodes\nafter Nik were marked with #, then L1ik would be proved, so that Nik should be\nmarked with #, a contradiction.\nWe are ready to prove Theorem 3.5.\nProof (Proof of Theorem 3.5). (\u21d0=) Straightforward.\n(=\u21d2) By Lemma 3.8, D contains an infinite sequence of selected subgoals H1 =\n1\n1\n{L1ji }\u221e\ni=1 such that for any i Lji \u227aanc Lji+1 . Since any logic program has only a finite\nnumber of predicate symbols, H1 must have an infinite subsequence H2 = {L1ki }\u221e\ni=1\nsuch that all L1ki have the same predicate symbol, say p. We now show that H2 has\n1\n1\nan infinite subsequence {L1gi }\u221e\ni=1 such that for any i Lgi \u2740loop Lgi+1 .\nLet T be the (finite) set of all constant and function symbols in the logic program\nand let \u03a3 = T \u222a{X }. Then the symbol string SL1k of each L1ki in H2 is a string over\ni\n\u03a3 that begins with p. These symbol strings constitute an infinite sequence {pAi }\u221e\ni=1\nwith each Ai being a substring. By Lemma 3.7 there is an infinite increasing integer\nsequence {ni }\u221e\ni=1 such that for any i pAni \u2286proj pAni+1 . Therefore, H2 has an\ninfinite subsequence H3 = {L1gi }\u221e\ni=1 with SL1gi = pAni being the symbol string of\nL1gi . That is, for any i SL1g \u2286proj SL1g . Thus, for any i L1gi \u2740loop L1gi+1 .\ni\n\ni+1\n\n4. CHARACTERIZING TERMINATION OF GENERAL LOGIC PROGRAMS\nIn [Schreye and Decorte 1993], a generic definition of termination of logic programs\nis presented as follows.\nDefinition 4.1 ([Schreye and Decorte 1993]). Let P be a general logic program,\nSQ a set of queries and SR a set of selection rules. P is terminating w.r.t. SQ and\nSR if for each query Qi in SQ and for each selection rule Rj in SR , all SLDNF-trees\nfor P \u222a {\u2190 Qi } via Rj are finite.\nObserve that the above definition considers finite SLDNF-trees for termination.\nThat is, P is terminating w.r.t. Qi only if all (complete) SLDNF-trees for P \u222a {\u2190\nQi } are finite. This does not seem to apply to Prolog where there exist cases in\nwhich P is terminating w.r.t. Qi and Rj , although some (complete) SLDNF-trees\nfor P \u222a {\u2190 Qi } are infinite. Example 2.2 gives such an illustration, where Prolog\nterminates with a negative answer to the top goal G0 .\nIn view of the above observation, we present the following slightly different definition of termination based on a generalized SLDNF-tree.\nDefinition 4.2. Let P be a general logic program, SQ a finite set of queries and\nR the depth-first, left-most control strategy. P is terminating w.r.t. SQ and R if\nfor each query Qi in SQ , the generalized SLDNF-tree for P \u222a {\u2190 Qi } via R is finite.\nThe above definition implies that P is terminating w.r.t. SQ and R if and only\nif there is no infinite generalized SLDNF-derivation in any generalized SLDNF-tree\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n11\n\nGT\u2190Qi . This obviously applies to Prolog. We then have the following immediate result from Theorem 3.5, which characterizes termination of a general logic\nprogram.\nTheorem 4.3. P is terminating w.r.t. SQ and R if and only if for each query\nQi in SQ there is no generalized SLDNF-derivation in GT\u2190Qi of the form\nN0 : G0 \u21d2 ...Ng1 : Gg1 \u21d2 ...Ng2 : Gg2 \u21d2 ...Ng3 : Gg3 \u21d2 ...\nsuch that for any j \u2265 1, Ggj+1 is a loop goal of Ggj .\n5. RELATED WORK\nConcerning termination analysis, we refer the reader to the papers of Decorte, De\nSchreye and Vandecasteele [Schreye and Decorte 1993; Decorte et al. 1999] for\na comprehensive bibliography. Most existing termination analysis techniques are\nstatic approaches, which only make use of the syntactic structure of the source code\nof a logic program to establish some well-founded conditions/constraints that, when\nsatisfied, yield a termination proof. Since non-termination is caused by an infinite\ngeneralized SLDNF-derivation, which contains some essential dynamic characteristics that are hard to capture in a static way, static approaches appear to be less\nprecise than a dynamic one. For example, it is difficult to apply a static approach\nto prove the termination of program P2 in Example 2.2 with respect to a query\npattern p.\nThe concept of generalized SLDNF-trees is the basis of our approach. There are\nseveral new definitions of SLDNF-trees presented in the literature, such as that\nof Apt and Doets [Apt and Doets 1994], Kunen [Kunen 1989], or Martelli and\nTricomi [Martelli and Tricomi 1992]. Generalized SLDNF-trees have two distinct\nfeatures as compared to these definitions. First, the ancester-descendent relation\nis explicitly expressed (using ancester lists) in a generalized SLDNF-tree, which is\nessential in identifying loop goals. Second, a ground negative subgoal \u00acA at a node\nNi in a SLDNF\u2217 -tree TNr :Gr is formulated in the same way as in Prolog, i.e. (1) the\nsubsidiary SLDNF\u2217 -tree TNi+1 :\u2190A for the subgoal terminates at the first success\nleaf, and (2) \u00acA succeeds if all branches of TNi+1 :\u2190A end with a failure leaf and\nfails if TNi+1 :\u2190A has a success leaf. When TNi+1 :\u2190A goes into an infinite extension,\nthe node Ni is treated as the last node of TNr :Gr which can be finitely generated.\nAs a result, a generalized SLDNF-tree exists for any general logic programs.\nOur work is also related to loop checking \u2212 another research topic in logic programming which focuses on detecting and eliminating infinite loops. Informally, a\nderivation\nN0 : G0 \u21d2 N1 : G1 \u21d2 ... \u21d2 Ni : Gi \u21d2 ... \u21d2 Nk : Gk \u21d2 ...\nis said to step into a loop at a node Nk : Gk if there is a node Ni : Gi (0 \u2264 i < k)\nin the derivation such that Gi and Gk are sufficiently similar. Many mechanisms\nrelated to loop checking have been presented in the literature (e.g. [Bol et al.\n1991; Shen et al. 2001]). However, most of them apply only to SLD-derivations\nfor positive logic programs and thus cannot deal with infinite recursions through\nnegation like that in Figure 1 or 2.\nLoop goals are defined on a generalized SLDNF-derivation for general logic programs and can be used to define the sufficiently similar goals in loop checking. For\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f12\n\n*\n\nYi-Dong Shen et al.\n\nsuch an application, they play a role similar to expanded variants defined in [Shen\net al. 2001]. Informally, expanded variants are variants except that some terms\nmay grow bigger. However, expanded variants have at least three disadvantages\nas compared to loop goals: their definition is less intuitive, their computation is\nmore expensive, and they are not transitive in the sense that A being an expanded\nvariant of B that is an expanded variant of C does not necessarily imply A is an\nexpanded variant of C.\n6. CONCLUSIONS AND FUTURE WORK\nWe have presented an approach to characterizing termination of general logic programs by making use of dynamic features. A concept of generalized SLDNF-trees\nis introduced, a necessary and sufficient condition for infinite generalized SLDNFderivations is established, and a new characterization of termination of a general\nlogic program is developed.\nWe have recently developed an algorithm for automatically predicting termination of general logic programs based on the characterization established in this\npaper. The algorithm identifies the most-likely non-terminating programs. Let P\nbe a general logic program, SQ a set of queries and R the depth-first, left-most\ncontrol strategy. P is said to be most-likely non-terminating w.r.t. SQ and R if for\nsome query Qi in SQ , there is a generalized SLDNF-derivation with a few (e.g. two\nor three) loop goals. Our experiments show that for most representative general\nlogic programs we have collected in the literature, they are not terminating w.r.t.\nSQ and R if and only if they are most-likely non-terminating w.r.t. SQ and R.\nThis algorithm can be incorporated into Prolog as a debugging tool, which would\nprovide the users with valuable debugging information for them to understand the\ncauses of non-termination.\nTabled logic programming is receiving increasing attention in the community of\nlogic programming (e.g. [Chen and Warren 1996; Shen et al. 2002]). Verbaeten, De\nSchreye and Sagonas [Verbaeten et al. 2001] recently exploited termination proofs\nfor positive logic programs with tabling. For future research, we are considering\nextending the work of the current paper to deal with general logic programs with\ntabling.\nACKNOWLEDGMENTS\n\nWe are particularly grateful to Danny De Schreye, Krzysztof Apt, Jan Willem Klop\nand the three anonymous referees for their constructive comments on our work and\nvaluable suggestions for its improvement. One anonymous reviewer brought the\nHigman's lemma to our attention. Another anonymous reviewer suggested the proof\nof Lemma 3.7 and presented us a different yet interesting proof to the Higman's\nlemma based on an idea from Dershowitz's paper [Dershowitz 1987]. The work of\nYi-Dong Shen is supported in part by Chinese National Natural Science Foundation\nand Trans-Century Training Program Foundation for the Talents by the Chinese\nMinistry of Education. Qiang Yang is supported by NSERC and IRIS III grants.\nREFERENCES\nApt, K. R. and Doets, K. 1994. A new definition of sldnf-resolution. Journal of Logic Programming 18, 177\u2013190.\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\fCharacterizing Termination of General Logic Programs\n\n*\n\n13\n\nApt, K. R. and Pedreschi, D. 1993. Reasoning about termination of pure prolog programs.\nInformation and Computation 106, 109\u2013157.\nBezem, M. 1992. Characterizing termination of logic programs with level mapping. Journal of\nLogic Programming 15, 1/2, 79\u201398.\nBol, R. N. 1991. Loop checking in logic programming. Ph.D. thesis, The University of Amsterdam, Amsterdam.\nBol, R. N., Apt, K. R., and Klop, J. W. 1991. An analysis of loop checking mechanisms for\nlogic programs. Theoretical Computer Science 86, 1, 35\u201379.\nBossi, A., Cocco, N., and Fabris, M. 1994. Norms on terms and their use in proving universal\ntermination of a logic program. Theoretical Computer Science 124, 1, 297\u2013328.\nBrodsky, A. and Sagiv, Y. 1991. Inference of inequality constraints in logic programs. In Proceedings of the Tenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database\nSystems. ACM Press, Denver, 227\u2013240.\nChan, D. 1988. Constructive negation based on the completed database. In Proceedings of the\nFifth International Conference and Symposium on Logic Programming. MIT Press, Seattle,\n111\u2013125.\nChen, W. D. and Warren, D. S. 1996. Tabled evaluation with delaying for general logic programs. J. ACM 43, 1, 20\u201374.\nClark, K. L. 1978. Negation as failure. In (H.Gallaire and J. Minker, eds.) Logic and Databases.\nPlenum, New York, 293\u2013322.\nDecorte, S., Schreye, D. D., and Fabris, M. 1993. Automatic inference of norms: A missing\nlink in automatic termination analysis. In Proceedings of the 1993 International Symposium\non Logic Programming. MIT Press, Vancouver, Canada, 420\u2013436.\nDecorte, S., Schreye, D. D., and Vandecasteele, H. 1999. Constraint-based termination\nanalysis of logic programs. ACM Transactions on Programming Languages and Systems 21, 6,\n1137\u20131195.\nDershowitz, N. 1987. Termination of rewriting. J. Symbolic Computation 3, 69\u2013116.\nHigman, G. 1952. Ordering by divisibility in abstract algebras. Proceedings of the London\nMathematical Society 3, 2, 326\u2013336.\nISLAB.\n1998.\nSICStus\nProlog\nUser's\nManual.\nIntelligent\nSystems\nLaboratory,\nSwedish\nInstitute\nof\nComputer\nScience,\nAvailable\nfrom\nhttp://www.sics.se/sicstus/docs/3.7.1/html/sicstus toc.html.\nKunen, K. 1989. Signed data dependencies in logic programming. Journal of Logic Programming 7, 231\u2013246.\nLindenstrauss, N. and Sagiv, Y. 1997. Automatic termination analysis of logic programs. In\nProceedings of the Fourteenth International Conference on Logic Programming. MIT Press,\nLeuven, Belgium, 63\u201377.\nLloyd, J. W. 1987. Foundations of Logic Programming. Springer-Verlag, Berlin.\nMartelli, M. and Tricomi, C. 1992. A new sldnf-tree. Information Processing Letters 43, 2,\n57\u201362.\nMartin, J. C., King, A., and Soper, P. 1997. Typed norms for typed logic programs. In Proceedings of the 6th International Workshop on Logic Programming Synthesis and Transformation.\nSpringer, Stockholm, Sweden, 224\u2013238.\nPlumer, L. 1990a. Termination Proofs for Logic Programs. Lecture Notes in Computer Science\n446, Springer-Verlag, Berlin.\nPlumer, L. 1990b. Termination proofs for logic programs based on predicate inequalities. In\nProceedings of the Seventh International Conference on Logic Programming. MIT Press, Cambridge, MA, 634\u2013648.\nSchreye, D. D. and Decorte, S. 1993. Termination of logic programs: the never-ending story.\nJournal of Logic Programming 19, 20, 199\u2013260.\nSchreye, D. D. and Verschaetse, K. 1995. Deriving linear size relations for logic programs by\nabstract interpretation. New Generation Computing 13, 2, 117\u2013154.\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f14\n\n*\n\nYi-Dong Shen et al.\n\nSchreye, D. D., Verschaetse, K., and Bruynooghe, M. 1992. A framework for analyzing\nthe termination of definite logic programs with respect to call patterns. In Proceedings of the\nInternational Conference on Fifth Generation Computer Systems. IOS Press, Tokyo, Japan,\n481\u2013488.\nShen, Y. D., Yuan, L. Y., and You, J. H. 2001. Loop checks for logic programs with functions.\nTheoretical Computer Science 266, 1/2, 441\u2013461.\nShen, Y. D., Yuan, L. Y., and You, J. H. 2002. Slt-resolution for the well-founded semantics.\nJournal of Automated Reasoning 28, 1, 53\u201397.\nUllman, J. D. and Gelder, A. V. 1988. Efficient tests for top-down termination of logical rules.\nJ. ACM 35, 2, 345\u2013373.\nVerbaeten, S., Schreye, D. D., and Sagonas, K. 2001. Termination proofs for logic programs\nwith tabling. ACM Transactions on Computational Logic 2, 1, 57\u201392.\nVerschaetse, K. 1992.\nStatic termination analysis for definite horn clause programs.\nPh.D. thesis, Department of Computer Science, K. U. Leuven, Available at\nhttp://www.cs.kuleuven.ac.be/ lpai.\n\nReceived June 2000; revised August 2001 and December 2001; accepted April 2002\n\nACM Transactions on Computational Logic, Vol. TBD, No. TBD, TBD 20TBD.\n\n\f"}