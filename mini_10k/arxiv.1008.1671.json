{"id": "http://arxiv.org/abs/1008.1671v1", "guidislink": true, "updated": "2010-08-10T09:23:09Z", "updated_parsed": [2010, 8, 10, 9, 23, 9, 1, 222, 0], "published": "2010-08-10T09:23:09Z", "published_parsed": [2010, 8, 10, 9, 23, 9, 1, 222, 0], "title": "A Parsing Scheme for Finding the Design Pattern and Reducing the\n  Development Cost of Reusable Object Oriented Software", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1008.0783%2C1008.3282%2C1008.5377%2C1008.0116%2C1008.3737%2C1008.0084%2C1008.4137%2C1008.0969%2C1008.1303%2C1008.5303%2C1008.2731%2C1008.3841%2C1008.3269%2C1008.5042%2C1008.0398%2C1008.1243%2C1008.0536%2C1008.2373%2C1008.0780%2C1008.0593%2C1008.5384%2C1008.0389%2C1008.4434%2C1008.0514%2C1008.4664%2C1008.2573%2C1008.1097%2C1008.5182%2C1008.2118%2C1008.2175%2C1008.4147%2C1008.4417%2C1008.0825%2C1008.2134%2C1008.3695%2C1008.3893%2C1008.5031%2C1008.0622%2C1008.3640%2C1008.1671%2C1008.1811%2C1008.4094%2C1008.2308%2C1008.2924%2C1008.0248%2C1008.0765%2C1008.2959%2C1008.2063%2C1008.1123%2C1008.0233%2C1008.3658%2C1008.1784%2C1008.1128%2C1008.2651%2C1008.5008%2C1008.3447%2C1008.5258%2C1008.0688%2C1008.4623%2C1008.0996%2C1008.3850%2C1008.0419%2C1008.1659%2C1008.3498%2C1008.3821%2C1008.1032%2C1008.0793%2C1008.4857%2C1008.3215%2C1008.1109%2C1008.0077%2C1008.5159%2C1008.2628%2C1008.2368%2C1008.1485%2C1008.0640%2C1008.5044%2C1008.1901%2C1008.2092%2C1008.3565%2C1008.2963%2C1008.3785%2C1008.1433%2C1008.1560%2C1008.3514%2C1008.3449%2C1008.0634%2C1008.0191%2C1008.3261%2C1008.1849%2C1008.0633%2C1008.4034%2C1008.3578%2C1008.0635%2C1008.3193%2C1008.2583%2C1008.1064%2C1008.5238%2C1008.2836%2C1008.2915%2C1008.0219&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Parsing Scheme for Finding the Design Pattern and Reducing the\n  Development Cost of Reusable Object Oriented Software"}, "summary": "Because of the importance of object oriented methodologies, the research in\ndeveloping new measure for object oriented system development is getting\nincreased focus. The most of the metrics need to find the interactions between\nthe objects and modules for developing necessary metric and an influential\nsoftware measure that is attracting the software developers, designers and\nresearchers. In this paper a new interactions are defined for object oriented\nsystem. Using these interactions, a parser is developed to analyze the existing\narchitecture of the software. Within the design model, it is necessary for\ndesign classes to collaborate with one another. However, collaboration should\nbe kept to an acceptable minimum i.e. better designing practice will introduce\nlow coupling. If a design model is highly coupled, the system is difficult to\nimplement, to test and to maintain overtime. In case of enhancing software, we\nneed to introduce or remove module and in that case coupling is the most\nimportant factor to be considered because unnecessary coupling may make the\nsystem unstable and may cause reduction in the system's performance. So\ncoupling is thought to be a desirable goal in software construction, leading to\nbetter values for external software qualities such as maintainability,\nreusability and so on. To test this hypothesis, a good measure of class\ncoupling is needed. In this paper, based on the developed tool called Design\nAnalyzer we propose a methodology to reuse an existing system with the\nobjective of enhancing an existing Object oriented system keeping the coupling\nas low as possible.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1008.0783%2C1008.3282%2C1008.5377%2C1008.0116%2C1008.3737%2C1008.0084%2C1008.4137%2C1008.0969%2C1008.1303%2C1008.5303%2C1008.2731%2C1008.3841%2C1008.3269%2C1008.5042%2C1008.0398%2C1008.1243%2C1008.0536%2C1008.2373%2C1008.0780%2C1008.0593%2C1008.5384%2C1008.0389%2C1008.4434%2C1008.0514%2C1008.4664%2C1008.2573%2C1008.1097%2C1008.5182%2C1008.2118%2C1008.2175%2C1008.4147%2C1008.4417%2C1008.0825%2C1008.2134%2C1008.3695%2C1008.3893%2C1008.5031%2C1008.0622%2C1008.3640%2C1008.1671%2C1008.1811%2C1008.4094%2C1008.2308%2C1008.2924%2C1008.0248%2C1008.0765%2C1008.2959%2C1008.2063%2C1008.1123%2C1008.0233%2C1008.3658%2C1008.1784%2C1008.1128%2C1008.2651%2C1008.5008%2C1008.3447%2C1008.5258%2C1008.0688%2C1008.4623%2C1008.0996%2C1008.3850%2C1008.0419%2C1008.1659%2C1008.3498%2C1008.3821%2C1008.1032%2C1008.0793%2C1008.4857%2C1008.3215%2C1008.1109%2C1008.0077%2C1008.5159%2C1008.2628%2C1008.2368%2C1008.1485%2C1008.0640%2C1008.5044%2C1008.1901%2C1008.2092%2C1008.3565%2C1008.2963%2C1008.3785%2C1008.1433%2C1008.1560%2C1008.3514%2C1008.3449%2C1008.0634%2C1008.0191%2C1008.3261%2C1008.1849%2C1008.0633%2C1008.4034%2C1008.3578%2C1008.0635%2C1008.3193%2C1008.2583%2C1008.1064%2C1008.5238%2C1008.2836%2C1008.2915%2C1008.0219&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Because of the importance of object oriented methodologies, the research in\ndeveloping new measure for object oriented system development is getting\nincreased focus. The most of the metrics need to find the interactions between\nthe objects and modules for developing necessary metric and an influential\nsoftware measure that is attracting the software developers, designers and\nresearchers. In this paper a new interactions are defined for object oriented\nsystem. Using these interactions, a parser is developed to analyze the existing\narchitecture of the software. Within the design model, it is necessary for\ndesign classes to collaborate with one another. However, collaboration should\nbe kept to an acceptable minimum i.e. better designing practice will introduce\nlow coupling. If a design model is highly coupled, the system is difficult to\nimplement, to test and to maintain overtime. In case of enhancing software, we\nneed to introduce or remove module and in that case coupling is the most\nimportant factor to be considered because unnecessary coupling may make the\nsystem unstable and may cause reduction in the system's performance. So\ncoupling is thought to be a desirable goal in software construction, leading to\nbetter values for external software qualities such as maintainability,\nreusability and so on. To test this hypothesis, a good measure of class\ncoupling is needed. In this paper, based on the developed tool called Design\nAnalyzer we propose a methodology to reuse an existing system with the\nobjective of enhancing an existing Object oriented system keeping the coupling\nas low as possible."}, "authors": ["K. M. Azharul Hasan", "Mohammad Sabbir Hasan"], "author_detail": {"name": "Mohammad Sabbir Hasan"}, "author": "Mohammad Sabbir Hasan", "arxiv_comment": "15 pages, 5 figures", "links": [{"href": "http://arxiv.org/abs/1008.1671v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1008.1671v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "68N30", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "K.6.3", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1008.1671v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1008.1671v1", "journal_reference": "International journal of computer science & information Technology\n  (IJCSIT), 2(3), 2010", "doi": null, "fulltext": "A Parsing Scheme for Finding the Design Pattern and\nReducing the Development Cost of Reusable Object\nOriented Software\nK. M. Azharul Hasan, Mohammad Sabbir Hasan\nComputer Science and Engineering Department\nKhulna University Of Engineering and Technology(KUET)\nKhulna 9203, Bangladesh.\nazhasan@gmail.com, shabbir_cse03@yahoo.com\nABSTRACT\nBecause of the importance of object oriented methodologies, the research in developing new measure for object\noriented system development is getting increased focus. The most of the metrics need to find the interactions\nbetween the objects and modules for developing necessary metric and an influential software measure that is\nattracting the software developers, designers and researchers. In this paper a new interactions are defined for\nobject oriented system. Using these interactions, a parser is developed to analyze the existing architecture of the\nsoftware. Within the design model, it is necessary for design classes to collaborate with one another. However,\ncollaboration should be kept to an acceptable minimum i.e. better designing practice will introduce low coupling.\nIf a design model is highly coupled, the system is difficult to implement, to test and to maintain overtime. In case of\nenhancing software, we need to introduce or remove module and in that case coupling is the most important factor\nto be considered because unnecessary coupling may make the system unstable and may cause reduction in the\nsystem's performance. So coupling is thought to be a desirable goal in software construction, leading to better\nvalues for external software qualities such as maintainability, reusability and so on. To test this hypothesis, a good\nmeasure of class coupling is needed. In this paper, based on the developed tool called Design Analyzer we\npropose a methodology to reuse an existing system with the objective of enhancing an existing Object oriented\nsystem keeping the coupling as low as possible.\n\nKEYWORDS\nCoupling, Cohesion, Design Pattern, Object Oriented Paradigm, Principal Component Analysis, Reusable\nSoftware.\n\n1. INTRODUCTION\nThere is increasing pressure on software developers to produce quality software in as short time as\npossible. This necessitates the reuse of previously developed or commercially available software elements\nto expedite the development process. The most common form of reuse is the reuse of code in a fine-grain\nmanner such as objects in the object-oriented paradigm or a large-grain manner such as components in the\ncomponent oriented paradigm [1]. A severe problem is encountered, however, is the quickly increasing\ncomplexity of such systems and the lack of adequate criteria and guidelines for good designs. To cope\nwith this problem, it is imperative to better understand the properties and characteristics of object-oriented\nsystems.\nReusability of software is considered as crucial technical precondition to improve the overall software\nquality and reduce production and maintenance cost [2]. Software components are supposed to be better\n1\n\n\freusable and more flexible compared to conventionally developed software. Unfortunately, the benefits\nassociated technology has their price [3]. Poor documentation of the code makes studying and\nunderstanding details painful and time consuming for reusing that software. Abstracting design details\nfrom the source code help to understand the implementation details reuse it in efficient manner.\nSometimes it becomes even impossible to understand particular document without the design details.\nDesign patterns provide ways to structure software components into systems that are flexible, extensible,\nand have a high degree of reusability. Design patterns are an attempt to capture expertise in building\nobject-oriented software that describes solution to a recurring design problem in a systematic and general\nway. Gamma at el [4] defines design patterns as \"descriptions of communicating objects and classes that\nare customized to solve a general design problem in a particular context.\" A design pattern names,\nabstracts, and identifies the key aspects of a common design structure that makes it useful for creating a\nreusable object-oriented design. The design pattern identifies the participating classes and their instances,\ntheir roles and collaborations, and the distribution of responsibilities. Object-oriented design patterns\ntypically show relationships and interactions between classes or objects, without specifying the final\napplication classes or objects that are involved[3][5]. In this paper a methodology is proposed to find the\ndesign pattern of the software from the source code. This would provide several goals in software\nconstruction leading to better values for external attributes such as maintainability, reusability, and\nreliability. To find the design pattern it is important to know the interactions between the internal\ncomponents of the software. Different interactions are pointed out and described to get the interactions.\nCoupling characterizes a module's relationship to other modules of the system. It measures the\ninterdependence of two modules[4]. Coupling measures the strength of physical relationships among the\nitems that comprise an object. Strong coupling makes a system more complex, highly inter-related\nmodules are harder to understand, change or correct. Designing the systems with the weakest possible\ncoupling between modules can reduce complexity[7]. To validate the interactions we have selected three\ndifferent types of industrial software for case study. For analyzing the coupling measures of object\noriented systems based on different interactions of the classes, a parser has been developed named\n\"Design Analyzer\" to find the design pattern of the system. Such design analyzer is useful to get internal\nsoftware architecture of software developed in Object Oriented Paradigm[1]. Finally, using principal\ncomponent analysis [7] the measures are analyzed for selecting the most responsive coupling measure.\n\n2. CASE STUDY\nIn this research work the analysis was performed on four industrial softwares developed in Object\nOriented paradigm. A tool named \"Design Analyzer\" is developed as a part of this research work for\nparsing the source code to get the design pattern. The selected softwares were developed prior to the\nanalysis and no modification was done during the analysis. For proceeding in an efficient manner the\nprocess of analyzing the source codes should follow the syntax of the programming language. Brief\ndescriptions of these softwares are given here:\nSoftware 1-Turtle Chat: This is chatting software like Yahoo! Messenger. This software can send and\nreceive instant messages over Internet Protocol. There are two parts of this software: Server Part and\nClient Part. Here the Client side of contains 22 user defined classes and the Server side contains 4 user\ndefined classes.\nSoftware 2-Com Chat: This is also chatting software, which sends and receives data through the\ncommunication port of a personal computer. The software uses Java Communication API. The main\npurpose of this software is to simulate the seven layers of the OSI Model. The software implements\nBroadcasting, CheckSum and Routing techniques. This software contains 22 user defined classes.\nSoftware 3-Admission Test Management System: This is mainly database software which can be used for\nadmission test management of any university by storing information of the applicants, information of\n2\n\n\fallowed candidate for exam, merit list of selected candidates, waiting list and so on. This software\ncontains 13 user defined classes.\n\n3. RELETED WORKS\nIn OO paradigm coupling describes the interdependency between methods and between object classes,\nrespectively [6][7]. Stevens et al., who first introduced coupling, in the context of structured development\ntechniques, define coupling as \"the measure of the strength of association established by a connection\nfrom one module to another\" [9]. Braind et al. defined some properties to be satisfied by the coupling\nmeasure for empirical validation [10]. There are differences between necessary and unnecessary coupling.\nThe rationale is that without any coupling the system is useless. Consequently, for any given software\nsolution there is a basic or necessary coupling level. Such unnecessary coupling does indeed needlessly\ndecrease the reusability of classes. There is also static and dynamic coupling measure for object oriented\nsystems. As the polymorphic method invocation is determined by run time, the coupling on this method\nbelongs to dynamic coupling [11]. It is not very much clear what the potential uses of existing measures\nare and how different coupling measures could be used in a complementary manner to obtain a more\ndetailed picture of the coupling in an object-oriented system. Several authors have tried to address this\nproblem by introducing frameworks to characterize different approaches to coupling and the relative\nstrengths of it. There are some existing and quite different frameworks for object-oriented coupling. Eder\net al. identify three different types of relationships[12]. These relationships, interaction relationships\nbetween methods, component relationships between classes, and inheritance between classes, are then\nused to derive different dimensions of coupling.\nHitz and Montazeri [13] characterize coupling by defining the state of an object (the value of its\nattributes at a given moment at run-time), and the state of an object's implementation (class interface and\nbody at a given time in the development cycle). From these definitions, they derive two \"levels\" of\ncoupling, Class level coupling (CLC), represents the coupling resulting from implementation\ndependencies between two classes in a system during the development lifecycle and Object level coupling\n(OLC), represents the coupling resulting from state dependencies between two objects during the run-time\nof a system.\nAn approach to measure coupling in object-based systems [14] such as those implemented in C++ by\nexpanding it to include inheritance and friendship relations between classes. This framework concentrates\non coupling as caused by interactions that occur between classes[15].\nAll the coupling measures mentioned in this paper are developed for using as metric suite. In this paper\nwe defined the interactions to find the design pattern of software. Designing software is phase which is\nnormally done before the implementation of software. But in this paper the design pattern of a software\nhas been recovered analyzing the existing source code. This design pattern will be used to reuse the\nexisting source code to modify or extend the software. This is a basic difference between other software\nmetric related works. Beside, In this a methodology is proposed to add a new module in a existing\nsoftware.\n\n4. A METHODOLOGY TO FIND THE DESIGN PATTERN FOR JAVA BASED OBJECT\nORIENTED SYSTEM\nBefore we go any further, it is imperative to first discuss the concept of a design pattern. Gamma at el\ndefines design patterns as \"descriptions of communicating objects and classes that are customized to solve\na general design problem in a particular context.\" A design pattern names, abstracts, and identifies the key\naspects of a common design structure that makes it useful for creating a reusable object-oriented design.\nThe design pattern identifies the participating classes and their instances, their roles and collaborations,\nand the distribution of responsibilities. Object-oriented design patterns typically show relationships and\n3\n\n\finteractions between classes or objects, without specifying the final application classes or objects that are\ninvolved. But beyond a description of the problem and its solution, software developers need deeper\nunderstanding to tailor the solution to their variant of the problem. Hence a design pattern also explains\nthe applicability, trade-offs, and consequences of the solution. It gives the rationale behind the solution,\nnot just a pat answer. In this paper the proposed Design Analyzer finds the interactions, roles,\ncollaborations and relationships of the software in a graphical format.\nIn the subsequent sub sections the interactions between objects is found out for Java based programs. In\nSection 3 these interactions are used to develop the algorithm for Design Analyzer. The term object is\nused to mean a module through out the paper.\n\n4.1 Types of Inter-module Interactions That Occur in Java\nThere different ways that are commonly found for interactions between the classes in a Java based\nobject-oriented software are described in this section. These inter module relationships are as follows:\n1. Inter-module relationship through Return Type\n2. Inter-module relationship through Argument Passing in a member function\n3. Inter-module relationship through Object Declaration\n4. Inter-module relationship through Inheritance\nFrom these four types of relationship, we have defined two types of interactions:\na) Operation-Operation (O-O) interaction\nb) Class-Class interaction (C-C) interaction\nOperation-Operation (O-O) interaction: The first two categories (relationship through return type and\nargument passing) above are included in O-O interaction. Hence we defined O-O interaction as follows\nDefinition 1: (Operation-Operation Interaction): The Operation-Operation interaction (O-O) is defined as\nthe interaction between two operations of two or more different objects or classes. Let OC be an operation\nof class C. There is an operation-operation interaction between classes C and D, if class D is the type of a\nparameter of operation OC or class D is the return type of OC.\nClass-Class interaction (C-C) interaction: The last two categories above (relationship through object\ndeclaration and inheritance) are included in C-C interaction. Hence we defined C-C interaction as follows\nDefinition 2: (Class-Class Interaction): The Class-Class interaction (C-C) is defined as the interaction\nbetween two classes if any one of the above two interaction occurs (i.e. interaction through object\ndeclaration or inheritance). Let C and D be two classes of an object oriented system. There is a C-C\ninteraction between the classes C and D, if an object Od of D is declared inside class C or D is derived\nfrom class C through inheritance.\nDefinition 3:(Interaction Graph ) The Interaction Graph <G,E> of a software is a graph where each\nnode G represents a class of the system and there is an edge E between two nodes G1 and G2 if there is an\ninteraction (O-O, C-C) between the two classes. Our developed and proposed Design Analyzer is an\nInteraction Graph.\n\n4.2 The Parsing Scheme to Find the Design Pattern\n\n4\n\n\fIn this section the two types of interactions defined in Section 2 (C-C and O-O) is parsed in java based\nprograms to develop the Design Analyzer. Although the examples are in Java but it can easily be extended\nin any object oriented language.\n4.2.1 Parsing for the O-O Interaction\nRelation through Argument Passing\nBefore proceeding we have to know the format of how classes can be inter-related through argument\npassing in functions. Let's consider two classes Class A and Class B. Let a is the object of Class A which\nis declared in the scope of Class B. In java this can happen in one of the following fashion:\n(1) Class B{\naccess-modifier static A function-name (argument list)\n}\n(2) Class B{\naccess-modifier final A function-name (argument list)\n}\n(3) Class B{\naccess-modifier A function-name (argument list)\n}\nHere access-modifier sits for indicating public, private or protected and argument list represents\nvariables of any data type. So from here we see that Class B is the container class because it contains a\nfunction that uses the object of another class as argument. During parsing the source codes of Class B if\nwe find a statement like:\naccess-modifier static A function-name (argument list) or access-modifier final A function-name\n(argument list) or\naccess-modifier A function-name (argument list);\nthen we can come to the decision that Class B is related to Class A through the object a and c as argument\nof the function function-name.\nRelation through Return Type of function\nConsidering two classes Class A and Class B. Let a is the object of Class A which is declared in the\nscope of Class B. In java this can happen in one of the following fashion:\n(1) Class B{\naccess-modifier static return-type function-name (A a, A c);\n}\n(2) Class B{\naccess-modifier final return-type function-name (A a, A c)\n}\n(3) Class B{\n5\n\n\faccess-modifier return-type function-name (A a, A c)\n}\nHere access-modifier sits for indicating public, private or protected and return type specifies value of\nany data type or void. So from here we see that Class B is the container class because it contains a\nfunction that uses the object of another class as argument. During parsing the source code of Class B if we\nfind a statement like\naccess-modifier static return-type function-name (A a, A c) or access-modifier final return-type functionname (A a, A c) or access-modifier return-type function-name (A a, A c);\nthen we can come to the decision that Class B is related to Class A through the object a and c as argument\nof the function function-name.\n4.2.2 Parsing for the C-C interaction\nRelation through object declaration\nBefore proceeding we have to know the format of how classes can be inter-related through object\ndeclaration in Java. Let's consider two classes Class A and Class B. Let a is the object of Class A which\nis declared in the scope of Class B. In java this can happen in the following fashion.\nClass B {\nA a = new A( );\n}\nSo from here we see that Class B is the container class because it contains the object of another class.\nDuring parsing the source code of Class B if we find a statement like A a = new A ( ); then we can come\nto the decision that Class B is related to Class A through the declaration of the object a.\nRelation through Inheritance\nLet's consider two classes Class A and Class B. Let a is the object of Class A which is declared in the\nscope of Class B. In java this can happen in one of the following fashion:\n(1) Class B extends A{\n// body of Class B\n}\n(2) Class B implements A {\n// body of Class B\n}\nSo from here we see that Class B inherits Class A. During parsing the source code of Class B if we find\na statement like Class B implements A or Class B extends A then we can come to the decision that Class\nB is related to Class A through inheritance.\n\n5. AN ANALYSIS OF DESIGN PATTERN USING DESIGN ANALYZER\nWe have developed tool using java for analyzing the source code of an object oriented system to get the\ndesign pattern of the system. We named it Design Analyzer. Through out the paper where we used the\nword Design Analyzer we mean the developed software. The Design Analyzer implements the parsing\n6\n\n\fscheme described in Section 4. The input of the system is the source code of an Object Oriented program\nand output is the graphical representation (See Fig. 1) of the design pattern of the software. The design\npattern is a graph <G,E> where each node G represents a class of the system and there is an edge E\nbetween two nodes if there is an interaction (O-O, C-C) between the two classes. We have considered\nonly the user defined classes that are found in the source code. This is because our next goal is to add a\nnew module in the system so that we can reuse the existing system with minimum modification.\n\nFig 1: Graphical Representation of the relationship among the User Defined Classes of software 1\nFig.1 shows the design pattern found using the Design Analyzer for software 1 described in Section 1\nfrom the figure we can see that there are 19 user defined classes in the system. Among them the class\nChatClient is very much coupled with other classes. The ChatClient class has 16 coupling relations with\nothers. We can see that there is no class isolated in the system. Hence this is a criterion of good design.\nBut the distribution of coupling is based on only three classes namely ChatClient, ScrollView and\nTappanel. This is a sign of low maintainability. Because if the class ChatClient fails for any reason most\nof the classes will be affected. Fig. 2 shows the design pattern of software 2. From Fig.3 we see that the\naverage coupling distribution is similar to the classes. Fig. 3 shows the design pattern of software 3. From\nthe figure we see that the software is poorly designed. Almost all the classes are coupled with one class\nnamely Admission. If this class fails or has a bug then the whole software will work poorly. In conclusion\nwe can say that to reuse a software it is very important to know about the design pattern of the software. If\nit is poorly designed then it might be error prone for reuse in the future.\n\n6. The Coupling Measures\nIn this research work the following couplings metrics have been chosen for the analysis of inter module\ndependencies. A brief definition of the measures is given here. All the measures determine the coupling\nbetween components. A survey of the metrics can be found in [16][17].\n1. Number of used classes by dependency relation (NUCD): This measure is used to count the total\nnumber of distinct classes with whom a particular class is creating dependency relation. Only one\nevidence for dependency relation would be enough, caused by any of dependency types (e.g. parameter,\nlocal variable, return type) to recognize the dependency between two classes.\n7\n\n\fFig 2: Graphical Representation of the relationship among the User Defined Classes of Software 2\n\nFig 3: Graphical Representation of the relationship among the User Defined Classes of Software 3\n\n2. Total number of evidences for \"Used classes by dependency relation\" (TNUCD): This measure is\nused to count total number of evidences for a particular class of \"Used classes by dependency relation.\"\nAll types of dependencies (e.g. parameter, local variable, return type) will be used to count such\nevidences.\n\n3. Number of user classes for a class through dependency relation (NUCC): This measurement\nrepresents the total number of distinct classes who are using a particular class through dependency\nrelations.\n4. Total number of evidences for \"User classes through dependency relation\" (TNUCC): This\nmeasurement counts the total number of usage evidences of a particular class by the other classes in OO\ndesign.\n\n8\n\n\f5. Class Coupling: The Class Coupling (CLC) is the summation of Client Coupling and Server Coupling\nof the class. It is the measure of the summation of out degree and in degree of a node in Class Class\nInteraction Graph(CCIG).\nClass Coupling= Client Coupling (CC) + Server Coupling (SC).\nThe number of Coupling Relations for which a class is a client to other class is called Client Coupling for\nthe class. It is the measure of out degree of a node in CCIG. The number of Coupling Relations for which\na class is a server to other class(s) is called Server Coupling for the class. It is the measure of in degree of\na node in CCIG.\n6. Visible Member: The measure \"Visible Member\" shows the amount of members (attributes and\nmethods) visible to other class numerically. This measure is used to find the over all members which can\nbe called or used by other classes. Visible members are the most required criteria for direct coupling\n\n7. Criteria of Measuring Coupling\nWe have developed an Interaction Graph (See Definition 3) and coupling occurs due to this interaction,\nhence among the coupling measures to select an effective one is necessary and useful. The methodology\nof Principal Component Analysis[7] has been adopted to select the most responsive coupling measure for\na system. When we want to add a module we need to find a class that is less responsive. From graphical\nanalysis we take decision to add a module in which the interaction graph has fewer edges and in this\nsection we show some experimental result to prove the idea.\n\n7.1 Experiment Design\nTo make a study of coupling measure we want to determine the best coupling metrics defined above. We\nare going to apply these measures on the software under observation. The above measures are applied on\nthese softwares through principal component analysis.\nPrincipal Component Analysis:\nPrincipal component analysis [7][17] is typically used to reduce the dimensionality and/or to extract new\nuncorrelated features from the original data. Principal component analysis involves an Eigen analysis on a\ncovariance matrix. If the input data is represented as a matrix X of 'n' rows and 'm' columns:\n\n\u23a1 x11\n\u23a2x\n\u23a2 21\nX =\u23a2 .\n\u23a2 .\n\u23a2x\n\u23a3 n1\n\nx12\nx 22\n.\n\n....\n....\n.\n\n.\n\n.\n...\n\nxn 2\n\nx1m \u23a4\nx 2 m \u23a5\u23a5\n. \u23a5\n. \u23a5\nx nm \u23a5\u23a6\n\nWhere n = total number of classes and m = total measures, when finding most effective measure and\nn = total number of measures and m = total number of classes, when finding the less responsive class.\nThen, the sample mean \u03bci is computed for each column when finding most effective measure, where\n\n1\n\u03bci =\nn\n\nn\n\n\u2211\n\ni =1\n\nx ij\n\nfor j = 1, 2...m.\n\nThen X can be centered to form X*\n9\n\n\f\u23a1 x11 \u2212 \u03bc1\n\u23a2x \u2212 \u03bc\n1\n\u23a2 21\nX* = \u23a2 .\n\u23a2 .\n\u23a2x \u2212 \u03bc\n1\n\u23a3 n1\n\nx12 \u2212 \u03bc 2\nx 22 \u2212 \u03bc 2\n.\n\n... x1m \u2212 \u03bc m \u23a4\n... x 2 m \u2212 \u03bc m \u23a5\u23a5\n.....\n.\n\u23a5\n\u23a5\n.....\n.\n.... x nm \u2212 \u03bc m \u23a5\u23a6\n\n.\nx 22 \u2212 \u03bc 2\n\nThen covariance matrix R = ( 1 )[ X * ]T X * is computed. An Eigen analysis on the covariance matrix R\n\nn\n\nyields a set of positive Eigen values {\u03bb1 , \u03bb 2 ,........., \u03bb m } . If the Eigen values are sorted in descending\norder (i.e., \u03bb1 > \u03bb2 > ..... > \u03bbm ), their corresponding Eigen vectors, { v1 , v 2 ,...., v m }, are the principal\ncomponents. The first principal component retains the most variance, if the feature vectors are projected\nonto the first principal component, more variance will be retained than if the vectors are projected onto\nany other principal component. The second component retains the next highest residual variance, and so\non. A smaller Eigen value contributes much less weight to the total variance. In many cases, the first few\ncomponents can retain nearly all of the variance. If the 'd' most significant principal components are\nselected for projection of the data, then the variance (V) retained by this approximation is [8]:\nd\n\nV =\n\n\u2211\n\n\u03bb\n\ni\n\n\u2211\n\n\u03bb\n\ni\n\ni=1\nm\ni=1\n\nV is also called the degree of accuracy for the approximation.\n\n8. Results and Discussions\n8.1 Finding an Effective metric for Coupling\nFor the set of xij are calculated as defined above for all 3 softwares under observation. Here Software-1\nhas 20 classes, Software-2 has 11 classes and Software-3 has 13 classes. The Principal Component\nAnalysis produces the principal components for coupling metrics (Shown in Table 1, Table 3 and Table\n5).\nIn case of Software-1 (see Table 1), the projection of the objects into the first principal component retains\n76.85% of the total variance and projection of the first two principal components retains 94.99% to the\ntotal variance as in Table 2. Observation of the first Eigen vectors reveals that in case of Category1\ncoupling metrics for Software-1, TNUCC is the most significantly weighted measure.\nIn case of Software-2 (see Table 3), the projection of the objects into the first principal component retains\n85.75% of the total variance and projection of the first two principal components retains 97.76% to the\ntotal variance as shown in Table 4. Observation of the first Eigen vectors reveals that in case of Category1\ncoupling metrics for Software-2, \"Class Coupling\" is the most significantly weighted measure.\nTable 5 shows the principal components of Category1 coupling metrics of Software-3, the projection of\nthe objects into the first principal component retains 84.46% of the total variance and projection of the\nfirst two principal components retains 96.87% to the total variance as shown in Table 6. Observation of\nthe first Eigen vectors reveals that in case of Category1 coupling metrics for Software-3, \"Class\nCoupling\" is the most significantly weighted measure.\nThe experimental result shows that projecting the object class feature vectors onto the first two principal\ncomponents retained up to a considerable range of the total variance, hence two components are sufficient\nto represent the entire dataset with less error. But the most significant component for all these software is\n\n10\n\n\fnot same. Hence there is no uniform coupling measure which remains the most significant component for\nall software.\n\nTable 1: The Principal Components and their Eigen Values for Coupling Metrics of Software 1.\nPrincipal\nComponent No.\n1\n2\n3\n4\n5\n6\n\nComponent Vector\n\nEigen Value\n\n(-0.0388 , 0.0505, 0.0289, 0.7147, 0.6960, 0.0000)\n\n2.8132\n\n(-0.3550, 0.7244, 0.1141, -0.0371, -0.0390, -0.5774)\n(-0.0399 , -0.0228 , 0.0026 , 0.6966 , -0.7160 , 0.0000)\n(-0.4562 , -0.6741 , -0.0521 , -0.0105 , 0.0365 , 0.5774)\n(-0.8112 , 0.0503 , 0.0620 , -0.0476 , -0.0025 , 0.5774)\n(-0.0690 , 0.1236 , -0.9897 , 0.0160 , 0.0118 , 0.0000)\n\n0.6641\n0.1771\n0.0043\n0.0018\n-0.0000\n\nTable 2: The retained variances of principal components for Coupling Metrics of Software 1.\nNumber of Component\n1\n2\n3\n4\n\n% Variance Retained\n76.85%\n94.99%\n99.83%\n99.95%\n\nDespite of the very interesting research work and studies on coupling measures, there is still a little\nunderstanding of the motivation and empirical hypotheses behind many of the measures. It is reported that\nrelating the measures is a difficult task in most of the cases and especially to conclude for which\napplications they can be used. Analysis shows that there are a lot of inconsistencies in different measures\nof coupling for object-oriented system. The variations of existing measures reveal that they cannot be\nrepresented in a unified framework accepted by all. Therefore, a conclusion can be drawn that the efforts\n\nTable 3: The Principal Components and their Eigen Values for Coupling Metrics of Software 2.\nPrincipal\nComponent No.\n1\n2\n3\n4\n\n5\n\n6\n\nComponent Vector\n(0.0795 , 0.0648 , -0.0225 , 0.5955 , 0.7344 , 0.3084)\n(0.5364 , 0.5395 , -0.0423, 0.4623, -0.3742, -0.2564)\n(0.0373 , -0.0463 , -0.2535 ,\n-0.0989 , -0.4453, 0.8510)\n(0.2428 , -0.8120 , -0.2278\n, -0.3757 , -0.1610, 0.2506)\n(0.7729 , -0.1612 , 0.3617\n, 0.4093 , 0.1854 ,\n0.2097)\n(0.2196 , 0.1317 , -0.8665\n, 0.3366 , 0.2492 , 0.0910)\n\n11\n\nEigen\nValue\n596.6112\n83.6107\n11.0265\n3.9422\n\n0.2327\n\n0.3619\n\n\fTable 4: The retained variances of principal components for Coupling Metrics of Software 2.\nNumber of Component\n1\n2\n3\n4\n\n% Variance Retained\n85.75%\n97.76%\n99.35%\n99.91%\n\nTable 5: The Principal Components and their Eigen Values for Coupling Metrics of Software 3.\nPrincipal\nComponent\nNo.\n1\n2\n3\n4\n5\n6\n\nComponent Vector\n\nEigen Value\n\n(-0.1548 , -0.0351 , -0.2210 , -0.5965 , 0.6043, -0.4529)\n(-0.3079 , -0.1109 , -0.6325 , -0.3580 , -0.2624 , 0.5438)\n(-0.3139 , 0.0804 , 0.2420 , -0.3704 , -0.6980, -0.4605)\n(-0.6161 , 0.2338 , 0.5561 , -0.0966 , 0.2745, 0.4145)\n(-0.6115 , 0.0560 , -0.3701 , 0.6063 , 0.0554, -0.3394)\n(0.1707 , 0.9603 , -0.2152 , -0.0440 , -0.0199, 0.0037)\n\n69.2342\n10.1730\n2.4804\n0.0583\n0.0224\n0.0081\n\nfor improving the understanding of object-oriented coupling and for creating a unique framework with\nempirical validation are useful and necessary.\n\nTable 6: The retained variances of principal components for Coupling Metrics of Software 3.\nNumber of Component\n1\n2\n3\n\n% Variance Retained\n84.46%\n96.87%\n99.89%\n\n8.2 Finding an Effective class to add a module for extending reusability\nHere effective class means the class that has low coupling with respect to others and the class in which if\none new module is added then the modification needed will be minimum to achieve the reusability. From\nthe graphical analysis the designer can take the decision of where to add the new module of the existing\nsoftware in an efficient manner by keeping the development cost as minimum as possible. This leads to a\nbetter reusability of the existing software. Here in this we show one example of software 1 (See fig...)\nwhere one new module is added to make the existing software reusable. From the graphical analysis of\nSoftware 1 the decision that can be taken is: a new module can be added beside the classes which are not\nhighly coupled such as: InformationDialog, CustomButton, ScrollBar, ImagePanel. Also we present a\nprincipal component analysis to find a module to interact with for reusing the module.\nTable 13 shows the first 3 principal component of software 1. Here first component retains 70.30%\nvariance and first two component retains 95.15% of the total variance. In Table 13 the lower coupling\ncontributing modules are shown in bold face. From the 3 principal components we can see that among the\nnegative impact values only module 9(whose name is InformationDialog and shown as underline) has\nnegative impact to all the principal components. Hence we can take decision if one module is added\ninteracting with only module 9 and then the purpose of the new software serves then it is a good decision\nto implement it. If the purpose does not serves then we should select a module having low coupling. Also\nwe can see from design pattern of software 1 that the class InformationDialog interacts only with 1 class\nnamely ChatClient. We have implemented our approach for software adding a new class StatusArea and\n12\n\n\fwe found that the system is working well serving the new purpose. Figure A shows the design pattern\nafter adding the new module StatusArea.\n\nTable 13: Principal components for finding most Affecting Class (Software 1)\nPrincipal\ncomp. #\n1.\n\n2.\n\n3.\n\nEigen Vector\n(-0.2190 -0.0989 0.5251 0.5679 0.2232 -0.0705 0.1037\n0.0043 -0.0430 0.0168 -0.0093 0.0019, 0.0167 0.1911 0.1806 0.3981 -0.0881 0.1068 0.0081 0.1707)\n( 0.9157 -0.0559 0.1064 0.1236 0.0472 0.0021 0.0214\n0.0033 -0.0089 0.0517 0.0505 0.0059, -0.0289 -0.1707 0.1957 0.1786 0.0640 -0.1361 -0.0267 0.0150 )\n(0.0874 0.5140 0.5518 -0.3007 -0.1698 0.0262 0.0652 0.0109 -0.0120 0.0457 -0.0055 -0.1150, 0.2353 0.1326\n0.0021 -0.2258 -0.0821 0.0315 -0.3285 0.2104)\n\nEigen Value\n0.9713\n\n0.2244\n\n0.0600\n\nFig 4 : Graphical Representation of the relationship among the User Defined Classes of software 1(after\nadding a new module)\n\n7. Conclusion\nIdentification of design patterns from source code is one of the most promising methods for improving\nsoftware maintainability and reusing design experience. It is hard or even impossible to understand poorly\ndocumented legacy systems. Nevertheless, developers try to understand unknown object oriented systems\nby analyzing the source code to recover the architecture of the system, which is a hard task since the\ndependencies between the classes cannot be recovered well enough. However when a software of Object\nOriented System undergoes the development process, the designer should be concern about the\ndevelopment cost that can be measured with respect to some quality metric of software such as Coupling.\nIn this paper, an approach of detecting design patterns from Java source code is presented and the\n13\n\n\fapproach continues with the analysis of source codes of softwares for selecting the most effective\ncomponent and the highly coupled class. This helps the designer to take the decision that how and where\na new module can be added in an efficient manner by keeping the coupling value as minimum as possible\nand by ensuring the reduction of development cost. We believe, the knowledge about design patterns\nusing the design tool can help developers to understand the underlying architecture faster.\n\nREFERENCES\n\n[1]\n\nW. AI-Ahmad, \"Object-Oriented Design Patterns for Detailed Design,\" Journal of Object\nTechnology, vol. 5 No. 2, pp. 155-169, 2006.\n\n[2]\n\nW. Pree, \"Meta Patterns-A means for capturing the essentials of reusable object-oriented design\",\nECOOP'94, LNCS 821, pp. 150-162. 1994.\n\n[3]\n\nW. Pree, H. Sikora, \"Design patterns for object-oriented software development (tutorial)\",\nInternational Conference on Software Engineering, Proceedings of the 19th international\nconference on Software engineering, pp. 663 \u2013 664, 1997.\n\n[4]\n\nMohammad S. Hasan, K. M. A. Hasan, Finding the Design Pattern from the Source Code for\nDeveloping Reusable Object Oriented Software, 2nd Int. Conference on the Application of Digital\nInformation and Web Technologies (ICADIWT 2009), August 4-6, 2009, London, UK, pp. 157162, IEEE Explorer.\n\n[5]\n\nS.R. Chidamber and C.F. Kemerer, \"A Metrics Suite for Object Oriented Design\", IEEE\nTransactions on Software Engineering 20 (6), 476-493, 1994.\n\n[6]\n\nP. Coad and E. Yourdon, \"Object-Oriented Analysis\", prentice-Hall, second edition 1991.\n\n[7]\n\nP.C. Wong, R.D. Bergeron, \"Multivariate visualization using metric scaling\". Proc., Visualization\n97, Phoenix, October 1997, pp. 111-118.\n\n[8]\n\nW. Stevens, G. Myers, and L. Constantine, \"Structured Design\", IBM Systems Journal, 13 (2),\n115-139, 1974.\n\n[9]\n\n. L. Briand, S. Morasca, and V. Basili, \"Property-Based Software Engineering Measurement\",\nIEEE Transactions of Software Engineering, 22 (1), 1996, pp. 68-86.\n\n[10]\n\nK. M. Azharul Hasan and D. N. Batanov, \"Measuring Coupling for Developing Object-Oriented\nSystems\", In Porc. ICT, April 8-10, pp. 325-330, 2003.\n\n[11]\n\nJ. Eder, G. Kappel, and M. Schrefl, \"Coupling and Cohesion in Object-Oriented Systems\",\nTechnical Report, University of Klagenfurt, 1994.\n\n[12]\n\nM. Hitz, and B. Montazeri, \"Measuring Coupling and Cohesion in Object-Oriented systems\", In\nProc. Int.Symposium on Applied Corporate Computing, 1995.\n\n[13]\n\nL. Briand, P. Devanbu, and W. Melo, 1997, \"An Investigation into Coupling Measures for C++\",\nTechnical Report ISERN 96-08, IEEE ICSE '97.\n\n14\n\n\f[14]\n\nDentcho N. Batanov and Somjit Arch-int, \"Business Objects and Components for Web-based\nInformation Systems Development\", Proceedings of IRMA'2002 Seattle, 2002.\n\n[15]\n\nImran Baig, \"Measuring Cohesion and Coupling of Object-Oriented Systems- Derivation and\nMutual Study of Cohesion and Coupling\", School of Engineering Blekinge Institute of\nTechnology, Thesis No: MSE-2004:29, pp. 20-26, August 2004\n\n[16]\n\nF. Brito e Abreu \"The MOOD Metrics Set\" Proc. ECOOP'95 Workshop on Metrics, 1995\n\n[17]\n\nK. M. Azharul Hasan, Mohammad Sabbir Hasan,\" Principal Component Analysis of Coupling\nMeasures for Developing High Quality Object Oriented Software\", Proceedings of 3rd\nInternational Conference on Computer Communication Engineering (ICCCE'10), Kualalampur,\nMalaysia, pp.217-222, IEEE.\n\nAuthors\nDr. K. M. Azharul Hasan received his B.Sc. (Engg.) from Khulna\nUniversity, Bangladesh in 1999 and M. E. from Asian Institute of\nTechnology (AIT), Thailand in 2002 both in Computer Science. He\nreceived his Ph.D. from the Graduate School of Engineering, University\nof Fukui, Japan in 2006. His research interest lies in the areas of\ndatabases and software engineering, and his main research interests\ninclude Parallel and distributed databases, Parallel algorithms,\nInformation retrieval, Data warehousing, MOLAP, Multidimensional\ndatabases, OOAD, Software metric and Software maintenance. He is\nwith the Department of Computer Science and Engineering Khulna\nUniversity of Engineering and Technology (KUET), Bangladesh since\n2001.\n\nMohammad Shabbir Hasan received his B.Sc. (Engg.) in\nComputer Science and Engineering from Khulna University of\nEngineering and Technology (KUET), Bangladesh in 2008. His\nresearch interest includes different areas of Software Engineering\nlike Software Metric, Requirement Gathering, Software Security\nand Software Maintenance. Currently he is serving as a Lecturer of\nDepartment of Computer Science and Engineering in Institute of\nScience, Trade and Technology (ISTT), Bangladesh.\n\n15\n\n\f"}