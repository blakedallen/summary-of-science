{"id": "http://arxiv.org/abs/0812.4642v2", "guidislink": true, "updated": "2009-01-08T06:08:39Z", "updated_parsed": [2009, 1, 8, 6, 8, 39, 3, 8, 0], "published": "2008-12-26T05:28:47Z", "published_parsed": [2008, 12, 26, 5, 28, 47, 4, 361, 0], "title": "Error-Trellis State Complexity of LDPC Convolutional Codes Based on\n  Circulant Matrices", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0812.3762%2C0812.3885%2C0812.3556%2C0812.2424%2C0812.2429%2C0812.0900%2C0812.1629%2C0812.1931%2C0812.2864%2C0812.4460%2C0812.4526%2C0812.0538%2C0812.1853%2C0812.4928%2C0812.2396%2C0812.2131%2C0812.4642%2C0812.2373%2C0812.1851%2C0812.5033%2C0812.4173%2C0812.2854%2C0812.1359%2C0812.1312%2C0812.5022%2C0812.0712%2C0812.4793%2C0812.2957%2C0812.4581%2C0812.0243%2C0812.1147%2C0812.0001%2C0812.3684%2C0812.4703%2C0812.1090%2C0812.0417%2C0812.1839%2C0812.3208%2C0812.2924%2C0812.0470%2C0812.3571%2C0812.4267%2C0812.0919%2C0812.3031%2C0812.2835%2C0812.4767%2C0812.4411%2C0812.2761%2C0812.0309%2C0812.3698%2C0812.0127%2C0812.1336%2C0812.3411%2C0812.4056%2C0812.3787%2C0812.5070%2C0812.3958%2C0812.4230%2C0812.2254%2C0812.4628%2C0812.3155%2C0812.1986%2C0812.3980%2C0812.0812%2C0812.0939%2C0812.4935%2C0812.3639%2C0812.1743%2C0812.4887%2C0812.4547%2C0812.3422%2C0812.1310%2C0812.0804%2C0812.4502%2C0812.4335%2C0812.1703%2C0812.1965%2C0812.0182%2C0812.3896%2C0812.0522%2C0812.4416%2C0812.2966%2C0812.2706%2C0812.2662%2C0812.4488%2C0812.2393%2C0812.4208%2C0812.4058%2C0812.4782%2C0812.0800%2C0812.3263%2C0812.1783%2C0812.2223%2C0812.3960%2C0812.3906%2C0812.0130%2C0812.0188%2C0812.2134%2C0812.2292%2C0812.3065%2C0812.2849&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Error-Trellis State Complexity of LDPC Convolutional Codes Based on\n  Circulant Matrices"}, "summary": "Let H(D) be the parity-check matrix of an LDPC convolutional code\ncorresponding to the parity-check matrix H of a QC code obtained using the\nmethod of Tanner et al. We see that the entries in H(D) are all monomials and\nseveral rows (columns) have monomial factors. Let us cyclically shift the rows\nof H. Then the parity-check matrix H'(D) corresponding to the modified matrix\nH' defines another convolutional code. However, its free distance is\nlower-bounded by the minimum distance of the original QC code. Also, each row\n(column) of H'(D) has a factor different from the one in H(D). We show that the\nstate-space complexity of the error-trellis associated with H'(D) can be\nsignificantly reduced by controlling the row shifts applied to H with the\nerror-correction capability being preserved.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0812.3762%2C0812.3885%2C0812.3556%2C0812.2424%2C0812.2429%2C0812.0900%2C0812.1629%2C0812.1931%2C0812.2864%2C0812.4460%2C0812.4526%2C0812.0538%2C0812.1853%2C0812.4928%2C0812.2396%2C0812.2131%2C0812.4642%2C0812.2373%2C0812.1851%2C0812.5033%2C0812.4173%2C0812.2854%2C0812.1359%2C0812.1312%2C0812.5022%2C0812.0712%2C0812.4793%2C0812.2957%2C0812.4581%2C0812.0243%2C0812.1147%2C0812.0001%2C0812.3684%2C0812.4703%2C0812.1090%2C0812.0417%2C0812.1839%2C0812.3208%2C0812.2924%2C0812.0470%2C0812.3571%2C0812.4267%2C0812.0919%2C0812.3031%2C0812.2835%2C0812.4767%2C0812.4411%2C0812.2761%2C0812.0309%2C0812.3698%2C0812.0127%2C0812.1336%2C0812.3411%2C0812.4056%2C0812.3787%2C0812.5070%2C0812.3958%2C0812.4230%2C0812.2254%2C0812.4628%2C0812.3155%2C0812.1986%2C0812.3980%2C0812.0812%2C0812.0939%2C0812.4935%2C0812.3639%2C0812.1743%2C0812.4887%2C0812.4547%2C0812.3422%2C0812.1310%2C0812.0804%2C0812.4502%2C0812.4335%2C0812.1703%2C0812.1965%2C0812.0182%2C0812.3896%2C0812.0522%2C0812.4416%2C0812.2966%2C0812.2706%2C0812.2662%2C0812.4488%2C0812.2393%2C0812.4208%2C0812.4058%2C0812.4782%2C0812.0800%2C0812.3263%2C0812.1783%2C0812.2223%2C0812.3960%2C0812.3906%2C0812.0130%2C0812.0188%2C0812.2134%2C0812.2292%2C0812.3065%2C0812.2849&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Let H(D) be the parity-check matrix of an LDPC convolutional code\ncorresponding to the parity-check matrix H of a QC code obtained using the\nmethod of Tanner et al. We see that the entries in H(D) are all monomials and\nseveral rows (columns) have monomial factors. Let us cyclically shift the rows\nof H. Then the parity-check matrix H'(D) corresponding to the modified matrix\nH' defines another convolutional code. However, its free distance is\nlower-bounded by the minimum distance of the original QC code. Also, each row\n(column) of H'(D) has a factor different from the one in H(D). We show that the\nstate-space complexity of the error-trellis associated with H'(D) can be\nsignificantly reduced by controlling the row shifts applied to H with the\nerror-correction capability being preserved."}, "authors": ["M. Tajima", "K. Okino", "T. Miyagoshi"], "author_detail": {"name": "T. Miyagoshi"}, "author": "T. Miyagoshi", "arxiv_comment": "5 pages, 5 figures", "links": [{"href": "http://arxiv.org/abs/0812.4642v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0812.4642v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.IT", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0812.4642v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0812.4642v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:0812.4642v2 [cs.IT] 8 Jan 2009\n\nError-Trellis State Complexity of LDPC\nConvolutional Codes Based on Circulant Matrices\nMasato Tajima\n\nKoji Okino\n\nTakashi Miyagoshi\n\nDept of Intellect. Inform. Systems Eng.\nUniversity of Toyama\nToyama 930-8555, Japan\ntajima@eng.u-toyama.ac.jp\n\nInformation Technology Center\nUniversity of Toyama\nToyama 930-8555, Japan\nokino@itc.u-toyama.ac.jp\n\nDept of Intellect. Inform. Systems Eng.\nUniversity of Toyama\nToyama 930-8555, Japan\nmiyagosi@eng.u-toyama.ac.jp\n\nAbstract- Let H(D) be the parity-check matrix of an LDPC\nconvolutional code corresponding to the parity-check matrix H\nof a QC code obtained using the method of Tanner et al. We\nsee that the entries in H(D) are all monomials and several rows\n(columns) have monomial factors. Let us cyclically shift the rows\nof H. Then the parity-check matrix H \u2032 (D) corresponding to the\nmodified matrix H \u2032 defines another convolutional code. However,\nits free distance is lower-bounded by the minimum distance of\nthe original QC code. Also, each row (column) of H \u2032 (D) has a\nfactor different from the one in H(D). We show that the statespace complexity of the error-trellis associated with H \u2032 (D) can\nbe significantly reduced by controlling the row shifts applied to\nH with the error-correction capability being preserved.\n\nI. I NTRODUCTION\nIn this paper, we assume that the underlying field is F =\nGF(2). Let G(D) be a polynomial generator matrix for an\n(n0 , k0 , \u03bd) convolutional code C with memory \u03bd. Denote by\nH(D) a corresponding parity-check matrix. Both G(D) and\nH(D) are assumed to be canonical [4], [5]. In this case, the\ncode-trellis module associated with G(D) and the error-trellis\nmodules [6] associated with the syndrome former H T (D) (T\nmeans transpose) have 2\u03bd states, where the obvious realization\nof G(D) and the adjoint-obvious realization [3] of H T (D)\nare assumed, respectively. Ariel and Snyders [1] presented\na construction of an error-trellis based on the scalar check\nmatrix derived from H(D). They showed that when some\n(jth) \"column\" of H(D) has a factor Dl (i.e., the jth column\nis not \"delay free\"), there is a possibility that state-space\nreduction can be realized. Being motivated by their work, we\nalso examined the same case. We took notice of a syndrome\ngeneration process. The time-k error ek and the time-k syndrome \u03b6 k are connected with the relation \u03b6 k = ek H T (D).\nFrom this relation, we noticed [8] that the transformation\n(j)\n(j)\n(j)\nek \u2192 Dl ek = ek\u2212l is equivalent to dividing the jth column\nl\nof H(D) by D . That is, reduction can be accomplished by\n(j)\nshifting the \"subsequence\" {ek } of the original error-path.\nOn the other hand, consider the parity-check matrix\n\u0012 2\n\u0013\n\u25b3\nD\nD2\n1\nH1 (D) =\n.\n(1)\n1 1 + D + D2 0\nSince H1 (D) is canonical and all the columns are delay free,\nany further reduction seems to be impossible. In fact, it follows\nfrom Theorem 1 of [1] that the dimension d1 of the state\n\nspace of the error-trellis based on H1T (D) is 4. However, a\n\u25b3\ncorresponding generator matrix is given by G1 (D) = (1+D+\nD2 , 1, D3 + D4 ). Note that the third column of G1 (D) has\na factor D2 . (Remark: It suffices to divide the third column\nby D2 in order to obtain a reduced code-trellis.) This fact\nimplies that a reduced error-trellis can be constructed [1], [8]\n(i.e., state-space reduction can be realized). Then consider the\nreciprocal dual encoder [4]\n\u0012\n\u0013\n\u25b3\n1\n1\nD2\nH\u03031 (D) =\n.\n(2)\nD2 1 + D + D2 0\nNote that the third column of H\u03031 (D) has a factor D2 .\nAccordingly, dividing the third column of H\u03031 (D) by D2 , we\ncan construct an error-trellis with 4 states (i.e., d \u03031 = 2) [1],\n[8]. Here, notice that each error-path in the error-trellis based\non H1T (D) can be represented in time-reversed order using\nthe error-trellis based on H\u03031T (D). Hence, a factor D2 in the\ncolumn of H\u03031 (D) corresponds to backward-shifting by two\ntime units (i.e., D\u22122 ) in terms of the original H1 (D). Actually,\nby \"multiplying\" the third column of H1 (D) by D2 , we have\n\u0012 2\n\u0013\n\u25b3\nD\nD2\nD2\nH1\u2032 (D) =\n.\n(3)\n1 1 + D + D2 0\nNote that this matrix can be reduced to an equivalent canonical\nparity-check matrix\n\u0012\n\u0013\n1\n1\n1\n\u25b3\n\u2032\u2032\nH1 (D) =\n(4)\n1 1 + D + D2 0\nby dividing the first \"row\" by D2 . Hence, the dimension d1\ncan be reduced to 2. (Remark: This fact cannot be derived\nfrom the results of [1].) It follows from the above argument\nthat there is a possibility that a reduced error-trellis can be\nconstructed not only using forward-shifted error subsequences\nbut also using backward-shifted error subsequences.\nNow, we remark that a parity-check matrix H(D) with\nthe form described above appears in [10]. Tanner et al. [10]\npresented a class of algebraically constructed quasi-cyclic\n(QC) LDPC codes and their convolutional counterparts. It\nis stated that the convolutional codes obtained in the paper\ntypically have large constraint lengths and therefore the use\nof trellis-based decoding is not feasible. However, the paritycheck matrices of LDPC convolutional codes proposed by\n\n\fTanner et al. have monomial entries. Accordingly, the abovementioned state-space reduction method can be directly applied to those parity-check matrices. Then we intended to\nevaluate the state-space complexity of the error-trellis of an\nLDPC convolutional code which appears in [10]. We show\nthat the overall constraint length (abbreviated as \"OCL\" in\nthis paper) of the parity-check matrix which specifies an\nLDPC convolutional code can be significantly reduced with\nthe error-correction capability of the convolutional code being\npreserved.\n\nAssume that the ith row of H(D) has the form\nDli h\u2032i1 (D)\n\nDli h\u2032i2 (D) . . . Dli h\u2032in0 (D)\n\n\u0001\n\n,\n\n(6)\n\nwhere li \u2265 1. Let H \u2032 (D) be the modified version of H(D)\nwith the ith row being replaced by\n\u0001\nh\u2032i1 (D) h\u2032i2 (D) . . . h\u2032in0 (D) .\n(7)\n\u2032\n\n(i)\n\nDefining \u03b6k\n(1)\n\n\u2032\n\n(i)\n\nas \u03b6k\n\n(i)\n\n\u25b3\n\n\u2032\n\n(i)\n\n= Dli \u03b6k\n\n(r)\n\n\u2032\n\n\u25b3\n\n(i)\n\n= \u03b6k\u2212li , we set \u03b6 \u2032k =\n\n(\u03b6k , * * * , \u03b6k , * * * , \u03b6k ). Then we have\n\u2032\n\n\u03b6 \u2032k = ek H T (D).\n\n(8)\n\nSimilarly, assume that the jth column of H(D) has the form\n\u0001T\nDlj h\u20321j (D) Dlj h\u20322j (D) . . . Dlj h\u2032rj (D)\n,\n(9)\n\nwhere lj \u2265 1. (Remark: H(D) is not basic [2] and then not\ncanonical.) Let H \u2032 (D) be the modified version of H(D) with\nthe jth column being replaced by\n\u0001T\nh\u20321j (D) h\u20322j (D) . . . h\u2032rj (D)\n.\n(10)\n\u25b3\n\n(1)\n\n\u2032\n\n(j)\n\n(n0 )\n\nAlso, let e\u2032k = (ek , * * * , ek , * * * , ek\n(j)\n(j)\nDlj ek = ek\u2212lj . Then we have\n\u2032\n\n\u03b6 k = e\u2032k H T (D).\n\n\u2032\n\n(j)\n\n), where ek\n\n\u25b3\n\n=\n\n(11)\n\nNoting these relations [8], [9], in the case where the ith\nrow of H(D) has a factor Dli , by shifting the ith syndrome\nsubsequence by li time units, whereas in the case where the\njth column of H(D) has a factor Dlj , by shifting the jth\nerror subsequence by lj time units, we can construct an error\ntrellis with reduced number of states. In the following, we call\nfactoring out Dl from a row of H(D) and from a column of\nH(D) \"row operation\" and \"column operation\", respectively.\n\nt=2\n\n001\n\nt=4\n000\n\n111\n\n110\n\nt=5\n\n010\n111\n\n000\n(01)\n110\n\n011\n\n100\n\n000\n\n101\n\n101\n\n011\n101\n\n110\n\n010\n\n001\n\n(1) (2)\n1\n1\n\n\u03b6 \u03b6 =01\n\nFig. 1.\n\n(1) (2)\n2\n2\n\n111\n\n\u03b6 \u03b6 =10\n\n(1) (2)\n3\n3\n\n\u03b6 \u03b6 =01\n\n010\n\n101\n\n100\n\n000\n\n001\n\n110\n\n111\n\n010\n\n001\n100\n\n111\n\n011\n\n110\n\n000\n\n011\n(10)\n\nt=3\n\n001\n010\n100\n\n(11)\n\nII. P RELIMINARIES\nA. Error-Trellis Construction Using Shifted Error/Syndrome\nSubsequences\nLet H(D) be a parity-check matrix for an (n0 , k0 ) convolutional code C. In this paper, we consider the error-trellis based\non the syndrome former H T (D). In this case, the adjointobvious realization of H T (D) is assumed unless otherwise\n(1)\n(j)\n(n )\nspecified. Denote by ek = (ek , * * * , ek , * * * , ek 0 ) and\n(1)\n(i)\n(r)\n\u03b6 k = (\u03b6k , * * * , \u03b6k , * * * , \u03b6k ) the time-k error and the time-k\nsyndrome, respectively, where r = n0 \u2212 k0 . Then we have the\nrelation:\n\u03b6 k = ek H T (D).\n(5)\n\nt=1\n\nt=0\n(00)\n\n011\n100\n(1) (2)\n4\n4\n\n\u03b6 \u03b6 =10\n\n101\n(2)\n\u03b6(1)\n5 \u03b65 =00\n\nExample error-trellis based on H2T (D).\n\nB. Error-Trellis Construction Based on a Reciprocal Dual\nEncoder\nConsider the (3, 1, 2) convolutional code C2 with canonical\nparity-check matrix given by\n\u0012\n\u0013\n\u25b3\nD\n0\n1\nH2 (D) =\n.\n(12)\n1 1+D 0\nIn this subsection, we discuss using this specific example.\nHowever, the argument is entirely general. Since the columns\nof H2 (D) are delay free, the dimension d2 of the state space\nof the error-trellis based on the syndrome former H2T (D) is\ngiven by 2 (see Theorem 1 of [1]). Fig.1 shows an error-trellis\nconstructed based on H2T (D) using the conventional method\n[6]. It is assumed that a transmitted code-path is terminated in\nthe all-zero state at t = 4 and the corresponding received data\nis given by z = z 1 z 2 z 3 z 4 z 5 = 010 011 000 001 000,\nwhere z 5 = 000 is the imaginary received data. Let z be\nthe input of the syndrome former H2T (D), then we have the\nsyndrome sequence \u03b6 = \u03b6 1 \u03b6 2 \u03b6 3 \u03b6 4 \u03b6 5 = 01 10 01 10 00.\nThe overall error-trellis is constructed by concatenating five\nerror-trellis modules corresponding to \u03b6 k . Note that the errortrellis in Fig.1 is terminated in state (00) at t = 5, which\ncorresponds to the final syndrome-former state \u03c3 5 = (00).\nFrom Fig.1 (note that e5 = 000), we have four admissible\nerror-paths:\nep1\nep2\n\n=\n=\n\n010 011 000 001 000\n010 101 101 000 000\n\n(13)\n(14)\n\nep3\nep4\n\n=\n=\n\n100 000 100 000 000\n100 110 001 001 000.\n\n(15)\n(16)\n\nNext, consider the reciprocal dual encoder\n\u0012\n\u0013\n\u25b3\n1\n0\nD\nH\u03032 (D) =\n.\nD 1+D 0\n\n(17)\n\nLet z\u0303 = z 4 z 3 z 2 z 1 z 0 = 001 000 011 010 000 be the\ntime-reversed received data of {z k }4k=1 augmented with the\nimaginary data z 0 = 000. If z\u0303 is inputted to the syndrome\nformer H\u03032T (D), then the time-reversed syndrome sequence\n\u03b6\u0303 = \u03b6 5 \u03b6 4 \u03b6 3 \u03b6 2 \u03b6 1 = 00 10 01 10 01 is obtained. The\n\n\ft=0\n000\n\nt=1\n\nt=2\n\n(00)\n001\n\n(01)\n011\n\n010\n\n100\n\nt=5\n\n101\n\n011\n\n110\n\n000\n\n110\n\n000\n\n111\n\n001\n\n111\n\n001\n\n000\n\n110\n\n000\n\n110\n\n001\n\n111\n\n100\n\n010\n111\n\n011\n\n(1) (2)\n5\n5\n\n\u03b6 \u03b6 =00\n\n(1) (2)\n4\n4\n\n\u03b6 \u03b6 =10\n\nFig. 2.\n\n(1) (2)\n3\n3\n\n\u03b6 \u03b6 =01\n\n100\n\n011\n(1) (2)\n2\n2\n\n\u03b6 \u03b6 =10\n\nI2\nI10\nI19\n\nI4\nI20\nI7\n\nI8\nI9\nI14\n\n\uf8f6\nI16\nI18 \uf8f8\nI28\n\n(23)\n\nbe the parity-check matrix of a (155, 64) QC code (m = 31),\nwhere Ix is a 31 \u00d7 31 identity matrix with rows shifted\ncyclically to the left by x positions. From H we obtain the\nfollowing parity-check matrix with polynomial entries:\n\uf8eb\n\uf8f6\nD\nD2 D4 D8 D16\nH(D) = \uf8ed D5 D10 D20 D9 D18 \uf8f8 .\n(24)\nD25 D19 D7 D14 D28\n\n111\n\n001\n\n010\n\n101\n\nFor example [10], let\n\uf8eb\nI1\nH = \uf8ed I5\nI25\n\n010\n\n011\n\n101\n\n110\n\nt=4\n100\n\n010\n\n101\n\n(10)\n\n(11)\n\nt=3\n\n100\n\n101\n(2)\n\u03b6(1)\n1 \u03b61 =01\n\nError-trellis based on H\u03032T (D).\n\ncorresponding error-trellis is shown in Fig.2, where the trellis\nis terminated in state (00), which corresponds to the final\nsyndrome-former state \u03c3\u0303 5 = (00). From Fig.2, we have four\nadmissible error-paths:\n\u1ebdq1\n\n=\n\n001 000 011 010 000\n\n(18)\n\n\u1ebdq2\n\u1ebdq3\n\n=\n=\n\n000 101 101 010 000\n000 100 000 100 000\n\n(19)\n(20)\n\n\u1ebdq4\n\n=\n\n001 001 110 100 000.\n\n(21)\n\nCompare these error-paths with those in Fig.1. We observe\nthat each error-path in Fig.2 (restricted to the section [0, 4]) is\nrepresented in Fig.1 in time-reversed order. That is, the original\nerror-paths can be represented using the error-trellis associated\nwith the corresponding reciprocal dual encoder.\nOn the other hand, dividing the third column of H\u03032 (D) by\nD, we have the reduced canonical parity-check matrix\n\u0012\n\u0013\n\u25b3\n1\n0\n1\n\u2032\nH\u03032 (D) =\n.\n(22)\nD 1+D 0\nIn this case [1], [8], error-paths associated with H\u03032T (D) can\nbe represented using the error-trellis constructed based on\n\u2032\nH\u03032T (D). Note that a factor Dl in the column of H\u0303(D)\ncorresponds to backward-shifting by l time units (i.e., D\u2212l )\nin terms of the original H(D). This observation implies that\nerror-trellis state-space reduction can be equally accomplished\nusing backward-shifted error subsequences.\nIII. QC C ODES AND C ORRESPONDING LDPC\nC ONVOLUTIONAL C ODES\nA. LDPC Convolutional Codes Based on Circulant Matrices\nEach circulant in the parity-check matrix of a QC block code\ncan be specified by a unique polynomial; the polynomial represents the entries in the first column of the circulant matrix. For\nexample, a circulant matrix whose first column is [1 1 1 0 1 0]T\nis represented by the polynomial 1 + D + D2 + D4 . Using this\ncorrespondence, an LDPC convolutional code is constructed\nbased on a parity-check matrix H of a given QC code [10].\n\n(Remark: It is stated [10] that the LDPC convolutional code\nis obtained by unwrapping the constraint graph (i.e., Tanner\ngraph) of the QC code.) Note that the polynomials in H(D)\nare all monomials. In this paper, we discuss exclusively\nusing this specific example. However, the argument is entirely\ngeneral.\nB. Reordering Rows of H and the Corresponding H(D)\nAgain, consider the parity-check matrix H of the (155, 64)\nQC code. Let us cyclically shift the first block of m = 31\nrows above by one position, the middle block of 31 rows by\nfive positions, and the last block of 31 rows by 25 positions.\nThe resulting matrix is given by\n\uf8f6\n\uf8eb\nI0 I1 I3 I7 I15\nH \u2032 = \uf8ed I0 I5 I15 I4 I13 \uf8f8 .\n(25)\nI0 I25 I13 I20 I3\nClearly, the QC block code and its associated constraint graph\nare unaffected by these row shifts. However, the convolutional\ncode obtained based on the above procedure has the paritycheck matrix\n\uf8eb\n\uf8f6\n1 D\nD3 D7 D15\nH \u2032 (D) = \uf8ed 1 D5 D15 D4 D13 \uf8f8 .\n(26)\n1 D25 D13 D20 D3\n\nWe see that H \u2032 (D) is not equivalent to H(D). Two convolutional codes specified by H(D) and H \u2032 (D) are in fact\ndifferent. We also remark that H(D) and H \u2032 (D) have different\nmonomial entries and accordingly, when row/column factors\nare factored out, the resulting matrices have different OCLs.\nOn the other hand, we have the following important fact\n[10]:\nProperty: The LDPC convolutional codes obtained by unwrapping the constraint graph of the QC codes have their free\ndistance df ree lower-bounded by the minimum distance dmin\nof the corresponding QC code.\nIt is shown that the QC code associated with H has a\nminimum distance dmin = 20. Then df ree of the convolutional\ncode C specified by H(D) is lower-bounded by dmin = 20.\n(It is conjectured that C has a free distance df ree of 24 [10].)\nFrom the above property, we also have d\u2032f ree \u2265 dmin = 20,\nwhere d\u2032f ree is the free distance of the convolutional code C \u2032\nspecified by H \u2032 (D). In general, let H \u2032 (D) be the parity-check\nmatrix associated with H \u2032 , where H \u2032 is the parity-check matrix\n\n\fobtained by applying cyclic shifts to the rows of each block\nof the original H. Above observations imply that the OCL of\nH \u2032 (D) can be controlled to some extent with its free distance\nd\u2032f ree being lower-bounded by the minimum distance dmin of\nthe QC code specified by H.\n\n7\n6\nfrequency\n\n5\n4\n3\n2\n\nIV. R EDUCTION\n\nOF\n\nOVERALL C ONSTRAINT L ENGTH\n\n1\n\nA. Row/Column Operations and Their Equivalent Representation\n\nSimilarly, the second and third rows of H(D) are represented\nby\n\uf8f1\n\uf8f1\nR1 = [0 25 13 20 3]\nQ1 = [0 5 15 4 13]\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2 R2 = [6 0 19 26 9]\n\uf8f2 Q2 = [26 0 10 30 8]\nR3 = [18 12 0 7 21]\nQ3 = [16 21 0 20 29] and\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\nR\nQ\n=\n[27\n1\n11\n0\n9]\n\uf8f4\n\uf8f4\n4 = [11 5 24 0 14]\n4\n\uf8f4\n\uf8f4\n\uf8f3\n\uf8f3\nR5 = [28 22 10 17 0],\nQ5 = [18 23 2 22 0]\n(28)\nrespectively. Hence, when we apply cyclic shifts to the rows\nof each block of the original H, the resulting H(D) can be\nspecified by a pattern [Pi , Qj , Rk ]T . For example, consider the\npattern [P1 , Q1 , R3 ]T . The corresponding H(D) (cf. Eq.(24))\nis given by\n\uf8eb\n\uf8f6\n1\nD\nD3 D7 D15\nH(D) = \uf8ed 1\nD5 D15 D4 D13 \uf8f8 .\n(29)\n18\nD\nD12\n1\nD7 D21\nSince row operations have been done, let\noperations. Then we have\n\uf8eb\n1\n1\nD3 D3\n\u2032\n4\n\uf8ed\n1\nD\nD15 1\nH (D) =\n18\n11\nD\nD\n1\nD3\nWe see that this is equivalent to the\n\uf8eb\n0 1 3\nS = \uf8ed 0 5 15\n18 12 0\n\nus apply column\n\uf8f6\nD2\n1 \uf8f8.\nD8\n\n(30)\n\ntransformation from\n\uf8f6\n7 15\n4 13 \uf8f8\n(31)\n7 21\n\n30\n\n35\n\n40\n\n45\n\n50\n\n55\n\n60\n\n65\n\n70\n\n75\n\n80\n\n85\n\n90\n\noverall constraint length (\u03bc)\n\nFig. 3.\n\nOverall constraint length of a reduced H \u2032 (D).\n\n7\n6\n5\nfrequency\n\nAgain, take the parity-check matrix H given by Eq.(23).\nHere, let us cyclically shift the first block of 31 rows above\nby one position. Then the first block [I1 I2 I4 I8 I16 ] changes\nto [I0 I1 I3 I7 I15 ]. That is, the subscript number of each\nentry decreases by 1. According to this change in H, the\nfirst row of H(D) changes from [D D2 D4 D8 D16 ] to\n[1 D D3 D7 D15 ]. In terms of the power of D, this change\nis expressed as [1 2 4 8 16] \u2192 [0 1 3 7 15]. In general, we\nobserve that each entry decreases by one (modulo 31) when\nwe cyclically shift the rows above by one position. Continuing\nthis procedure (Remark: it is assumed that row operations have\nbeen done), we see that the first row of H(D) corresponds to\none of the following five patterns in terms of the power of D:\n\uf8f1\nP1 = [0 1 3 7 15]\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2 P2 = [30 0 2 6 14]\nP3 = [28 29 0 4 12]\n(27)\n\uf8f4\n\uf8f4\nP\n=\n[24\n25\n27\n0\n8]\n\uf8f4\n4\n\uf8f4\n\uf8f3\nP5 = [16 17 19 23 0].\n\n0\n\n4\n3\n2\n1\n0\n\n\u0001\n\n\u0002\u0003\n\n\u0004\u0005\n\n\u0006\u0007\n\n\b\n\n\u000e\u000f\n\n\u0010\u0011\n\n\u0012\u0013\n\n\u0014\u0015\n\n\u0016\u0017\n\n\u0018\u0019\n\noverall constraint length (\u03b7)\n\nFig. 4.\n\nto\n\nOverall constraint length of a reduced H\u0303 \u2032 (D).\n\n\uf8eb\n\n0 0 3 3\nS \u2032 = \uf8ed 0 4 15 0\n18 11 0 3\n\n\uf8f6\n2\n0 \uf8f8,\n8\n\n(32)\n\nwhere subtraction is performed in each column of S in order\nthat the minimum is equal to zero. From S \u2032 , the OCL of the\nreduced H \u2032 (D) is obtained as 3 + 15 + 18 = 36.\nB. Reduction of Overall Constraint Length: Search Results\nAs we have seen in the previous section, there are 5 \u00d7 5 \u00d7\n5 = 125 patterns in total. By applying column operations to\neach pattern, we examined the OCL \u03bc of the corresponding\nreduced parity-check matrix H \u2032 (D). The result is shown in\nFig.3, where the horizontal axis represents the OCL \u03bc and\nthe vertical axis represents its frequency. Observe that the\nminimum OCL \u03bcmin is 35, whereas the maximum OCL \u03bcmax\nis 83. That is, the values of \u03bc cover a wide range. Next,\nbased on the argument in Section II-B, we examined the OCL\n\u03b7 using the reciprocal dual encoder H\u0303(D) associated with\nH(D). The result is shown in Fig.4. We have \u03b7min = 31 and\n\u03b7max = 85. Note that in this example, the minimum OCL\nis further reduced using a reciprocal dual encoder. Moreover,\nafter having applied row/column operations to each H(D)\n(denote by H \u2032 (D) the resulting matrix), we took its reciprocal\nf\u2032 (D). Then again applying row/column operations\nversion H\nf\u2032 (D), we examined the OCL \u03bc\u2032 of the resulting matrix.\nto H\nUsing this method, we have further reduction with respect to\n\n\fadditional memory reduction (\u0394\u03bc)\n\nV. C ONCLUSION\n\n18\n16\n14\n12\n10\n8\n6\n4\n2\n0\n1\n\n11\n\n21\n\n31\n\n41\n\n51\n\n61\n\n71\n\n81\n\n91 101 111 121\n\npattern No.\n\nFig. 5.\n\nAdditional overall-constraint-length reduction.\n\nthe value of \u03bc. The result is shown in Fig.5. We observe that\nthe maximum reduction \u2206\u03bc(= \u03bc \u2212 \u03bc\u2032 \u2265 0) of 16 is realized.\nWe remark that \u03bcmin = 35 is reduced to \u03bc\u2032 = 34 using this\nmethod.\nC. Efficient Search Method\nOur aim is the reduction of the OCL of a parity-check matrix\nH(D). Since row operations have been done in a pattern\n[Pi , Qj , Rk ]T , it is desirable for figures in each column to be\nclose together (i.e., the difference \u03b4j between the maximum\nand the minimum in the jth column is small). In this case,\neach figure in the column becomes small after the column\noperation, which finally leads to the reduction of the OCL.\nHence, we search for a pattern in which every column has\n\u03b4j \u2264 \u2206, where \u2206 is a predetermined search parameter.\nFor example, set \u2206 = 20. Consider the pattern\n[P2 , Q4 , R3 ]T :\n\uf8eb\n\uf8f6\n30 0 2 6 14\nS1 = \uf8ed 27 1 11 0 9 \uf8f8 .\n(33)\n18 12 0 7 21\n\u03b4j are given by 12, 12, 11, 7, and 12, respectively and remain\nwithin \u2206 = 20. Applying column operations, we have\n\uf8eb\n\uf8f6\n12 0 2 6 5\nS1\u2032 = \uf8ed 9 1 11 0 0 \uf8f8 .\n(34)\n0 12 0 7 12\nThe OCL is given by 12 + 11 + 12 = 35.\nSimilarly, consider the pattern [P5 , Q5 , R5 ]T :\n\uf8eb\n\uf8f6\n16 17 19 23 0\nS2 = \uf8ed 18 23 2 22 0 \uf8f8 .\n28 22 10 17 0\nIn this case, \u03b4j are given by 12, 6, 17,\nApplying column operations, we have\n\uf8eb\n0 0 17 6\nS2\u2032 = \uf8ed 2 6 0 5\n12 5 8 0\n\n(35)\n\n6, and 0, respectively.\n\uf8f6\n0\n0 \uf8f8.\n0\n\n(36)\n\nAgain, the OCL is given by 17 + 6 + 12 = 35. Observe that\nthese patterns have \u03bcmin = 35.\n\nIn this paper, we examined the state-space complexity of the\nerror-trellis of an LDPC convolutional code derived from the\nQC block code specified by a parity-check matrix H. Since the\nentries in the corresponding parity-check matrix H(D) are all\nmonomials, we can construct a reduced error-trellis using the\nmethod of [1] or that of [8]. We noticed that when cyclic shifts\nare applied to the rows of H, the QC code remains unchanged,\nwhereas the corresponding parity-check matrix H \u2032 (D), which\ndefines another convolutional code, has row/column factors\ndifferent from those in the original H(D). That is, the OCL\nof H \u2032\u2032 (D), where H \u2032\u2032 (D) is the matrix obtained by factoring\nout row/column factors in H \u2032 (D), varies depending on the row\nshifts applied to H. On the other hand, the free distance of\nthe resulting convolutional code is still lower-bounded by the\nminimum distance of the original QC code. These facts imply\nthat the state-space complexity of the error-trellis associated\nwith H \u2032 (D) can be controlled to some extent with the errorcorrection capability being preserved and this is our basic idea.\nBy applying our method to the example in [10], we have\nshown that the OCL of the parity-check matrix of an LDPC\nconvolutional code can be significantly reduced compared to\nthe average one. The LDPC convolutional codes proposed\nby Tanner et al. have large constraint lengths. Therefore, it\nis stated [10] that the use of trellis-based decoding is not\nfeasible. We basically agree on this point. However, it has\nbeen shown that an error-trellis with much lower state-space\ncomplexity than we imagined can be constructed, which gives\nsome prospect of trellis-based decoding.\nACKNOWLEDGMENT\nThis work was supported in part by the Japan Society for\nthe Promotion of Science, under Grant-in-Aid No. 19500011.\nR EFERENCES\n[1] M. Ariel and J. Snyders, \"Error-trellises for convolutional codes\u2013Part I:\nConstruction,\" IEEE Trans. Commun., vol. 46, no. 12, pp. 1592\u20131601,\nDec. 1998.\n[2] G. D. Forney, Jr., \"Convolutional codes I: Algebraic structure,\" IEEE\nTrans. Inform. Theory, vol. IT-16, no. 6, pp. 720\u2013738, Nov. 1970.\n, \"Structural analysis of convolutional codes via dual codes,\"\n[3]\nIEEE Trans. Inform. Theory, vol. IT-19, no. 4, pp. 512\u2013518, July 1973.\n[4] R. Johannesson and K. S. Zigangirov, Fundamentals of Convolutional\nCoding. New York : IEEE Press, 1999.\n[5] R. J. McEliece and W. Lin, \"The trellis complexity of convolutional\ncodes,\" IEEE Trans. Inform. Theory, vol. 42, no. 6, pp. 1855\u20131864,\nNov. 1996.\n[6] J. P. M. Schalkwijk and A. J. Vinck, \"Syndrome decoding of convolutional codes,\" IEEE Trans. Commun., vol. COM-23, pp. 789\u2013792, July\n1975.\n[7] V. Sidorenko and V. Zyablov, \"Decoding of convolutional codes using a\nsyndrome trellis,\" IEEE Trans. Inform. Theory, vol. 40, no. 5, pp. 1663\u2013\n1666, Sept. 1994.\n[8] M. Tajima, K. Okino, and T. Miyagoshi, \"Error-trellis construction\nfor convolutional codes using shifted error-subsequences,\" in Proc.\nSITA2005, pp. 773\u2013776, Nov. 2005 (in Japanese).\n, \"Error-trellis construction for convolutional codes using shifted\n[9]\nsyndrome-subsequences,\" in Proc. SITA2006, pp. 295\u2013298, Nov. 2006\n(in Japanese).\n[10] R. M. Tanner, D. Sridhara, A. Sridharan, T. E. Fuja, and D. J. Costello,\nJr., \"LDPC block and convolutional codes based on circulant matrices,\"\nIEEE Trans. Inform. Theory, vol. 50, no. 12, pp. 2966\u20132984, Dec. 2004.\n\n\f"}