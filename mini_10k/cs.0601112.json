{"id": "http://arxiv.org/abs/cs/0601112v1", "guidislink": true, "updated": "2006-01-26T10:38:11Z", "updated_parsed": [2006, 1, 26, 10, 38, 11, 3, 26, 0], "published": "2006-01-26T10:38:11Z", "published_parsed": [2006, 1, 26, 10, 38, 11, 3, 26, 0], "title": "Complexity of the Guarded Two-Variable Fragment with Counting\n  Quantifiers", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0408004%2Ccs%2F0408026%2Ccs%2F0408013%2Ccs%2F0408066%2Ccs%2F0408003%2Ccs%2F0408025%2Ccs%2F0408014%2Ccs%2F0408015%2Ccs%2F0408042%2Ccs%2F0408010%2Ccs%2F0408028%2Ccs%2F0408033%2Ccs%2F0408020%2Ccs%2F0408034%2Ccs%2F0408049%2Ccs%2F0408062%2Ccs%2F0408045%2Ccs%2F0408016%2Ccs%2F0408057%2Ccs%2F0408030%2Ccs%2F0408053%2Ccs%2F0408056%2Ccs%2F0408063%2Ccs%2F0408027%2Ccs%2F0408017%2Ccs%2F0408051%2Ccs%2F0408069%2Ccs%2F0408002%2Ccs%2F0408052%2Ccs%2F0408047%2Ccs%2F0408061%2Ccs%2F0408039%2Ccs%2F0408041%2Ccs%2F0408006%2Ccs%2F0408021%2Ccs%2F0408038%2Ccs%2F0408005%2Ccs%2F0408024%2Ccs%2F0408068%2Ccs%2F0408040%2Ccs%2F0408055%2Ccs%2F0408060%2Ccs%2F0408050%2Ccs%2F0408043%2Ccs%2F0408022%2Ccs%2F0408054%2Ccs%2F0408064%2Ccs%2F0408044%2Ccs%2F0408048%2Ccs%2F0408065%2Ccs%2F0408012%2Ccs%2F0408009%2Ccs%2F0408046%2Ccs%2F0408058%2Ccs%2F0408059%2Ccs%2F0408008%2Ccs%2F0408023%2Ccs%2F0408032%2Ccs%2F0408029%2Ccs%2F0601004%2Ccs%2F0601011%2Ccs%2F0601093%2Ccs%2F0601119%2Ccs%2F0601116%2Ccs%2F0601040%2Ccs%2F0601060%2Ccs%2F0601058%2Ccs%2F0601103%2Ccs%2F0601129%2Ccs%2F0601069%2Ccs%2F0601067%2Ccs%2F0601021%2Ccs%2F0601018%2Ccs%2F0601092%2Ccs%2F0601044%2Ccs%2F0601012%2Ccs%2F0601079%2Ccs%2F0601128%2Ccs%2F0601074%2Ccs%2F0601045%2Ccs%2F0601020%2Ccs%2F0601015%2Ccs%2F0601072%2Ccs%2F0601130%2Ccs%2F0601010%2Ccs%2F0601026%2Ccs%2F0601088%2Ccs%2F0601095%2Ccs%2F0601003%2Ccs%2F0601087%2Ccs%2F0601075%2Ccs%2F0601096%2Ccs%2F0601023%2Ccs%2F0601099%2Ccs%2F0601112%2Ccs%2F0601101%2Ccs%2F0601076%2Ccs%2F0601085%2Ccs%2F0601084%2Ccs%2F0601051%2Ccs%2F0601025&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Complexity of the Guarded Two-Variable Fragment with Counting\n  Quantifiers"}, "summary": "We show that the finite satisfiability problem for the guarded two-variable\nfragment with counting quantifiers is in EXPTIME. The method employed also\nyields a simple proof of a result recently obtained by Y. Kazakov, that the\nsatisfiability problem for the guarded two-variable fragment with counting\nquantifiers is in EXPTIME.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0408004%2Ccs%2F0408026%2Ccs%2F0408013%2Ccs%2F0408066%2Ccs%2F0408003%2Ccs%2F0408025%2Ccs%2F0408014%2Ccs%2F0408015%2Ccs%2F0408042%2Ccs%2F0408010%2Ccs%2F0408028%2Ccs%2F0408033%2Ccs%2F0408020%2Ccs%2F0408034%2Ccs%2F0408049%2Ccs%2F0408062%2Ccs%2F0408045%2Ccs%2F0408016%2Ccs%2F0408057%2Ccs%2F0408030%2Ccs%2F0408053%2Ccs%2F0408056%2Ccs%2F0408063%2Ccs%2F0408027%2Ccs%2F0408017%2Ccs%2F0408051%2Ccs%2F0408069%2Ccs%2F0408002%2Ccs%2F0408052%2Ccs%2F0408047%2Ccs%2F0408061%2Ccs%2F0408039%2Ccs%2F0408041%2Ccs%2F0408006%2Ccs%2F0408021%2Ccs%2F0408038%2Ccs%2F0408005%2Ccs%2F0408024%2Ccs%2F0408068%2Ccs%2F0408040%2Ccs%2F0408055%2Ccs%2F0408060%2Ccs%2F0408050%2Ccs%2F0408043%2Ccs%2F0408022%2Ccs%2F0408054%2Ccs%2F0408064%2Ccs%2F0408044%2Ccs%2F0408048%2Ccs%2F0408065%2Ccs%2F0408012%2Ccs%2F0408009%2Ccs%2F0408046%2Ccs%2F0408058%2Ccs%2F0408059%2Ccs%2F0408008%2Ccs%2F0408023%2Ccs%2F0408032%2Ccs%2F0408029%2Ccs%2F0601004%2Ccs%2F0601011%2Ccs%2F0601093%2Ccs%2F0601119%2Ccs%2F0601116%2Ccs%2F0601040%2Ccs%2F0601060%2Ccs%2F0601058%2Ccs%2F0601103%2Ccs%2F0601129%2Ccs%2F0601069%2Ccs%2F0601067%2Ccs%2F0601021%2Ccs%2F0601018%2Ccs%2F0601092%2Ccs%2F0601044%2Ccs%2F0601012%2Ccs%2F0601079%2Ccs%2F0601128%2Ccs%2F0601074%2Ccs%2F0601045%2Ccs%2F0601020%2Ccs%2F0601015%2Ccs%2F0601072%2Ccs%2F0601130%2Ccs%2F0601010%2Ccs%2F0601026%2Ccs%2F0601088%2Ccs%2F0601095%2Ccs%2F0601003%2Ccs%2F0601087%2Ccs%2F0601075%2Ccs%2F0601096%2Ccs%2F0601023%2Ccs%2F0601099%2Ccs%2F0601112%2Ccs%2F0601101%2Ccs%2F0601076%2Ccs%2F0601085%2Ccs%2F0601084%2Ccs%2F0601051%2Ccs%2F0601025&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We show that the finite satisfiability problem for the guarded two-variable\nfragment with counting quantifiers is in EXPTIME. The method employed also\nyields a simple proof of a result recently obtained by Y. Kazakov, that the\nsatisfiability problem for the guarded two-variable fragment with counting\nquantifiers is in EXPTIME."}, "authors": ["Ian Pratt-Hartmann"], "author_detail": {"name": "Ian Pratt-Hartmann"}, "author": "Ian Pratt-Hartmann", "arxiv_comment": "20 pages, 3 figures", "links": [{"href": "http://arxiv.org/abs/cs/0601112v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0601112v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0601112v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0601112v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:cs/0601112v1 [cs.LO] 26 Jan 2006\n\nComplexity of the Guarded Two-Variable\nFragment with Counting Quantifiers\nIan Pratt-Hartmann\nSchool of Computer Science\nManchester University\nAbstract\nWe show that the finite satisfiability problem for the guarded twovariable fragment with counting quantifiers is in EXPTIME. The method\nemployed also yields a simple proof of the result obtained in Kazakov [6],\nthat the satisfiability problem for the guarded two-variable fragment with\ncounting quantifiers is in EXPTIME.\n\n1\n\nIntroduction\n\nThe two-variable fragment with counting quantifiers, here denoted C 2 , is the set\nof function-free, first-order formulas containing at most two variables, but with\nthe counting quantifiers \u2203\u2264C , \u2203\u2265C and \u2203=C (for every C > 0) allowed. The\nguarded two-variable fragment with counting quantifiers, here denoted GC 2 , is\nthe subset of C 2 whose formulas contain no individual constants, and where all\nquantifiers appear only in guarded patterns (explained below). Both C 2 and GC 2\nare assumed to contain equality. Neither fragment has the finite model property,\nso that their respective satisfiability problems and finite satisfiability problems\ndo not coincide. It was shown in Pratt-Hartmann [11] that the satisfiability\nand finite satisfiability problems for C 2 are both in NEXPTIME. It was shown\nin Kazakov [6] that the satisfiability problem for GC 2 is in EXPTIME; however\nthe method employed in that paper yields no information about the finite satisfiability problem for GC 2 . In this paper, we show that the finite satisfiability\nproblem for GC 2 is in EXPTIME; furthermore, the method employed here also\nyields a simple proof of Kazakov's result. All complexity results mentioned in\nthis paper assume succinct (binary) coding of numerical quantifier subscripts.\nThe fragment GC 2 is a proper superset of the \"description logic\" ALCQI\n(Calvanese [2]), which in turn is a proper superset of the description logic ALC\nwith general concept inclusion (essentially, multimodal K with universal quantification of formulas). This latter fragment has the finite model property, and\nits satisfiability problem (= finite satisfiability problem) is EXPTIME-hard.\nHence, the complexity bounds reported here for GC 2 are tight. Furthermore, it\nwas shown in Lutz et al. [8, 9] that the finite satisfiability problem for ALCQI\n1\n\n\f2 PRELIMINARIES\n\n2\n\nis in EXPTIME. The present paper thus extends that result to the whole of\nGC 2 .\nBy contrast, GC 2 is a proper subset of C 2 , whose satisfiability and finite\nsatisfiability problems are NEXPTIME-hard. In fact, even the 2-variable fragment of first-order logic without counting quantifiers, which has the finite model\nproperty, exhibits a NEXPTIME-hard satisfiability problem, as can be shown\nby using its formulas to encode exponentially large grids (see, e.g. B\u00f6rger et\nal. [1], pp. 253 ff.). In such encodings, the quantifiers (\u2200 and \u2203) appear in unguarded patterns. On the other hand, in the presence of counting quantifiers,\na similar encoding is possible using only guarded quantification, provided that\njust one individual constant is admitted to the language. Thus, both the lack\nof individual constants and the restriction to guarded patterns of quantification\nare essential to the comparatively low complexity of GC 2 (assuming, of course,\nthat EXPTIME 6= NEXPTIME).\nIt was shown in Pratt-Hartmann [11], Corollary 1 that, if a formula \u03c6 of\nC 2 is finitely satisfiable, then it has a model whose size is bounded by a doubly\nexponential function of the number of symbols in \u03c6. This bound is optimal, even\nfor the fragment GC 2 , in the sense that there exists a sequence {\u03c6i } of finitely\nsatisfiable formulas of GC 2 \u2286 C 2 whose size grows as a polynomial function of i,\nbut whose smallest satisfying structures grow as a doubly exponential function of\ni (Gr\u00e4del et al. [5], p. 317). In view of this lower bound on the sizes of smallest\nsatisfying structures, the upper complexity bound on the finite satisfiability\nproblem for GC 2 proved here is noteworthy.\nThe plan of this paper is as follows. Section 2 defines the fragment GC 2 and\nestablishes some basic results. Section 3 describes a procedure for transforming\nany GC 2 -formula into an (exponentially large) constraint satisfaction problem\nwith variables ranging over N. Section 4 uses this transformation to prove that\nthe finite satisfiability problem for GC 2 is in EXPTIME. Section 5 is dessert.\n\n2\n\nPreliminaries\n\nWe restrict consideration to first-order languages whose only primitive symbols\nare the variables x and y, the usual Boolean connectives, the quantifiers \u2200, \u2203,\n\u2203\u2264C , \u2203\u2265C , \u2203=C (for all C > 0), the equality predicate (here written as \u2248)\nand a non-logical signature of 0-ary, unary and binary predicates. There are\nno individual constants or function-symbols in these languages. If p is any\nbinary predicate (including \u2248), we call an atomic formula having either of the\nforms p(x, y) or p(y, x) a guard-atom. The two-variable guarded fragment with\ncounting quantifiers, GC 2 , can then be defined as the smallest set of formulas\nsatisfying the following conditions:\n1. GC 2 contains all atomic formulas and is closed under Boolean combinations;\n2. if \u03c6 is a formula of GC 2 with at most one free variable, and u is a variable\n(i.e. either x or y), then the formulas \u2200u\u03c6 and \u2203u\u03c6 are in GC 2 ;\n\n\f3\n\n2 PRELIMINARIES\n\n3. if \u03c6 is a formula of GC 2 , \u03b3 a guard-atom, u a variable, and Q any of the\nquantifiers \u2203, \u2203\u2264C , \u2203\u2265C , \u2203=C (for C > 0), then the formulas \u2200u(\u03b3 \u2192 \u03c6)\nand Qu(\u03b3 \u2227 \u03c6) are in GC 2 .\nWe take the semantics to be the usual semantics of first-order logic, with counting quantifiers interpreted in the obvious way. If \u03c6 is any formula of GC 2 , we\ndenote the number of symbols in \u03c6 by k\u03c6k, assuming binary coding of numerical\nquantifier subscripts.\nAccording to the above syntax, the non-counting quantifiers \u2203 and \u2200 may\napply without restriction to formulas with at most one free variable; however,\nthey may apply to formulas with two free variables only in the presence of a\nguard-atom. By contrast, the counting quantifiers \u2203\u2264C , \u2203\u2265C , \u2203=C may only\nevery apply in the presence of a guard atom (which by definition has two free\nvariables). Note in particular that the formula \u2203=1 xp(x) is not in GC 2 . In fact,\nthe next lemma shows that no formula of GC 2 can force a predicate p to be\nuniquely instantiated in its models.\nDefinition 1. Let A, B be structures over disjoint domains A, B, respectively,\ninterpreting a common signature \u03a3 with no individual constants. The union\nA \u222a B of A and B is the structure with domain A \u222a B and interpretations\n\u03c3 A\u222aB = \u03c3 A \u222a \u03c3 B for every \u03c3 \u2208 \u03a3.\nLemma 1. Let \u03c6 be a formula of GC 2 and A a structure over the signature of\n\u03c6. For N \u2265 1, let N * A denote the union of N disjoint copies of A. If \u03c6 is\nsatisfied in A, then it is satisfied in N * A.\nProof. If \u03b8 : {x, y} \u2192 A is any variable assignment over A and 1 \u2264 i \u2264 N , let \u03b8i\nbe the variable assignment over N * A which maps x and y to the corresponding\nelements in the ith copy of A. A routine structural induction on \u03c6 shows that\nA |=\u03b8 \u03c6 if and only if, for some (= for all) i (1 \u2264 i \u2264 N ), N * A |=\u03b8i \u03c6.\nIt follows immediately from Lemma 1 that, if a formula of GC 2 has a finite\nmodel, then it has arbitrarily large finite models, and indeed infinite models.\nThe following lemma, which is a cosmetic modification of Kazakov [6],\nLemma 2, establishes a normal form for GC 2 -formulas.\nLemma 2. Let \u03c8 be a formula in GC 2 . We can construct, in time bounded by\na polynomial function of k\u03c8k, a formula\n^\n\u03c6 := \u2200x\u03b1 \u2227\n\u2200x\u2200y(eh (x, y) \u2192 (\u03b2h \u2228 x \u2248 y))\u2227\n1\u2264h\u2264l\n\n^\n\n\u2200x\u2203=Ci y(fi (x, y) \u2227 x 6\u2248 y)\n\n(1)\n\n1\u2264i\u2264m\n\nsuch that: (i) \u03b1 is a quantifier-free formula not involving \u2248 with x as its only\nvariable; (ii) l and m are positive integers; (iii) for all h (1 \u2264 h \u2264 l), eh is a\nbinary predicate other than \u2248, and \u03b2h is a quantifier-free formula not involving\n\u2248 with x and y as its only variables; (iv) for all i (1 \u2264 i \u2264 m), Ci is a positive\n\n\f2 PRELIMINARIES\n\n4\n\ninteger, and fi is a binary predicate other than \u2248; (v) \u03c6 is satisfiable if and\nonly if \u03c8 is satisfiable; (vi) \u03c6 is finitely satisfiable if and only if \u03c8 is finitely\nsatisfiable.\nProof. Standard transformation to Scott normal form, using Lemma 1. See\nKazakov op. cit. for details.\nHence, to show that the (finite) satisfiability problem for GC 2 is in EXPTIME, it suffices to consider only formulas of the form (1). Furthermore, we\nmay assume without loss of generality that no 0-ary predicates (proposition letters) occur in \u03c6, since we can consider each of the (at most 2k\u03c6k ) truth-value\nassignments to the 0-ary predicates of \u03c6 in turn, replacing each 0-ary predicate\nwith \u22a4 or \u22a5 according to its truth-value in the considered assignment.\nAccordingly, fix \u03c6 to be some formula of the form (1) over a signature of\nunary and binary predicates. Set C = max1\u2264i\u2264m Ci , and let \u03a3 be the signature\nof \u03c6 together with log((mC)2 + 1) (rounded up) new unary predicates. Thus,\n|\u03a3| is bounded by a polynomial (actually, linear) function of k\u03c6k. Since \u03a3 is the\nonly signature we shall be concerned with in the sequel, we generally suppress\nreference to it. Thus, 'predicate' henceforth means 'predicate in \u03a3 \u222a {\u2248}',\n'structure' henceforth means 'structure interpreting \u03a3', and so on. We keep the\nmeanings of the symbols \u03b1, l, m, eh , \u03b2h , (1 \u2264 h \u2264 l), Ci , fi (1 \u2264 i \u2264 l), \u03c6, C,\n\u03a3 fixed throughout this paper. The predicates f1 , . . . , fm will play a key role\nin the ensuing argument; we refer to them as the counting predicates. There is\nno restriction on these predicates' occurring in other parts of \u03c6: in particular,\nthey may feature as guards.\nWe review some standard concepts. A literal is an atomic formula or the\nnegation of an atomic formula. A 1-type is a maximal consistent set of equalityfree literals involving only the variable x. A 2-type is a maximal consistent set of\nequality-free literals involving only the variables x and y. If \u03c4 is a 2-type, then\nthe result of transposing the variables x and y in \u03c4 will also be a 2-type, denoted\n\u03c4 \u22121 . If A is any structure, and a \u2208 A, then there exists a unique 1-type \u03c0(x)\nsuch that A |= \u03c0[a]; we denote \u03c0 by tpA [a]. If, in addition, b \u2208 A is distinct from\na, then there exists a unique 2-type \u03c4 (x, y) such that A |= \u03c4 [a, b]; we denote \u03c4\nby tpA [a, b]. We do not define tpA [a, b] if a = b.\nNotation 1. Any 2-type \u03c4 includes a unique 1-type, denoted tp1 (\u03c4 ); in addition, we write tp2 (\u03c4 ) for tp1 (\u03c4 \u22121 ).\nRemark 1. Let A be a structure, and let a, b be distinct elements of A. If\ntpA [a, b] = \u03c4 , then tpA [b, a] = \u03c4 \u22121 , tpA [a] = tp1 (\u03c4 ), and tpA [b] = tp2 (\u03c4 ).\nDefinition 2. Let \u03c4 be a 2-type. We say that \u03c4 is a message-type if, for some\ncounting predicate fi (1 \u2264 i \u2264 m), fi (x, y) \u2208 \u03c4 . If \u03c4 is a message-type such\nthat \u03c4 \u22121 is also a message-type, we say that \u03c4 is invertible; otherwise, \u03c4 is noninvertible. Finally, if \u03c4 is a 2-type such that neither \u03c4 nor \u03c4 \u22121 is a message-type,\nwe say that \u03c4 is silent.\n\n\f5\n\n2 PRELIMINARIES\n\nRemark 2. Let A be a structure, and let a, b be distinct elements of A. Then\ntpA [a, b] is a message-type just in case A |= fi [a, b] for some i (1 \u2264 i \u2264 m);\nif so, then this message-type is invertible just in case A |= fi\u2032 [b, a] for some i\u2032\n(1 \u2264 i\u2032 \u2264 m).\nThe terminology is meant to suggest the following imagery. If tpA [a, b] is a\nmessage-type \u03bc, then we may imagine that a sends a message (of type \u03bc) to b.\nIf \u03bc is invertible, then b replies by sending a message (of type \u03bc\u22121 ) back to a.\nIf tpA [a, b] is silent, then neither element sends a message to the other.\nDefinition 3. Let A be a structure. We say that A is chromatic if distinct\nelements connected by a chain of 1 or 2 invertible message-types have distinct\n1-types. That is, A is chromatic just in case, for all a, a\u2032 , a\u2032\u2032 \u2208 A:\n1. if a 6= a\u2032 and tpA [a, a\u2032 ] is an invertible message-type, then tpA [a] 6= tpA [a\u2032 ];\nand\n2. if a, a\u2032 , a\u2032\u2032 are pairwise distinct and both tpA [a, a\u2032 ] and tpA [a\u2032 , a\u2032\u2032 ] are invertible message-types, then tpA [a] 6= tpA [a\u2032\u2032 ].\nLemma 3. If \u03c6 has a model, then it has a chromatic model over the same\ndomain.\nProof. Suppose A |= \u03c6, and consider the (undirected) graph G on A whose\nedges are the pairs of distinct elements connected by a chain of 1 or 2 invertible\nmessage-types. That is, G = (A, E 1 \u222a E 2 ), where\nE 1 ={(a, a\u2032 ) |a 6= a\u2032 and tpA [a, a\u2032 ] is an invertible message-type}\nE 2 ={(a, a\u2032\u2032 ) | a 6= a\u2032\u2032 and for some a\u2032 \u2208 A, (a, a\u2032 ) and (a\u2032 , a\u2032\u2032 ) are\nboth in E 1 }.\nSince C = max1\u2264i\u2264m Ci , the degree of G (in the normal graph-theoretic sense)\nis at most (mC)2 . Now use the standard (greedy) algorithm to colour the nodes\nof G with (mC)2 + 1 colours in such a way that no edge joins two nodes of the\nsame colour. By interpreting the log((mC)2 + 1) (rounded up) unary predicates\nof \u03a3 not occurring in \u03c6 to encode these colours, we obtain the desired chromatic\nmodel.\nIn the sequel, we shall need to refer to sets of invertible message-types indexed by bit-strings as follows. Let the 1-types be enumerated as\n\u03a0 = \u03c00 , . . . , \u03c0P \u22121 .\nEvidently, P is a power of 2, so p = log P is an integer. (Actually, p = |\u03a3|.)\nNow let s be any bit string (0 \u2264 |s| \u2264 p), and denote the string of length 0 by \u01eb.\nWe inductively define the sub-sequence \u03a0s of \u03a0 by setting \u03a0\u01eb to be the whole\nof \u03a0, and setting \u03a0s0 and \u03a0s1 to be the left and right halves of \u03a0s , respectively.\nFormally:\n\u03a0\u01eb\n\n= \u03c00 , . . . , \u03c0P \u22121 ,\n\n\f6\n\n2 PRELIMINARIES\n\nand if \u03a0s = \u03c0j , . . . , \u03c0k\u22121 , with |s| < p,\n\u03a0s0\n\n=\n\n\u03c0j , . . . , \u03c0 k\u2212j\n\n\u03a0s1\n\n=\n\n\u03c0 k\u2212j +1 , . . . , \u03c0k\u22121 .\n\n2\n\n2\n\nThus, if |s| = p, then \u03a0s is a one-element sequence \u03c0j , where j is the integer\n(0 \u2264 j < P ) encoded by the bit-string s in the usual way. To avoid clumsy\ncircumlocutions, we occasionally equivocate between bit-strings and the integers\nthey encode, thus, for example, writing \u03c0s instead of \u03c0j in this case. But we\nwill only ever write \u03c0s if |s| = p.\nWe may use the sets \u03a0s to define sets of invertible message-types indexed by\nbit-strings as follows. Fix any 1-type \u03c0, and denote by \u039b\u03c0 the set of invertible\nmessage-types \u03bb such that tp1 (\u03bb) = \u03c0. If s is any bit-string such that |s| \u2264 p,\nlet\n\u039b\u03c0,s = {\u03bb \u2208 \u039b\u03c0 | tp2 (\u03bb) \u2208 \u03a0s }.\nThus, the \u039b\u03c0,s are sets of invertible message-types identified purely by their\nterminal 1-types. Except in very special cases, these sets will contain more than\none member, even when |s| = p. However, for chromatic models, we have the\nfollowing important fact.\nLemma 4. If A is chromatic, \u03c0 = tpA [a], and s is a bit-string with |s| = p,\nthen there can be at most one element b \u2208 A \\ {a} such that tpA [a, b] \u2208 \u039b\u03c0,s .\nProof. Any two such elements would be connected by a chain of two invertible\nmessage-types, and would both have the 1-type \u03c0s .\nFinally, we use bit strings to index other sets of 2-types as follows. Again,\nfix any 1-type \u03c0, and consider the set of non-invertible message-types \u03bc such\nthat tp1 (\u03bc) = \u03c0. Let these be enumerated in some way as a sequence\n\u03bc\u03c0,0 , . . . , \u03bc\u03c0,R\u22121 .\nFurthermore, consider the set of silent 2-types \u03bc such that tp1 (\u03bc) = \u03c0. Let\nthese be enumerated in some way as a sequence\n\u03bc\u03c0,R , . . . , \u03bc\u03c0,Q\u22121 .\nThus, the sequence\nM\u03c0 = \u03bc\u03c0,0 , . . . , \u03bc\u03c0,Q\u22121 .\nis a list of precisely those 2-types \u03c4 such that tp1 (\u03c4 ) = \u03c0 and \u03c4 \u22121 is not a\nmessage-type. Evidently, R and Q are independent of the choice of \u03c0; moreover,\nQ is a power of 2, so q = log Q is an integer. (We remark that R is not a power of\n2.) Let t be any bit string (0 \u2264 |t| \u2264 q). We inductively define the sub-sequence\nM\u03c0,t of M\u03c0 by setting M\u03c0,\u01eb to be the whole of M\u03c0 , and setting M\u03c0,t0 and M\u03c0,t1\nto be the left and right halves of M\u03c0,t , respectively. Formally:\nM\u03c0,\u01eb\n\n=\n\n\u03bc\u03c0,0 , . . . , \u03bc\u03c0,Q\u22121 ,\n\n\f3 TRANSFORMATION INTO AN INTEGER CONSTRAINT PROBLEM 7\nand if M\u03c0,t = \u03bc\u03c0,j , . . . , \u03bc\u03c0,k\u22121 , with |t| < q,\nM\u03c0,t0\n\n=\n\n\u03bc\u03c0,j , . . . , \u03bc\u03c0, k\u2212j\n\nM\u03c0,t1\n\n=\n\n\u03bc\u03c0, k\u2212j +1 , . . . , \u03bc\u03c0,k\u22121 .\n\n2\n\n2\n\nThus, if |t| = q, then M\u03c0,t is a one-element sequence \u03bc\u03c0,j , where j is the integer\n(0 \u2264 j < Q) encoded by the bit-string t in the usual way. Again we may for\nconvenience write \u03bc\u03c0,t instead of \u03bc\u03c0,j in this case, but here too we only ever\nwrite \u03bc\u03c0,t if |t| = q.\n\n3\n\nTransformation into an integer constraint\nproblem\n\nHenceforth, vector means \"m-dimensional vector over N\". If u and v are vectors,\nwe write u \u2264 v if every component of u is less than or equal to the corresponding\ncomponent of v; we write u < v if u \u2264 v and u 6= v. Similarly for \u2265 and >.\nThe number of vectors u such that u \u2264 C is bounded by (C + 1)m , and hence\nby an exponential function of k\u03c6k.\nReferring to the formula (1), denote the vector (C1 , . . . , Cm ) by C and the\nvector (0, . . . , 0) by 0. Moreover, given any 2-type \u03c4 , we write C\u03c4 for the vector\n(C\u03c4,1 , . . . , C\u03c4,m ) where, for all i (1 \u2264 i \u2264 m),\n(\n1\nif fi (x, y) \u2208 \u03c4 ,\nC\u03c4,i =\n(2)\n0\notherwise.\nNote that, if \u03c4 is not a message-type-in particular, if \u03c4 is a silent 2-type-we\nhave C\u03c4 = 0.\nLet \u03c4 be any 2-type.V Since \u03c4 is a finite set of formulas with free variables\nx and y, we may write \u03c4 to denote their conjunction. Referring again to the\nformula (1), we say that \u03c4 is forbidden, if the formula\n^\n^\n\u03b1(x) \u2227 \u03b1(y) \u2227\n(eh (x, y) \u2192 \u03b2h ) \u2227\n\u03c4\n(3)\n1\u2264h\u2264l\n\nis unsatisfiable. Thus, if A |= \u03c6 and a, b are distinct elements of A, then tpA [a, b]\ncannot be forbidden. Since (3) is purely Boolean, we can evidently identify the\nforbidden 2-types in time bounded by an exponential function of k\u03c6k.\nIn the sequel, we take \u03c0 to vary over the set of 1-types, \u03bb to vary over the\nset of invertible message-types, s to vary over the set of bit-strings of length at\nmost p, t to vary over the set of bit-strings of length at most q, and u, v and\nw to vary over the set of vectors \u2264 C. (Similarly for their primed counterparts\n\u03c0 \u2032 , \u03bb\u2032 , s\u2032 , t\u2032 , u\u2032 , v\u2032 and w\u2032 .) We refer to these sets as the standard ranges of the\nrespective letters. Occasionally, additional restrictions on these ranges will be\nimposed.\n\n\f3 TRANSFORMATION INTO AN INTEGER CONSTRAINT PROBLEM 8\n\nNow let V be the set whose elements are the following (distinct) symbols,\nwhere the indices \u03bb, \u03c0, s, t, u, v, w vary over their standard ranges:\nx\u03bb ,\n\ny\u03c0,s,u ,\n\u0177\u03c0,s,v,w whenever |s| < p,\n\nz\u03c0,t,u,\n\u1e91\u03c0,t,v,w whenever |t| < q.\n\nThe symbols \u0177\u03c0,s,v,w and \u1e91\u03c0,t,v,w are not defined when |s| = p and |t| = q. The\ncardinality of V is evidently bounded by an exponential function of k\u03c6k. We\nimpose some arbitrary order on V , and refer to its elements as variables. P\nIf U\nis a non-empty set of variables, enumerated, in order,\nas\n{u\n,\n.\n.\n.\n,\nu\n},\nlet\nU\n1\nk\nP\ndenote the term u1 +* * *+uk ; if U is the empty set, let U denote the (constant)\nterm 0. In the sequel, we take a constraint to be an equation or inequality\ninvolving arithmetical terms over V , or a conditional statement formed from\ntwo such inequalities. A solution of a set of constraints over some numerical\ndomain D is simply a function \u03b8 : V \u2192 D under which all the constraints in\nquestion evaluate (in the obvious way) to true.\nWith this notation, let E1 be the following set of constraints involving the\nvariables V , where \u03c0, u, v, w again vary over their standard ranges, and s, t\nvary over bit-strings such that |s| < p and |t| < q:\nz\u03c0,\u01eb,u\n\n= y\u03c0,\u01eb,C\u2212u\nX\n=\n{\u0177\u03c0,s,v\u2032 ,w\u2032 | v\u2032 + w\u2032 = u}\nX\n=\n{\u1e91\u03c0,t,v\u2032 ,w\u2032 | v\u2032 + w\u2032 = u}\nX\n=\n{\u0177\u03c0,s,v,w\u2032 | v + w\u2032 \u2264 C}\nX\n=\n{\u0177\u03c0,s,v\u2032 ,w | v\u2032 + w \u2264 C}\nX\n=\n{\u1e91\u03c0,t,v,w\u2032 | v + w\u2032 \u2264 C}\nX\n=\n{\u1e91\u03c0,t,v\u2032 ,w | v\u2032 + w \u2264 C}\nX\n\u2264\n{y\u03c0\u2032 ,\u01eb,u\u2032 | \u03c0 \u2032 a 1-type, u\u2032 \u2264 C}.\n\ny\u03c0,s,u\nz\u03c0,t,u\ny\u03c0,s0,v\ny\u03c0,s1,w\nz\u03c0,t0,v\nz\u03c0,t1,w\n1\n\n(4)\n(5)\n(6)\n(7)\n(8)\n(9)\n(10)\n(11)\n\nLet E2 consist of the following constraints, where \u03bb, \u03c0 vary over their standard ranges, s, t vary over bit-strings such that |s| = p, |t| = q, and u varies\nover vectors such that 0 < u \u2264 C:\nX\n(12)\ny\u03c0,s,u =\n{x\u03bb\u2032 | \u03bb\u2032 \u2208 \u039b\u03c0,s and C\u03bb\u2032 = u}\nwhenever u is not a scalar multiple of\nC\u03c4 for \u03c4 = \u03bc\u03c0,t\n\nz\u03c0,t,u\n\n=\n\n0\n\nx(\u03bb\u22121 )\n\n=\n\nx\u03bb\n\nx\u03bb\n\n=\n\n0\n\nwhenever tp1 (\u03bb) = tp2 (\u03bb)\n\n(15)\n\nx\u03bb\n\n=\n=\n\n0\n0\n\nwhenever \u03bb is forbidden\nwhenever \u03bc\u03c0,t is forbidden.\n\n(16)\n(17)\n\nz\u03c0,t,u\n\n(13)\n\n(14)\n\n\f4 MAIN RESULT\n\n9\n\nNote that, in (13), \u03c4 = \u03bc\u03c0,t is a 2-type, and the vector C\u03c4 is defined according\nto (2). If the integer encoded by t is less than R, \u03c4 = \u03bc\u03c0,t will be a (noninvertible) message-type, and we will have C\u03c4 > 0. If, on the other hand, the\ninteger encoded by t is greater than or equal to R, \u03c4 will be a silent 2-type, and\nwe will have C\u03c4 = 0. In this latter case, no vector u such that u > 0 can be a\nmultiple of C\u03c4 , whence, E2 contains the constraint z\u03c0,t,u = 0 for all u such that\n0<u\u2264C.\nLet E3 consist of the following constraints, where \u03c0 varies over all 1-types,\nt varies over bit-strings such that |t| = q, and u varies over vectors such that\n0 < u \u2264 C:\nX\nz\u03c0,t,u > 0 \u21d2\n{y\u03c0\u2032 ,\u01eb,u\u2032 | \u03c0 \u2032 = tp2 (\u03bc\u03c0,t ) and u\u2032 \u2264 C} \u2265 3mC. (18)\n\nAgain, if the integer encoded by t is greater than or equal to R, we have already\nargued that E2 contains the constraint, z\u03c0,t,u = 0 for all u such that 0 < u \u2264 C,\nrendering the corresponding instances of (18) trivial.\nFinally, let E = E1 \u222a E2 \u222a E3 .\n\n4\n\nMain result\n\nLemma 5. Let \u03c6 and E be as above. If \u03c6 is finitely satisfiable, then E has a\nsolution over N.\nProof. Suppose \u03c6 is finitely satisfiable. By Lemma 3, let A\u2032 be a finite, chromatic\nmodel of \u03c6, and by Lemma 1, let A = 3mC * A\u2032 . Thus, A is also chromatic. Let\nA have domain A. If \u03c0 is a 1-type, let A\u03c0 = {a \u2208 A | tpA [a] = \u03c0}. Now suppose\na \u2208 A\u03c0 . For any bit-string s (0 \u2264 |s| \u2264 p), define the s-spectrum of a, denoted\nspA\ns [a], to be the vector whose ith component (1 \u2264 i \u2264 m) is given by\n|{b \u2208 A : A |= fi [a, b], b 6= a and tpA [a, b] \u2208 \u039b\u03c0,s }|.\nFor any bit-string t (0 \u2264 |t| \u2264 q), define the t-tally of a, denoted tlA\nt [a], to be\nthe vector whose ith component (1 \u2264 i \u2264 m) is given by\n|{b \u2208 A : A |= fi [a, b], b 6= a and tpA [a, b] \u2208 M\u03c0,t }|.\nThese quantities are easiest to understand when the strings s and t take the\nvalue \u01eb. For any a \u2208 A, spA\n\u01eb [a] is the vector whose ith component records the\nnumber of elements b to which a sends a message of invertible type containing\nthe atom fi (x, y). Likewise, tlA\n\u01eb [a] is the vector whose ith component records\nthe number of elements b to which a sends a message of non-invertible type\ncontaining the atom fi (x, y). If tpA [a] = \u03c0 and 0 < |s| \u2264 p, then spA\ns [a] is\nobtained in the same way as spA\n[a],\nexcept\nthat\nwe\ndiscount\nall\nmessages\nwhose\n\u01eb\ntype is not a member of \u039b\u03c0,s . Likewise, if tpA [a] = \u03c0 and 0 < |t| \u2264 q, then\nA\ntlA\nt [a] is obtained in the same way as tl\u01eb [a], except that we discount all messages\n\n\f10\n\n4 MAIN RESULT\n\nwhose type is not a member of M\u03c0,t . It is then easy to see that, for all a \u2208 A,\nall bit-strings s (|s| < p) and all bit-strings t (|t| < q),\nA\nspA\n\u01eb [a] + tl\u01eb [a] =\nA\nspA\ns0 [a] + sps1 [a]\nA\ntlA\nt0 [a] + tlt1 [a]\n\n=\n=\n\nC\n\n(19)\n\nspA\ns [a]\nA\ntlt [a].\n\n(20)\n(21)\n\nLet \u03b8 : V \u2192 N be defined by:\n\u03b8(x\u03bb )\n\u03b8(y\u03c0,s,u )\n\n= |{a \u2208 A : there exists b \u2208 A \\ {a} such that tpA [a, b] = \u03bb}|\n= |{a \u2208 A\u03c0 : spA\ns [a] = u}|\n\n\u03b8(z\u03c0,t,u )\n\u03b8(\u0177\u03c0,s,v,w )\n\n= |{a \u2208 A\u03c0 : tlA\nt [a] = u}|\nA\n= |{a \u2208 A\u03c0 : spA\ns0 [a] = v and sps1 [a] = w}| whenever |s| < p\n\n\u03b8(\u1e91\u03c0,t,v,w )\n\nA\n= |{a \u2208 A\u03c0 : tlA\nt0 [a] = v and tlt1 [a] = w}|\n\nwhenever |t| < q,\n\nwhere the indices \u03bb, \u03c0, s, t, u, v and w vary over their standard ranges.\nWe show that \u03b8 is a solution of E by checking the forms (4)\u2013(18) in turn.\nThe constraints (4)\u2013(6) follow easily from Equations (19)\u2013(21), respectively.\nThe constraints (7)\u2013(10) are immediate. In the (single) constraint (11), the\nsum on the right-hand side evaluates under \u03b8 to the cardinality of A, which is\npositive by definition. To understand the constraints (12), fix any \u03c0 and s (with\n|s| = p), and write, for any \u03bb \u2208 \u039b\u03c0,s ,\nA\u03bb = {a \u2208 A | there exists b \u2208 A \\ {a} such that tpA [a, b] = \u03bb}.\nThus, A\u03bb \u2286 A\u03c0 , and |A\u03bb | = \u03b8(x\u03bb ). By Lemma 4, for any a \u2208 A\u03c0 , there can\nbe at most one element b \u2208 A \\ {a} such that tpA [a, b] \u2208 \u039b\u03c0,s . It follows that\nthe sets A\u03bb , for \u03bb varying over \u039b\u03c0,s , are pairwise disjoint, and, moreover, that\na \u2208 A\u03c0 has s-spectrum u > 0 if any only if it is a member of some (hence,\nexactly one) of these sets A\u03bb , with C\u03bb = u. That is, for all u > 0,\n[\n{a \u2208 A\u03c0 | spA\n{A\u03bb\u2032 | \u03bb\u2032 \u2208 \u039b\u03c0,s and C\u03bb\u2032 = u},\ns [a] = u} =\n\nwith the sets on the right-hand side pairwise disjoint. The relevant instance\nof (12) is then immediate from the definition of \u03b8. To see why the constraints (13) hold, note that, if |t| = q, then M\u03c0,t is a set containing precisely one\n2-type \u03c4 = \u03bc\u03c0,t , which is either a non-invertible message-type or a silent 2-type.\nEither way, for every a \u2208 A\u03c0 , tlA\nt [a] must be a scalar multiple (possibly zero) of\nC\u03c4 . In other words, if u > 0 is not a scalar multiple of C\u03c4 , then \u03b8(z\u03c0,t,u ) = 0.\nTo understand the constraints (14), observe that, since A is chromatic, \u03b8(x\u03bb )\nis actually the total number of messages of (invertible) type \u03bb sent by elements\nof A, and similarly for \u03b8(x(\u03bb\u22121 ) ); and these numbers are obviously equal. The\nconstraints (15) are immediate given that A is chromatic. The constraints (16)\nand (17) are immediate given that A |= \u03c6. To understand the constraints (18),\nfix any \u03c0, t and u such that |t| = q and u > 0. If z\u03c0,t,u > 0 holds under \u03b8, then\n\u03bc\u03c0,t is a (non-invertible) message-type; and furthermore, at least one message\n\n\f11\n\n4 MAIN RESULT\n\nof that type must be sent in A, so that A contains at least one element whose\n1-type is tp2 (\u03bc\u03c0,t ) and hence-since A = 3mC *A\u2032 -at least 3mC such elements.\nBut the exact number\nP of elements in A whose 1-type is tp2 (\u03bc\u03c0,t ) is given by the\nvalue, under \u03b8, of {y\u03c0\u2032 ,\u01eb,u\u2032 | \u03c0 \u2032 = tp2 (\u03bc\u03c0,t ) and u\u2032 \u2264 C}.\n\nIn establishing the converse of Lemma 5, the following technical result concerning solutions of E will prove useful. To avoid notational clutter, we use the\nvariable names x\u03bb , y\u03c0,s,u , z\u03c0,t,u , \u0177\u03c0,s,v,w , \u1e91\u03c0,t,v,w to stand for the corresponding\nnatural numbers in some such solution (and similarly for terms involving these\nvariables).\n\nLemma 6. Let x\u03bb , y\u03c0,s,u , z\u03c0,t,u , \u0177\u03c0,s,v,w , \u1e91\u03c0,t,v,w (with indices having the\nappropriate ranges) be natural numbers satisfying theP\nconstraints E given above.\nFix any 1-type \u03c0, and let A\u03c0 be a set of cardinality {y\u03c0,\u01eb,u\u2032 | u\u2032 \u2264 C}. Then\nthere exists a system of functions on A\u03c0\nf\u03c0,s : A\u03c0 \u2192 {u | u \u2264 C}\n\ng\u03c0,t : A\u03c0 \u2192 {u | u \u2264 C},\n\nwhere the indices s and t vary over their standard ranges, such that, for all\nvectors u \u2264 C,\n\u22121\n(u)| =\n|f\u03c0,s\n\ny\u03c0,s,u\n\n(22)\n\n\u22121\n|g\u03c0,t\n(u)| =\n\nz\u03c0,t,u ,\n\n(23)\n\nand such that, for all a \u2208 A\u03c0 ,\nX\nX\n{g\u03c0,t\u2032 (a) : |t\u2032 | = q}\n{f\u03c0,s\u2032 (a) : |s\u2032 | = p} +\n\n= C.\n\n(24)\n\nProof. Decompose the set A\u03c0 into pairwise disjoint (possibly empty) sets Au\nsuch that |Au | = y\u03c0,\u01eb,u , where the index u varies over all vectors \u2264 C. This is\npossible by the cardinality of A\u03c0 . For all u \u2264 C, and all a \u2208 Au , set\nf\u03c0,\u01eb (a) = u\n\ng\u03c0,\u01eb (a) = C \u2212 u.\n\nThis assignment evidently satisfies (22) for s = \u01eb; and by the constraints (4), it\nalso satisfies (23) for t = \u01eb. We observe in passing that, for all a \u2208 A\u03c0 ,\nf\u03c0,\u01eb (a) + g\u03c0,\u01eb (a) = C.\n\n(25)\n\nWe now construct the functions f\u03c0,s , where 0 < |s| \u2264 p, by induction on s.\nAssume that, for some s (0 \u2264 |s| < p), f\u03c0,s has been defined and satisfies (22).\n\u22121\nFor every vector u \u2264 C, decompose f\u03c0,s\n(u) into pairwise disjoint (possibly\nempty) sets Av,w such that |Av,w | = \u0177\u03c0,s,v,w , where the indices v, w vary over\nall vectors satisfying v + w = u. This is possible by the constraints (5) together\nwith the assumption that f\u03c0,s satisfies (22). Having thus decomposed the sets\n\n\f12\n\n4 MAIN RESULT\n\n\u22121\nf\u03c0,s\n(u) (for all u \u2264 C), we see that, for any a \u2208 A\u03c0 , there is precisely one\n(ordered) pair of vectors v, w such that a \u2208 Av,w ; hence we may set\n\nf\u03c0,s0 (a) = v\n\nf\u03c0,s1 (a) = w.\n\nThis defines the functions f\u03c0,s0 and f\u03c0,s1 . We observe in passing that, for all\na \u2208 A\u03c0 ,\nf\u03c0,s0 (a) + f\u03c0,s1 (a) = f\u03c0,s (a).\n(26)\nTo see that f\u03c0,s0 and f\u03c0,s1 both satisfy Equation (22), note that f\u03c0,s0 (a) = v\nif and only if, for some vector w\u2032 such that v + w\u2032 \u2264 C, a \u2208 Av,w\u2032 . Similarly,\nf\u03c0,s1 (a) = w if and only if, for some vector v\u2032 such that v\u2032 + w \u2264 C, a \u2208 Av\u2032 ,w .\nThat is,\n[\n\u22121\nf\u03c0,s0\n(v) =\n{Av,w\u2032 | v + w\u2032 \u2264 C}\n[\n\u22121\nf\u03c0,s1\n(w) =\n{Av\u2032 ,w | v\u2032 + w \u2264 C},\n\nwith the collections of sets on the respective right-hand sides being pairwise\ndisjoint. By the constraints (7)\u2013(8), together with the fact that |Av,w | = \u0177\u03c0,s,v,w\nfor all v, w, we have:\n\u22121\n|f\u03c0,s0\n(v)|\n\n=\n\ny\u03c0,s0,v\n\n\u22121\n|f\u03c0,s1\n(w)|\n\n=\n\ny\u03c0,s1,w ,\n\nwhich establishes (22) for the functions f\u03c0,s0 and f\u03c0,s1 . This completes the induction. The construction of the functions g\u03c0,t proceeds completely analogously,\nusing Constraints (6), (9) and (10). In carrying out this latter construction, we\nobtain, in a parallel way to (26),\ng\u03c0,t0 (a) + g\u03c0,t1 (a) = g\u03c0,t (a),\n\n(27)\n\nfor all bit-strings t (|t| < q) and all a \u2208 A\u03c0 .\nIt remains to establish (24). We prove the stronger result that, for all a \u2208 A\u03c0 ,\nj (0 \u2264 j \u2264 p) and k (0 \u2264 k \u2264 q),\nX\nX\n(28)\n{g\u03c0,t\u2032 (a) : |t\u2032 | = k} = C,\n{f\u03c0,s\u2032 (a) : |s\u2032 | = j} +\n\nusing a double induction on j and k. If j = k = 0, then the left-hand side\nof (28) is simply f\u03c0,\u01eb (a) + g\u03c0,\u01eb (a), which is equal to C by (25). Suppose now\nthat the result holds for the pair j, k, with j < p. Then\nX\nX\n{g\u03c0,t\u2032 (a) : |t\u2032 | = k}\n{f\u03c0,s\u2032 (a) : |s\u2032 | = (j + 1)} +\nX\nX\n=\n{f\u03c0,s\u2032 0 (a) + f\u03c0,s\u2032 1 (a) : |s\u2032 | = j} +\n{g\u03c0,t\u2032 (a) : |t\u2032 | = k}\nX\nX\n=\n{f\u03c0,s (a) : |s\u2032 | = j} +\n{g\u03c0,t\u2032 (a) : |t\u2032 | = k}\nby (26)\n=\n\nC\n\nby inductive hypothesis.\n\nThis establishes the result for the pair j+1, k. An analogous argument using (27)\napplies when k < m, completing the induction.\n\n\f4 MAIN RESULT\n\n13\n\nBefore we come to the promised converse of Lemma 5, we remark on the\n(exponentially many) choices made during the construction of the various functions f\u03c0,s and g\u03c0,t in the proof of Lemma 6-specifically, in the decomposition\nof certain sets into collections of subsets. It is because of this large number\nof independent choices that solutions of E typically encode not one, but many,\nmodels of \u03c6.\nLemma 7. Let \u03c6 and E be as above. If E has a solution over N, then \u03c6 is\nfinitely satisfiable.\nProof. Suppose E has a solution over N. Again, we use the variable names x\u03bb ,\ny\u03c0,s,u , z\u03c0,t,u , \u0177\u03c0,s,v,w , \u1e91\u03c0,t,v,w to stand for the corresponding values in some\nsuch solution. Our task is to construct a model A of \u03c6.\nP\nFor each 1-type \u03c0, let A\u03c0 be a setSof cardinality {y\u03c0,\u01eb,u | u \u2264 C}, with\nthe A\u03c0 pairwise disjoint; and let A = {A\u03c0 | \u03c0 a 1-type}. Think of A\u03c0 as the\nset of elements of A which 'want' to have 1-type \u03c0. By the constraint (11),\nA 6= \u2205. For every 1-type \u03c0, let the functions f\u03c0,s and g\u03c0,t be constructed as\nin Lemma 6; we are interested only in those f\u03c0,s and g\u03c0,t where |s| = p, and\n|t| = q. For all such \u03c0, s, t, and all a \u2208 A\u03c0 , think of f\u03c0,s (a) as the s-spectrum\nwhich a 'wants' to have, and think of g\u03c0,t (a) as the t-tally which a 'wants' to\n\u22121\nhave. Finally, consider any set f\u03c0,s\n(u), where 0 < u \u2264 C and |s| = p. Using\n\u22121\nthe constraints (12) and Equation (22), we can decompose f\u03c0,s\n(u) into pairwise\ndisjoint (possibly empty) sets A\u03bb with |A\u03bb | = x\u03bb , where \u03bb varies over the set\nof invertible message-types such that \u03bb \u2208 \u039b\u03c0,s and C\u03bb = u. It follows that, if\na \u2208 A\u03bb , with \u03bb \u2208 \u039b\u03c0,s , then C\u03bb = f\u03c0,s (a). Think of A\u03bb as the set of elements\nof A\u03c0 which 'want' to send a single message of (invertible) type \u03bb.\nBefore proceeding, we pause to consider the construction just described in\nrespect of any of the sets A\u03c0 . Fixing, for the moment, some bit-string s with\n\u22121\n|s| = p, we see that A\u03c0 is decomposed into the pairwise disjoint sets f\u03c0,s\n(u)\n\u22121\n(as u varies over vectors such that u \u2264 C), and that each of the sets f\u03c0,s (u),\nwhere 0 < u \u2264 C, is further decomposed into the pairwise disjoint subsets\nA\u03bb (as \u03bb varies over the elements of \u039b\u03c0,s such that C\u03bb = u). Note that the\n\u22121\n(0) is not subject to this further stage of decomposition. This process\nset f\u03c0,s\nis performed for every bit string s with |s| = p, so that different values of s\nlead to independent-and possibly overlapping-decompositions, as illustrated\nin Fig. 1. Likewise, for every bit-string t with |t| = q, A\u03c0 is decomposed into\n\u22121\nthe pairwise disjoint sets g\u03c0,t\n(u) (as u varies over vectors such that u \u2264 C).\nAgain, decompositions corresponding to different values of t should be thought\nof as independent of each other.\nWe now proceed to construct, for every a \u2208 A, a data-structure recording a\ncollection of messages sent by a, each of which is labelled with some (invertible\nor non-invertible) message-type. (These data-structures will later be combined\nto form a structure A on A.) Recall that, if \u03c0 is any 1-type, then \u03bc\u03c0,0 , . . . , \u03bc\u03c0,R\u22121\nis an enumeration of the non-invertible message-types \u03bc such that tp1 (\u03bc) = \u03c0.\nFix a \u2208 A, and let \u03c0 be the unique 1-type such that a \u2208 A\u03c0 . The messages\nsent by a shall be as follows. (i) For every bit-string s such that |s| = p, if\nf\u03c0,s (a) > 0, let \u03bba,s be the invertible message-type \u03bb \u2208 \u039b\u03c0,s such that a \u2208 A\u03bb\n\n\f14\n\n4 MAIN RESULT\nA\u03c0\n\n\u22121\nf\u03c0,s\n(u)\n\n000000000000000000000\n111111111111111111111\n000000000\n111111111\n000000000\n111111111\n000000000\n111111111\n000000000\n111111111\n111111111111111111111\n000000000000000000000\n0000000\n1111111\n00000\n11111\n000000000\n111111111\n0000000\n1111111\n00000\n11111\n000000000\n111111111\n0000000\n1111111\n00000\n11111\n000000000\n111111111\n11111111111111111111\n00000000000000000000\n0000000\n1111111\n00000\n11111\n000000000\n111111111\n0000000\n1111111\n0000000\n1111111\n0000000\n1111111\n0000000\n1111111\n\n0110\n10\u22121 \u2032\n1010f\u03c0,s (u )\n1010\n10\n\u2032\n\nA\u03bb\u2032 , where \u03bb\u2032 \u2208 \u039b\u03c0,s\u2032\nand C\u03bb\u2032 = u\u2032\n\nA\u03bb , where \u03bb \u2208 \u039b\u03c0,s\nand C\u03bb = u\n\n111111111111111111111\n000000000000000000000\n\n\u22121\nf\u03c0,s\n\u2032 (0)\n\n\u22121\nf\u03c0,s\n(0)\n\nFigure 1: The decompositions of A\u03c0 for the strings s and s\u2032 .\n(hence C\u03bb = f\u03c0,s (a)), and let a send a single message labelled \u03bba,s . Note that,\nif f\u03c0,s (a) > 0, then \u03bba,s exists and is unique by the construction of the sets A\u03bb .\n(ii) For every bit string t such that |t| = q, if t encodes an integer less than R\n(so that \u03bc = \u03bc\u03c0,t is a non-invertible message-type and C\u03bc > 0), let na,t be the\nunique natural number n such that g\u03c0,t (a) = nC\u03bc , and let a send na,t distinct\nmessages labelled \u03bc\u03c0,t . Note that, if g\u03c0,t (a) = 0, then na,t = 0; on the other\nhand, if g\u03c0,t (a) > 0, then na,t exists by the constraints (13) and Equation (23).\nThe resulting data-structure is depicted in Fig. 2, where, for readability, we\nhave replaced any bit-strings by the integers they conventionally denote. For\nall a \u2208 A and all i (1 \u2264 i \u2264 m), let Ca,i (1 \u2264 i \u2264 m) be the number of messages\nsent by a having any label \u03bd for which fi (x, y) \u2208 \u03bd, and furthermore let Ca be\nthe vector (Ca,1 , . . . , Ca,m ). By inspection of Fig. 2,\nX\nX\n{g\u03c0,t\u2032 (a) : |t\u2032 | = q},\nCa =\n{f\u03c0,s\u2032 (a) : |s\u2032 | = p} +\nand so, by Equation (24),\n\nCa = C.\n\n(29)\n\nWe now build A in four steps as follows.\nStep 1 (Fixing the 1-types): For all 1-types \u03c0 and all a \u2208 A\u03c0 , set tpA [a] = \u03c0.\nSince the A\u03c0 are pairwise disjoint, no clashes arise.\nStep 2 (Fixing the invertible message-types): Let \u03bb be any invertible messagetype. By construction, exactly |A\u03bb | = x\u03bb elements of A send some message\nlabelled with \u03bb, and each of those elements sends exactly one such message.\nHence, the number of messages labelled with \u03bb (over all a \u2208 A) is x\u03bb ; likewise,\n\n\f15\n\n4 MAIN RESULT\n\n\u03bba,0\n\nna,R\u22121\n\u03bc\u03c0,R\u22121\n\n\u03bba,1\n\u03bc\u03c0,R\u22121\n\n\u03bba,P \u22121\n\n\u03bc\u03c0,1\n\u03bc\u03c0,1\nna,1\n\n\u03bc\u03c0,0\n\u03bc\u03c0,0\n\nna,0\n\nFigure 2: The messages sent by a \u2208 A\u03c0 . For each j (0 \u2264 j < P ), a may or\nmay not send a message labelled \u03bba,j (hence the dotted lines); if it does, then\n\u03bba,j \u2208 \u039b\u03c0,j . For each k (0 \u2264 k < R), a sends na,k messages labelled \u03bc\u03c0,k ; but\nthe numbers na,k can be zero.\nthe number of messages labelled with \u03bb\u22121 is x\u03bb\u22121 . By the constraints (14), we\nmay put the \u03bb-labelled messages and the \u03bb\u22121 -labelled messages in 1\u20131 correspondence. If a \u2208 A sends a \u03bb-labelled message, let b \u2208 A send the corresponding\n\u03bb\u22121 -labelled message, and set tpA [a, b] = \u03bb. For this assignment to make sense,\nwe need to check that a and b are distinct. But, by construction, we must have\nx\u03bb > 0, whence, by the constraints (15), tp1 (\u03bb) 6= tp2 (\u03bb), so that Atp1 (\u03bb) and\nAtp2 (\u03bb) are disjoint sets containing a and b, respectively. Thus, the assignment\ntpA [a, b] = \u03bb makes sense, and does not clash the with 1-type assignments in\nStep 1. We can think of the element b as 'receiving' the message sent by a (and\nvice versa). Moreover, by construction, for every 1-type \u03c0 \u2032 , a sends at most\none message labelled with an invertible message-type \u03bb\u2032 such that tp2 (\u03bb\u2032 ) = \u03c0 \u2032 .\nTherefore, there is no chance that these assignments clash with each other.\nStep 3 (Fixing the non-invertible message-types): As a preliminary, for every 1type \u03c0, we decompose A\u03c0 into three pairwise disjoint (possibly empty) sets A\u03c0,0 ,\nA\u03c0,1 and A\u03c0,2 satisfying the condition that, if |A\u03c0 | \u2265 3mC, then |A\u03c0,j | \u2265 mC for\nall j (0 \u2264 j \u2264 2). Now let \u03bc be any non-invertible message-type, let \u03c0 = tp1 (\u03bc),\nand let \u03c1 = tp2 (\u03bc). (Note that \u03c0 and \u03c1 may be identical.) Let t be the\nbit-string of length q such that \u03bc = \u03bc\u03c0,t , and suppose some element a sends\n\n\f16\n\n4 MAIN RESULT\n\nA\u03c0,j\n\nA\u03c0,j \u2032\n\na q\u2773\u2773\n\u2773\u2773\n\u2773\u2773\u2773\n3\n\u2773\n\u2718q b\n\u2718\u2718\u2718\n\u2718\n\u2718\n\u273e\u2718\nq\u2718\nA\u03c0\n\nA\u03c1,k\n\nA\u03c1\n\nFigure 3: Fixing the non-invertible message-types.\nna,t > 0 messages labelled \u03bc. It follows that a \u2208 A\u03c0 , and also that there is a\n\u22121\nvector u > 0 such that g\u03c0,t (a) = u, and hence such that g\u03c0,t\n(u)\nPis non-empty.\nBy Equation (23), z\u03c0,t,u > 0, whence, by the constraintsP(18), {y\u03c1,\u01eb,u\u2032 | u\u2032 \u2264\nC} \u2265 3mC. But recall that, since \u03c1 is a 1-type, |A\u03c1 | = {y\u03c1,\u01eb,u\u2032 | u\u2032 \u2264 C}, so\nthat each of the sets A\u03c1,0 , A\u03c1,1 and A\u03c1,2 contains at least mC elements. Since\na \u2208 A\u03c0 , let j (0 \u2264 j \u2264 2) be such that a \u2208 A\u03c0,j , let k = j + 1 (mod 3), and\nselect na,t elements b from A\u03c1,k which have not yet been chosen to receive any\nother messages (invertible or non-invertible) sent by a. Since the total number\nof messages sent by a is certainly at most mC, we never run out of choices. For\neach of these elements b, set tpA [a, b] = \u03bc. Since \u03c0 = tp1 (\u03bc) and \u03c1 = tp2 (\u03bc),\nthese assignments cannot clash with those made in Step 1, and by construction,\nthey cannot clash with assignments corresponding to other messages sent by a.\nWe need only check that they cannot clash with assignments corresponding to\nmessages sent by b. Specifically, we must ensure that, if tpA [a, b] = \u03bc is assigned\nas just described, it is not possible for a to be chosen to receive a \u03bc\u2032 -labelled\nmessage sent by b, where \u03bc\u2032 is some non-invertible message-type. But any \u03bc\u2032 labelled message sent by b \u2208 A\u03c1,k , with tp2 (\u03bc\u2032 ) = \u03c0, could only be sent to an\nelement in A\u03c0,j \u2032 , where j \u2032 = k + 1 (mod 3); and by assumption, A\u03c0,j and A\u03c0,j \u2032\nare disjoint, (Fig. 3). Observe that this conclusion follows even if \u03c0 = \u03c1.\nStep 4 (Fixing the remaining 2-types): Recall that a guard-atom is any atom\np(x, y) or p(y, x), where p is a binary predicate. If tpA [a, b] has not been defined,\nset it to be the 2-type\n\u03c0 \u222a \u03c1[y/x] \u222a {\u00ac\u03b3 | \u03b3 is a guard-atom not involving \u2248},\nwhere \u03c0 = tpA [a], \u03c1 = tpA [b], and \u03c1[y/x] is the result of replacing x by y in \u03c1.\nNote that neither this 2-type nor its inverse is a message-type. Note also that,\nsince a and b certainly\nsend V\nsome messages, the constraints (16) and (17) ensure\nV\nthat both \u03b1 \u2227 \u03c0 and \u03b1 \u2227 \u03c1 are satisfiable.\nThis completes the definition of A; it remains to show that A |= \u03c6. Referring\nto (1), we consider first the conjuncts:\n^\n\u2200x\u03b1 \u2227\n\u2200x\u2200y(eh (x, y) \u2192 (\u03b2h \u2228 x \u2248 y)).\n1\u2264h\u2264l\n\nWe see from the constraints (16) and (17) that no 2-type assignment in Steps 2\n\n\f17\n\n4 MAIN RESULT\n\nand 3 violates these conjuncts. And it is obvious that no assignment in Step 4\ndoes so. (This is where we use the guardedness of \u03c6, of course.) Finally, we\nconsider the conjuncts\n^\n\u2200x\u2203=Ci y(fi (x, y) \u2227 x 6\u2248 y).\n1\u2264i\u2264m\n\nTo see that these conjuncts are all satisfied, it suffices to note Equation (29)\nand the fact that none of the 2-types assigned in Step 4 is a message-type. We\nremark in passing that A is chromatic.\nThe constraints E all have the forms\nx1 + * * * + xn\nx1 + * * * + xn\nx\nx > 0 \u21d2 x1 + * * * + xn\n\n=\n\u2265\n=\n\u2265\n\nx\n1\n0\nD,\n\n(30)\n\nwhere n > 0, x, x1 , . . . , xn are variables, and D is a positive integer. We measure\nthe size kEk of E in the usual way, with binary encoding of the constants D.\nThe following lemma essentially repeats Lutz, Sattler and Tendera [9], Proposition 11. (Those authors in turn credit Calvanese [3].) We repeat the proof for\nconvenience.\nLemma 8. Let \u03c6 and E be as above. An algorithm exists to determine, in time\nbounded by an exponential function of k\u03c6k, whether E has a solution over N.\nProof. Suppose E has a solution \u03b8 : V \u2192 N. We define the integer programming\nproblem E\u03b8 by replacing every constraint in E having the form x > 0 \u21d2 x1 +\n* * * + xn \u2265 D with one of two corresponding inequalities as follows:\n(\nx=0\nif \u03b8(x) = 0\nx1 + * * * + xn \u2265 D\notherwise.\nIt is easy to check that \u03b8 is a solution of E\u03b8 , and, moreover, that every solution\nof E\u03b8 is a solution of E. Since E\u03b8 is an integer programming problem and has a\nsolution over N, by a well-known theorem (Papadimitriou [10]), it has a solution\n\u03b8\u2032 over N in which every value is bounded by a (positive) integer H, where H\ncan be computed (as a binary string) in time bounded by a polynomial function\nof kE\u03b8 k and hence in time bounded by an exponential function of k\u03c6k. (Of\ncourse, the integer H is bounded only by an doubly exponential function of\nk\u03c6k.) Moreover, \u03b8\u2032 must also be a solution of E. Therefore E too has a solution\nover N if and only if it has a solution over N in which every value is bounded\nby H.\nNow consider the integer programming problem EH defined by replacing\nevery constraint of the form x > 0 \u21d2 x1 +* * *+xn \u2265 D in E by the corresponding\ninequalities\nHy\nx1 + * * * + xn\n\n\u2265\n\u2265\n\nx\nDy,\n\n\f18\n\n5 THE SATISFIABILITY PROBLEM\n\nwhere y is a new variable. Every solution of EH over N is a solution of E.\nMoreover, suppose \u03b8\u2032 is any solution of E over N in which all values are bounded\nby H; and let y be one of the new variables of EH , introduced to eliminate the\nconstraint x > 0 \u21d2 x1 + * * * + xn \u2265 D. Let us extend \u03b8\u2032 to give a value to y as\nfollows:\n(\n0\nif \u03b8\u2032 (x) = 0\n\u03b8\u2032 (y) =\n1\notherwise.\nIt is routine to check that extending \u03b8\u2032 in this way for all the new variables y in\nEH yields a solution of EH . Hence E can be transformed, in time bounded by\nan exponential function of k\u03c6k, into the equisatisfiable (over N) constraint set\nEH , in which all constraints are of the forms\nx1 + * * * + xn\nx1 + * * * + xn\nx1 + * * * + xn\n\n= x\n\u2265 1\n\u2265 Dx,\n\nx\nDx1\n\n= 0\n\u2265 x2\n\nwhere, again, the D are positive integers. It is obvious that, if EH has a solution\nover the non-negative rationals, then it has a solution over N as well. (Simply\nmultiply by the product of all the denominators.) Hence, we can equivalently\nregard EH as a linear programming problem. But linear programming is in\nPTIME, by Khachiyan's theorem [7].\nTheorem 1. The finite satisfiability problem for GC 2 is in EXPTIME.\nProof. Lemmas 2, 5, 7 and 8.\n\n5\n\nThe Satisfiability Problem\n\nThe above technique also provides a simple proof of a result derived in Kazakov [6], namely, that the satisfiability problem for GC 2 is in EXPTIME.\nNotation 2. Let N\u2217 denote the set N\u222a{\u05d00 }. We extend the ordering > and the\narithmetic operations + and * from N to N\u2217 in the obvious way. Specifically, we\ndefine \u05d00 > n for all n \u2208 N; we define \u05d00 +\u05d00 = \u05d00 *\u05d00 = \u05d00 and 0*\u05d00 = \u05d00 *0 = 0;\nwe define n + \u05d00 = \u05d00 + n = \u05d00 for all n \u2208 N; and we define n * \u05d00 = \u05d00 * n = \u05d00\nfor all n \u2208 N such that n > 0. Under this extension, > remains a total order,\nand +, * remain associative and commutative.\nConsider again the constraints E given in (4)\u2013(18), but now with the variables\nranging over the whole of N\u2217 . Using the arithmetic in Notation 2, the reasoning\nof Lemmas 5\u20137 works unproblematically even when countably infinite sets are\nallowed. Thus, we have:\nLemma 9. Let \u03c6 and E be as above. Then \u03c6 is satisfiable if and only if E has\na solution over N\u2217 .\nProof. If \u03c6 is satisfiable, then it has a model which is finite or countably infinite.\nNow proceed as for Lemma 5. For the converse, proceed as for Lemma 7.\n\n\f19\n\nREFERENCES\n\nLemma 10. The set of constraints E has a solution over N\u2217 if and only if it\nhas a solution over {0, \u05d00 }.\nProof. Suppose E has a solution \u03b8 : V \u2192 N\u2217 . By considering the forms in E,\nwe see that \u03b8\u2032 : V \u2192 {0, \u05d00 } defined by \u03b8\u2032 (v) = \u05d00 \u03b8\u2032 (v) is also a solution. The\nother direction is trivial.\nSince the domain {0, \u05d00 } has only 2-elements, variables interpreted over it\nare essentially Boolean. If x \u2208 V , let us write X for the corresponding statement\nx = 0, so that the constraints E are viewed as formulas of propositional logic.\nFor example, a constraint of the form\nx1 + * * * + xn = x\nbecomes the set of Boolean formulas\n{X1 \u2227 * * * \u2227 Xn \u2192 X} \u222a {X \u2192 Xi | 1 \u2264 i \u2264 n};\na constraint of the form\nx1 + * * * + xn \u2265 1\nbecomes the Boolean formula\nX1 \u2227 * * * \u2227 Xn \u2192 \u22a5;\nand a constraint of the form\nx > 0 \u21d2 x1 + * * * + xn \u2265 D\nbecomes the Boolean formula\nX1 \u2227 * * * \u2227 Xn \u2192 X.\nA quick check reveals that all of the resulting formulas are Horn-clauses.\nThis immediately yields:\nTheorem 2 (Kazakov). The satisfiability problem for GC 2 is in EXPTIME.\nThe proof in Kazakov [6] proceeds by showing that satisfiability in GC 2 can be\nreduced in polynomial time to satisfiability in the 3-variable guarded fragment;\nTheorem 2 then follows by the complexity bound for the latter established by\nGr\u00e4del [4]. The approach taken here is thus somewhat more direct. Moreover,\nKazakov's reduction is not conservative, and, as mentioned, yields no complexity\nbound for the corresponding finite satisfiability problem.\n\nReferences\n[1] Egon B\u00f6rger, Erich Gr\u00e4del, and Yuri Gurevich. The Classical Decision\nProblem. Perspectives in Mathematical Logic. Springer-Verlag, Berlin,\n1997.\n\n\fREFERENCES\n\n20\n\n[2] D. Calvanese. Finite model reasoning in description logics. In L. C. Aiello,\nJ. Doyle, and S. Shapiro, editors, Principles of Knowledge Representation\nand Reasoning (KR '96), pages 292\u2013303, San Francisco, CA, 1996. Morgan\nKaufmann.\n[3] D. Calvanese. Unrestricted and finite model reasoning in class-based representation formalisms. PhD thesis, Dipartimento di Informatica e Sistemistica, Universit\u00e0 di Roma, 1996.\n[4] E. Gr\u00e4del. On the restraining power of guards. Journal of Symbolic Logic,\n64:1719\u20131742, 1999.\n[5] Erich Gr\u00e4del, Martin Otto, and Eric Rosen. Two-variable logic with counting is decidable. In Proceedings of the 12th IEEE Symposium on Logic in\nComputer Science, pages 306\u2013317. IEEE Online Publications, 1997.\n[6] Y. Kazakov. A polynomial translation from the two-variable guarded fragment with number restrictions to the guarded fragment. In J. J. Alferes and\nJ. Leite, editors, Logics in Artificial Intelligence: 9th European Conference,\nJELIA 2004, volume 3229 of Lecture Notes in Artificial Intelligence, pages\n372\u2013384, Berlin, 2004. Springer.\n[7] L.G. Khachiyan. A polynomial algorithm in linear programming. Soviet\nMathematics Doklady, 20:191\u2013194, 1979.\n[8] C. Lutz, U. Sattler, and L. Tendera. The complexity of finite model reasoning in description logics. In Franz Baader, editor, Automated Deduction-\nCADE-19: 19th International Conference on Automated Deduction, volume\n2741 of Lecture Notes in Artificial Intelligence, pages 60\u201374, Berlin, 2003.\nSpringer.\n[9] C. Lutz, U. Sattler, and L. Tendera. The complexity of finite model reasoning in description logics. Information and Computation, 199:132\u2013171,\n2005.\n[10] Christos H. Papadimitriou. On the complexity of integer programming.\nJournal of the Association for Computing Machinery, 28(4):765\u2013768, 1981.\n[11] Ian Pratt-Hartmann. Complexity of the two-variable fragment with counting quantifiers. Journal of Logic, Language and Information, 14:369\u2013395,\n2005.\n\n\f"}