{"id": "http://arxiv.org/abs/0909.3392v2", "guidislink": true, "updated": "2010-02-10T10:51:41Z", "updated_parsed": [2010, 2, 10, 10, 51, 41, 2, 41, 0], "published": "2009-09-18T08:50:20Z", "published_parsed": [2009, 9, 18, 8, 50, 20, 4, 261, 0], "title": "On the communication complexity of XOR functions", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0909.5587%2C0909.1768%2C0909.5537%2C0909.2594%2C0909.4684%2C0909.1625%2C0909.4035%2C0909.3330%2C0909.1795%2C0909.1974%2C0909.4892%2C0909.0503%2C0909.1329%2C0909.5067%2C0909.3483%2C0909.0717%2C0909.0610%2C0909.5152%2C0909.0489%2C0909.2949%2C0909.4974%2C0909.3531%2C0909.4883%2C0909.1006%2C0909.5126%2C0909.4860%2C0909.0609%2C0909.5350%2C0909.5112%2C0909.2251%2C0909.0519%2C0909.4331%2C0909.3397%2C0909.5104%2C0909.4378%2C0909.0403%2C0909.3371%2C0909.5685%2C0909.2605%2C0909.4387%2C0909.3556%2C0909.4727%2C0909.3392%2C0909.5284%2C0909.4959%2C0909.0783%2C0909.1593%2C0909.0146%2C0909.1519%2C0909.0874%2C0909.4837%2C0909.0203%2C0909.2072%2C0909.5335%2C0909.3646%2C0909.2543%2C0909.2362%2C0909.0398%2C0909.5230%2C0909.1368%2C0909.4657%2C0909.2037%2C0909.4277%2C0909.3928%2C0909.4578%2C0909.4503%2C0909.2117%2C0909.2177%2C0909.5477%2C0909.5008%2C0909.0100%2C0909.0846%2C0909.3473%2C0909.1591%2C0909.2276%2C0909.4816%2C0909.1048%2C0909.2122%2C0909.4639%2C0909.0882%2C0909.2231%2C0909.2963%2C0909.0158%2C0909.3803%2C0909.0011%2C0909.3131%2C0909.3199%2C0909.1167%2C0909.2806%2C0909.2210%2C0909.3085%2C0909.0810%2C0909.3671%2C0909.1312%2C0909.1966%2C0909.3077%2C0909.5145%2C0909.0012%2C0909.2553%2C0909.4863%2C0909.4116&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "On the communication complexity of XOR functions"}, "summary": "An XOR function is a function of the form g(x,y) = f(x + y), for some boolean\nfunction f on n bits. We study the quantum and classical communication\ncomplexity of XOR functions. In the case of exact protocols, we completely\ncharacterise one-way communication complexity for all f. We also show that,\nwhen f is monotone, g's quantum and classical complexities are quadratically\nrelated, and that when f is a linear threshold function, g's quantum complexity\nis Theta(n). More generally, we make a structural conjecture about the Fourier\nspectra of boolean functions which, if true, would imply that the quantum and\nclassical exact communication complexities of all XOR functions are\nasymptotically equivalent. We give two randomised classical protocols for\ngeneral XOR functions which are efficient for certain functions, and a third\nprotocol for linear threshold functions with high margin. These protocols\noperate in the symmetric message passing model with shared randomness.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0909.5587%2C0909.1768%2C0909.5537%2C0909.2594%2C0909.4684%2C0909.1625%2C0909.4035%2C0909.3330%2C0909.1795%2C0909.1974%2C0909.4892%2C0909.0503%2C0909.1329%2C0909.5067%2C0909.3483%2C0909.0717%2C0909.0610%2C0909.5152%2C0909.0489%2C0909.2949%2C0909.4974%2C0909.3531%2C0909.4883%2C0909.1006%2C0909.5126%2C0909.4860%2C0909.0609%2C0909.5350%2C0909.5112%2C0909.2251%2C0909.0519%2C0909.4331%2C0909.3397%2C0909.5104%2C0909.4378%2C0909.0403%2C0909.3371%2C0909.5685%2C0909.2605%2C0909.4387%2C0909.3556%2C0909.4727%2C0909.3392%2C0909.5284%2C0909.4959%2C0909.0783%2C0909.1593%2C0909.0146%2C0909.1519%2C0909.0874%2C0909.4837%2C0909.0203%2C0909.2072%2C0909.5335%2C0909.3646%2C0909.2543%2C0909.2362%2C0909.0398%2C0909.5230%2C0909.1368%2C0909.4657%2C0909.2037%2C0909.4277%2C0909.3928%2C0909.4578%2C0909.4503%2C0909.2117%2C0909.2177%2C0909.5477%2C0909.5008%2C0909.0100%2C0909.0846%2C0909.3473%2C0909.1591%2C0909.2276%2C0909.4816%2C0909.1048%2C0909.2122%2C0909.4639%2C0909.0882%2C0909.2231%2C0909.2963%2C0909.0158%2C0909.3803%2C0909.0011%2C0909.3131%2C0909.3199%2C0909.1167%2C0909.2806%2C0909.2210%2C0909.3085%2C0909.0810%2C0909.3671%2C0909.1312%2C0909.1966%2C0909.3077%2C0909.5145%2C0909.0012%2C0909.2553%2C0909.4863%2C0909.4116&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "An XOR function is a function of the form g(x,y) = f(x + y), for some boolean\nfunction f on n bits. We study the quantum and classical communication\ncomplexity of XOR functions. In the case of exact protocols, we completely\ncharacterise one-way communication complexity for all f. We also show that,\nwhen f is monotone, g's quantum and classical complexities are quadratically\nrelated, and that when f is a linear threshold function, g's quantum complexity\nis Theta(n). More generally, we make a structural conjecture about the Fourier\nspectra of boolean functions which, if true, would imply that the quantum and\nclassical exact communication complexities of all XOR functions are\nasymptotically equivalent. We give two randomised classical protocols for\ngeneral XOR functions which are efficient for certain functions, and a third\nprotocol for linear threshold functions with high margin. These protocols\noperate in the symmetric message passing model with shared randomness."}, "authors": ["Ashley Montanaro", "Tobias Osborne"], "author_detail": {"name": "Tobias Osborne"}, "author": "Tobias Osborne", "arxiv_comment": "18 pages; v2: minor corrections", "links": [{"href": "http://arxiv.org/abs/0909.3392v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0909.3392v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0909.3392v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0909.3392v2", "journal_reference": null, "doi": null, "fulltext": "On the communication complexity of XOR functions\n\narXiv:0909.3392v2 [cs.CC] 10 Feb 2010\n\nAshley Montanaro\u2217 and Tobias J. Osborne\u2020\nOctober 29, 2018\n\nAbstract\nAn XOR function is a function of the form g(x, y) = f (x \u2295 y), for some boolean\nfunction f on n bits. We study the quantum and classical communication complexity\nof XOR functions. In the case of exact protocols, we completely characterise one-way\ncommunication complexity for all f . We also show that, when f is monotone, g's\nquantum and classical complexities are quadratically related, and that when f is a\nlinear threshold function, g's quantum complexity is \u0398(n). More generally, we make a\nstructural conjecture about the Fourier spectra of boolean functions which, if true, would\nimply that the quantum and classical exact communication complexities of all XOR\nfunctions are asymptotically equivalent. We give two randomised classical protocols for\ngeneral XOR functions which are efficient for certain functions, and a third protocol for\nlinear threshold functions with high margin. These protocols operate in the symmetric\nmessage passing model with shared randomness.\n\n1\n\nIntroduction\n\nThe communication complexity model was introduced by Yao in 1979 [28]. In its most\nbasic form, the model considers two separated parties (Alice and Bob), who attempt to\ncompute some function f (x, y) of their joint inputs x, y, while using the minimum amount\nof communication. They may be required to compute f exactly (the deterministic model),\nor may be allowed some constant probability of error (the bounded-error model). The\nconsiderable theoretical interest of this simple model, as well as its practical applications,\nhave motivated its intensive study over the last thirty years.\nMore recently, the model of quantum communication complexity was introduced [29, 12].\nIn this model, Alice and Bob are allowed to send and receive qubits (quantum bits), with\nthe goal being to reduce the amount of communication required. It has recently been\nshown that, when the function f (x, y) to be computed is partial (there is some promise on\nthe inputs x, y), there can be an exponential separation between quantum and classical\ncommunication complexity [19, 5]. No separation beyond quadratic is known for total\n\u2217\n\nDepartment of Computer Science, University of Bristol, Woodland Road, Bristol, BS8 1UB, UK;\nmontanar@cs.bris.ac.uk.\n\u2020\nDepartment of Mathematics, Royal Holloway, University of London, Egham, TW20 0EX, UK;\ntobias.osborne@rhul.ac.uk.\n\n1\n\n\ffunctions, and it is conjectured that the quantum and classical communication complexities\nof total functions are in fact polynomially related. However, this conjecture has resisted\nproof in both the exact and bounded-error models.\nA natural way to make progress on the conjecture is to attempt to prove it for restricted\ntypes of function. The class of functions g(x, y) = f (x \u2227 y), where f is a boolean function,\nhas received particular attention. These functions seem to have first been considered by\nBuhrman and de Wolf [2], who showed that deterministic quantum and classical communication complexities are asymptotically equivalent for all symmetric functions f (f is said\nto be symmetric if f (z) depends only on |z|, the Hamming weight of z). They also showed\nthat these communication complexity measures are polynomially related if f is a monotone\nfunction (f is said to be monotone if f (x \u2228 y) \u2265 max{f (x), f (y)} for all x, y). It was several\nmore years before Razborov proved, in a fundamental paper [20], that the bounded-error\nquantum and classical communication complexities of symmetric functions in this model are\npolynomially related; see [22] for a recent alternative proof. In other recent work, Sherstov\nhas shown that the conjecture does indeed hold if one is required to compute both f (x \u2228 y)\nand f (x\u2227y) [23], and Shi and Zhu have proven lower bounds in a model with a more general\nnotion of composition of functions [25].\nThis paper is concerned with another natural class of functions, where Alice and Bob\neach receive an n-bit string, and the function they need to compute is defined as g(x, y) =\nf (x \u2295 y) for some boolean function f . These functions were recently studied by Shi and\nZhang [24], who refer to them as \"XOR functions\". Shi and Zhang essentially determined\nthe quantum and classical communication complexity of all XOR functions where f is\nsymmetric, up to polylogarithmic factors1 . In particular, using Fourier-analytic techniques,\nthey showed that the exact quantum communication complexity of all symmetric XOR\nfunctions (excluding a few trivial special cases) is \u03a9(n). Bounded-error communication\ncomplexity is dealt with via a reduction to the previous result of Razborov [20]. The special\ncase where f is a threshold function (f (z) = 1 \u21d4 |x| \u2265 t for some t) had been considered\npreviously by Huang et al [8].\nIn the present work, we consider more general classes of XOR function, for which we\nfind new quantum lower bounds and classical upper bounds on communication complexity.\nAs well as monotone functions, another class of function in which we will be interested is\nlinear threshold functions. f : {0, 1}n \u2192 {0, 1} is said to be a linear threshold function\n(LTF) if\n\uf8f1\nn\nX\n\uf8f4\n\uf8f4\n\uf8f4\nwi xi \u2264 \u03b8\n0\nif\n\uf8f4\n\uf8f2\ni=1\nf (x) =\n(1)\nn\n\uf8f4\nX\n\uf8f4\n\uf8f4\n\uf8f4\nwi xi > \u03b8,\n\uf8f3 1 if\ni=1\n\nwhere wi , \u03b8 \u2208 R. The set {wi } are known as the weights of f , and \u03b8 is called the threshold of\nf . These functions have been much studied in the computer science literature and elsewhere;\nsee [21] for a review.\n1\n\nSome general quantum lower bounds, which are tight for some XOR functions, had previously been\nobtained by Buhrman and de Wolf [2], and also Klauck [11].\n\n2\n\n\fIn the case of the model of communication complexity studied here, LTFs are a particularly natural class to consider, for the following reason. Imagine that Alice and Bob each\nhave a document, and they wish to determine whether their documents differ significantly.\nIn practice, differing at one position may be more significant than differing at another (consider a bioinformatics application where mutations are more likely at particular points on\na chromosome). This can be modelled by the task of determining whether a weighted sum\nof differences between bits held by Alice and bits held by Bob is above a threshold, which\nis exactly the problem of computing an XOR function defined by an LTF.\nThe main results we obtain are as follows. First, we completely characterise the deterministic quantum and classical one-way communication complexity of XOR functions\ng(x, y) = f (x \u2295 y) in terms of an algebraic property of f , its Fourier dimension [6]. We\nobserve a relationship between deterministic two-way communication complexity and the\nparity decision tree model introduced in the context of computational learning theory by\nKushilevitz and Mansour [14], and make a structural conjecture about the Fourier spectra of\nboolean functions which, if true, would imply that the quantum and classical deterministic\ntwo-way communication complexity of all XOR functions are asymptotically equivalent.\nTurning to probabilistic communication complexity, we first show that one-way protocols cannot be efficient for all XOR functions: indeed, one-way quantum communication\ncomplexity can be exponentially larger than two-way classical communication complexity.\nOn the other hand, there are randomised classical protocols in the more restrictive simultaneous message passing (SMP) model with shared randomness2 , which are efficient for\nparticular XOR functions. Using a previous result of Grolmusz [7], one can give an efficient\nprotocol for those functions g(x, y) = f (x \u2295 y) where f has a very low spectral norm (f 's\nFourier spectrum is \"narrow\"). We give a new protocol that is efficient for functions where\nf is close to a parity function (f 's Fourier spectrum is \"tall\"), and in particular for functions\nwhere f takes the value 1 on a small number of inputs.\nSpecialising to particular types of XOR function, we first show that the deterministic\nquantum and classical two-way communication complexities of all monotone XOR functions\nare quadratically related. Specialising further, we show that the deterministic two-way\ncommunication complexity of all XOR functions where f is an LTF depending on n bits is\n\u0398(n). Finally, we give a randomised communication protocol for computing LTFs in the\nSMP model with shared randomness, which is efficient provided that the margin of the LTF\nin question is high. The protocol generalises previous results [30, 8] on computing threshold\nfunctions.\nThese results are all given more formally in Section 1.2 below. In order to state them,\nwe will first require some definitions.\n2\n\nSee Section 1.1 for the definition of this and other terms in this introduction.\n\n3\n\n\f1.1\n1.1.1\n\nPreliminaries\nQuery complexity and boolean functions\n\nWe will use a number of mostly standard notions from the field of query complexity (see\nthe review [3] for further details). Let f : {0, 1}n \u2192 {0, 1} be a function of n bits. The\ndeterministic decision tree complexity of f , written D(f ), is the minimal number of queries\nto the input variables (x1 , . . . , xn ) that are necessary to evaluate f (x) with certainty, for any\ninput x. A somewhat less familiar complexity measure is the parity decision tree complexity\nD \u2295 (f ). This is the minimum number of queries necessary to compute f (x) with certainty on\nany input x, where each query the algorithm makes is the parity of any subset of the n bits\nof f 's input. Note that D \u2295 (f ) can be considerably smaller than D(f ); a trivial example is\ngiven by taking f to be the parity function on n bits, where D(f ) = n, but D \u2295 (f ) = 1. This\nmodel was previously studied by Kushilevitz and Mansour [14], who showed that functions\nwith low parity decision tree complexity can be learnt efficiently from membership queries.\nA boolean function is a function on the boolean cube {0, 1}n that takes one of at most\ntwo values on all inputs. When studying the query or communication complexity of boolean\nfunctions, we are free to relabel these values, as of course this choice makes no difference\nto the complexity. In particular, we say that both f : {0, 1}n \u2192 {0, 1} and f \u2032 : {0, 1}n \u2192\n{1, \u22121} are boolean functions. Any boolean function f : {0, 1}n \u2192 {0, 1} can be written\nuniquely as a multilinear polynomial in n variables over F2 ; deg2 (f ) denotes the degree of\nthis polynomial. The sensitivity of a boolean function f , written s(f ), is defined as the\nmaximum, over all bit strings x, of the number of neighbours y of x such that f (y) 6= f (x).\n1.1.2\n\nCommunication complexity\n\nWe study several standard models of communication complexity (see the book [15] for\nfurther details). In all models, two parties (Alice and Bob) each receive n-bit strings x,\ny (respectively), and share a string of public random bits. Their goal is to compute some\nboolean function g(x, y) using the minimum amount of communication. The matrix Mxy =\ng(x, y) is known as the communication matrix of g.\nThe communication complexity of g in a given model is the total number of bits that\nare required to be transmitted to compute g. In the two-way model of communication\ncomplexity, Alice and Bob take it in turns to send bits to each other; we will assume that\nAlice speaks first and Bob has to output g(x, y). Define D cc (g) to be the mininum total\nnumber of bits required to be transmitted for any classical deterministic protocol to compute\ng(x, y) on any input. Similarly, let R2cc (g) denote the number of bits required in the worst\ncase for any classical randomised protocol to compute g(x, y) with success probability at\nleast 2/3 on every input (the \"2\" refers to 2-sided error).\nThere are quantum generalisations of these models, in which Alice and Bob are allowed\nto send and receive qubits (quantum bits) [29, 12]. We also allow them to share an arbitrary\nprior entangled quantum state. The total number of qubits required to be transmitted\nbetween Alice and Bob for them to compute g exactly and with bounded error will be\ncc\ndenoted by Qcc\nE (g) and Q2 (g), respectively. See [26] for a good introduction to quantum\n4\n\n\fcommunication complexity.\nTwo more restricted scenarios we consider are the one-way and simultaneous message\npassing (SMP) models. In the one-way model, Alice sends a single message to Bob, who must\nthen use this message and his own input to evaluate g(x, y). The bounded-error classical and\nquantum complexities in this model will be denoted by R21 (g), Q12 (g), respectively. A more\nrestricted setting still is the SMP model. Here, Alice and Bob each send a single message\nto a referee, who performs some computation on the messages and outputs g(x, y). The\nk,pub\nrandomised communication complexity of g in this model is denoted by R2 (g); note that,\nin this paper, we assume that Alice and Bob are still allowed to share public randomness,\nwhich the referee can also see.\n1.1.3\n\nFourier analysis\n\nWe will make heavy use of some basic ideas from the field of Fourier analysis on the group Zn2\n(see [18] or [27] for excellent introductions to this area). Let [n] denote the set {1, . . . , n}.\nThen for any Ppositive integer n, the set of 2n parity functions \u03c7S : {0, 1}n \u2192 {1, \u22121},\n\u03c7S (x) = (\u22121) i\u2208S xi , which are indexed by subsets of [n], are known as the characters of\nthe group Zn2 . Let f : {0, 1}n \u2192 R be a function on the boolean cube. Then the Fourier\ncoefficients of f are the set of coefficients, indexed by subsets S \u2286 [n],\n1\nf\u02c6(S) = n\n2\n\nX\n\n\u03c7S (x)f (x).\n\nx\u2208{0,1}n\n\nThe p-norms of f on the Fourier side are defined as\n\uf8eb\n\nkf\u02c6kp = \uf8ed\n\nX\n\nS\u2286[n]\n\n\uf8f61/p\n\n|f\u02c6(S)|p \uf8f8\n\n,\n\nwith the special cases kf\u02c6k0 = | supp f\u02c6| (where supp f\u02c6 denotes the set {S : f\u02c6(S) 6= 0}),\nkf\u02c6k\u221e = maxS |f\u02c6(S)|; of course, the former is not actually a norm. The norm kf\u02c6k1 is known\nas the spectral norm of f . Parseval's equality states that\nkf\u02c6k22 =\n\n1\n2n\n\nX\n\nf (x)2 .\n\nx\u2208{0,1}n\n\nWe frequently identify n-bit strings with their corresponding subsets of [n] (that is, if x is an\nn-bit string, and S is the subset of [n] whose characteristic vector is x, then f\u02c6(x) = f\u02c6(S)).\nThe notation f\u02c6\u2206T denotes the function whose Fourier coefficients are all shifted by T :\n(f\u02c6\u2206T )(S) = f\u02c6(S\u2206T ), with S\u2206T denoting the symmetric difference of the sets S and T .\nSimilarly define f \u2295y (x) = f (x \u2295 y). One can easily verify that \u03c7S\u2206T (x) = \u03c7S (x)\u03c7T (x) for\nany S, T , and similarly \u03c7S (x \u2295 y) = \u03c7S (x)\u03c7S (y). The Fourier dimensionality of f , dim f ,\nis the smallest k such that the Fourier spectrum of f lies in a k-dimensional subspace of\n{0, 1}n . Finally, note that when we consider the Fourier transform of a boolean function f ,\nwe will always assume that f is given in the form f : {0, 1}n \u2192 {1, \u22121}.\n5\n\n\f1.1.4\n\nLinear threshold functions\n\nWe give some assumptions and definitions related to LTFs. Let f be an LTF as in eqn.\n(1). In general, the weights {wi } may be negative, and hence f may not be monotone but\nonly locally monotone (or unate). However, for the purposes of understanding query and\ncommunication complexity, it suffices to assume that the weights are indeed positive, as this\nmay be simulated by local complementation of the individual bits. We also assume that the\nweights are given in non-increasing order, i.e. w1 \u2265 w2 \u2265 * * * \u2265 wn . Define mj , where j = 0\nor j = 1, as\nn\nX\nwi zi \u2212 \u03b8 ,\nmj = min\nz,f (z)=j\n\ni=1\n\nand define the margin of f as m = min {m0 , m1 }. We assume that there is no x such that\nP\nn\ni=1 wi xi = \u03b8, so the margin is strictly positive.\n\n1.2\n\nStatement of results\n\nNow we are equipped with definitions, the main results that we obtain can be stated concisely as follows.\n\u2022 Section 2.1: If g is an XOR function, then D cc,1 (g) = Qcc,1\nE (g) = dim f .\n\u2022 Section 2.2: For any positive integer m, there is an XOR function g such that D cc (g) =\nO(m), but Q12 (g) = \u03a9(2m ).\n\u2022 Section 2.3: For any XOR function g, D cc (g) = O(Qcc\nE (g)), if the following conjecture\nholds: For any boolean function f , there exists a subset T \u2286 [n] such that | supp(f\u02c6) \u2229\nsupp(f\u02c6\u2206T )| \u2265 Kkf\u02c6k0 , for some constant 0 < K < 1.\n\u2022 Section 3: Let g(x, y) = f (x \u2295 y) be an XOR function. Then Rk,pub (g) = O(kf\u02c6k21 ),\nand also Rk,pub (g) = O(log(2n\u22121 (1 \u2212 kf\u02c6k\u221e ))). The former result is a special case of a\ntheorem of Grolmusz [7]; we give a simplified proof.\n\u2022 Section 4: Let g(x, y) = f (x \u2295 y) be an XOR function. If f is monotone, then\n2\ncc\nD cc (g) = O(Qcc\nE (g) ). If f is an LTF and depends on n bits, then QE (g) = \u03a9(n).\n\u2022 Section 4.2: Let g(x, y) = f (x \u2295 y) be an XOR function where f is an LTF with\nmargin m and threshold \u03b8. Then Rk,pub (g) = O((\u03b8/m)2 ).\nWe now turn to proving these results.\n\n2\n2.1\n\nCommunication complexity of general XOR functions\nDeterministic one-way communication complexity\n\nWe begin by noting that the deterministic one-way communication complexity of all XOR\nfunctions has a simple characterisation.\n6\n\n\fProposition 1. Let g(x, y) = f (x \u2295 y) be an XOR function. Then\nD cc,1 (g) = Qcc,1\nE (g) = dim f.\nProof. It is well-known [15] that D cc,1 (g) = \u2308log2 nrows(g)\u2309, where nrows(g) denotes the\nnumber of distinct rows in the communication matrix of g, and Klauck showed that the\nsame is true for deterministic one-way quantum communication [9]. Now it holds that\nnrows(g) =\n\nX\n\n1\n\nx\u2208{0,1}n\n\n=\n\n|{y : f \u2295x = f \u2295y }|\n\n2n\n\n|{y : f \u2295y = f }|\n\n=\n\n=\n\nX\n\nx\u2208{0,1}n\n2n\n\n1\n|{y : f \u2295(x\u2295y) = f }|\n\n|{y : hy, si = 0 \u2200s \u2208 supp f\u02c6}|\n\n= 2dim f ,\nwhere in the penultimate equality we use the fact (which follows easily from Fourier duality)\nthat f = f \u2295y if and only if the function \u03c7y * f\u02c6 = f\u02c6. This implies that there is no s \u2208 supp f\u02c6\nsuch that hy, si = 1, where the inner product is taken over Fn2 .\n\n2.2\n\nSeparation between one-way and two-way communication complexity\n\nWe now establish that there can be an exponential gap between the one-way (quantum,\nbounded-error) and two-way (classical, deterministic) communication complexity of XOR\nfunctions3 , using a VC-dimension argument. The VC-dimension of a matrix M , VC-dim(M ),\nis the largest k such that there exists a 2k \u00d7 k submatrix M \u2032 of M whose rows are all distinct. It was previously shown by Klauck [10] that VC-dimension gives a lower bound on\nbounded-error quantum communication complexity:\nTheorem 2 (Klauck [10]). Let M be the communication matrix of some function f . Then\nQ12 (f ) = \u03a9(VC-dim(M )).\nWe have the following proposition.\nProposition 3. Let x be an (m + 2m )-bit string divided into an m-bit \"address\" register a,\nand a 2m -bit \"data\" register d. Let f (x) be the addressing function, which returns the data\nbit at a given address: f (x) = da . Finally, let g be the XOR function g(x, y) = f (x \u2295 y).\nThen D cc (g) = O(m), but Q12 (g) = \u03a9(2m ).\nProof. For the upper bound, note that D(f ) = m + 1: a decision tree for f can just evaluate\nthe m address bits, followed by the one relevant data bit. For the lower bound, we will\nshow that VC-dim(M ) \u2265 2m , with the result following from Theorem 2. Let Sx be the set\nm\nm\n{(a, 02 )} for a \u2208 {0, 1}m , and let Sy be the set {(0m , d)} for d \u2208 {0, 1}2 . For all pairs of\n2m -bit strings d 6= d\u2032 , there exists an a such that da 6= d\u2032a . Thus, for all y 6= y \u2032 \u2208 Sy , there\nis an x \u2208 Sx such that f (x \u2295 y) 6= f (x \u2295 y \u2032 ), implying that VC-dim(M ) \u2265 2m .\n3\n\nNote that this is a stronger separation than between quantum and randomised communication complex-\n\nity.\n\n7\n\n\fMany of the most efficient known communication protocols for XOR functions require\nonly one-way communication [8, 24], and indeed it was left as an open question in [24]\nwhether all symmetric functions could be computed optimally using a one-way protocol.\nThe above proposition implies that this cannot be true in a more general setting.\n\n2.3\n\nParity decision trees and Fourier spectra\n\nWe turn to the question of finding classical upper bounds, and quantum lower bounds, on the\ntwo-way deterministic communication complexity of XOR functions. This is where Fourier\nanalysis becomes very useful, in particular because of the following natural observation,\nwhich appears to have first been written down by Shi and Zhang [24].\nObservation 4. Let g(x, y) = f (x \u2295 y) be an XOR function. Then D cc (g) \u2265 log2 kf\u02c6k0 and\n1\n\u02c6\nQcc\nE (g) \u2265 2 log2 kf k0 .\nProof. Assume f is a function on n bits, and let M be the communication matrix of g.\nThen it is easy to see that M is diagonalised by the Fourier transform over Zn2 , and the\neigenvalues of M are given by f 's Fourier coefficients, scaled appropriately. Indeed, letting\nF denote the matrix of this Fourier transform in the usual basis indexed by n-bit strings,\nFxy = (\u22121)hx,yi (with the inner product being taken over Fn2 ), we have\n1\n(F M F )xy =\n2n\n\n1\n2n\n\n=\n\n1\n2n\n\nX\n\nFxu Muv Fvy =\n\nu,v\u2208{0,1}n\n\nX\n\nw\u2208{0,1}n\n\nf (w)\n\nX\n\n1\n2n\n\nX\n\n(\u22121)hx,ui+hv,yi f (u \u2295 v)\n\nu,v\u2208{0,1}n\n\n(\u22121)hx,ui+h(w\u2295u),yi =\n\nu\u2208{0,1}n\n\nX\n\nf (w)(\u22121)hw,yi \u03b4xy ,\n\nw\u2208{0,1}n\n\nwhich is equal to 2n f\u02c6(x) if x = y, and 0 otherwise. So the rank of M is equal to kf\u02c6k0 . The\nobservation now follows from known results lower bounding the classical [16] and quantum\n[2, 17] communication complexity of a function by the log of the rank of its communication\nmatrix.\nIn the other direction, the following observation gives a natural way of finding upper\nbounds on the deterministic communication complexity of XOR functions.\nObservation 5. Let g(x, y) = f (x \u2295 y) be an XOR function. Then D cc (g) \u2264 2D \u2295 (f ).\nProof. Given a parity decision tree for f that uses at most D \u2295 (f ) queries on any input,\na communication protocol for g can be obtained as follows. Each query to\nL a subset S of\nthe bits of the string x \u2295 y can beLsimulated by Alice sending the parity i\u2208S xi to Bob,\nwho\ni\u2208S yi . This clearly enables each of them to compute\nL reciprocates by sending her\ni\u2208S (xi \u2295 yi ).\nTherefore, it would suffice to prove the following conjecture to show that quantum and\nclassical communication complexity of XOR functions is polynomially related.\n\n8\n\n\fConjecture 6. Let f : {0, 1}n \u2192 {1, \u22121} be a boolean function. Then\nD \u2295 (f ) = O(polylog(kf\u02c6k0 )).\nIt appears to be fairly difficult to reason about parity decision trees. We now give a\nconjecture which is merely about the structure of the Fourier spectrum of boolean functions\nand which, if true, would imply Conjecture 6.\nConjecture 7. Let f : {0, 1}n \u2192 {1, \u22121} be a boolean function. Then there exist universal\nconstants C, 0 < K < 1 such that, if kf\u02c6k0 > C, there exists a subset T \u2286 [n] such that\n| supp(f\u02c6) \u2229 supp(f\u02c6\u2206T )| \u2265 Kkf\u02c6k0 .\nIn order to show that Conjecture 7 does indeed imply Conjecture 6, we will need the\nfollowing lemma.\nLemma 8. Let f : {0, 1}n \u2192 R be some function on the boolean cube, and let T \u2286 [n] be\narbitrary. Define the function g by\n\u001a\nf (x)\n[\u03c7T (x) = r]\ng(x) =\nf (x \u2295 t) [\u03c7T (x) = \u2212r],\nfor some t such that \u03c7T (t) = \u22121, and some r = \u00b11. Then g(x) = f (x) wherever \u03c7T (x) = r,\nand for all S, \u011d(S) = 12 ((1 + \u03c7S (t)))(f\u02c6(S) + r f\u02c6(S\u2206T )). In particular, for all S such that\n\u03c7S (t) = \u22121, \u011d(S) = 0.\nProof. The fact that g(x) = f (x) wherever \u03c7T (x) = r is immediate; we now prove the\nsecond claim. We have\n\uf8f6\n\uf8eb\nX\n1 \uf8ed X\n\u011d(S) =\nf (x)\u03c7S (x) +\nf (x + t)\u03c7S (x)\uf8f8\n2n\nx,\u03c7T (x)=r\nx,\u03c7T (x)=\u2212r\n\uf8f6\n\uf8eb\nX\n1 \uf8ed X\n=\n(1 + r\u03c7T (x))f (x)\u03c7S (x) +\n(1 \u2212 r\u03c7T (x))f (x + t)\u03c7S (x)\uf8f8\n2 * 2n\nn\nn\nx\u2208{0,1}\nx\u2208{0,1}\n\uf8f6\n\uf8eb\nX\nX\n1 \uf8ed\n=\n(1 + r\u03c7T (x))f (x)\u03c7S (x) +\n\u03c7S (t)(1 + r\u03c7T (x))f (x)\u03c7S (x)\uf8f8\n2 * 2n\nn\nn\nx\u2208{0,1}\n\n=\n\n=\n\n(1 + \u03c7S (t))\n2 * 2n\n\nX\n\nx\u2208{0,1}\n\n(1 + r\u03c7T (x))f (x)\u03c7S (x)\n\nx\u2208{0,1}n\n\n\u0011\n(1 + \u03c7S (t)) \u0010 \u02c6\n\u02c6\nf (S) + r f(S\u2206T\n) ,\n2\n\nwhich is clearly zero wherever \u03c7S (t) = \u22121.\n\nNow consider an algorithm which attempts to evaluate f (x) for some unknown input\nx by making a query to the parity of the bits in a subset T \u2286 [n], which is equivalent to\n9\n\n\fquerying the function \u03c7T (x). Given the knowledge that \u03c7T (x) = r, for r = \u00b11, in order\nto evaluate f (x), it suffices to evaluate g(x) for any function g of our choice, as long as\ng(x) = f (x) wherever \u03c7T (x) = r. That is, we can replace f with g.\nIf we pick g according to the procedure of Lemma 8, then as \u03c7T (t) = \u22121, for each S\neither \u011d(S) = 0, or \u011d(S\u2206T ) = 0. This implies that whatever the value of r, the number of\nnonzero Fourier coefficients of g is upper bounded by half of the number of subsets S where\neither f\u02c6(S) 6= 0 or f\u02c6(S\u2206T ) 6= 0; this quantity can be written down concisely as\n1\n1\nsupp(f\u02c6) \u222a supp(f\u02c6\u2206T ) = kf\u02c6k0 \u2212 supp(f\u02c6) \u2229 supp(f\u02c6\u2206T ) .\n2\n2\nSo, if there exists a subset T such that | supp(f\u02c6) \u2229 supp(f\u02c6\u2206T )| \u2265 Kkf\u02c6k0 , for some constant\n0 < K < 1, then k\u011dk0 will be at most a constant fraction of kf\u02c6k0 . If there exists such\na subset for all boolean functions, then after repeating this procedure O(log kf\u02c6k0 ) times\n(querying the parity of the bits in the best subset each time), f would be reduced to a\nconstant function. This would thus imply that D \u2295 (f ) = O(log kf\u02c6k0 ).\n\n3\n\nRandomised protocols for XOR functions\n\nIn this section we discuss randomised classical protocols for computing general XOR functions. The first protocol we give is efficient for functions whose spectral norm is low4 , while\nthe second is efficient for functions which are close to a parity function on some subset of\nthe bits. These protocols can be seen as two different generalisations of a protocol for computing the equality function (g(x, y) = 1 \u21d4 x = y), which satisfies both of these conditions.\nWe give a third (!) generalisation of this protocol in Section 4.2.\nProposition 9 (Grolmusz [7]). Let g(x, y) = f (x \u2295 y) be an XOR function with f :\n{0, 1}n \u2192 {1, \u22121}. Then Rk,pub (g) = O(kf\u02c6k21 ).\nProof. We give a variant of a protocol of Kremer, Nisan and Ron [13] for computing the\ninner product of two vectors, which will achieve the specified complexity. Using their shared\nrandomness, Alice and Bob pick k subsets {Si } from the family of subsets of [n], for some k\nto be determined, where the set S is picked with probability |f\u02c6(S)|/kf\u02c6k1 . For each subset\nSi , Alice sends the referee the bit \u03c7Si (x), and Bob sends the referee the bit \u03c7Si (y). The\nreferee uses these k bits to compute\nk\nX\n\n\u03c7Si (x)\u03c7Si (y) sgn(f\u02c6(Si )) =\n\nk\nX\n\n\u03c7Si (x \u2295 y) sgn(f\u02c6(Si )),\n\ni=1\n\ni=1\n\nand outputs 1 if the result is positive, and \u22121 if negative. To see correctness of this\nprotocol, note that for each i, \u03c7Si (x \u2295 y) sgn(f\u02c6(Si )) is a sample from a random variable\nwhose expectation is\nf (x \u2295 y)\n1 X\n\u03c7S (x \u2295 y)f\u02c6(S) =\n.\nkf\u02c6k1\nkf\u02c6k1\nS\u2286[n]\n\n4\n\nThis is a special case of a result of Grolmusz [7]; we give a simplified proof.\n\n10\n\n\fStandard Chernoff bound arguments thus give that the number of samples k required to\ndetermine whether f (x \u2295 y) > 0, with a constant probability of success, is O(kf\u02c6k21 ).\nOne can use the previous example of the addressing function to show that the above\nprotocol is close to optimal in terms of its dependence on the spectral norm, even among\nall one-way quantum protocols. Indeed, the addressing function with an m-bit address\nregister has spectral norm 2m , and by Proposition 3 has one-way quantum communication\ncomplexity \u03a9(2m ).\nThe second protocol rests on the following lemma.\nLemma 10. Let f : {0, 1}n \u2192 {1, \u22121} and f \u0303 : {0, 1}n \u2192 {1, \u22121} be boolean functions that\ndisagree on at most m inputs, and let g(x, y) = f (x \u2295 y) and g\u0303(x, y) = f \u0303(x \u2295 y) be the\ncorresponding XOR functions. Then Rk,pub (g\u0303) \u2264 Rk,pub (g) + O(log m).\nProof. Let S be the set of inputs z such that f (z) 6= f \u0303(z). We give a protocol in the SMP\nmodel with shared randomness that determines whether (x \u2295 y) \u2208 S, using O(log |S|) bits\nof communication. This clearly implies the lemma: to get a protocol for g\u0303, it suffices to\ncarry out the protocol for g, then check whether (x \u2295 y) \u2208 S, and if so, negate the result. In\norder to do this check, we use a simple generalisation of a well-known protocol for testing\nequality [15], which was also used by Gavinsky, Kempe and de Wolf [4] in their protocol for\ncomputing the Hamming distance. We give it explicitly for completeness.\nUsing their shared randomness, Alice and Bob create k n-bit strings {r1 , . . . , rk }, for\nsome k to be determined. Alice sends the referee the k-bit string a = (hx, r1 i, . . . , hx, rk i)\nthat lists their inner products with x over F2 , and Bob does the same with the string b =\n(hy, r1 i, . . . , hy, rk i). The referee outputs 1 if there is some z \u2208 S such that ai \u2295 bi = hz, ri i\nfor all i, and otherwise outputs \u22121. We have\nPr[ai \u2295 bi = hz, ri i] = Pr[hx \u2295 y, ri i = hz, ri i],\nwhich will equal 1 if x \u2295 y = z, and 1/2 otherwise. Thus the probability, for any given z \u2208 S\nwith x \u2295 y 6= z, that the referee incorrectly outputs 1 is 1/2k . Using a union bound over all\nz \u2208 S, it suffices to take k = O(log |S|) to achieve a constant probability of success.\nNote that the above lemma still holds for stronger models of communication (e.g. R2cc ,\nand that a similar result does not apparently hold for the communication complexity\nof general functions. It is now straightforward to see the following proposition.\n\nR1 ),\n\nProposition 11. Let g(x, y) = f (x \u2295 y) be an XOR function with f : {0, 1}n \u2192 {1, \u22121}.\nAssume that there is some parity function \u03c7T such that f disagrees with \u03c7T on m inputs.\nThen Rk,pub (g) = O(log m). In other words,\nRk,pub (g) = O(log(2n\u22121 (1 \u2212 kf\u02c6k\u221e ))).\nAs a special case, if f takes the value 1 (or the value \u22121) on at most m inputs, Rk,pub (g) =\nO(log m).\n\n11\n\n\fProof. It is clear that any function g(x, y) = \u03c7T (x \u2295 y), with T nonempty, has Rk,pub (g) = 2\n(by a protocol where Alice and Bob each send the referee the parity of the bits of their\ninputs in the set T ). The result follows from Lemma 10.\n\n4\n\nCommunication complexity of monotone functions\n\nWe now show that the two-way deterministic communication complexity of monotone XOR\nfunctions is almost determined by the rank. We will need the following lemma relating\nsensitivity and degree over F2 ; the proof is essentially the same as a previously known\nresult relating sensitivity and degree over R [3].\nLemma 12. Let f : {0, 1}n \u2192 {0, 1} be a monotone boolean function. Then s(f ) \u2264 deg2 (f ).\nProof. It is well known (see [1, Lemma 3], for example) that the degree of f over F2 is\nprecisely the size of the largest subfunction of f that takes the value 1 on an odd number\nof inputs. Now consider a point x that achieves maximal sensitivity, i.e. f (y) 6= f (x) for\nexactly s(f ) neighbours y of x. Assume wlog f (x) = 1. Now, by the monotonicity of\nf , all the points z in the subcube traced out by x and all the neighbours y must have\nf (z) = 0 (of the points in this subcube, x must have maximal Hamming weight; for each y\nneighbouring x, f (y) = 0; and all other points in this subcube must have lower Hamming\nweight). So f takes the value 1 on exactly one point in this dimension s(f ) subcube, so\ndeg2 (f ) \u2265 s(f ).\nProposition 13. Let f : {0, 1}n \u2192 {0, 1} be a monotone boolean function. Define g(x, y) =\nf (x \u2295 y). Then D cc (g) \u2264 4(log2 kf\u02c6k0 )2 = 4(log2 rank g)2 .\nProof. The result follows from\nD cc (g) \u2264 2D(f ) \u2264 4s(f )2 \u2264 4 deg2 (f )2 \u2264 4(log 2 kf\u02c6k0 )2 .\nThe inequalities are proven in order, as follows. For the first, if Alice and Bob have a\ndecision tree for f , they can use it to compute g with only an overhead of a factor of 2 [15].\nThe second is proven as Corollary 5 of [3], while the third inequality follows from Lemma\n12. The fourth is Lemma 3 of [1] (or see [6, eqn. (2)]).\n\nThis proposition immediately implies the following corollary.\nCorollary 14. Let f : {0, 1}n \u2192 {0, 1} be a monotone boolean function. Define g(x, y) =\n2\nf (x \u2295 y). Then D cc (g) \u2264 16 Qcc\nE (g) .\n\n4.1\n\nLower bounds on communication complexity of LTFs\n\nWe turn to a class of XOR functions that is more specialised still: those based on linear\nthreshold functions. We will see that the deterministic communication complexity of these\nfunctions is always \u03a9(n). We will need the following lemma, which does not appear to have\nbeen noted previously in the literature.\n12\n\n\fLemma 15. Let f be an LTF that depends on n bits. Then s(f ) \u2265 \u2308(n + 1)/2\u2309, and this\nresult is best possible.\nProof. Write the weights in non-increasing order, w1 \u2265 * * * \u2265 wn . Then, as f depends on\nall n variables, there exists an assignment to the bits x1 , . . . , xn\u22121 such that\nn\u22121\nX\n\nwi xi + wn > \u03b8,\n\ni=1\n\nbut\n\nn\u22121\nX\n\nwi xi < \u03b8.\n\ni=1\n\nCall this assignment (z1 , . . . , zn\u22121 ). As wn is the smallest of the weights, flipping any of\nthe bits of the string z 0 = (z1 , . . . , zn\u22121 , 0) from 0 to 1 will change the value of f , as will\nflipping any of the bits of the string z 1 = (z1 , . . . , zn\u22121 , 1) from 1 to 0. Thus s(f ) is lower\nbounded by the maximum of {n \u2212 |z 0 |, |z 1 |}, which is at least \u2308(n + 1)/2\u2309. The Majority\nfunction has sensitivity \u2308(n + 1)/2\u2309 and demonstrates that this result is best possible.\nProposition 16. Let f be an LTF that depends on n bits, and set g(x, y) = f (x \u2295 y). Then\nD cc (g) \u2265 \u2308(n + 1)/2\u2309 and Qcc\nE (f ) \u2265 \u2308(n + 1)/4\u2309.\nProof. In the proof of Proposition 13 it was shown that, if f is monotone, log2 rank(g) \u2265\ns(f ). The present proposition now follows from Lemma 15 and known results lower bounding classical [16] and quantum [2, 17] communication complexity by the log of the rank of\ng.\n\n4.2\n\nUpper bounds on communication complexity of LTFs\n\nThe final result of this paper is an upper bound on the randomised classical communication\ncomplexity of LTFs, derived by giving an explicit protocol for such functions in the SMP\nmodel with shared randomness. Formally, we have the following result.\nProposition 17. Let g(x, y) = f (x \u2295 y), where f is an LTF with threshold \u03b8 and margin\nm. Then Rk,pub (g) = O((\u03b8/m)2 ).\nOur protocol can be seen as a generalisation of Yao's protocol for the Hamming distance function [30], which in turn can be understood as a generalisation of the well-known\nconstant-communication protocol for computing equality of two bit strings. It proceeds as\nfollows.\n1. Alice and Bob use their shared randomness to generate k = O((\u03b8/m)2 ) n-bit strings\nr1 , . . . , rk , where the i'th bit of each string rj is equal to 1 with probability pi , for\nsome probabilities {pi } which will be determined later.\n\n13\n\n\f2. For each j, Alice and Bob each compute the bits aj = hrj , xi and bj = hrj , yi (respectively), where the inner product is taken over Fn2 , and each send the resulting k bits\nto the referee.\nP\n3. The referee computes s = k1 kj=1 (aj \u2295 bj ) and outputs 1 if\n1\ns>\n2\n\n\u0012\n\n\u0011\u0013\n1\u0010\n\u03b8\u2212m0\n\u03b8+m1\n(1 \u2212 1/\u03b8)\n+ (1 \u2212 1/\u03b8)\n.\n1\u2212\n2\n\nwhere m0 , m1 are defined as in Section 1.1.4, and we assume that m0 , m1 , and \u03b8 are\nall greater than 1, rescaling if necessary.\nWe now prove that there is a choice of {pi } such that this protocol succeeds with constant\nprobability. We will need the following lemma.\nLemma 18. Let x be an arbitrary n-bit string, and let r be a randomly generated n-bit\nstring such that Pr[ri = 1] = pi for some {pi }. Then\n!\nn\nY\n1\n(1 \u2212 2 pi xi ) .\n1\u2212\nPr[hr, xi = 1] =\nr\n2\ni=1\n\nL\nProof. For 1 \u2264 k \u2264 n, define Qk = Prr [ ki=1 ri xi = 1]. Then, for 2 \u2264 k \u2264 n,\n\nk\u22121\nk\u22121\nM\nM\nri xi = 1](1 \u2212 Pr[rk xk = 1])\nri xi = 1]) Pr[rk xk = 1] + Pr[\nQk = (1 \u2212 Pr[\nr\n\ni=1\n\nr\n\nr\n\ni=1\n\nr\n\n= Qk\u22121 (1 \u2212 2pk xk ) + pk xk ,\n\nand also Qn = Prr [hr, xi = 1]. Now the lemma follows by induction on k, noting that the\nbase case\n!\n1\nY\n1\nQ 1 = p 1 x1 =\n(1 \u2212 2pi xi ) .\n1\u2212\n2\ni=1\n\nNow the central idea behindP\nour approach is as follows. Consider\nP the string z = x \u2295 y.\nThe referee needs to output 1 if ni=1 wi zi > \u03b8. He does not know ni=1 wi zi , but if we pick\npi to be small and proportional to wi , the quantity\nn\nY\n\n(1 \u2212 2 pi zi ) ,\n\ni=1\n\nP\nwhich the referee can estimate using Lemma 18, should give an estimate of ni=1 wi zi , as\nthe first order terms are proportional to this sum. We will not in fact quite do this, but\nwill do something easier to analyse. If we pick\npi =\n\n1\n(1 \u2212 (1 \u2212 2\u03b1)wi ) ,\n2\n14\n\n\ffor some constant 0 \u2264 \u03b1 \u2264 1 to be determined, we get\n!\nn\n\u0011\nPn\nY\n1\u0010\n1\nw i zi\n=\n(1 \u2212 2\u03b1)\n1\u2212\n1 \u2212 (1 \u2212 2\u03b1) i=1 wi zi .\nPr[hr, zi = 1] =\nr\n2\n2\n\n(2)\n\ni=1\n\nP\nWrite v = ni=1 wi zi . Our task is now to choose a value for \u03b1 that makes the two cases\nv < \u03b8, v > \u03b8 easy to distinguish. As the most difficult cases to distinguish will be when\nv \u2248 \u03b8, we achieve this by choosing \u03b1 to maximise the absolute value of the derivative\nd 1\n1\n(1 \u2212 (1 \u2212 2\u03b1)v ) = \u2212 (1 \u2212 2\u03b1)v ln(1 \u2212 2\u03b1),\ndv 2\n2\nevaluated at v = \u03b8. For 0 < \u03b1 < 1/2 this derivative is positive, and we have\n\u0013\n\u0012\nd\n1\n\u2212 (1 \u2212 2\u03b1)\u03b8 ln(1 \u2212 2\u03b1) = (1 \u2212 2\u03b1)\u03b8 (1 + \u03b8 ln(1 \u2212 2\u03b1)).\nd\u03b1\n2\nSetting this expression equal to 0 and solving for \u03b1 gives\n\u03b1=\n\n\u0011\n1\n1\u0010\n1 \u2212 e\u22121/\u03b8 \u2248 .\n2\n2\u03b8\n\nInserting this value for \u03b1 into eqn. (2), we obtain\nPr[hr, zi = 1] =\nr\n\n\u0011\nPn\n1\u0010\n1 \u2212 (1 \u2212 1/\u03b8) i=1 wi zi .\n2\n\nPn\nOur problem has therefore been reduced to determining whether\ni=1 wi zi > \u03b8, using\nsamples from this distribution. The remainder of the proof is a standard Chernoff bound\nargument. Let X denote the sum of k i.i.d. random variables Xi , which take values in {0, 1},\nwith Pr[Xi = 1] = \u03bc. Then the inequality\nPr[|X \u2212 k\u03bc| > \u03b4] < 2e\u2212\u03b4\n\n2 /4k\u03bc\n\nholds, implying that one can distinguish two different distributions with means \u03bc, \u03bc\u2032 , where\n|\u03bc \u2212 \u03bc\u2032 | \u2265 \u01eb, with O(1/\u01eb2 ) samples from Xi .\nP\nRecall that | ni=1 wi zi \u2212 \u03b8| \u2265 m for all z. Thus, for any z, z \u2032 such that f (z) 6= f (z \u2032 ),\nwe have\n\u0011\n1\u0010\n| Pr[hr, zi = 1] \u2212 Pr[hr, z \u2032 i = 1]| \u2265\n(1 \u2212 1/\u03b8)\u03b8\u2212m \u2212 (1 \u2212 1/\u03b8)\u03b8+m\nr\nr\n2\n\u0001\n1\n=\n(1 \u2212 1/\u03b8)\u03b8 (1 \u2212 1/\u03b8)\u2212m \u2212 (1 \u2212 1/\u03b8)m\n2\n= \u03a9(m/\u03b8),\n2\nwhich implies that it suffices\nPn for the referee to take O((\u03b8/m) ) samples from the distribution\nto determine whether i=1 wi zi > \u03b8 with constant probability. The threshold value picked\nin the protocol is simply halfway between the two worst-case values of z.\n\n15\n\n\f5\n\nConclusions\n\nWe have presented a number of partial results on the communication complexity of XOR\nfunctions, but the initial question still remains: are the quantum and classical communication complexities of XOR functions polynomially related? We believe that the class of\nXOR functions is of particular interest in the context of communication complexity because\nof the connection to Fourier analysis of boolean functions, and remain hopeful that this\nconjecture is tractable. The little-studied classical model of parity decision tree complexity\nalso appears to be of some interest in its own right; the connection with the \"width\" of the\nFourier spectrum is an interesting contrast to the usual decision tree complexity, which is\npolynomially related to the \"height\" (degree) of the Fourier spectrum.\nA final question: can the protocol of Section 4.2 be improved to use, for example,\nO((\u03b8/m) log(\u03b8/m)) communication, in a similar way to Huang et al's protocol for the Hamming distance problem [8]?\n\nAcknowledgements\nAM was supported by the EC-FP6-STREP network QICS and an EPSRC Postdoctoral\nResearch Fellowship, and would like to thank Aram Harrow and Rapha\u00ebl Clifford for helpful\ncomments on a previous version.\n\nReferences\n[1] A. Bernasconi and B. Codenotti. Spectral analysis of Boolean functions as a graph\neigenvalue problem. IEEE Transations on Computers, 48(3):345\u2013351, 1999.\n[2] H. Buhrman and R. de Wolf. Communication complexity lower bounds by polynomials.\nIn Proc. 16th Annual IEEE Conf. Computational Complexity, pages 120\u2013130, 2001.\ncs.CC/9910010.\n[3] H. Buhrman and R. de Wolf. Complexity measures and decision tree complexity: a\nsurvey. Theoretical Computer Science, 288:21\u201343, 2002.\n[4] D. Gavinsky, J. Kempe, and R. de Wolf. Quantum communication cannot simulate a\npublic coin, 2004. quant-ph/0411051.\n[5] D. Gavinsky, J. Kempe, I. Kerenidis, R. Raz, and R. de Wolf. Exponential separations for one-way quantum communication complexity, with applications to cryptography. In Proc. 39th Annual ACM Symp. Theory of Computing, pages 516\u2013525, 2007.\nquant-ph/0611209.\n[6] P. Gopalan, R. O'Donnell, R. A. Servedio, A. Shpilka, and K. Wimmer. Testing\nFourier dimensionality and sparsity. In Proc. International Conference on Automata,\nLanguages and Programming 2009 (ICALP'09), 2009.\n\n16\n\n\f[7] V. Grolmusz. On the power of circuits with gates of low L1 norm. Theoretical Computer\nScience, 188:117\u2013128, 1997.\n[8] W. Huang, Y. Shi, S. Zhang, and Y. Zhu. The communication complexity of the\nHamming distance problem. Information Processing Letters, 99(4):149\u2013153, 2006.\nquant-ph/0509181.\n[9] H. Klauck. On quantum and probabilistic communication: Las Vegas and one-way\nprotocols. In Proc. 32nd Annual ACM Symp. Theory of Computing, pages 644\u2013651.\nACM, 2000.\n[10] H. Klauck. Lower bounds for quantum communication complexity. In Proc.\n42nd Annual Symp. Foundations of Computer Science, pages 288\u2013297. IEEE, 2001.\nquant-ph/0106160.\n[11] H. Klauck. Lower bounds for quantum communication complexity. SIAM J. Comput.,\n37(1):20\u201346, 2007. quant-ph/0106160.\n[12] I. Kremer. Quantum communication. Master's thesis, Hebrew University, 1995.\n[13] I. Kremer, N. Nisan, and D. Ron. On randomized one-round communication complexity. Computational Complexity, 8:21\u201349, 1999.\n[14] E. Kushilevitz and Y. Mansour. Learning decision trees using the Fourier spectrum.\nIn Proc. 23rd Annual ACM Symp. Theory of Computing, pages 455\u2013464, 1991.\n[15] E. Kushilevitz and N. Nisan. Communication Complexity. Cambridge University Press,\n1997.\n[16] K. Mehlhorn and E. Schmidt. Las Vegas is better than determinism in VLSI and\ndistributed computing. In Proc. 14th Annual ACM Symp. Theory of Computing, pages\n330\u2013337, 1982.\n[17] M. A. Nielsen. Quantum information theory. PhD thesis, University of New Mexico,\nAlbuquerque, 1998. quant-ph/0011036.\n[18] R.\nO'Donnell.\n15-859S:\nAnalysis\nof\nboolean\nhttp://www.cs.cmu.edu/~odonnell/boolean-analysis/.\n\nfunctions,\n\n2007.\n\n[19] R. Raz. Exponential separation of quantum and classical communication complexity.\nIn Proc. 31st Annual ACM Symp. Theory of Computing, pages 358\u2013367, 1999.\n[20] A. A. Razborov. Quantum communication complexity of symmetric predicates.\nIzvestiya of the Russian Academy of Science, 67:145\u2013159, 2003. quant-ph/0204025.\n[21] M. Saks. Slicing the hypercube. In Surveys in Combinatorics, pages 211\u2013255, 1993.\n[22] A. Sherstov. The pattern matrix method for lower bounds on quantum communication.\nIn Proc. STOC'08, pages 85\u201394, 2008.\n\n17\n\n\f[23] A. Sherstov. On quantum-classical equivalence for composed communication problems,\n2009. arXiv:0906.1399.\n[24] Y. Shi and Z. Zhang. Communication complexities of symmetric XOR functions. Quantum Inf. Comput., 9:255\u2013263, 2009. arXiv:0808.1762.\n[25] Y. Shi and Y. Zhu. Quantum communication complexity of block-composed functions,\n2008. arXiv:0710.0095.\n[26] R. de Wolf. Quantum communication and complexity. Theoretical Computer Science,\n287(1):337\u2013353, 2002.\n[27] R. de Wolf. A brief introduction to Fourier analysis on the boolean cube. Theory of\nComputing Library Graduate Surveys, 1:1\u201320, 2008.\n[28] A. Yao. Some complexity questions related to distributive computing. In Proc. 11th\nAnnual ACM Symp. Theory of Computing, pages 209\u2013213. ACM Press, 1979.\n[29] A. Yao. Quantum circuit complexity. In Proc. 34th Annual Symp. Foundations of\nComputer Science, pages 352\u2013361. IEEE, 1993.\n[30] A. Yao. On the power of quantum fingerprinting. In Proc. 35th Annual ACM Symp.\nTheory of Computing, pages 77\u201381. ACM Press, 2003.\n\n18\n\n\f"}