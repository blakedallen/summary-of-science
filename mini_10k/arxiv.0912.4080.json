{"id": "http://arxiv.org/abs/0912.4080v3", "guidislink": true, "updated": "2012-07-04T01:08:26Z", "updated_parsed": [2012, 7, 4, 1, 8, 26, 2, 186, 0], "published": "2009-12-21T04:56:03Z", "published_parsed": [2009, 12, 21, 4, 56, 3, 0, 355, 0], "title": "Windtalking Computers: Frequency Normalization, Binary Coding Systems\n  and Encryption", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0912.4085%2C0912.5177%2C0912.3804%2C0912.3693%2C0912.4961%2C0912.1688%2C0912.1891%2C0912.4755%2C0912.2711%2C0912.3870%2C0912.2425%2C0912.0540%2C0912.4047%2C0912.0147%2C0912.4730%2C0912.0959%2C0912.2798%2C0912.0671%2C0912.5432%2C0912.5008%2C0912.3613%2C0912.1279%2C0912.3847%2C0912.1017%2C0912.4333%2C0912.0550%2C0912.3591%2C0912.2656%2C0912.2805%2C0912.4726%2C0912.4647%2C0912.4228%2C0912.3209%2C0912.1901%2C0912.1532%2C0912.2196%2C0912.4913%2C0912.0216%2C0912.5025%2C0912.0259%2C0912.0876%2C0912.3967%2C0912.0159%2C0912.1743%2C0912.0190%2C0912.2728%2C0912.0180%2C0912.4943%2C0912.0995%2C0912.1393%2C0912.2955%2C0912.1778%2C0912.5268%2C0912.2646%2C0912.1128%2C0912.4080%2C0912.5483%2C0912.4732%2C0912.3200%2C0912.4738%2C0912.2945%2C0912.5120%2C0912.2633%2C0912.1673%2C0912.0188%2C0912.1683%2C0912.3329%2C0912.3128%2C0912.4908%2C0912.4197%2C0912.4008%2C0912.1498%2C0912.4884%2C0912.5109%2C0912.4498%2C0912.0214%2C0912.0858%2C0912.1320%2C0912.1472%2C0912.2061%2C0912.1823%2C0912.3881%2C0912.4323%2C0912.2880%2C0912.0704%2C0912.4495%2C0912.4874%2C0912.3084%2C0912.4731%2C0912.4953%2C0912.4264%2C0912.1011%2C0912.5361%2C0912.4518%2C0912.4435%2C0912.1659%2C0912.0270%2C0912.3550%2C0912.1030%2C0912.4969%2C0912.4190&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Windtalking Computers: Frequency Normalization, Binary Coding Systems\n  and Encryption"}, "summary": "This paper discusses the application of known techniques, knowledge and\ntechnology in a novel way for encryption. Two distinct and separate methods are\npresented.\n  Method 1: Alter the symbol set of the language by adding additional redundant\nsymbols for frequent symbols. This will reduce the high frequency of more\ncommonly used symbols. Hence, frequency analysis upon ciphertext will not be\npossible. Hence, decryption will be possible.\n  Method 2: Computers use binary base 2. Most encryption systems use ciphering\nto convert data to ciphertext. The author presents the theory and several\npossible implementations of a method for computers analogous to speaking\nanother language. This is done by using a binary base other than base 2. Ex.\nFibonacci, Phi or Prime.\n  In addition, steganography may be used for creating alternate binary bases.\n  This kind of encryption significantly increases the complexity of decryption.\nFirst the binary base must be known. Only then, can decryption begin.\n  This kind of encryption also breaks the transitivity of\nplaintext-codebook-binary; the correlation of letters-ASCII-base2. With this\ntransitivity broken, decryption is logically impossible. Coupled with\nencrypting the plaintext, binary encryption makes decryption uncrackable. It\nmay produce false positives--information theoretic secure, and requires much\nmore computing power to resolve than is currently used in brute force\ndecryption. Hence, the assertion that these combination of methods are\ncomputationally secure--impervious to brute force.\n  The proposed system has a drawback. It is not as compressed as a base2.\n(Similar to adding random padding to the encryption.) However, this is\nacceptable, since the goal is very strong encryption:\n  Both methods are not decryptable by method uncrackable - by conventional,\nstatistical means.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0912.4085%2C0912.5177%2C0912.3804%2C0912.3693%2C0912.4961%2C0912.1688%2C0912.1891%2C0912.4755%2C0912.2711%2C0912.3870%2C0912.2425%2C0912.0540%2C0912.4047%2C0912.0147%2C0912.4730%2C0912.0959%2C0912.2798%2C0912.0671%2C0912.5432%2C0912.5008%2C0912.3613%2C0912.1279%2C0912.3847%2C0912.1017%2C0912.4333%2C0912.0550%2C0912.3591%2C0912.2656%2C0912.2805%2C0912.4726%2C0912.4647%2C0912.4228%2C0912.3209%2C0912.1901%2C0912.1532%2C0912.2196%2C0912.4913%2C0912.0216%2C0912.5025%2C0912.0259%2C0912.0876%2C0912.3967%2C0912.0159%2C0912.1743%2C0912.0190%2C0912.2728%2C0912.0180%2C0912.4943%2C0912.0995%2C0912.1393%2C0912.2955%2C0912.1778%2C0912.5268%2C0912.2646%2C0912.1128%2C0912.4080%2C0912.5483%2C0912.4732%2C0912.3200%2C0912.4738%2C0912.2945%2C0912.5120%2C0912.2633%2C0912.1673%2C0912.0188%2C0912.1683%2C0912.3329%2C0912.3128%2C0912.4908%2C0912.4197%2C0912.4008%2C0912.1498%2C0912.4884%2C0912.5109%2C0912.4498%2C0912.0214%2C0912.0858%2C0912.1320%2C0912.1472%2C0912.2061%2C0912.1823%2C0912.3881%2C0912.4323%2C0912.2880%2C0912.0704%2C0912.4495%2C0912.4874%2C0912.3084%2C0912.4731%2C0912.4953%2C0912.4264%2C0912.1011%2C0912.5361%2C0912.4518%2C0912.4435%2C0912.1659%2C0912.0270%2C0912.3550%2C0912.1030%2C0912.4969%2C0912.4190&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "This paper discusses the application of known techniques, knowledge and\ntechnology in a novel way for encryption. Two distinct and separate methods are\npresented.\n  Method 1: Alter the symbol set of the language by adding additional redundant\nsymbols for frequent symbols. This will reduce the high frequency of more\ncommonly used symbols. Hence, frequency analysis upon ciphertext will not be\npossible. Hence, decryption will be possible.\n  Method 2: Computers use binary base 2. Most encryption systems use ciphering\nto convert data to ciphertext. The author presents the theory and several\npossible implementations of a method for computers analogous to speaking\nanother language. This is done by using a binary base other than base 2. Ex.\nFibonacci, Phi or Prime.\n  In addition, steganography may be used for creating alternate binary bases.\n  This kind of encryption significantly increases the complexity of decryption.\nFirst the binary base must be known. Only then, can decryption begin.\n  This kind of encryption also breaks the transitivity of\nplaintext-codebook-binary; the correlation of letters-ASCII-base2. With this\ntransitivity broken, decryption is logically impossible. Coupled with\nencrypting the plaintext, binary encryption makes decryption uncrackable. It\nmay produce false positives--information theoretic secure, and requires much\nmore computing power to resolve than is currently used in brute force\ndecryption. Hence, the assertion that these combination of methods are\ncomputationally secure--impervious to brute force.\n  The proposed system has a drawback. It is not as compressed as a base2.\n(Similar to adding random padding to the encryption.) However, this is\nacceptable, since the goal is very strong encryption:\n  Both methods are not decryptable by method uncrackable - by conventional,\nstatistical means."}, "authors": ["Givon Zirkind"], "author_detail": {"name": "Givon Zirkind"}, "author": "Givon Zirkind", "arxiv_comment": "33 pages; 5 Flowcharts; 12 Tables; Glossary Replaced to correct title\n  Replaced to add original date written", "links": [{"href": "http://arxiv.org/abs/0912.4080v3", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0912.4080v3", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "94A60, 14G50", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.2.11; E.0; E.3; E.m; F.2.0; F.2.1; F.2.2; F.2.m; H.0; H.1.0; H.1.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0912.4080v3", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0912.4080v3", "journal_reference": null, "doi": null, "fulltext": "Windtalking Computers:\nFrequency Normalization, Binary Coding Systems, and\nEncryption\nGivon Zirkind\nB.Sc., Computer Science, Touro\nCollege; M.Sc. Computer Science,\nFairleigh Dickinson University\n\ngivonz@hotmail.com\n\nABSTRACT\nThe goal of this paper is to discuss the application of known\ntechniques, knowledge and technology in a novel way, to\nencrypt computer and non-computer data. There are two\ndistinct and separate methods presented in this paper.\nMethod 1: Alter the symbol set of the language by adding\nadditional redundant symbols for frequent symbols. This will\nreduce the high frequency of more commonly used symbols.\nHence, frequency analysis upon ciphertext will not be possible.\nHence, neither will decryption be possible.\n\ndecryptions. Hence, my assertion that these combination of\nmethods are computationally secure-impervious to brute force.\nAs every methodology has its drawbacks, so too, the proposed\nsystem has its drawbacks. It is not as compressed as a base 2\nwould be.\n(Similar to adding random padding to the\nencryption.) However, this is manageable and acceptable, if the\ngoal is very strong encryption:\nAt least two of the general methods and their various\nimplementations herein proposed are not decryptable by method\n\u2013 uncrackable \u2013 by conventional, statistical means.\n\nMethod 2: [A prerequisite to understanding this method is to\nunderstand that there is a difference between a binary\nrepresentation and base 2.] To-date most computers use the\nbinary base 2 (base2) and most encryption systems use ciphering\nand/or an encryption algorithm, to convert data into a secret\nmessage. The method of having the computer \"speak another\nsecret language\" as used in human military secret\ncommunications has never been imitated. The author presents\nthe theory and several possible implementations of a method for\ncomputers for secret communications analogous to human\nbeings using a secret language or; speaking multiple languages.\nThis is done by using a binary base other than base 2. Ex.\nFibonacci, Phi or Prime.\n\nSpecifically:\n\nIn addition, steganography may be used for creating alternate\nbinary bases.\nThis has no mathematical resolution if\nimplemented with randomness.\n\nD.2.11 [Software]: Software Architectures \u2013 Data abstraction\nE.0 [Data]: General\nE.3 [Data]: Encryption\nE.3 [Data]: Encryption \u2013 Code Breaking\nE.m [Data]: Miscellaneous\nF.2.0 [Theory of Computation]: Analysis Of Algorithms And\nProblem Complexity \u2013 General\nF.2.1 [Theory of Computation]: Analysis Of Algorithms And\nProblem Complexity \u2013 Numerical Algorithms and Problems \u2013\nNumber-theoretic computations\nF.2.2 [Theory of Computation]: Analysis Of Algorithms And\nProblem Complexity \u2013 Nonnumerical Algorithms and Problems\n\u2013 Pattern matching\nF.2.m [Theory of Computation]: Miscellaneous\nH.0 [Information Systems]: General\nH.1.0 [Information Systems]: Models and Principles \u2013 General\n\nThis kind of encryption scheme proposed significantly increases\nthe complexity of and the effort needed for, decryption. First\nthe binary base must be known. Only then, can decryption\nbegin.\nThis kind of encryption also breaks the transitivity of plaintextcodebook-binary. Or, the correlation between letters-ASCIIbase2. With this transitivity broken, decryption is logically not\npossible. (This is discussed and explained in detail.)\nCoupled together with encrypting the plaintext, binary\nencryption makes decryption uncrackable, produces false\npositives-information theoretic secure, and requires much more\ncomputing power to resolve than is currently used in brute force\n\n1.\n2.\n\nCreation of new symbol sets is used to alter and\nconfound the natural symbol frequency.\nAlso, alternate binary encryptions other than binary\nbase 2 are used.\n\nUsing alternate binary encryptions lend easily to the creation of\nnew symbol sets and the confounding frequency analysis.\nAll rights reserved. Originally Written April 28, 2008.\nAll rights reserved. Revised June 28, 2012\n\nCategories and Subject Descriptors\n\n\fH.1.1 [Information Systems]: Models and Principles \u2013 Systems\nand Information Theory \u2013 Information Theory\n\nMathematics Subject Classification\n94A60 Cryptography\n14G50 Applications to coding theory and cryptography\n\nGeneral Terms\nAlgorithms,\nSecurity.\n\nDecryption,\n\nEncryption,\n\nDesign,\n\nReliability,\n\nKeywords\nBinary Coding, Binary Encryption, Data Encryption,\nDecryption, Encryption, Fibonacci, Fibonacci Representation,\nGolden Mean, Golden Mean Base, Phinary, Secret Encryption\n\n1.\n\nINTRODUCTION\n\n1.1\n\nRevisions:\n\nThis article was originally published in April 2008. The article\ndid not pass peer review. I self published on the web. Also,\nafter years of not being able to pass peer review in academic\ncircles; I sought support from the hacker community (white &\ngray hat only) to attempt to crack a sample encrypt. Possibly, by\nsetting up a distributed net to attempt a brute force decrypt. I\ndid not say how to attempt or program that brute force decrypt.\n(My methods are known and available from the ACM archive,\npart of the Cornell archive.) Over time, I have gotten several\ncomments about the article. These comments can be divided\ninto categories. Also, there are some comments that reoccur.\nThis revised article is to address the category of statements and\nthe commonly reoccurring statements. A lot of history and\nanecdotes have been removed from this article. Many examples\nhave been deleted from this article. The Abstract has been\nrevised, reformatted and has many additions. A lot of\ninformation has been removed in the hopes of simplification and\nclarity.\nThe\noriginal\ncan\nbe\nfound\nat\nhttp://arxiv.org/abs/0912.4080\nI fully understand the resistance to someone making the claim to\nhaving made an advance in the field of encryption. I fully\nunderstand the oft asserted claim of making an encryption that is\nuncrackable. Which is why I always preface my emails and\narticles, with a brief bio, of my academic background as well as\nthe fact that I own a patent in data compression. Data\ncompression inherently involves encryption. Along with the\nachievement of having solved a compression with a 20 year\nstanding engineering prize. Also, since the claim is tall, I had all\nmy colleagues review the article before submitting to any\njournal.\nEven thought the claim is tall, intellectual probity demands\nactually reading an article before assuming it is bunk. Real\nrefutations require stating the premise and steps of the logical\nproof, THEN; demonstrating that either the premise or one of\nthe steps of the logical proof are false. Detractors that don't do\nthat, are not valid detractors. Detractors who say, as some PhDs\n\nin cryptography have said, 'Your math is potentially ok.' But,\nrefuse to accept my conclusions, do not have probity. [Or,\nperhaps they are government hacks trying to dissimulate? So,\nmore uncrackable encryption methods will not be available to\nthe public?]\nI readily admit cryptography is not my forte. At the same time, I\nam not ignorant of the subject either.\nIf a scientist is to have true probity, he has to actually read the\narticle before rejecting the method. I have received many\noffhanded, spurious dismissals. No one can read a technical\narticle of this length in 5 minutes. I accept those offhanded\ndismissals as a fact of life. Arrogance. Intellectual arrogance.\nProfessorial arrogance. Scorn of a presumptuous neophyte. Not\nas a real refutation.\nThe honest and good say they are not interested in evaluating\nsuch a tall claim and are not going to read such a paper. \u2013 I can\naccept and appreciate that.\nI will note a significant aspect of the rejections so far. The more\nacademic or government related the reviewer the less academic\nand more personal of an attack, the rejection is. Many\nprejudicial assumptions are made-of me personally or my\nclaims. The ultimate of course is the exasperated, \"it doesn't\nmake sense\" without explanation. Remember, especially in the\nU.S., schools and research centers are heavily government\nfunded, especially in the field of cybersecurity. The less\ngovernment affiliated the reviewer \u2013 business person (sysadmin\nor security professional) or tech writer or hacker (or the term\ncracker if you prefer as a non-malicious curious individual) \u2013 the\nmore they understand.\nAlso, by simple comments and questions, I can tell:\n1.\n\nIf someone actually read the article. Any reviewer that\ndiscusses and rejects my method-singular-has\neither not read the article, nor understood it. All\nexcept one reviewer [Travis H.] has mentioned just\none method.\nThat reviewer did NOT give an\noffhanded dismissal to my claims. Not to say he\nagrees. But to say, he warrants reading the article and\ncontemplating the processes discussed.\n\n2.\n\nIf someone understands the heart of the linguistics and\nmath involved or not.\n\nFirst, I describe two basic categories of encryption. That is\nmentioned in the title. Frequency normalization is the first. I\ndevote an entire section to this one process. Even laymen get\nthat.\nFirst Method:\nFrequency normalization is a common\nmathematical term also employed in physic, probability and\nother fields. As the basis of decryption is to look for the natural\nfrequency of letters in a ciphertext-basing an encryption\nprocess upon the efficacy of confounding the natural frequency\nof letters is something I will not belabor an explanation. This is\nfundamental to cryptography.\nOnce the frequency has been normalized, then standard\nencryption techniques are applied. The binary techniques here\n\n\fmay be applied also for good measure. But once the frequency\nhas been normalized; and then the plaintext encrypted; the\nfrequency analysis commonly employed in decryption will be\nof no avail.\nOnly one person [from the Cryptography listed in the\nacknowledgements] commented, so far has asked me why you\nmust change the symbol set. At least he asked the right\nquestion. The answer is the heart of the first encryption process.\nWithout changing the symbol set, confounding the natural\nfrequency is not possible. (Perhaps reading my article, [ZIR01]\non data compression might help explain why. Read the section\nthat describes, why serial compression will not gain in\ncompression.)\nThis method of enciphering or encoding or encryption (each\nword has its own technical meaning is this list) by altering the\nsymbol set has never been used in the field of encryption. All\nthe reviewers \u2013like one reviewer for the American Mathematical\nSociety (AMS)-who said, 'No one has ever done it this way\nbefore.' Only confirms my assertion of the novelty of the\nencryption methods I propose.\nIf no other encryption would be employed together with\nfrequency normalization, then decryption would involve:\nguessing which sets of letters represent the original letter; then\nobserving if the words created are in the dictionary and if the\nentire message makes sense.\nThis decryption should be, I believe, information theoretic.\nThere would be false positives. While I have not calculated the\nprobabilities or statistics, the simple number of combinations\nwould seem to me, to generate some false positives.\n\n[Steganography in computers is not new. [JOH001] People\nhave been embedding messages in the bytes of JPEGs and\npictures for decades. The particular technique of computer\nsteganography I propose in my examples may or may not have\nbeen used before. I have not heard of its use before. I have not\nresearched its existence or use. I will leave the priority usage to\ncomputer historians to judge.]\nOne very intellectual commentator [Travis H.] stated that\nwithout randomness, the steganography is crackable.\nTrue.\nWhile randomness can be implemented into the\ntechnique, I intentionally leave out how to implement\nrandomness in this technique. Suffice to say, randomness can\nbe built into the steganography. However, in my original article I\ndiscuss the subject when discussing using big and little endian as\nsteganographic techniques. Also, I did mention \"changing the\nmasks\". Bear this in mind when reading that section.\nSome individuals who reviewed the article, told me, that unless\nrandomness was introduced-which must be done by padding\n-the method would be crackable. The original article discusses\nthis too. (That section has been preserved as Section 7, \"Infinite\nCombinations\", in this article.) That when encrypting the binary\nfrom base 2 to another binary base, padding is a natural\nconsequence. Padding is also a natural consequence of the\nsteganography.\nIt is obvious if you look at the pictures in the article, that the\nsteganography pads the ciphertext.\n\n1.2\n\nAmended From Original Introduction:\n\nDecrypting this method alone may or may not be\ncomputationally secure. This method alone may not be\nimpervious to brute force. [A human could easily decrypt this.\nA computer would require lots of guessing and may not be able\nto guess right.] But, coupled with any other encryption-of any\nkind-even the simplest-it would be logically \"uncrackable\"\nand beyond brute force decryption.\n\nThe order of several sections have been change so that the\npresentation of methods will match the order of the methods\nlisted in the title.\n\nSecond method: Involves breaking the transitivity of letter-\ncodebook-actual binary representation. Commonly, letter-\nASCII-base 2. [Explained in depth in the article.] This is done\nwith a combination of two techniques:\n\nA section has been added explaining with changing the symbol\nset is not decryptable by brute force.\n\n1.\n\nA choice of encryption of the letter or using a different\ncodebook (reference chart, ex. EBCIDIC instead of\nASCII) or both changing the codebook along with\nencrypting the letter.\n\n2.\n\nEncrypting the binary.\n\nEncrypting the binary must be done in a way that has no\nmathematical relationship to the encryption of the codebook.\nOtherwise, transitivity is maintained. This is explained in depth\nin the article.\nEncrypting the binary is done either with steganography or; by\nusing other natural bases \u2013other than base 2-which can be\nrepresented in binary. (Ex. Fibonacci and Phinary) This is\ndiscussed in depth in the article.\n\nReordering the material included renumbering the tables.\nAlthough the table references were proof read, there may be\nsome errata in the references.\nTwo major section headings have been added to indicate where\nthose methods are being discussed.\n\nIn a previous published article, I mentioned parenthetically, in a\ndiscussion of compression and encryption, that the exchange of\nsymbol sets (ciphering) does not alter the frequency of the\nsymbols [ZIR01]. Hence, the original symbol set can always be\nascertained from an enciphered text [KAH05]. Intrinsically\naltering the symbol set is one way to truly encrypt a linguistic\nmessage. This article discusses the process of altering the\nlinguistic symbol set and the impact that altering the linguistic\nsymbol set has upon encryption. In addition, this article\ndiscusses how to encrypt the binary numeric representation,\nexclusive of the alphabetic encryption and; the impact binary\nnumeric encryption has upon decryption. I.e. Producing a very\nstrong encryption that can not be decrypted, certainly not\nmethodically by process.\n[The linguistic symbol set would be letters as opposed to a\nnumeric symbol set of numerals.]\n\n\fI have made it (non-decryptable or uncrackable encryption)\nmuch easier and more practical than one time key encryption.\nWhat I have done, improved upon, is, that practically speaking,\none time key encryption can now be decoded by guessing. That\nis what brute force methods do. I have increased the guessing\npossibilities astronomically.\nWhether supercomputers or\ndistributed networks can crack these encryption methods,\nremains to be seen.\nOn another level, what I have done is to advance the level of\nintelligence in language. There can be no intelligence without\nlanguage. [WHO01] Language inherently involves intelligence\nand the expression of ideas. [WHO01] One of the chief\nmethods that language employs in expressing ideas and using\nintelligence is comparison and categorization.\n[WHO01].\nLanguage involves the expression of covert as well as overt ideas\nand concepts. [WHO01] Which, is done by categorization.\n[WHO01] Encryption, in a regard, involves a high level of\nintelligence, linguistically speaking, by making extremely covert\ncategories. The reverse, decryption, involves a high level of\nintelligence, by recognizing the hidden patterns of language in a\nseemingly mass of chaos. What I have done, is to raise our level\nof intelligence to the point, that even though there is an overt\nchaotic mass, in which we can not see the intelligence, at least\n(upon generation) we can categorize the different, noninterpretable (non-decryptable) chaotic masses containing\nintelligence.\n[One professor commentator said that he has no idea what I am\ntalking about. But, suggested that perhaps I was talking about\nusing chaos theory for encryption. His comment implied been\nthere done that. To be clear, although I did use the word chaos\nin the previous paragraph, the methods I propose, do not,\nintentionally have anything to do with chaos theory. This all\nabout logic, math and linguistics.]\nThis is the indicator to understanding this paper. When one\nreads this presentation, one should understand, that there are\nmany examples of several new methods. If one sees just one\nmethod, one has to study the paper further. [I have adjusted the\ntitles to make this clear.]\nWriting is a relationship and correspondence between sounds,\nlexicons and written symbols.\nThe permutations and\ncombinatorics of all the possible sounds, to make as many\nwords as we need, is a necessity of communication. Those\npermutations and combinations must be defined and limited by\nthe natural phenomenon of what the mouth can utter and the ear\ncan hear. Permutations and combinatorics are math. A lexicon\nand grammar relate objects (words). Relationships are logic. So,\nmath and logic are an intrinsic part of communication. When\nyou can no longer do the math and; there are no relationships\n(It's illogical.); then, there can be no communication. That is\nencryption.\n\n1.3\n\nResponses to Additional Comments\n\n\u2192 At this point it is fitting to answer a common comment about\nmy work, \"Why would I want to use non-decryptable\nencryption? Why would I want to encrypt something that I\n\ncould not decrypt?\" To take this comment seriously, it is a gross\nmisunderstanding of encryption and; an ignorance of the\nfundamental concept of encryption.\nAny encryption or\nenciphering or encoding (these are three distinct technical terms\nchosen specifically for a reason), is designed to be nondecryptable-to the uninitiated. But the sender and receiver will\nhave the keys and methods to decrypt.\nObviously, I did not intend to produce total gibberish that can\nnever be understood again.\nObviously, I did not intend that there should be no reverse\nprocess for decryption.\nWhat I intended by \"non-decryptable by method\" is\n\"uncrackable\".\nWhat I intended is, that if you do not have the keys and you do\nnot know the exact methods of encryption (the alpha & binary),\nthen, you can not decrypt the message. Even with the advanced\ncomputing power of the today. Your information is secure.\nThat is what encryption is all about.\n\u2192 One comment and misconception that constantly arises is a\nmisunderstanding of terms. In the original paper I used the term\n\"non-decryptable by method\". Apparently, this is an old term,\nno longer used. The term \"uncrackable\" or \"unbreakable\"\nseems more appropriate.\n[Jeremy Stanley, commented on Jack Lloyd's Cryptography list,\nthat he was not able to find the expression \"non-decryptable by\nmethod\" in literature. I responded, that I had used the term from\nthe original patent for one time key pad from the 1930s. So, I\nhave gone with the suggestion \"uncrackable\".]\nHe also asserts that this would seem an exaggeration. Because\nof brute force. True. But, it is no more an exaggeration than the\nability to decrypt one time key pad. And, if you need more\ncomputing power than currently available-a common fallback\nfor many encryption schemes-than this new method is no\nexaggeration. That is why we constantly hunt for bigger &\nbigger prime numbers. To require more computing power to\ndecrypt, than is currently available.\n\u2192 As for not having passed peer review in the past:\nThe so-called refutations lack any logical and mathematical\nrefutation.\nOne absurd declaimer said, that my math is potentially ok but he\ndoesn't know what I am talking about. A clear contradiction. If\nmy math is ok, then, I am right? Ne c'est pas?\nAll these so-called refutations say that encryption was never\ndone this way before. So my claim of novel techniques is\ncertainly valid.\n\u2192 Previously, I had a lengthy discussion in the introduction\nabout releasing the genie from the bottle. That in our age of\nterrorism, cybercrime, cyberwarfare, would it be prudent \u2013if I\nreally had found a new uncrackable, unbreakable encryption-\nwould it be prudent to publish a paper about it? Well, if the\nacademic community and tremendously funded government\n\n\fagencies entrusted to this science say I am full of hokum, then\nthe release of this information and techniques is of no moment\n-certainly of no moment to governments.\n\nseveral equations that I had to conceive as well as an integral\nmathematical concept.)\n\n\u2192 Here I will add some history, that I did not mention in the\noriginal version. This history is now appropriate:\n\n2.\n2.1\n\nWhen David Kahn, a newpaper reporter, wrote his \"History of\nCryptography\", an excellent work for an amateur and a good\nprimer for encryption, the NSA (National Security Agency, U.S.)\nmaligned him as an amateur and his work as incorrect. If so,\nwhy was the NSA pressuring the publisher not to publish his\nbook? When the NSA asked for the removal of certain\ninformation which they considered sensitive-which was public\nrecord anyway-the author simply agreed. [BAM01] The NSA\ncould have chosen the correct, civil and polite method. It didn't\nneed to be nasty, maliciously degrading and maliciously\ndiscrediting.\n\nAs I stated and partially explained above as well as in a previous\narticle [ZIR01], what is necessary for compression and\nencryption is to change the symbol set. For example, if the\nEnglish text were replaced with the international phonetic\nalphabet, there would be more letters altogether and less of some\nregularly written letters. I.e. The dipthong \"ch\" would be\nreplaced by one symbol. Now this new symbol appears, with its\nown frequency. And, the frequencies of 'c' and 'h' have been\nchanged. Because, 'c' and 'h' no longer appear where 'ch'\nappears \u2013 the dipthong has been replaced by a new symbol. 1\n\nI believe we are witnessing a repeat performance by the NSA\nand other government types of attacking law abiding citizens,\nwho are not part of the government cryptographic apparatus.\nToday, this runs counter to the federal law in the U.S., the\nCybersecurity Act. It would behoove the U.S. government and\nother governments to work with intelligent and talented, law\nabiding private individuals. Rather than, attacking and harassing\nthem.\nFor this reason, I have eliminated any apologies for unleashing a\nnew \"uncrackable\" encryption method.\nI intentionally\nsubmitted prior versions of my article to journals inside the U.S.\nonly. (Where was living at the time.) However: If the academic\ncommunity can not understand my presentation; then I am not\nto blame for disseminating gibberish. If the government with all\ntheir experts, can not understand my presentation, their loss. I\nwas intentionally obfuscating, but included enough for\nintelligent, open minded people knowledgeable in the field to get\nit. If hackers got it, while the government and academics didn't;\nthe governmentals and academics need to rethink their position\nand academic status. If the hackers have already understood,\nthen the genie is already out of the bottle. This article, written\nwith clarity intended, should not cause any clamor about\nunleashing a new \"unbreakable\" encryption method.\nI am reminded of the anecdote of the man who's car has engine\ntrouble. He brings his car to his mechanic. His mechanic can't\nfind the problem. His car breaks down on the highway. He goes\nto get help. By the time a tow truck comes to tow his car to a\ngarage, his car is stolen. What the mechanics couldn't fix for\nweeks, the thieves could fix in a minutes!\nHad the government chosen the correct path of classification and\nrestriction of technology, as a law abiding citizen I could have\naccepted that.\nAlthough, with all the cyrberattacks and\ncybercrime, in my opinion, John Q. Public deserves better\nencryption and security than the government is allowing or;\nindustry is providing.\nSince, there are issues to implementation, which I have not\nexplained how to overcome, that is sufficient for my conscience\nfor not having released the genie from the bottle. Because, no\none who understands the process, so far, has been able to\novercome the obstacles to implementation. (Also, omitting\n\nFREQUENCY NORMALIZATION\nCHANGING THE SYMBOL SET\n\nThis substitution technique is also well known in cryptography.\nIt does complicate matters. [KAH12] [KAH13] [VAU03]\nApplying this knowledge to the premise of this paper: The\nproperties of the binary symbol set are altered so that the\nalphabetic symbol set is altered in a way that \"normalizes\" the\nfrequency of the letters. This is a completely novel approach to\nencryption. This encryption method does not use a key per se;\nalthough one must have the translation table.\nWhat I am proposing is: Add extraneous, \"useless\" binary\nnumbers to create extra symbols to alter the frequency. Then\nencryption methods are used on the letters of the original text, to\nproduce a ciphered text that includes new identity letters which\ndo not have the frequency analysis of English. This would be\nsufficient to not be decryptable. But, in addition to altering the\nfrequency, the ciphered text is (for example) then translated to\nbinary base 2 which is enciphered in base Fibonacci. With\nextraneous numbers?! \u2013 Then, the encryption is very strong and\nnot decipherable!\nExample:\nReturning to the \"The quick brown fox jumped lazily over the\nsleepy dog.\" Let's say, I replace some of the 'e's with another,\nnew, symbol. E.g. \"The quick brown fox jump\u03c6d lazily over\nth\u03c6 sle\u03c6py dog.\" I have achieved several things. Most\nimportantly, the frequency analysis is now confounded. The\nletter 'e' is no longer the most frequent letter. If I would now\nengage in some kind of enciphering, there is no way to get back\nto the original message by frequency analysis. [Nor, is there any\nother method that I can think of, that will reverse the process\n\n1\n\nSee citations [WIK10] & [WIK11] for more information on\nthe International Phonetic Alphabet (IPA), as well as a link for\na chart of the IPA.\n\n\fwithout knowing the codebook encryption process. (The extra\nsymbols and what they replace.)]\nIn a sense, this kind of encoding is a CAPTCHA. When a\nhuman sees this encryption, a human knows that it is seeing an\nencryption and; what is encrypted. But, a computer, using\ndictionary attacks, by trying to match the letter patterns of words\nin a dictionary will not. The computer can only offer the human\na possible, but not definite, decryption.\nNotice how \"the\" and \"th\u03c6\" are now 2 different words. The\nconfusion begins.\nIf I follow the procedure through, and apply the technique to the\n2nd most frequent letter, \"O\", then the sentence now looks like:\n\"The quick brown f\u03c8x jump\u03c6d lazily over th\u03c6 sle\u03c6py d\u03c8g.\"\nLook at Tables 1A, 1B & 1C, below comparing the 3 frequencies\nfor the 3 different enciphering methods:\n\nFrequency for unaltered text.\nLetter\n\nTally Frequency\n\nE\n\n6\n\n6/44 = 13.6%\n\nO\n\n4\n\n4/44 = 9.0%\n\nL\n\n3\n\n3/44 = 6.8%\n\nD\n\n2\n\n2/44 = 2.5%\n\nH\n\n2\n\n2/44 = 2.5%\n\nI\n\n2\n\n2/44 = 2.5%\n\nR\n\n2\n\n2/44 = 2.5%\n\nT\n\n2\n\n2/44 = 2.5%\n\nU\n\n2\n\n2/44 = 2.5%\n\nA\n\n1\n\n1/44 = 2.3%\n\nB\n\n1\n\n1/44 = 2.3%\n\nC\n\n1\n\n1/44 = 2.3%\n\nF\n\n1\n\n1/44 = 2.3%\n\nG\n\n1\n\n1/44 = 2.3%\n\nJ\n\n1\n\n1/44 = 2.3%\n\nK\n\n1\n\n1/44 = 2.3%\n\nM\n\n1\n\n1/44 = 2.3%\n\nN\n\n1\n\n1/44 = 2.3%\n\nP\n\n1\n\n1/44 = 2.3%\n\nQ\n\n1\n\n1/44 = 2.3%\n\nS\n\n1\n\n1/44 = 2.3%\n\nV\n\n1\n\n1/44 = 2.3%\n\nW\n\n1\n\n1/44 = 2.3%\n\nX\n\n1\n\n1/44 = 2.3%\n\nY\n\n1\n\n1/44 = 2.3%\n\nZ\n\n1\n\n1/44 = 2.3%\n\nTable 1A\n\n\fFrequency with one\nadditional new letter.\n\nFrequency with two additional\nnew letters.\n\nLetter Tally Frequency\n\nLetter\n\nO\n\n4\n\n4/44 = 9.0%\n\nE\n\n3\n\n3/44 = 6.8%\n\nL\n\n3\n\n3/44 = 6.8%\n\nD\n\n2\n\n2/44 = 2.5%\n\nH\n\n2\n\n2/44 = 2.5%\n\nI\n\n2\n\n2/44 = 2.5%\n\nR\n\n2\n\n2/44 = 2.5%\n\nT\n\n2\n\n2/44 = 2.5%\n\nU\n\n2\n\n2/44 = 2.5%\n\nA\n\n1\n\n1/44 = 2.3%\n\nB\n\n1\n\n1/44 = 2.3%\n\nC\n\n1\n\n1/44 = 2.3%\n\nF\n\n1\n\n1/44 = 2.3%\n\nG\n\n1\n\n1/44 = 2.3%\n\nJ\n\n1\n\n1/44 = 2.3%\n\nK\n\n1\n\n1/44 = 2.3%\n\nM\n\n1\n\n1/44 = 2.3%\n\nN\n\n1\n\n1/44 = 2.3%\n\nP\n\n1\n\n1/44 = 2.3%\n\nQ\n\n1\n\n1/44 = 2.3%\n\nS\n\n1\n\n1/44 = 2.3%\n\nV\n\n1\n\n1/44 = 2.3%\n\nW\n\n1\n\n1/44 = 2.3%\n\nX\n\n1\n\n1/44 = 2.3%\n\nY\n\n1\n\n1/44 = 2.3%\n\nZ\n\n1\n\n1/44 = 2.3%\n\nTable 1B\n\nTally Frequency\n\nE\n\n3\n\n6/44 = 6.8%\n\nL\n\n3\n\n3/44 = 6.8%\n\nD\n\n2\n\n2/44 = 2.5%\n\nH\n\n2\n\n2/44 = 2.5%\n\nI\n\n2\n\n2/44 = 2.5%\n\nO\n\n2\n\n2/44 = 2.5%\n\nR\n\n2\n\n2/44 = 2.5%\n\nT\n\n2\n\n2/44 = 2.5%\n\nU\n\n2\n\n2/44 = 2.5%\n\nA\n\n1\n\n1/44 = 2.3%\n\nB\n\n1\n\n1/44 = 2.3%\n\nC\n\n1\n\n1/44 = 2.3%\n\nF\n\n1\n\n1/44 = 2.3%\n\nG\n\n1\n\n1/44 = 2.3%\n\nJ\n\n1\n\n1/44 = 2.3%\n\nK\n\n1\n\n1/44 = 2.3%\n\nM\n\n1\n\n1/44 = 2.3%\n\nN\n\n1\n\n1/44 = 2.3%\n\nP\n\n1\n\n1/44 = 2.3%\n\nQ\n\n1\n\n1/44 = 2.3%\n\nS\n\n1\n\n1/44 = 2.3%\n\nV\n\n1\n\n1/44 = 2.3%\n\nW\n\n1\n\n1/44 = 2.3%\n\nX\n\n1\n\n1/44 = 2.3%\n\nY\n\n1\n\n1/44 = 2.3%\n\nZ\n\n1\n\n1/44 = 2.3%\n\nTable 1C\n\n\fAnalyzing the data in Table 1, we see that with only one new\nsymbol, 'e' is no longer the most common letter. If we use two\nnew symbols, 'e' is tied in first place with another letter and; 'o',\na very frequent number, becomes an ordinary number.\nThe additional letters are not shown. The additional letters have\nthe same frequency as the letters they replace. Although, we\ncould do this differently so that one new twin letter has a higher\nfrequency, than its additional twin letter. This means, for the\nmost frequently occurring letter, there is at least two, if not three\nletters tied for 1st place.\nWould a decryption method start by guessing that some\ncombination of the most frequent letters is 'e'? Then, what?\nAnd, if I follow through with the identity replacement procedure,\nand apply the technique to punctuation marks, like spacing, then\nthe sentence now looks like:\n\"The\u03c9quick brown\u03c9f\u03c8x\njump\u03c6d\u03c9lazily over\u03c9th\u03c6 sle\u03c6py\u03c9d\u03c8g.\" And, if you do not\nknow where words begin and end, you are missing a big clue in\ndeciphering. Human beings intuitively know, when deciphering,\nif they are seeing words or not and where spaces, breaks\nbetween words, should go. Computers have to do a dictionary\ncomparison on text and subtext: Guess.\nA dictionary comparison creates longer and longer cumulative\nlength strings, compares them with EVERY word in the\ndictionary and; then, decides if a possible word or word, has\nbeen located and a new string should be started for analysis.\nE.g. Using the example above, a dictionary comparison would\nbe done like this:\nThe secret message is:\n\"Thequickbrownfoxjumpedlazilyoverthesleepydog.\"\n\"T\" \u2013 is \"T\" a word? No. Add a letter.\n\"Th\" \u2013 is \"Th\" a word? No. Add a letter.\n\"The\" \u2013 is \"The\" a word? Yes. Record first word. Start new\nword.\n\"q\" \u2013 is \"q\" a word? No. Add a letter.\n\nahead? If so, how many letters to look ahead? Is it \"over\" or\n\"overt\"? It could it be \"overt he\" instead of \"over the\". Is slang\nincluded or not? I.e. Is \"bro\" a word?\nTrue, there are sophisticated dictionary algorithms. But, the\npoint is that by simply removing the space between words\ncreates a big obstacle for a computer to decipher. -- Consider\nthis, removing a space is alteration of the symbol set. There is\nnow, one less symbol. If half the 'e's in the sentence had been\nremoved, it would be a big alteration.\nWhile computers can figure out, if the string of words\ndeciphered actually makes sense as a sentence in English; this is\nnot accurate and is not as sophisticated as a human.\n\n2.2\n\nFrequency Normalization\n\nIn addition, to just replacing every other letter, knowing the\nletters' frequencies from tables, etc.; with little effort, one could\nparse any given input text, tally all the letters, calculate the\nfrequency of each letter, and then; create a sufficient amount of\nnew symbols \u2013 identity symbols \u2013 to \"normalize\" enough of the\nletters to make frequency analysis impossible! All that would be\nrequired is to randomly replace the given letters with their\ncorresponding identity letters.\nIn fact, a very similar method is done in JPEG, with Huffman\ncoding. [MIA01] [PEN01] The JPEG standard has a feature, to\nuse Huffman coding. Huffman coding is the most compact\nbinary encoding. [HUF01] What Huffman coding does, is tally\nall the symbols, and assigns the shortest code symbol to the\nmost frequent symbol to be coded. I.e. The most frequent\nletter, for example, will be replaced with a '1'. But, Huffman\ncoding requires parsing the data prior to encoding. This is\nnecessary to develop the code table. Huffman encoding\nproduces a table which must be transmitted for decoding. Also,\nin JPEG, each new section of data \u2013 image frame, will have its\nown Huffman table as the frequency of the symbols will change\nin each frame. For example, in one frame, you may have\nhundreds of red pixels \u2013 which will be assigned a '1'. And, only\na few white pixels, which may be assigned a '1111'. But, in the\nnext frame, there may be hundreds of white pixels \u2013 which will\nthen be assigned a '1'. And, the few red pixels, which will be\nassigned a '111'.\n\n\"qu\" \u2013 is \"qu\" a word? No. Add a letter.\n\"quic\" \u2013 is \"qui\" a word? No. Add a letter.\n\"quic\" \u2013 is \"quic\" a word? No. Add a letter.\n\"quick\" \u2013 is \"quick\" a word? Yes. Record second word. Start\nnew word.\nHere we can see the difficulties in this analysis and the\npropensity for errors. After having discovered the first four\nwords, \"the\", \"quick\", \"brown\", \"fox\"; the next word is \"jump\".\nThen the analysis becomes unclear. Should there be a look\n\nSince JPEG is not a secret encryption method, there is no\nconcern about the code table being captured and the data being\ndecrypted. But, with secret messaging, it will be very important\nto protect the code tables. \u2013 A disadvantage. But, a common\nconcern in secret encryption and a concern that is no more\nsignificant than protecting an encryption key.\n[In [ZIR01] I discuss JPEG and Huffman encryption in depth.]\n\n\fFollowing are possible implementations of this theory:\n\n2.3\nBase 2 Binary Frequency\nNormalization\nEven with regular binary, not all the symbols of the ASCII table\nare used. There are enough symbols left over for graphics and\nalternate (other language) alphabets (e.g. Greek). What if, for\nexample, the symbol 253 was also used to represent the letter\n'e', along with symbol 69?\nFollowing such an insertion of additional identity symbols, with\none simple binary encryption, the entire frequency analysis is\nirrevocably confounded! No complex key is needed to make\nand keep the message secret!\n\n2.4\n\nFibonacci Frequency Normalization\n\nUsing a more simple and obvious example first: Any positive\ninteger less than any given Fibonacci number can be had, by\nadding up some set of the previous Fibonacci numbers. For\nexample, the number 6 is not in the Fibonacci sequence, but, it\ncould be composed of 1+5; or 1+2+3. In fact, adhering strictly\nto the Fibonacci sequence; {0, 1, 1, 2, 3, 5....} \u2013 the number (big\nendian) \"010001FIB\" (1+5) is not the same as \"001001FIB\" (1+5)!\nIt would be a trivial matter to create extra symbols that referred\nto the same letter.\nThere is no one to one correspondence between positive integers\nand Fibonacci numbers. \u2013 This is one of the beauties of base\nFibonacci. This property alone, becomes very useful for\nimplementing a frequency normalization encryption scheme as\nherein discussed, without any serious extra effort encoding!\nSimply pick different sets of numbers to express the ASCII\nnumbers for any letter \u2013 and alternate the set you use! Most\nletters will have corresponding ASCII numbers with multiple\ncorresponding Fibonacci sets.\nIn addition, if there is no frequency analysis to be had, there is\nalso no way of knowing which binary system is being used!\nFor, even if we assume, that the binary system was encrypted,\nand; that it would be possible to determine which binary system\nwas being used; by assuming that we could backtrack from a\nvalid language letter frequency analysis; after frequency\nnormalization of the language letter symbol set, that clue \u2013 the\nlanguage letter symbol frequency \u2013 no longer exists. After\nfrequency normalization, any binary system that does produce a\nproper frequency analysis is producing a false positive! You\nwould not know, that the frequency analysis, did indeed provide\na link to the correct binary system or not.\n\n2.5\nAn Example of Frequency\nNormalization\nTo give a real example, with a larger sample than one sentence:\nLet's use the abstract of this paper which is only one paragraph.\nWhen that abstract was written, there was no intention of\nchoosing words so that a special frequency would occur or; that\nevery letter of the alphabet would be used or; that any letter\nwould be excluded. It was just written to express a thought.\nThe text was not adjusted in any way to facilitate encryption or\nbe an example of any kind. I am positive very similar results will\noccur if I choose to work on the King James' Version of the\nBible or any other text for that matter.\nLook at Table 2. It is divided into three sub-tables A, B & C.\nEach sub-table has three columns. The leftmost column\ncontains the letters of the alphabet. The middle column contains\nthat letter's tally. The rightmost column expresses that letter's\ntally as a percentage of the total number of letters in the\nparagraph.\n\n\u2022\n\nThe leftmost sub-table is sorted alphabetically.\n\n\u2022\n\nThe middle table is sorted by percentage, in\ndescending order. I.e. Most frequent letter first.\nFollowed by the next most frequent letter. Etc.\n\n\u2022\n\nThe rightmost sub-table shows what the percentages\nwould be, if identities had been issued and frequency\nnormalization applied.\no\n\nThe additional new identity symbols are not\ndisplayed.\n\no\n\nThe frequencies of the new symbols are\nassumed to be the same as the letters that\nthey replace.\n\no\n\nThe encryption method applied:\n\uf0a7\n\nAdding three additional symbols\nto the most frequent letter. Its\nfrequency is altered as it appears in\nthe third sub-table.\n\n\uf0a7\n\nAdding two additional symbols to\neach of the next, top 9 most\nfrequent letters. Their frequencies\nare also altered as they appear in\nthe third sub-table.\n\no\n\nAdding new symbols to a given letter, in\neffect divides the tally of that given letter.\n\no\n\nThe letter 'e', having such a high frequency,\nwas given three new symbols. So, 'e', goes\nfrom a frequency of 12% to 3%\n(12%/4=3%).\n\n\fAlphabetized\nFrequency\nAnalysis\n\nFrequency\nAnalysis Sorted by\nNumeric Value\n\nFrequency Analysis\nWith Identity Letters\nAdded; Sorted by\nNumeric Value\n\n\u2022\n\nThe standard deviation from the mean frequency is\n3.4%\n\n\u2022\n\nThat any letter appearing with a frequency greater than\nthe average plus the standard deviation (3.9%\n+3.4%=7.3%) is exceptional and unique. I.e. An\nidentifiable letter.\n\n\u2022\n\nIn the example above, 'E', 'T', 'O', 'A', 'S', & 'N'\nare exceptional and unique letters as we would expect.\n\nA\n\n67\n\n8.5%\n\nE\n\n96\n\n12.1%\n\nE\n\n96\n\n3.0%\n\nB\n\n10\n\n1.3%\n\nT\n\n75\n\n9.5%\n\nT\n\n75\n\n3.2%\n\nC\n\n36\n\n4.5%\n\nO\n\n71\n\n9.0%\n\nO\n\n71\n\n3.0%\n\nD\n\n26\n\n3.3%\n\nA\n\n67\n\n8.5%\n\nA\n\n67\n\n2.8%\n\nE\n\n96\n\n12.1%\n\nS\n\n64\n\n8.1%\n\nS\n\n64\n\n2.7%\n\nF\n\n14\n\n1.8%\n\nN\n\n58\n\n7.3%\n\nN\n\n58\n\n2.4%\n\nG\n\n21\n\n2.7%\n\nI\n\n45\n\n5.7%\n\nI\n\n45\n\n1.9%\n\n\u2022\n\nSome letters do not appear at all!\n\nH\n\n31\n\n3.9%\n\nR\n\n41\n\n5.2%\n\nR\n\n41\n\n1.7%\n\n\u2022\n\nThe letter 'e' appears as often as any other letter.\n\nI\n\n45\n\n5.7%\n\nC\n\n36\n\n4.5%\n\nC\n\n36\n\n1.5%\n\n\u2022\n\nJ\n\n0\n\n0.0%\n\nH\n\n31\n\n3.9%\n\nH\n\n31\n\n1.3%\n\nK\n\n6\n\n0.8%\n\nM\n\n29\n\n3.7%\n\nM\n\n29\n\n3.7%\n\nThe first 10 letters, with a significantly higher\nfrequency from Sub-Table 2A, now appear as often as\nother letters.\n\nL\n\n23\n\n2.9%\n\nP\n\n27\n\n3.4%\n\nP\n\n27\n\n3.4%\n\n\u2022\n\nApproximately, 6 letters appear very infrequently.\n\nM\n\n29\n\n3.7%\n\nD\n\n26\n\n3.3%\n\nD\n\n26\n\n3.3%\n\n\u2022\n\nThe average frequency of a letter is 2.1%.\n\nN\n\n58\n\n7.3%\n\nL\n\n23\n\n2.9%\n\nL\n\n23\n\n2.9%\n\n\u2022\n\nThe standard deviation from the mean frequency is 1%\n\nO\n\n71\n\n9.0%\n\nU\n\n22\n\n2.8%\n\nU\n\n22\n\n2.8%\n\n\u2022\n\nP\n\n27\n\n3.4%\n\nG\n\n21\n\n2.7%\n\nG\n\n21\n\n2.7%\n\nQ\n\n1\n\n0.1%\n\nY\n\n16\n\n2.0%\n\nY\n\n16\n\n2.0%\n\nLetters ['M', 'P' & 'D'] appearing with a frequency\ngreater than the average plus the standard deviation\n(2.1%+1%=3.1%) are not exceptional and unique. I.e.\nAn identifiable letter.\n\nR\n\n41\n\n5.2%\n\nF\n\n14\n\n1.8%\n\nF\n\n14\n\n1.8%\n\nS\n\n64\n\n8.1%\n\nB\n\n10\n\n1.3%\n\nB\n\n10\n\n1.3%\n\nT\n\n75\n\n9.5%\n\nK\n\n6\n\n0.8%\n\nK\n\n6\n\n0.8%\n\nU\n\n22\n\n2.8%\n\nV\n\n6\n\n0.8%\n\nV\n\n6\n\n0.8%\n\nV\n\n6\n\n0.8%\n\nW\n\n6\n\n0.8%\n\nW\n\n6\n\n0.8%\n\nW\n\n6\n\n0.8%\n\nQ\n\n1\n\n0.1%\n\nQ\n\n1\n\n0.1%\n\nX\n\n1\n\n0.1%\n\nX\n\n1\n\n0.1%\n\nX\n\n1\n\n0.1%\n\nY\n\n16\n\n2.0%\n\nJ\n\n0\n\n0.0%\n\nJ\n\n0\n\n0.0%\n\nZ\n\n0\n\n0.0%\n\nZ\n\n0\n\n0.0%\n\nZ\n\n0\n\n0.0%\n\nTable 2A.\n\nTable 2B.\n\nTable 2C.\n\nObservations From Sub-Table 2A:\n\n\u2022\n\nSome letters do not appear at all!\n\n\u2022\n\nThe letter 'e' appears significantly more often than the\nrest.\n\n\u2022\n\nThe first 10 letters, have a significantly higher\nfrequency than the other letters.\n\n\u2022\n\nApproximately, 6 letters appear very infrequently.\n\n\u2022\n\nThe average frequency of a letter is 3.9%.\n\nObservations From Sub-Table 2C:\n\nTable 3 below shows two sub-tables. Sub-table A on the left,\nshows the letters of the alphabet sorted by their original\nfrequency prior to any attempts at frequency normalization.\nSub-table B on the left, shows the letters of the alphabet; sorted\nby their new frequency if identities had been added to alter the\nfrequency. We see previously frequent letters buried deep\nbelow. For instance, the frequent 'i', looks identical to an 'f'.\nThe average 'm', now looks like the most frequent letter, an 'e'.\nWe see that the frequent 'e' is now tied with 'o' and, the original\ntop 10 letters [E,T,O,A,S,N,I,R,C,H], all have the same\napproximate frequency. In addition, remember to factor in, the\nadditional 21 extra identity symbols. There are now, 10 original\n+ 21 new symbols = 31 symbols: All with approximately the\nsame frequency! The entire alphabet has 47 letters in total. (26\nletters + 21 new symbols = 47 letters new alphabet)\n[Each letter that has twin replacements is having its frequency\ndivided by 3. So, there is the original symbol, plus 2 new\nidentity symbols. (1+2=3). This is done for 9 of the first 10\nletters. So, 9 x 2 = 18. The letter 'e', having such a high\nfrequency, gets one more identity symbol. I.e. The frequency\nfor 'e' is divided by 4 instead of 3. That requires 3 new symbols.\nSo, 18 + 3 = 21 new symbols.]\n\n\fFrequency of Letters with\nNew Symbol Set \u2013\nDisplayed in Original\nFrequency Order\n\nFrequency of Letters with\nNew Symbol Set \u2013 Displayed\nin New Frequency Order\n\nE\n\n96\n\n3.0%\n\nM\n\n29\n\n3.7%\n\nT\n\n75\n\n3.2%\n\nP\n\n27\n\n3.4%\n\nO\n\n71\n\n3.0%\n\nD\n\n26\n\n3.3%\n\nA\n\n67\n\n2.8%\n\nT\n\n75\n\n3.2%\n\nS\n\n64\n\n2.7%\n\nE\n\n96\n\n3.0%\n\nN\n\n58\n\n2.4%\n\nO\n\n71\n\n3.0%\n\nI\n\n45\n\n1.9%\n\nL\n\n23\n\n2.9%\n\nR\n\n41\n\n1.7%\n\nA\n\n67\n\n2.8%\n\nC\n\n36\n\n1.5%\n\nU\n\n22\n\n2.8%\n\nH\n\n31\n\n1.3%\n\nS\n\n64\n\n2.7%\n\nM\n\n29\n\n3.7%\n\nG\n\n21\n\n2.7%\n\nP\n\n27\n\n3.4%\n\nN\n\n58\n\n2.4%\n\nD\n\n26\n\n3.3%\n\nY\n\n16\n\n2.0%\n\nL\n\n23\n\n2.9%\n\nI\n\n45\n\n1.9%\n\nU\n\n22\n\n2.8%\n\nF\n\n14\n\n1.8%\n\nG\n\n21\n\n2.7%\n\nR\n\n41\n\n1.7%\n\nY\n\n16\n\n2.0%\n\nC\n\n36\n\n1.5%\n\nF\n\n14\n\n1.8%\n\nH\n\n31\n\n1.3%\n\nB\n\n10\n\n1.3%\n\nB\n\n10\n\n1.3%\n\nK\n\n6\n\n0.8%\n\nK\n\n6\n\n0.8%\n\nV\n\n6\n\n0.8%\n\nV\n\n6\n\n0.8%\n\nW\n\n6\n\n0.8%\n\nW\n\n6\n\n0.8%\n\nQ\n\n1\n\n0.1%\n\nQ\n\n1\n\n0.1%\n\nX\n\n1\n\n0.1%\n\nX\n\n1\n\n0.1%\n\nJ\n\n0\n\n0.0%\n\nJ\n\n0\n\n0.0%\n\nZ\n\n0\n\n0.0%\n\nZ\n\n0\n\n0.0%\n\nTable 3A.\n\nTable 3B.\n\nTable 4A.\nLetters & Identities Sorted by Frequency Prior\nto Normalization\nOriginal\nNormalized\nLetter or Tally Tally of Letter Frequency\nIdentity\n& Identity\nas a percent\n\nE\n\n24\n\n3.0%\n\n\u00e9\n\n24\n\n3.0%\n\n\u00e2\n\n24\n\n3.0%\n\n\u00e4\n\n24\n\n3.0%\n\n25\n\n3.2%\n\n\u00e0\n\n25\n\n3.2%\n\n\u00fc\n\n25\n\n3.2%\n\n24\n\n3.0%\n\n\u00c7\n\n24\n\n3.0%\n\n\u00ea\n\n23\n\n2.9%\n\n22\n\n2.8%\n\n\u00eb\n\n22\n\n2.8%\n\n\u00e8\n\n23\n\n2.9%\n\n21\n\n2.7%\n\n\u00cf\n\n21\n\n2.7%\n\n\u00ce\n\n22\n\n2.8%\n\n19\n\n2.4%\n\n\u00cc\n\n19\n\n2.4%\n\n\u00c4\n\n20\n\n2.5%\n\n15\n\n1.9%\n\n\u00c5\n\n15\n\n1.9%\n\n\u00c9\n\n15\n\n1.9%\n\n14\n\n1.7%\n\nAE\n\n14\n\n1.7%\n\nAE\n\n13\n\n1.6%\n\n12\n\n1.5%\n\n\u00d4\n\n12\n\n1.5%\n\n\u00d6\n\n12\n\n1.5%\n\n10\n\n1.3%\n\n\u00d2\n\n10\n\n1.3%\n\n\u00db\n\n11\n\n1.4%\n\n29\n\n3.7%\n\nT\n\nO\n\nA\n\nS\n\nN\n\nI\n\nR\n\nC\n\nH\n\nM\n\n96\n\n75\n\n71\n\n67\n\n64\n\n58\n\n45\n\n41\n\n36\n\n31\n\n29\n\n\fTable 4B.\n\nP\n\n27\n\n27\n\n3.4%\n\nD\n\n26\n\n26\n\n3.3%\n\nL\n\n23\n\n23\n\n2.9%\n\nU\n\n22\n\n22\n\n2.8%\n\nG\n\n21\n\n21\n\n2.7%\n\nY\n\n16\n\n16\n\n2.0%\n\nF\n\n14\n\n14\n\n1.8%\n\nB\n\n10\n\n10\n\n1.3%\n\nK\n\n6\n\n6\n\n0.8%\n\nM\n\n3.7%\n\nV\n\n6\n\n6\n\n0.8%\n\nP\n\n3.4%\n\nW\n\n6\n\n6\n\n0.8%\n\nD\n\n3.3%\n\nQ\n\n1\n\n1\n\n0.1%\n\nT\n\n3.2%\n\nX\n\n1\n\n1\n\n0.1%\n\n\u00e0\n\n3.2%\n\nJ\n\n0\n\n0\n\n0.0%\n\n\u00fc\n\n3.2%\n\nZ\n\n0\n\n0\n\n0.0%\n\nE\n\n3.0%\n\n\u00e9\n\n3.0%\n\n\u00e2\n\n3.0%\n\n\u00e4\n\n3.0%\n\nO\n\n3.0%\n\n\u00c7\n\n3.0%\n\n\u00ea\n\n2.9%\n\n\u00e8\n\n2.9%\n\nL\n\n2.9%\n\nA\n\n2.8%\n\n\u00eb\n\n2.8%\n\n\u00ee\n\n2.8%\n\nU\n\n2.8%\n\nS\n\n2.7%\n\n\u00ef\n\n2.7%\n\nG\n\n2.7%\n\n\u00c4\n\n2.5%\n\nN\n\n2.4%\n\n\u00ec\n\n2.4%\n\nY\n\n2.0%\n\nI\n\n1.9%\n\n\u00c5\n\n1.9%\n\n\u00c9\n\n1.9%\n\nF\n\n1.8%\n\nR\n\n1.7%\n\nae\n\n1.7%\n\nTable 4A. Continued.\n\nLetters & Identities Sorted\nby Normalized Frequency\nOriginal\nLetter or Frequency\nIdentity as a percent\n\n\fAE\n\n1.6%\n\nC\n\n1.5%\n\n\u00f4\n\n1.5%\n\n\u00f6\n\n1.5%\n\n\u00fb\n\n1.4%\n\nH\n\n1.3%\n\n\u00f2\n\n1.3%\n\nB\n\n1.3%\n\nK\n\n0.8%\n\nV\n\n0.8%\n\nW\n\n0.8%\n\nQ\n\n0.1%\n\nX\n\n0.1%\n\nJ\n\n0.0%\n\nZ\n\n0.0%\n\nTable 4B. Continued.\nTables 4A & 4B above shows the results of the frequency\nnormalization process herein discussed. Table 4A lists the letters\naccording to the frequency order prior to normalization. The\nidentities of a letter are grouped with the letter itself. Table 4B\nshows the letters and their identities, both, sorted by their\nfrequencies after normalization.\nObservations: Several infrequently found letters rise to the top.\nFrequent letters are buried deep below.\nFrequency analysis observations:\n\n\u2022\n\nThere are 46 symbols\n\n\u2022\n\nThe average frequency is 2.1%\n\n\u2022\n\nThe standard deviation of the frequency of any given\nsymbol is approximately 1% (0.995%)\n\n\u2022\n\nFrequencies between 1.1% -- 3.1% are within the\nstandard deviation of the mean.\n\n\u2022\n\n72% of the symbols (33/46) (approximately 3\u20444) appear\nwithin a frequency range of the standard deviation\n(1%) from the mean (average).\n\n\u2022\n\nThe remaining 18% of the symbols appear within a\nfrequency range of 2% from the mean.\n\nComparison of Tables 4 with Tables 6:\n\n\u2022\n\nCompare the standard deviation of the expanded\nsymbol set: 1% from Table 4; with the original\nstandard deviation of 3.4% from Table 2B.\n\n\u2022\n\nAll the letters from the expanded symbol set have a\nfrequency less than the original average frequency.\n[Compare the highest frequency of the expanded\nsymbol set: 3.7% from Table 4B; with the average\nfrequency of 3.9% from Table 2B.]\n\nWith only a 1% difference between the majority of frequencies\nafter normalization, the symbols are can not be differentiated\nafter normalization if ciphered.\nAlso, the decipherer can not know, that extra symbols have been\nadded. Even if an assumption (guess) that extra symbols have\nbeen added, one can not know which symbols are the extra\nsymbols.\n\n3.\nENCRYPTING THE BINARY\n3.1\nFUNDAMENTAL PRINCIPLES:\nBREAKING THE TRANSITIVITY AND\nCORRESPONDENCE OF ALPHABET TO\nBASE 2\n[This section is not intended as a survey. It merely states all the\ncomputer science principles necessary to understand the\ncryptographic process.]\nEncryption is an integral part of computing.\nElectronic computers use an immense number of tiny electronic\nswitches, measuring on and off, voltage positions of high or low.\n[MAL01] The status of these switches (on or off) is easily\nrepresented by a binary system \u2013 a system of only two\npossibilities. [MAL01] When stringed together, the many\ndifferent combinations of just two possibilities, provide enough\nsymbols for our needs. E.g. All the letters of the alphabet,\nletters of multiple alphabets, punctuation marks, numerals,\ndifferent machine control codes, different machine operation\ncodes, etc.\nThe string of switches are conventionally converted to the\nnumerals 0 & 1 for easy representation. Also, these numerals (0\n& 1) are conventionally grouped together. Due to the binary\nnature of the numbers and operation of current electronic\ncomputing machinery, a binary numeral system is used.\n[MAL01]\nAs binary numbers go beyond several digit places, they become\nunwieldy for human comprehension. An easy mathematical\nway, of representing large binary numbers, is to convert them\ninto a number that represents an exponential multiple of 2. E.g.\nBase 16 (base16), is the 4th exponential multiple of 2\n(2x2x2x2=16). Using base 16 makes it easier for humans to\nconceptualize and deal with the large number of switches, their\n\n\fcombinations, and the codes used for the combination of\nswitches.\nA base16 number represents 4 binary digits. Two base 16 numbers\nare referred to as one byte and represents 8 switches. The\npossible number of combinations and permutations of all the\nbinary switches (and digits) for 2 base 16 numbers is 256.\n[GOL001] This number (256) provides a sufficient amount of\ncodes for all the symbols usually needed to represent linguistic\ndata (letters and punctuation marks). [JEN01]\nA code book to correlate the base 16 numbers to the language\nsymbols is needed [JEN01]. There are two common code\nbooks. They are referred to as ASCII and EBCIDIC [COL01]\n[HOD01], with ASCII being more pervasive as it is used in PC\ncomputers.2\nAs a rule, most encryption systems take the ASCII value as a\ndecimal number or; some numerical value standing for the\nlanguage symbol, and scramble it somehow. (Either by\nencoding, enciphering or encryption, as will be explained in\ndetail below.) [KAH11] Then, the new number is translated into\na base 2 binary number.\nIf instead of using the standard base 2 binary representation for\nASCII values, an alternate binary representation can be used.\nE.g. The letter \"A\" has an ASCII value of 65 in base 10. The\nnumber 6510 in binary, base 2, is represented as 0100 0001.\nHowever, quite logically and mathematically, the same number,\ncould be represented in a binary system \u2013 that is not base 2 \u2013 as\n0001 1000 0000.\nIndeed, as will be explained mathematically and\ncryptographically, there are many binary number systems:\nSome natural and many, unnatural.\nThe advantage to using alternate binary systems becomes clear\nwhen the decryption process is understood.\nWhile the\ndecryption process will be explained below in detail, in very\nbrief, it integrally involves a frequency analysis of the symbol\nset, the numbers representing the letters of the alphabet. Any\ngiven language will have an intrinsic frequency to certain letters\nand sounds. Some of which, will be high and, some will be low.\nBy counting the frequency of symbols in a secret message and;\nmatching those frequencies to the frequencies of the symbols\nwithin a given language, one slowly develops a correspondence\nbetween encrypted symbols and the alphabet. Thus, a message\n2\n\nWhile I could not find a citation or study to support this claim,\nit would appear, that as PCs are a ubiquitous commodity item\nand; mainframes a large ticket item reserved for government\nand industry; therefore, PCs are more prevalent than\nmainframes. And, as EBCDIC is an IBM code table, used for\nIBM mainframes [GAN01]; whereas ASCII is used on PCs;\ntherefore: it appears that ASCII is more common than\nEBCDIC. In addition, ASCII is the backbone of Internet\ncommunications [HOD01].\n\nis decrypted. With more advanced encryption techniques,\nhighly sophisticated mathematics are needed to determine the\nfrequencies. But, the process remains the same: Find the most\ncommon letter, the 2nd most common letter, the 3rd most\ncommon letter, etc. [KAH05]\nThis decryption technique works, because, ultimately, a person\nis always working on only one symbol set. I.e. The letters of the\nknown alphabet. The resultant encrypted letter (the output of\nthe encryption) is always equal to a specific ASCII symbol.\nMeaning, however you encrypt your original text message, if the\noutput is an \"A\", that \"A\" will always be an ASCII 65. And,\nany given ASCII number will always be equal to the same\nspecific base2 number. Serial ciphering will not alter the\nfrequency of the letters in a message. No matter how many\nconsecutive types of scrambling from alphabet, to base 10 to base2\nare used; the same inherent frequency of the source remains.\n[KAH11]\nA basic transitivity exists:\nASOURCE SYMBOL \u2194 BASCII BASE 16 NUMBER/CODE BOOK \u2194 CBASE 2 BINARY NUMBER\nSo, no matter how many different substitutions you use to\nscramble an \"A\" \u2013 only the representation by number changes.\nYou never change the codebook! The ASCII table always\nremains the same! And, you never change the base 2 binary\nnumber which is necessary to convert the ASCII number into a\nstring of switches for the computer to work with!\nIf you break the transitivity; if the binary number is not a base 2\nnumber; if the binary number is one of many different binary\nnumbers; then, two totally different relationships have been\nscrambled. The ASOURCE SYMBOL \u2194 BASCII BASE 16 NUMBER/CODE BOOK\nrelationship is independently scrambled from the BASCII BASE 16\nNUMBER/CODE BOOK \u2194 CBASE 2 BINARY NUMBER relationship. In addition, the\nBASCII BASE 16 NUMBER/CODE BOOK \u2194 CBASE 2 BINARY NUMBER is not a linguistic\nscrambling! Meaning, that there is no frequency analysis to be\nhad, to figure out which decimal number is the most frequently\nencrypted, the 2nd most frequently encrypted, etc. By visual\ninspection, one can not know which binary system one is\nlooking at.\n(As will be explained below, there are some intricacies to specific\nbinary systems that may exhibit or exclude certain visual\npatterns. But, this is not definite. And, a sufficient number of\nbinary systems are available, that have no indicators whatsoever,\nto make scrambling of the binary system possible and logically\nirreversible.)\nThus, using the procedure above, a very strong encryption\ntechnique can be made with only the major drawback, that it is\nimperative to keep the keys or code tables as well as the binary\nsystem used, secret!\n\n\fTo-date, neither the author nor any reviewer of this article has\nnever read of any encoding or encryption device that uses this\ntechnique. Nor, has the author ever read of a proposal for using\nthis technique. And, while there are mathematical works\ndiscussing binary systems and converting binary numbers to a\nstandard form [KNO01] [WIK01]; the author has never heard or\nread of any one, applying such knowledge to encrypt a binary\ntransmission. Usually, encryption is done on the letters, not on\nthe binary representation.\n\n3.2\n\nPlaintext\nIn\n\nCipher Text\n\nYes\nNumerical Value\nAssigned to Letter?\n\nDEFINITIONS:\nNo\n\n[While it is customary to explain all technical terms in the\nbeginning of a paper, prior to using them, doing so, in this\ninstance, may give the impression of a survey. Therefore, this\nsection has been made a glossary at the end of the article. The\nglossary defines all computer science, mathematical, linguistic\nand cryptographic terms used in this paper. The reader may\nwish to read the glossary before proceeding. Or; to continue\nreading and refer to the glossary for those terms which are\nunfamiliar.]\n\n3.3\n\nTranslate Alpha\nLetters to ASCII\n\nTranslate\nNumerical Value of\nLetters to Binary\nBase 2\n\nTHE PROCESS:\n\nThe process is easily understood, but in application, may be\nmore complicated:\n1.\n\nSimply encipher or encrypt the letters of the message.\n\n2.\n\nIf a numerical value has already been assigned to each\nenciphered letter, then skip the next step.\n\n3.\n\nIf a numerical value has not been assigned to each\nenciphered letter, translate the enciphered letters into\nASCII\n\n4.\n\nTranslate the ASCII into base 2 binary.\n\n5.\n\nCipher the base 2 binary with another binary system.\n\nTranslate Binary\nBase 2 to Another\nBinary System\n\nFlowchart A.\n\n3.4\n\nIMPLEMENTATION:\n\nNow, we can get into the details of operation for encryption\nmethods using alternate binary systems. From the definitions\nabove, it is clear that aside from base 2, there are four natural\nbinary systems: Fibonacci and Phinary, both standard and nonstandard.\nAs for unnatural binary systems, many could be constructed.\nAll that would be required is to either refer to a different series,\nother than Fibonacci. Or, exclude certain numbers from the\nnatural order. Thus, by creating gaps in the number line, a new\nnumbering system will be had. E.g. 0, 1, 3, 5 Or, in a binary\nformat: \"0000\", \"0010\", \"0100\", \"0101\". If one is trying to\nencode, just the 26 letter alphabet, then, within a two byte space,\n16 bits, many numerical systems could be had. (The significance\nof two bytes will soon become apparent.) In fact, for Fibonacci\nrepresentation, only 5 bits would be needed for a reasonable\n\n\fminimum. Since encryption and confusion are the goal, there is\nno maximum to the number of bits we could use to generate\nartificial numbering systems. Quite a large number of binary\nsystems could be generated with 16 bits alone. And, although it\nwill take more bits to represent the message, the tradeoff will be\nmore than worth the security of the data encryption, as will be\nexplained below.\nUsing just 16 bits, to produce 256 symbols, which only requires\n8 bits, will produce many extraneous, \"don't care\", symbols.\nThe decryptor can not know which ones are the \"don't' care\"\nsymbols. Nor does the bit sequence have to be consecutive.\nE.g. The first 2 bits could be part of the number, but the next 2\nbits could not be part of the number. E.g. If instead of writing\n\"1111 11112\" for 256; one could write: \"0000 1111 1111\n0000encrypted base\". The inability of the computer to do math with\nsuch a binary number is irrelevant. The encryption is the only\nrelevant matter.\nThe total number of 256 binary number encryption tables that\ncould be constructed, for 256 numbers is, out of 16 binary digits\n(bits) : 1024*1023*1022*1021*...*768. [The first number can\nbe one of any of the 1024 bit combinations. Now that one\ncombination has been used, the next number can only be one of\n1024-1, or 1023 bit combinations. Now that one more\ncombination has been used, the next number can only be one of\n1024-2, or 1022 bit combinations.] That is a mighty large\nnumber!\nWhile it can be argued that this is just another cipher, and serial\nciphering does not really add to the complexity of deciphering\nKAH11]; the difference is, that neither the letters nor a numerical\nidentity for the letters [A=1, B=2, etc.] are not being serially\nciphered! The binary numbers themselves are being ciphered!\nAnd, it is not a mathematical formula to be deciphered! It's a\ncode table!\nAlso, that the decipherers are expecting 8 bit groups to represent\nnumbers. And, there is no way to know if this is a two 8 bit\ngroups or one 16 bit group. It will be unknown as to how many\ndifferent bit groups were used in enciphering a message if an 8\nbit group does not work. And, if an 8 bit grouping does not\nwork, it is unknown if that is because it is not the right bit\ngrouping or; because of a complicated cipher/frequency\nconfounding encryption scheme.\nAnd, if just numbers are being encrypted, there is usually, no\nway to reverse that encryption. For example, I could encrypt all\nthe numbers in a checkbook, with a numerical translation table.\nThat is not decryptable. One can not reconstruct the proper\nbinary numbers from encrypted binary numbers.\n[Statistics are a funny thing. If it looks too good to be true, it is.\nThere is something known as the \"First Digit Phenomenon\" and\nBenford's Law. It is a statistical law about distribution which\n\nexplains a fact, that taking random numbers \u2013 first digits, such as\nin lists, usually produces a certain distribution of numerals. 30%\nfor 1, 17.6% for 2, etc. This statistical law has been used in\naudits to find fraud. If it is used in the decryption of numerical\ndata I do not know. The equation is (P=log(1+1/D). P \u2013\nProbability, D \u2013 The Digit in question. E.g. For the numeral\n\"1\": P=log(1+1/1)=log(1+1)=log 2 = 0.30 Also, not all lists\nfollow this law. So, even with Benford's law: The list in\nquestion may not be subject to Benford's law\n[LIV003]\n[LIV004] Even if the list in question is subject to Benford's law,\nsimply knowing something is wrong, does not tell what should\nbe right.]\nEach binary system will have its pros and cons in application \u2013\nwith computers or encryption.\nAs Huffman proved, the most compressed binary system is a\nbase 2 system. [HUF01] A clear advantage to using base 2\nbinary. Which means, conversely, if base 2 is the most\ncompressed binary system, then, there must be other binary\nsystems!\n\n3.4.1\n\nPhinary\n\nThe Phinary system, especially the standardized Phinary system,\nuses many bits per number.\nIt can be seen from simple\ninspection [See Table A, below, for the Phinary numbers 1 thru\n10.], that Phinary numbers require lots of digits. The tradeoff in\nsize will make the system produce very large bit-sized messages.\nMuch larger than other binary systems. However, for small\nmessages, this disadvantage may be of no significance. As often\noccurs, encryption is needed with short messages and not\nencyclopedias. So, in spite of the tradeoff, the increase in size\nand; subsequent transmission time, may be of no moment;\nconsidering the capacity of today's technology.\n\n\fDecimal\n\nTo illustrate:\n\nBase \u03c6\n\n1\n\n1\n\n2\n\n10.01\n\n3\n\n100.01\n\n4\n\n101.01\n\n5\n\n1000.1001\n\n6\n\n1010.0001\n\n7\n\n10000.0001\n\n8\n\n10001.0001\n\n9\n\n10010.0101\n\n10\n\n10100.0101\n\nTable A.\n\n3.4.2\n\nFibonacci Representation\n\nWhile Fibonacci representation does not generate as many digits\nas the Phinary system, still, it requires more digits than a base 2\nsystem. In fact, to express, the 256 characters of the entire\nASCII table, will require 12 digits in Fibonacci. This is not that\nsignificant an increase in the number of bits used.\nIn addition, at the very minimum, four bits must be added to\ncomplete one byte to facilitate most computer operations. If\nfour more bits-digits, extraneous digits are added to a 12\nbit/digit Fibonacci number, then, the Fibonacci number appears\njust like two 8 bit base 2 numbers taking up 2 bytes.\nAlso, if four extraneous digits are added, then many additional\nbit patterns can be created and substituted for natural Fibonacci\nbinary numbers. E.g. If the first four bits of every two bytes, is\nin a \"don't care\" state, then, the first four bits can be randomly\nfilled with garbage data \u2013 noise. This will only add to the\nconfusion of the binary number ciphering.\nIf every 12 bit Fibonacci number is padded with 4 bits, then, this\nis an increase of merely 1/3 the size of the entire message. Such\na trade off in length is not a negative attribute given the current\ncapacities of today's computers and transmission facilities.\nConfusion is paramount. A little extra space or time is of\nminimal concern.\nIn addition, if no padding of extra bits are used, but two 12 bit\nFibonacci numbers are laid out, one after the other, then; two\nconsecutive Fibonacci numbers appear as 3 two byte base 2\nnumbers.\n\nUsing big endian, the highest natural Fibonacci number needed\nto express 256 is\n\"1111 0000 0000FIB\"\n= (1x12210) + (1x6810) + (1x4410) + (1x2110) + (0x1310) + (0x810) +\n(0x510) + (0x310) + (0x210) + (0x110) + (0x110) + (0x0)\n= 25510.\nAdding 4 extra bits, to fill out a byte, I could write the Fibonacci\nnumber \"1111 0000 0000FIB\" as: \"0000 1111 0000 0000FIB\" and\nexpress this number in two bytes. If I so desired, I could\nsubstitute, encipher, this Fibonacci number, \"1111 0000 0000FIB\",\nwith \"1010 0000 0000 0000\" or \"1010 1111 0000 0000\". Further\nconfounding the encryption process and creating more binary\nsystems.\nSo we see, that length, symbol boundaries and (byte) word\nboundaries are of significance in both encryption and\ndecryption.\nSince, if I were to employ enciphering of the binary system, as\npart of my encryption method, by picking and choosing from\ndifferent binary systems; I could \u2013 as described above \u2013 create a\nbinary system, made of 2 bytes, from which, I use only a\nsufficient set of symbols to express 256 out of the 1024\npossibilities.\nIndeed, using a two byte cipher for a one byte base 2 binary\nnumber, I could construct a cipher that would imitate a\nstandardized Fibonacci number.\nThis possible identity,\ndemonstrates, that I could totally confound a message\nrepresented in a binary coding system by encrypting just the\nbinary.\nFurthermore: If I take a 40 character message, and transmit the\nsame message as 4,000 bytes containing ciphered numbers,\nFibonancci or not; unless the interceptor knows the length of\nthe original message, there is no way to know, just how big a\nbinary group might be and; how many binary groupings have\nbeen transmitted. Perhaps, forty 8 bit bytes were sent with a lot\nof garbage in between. Which means, that the binary encoding\nrequires one hundred 8 bit bytes per character.\nOne could use base 2 binary, but, exclude all numbers that have\nan \"11\" sequence, in order to mimic a standardized Phinary\nbinary system. Again, ambiguity provides obfuscation.\nPracticality will limit the number of binary bases available for\nuse. But even so, there are a sufficient number of possibilities to\n\n\fconfound the process sufficiently to make methodical deductive\ndecryption impossible.\n\n3.4.3\n\nGolden Sequence Representation\n\nUse successive sequences of golden sequence symbols as\nnumerals to represent numeric data for ciphering and encryption.\nBecause of the order of the symbols, i.e. no symbol starts with a\n\"0\" or; that each symbol must be a combination of previous\nsymbols; therefore, a string of golden sequence symbols can be\nbroken up into individual parts.\nAgain, the symbols are purely binary. Again, there is no way of\ndiscerning these symbols from base 2 binary.\n\n3.4.4\n\nBase Prime Representation\n\nOne could define any number as a sum of prime numbers\nsmaller than that number itself; with each prime number being\nused only once. Hence, if we use bits to represent the prime\nnumber sequence; e.g. 1, 2, 3, 5, 7, 11... In a fashion similar to\nFibonacci representation, we could use prime number\nrepresentation, to define each number.\nFor sure, we can conjure up other sequences as well, to use to\nmimic the idea of numeric representation, as we started with\nFibonacci representation.\n\n3.4.5\n\nBoustrophedon:\n\nIf boustrophedon is applied to bit sequences, binary numbers,\nthe result is NOT a mathematical inversion. (E.g. \"0000 0001\"\nbecomes \"1000 0000\") This is neither an additive, nor\nmultiplicative inverse nor; is this multiplication by (\u20131) or some\nsuch procedure. It is a physical inversion. This is not\ndecipherable by some mathematical calculation. It is a pictorial\nencryption and the picture still looks legitimate. There is no\nlogical or mathematical way to know, what the original number\nwas.\nHowever, as in many forms of ciphering, even if the original\nsymbols are swapped with new symbols; the original frequency\nis maintained. Even if I do not know what the new symbols\nstand for. And, so long as the language's frequency is\nmaintained, it is decipherable. Or better put, translatable from\nthe binary code to the original alpha letters.\nBut, if alternation (e.g. every other byte is inverted) or other\nvariables are introduced (such as an encoding the letters with a\nkey or an encryption method prior to inverting the binary); since\none can not tell the difference between the pictures; the\nfrequency analysis is confounded. Once the frequency analysis\n\nis confounded, the message can no longer be decrypted. -- This\nwill be true for any combination of methods that encrypt the\nbinary numbers and confound the frequency analysis.\nAlternating inversion of the bits with every other byte, would\nproduce very interesting results. Because, while it would halve\nthe frequency of some letters, it would increase the frequency of\nother letters. Hence, the frequency distribution is disturbed. In\nfact, by reason, it would halve the frequency of higher, more\nfrequent letters. Alternating boustrophedon would perform an\nincomplete frequency normalization.\nIn addition, there is no code table. What is necessary for\ndecoding, is the right sequence, starting position for inversion,\nand jump order (how many bytes to skip between inversions),\netc. These are parameters that are easily altered.\nCertainly, if a complex mathematical formula was used to\nencrypt the data; and then, the resultant binary data was\nencrypted with boustrophedon; decryption would be impossible\nas correct mathematical calculations would be impossible and;\ndeciphering numeric encryption is not possible.\nHowever, we must remember, as is prone with encryption &\nencoding, espionage is engaged in, to steal the encryption\nalgorithm or the codebook. (See [KAH14] for a good example of\nthe necessity of stealing a codebook.) That would be true of\nencrypted binary systems too. The only good \u2013 and sensible\ndefense, is to continually change the encryption method or\ncodebook.\n[KAH07] [KAH08]\nEncrypting the binary,\nespecially with ciphered Fibonacci numbers, permits quick and\nconstant alternate codebook generation.\nFrom real life: Towards the end of WWII, the U.S. Army was\nchanging codebooks for the U.S. forces in Europe at a rate of\nonce every two weeks. [KAH01] The Japanese, who failed to\nchange their codebooks, faced devastating results. [KAH07]\n[KAH08]\nFor example, look at Table 5. The left most column is a digit\nsequence. The middle column is a base. The right most column\nis the value of the sequence in base 10. Every number is written\nas \"11\". But, if I do not know what the base is, I do not know\nwhat the number means. For all you know, it's \"11\" in base 256\nor base 1024!\n\n\fSymbolic\nRepresentation\n\nBase\n\nBase\n10\nEquivalent\n\nA\n\n0.082\n\nB\n\n0.015\n\nC\n\n0.025\n\n11\n\nBase 2\n\n3\n\nD\n\n0.043\n\n11\n\nBase 3\n\n4\n\nE\n\n0.127\n\n11\n\nBase 4\n\n5\n\nF\n\n0.022\n\n11\n\nBase 5\n\n6\n\nG\n\n0.020\n\n11\n\nBase 6\n\n7\n\nH\n\n0.061\n\n11\n\nBase 7\n\n8\n\nI\n\n0.070\n\n11\n\nBase 8\n\n9\n\nJ\n\n0.002\n\n11\n\nBase 9\n\n10\n\nK\n\n0.008\n\n11\n\nBase 10\n\n11\n\nL\n\n0.040\n\n11\n\nBase 16\n\n17\n\nM\n\n0.024\n\nN\n\n0.067\n\nO\n\n0.075\n\nP\n\n0.019\n\nQ\n\n0.001\n\nR\n\n0.060\n\nS\n\n0.063\n\nT\n\n0.091\n\nU\n\n0.028\n\nV\n\n0.010\n\nW\n\n0.023\n\nX\n\n0.001\n\nY\n\n0.020\n\nZ\n\n0.001\n\nTable 5\nThe same would be true for expressing binary in a variety of\ndifferent bases.\nTake another example that has many significances. If I wanted\nto encrypt the numbers in a checkbook, and I use a simple cipher\nof adding one to a digit [9+1 becomes 0], then I transmit the\nnumbers, that can not be decrypted. It is not possible. One\nneeds some kind of mathematical reference, a total \u2013 correct or\nincorrect \u2013 to even know, if an encryption has been attempted.\nLanguages, as will be explained below in detail, have a natural\nfrequency distribution of letters3 [KAH15] \u2013 numbers do not!\nUnless there is a restriction on the possible numbers somehow,\nlike map coordinates [KAH01] [VAU03] to clue one in\nsomehow, there is no way of decrypting encrypted numbers. -When this fact is factored into encrypting the binary, that one is\nencrypting numbers and not letters; then it becomes apparent\nthat if the binary is encrypted, the binary can not be decrypted.\n\nTable B.\nFrequency Distribution of Letters [VAU03]\nThis is very significant. Because often, secret messages often\ncontain just numeric or monetary values. A very practical and\nhistorical example is that of agents representing buyers and\nbidders. The various agents, during the bidder process, must\ncommunicate with their home offices. But, the agents and\nbuyers do not want their competition to know what price they\nare bidding.\nTo implement this, we need to remember that quite often, secret\nmessages will have the minimum of information to get the\nmessage across. E.g. Go. Yes. No. Buy. Sell. Etc. Also, a\ncode includes a prearranged agreement to symbols, which\nincludes the symbol sequence. If an agent transmits just two\nnumbers; the first the agent's bid, the second the competition's\nbid and, the buyer knows this sequence and; the numbers are\n\n3\n\nSee Table B.\n\n\fencrypted and; that's all there is to the message; that is not a\ndecryptable message.\nE.g. Simply add or subtract 5 from every digit to any sale price.\nOr, just add or subtract $5, from every sale price.\nIn sum, from the above examples, it becomes imminently clear,\nthat enciphering the binary number has no connection with the\nencryption of the letters associated with the ASCII table.\nFurthermore, if so desired, alternates to the natural binary\nsystems can be employed increasing the number of possible\nciphers for enciphering base 2.\nAlso, we must take into consideration, that while the ASCII table\nrepresents 256 characters; commonly, messages use far few\ncharacters. The rich character set of ASCII includes machine\ncontrol codes, e.g. carriage return, new line, etc. The rich\ncharacter set is not necessary for the data payload. Also, the\nASCII character set includes graphics or other language letter\nsymbols as well as capital and miniscule letters. Miniscule letters\nare often a redundancy that is eliminated in encryption.\nIn addition, the table could also be enciphered in and of itself.\nAdding to the confusion. E.g. The letter \"A\" could be\nrepresented by the number 32, instead of 65. This enciphering is\nalso separate from the encryption of the letters of the original\nplaintext message. (But, this could be viewed as just serial\nenciphering, which does not really add to the strength of the\nencryption.)\n\n4.\nSUMMARY OF BREAKING THE\nTRANSITIVITY AND CORRESPONDENCE\nOF ALPHABET TO BASE 2:\nThe ultimate goal of all language encryption is to confound the\nfrequency analysis.\nEvery language has a frequency for the letters within the\nlanguage. [KAH15] The frequency is different for each language.\nIn English, the letters 'E', 'T', 'O', 'N', 'I', 'S' are the most\ncommon, with \"E\" being approximately 13% [KAH09]\n[KAH10] or 12.7% [VAU03]. This frequency does not really\nchange. [KAH05] And, with more written samples, the more\ndefinite the frequency becomes. [KAH05]\nThe most basic kind of encryption, simple ciphering, replacing\neach letter with a different letter, will not alter the frequency of\nthe letters. The cipher will look different from legible text, but,\nwhen tallied, the frequency of the letters will be the same.\n[KAH11]\n\nE.g. \"The quick brown fox jumped lazily over the sleepy dog.\"\n-- This sentence is used when teaching typing because it has\nevery letter in the alphabet. An unnatural contrivance, true,\nwhich just strengthens the point that innate frequencies of letters\nexist. An analysis of the sentence reveals the following\ntabulation:\nAlphabetical Listing\n\nSorted by Frequency\nBy Alphabetically\n\nLetter Tally Frequency\n\nLetter Tally Frequency\n\nA\n\n1\n\n1/44 = 2.3%\n\nE\n\n6 6/44 = 13.6%\n\nB\n\n1\n\n1/44 = 2.3%\n\nO\n\n4\n\n4/44 = 9.0%\n\nC\n\n1\n\n1/44 = 2.3%\n\nL\n\n3\n\n3/44 = 6.8%\n\nD\n\n2\n\n2/44 = 2.5%\n\nD\n\n2\n\n2/44 = 2.5%\n\nE\n\n6 6/44 = 13.6%\n\nH\n\n2\n\n2/44 = 2.5%\n\nF\n\n1\n\n1/44 = 2.3%\n\nI\n\n2\n\n2/44 = 2.5%\n\nG\n\n1\n\n1/44 = 2.3%\n\nR\n\n2\n\n2/44 = 2.5%\n\nH\n\n2\n\n2/44 = 2.5%\n\nT\n\n2\n\n2/44 = 2.5%\n\nI\n\n2\n\n2/44 = 2.5%\n\nU\n\n2\n\n2/44 = 2.5%\n\nJ\n\n1\n\n1/44 = 2.3%\n\nA\n\n1\n\n1/44 = 2.3%\n\nK\n\n1\n\n1/44 = 2.3%\n\nB\n\n1\n\n1/44 = 2.3%\n\nL\n\n3\n\n3/44 = 6.8%\n\nC\n\n1\n\n1/44 = 2.3%\n\nM\n\n1\n\n1/44 = 2.3%\n\nF\n\n1\n\n1/44 = 2.3%\n\nN\n\n1\n\n1/44 = 2.3%\n\nG\n\n1\n\n1/44 = 2.3%\n\nO\n\n4\n\n4/44 = 9.0%\n\nJ\n\n1\n\n1/44 = 2.3%\n\nP\n\n1\n\n1/44 = 2.3%\n\nK\n\n1\n\n1/44 = 2.3%\n\nQ\n\n1\n\n1/44 = 2.3%\n\nM\n\n1\n\n1/44 = 2.3%\n\nR\n\n2\n\n2/44 = 2.5%\n\nN\n\n1\n\n1/44 = 2.3%\n\nS\n\n1\n\n1/44 = 2.3%\n\nP\n\n1\n\n1/44 = 2.3%\n\nT\n\n2\n\n2/44 = 2.5%\n\nQ\n\n1\n\n1/44 = 2.3%\n\nU\n\n2\n\n2/44 = 2.5%\n\nS\n\n1\n\n1/44 = 2.3%\n\nV\n\n1\n\n1/44 = 2.3%\n\nV\n\n1\n\n1/44 = 2.3%\n\nW\n\n1\n\n1/44 = 2.3%\n\nW\n\n1\n\n1/44 = 2.3%\n\nX\n\n1\n\n1/44 = 2.3%\n\nX\n\n1\n\n1/44 = 2.3%\n\nY\n\n1\n\n1/44 = 2.3%\n\nY\n\n1\n\n1/44 = 2.3%\n\nZ\n\n1\n\n1/44 = 2.3%\n\nZ\n\n1\n\n1/44 = 2.3%\n\nTable 6.\nSub-Table A.\n\nSub-Table B.\n\nIt must be remembered, that this sentence is contrived to contain\nevery letter in the alphabet. Even in a contrived sentence like\n\n\fthis, the frequent occurrence of the letter \"E\" can not be avoided.\nIn regular text, with a greater statistical sample (of letters), the\nfrequency will be apparent.\nReturning to the example sentence, notice, that if I replace all the\n'e's with 'q's, how the frequency is unaltered: \"Thq euick\nbrown fox jumpqd lazily ovqr thq slqqpy dog.\" -- There is now\none 'e' and 6 'q's. The letters look different, but the frequency\nis the same.\nSerial enciphering, using one cipher substitution after another,\nmay appear complicated, but in reality, it does nothing to alter\nthe difficulty of decryption. Because, once again, the frequency\nanalysis is unaltered. And, it is entirely a binary correspondence.\nE.g. If I repeat the substitution from the above example, and\nnow replace all the 'q's with 'x's; then I have:\n\"Thx euick\nbrown foq jumpxd lazily ovxr thx slxxpy dog.\" There are now 6\n'x's, representing the same letter.\nAnd, only one 'q',\nrepresenting the only 'x' in the sentence.\nWhat more complicated ciphering does, is to alternate, which\nletters replace other letters. Often, this is done with a key. So,\nthat given a word, like \"sleepy\", the replacement for the 1 st 'e'\nwill be 'q', but the replacement for the 2 nd 'e' will be 'x'. Now,\nwhen encoded, we have \"slqxpy\". Now, the frequency of the\nappearance of the letter 'e', has been changed.\nAs interesting as the subject is, I will not go into the complexity\nof the keys and methodology of decryption. (I refer interested\nreaders to David Kahn's excellent book, The Codebreakers.\n[KAH01]) Suffice to say, some trace of cyclic repetition remains\nand can be ultimately factored out.\nAlbeit by difficult\nmathematical means and computers, but any key, no matter how\nlong, so long as it repeats, can eventually be decrypted. This is\nwhy large prime numbers are so important to encryption.\nBecause one can go on for millions of digits, without a repetition\never occurring. Think of digits as characters, or alterations to\ncharacters.\nAs David Kahn, a great historian of cryptography noted\n[KAH05] [KAH11], people often mistakenly think that it is the\ncomplexity of the encryption that makes something\ndecipherable. But, this is a fallacy. Indeed, the method herein\nproposed, is a simple, and yet, quite elegant way, of encrypting\nand making something undecipherable.\nBut, by employing alternate binary systems, and encoding the\nbinary translation of an enciphered message, one is not adding to\nthe same target of substitution. The binary encoding does not\njust add another layer of substitution to the letters, albeit a bit\nmore complicated. Encrypting the binary number system is a\ndifferent target of encryption than the letters of the message.\n\nTherefore, the ternary correspondence of letter to ASCII to\nbinary is irrevocably altered.\nDisregarding the ASCII table. One can conceive of the\nencryption used with computers, as the substitution of a base 10\n(decimal) number for a letter; which is then converted from base\n10 to base 2 binary. Even this simple correspondence of base 10\nto base 2 binary is broken with binary encryption.\n[In the examples to follow, { }, ( ) & [ ] are used to pair\ncorresponding symbols and connote a relationship. Symbols\noutside an enclosure are enciphered symbols referencing the\nsymbols inside the enclosure marks.]\nConventional encryption only encrypts the letters of the original\nplaintext message. There is a simple logic, that A SOURCE SYMBOL =\nBASCII BASE 16 NUMBER/CODE BOOK = CBASE 2 BINARY NUMBER. A=B=C. And, no\nmatter what kind of cosmetic alteration to \"A\" is done, it\nremains, that A=B=C. Only one variable, \"A\", is encrypted.\nBut, the relation, A=B=C is still valid. E.g. In binary base 2,\nusing ASCII: \"A\" = 65 = \"0001 0001\". If some letter, \"Q\" for\nexample, is converted to another letter, \"A\" for example, by\nsome encryption technique, the correspondence has not been\nchanged. E.g. \"Q\" = [(65 = \"0001 000\") = \"A\"] So, really,\nonly one symbol has been encrypted. That limitation (of only\none symbol having been encrypted) makes decryption possible.\nHowever, if an alternate binary system is used, the\ncircumstances are different. E.g. \"A\" = 65 = \"0001 1000 0000FIB\"\nalready alters the correspondence, A=B=C by only one\nenciphering. [(\"A\" = 65) = \"0001 00012\"] = \"0001 1000\n0000FIB\"). Such an alteration would be an enciphering \"0001\n1000 0000FIB\" = \"0001 00012\". If an additional enciphering is\nused, e.g. \"A\" is exchanged with \"Q\", then the transitivity is\nbroken. E.g. {\"Q\" = (\"A\"} = {65) = (\"0001 00012\"} = \"0001\n1000 0000FIB\"). A\u2260B\u2260C. And; enciphering BASCII BASE 16 NUMBER/CODE\nBOOK, would only complicate matters more, because any frame of\nreference is now gone. E.g. {\"Q\" = (\"A\"} = {[65=54]) = (\"0011\n01102\"} = \"0010 0100 1000FIB\").\n[It is more than serial enciphering, because the target of\nenciphering is different; the binary system is not directly\nattached, referencing, the original plaintext. Therefore, when the\nbinary system is enciphered, it is not an additional enciphering of\nthe original plaintext.]\n[In addition, enciphering the binary is not a mathematical\nchange, but a pictorial change.]\nThe frequency analysis is confounded because you don't know\nwhat you are counting. Meaning, let's assume the original\nmessage is in unencrypted English \u2013 Plaintext. You have a bit\nstream that was enciphered with \"a\" binary system. You have\nno way of knowing which binary system it is. You do not know\nif you should tally different individual bytes or; every different\nset of two bytes; or every 12 bits. The tally will not necessarily\n\n\fgenerate a frequency analysis similar to English. None of the\nfrequency analyses generated need be similar to English. More\nthan one frequency analysis may be similar to English. The\nmessage may be too short to confirm a frequency analysis. If a\nsophisticated encryption algorithm was first applied to the\nletters, to substitute for other letters, to severely confound the\nfrequency analysis, there may be no frequency observable. If\nsome unnatural binary coding system was used; with or without\na sophisticated encryption algorithm, a frequency analysis will\nnot be apparent. Best case scenario, you have to engage in many\nfrequency analyses, of several different bit lengths.\n\n5.\n\nDECRYPTING:\n\n5.1\n\nNormalized Letter Frequency\n\nThis would require assuming the language of the ciphertext and\nits corresponding frequency. Then, guesses would have to be\nmade to reconstruct the symbol set (of the alphabet). Apply the\nsymbol set guessed. See if the decrypt makes sense. The\nmagnitude of the decryption process would be measured in the\nfactorials of the possible combination of symbols.\nSpacing and punctuation-which may or may not have been\nincluded-would have to be taken into account.\nIt must be noted that the combinations of the frequencies will\nnot be exact. Frequencies are probabilities. Tolerance factors\nwill have to be introduced to guessing symbol sets. [The\nfrequency of the letter 'e' may be 11%, 12%, 13% or even 14%.\nAny combination of symbols within the range must be\nconsidered.] I have never seen an actual letter frequency which\nis a whole number.\nAlso, frequencies vary with text and probably with context.\nAlso, the smaller the text, the greater the possibility the\nfrequency will deviate from the standard frequency.\nOne option, is to select an assumed subset of symbols to be\nequal to the most frequent letter, 'e', then; 't', etc. Then apply\nthe assumed reconstructed symbol set to the ciphertext and see\nif it makes sense.\nHowever, if any kind of encryption was done to the ciphertext\nafter replacing the ordinary alphabet with the new symbol set\nthen; the regroupings and tests will be on the wrong symbols\nand combinations of symbols. There is no way to know what\nthe original symbols were and which encrypted symbols refer to\nwhich symbols in the (new, revised) extended symbol set.\nThis is not decryptable by method-uncrackable-unbreakable.\nBrute force is useless.\n\n5.2\n\nEncrypted Binary\n\nAs the encryption possibilities for the binary system increase, so\ndoes the decryption possibilities decrease.\n\nAgain, look at Table 5. If one does not know the value of the\nsequence of digits \"11\", one does not know the base. I can not.\nI can only guess or assume \u2013 which is a guess.\nSometimes, when it is known, that the numbers must have\ncertain values, decryption is possible. This scenario occurs in\nmilitary applications when determining encrypted map\ncoordinates. [KAH01]\nAgain, if I encrypt all the numbers in a checkbook with some\ncipher key, that can not be decrypted. A control number might\nindicate inaccuracies, but a control number will not indicate a\ndeciphering method. Certain arithmetic manipulations might\nindicate transpositions (exchanging certain numbers for others)\nwithin a given sum. But, a cipher will not be found.\nAgain, Benford's law might indicate something is amiss. But,\nBenford's law will not tell you what the correct numbers should\nbe.\nThe key to decryption of text expressed as numbers is in the\nrelationship of the numbers to the letters. When numbers\nrepresent letters, decryption is commonly done by frequency\nanalysis of the numerals representing the letters. [KAH05]\nWhen employing frequency normalization, there is no frequency\nanalysis to be had. Hence, the standard and common method of\ndecryption innately fails.\nAs explained in a previous paper [ZIR01], if the frequency is\naltered, then, decryption becomes difficult. If the frequency is\nsufficiently altered, then decryption is impossible.\nWhat an encryption key does is to alter the frequency of the\nappearance of letters, especially, even in any cyclic fashion of\nany kind. With longer and longer keys, one simply lowers the\nfrequency more and more. When one uses a large enough prime\nnumber as a key to encrypt a message; essentially, what one has\ndone is, to alter the frequency of appearance of each symbol to\n\"1\".\nTo undo frequency normalization, theoretically, one could guess\nand tally up different symbols, in different permutations,\nassuming a valid, normal frequency distribution. And; attempt\nto decipher the message based upon these guesses. However, if\nyou compare Tables 1A & 2A; you will see that there is a\ndifference between the frequency for the letter 'e', the most\ncommon letter in the alphabet between the two texts. Estimated\nfrequencies are not exact. It is only in theory, that some such\nbrute force method may be able to decipher such an encryption.\nThat theory requires many variables to become known\nconstants. This is not reality. There are too many variables and\nunknowns. In practicality, I do not think decryption of\nfrequency normalization is plausible.\n\n\f5.\nFor Example: Using a binary encryption scheme without adding\nnew symbols, -- assuming you know the source language,\nassuming there was no substitution or scrambling of the letters\nand; assuming no extra dummy letters have been added \u2013 at the\nvery minimum \u2013 from the methods listed in this paper alone \u2013\nseveral frequency analyses have to be done. After all, it could be\na 16 bit binary system. Or; an 8 bit binary system, but each 16\nbits is two 8 bit symbols. Or;, a 12 bit binary system, that\nrequires two bytes to represent itself, so it appears as two 8 bit\nsymbols. And, if a larger binary representation, such as \u03c6 is\nused, the number of possibilities and attempts increase. Also,\none has to account for big endian, little endian possibilities?\n\nExample:\n[(fn+1)/fn]=[(fn+2)/(fn+1)]=[(fn+3)/(fn+2)]=\n[(fn+4)/(fn+3)]... = The Golden Mean\n[LIV02]\nUsing a bit pattern correlating to the Fibonacci\nnumbers to represent letters, will not produce\nFibonacci numbers in sequence. Hence, you can not\ntest sequential numbers. If you can not test sequential\nnumbers, the tests will fail.\n\nIn fact, one could use base 2 binary, but skip each number that\ncontains a \"11\" in order to mimic a standardized Phinary binary\nsystem. There is no way to discern the difference.\nIf it is only several possibilities as described above, then, there\nare several analyses to review. Some will be gibberish, and one\nwill be valid. Assuming, nothing was done to confound the\nfrequency. But, extra letters could have been added in the\noriginal text. Or, a 12 bit binary system, could have been coded\nwith extra dummy numbers that are not valid, to distort the\nfrequency distribution. In fact, it is conceivable, that sufficient\nleeway is possible, to remove the frequency distribution\naltogether with dummy letters!\nWhile one might argue, that if a Fibonacci numbering system is\nbeing used, then, the (unique) properties of the Fibonacci system\nwill be discoverable. Then, the message could be decrypted. \u2013\nThis is a fallacy. I will explain:\n1.\n\nThe Fibonacci numbers are not being written \u2013 in or\nout of sequence.\n\n2.\n\nReferences to Fibonacci numbers are being written \u2013\nNOT Fibonacci numbers!\n\n3.\n\nThe Fibonacci numbers are only correlated to a bit\npattern.\n\n4.\n\nBut, the bit pattern itself does not express a Fibonacci\nnumber!\n\nUsing a bit pattern correlating to Fibonacci numbers to\nrepresent positive integers results in non-Fibonacci\nnumbers. -- I.e. The Fibonacci sequence has the series of\nnumbers, starting from 0 or 1, that satisfy the formula,\nfn=(fn-1)+(fn-2). The series is {0,1,1,2,3,5,8,13...}. While\nthe numbers 2 & 5 are Fibonacci numbers; their sum 7 is\nnot. Using a bit pattern (little endian) \"0010 1000FIB\" that\nreferences the Fibonacci series to indicate the addition of\n2+5; does not produce a Fibonacci number. [Even in base\n2, the bit pattern \"0010 10002\" = 3310. Thirty-three is not a\nFibonacci number either.]\n\nThe unusual properties of the Fibonacci sequence only\nappear, when the Fibonacci numbers are used in a way\nthat takes advantage of the numbers' order within the\nFibonacci series. I.e. (fn=Fibonacci number) fn,\nfn+1, fn+2, fn+3....\n\nIt should be intuitive that any bit pattern could be correlated to a\nsubset of the Fibonacci sequence or; any other sequence for that\nmatter. There is no way to determine what sequence, if any, the\nbit pattern is referring to.\nDecryption techniques other than frequency analysis are now\nnecessary; such as capturing known cleartext messages and their\ncorresponding ciphertext. It will become immediately apparent,\nthat there are more bytes than a one to one correspondence\nwould require. That could mean many things. But, it is a clear\nindication that a pure 8 bit/byte binary representation is NOT\nbeing used! Possibly, every other byte is a dummy byte. Or,\nsome other algorithm may be used to insert dummy bytes.\nSomeone may decide to encrypt each character with more than 2\nbytes. It is unknown how many bits did used for a valid\ncharacter.\nOf course, the more bits used, the longer the message, the longer\nthe time involved in transmitting that message. But, someone\nmay decide, the security is worth it.\n\n5.3\n\nBrute Force\n\nBrute force techniques are predicated upon the assumption, that\nthe method of decryption is known and; there are a finite \u2013 a\nvery large number \u2013 but finite, number of possible solutions. It\nis just the amount of time to test each and every possible\nsolution that is the obstacle.\nFor example, dictionary attacks for passwords. A password is\nknown to exist and all the possibilities of the password are\nknown. Exactly which characters can make up the password are\nknown. The possible lengths of the password are known. All\nthe possible permutations and combinations of characters are\nknown. There is a limited set of alphanumeric possibilities to the\npassword. A very large set, but a limited and known set. A\n\n\fperson trying each and every possible password, one at a time,\nwill take too long to penetrate the security. But, a computer\ncould do so in a half hour or, overnight. Or, with a distributed\nnetwork, over the course of months or years.\nBrute force attacks for longer messages and more complicated\nencryption methods usually attack targets assuming known\nmethods of encryption were used, especially methods that use\nkeys for ciphering. The long keys, the complicated mathematical\nequations, are all known. Computing the questions or testing the\nkeys takes a long time. But, it is doable. The time obstacle is\ndiminished by distributed computing or supercomputer power.\nBut, the basic principle of brute force decryption is:\n1.\n\nThe methods of encryption are known.\n\n2.\n\nAll possible keys are known \u2013 even if it is a very large\nnumber.\n\n3.\n\nThe numerical representation of the letter is known\nand; if reversing the mathematical encryption is\nnecessary, it is possible to do the math.\n\n4.\n\nIt is just a matter of processing time to perform all the\ncalculations.\n\n5.\n\nThe frequency of the letters in the ciphertext has been\nmaintained \u2013 in some form.\n\nWhen applying the rules necessary for a brute force decryption\nto the encryption methods described in this paper:\n1.\n\nThe methods of encryption are known. \u2013 We just\ndiscussed them.\n\n2.\n\nWhile the implementations of the methods of\nencryption, that we discussed, are finite; the\npossibilities are infinite: Unlike the possible number of\npasswords to a given system, which is finite.\n\n3.\n\nAs for keys:\n\n4.\n\na.\n\nWhile keys may be used and are known,\nthey are not necessarily an integral part of\nthe process. But, if keys are used, they are\nknown.\n\nb.\n\nSince the encryption method is based upon\npictorial representations; using combinations\nof 1s & 0s, in different or same length\nstrings; to reference subsets of numbers:\nThe question is, are the combinations of 1s\n& 0s, in different or same length strings\nfinite and/or the number of subsets of\nnumbers these representations refer to;\nfinite? \u2013 Since I can always add one more 0\nor 1 to the string, these pictorial\nrepresentations are infinite. As for the\nnumber of subsets of numbers referred to,\nno matter how large, it is finite.\n\nThe numerical representation of the letter is not known\nand; if reversing the mathematical encryption is\n\nnecessary, it is impossible to do the math until the\nnumerical representation is known.\n5.\n\nThe frequency of the letters in the ciphertext has not\nbeen maintained! -- A crucial difference!\n\n5.3.1 Brute Force Fails When Applied to an\nInfinite Number of Possibilities\nOnce an element of infinity has been introduced (point 2 & 3b),\nbrute force fails \u2013 as a method. Brute force may provide a lucky\nguess. But, brute force will not definitely provide an answer.\nThis is fundamental difference in applying brute force to binary\nencryption as opposed to key based encryption.\nExample: Currently, with a dictionary type attack on a 5 letter\npassword, the total number of possible passwords are 2565. A\nbig number. Not humanly possible, unless one is dedicating\none's life to the solution. One can think of medieval\nmathematicians calculating the values of sines, cosines and\nlogarithms. For a computer: It's just a half hour's work. It's\nnot a guess! It's an algorithm based upon permutations.\n\n5.3.2 Brute Force is Inaccurate When Applied to\nFrequency Normalization\nAgainst frequency normalization alone, not in conjunction with\nany other encryption method, brute force may, by assembling all\nthe possible permutations, reconstruct the original sequence.\nConsider: Pasting together symbols with different frequencies,\nto ascertain which sets of symbols represent actual alphabetic\nfrequencies, may follow a method. However, the frequencies of\nletters that we use, are only theoretical \u2013 not actual. The actual\nfrequencies fluctuate and differ between real messages.\nCompare Tables 4B & 6. Even for high ranking letters, the\nfrequencies of appearance are almost all not the same. \u2013 The\nfrequencies of appearance may be similar for the appearance of\nthe same letter in different texts; but usually the frequency of\nappearance is not the exact same frequency in two separate\ntexts. [E.g. In comparing Tables 6 & 2B, the letter \"E\" appears\n13.6% in Table 6 vs. 12.1% in Table 2B.] So, even though we\nhave a method, it is inaccurate and we may not succeed.\n\n5.3.3 The Possible Number of Binary\nRepresentations are Infinite\nWith the binary representation encryption methods described in\nthis paper, there is no algorithm to decryption. We start by\nguessing one method, then another, then another. What if the\nencryption uses a different implementation than one discussed in\nthis paper?\nWe have no method to try all different\nimplementations.\n\n\f5.3.4 Alternate Bit Patterns Appear Similar and\nCan Not Be Differentiated\nEssentially, by binary representation redundancy, we have\nintroduced a parameter into the encryption method that can not\nbe discerned by a computer. Akin to CAPTCHA, but the lack of\nidentity applies to humans as well. The computer can not tell by\nlooking at or, inspecting, the bit patterns; which binary\nrepresentation/encoding was used. Because, all possible bit\npatterns, are valid bit patterns, for many different possible\nrepresentations. E.g. If a sigma is used in English writing,\nsomething is wrong. A sigma is not an English letter. But, a\nFibonacci or prime number binary representation, is a valid bit\npattern for base 2.\nAlso, as the numeric representation is not known:\n1.\n\nWe have no way of mathematically solving for\nequations that may have encrypted the data.\n\n2.\n\nThe issue of reconstructing symbol subsets arises\nagain. Only this time, for the numbers themselves.\nThis encryption does not have a frequency analysis to\nuse as a basis for reconstruction. We have no method\nof reconstructing the numerical references, if\nfrequency normalization was used on the numerals.\n[Given the example above in Table 4, if using the\nFibonacci representation for the numbers 1 through\n46, many numbers can be represented by different\nsums of Fibonacci numbers. This encrypts the\nnumerals. \u2013 Not the letters.\nThis complicates\nreconstructing the symbol sets with the frequencies of\nletters and impedes such reconstruction.]\n\nOne can argue, that, if known binary numbers, were used for\nthese symbols, you could algorithmically \u2013 by method \u2013 go\nthrough a large number of permutations and reconstructions to\nattempt to guess the correct correspondence of sets of identities\nto letters. Although, this will require a lot of computing power\nand time.\n\nfor brute force. However, it will require human intervention,\nCAPTCHA, to inspect each possibility for correctness.\nHowever, in combination with binary number encryption,\ndecryption is not possible. Because, you do not know what\nsymbols to count. You can not create a tally for frequency\nanalysis or reconstruction.\nBrute force fails against a theoretically non-decryptable\nencryption method such as one time key encryption. Likewise, I\nmaintain that brute force fails when the two methods together:\nencrypting the binary numbers in another base besides base 2;\nalong with the combination of letter frequency normalization are\nused together. Because, the combination of the methods is\ntheoretically not decryptable.\nIn sum, just as one time key encryption is theoretically proven to\nbe non-decryptable; so to the combination of ciphering the\ncleartext and encrypting the binary numbers separately, results\nin a lack of correlation making decryption impossible. Likewise,\nfrequency normalization, especially when coupled with\nencrypting the binary numbers separately, result in a lack of\nfrequency making decryption impossible.\n\n6.\n\nSUMMARY\n\nSeveral encryption methods are proposed:\n1.\n\nAn encryption method that targets the binary\nnumbering system alone. This method uses other\nbinary numbering systems, both natural binary\nsystems such as Phinary and Fibonacci, as well as\nunnatural binary systems, to replace the base 2 system.\n\n2.\n\nA second encryption method of ciphering the text and\nencrypting the binary numbers. This method provides\na theoretically undecipherable system.\n\n3.\n\nA third encryption method of frequency\nnormalization; using a sufficient number of identity\nletters for high frequency letters. This reduces the\nfrequencies of high identity letters and introduces\nadditional letters into the alphabet. This method is a\nstrong encryption method, if not decipherable. This\nmethod may be decryptable by brute force.\n\n4.\n\nA fourth encryption method of frequency\nnormalization and encrypting the binary numbers.\nThis method also provides a theoretically\nundecipherable system.\n\nCounterpoint: While there may be an algorithm that can give\nevery possible permutation to reconstruct the correct frequencies\nfrom a frequency normalization; there is no algorithm to\ndetermine the binary number encryption. So, if you do not\nknow what you are counting, how can you reconstruct the\nfrequency?\nPerhaps brute force could be used against frequency\nnormalization, if there was no binary number encryption. Then,\nby adding symbol frequencies together, to create a table that\nmatches the normal frequency distribution, one could try to\nrecreate the message.\nYes, this would involve many\npermutations until a correct table would be made. Which is par\n\n\fProcess #1:\n1.\n\nTranslate the letters of the plaintext to ASCII values.\n\n2.\n\nCipher the base 2 binary values of the ASCII values to\nanother binary base.\n\nPlaintext\nIn\n\nCipher Text\n\nFlowchart of Process #1:\nTranslate Alpha\nLetters to ASCII\n\nPlaintext\nIn\n\nTranslate\nNumerical Value of\nLetters to Binary\nBase 2\n\nTranslate Text to\nASCII\n\nTranslate Binary\nBase 2 to Another\nBinary System\nTranslate ASCII\nfrom Base 2\nBinary to another\nBinary System\n\nFlowchart C \u2013 Process #2.\nProcess #3:\n\nFlowchart B \u2013 Process #1.\nProcess #2:\n1.\n\nCipher the letters of the plaintext.\n\n2.\n\nTranslate the letters of the plaintext to ASCII values.\n\n3.\n\nCipher the base 2 binary values of the ASCII values to\nanother binary base.\n\nFlowchart of Process #2:\n\n1.\n\nAdd 3 symbols as identities for the letter 'e'.\n\n2.\n\nRandomly replace the letter 'e' with identities.\n\n3.\n\nAdd 2 symbols as identities for the 9 next, most\nfrequent letters in the alphabet.\n\n4.\n\nRandomly replace the nine most frequent letters with\ntheir identities.\n\nFlowchart of Process #3:\n\n\fPlaintext\nIn\n\nPlaintext\nIn\n\nReplace an equal\nnumber of 'e's with\n3 identities.\n\nReplace an equal\nnumber of 'e's with\n3 identities.\n\nReplace an equal\nnumber of the 2nd10th most frequent\nletters with 2\nidentities for each\nletter.\n\nReplace an equal\nnumber of the 2nd10th most frequent\nletters with 2\nidentities for each\nletter.\n\nFlowchart D \u2013 Process #3.\nAlternate implementations could include using a formula to\nfigure out how many identities to add, per letter. This would be\ndone by calculating the average frequency. Then, dividing any\ngiven frequency by the average frequency, to ascertain the\nnumber of identities necessary to generate, for any given\nnumber.\nProcess #4:\n1.\n\nAdd 3 symbols as identities for the letter 'e'.\n\n2.\n\nRandomly replace the letter 'e' with identities.\n\n3.\n\nAdd 2 symbols as identities for the 9 next, most\nfrequent letters in the alphabet.\n\n4.\n\nRandomly replace the nine most frequent letters with\ntheir identities.\n\n5.\n\nCipher the text.\n\n6.\n\nEncrypt the binary.\n\nFlowchart of Process #4:\n\nCipher the altered\ntext (the text with\nthe identities\nadded).\n\nAssign numeric\nvalues to the\nsymbols for the\nletters.\n\nWithout using\nbase 2: Encrypt\nthe binary\nrepresentation for\nthe numeric values\nof the letters.\n\nFlowchart E \u2013 Process #4.\nAlternate implementations could include using a formula to\nfigure out how many identities to add, per letter. This would be\ndone by calculating the average frequency. Then, dividing any\ngiven frequency by the average frequency, to ascertain the\n\n\fnumber of identities necessary to generate, for any given\nnumber.\n\n001-0 00-01 || 0-010 \u2013001-0 || 00-10 0-011 \u2013 Divided in Triplets\n1011010110110 -- Golden Sequence\n0011 0000 || 0101 0101 || 0010 0001 || 1000 0111 -- Merged\n\n7.\n\nINFINITE COMBINATIONS\n\n48 85 65 135 \u2013 Ciphertext ASCII\n0 U A Graphic -- Ciphertext\n\nI hesitated from saying that these methods of encryption were\nnot decipherable. Not because they were not. But, because they\nhave an attribute in common with one time key encryption; in\nthat the encryption is not decipherable by method; however,\nthey are decipherable by brute force. The reason one time key\nencryption is decipherable by brute force is; that the number of\npossible keys is finite. However, I have now reasoned how to\nmake the methods proposed, have an infinite number of possible\ncombinations. Thereby, defeating brute force decryption as a\nmethod of decryption.\nOnce upon a time, before the computing power of our day, one\ntime key encryption could not be guessed. However, today,\nwith current computing power, a brute force method will\ndecipher one time key encryption. Because, the number of keys\nare finite. Albeit, a very large number of possible keys. But,\nstill, a finite set. So, each possible key is individually tested. If\nhowever, one could make an infinite set of keys, or\npermutations, one could make an encrypted message\ntheoretically non-decipherable.\nWhile I had the beginnings of such an idea, it was not fully\ndeveloped. Now, I have come upon a way of making the above\nmethods applicable in an infinite number of different ways.\nOne possibility: Using the method of altering the picture, by bitslicing, meaning: combing the plaintext bit pattern, with the\ngolden sequence, one can produce ciphertext. As the golden\nsequence is self expanding, the golden sequence can be enlarged\nto be as large as necessary for any given message.\nFor example: Using some known algorithm, add extra bits. E.g.\nAfter every third bit, insert a bit from the golden sequence. The\nciphertext produced, similar to the ciphertext produced by the\nmethod of reversing the bits, has an altered pattern. The\nalteration is pictorial and not based upon math per se. The target\nof the ciphering is the ASCII. The result of the ciphering is\nindistinguishable from ASCII. The process is not reversible by\nmethod. There is no way to know if the original ASCII has been\naltered. And, there are an infinite number of possible ASCII\ncipherings.\nEx. The merging of plaintext with the golden sequence on the\nthird bit of each byte:\n\nAlso, it was noted, that the increase in size of the ciphertext over\nthe plaintext, is acceptable, in order to achieve security. This\ngives an infinite number of possible combinations. Which, is\nmuch better than a finite number of combinations: The\ndrawback of any key encryption method. Because, all key\nencryption methods have a minimum and maximum size. One\nsize is the case when the minimum equals the maximum. Also,\nall key encryption systems have a finite set of symbols\n(numbers) from which to select for each digit/position/character.\nSo, the possible permutations and combinations to create keys is\nfinite.\nOne is not limited to the golden sequence. There are an infinite\nnumber of sequences, irrationals, transcendentals, etc. to base\nsuch a method on.\nAlso, what is merged can be mixed up, in an infinite number of\nways. The starting point in the irrational or golden sequence can\nbe altered. Non-sequential digits can be used for merging. Not\nevery byte has to be merged. Etc.\nEx. Sin 49o 50' 39\"; every third digit of Sin 49o 50' 39\"; Sin\n49o 50' 39\" spliced into a round robin of every set of 1 st, 2nd, 3rd\nand 4th bit position.\nOne can go on and on with, more and more possible\ncombinations.\nThe point is, the possible number of\ncombinations is infinite: Practically, as well as theoretically.\nThis is because one can always add another position or byte. In\naddition, each new combination will be unique, with its own\nunique frequency analysis; which does not correlate to the\noriginal plaintext.\nNow, that an infinite number of possibilities has been\nintroduced, deciphering, by method is truly not possible. While\nguessing may work, there is no method.\nBrute force guessing would require scanning for familiar bit\nsequences. Also, if the algorithm is known, a simple XOR will\ndecrypt the ciphertext. Also, the security as well as transmission\nof algorithm choice and merging sequence, is no better than\nkeyed encryption. But, I contend, that there are an infinite\nnumber of \"unfamiliar\" irrational sequences to choose from to\nmake guessing impractical. I maintain that while guessing is\npossible, it is highly improbable.4\n\nABC -- Plaintext\n65 66 67 -- ASCII\n0010 0001 || 0010 0010 || 0010 0011 -- Binary\n\n4\n\nCredit goes to Dr. Gertrude Levine (Fairleigh Dickinson\nUniversity) for her criticism and disagreement, which helped\nme coalesce these thoughts.\n\n\f8.\n\nFURTHER RESEARCH\n\n[Original content deleted.]\nThe ensuing discussions about the original article has led me to\nunderstand that there are presumptions about one time key pad\nand its implementation. These assumptions lead to building in\nvulnerability and susceptibility to brute force attack. Other\nimplementations would eliminate that vulnerability. That is out of\nthe scope of this article.\n\n9.\n\nCONCLUSION\n\nEssential to achieving the goal of this project, was to use a\ndifferent perspective.\nHitherto, throughout the history of\ncryptography; all enciphering and encryption methods sought\nuniqueness to obfuscate the data \u2013 unique encoding of each letter\nin a message, unique keys. This method uses the opposite\napproach: ambiguity \u2013 multiple letters for the same letter \u2013 to\nobfuscate the data.\nIn addition, this work demonstrates the aphorism, that a\nmathematical proof should be like a poem. The methodology is\nsimple and requires few steps as well as little effort.\nAuthor's Bio:\nGivon Zirkind received his Bachelor's in\nComputer Science from Touro College and; his Master's in\nComputer Science from Fairleigh Dickinson University, both\nschools are located in the USA. His career has involved computer\noperations; software engineering; design and management of\nbusiness applications with extensive database programming and\nmanagement; Internet, web page design and implementation; ecommerce\nsolutions,\nGoogle\nanalytics;\ncomputer\ncommunications, data transfers and telecommunications; data\nconversion projects; reverse engineering of data and legacy\nsoftware; being a published author and editor of a technical\njournal; teaching and; automated office support. His research\nwork includes AFIS data compression and independent genetic\ndatabase development and research. He may be reached at his\nemail: GIVONZ@HOTMAIL.COM.\n\n10.\n\nACKNOWLEDGMENTS\n\nTo my grandfather for all his support in all my endeavors.\nAllen Scott Gerner, colleague and friend, for his assistance with\ncompiler operations, access to his library and encouragement. B.S.\nComputer Information Science, NJ Institute of Technology; M.S.\nComputer Science, NJ Institute of Technology.\nTo Ramona Brandt for donating resources and support to this\nproject.\nDr. Larry T. Ray, R.I.P., Ph.D. Mathematics/Computer Science,\nStevens Institute of Technology (NJ), formerly professor of\ncomputer science, Fairleigh Dickinson University, for his\nmathematical evaluation and support in this project.\n\nTo Jack Lloyd and all those on his Cryptography List,\nrandombits.net for all their input and comments. Travis H. Jeremy\nStanley, and others.\n\n11.\n\nREFERENCES\n\n[BAM01] Bamford, James; The Puzzle Palace: Inside America's\nMost Secret Intelligence Organization, Penguin Books, USA, 1983,\nISBN: 0-14-00-6748-5\n[BET01] Understanding Big and Little Endian Byte Order,\nhttp://betterexplained.com/articles/understanding-big-and-littleendian-byte-order\n[BLA01] Blanc, Bertrand; Maaraoui, Bob; Endianness or Where\nis Byte 0, http://3bc.bertrand-blanc.com/endianness05.pdf\n[CAP01] CAPTCHA: Telling Humans and Computers Apart\nAutomatically; http://www.captcha.net/\n[COL01] Collin, S.M.H.; Dictionary of Computing, Fourth\nEdition, Peter Collin Publishing, 2002, ISBN: 9781901659467; See\nentries for ASCII and EBCDIC\n[DAV01] DaVinci, Leonardo; The notebooks of Leonardo\nDaVinci; Konecky & Konecky, Old Saybrook, CT; ISBN:\n156852448X, Translated by Edward MacCurdy\n[EUC01] Euclid, translated by Sir Thomas L. Heath, Book 6,\nDover Books, USA, ISBN: 0-486-60089-0; Proposition 30\n[EUC02] Euclid, translated by Sir Thomas L. Heath, Book 2,\nDover Books, USA, ISBN: 0-486-60088-2, Proposition 11\n[FRI001] Friedrich, Johannes; Extinct Languages, Dorset Press,\nNew York, 1989, ISBN: 0880293381\n[GAN01] Ganssle, Jack and Barr, Michael; Embedded Systems\nDictionary; CMP Books, 2003, ISBN: 978157820204\n[GOL01] Goldstein, Larry J., Schneider, David I., Siegel, Martha\nJ.; Finite Mathematics and Its Applications, Fourth Edition,\nPrentice Hall, 1980, ISBN 0-13-318221-5\n[HIG001] Higham, Charles; Trading With the Enemy: An Expose\nof the Nazi-American Money-Plot 1933-1949, Hale, London 1983\n[HOD01] Hodges, M. Susan; Computers: Systems, Terms and\nAcronyms, 16th Edition; SemCo, 2006, ISBN: 9780966842289\n[HUF01] A Method for the Construction of Minimum redundancy\nCodes, David A. Huffman, Proceedings of the I.R.E., Volume 40,\nIssue 9, Sept. 1952, pgs 1098-1102, ISBN 0096-8390\n[JEN01] Jennings, Tom; An Annotated History of Some\nCharacter\nCodes\nor\nASCII\nInfiltration;\nhttp://www.wps.com/projects/codes/\n[JOH001] Johnson, Dr. Neil F., www.jjtc.com/ Steganography\n[KAH01] Kahn, David; The Codebreakers: The Story of Secret\nWriting; Scribner, New York, 1996; ISBN 0684831309\n[KAH02] ibid. pg. 523\n[KAH03] ibid. Chapter 16\n[KAH04] ibid. pg. 518\n[KAH05] ibid. Chapter 20\n[KAH06] ibid. pgs. xv-xviii\n\n\f[KAH07] ibid. pg. 508\n\n[WEB03] Webster's New International Dictionary, Second\nEdition, G & C. Merriam Co., Springfield, Massechusetts; 1945;\nentry for argot\n\n[KAH08] ibid. Chapter 17\n[KAH09] ibid. pg. 100\n[KAH11] ibid. pg. 737\n\n[WHO01] Language, Thought and Reality: Selected Writings of\nBenjamin Lee Whorf, MIT Press, Cambridge Massachusetts;\n1993; ISBN 0-262-2303-8\n\n[KAH12] ibid. pgs. 100-105\n\n[WIK01] Golden ratio base;\n\n[KAH13] ibid. Chapter 4\n\nhttp://en.wikipedia.org/wiki/Phinary#Writing_golden_ratio_base_\nnumbers_in_standard_form\n\n[KAH10] ibid. pgs. 739-740\n\n[KAH14] ibid. pg. 488\n\n[WIK02] Non-standard Positional Numeral Systems,\n\n[KAH15] ibid. pg. 748\n[KNO01] Knott, Ron; Using the Fibonacci Numbers to Represent\nWhole\nNumbers,\nhttp://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibrep.ht\nml\n\nhttp://en.wikipedia.org/wiki/Nonstandard_positional_numeral_systems\n[WIK03] Endianness\nhttp://en.wikipedia.org/wiki/Big_endian\n\n[LIV01] Livio, Mario; The Golden Ratio: The Story of Phi, The\nWorld's Most Astonishing Number; Broadway Books, New York,\n2002, ISBN: 0-7679-0815-5; pg. 11\n\n[WIK04] Encryption; http://en.wiktionary.org/wiki/encryption\n\n[LIV02] Ibid. Chapter 5\n\n[WIK06] Golden ratio; http://en.wikipedia.org/wiki/Golden_ratio\n\n[LIV03] Ibid. pgs. 232-236\n\n[WIK07]\nFibonacci\nhttp://en.wikipedia.org/wiki/Fibonacci_number\n\n[LIV04] Ibid. Appendix 9\n[MAL01] Digital Principles and Applications, Fourth Edition,\nMalvino, Albert Paul and Leach, Donald P.; Macmillan/McGraw\nHill, 1986, ISBN 0-07-039883-6\n[MIA01] Compressed Image File Formats: JPEG, PNG, GIF,\nXBM, BMP, Your guide to graphics; by John Miano, ACM Press,\nSIGGRAPH Series, 1999\n\n[WIK05] CAPTCHA; http://en.wikipedia.org/wiki/Captcha\n\n[WIK08]\nFibonacci\nhttp://en.wikipedia.org/wiki/Fibonacci_representation\n[WIK09]\nZeckendorf's\nhttp://en.wikipedia.org/wiki/Zeckendorf%27s_theorem\n\nNumber;\ncoding;\ntheorem;\n\n[WIK10]\nInternational\nPhonetic\nAlphabet,\nhttp://en.wikipedia.org/wiki/International_Phonetic_Alphabet\n\n[PEN01] Pennebaker, William B. and Mitchell, Joan L.; JPEG\nStill Image Data Compression Standard , Van Nostrand\nReinhold, 1993\n\n[WIK11]\nIPA\nChart\nfor\nEnglish,\nhttp://en.wikipedia.org/wiki/International_Phonetic_Alphabet_for\n_English\n\n[PHI01] Philologos; Boydem II:Yiddish and Cockney?\nJewish Daily Forward; Friday, December 22, 2006;\n\n[ZIR01] Zirkind, Givon; AFIS Data Compression: An Example\nof How Domain Specific Compression Algorithms Can Produce\nVery High Compression Ratios; ACM SIGSOFT, Software\nEngineering Notes, Volume 32, Issue 6, November 2007, Article\nNo. 8, ISSN: 0163-5948\n\nThe\n\n[VAU01]\nVaudenay, Serge; A Classical Introduction to\nCryptography: Applications for Communications Security;\nSpringer Science+Business Media, Inc., New York, 2006, ISBN10: 0-387-25464-1\n[VAU02]\nVaudenay, Serge; A Classical Introduction to\nCryptography: Applications for Communications Security;\nSpringer Science+Business Media, Inc., New York, 2006, ISBN10: 0-387-25464-1; Section 1.1.2, definition of decryption\n[VAU03]\nVaudenay, Serge; A Classical Introduction to\nCryptography: Applications for Communications Security;\nSpringer Science+Business Media, Inc., New York, 2006, ISBN10: 0-387-25464-1; Section 1.1.3\n[VER01] Verne, Jules; Twenty Thousand Leagues Under the Sea,\nSterling Publishers, New York, 2006, ISBN: 140272599X\n[WEB01] Webster's New International Dictionary, Second\nEdition, G & C. Merriam Co., Springfield, Massechusetts; 1945;\nentry for cipher\n[WEB02] Webster's New International Dictionary, Second\nEdition, G & C. Merriam Co., Springfield, Massechusetts; 1945;\nentry for code\n\n\fGLOSSARY\nCipher or Encipher \u2013 A cipher is a set of symbols or letters used to\nreplace intended letters to create a secret message. Enciphering is\nthe process of substituting the letters of one message with a\ncipher. [WEB01] Commonly, especially with computers,\nnumbers are used for letters and; the numbers are interchanged.\nI.e. A=1, B=2, C=3, etc. Ciphering might be as simple as adding\none to each number. Or, ciphering might involve a more complex\nmathematical operation.\nCode or Encoding \u2013 is to translate into symbols. [WEB02] Using\nsome kind of one to one correspondence, a translation of symbols\nis made. Letters and words are both symbols and; can both be\nencoded.\nEnciphering \u2013 is a special kind of encoding, when substituting one\nset of symbols (letters) for another set of (letters).\nEncryption \u2013 is new term for scrambling information or data.\nEncryption is not limited to letters or words. Also, encryption is\nnot limited to substitution or a one to one correspondence, such as\na codebook or using a key per se. Commonly, encryption\ninvolves complex algorithms, usually employing complex\nmathematical formulae. [WIK004] [KAH05] [KAH06]\nDeciphering \u2013 is to reverse the process of enciphering.\nDecoding \u2013 is to reverse the process of encoding.\nDecrypting \u2013 is to reverse the process of encrypting. However,\ntechnically or commonly, decrypting connotes reversing the\nencryption when NOT in possession of the decryption key.\n[VAU01]\nApart from the above methods of making messages secret and\nkeeping communications secure; there is yet another way of\nkeeping messages secret:\nThat is to speak another, not\nunderstood, \"secret,\" language. This practice has been used by\nthieves, the military, spies and private investigators. Immigrant\nparents often use their native tongue as \"the secret\" language.\nSecret languages are also a common tactic used in price\nnegotiations in markets. Argot is an example of this. [PHI01]\n[WEB03]\n\nright. Each successive digit, is an additional multiple of the base.\nE.g. In base 10: 102 x 101 x 100. E.g. In binary numbers: \"0001\"\ncould be a decimal 1. Or, \"1000\" could be a decimal 1. Or,\n\"1000\" could be a decimal 8 [2x2x2]. It depends where you put\nthe big end and where you put the little end. This has a bearing\nupon how binary numbers are written, represented and actually\nplaced onto hardware. While little endian is common in writing,\ni.e. \"0001\" is a decimal 1; machines may actually operate in big\nendian format.\nIn terms of encryption, one can consider reversing big endian with\nlittle endian, like boustrophedon or mirror writing. Meaning, to\nwrite the letters of a message backwards.\nCAPTCHA \u2013 Completely Automated Public Turing test to tell\nComputers and Humans Apart. A test, given as a challenge, by a\ncomputer, that a computer can not answer. If the question is\nanswered correctly, it is assumed the respondent is human. This\ntest usually involves reading a distorted image. [CAP01] [WIK05]\nBinary Code \u2013 A code with only two symbols. E.g. on/off, 1/0,\netc. These two symbols can be combined in any fashion to\nencode any number of things. Morse code is one example of a\nbinary code. Base 2 is another common well known example of a\nbinary code.\nThe Golden Ratio \u2013 is the ratio that satisfies the ratio a:b::(a+b):a.\nOr, a/b = b/(a+b). This equation becomes a 2+ab-b2=0. Using the\nquadratic equation, the equation can be solved. The solution to\nthe equation is a constant, equal to (1 + \u221a5)/2 \u2248 1.6 The golden\nratio is symbolized with the Greek letter Phi: \u03c6 The golden ratio\nhas many unique properties that have made it the object of study.\n[EUC01] [EUC02] [LIV001] [WIK06]\nThe Golden Mean \u2013 same thing as the golden ratio. Although, the\ngolden mean is more of a geometric property, rather than an\nalgebraic description of the ratio.\nThe Fibonacci Sequence \u2013 is a sequence named after the\nmathematician, Leonardo Fibonacci, who did not discover this\nsequence, but wrote about it, in his book, Book of Calculation, the\nLiber Abaci. [LIV001] [KNO01] The sequence starts at zero.\nFollowed by a one. Thereafter, each consecutive number is the\nsum of the previous two consecutive numbers: {0, 1, 1, 2, 3, 5, 8,\n13... } [LIV02] [KNO01] [WIK07]\n\nBoustrophedon \u2013 is when a language is written from either right to\nleft or; left to right. This was true of some ancient languages,\nincluding Greek, up until a certain time. [KAH001] [FRI001]\n\nA Fibonacci number \u2013 is a number in the Fibonacci sequence.\n[LIV02] [KNO01] [WIK07]\n\nLittle Endian / Big Endian \u2013 This refers to which digit, the right or\nthe left, is the biggest, or most significant digit. [BET01] [BLA01]\n[WIK03] Little Endian systems have the smallest digit on the\nright. While Big Endian systems, have the biggest digit on the\n\nThe Fibonacci sequence has many unique properties. One\nproperty is, that any whole number, positive integer, less than any\ngiven Fibonacci number, can be expressed as the sum of some\nsubset of the preceding Fibonacci numbers. E.g. Using the above\n\n\fsubset of Fibonacci numbers, one can count up to 13 thus: 1, 2, 3,\n1+3, 5, 1+5 or 1+2+3, 2+5, 8, 1+8, 2+8 or 1+1+8, 3+8 or 1+2+8,\n1+3+8 or 1+1+2+8, 13. [LIV02] [KNO01] [WIK07]\nFibonacci Representation \u2013 is a numeric representation that uses\nthe property of the Fibonacci series that permits the expression of\nany positive integer as a sum of Fibonacci numbers. This numeric\nrepresentation is a natural extension of the Fibonacci series;\nmaking Fibonacci representation a natural binary system. [LIV01]\n[KNO01] [WIK01] I.e. Using a left to right sequence, big endian,\nsystem, and a zero for exclusion, and a one for inclusion:\n\"01111FIB\" = (in decimal) 0+1+1+2+3 = 710 Even though the\nFibonacci is a natural binary system, the mathematics are more\ncomplicated than base 2.\nStandard Form Fibonacci Representation \u2013 In addition, the\nFibonacci sequence has a property, proven by Zeckendorf's\ntheorem, that any number can be represented by a set of previous\nFibonacci numbers, without any two Fibonacci numbers in a row.\nE.g. Four in base 10, could be \"0111 FIB\" or \"01001FIB\" or\n\"00101FIB\". [KNO01] [WIK09]\nStandardized Form \u2013 is when, in a binary system, for a given type\nof number, e.g. positive integer, every number can be expressed\nwithout consecutive ones. E.g. \"11\" is not present in the\nnumbering system. [WIK09]\nWhen applying Zeckendorf's\ntheorem [see previous paragraph] to the Fibonacci based\nnumbering system, then, the Fibonacci numbers are being\nexpressed in standardized form.\nGolden Ratio Base \u2013 Using the golden ratio as a base, any real\nnumber can be expressed as a binary number. This is also referred\n\nto as Phinary, after the name Phi, \u03c6, for the golden ratio. Numbers\nin Phinary are written thus: 0101\u03c6 In addition, like Fibonacci\nnumbers, any golden ratio base number can be written in a\nstandardized form. [WIK01] [WIK06] [WIK09]\nGolden Sequence \u2013 a binary sequence, a long range numeric\nsequence, that is not periodic; based upon the Fibonacci sequence.\nThe sequence is generated by starting with a \"1\". Then, replacing\neach \"1\" with a \"10\" and, each \"0\" by a \"1\":\n1\n10\n101\n10110\n10110101\n1011010110110\nEach sequence is a combination of the last two previous\nsequences \u2013 in Fibonacci fashion. The sequence is \"self-similar\"\nand expandable infinitely; with uniqueness.\nCleartext or Plaintext \u2013 Regular text that has not been enciphered,\nencoded or encrypted. [KAH06] [VAU01]\nWhile I have mentioned only four natural binary systems:\nFibonacci and Phinary, both standard and non-stardard; there are\nmany more binary systems that could be constructed, as will be\ndiscussed below.\n\n_____________\n\n\f"}