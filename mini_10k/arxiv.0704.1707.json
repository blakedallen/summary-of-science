{"id": "http://arxiv.org/abs/0704.1707v2", "guidislink": true, "updated": "2007-04-17T03:11:16Z", "updated_parsed": [2007, 4, 17, 3, 11, 16, 1, 107, 0], "published": "2007-04-13T07:29:31Z", "published_parsed": [2007, 4, 13, 7, 29, 31, 4, 103, 0], "title": "A Cut-free Sequent Calculus for Bi-Intuitionistic Logic: Extended\n  Version", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0704.2295%2C0704.1508%2C0704.2678%2C0704.0246%2C0704.2980%2C0704.1888%2C0704.0243%2C0704.2512%2C0704.2195%2C0704.0192%2C0704.2929%2C0704.1649%2C0704.2600%2C0704.2972%2C0704.0645%2C0704.1632%2C0704.1525%2C0704.1218%2C0704.1759%2C0704.1892%2C0704.2579%2C0704.3107%2C0704.3797%2C0704.3854%2C0704.3588%2C0704.3047%2C0704.2775%2C0704.0113%2C0704.3713%2C0704.3132%2C0704.2773%2C0704.0552%2C0704.2886%2C0704.3881%2C0704.0130%2C0704.3996%2C0704.0388%2C0704.0828%2C0704.1741%2C0704.0832%2C0704.2405%2C0704.3197%2C0704.1839%2C0704.0868%2C0704.2500%2C0704.2637%2C0704.1657%2C0704.0722%2C0704.2486%2C0704.1072%2C0704.1707%2C0704.0142%2C0704.1549%2C0704.3446%2C0704.0783%2C0704.2515%2C0704.2285%2C0704.0853%2C0704.1035%2C0704.3290%2C0704.3495%2C0704.0963%2C0704.0660%2C0704.3648%2C0704.1800%2C0704.1726%2C0704.2559%2C0704.1750%2C0704.3505%2C0704.2289%2C0704.2245%2C0704.0672%2C0704.2805%2C0704.4001%2C0704.3737%2C0704.0397%2C0704.1899%2C0704.0784%2C0704.2435%2C0704.1423%2C0704.1942%2C0704.1015%2C0704.1271%2C0704.2620%2C0704.3688%2C0704.0922%2C0704.0483%2C0704.3615%2C0704.2011%2C0704.2337%2C0704.3861%2C0704.0540%2C0704.0889%2C0704.3651%2C0704.0304%2C0704.0456%2C0704.2169%2C0704.3960%2C0704.3027%2C0704.3531%2C0704.1058&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Cut-free Sequent Calculus for Bi-Intuitionistic Logic: Extended\n  Version"}, "summary": "Bi-intuitionistic logic is the extension of intuitionistic logic with a\nconnective dual to implication. Bi-intuitionistic logic was introduced by\nRauszer as a Hilbert calculus with algebraic and Kripke semantics. But her\nsubsequent ``cut-free'' sequent calculus for BiInt has recently been shown by\nUustalu to fail cut-elimination. We present a new cut-free sequent calculus for\nBiInt, and prove it sound and complete with respect to its Kripke semantics.\nEnsuring completeness is complicated by the interaction between implication and\nits dual, similarly to future and past modalities in tense logic. Our calculus\nhandles this interaction using extended sequents which pass information from\npremises to conclusions using variables instantiated at the leaves of failed\nderivation trees. Our simple termination argument allows our calculus to be\nused for automated deduction, although this is not its main purpose.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0704.2295%2C0704.1508%2C0704.2678%2C0704.0246%2C0704.2980%2C0704.1888%2C0704.0243%2C0704.2512%2C0704.2195%2C0704.0192%2C0704.2929%2C0704.1649%2C0704.2600%2C0704.2972%2C0704.0645%2C0704.1632%2C0704.1525%2C0704.1218%2C0704.1759%2C0704.1892%2C0704.2579%2C0704.3107%2C0704.3797%2C0704.3854%2C0704.3588%2C0704.3047%2C0704.2775%2C0704.0113%2C0704.3713%2C0704.3132%2C0704.2773%2C0704.0552%2C0704.2886%2C0704.3881%2C0704.0130%2C0704.3996%2C0704.0388%2C0704.0828%2C0704.1741%2C0704.0832%2C0704.2405%2C0704.3197%2C0704.1839%2C0704.0868%2C0704.2500%2C0704.2637%2C0704.1657%2C0704.0722%2C0704.2486%2C0704.1072%2C0704.1707%2C0704.0142%2C0704.1549%2C0704.3446%2C0704.0783%2C0704.2515%2C0704.2285%2C0704.0853%2C0704.1035%2C0704.3290%2C0704.3495%2C0704.0963%2C0704.0660%2C0704.3648%2C0704.1800%2C0704.1726%2C0704.2559%2C0704.1750%2C0704.3505%2C0704.2289%2C0704.2245%2C0704.0672%2C0704.2805%2C0704.4001%2C0704.3737%2C0704.0397%2C0704.1899%2C0704.0784%2C0704.2435%2C0704.1423%2C0704.1942%2C0704.1015%2C0704.1271%2C0704.2620%2C0704.3688%2C0704.0922%2C0704.0483%2C0704.3615%2C0704.2011%2C0704.2337%2C0704.3861%2C0704.0540%2C0704.0889%2C0704.3651%2C0704.0304%2C0704.0456%2C0704.2169%2C0704.3960%2C0704.3027%2C0704.3531%2C0704.1058&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Bi-intuitionistic logic is the extension of intuitionistic logic with a\nconnective dual to implication. Bi-intuitionistic logic was introduced by\nRauszer as a Hilbert calculus with algebraic and Kripke semantics. But her\nsubsequent ``cut-free'' sequent calculus for BiInt has recently been shown by\nUustalu to fail cut-elimination. We present a new cut-free sequent calculus for\nBiInt, and prove it sound and complete with respect to its Kripke semantics.\nEnsuring completeness is complicated by the interaction between implication and\nits dual, similarly to future and past modalities in tense logic. Our calculus\nhandles this interaction using extended sequents which pass information from\npremises to conclusions using variables instantiated at the leaves of failed\nderivation trees. Our simple termination argument allows our calculus to be\nused for automated deduction, although this is not its main purpose."}, "authors": ["Linda Buisman", "Rajeev Gor\u00e9"], "author_detail": {"name": "Rajeev Gor\u00e9"}, "author": "Rajeev Gor\u00e9", "links": [{"href": "http://arxiv.org/abs/0704.1707v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0704.1707v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0704.1707v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0704.1707v2", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "arXiv:0704.1707v2 [cs.LO] 17 Apr 2007\n\nA Cut-free Sequent Calculus for\nBi-Intuitionistic Logic:\nExtended Version\nLinda Buisman and Rajeev Gor\u00e9\n1\n\nThe Australian National University\nCanberra ACT 0200, Australia\n2\nLogic and Computation Programme\nCanberra Research Laboratory, NICTA\u22c6 , Australia\n{Linda.Buisman|Rajeev.Gore}@anu.edu.au\n\nAbstract. Bi-intuitionistic logic is the extension of intuitionistic logic\nwith a connective dual to implication. Bi-intuitionistic logic was introduced by Rauszer as a Hilbert calculus with algebraic and Kripke semantics. But her subsequent \"cut-free\" sequent calculus for BiInt has\nrecently been shown by Uustalu to fail cut-elimination. We present a new\ncut-free sequent calculus for BiInt, and prove it sound and complete with\nrespect to its Kripke semantics. Ensuring completeness is complicated by\nthe interaction between implication and its dual, similarly to future and\npast modalities in tense logic. Our calculus handles this interaction using\nextended sequents which pass information from premises to conclusions\nusing variables instantiated at the leaves of failed derivation trees. Our\nsimple termination argument allows our calculus to be used for automated deduction, although this is not its main purpose.\n\n1\n\nIntroduction\n\nPropositional intuitionistic logic (Int) has connectives \u2192, \u2227, \u2228 and \u00ac, with \u00ac\u03c6\noften defined as \u00ac\u03c6 := \u03c6 \u2192\u22a5. Int has a well-known Kripke semantics, where a\npossible world w makes \u03c6 \u2192 \u03c8 true if every successor v that makes \u03c6 true also\nmakes \u03c8 true. Int also has an algebraic semantics in terms of Heyting algebras,\nand there is a well-known embedding from Int into the classical modal logic S4.\nInt is constructive in that it rejects the Law of Excluded Middle: that is, \u03c6 \u2228 \u00ac\u03c6\nis not a theorem of Int.\nPropositional dual intuitionistic logic (DualInt) has connectives \u2212< , \u2227, \u2228\nand \u223c, with \u223c\u03c6 often defined as \u223c\u03c6 := \u22a4 \u2212<\u03c6. DualInt also has Kripke semantics, where a possible world w makes \u03c6\u2212< \u03c8 true if there exists a predecessor\nv where \u03c6 holds, but \u03c8 does not hold: that is, \u03c6 excludes \u03c8. Thus, the \u2212<\nconnective of DualInt is dual to implication in Int. DualInt also has algebraic\n\u22c6\n\nNational ICT Australia is funded by the Australian Government's Dept of Communications, Information Technology and the Arts and the Australian Research Council\nthrough Backing Australia's Ability and the ICT Centre of Excellence program.\n\n\fsemantics in terms of Brouwer algebras [13]. There is a less well-known embedding from DualInt into S4. DualInt is para-consistent in that it rejects the Law\nof Non-contradiction: that is, \u03c6\u2227 \u223c\u03c6 is DualInt-satisfiable. Various names have\nbeen used for \u2212< : coimplication [24, 23], subtraction [2, 3], pseudo-difference\n[16], explication [15]. We refer to it as exclusion.\nBi-intuitionistic logic (BiInt), also known as subtractive logic and HeytingBrouwer logic, is the union of Int and DualInt, and it is a conservative extension of both. BiInt was first studied by Rauszer [15, 16]. BiInt is an interesting logic to study, since it combines the constructive aspects of Int with the\npara-consistency of DualInt. While every Int-theorem is also a BiInt-theorem,\nadding DualInt connectives introduces a non-constructive aspect to the logic \u2013\nthe disjunction property does not hold for BiInt formulae if they contain \u2212< .\nNote that BiInt differs from intuitionistic logic with constructive negation, also\nknown as constructible falsity [14], where the disjunction property does hold.\nWhile the proof theory of Int and DualInt separately has been studied extensively and there are many cut-free sequent systems for Int (for example, [8,\n6, 5]) and DualInt (for example, [20, 4]), the case for BiInt is less satisfactory.\nAlthough Rauszer presented a sequent calculus for BiInt in [15] and \"proved\" it\ncut-free, Uustalu has recently given a counter-example [21] to her cut-elimination\ntheorem: the formula p \u2192 (q \u2228 (r \u2192 ((p\u2212< q) \u2227 r)) is BiInt-valid, but cannot\nbe derived in Rauszer's calculus without the cut rule. Similarly, Uustalu's counterexample shows that Crolard's sequent calculus [2] for BiInt is not cut-free.\nUustalu's counterexample fails in both Rauszer's and Crolard's calculi because\nthey limit certain sequent rules to singleton succedents or antecedents in the\nconclusion, and the rules do not capture the interaction between implication\nand exclusion.\nUustalu and Pinto have also given a cut-free sequent-calculus for BiInt in\n[23]. Since only the abstract of this work has been published so far, we have\nnot been able to examine their sequent rules, or verify their proofs. According\nto the abstract [23] and personal communication with Uustalu [22], his calculus\nuses labelled formulae, thereby utilising some semantic aspects, such as explicit\nworlds and accessibility, directly in the rules. Hence a traditional cut-free sequent\ncalculus for BiInt is still an open problem.\nWe present a new purely syntactic cut-free sequent calculus for BiInt. We\navoid Rauszer's and Crolard's restrictions on the antecedents and succedents for\ncertain rules by basing our rules on Dragalin's GHPC [5] which allows multiple\nformulae on both sides of sequents. To maintain intuitionistic soundness, we restrict the premise of the implication-right rule to a singleton in the succedent.\nDually, the premise of our exclusion-left rule is restricted to a singleton in the\nantecedent. But using Dragalin's calculus and its dual does not give us BiInt\ncompleteness. We therefore follow Schwendimann [17], and use sequents which\npass relevant information from premises to conclusions using variables instantiated at the leaves of failed derivation trees. We then recompute parts of our\nderivation trees using the new information, similarly to the restart technique of\n[11]. Our calculus thus uses a purely syntactic addition to traditional sequents,\n2\n\n\frather than resorting to a semantic mechanism such as labels. Our termination\nargument also relies on two new rules from \u015avejdar [18].\nIf we were interested only in decision procedures, we could obtain a decision\nprocedure for BiInt by embedding it into the tense logic Kt.S4 [24], and using\ntableaux for description logics with inverse roles [11]. However, an embedding\ninto Kt.S4 provides no proof-theoretic insights into BiInt itself. Moreover, the\nrestart technique of Horrocks et al. [11] involves non-deterministic expansion of\ndisjunctions, which is complicated by inverse roles. Their actual implementation\navoids this non-determinism by keeping a global view of the whole counter-model\nunder construction. In contrast, we handle this non-determinism by syntactically\nencoding it using variables and extended formulae, neither of which have a semantic content. Our purely syntactic approach is preferable for proof-theoretic\nreasons, since models are never explicitly involved in the proof system: see Remark 3.\nThe rest of the paper is organized as follows. In Section 2, we define the syntax\nand semantics of BiInt. In Section 3, we introduce our sequent calculus GBiInt\nand give an example derivation of Uustalu's interaction formula. We prove the\nsoundness and completeness of GBiInt in Sections 4 and 5 respectively. In\nSection 6, we outline further work.\n\n2\n\nSyntax and Semantics of BiInt\n\nIn this section we introduce the syntax and semantics of BiInt.\nDefinition 1 (Syntax). The formulae of BiInt are defined as:\np ::= \u22a4 | \u22a5 | p0 | p1 | * * *\n\n(2.1)\n\n\u03c6 ::= p | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 | \u03c6 \u2228 \u03c6 | \u03c6 \u2192 \u03c6 | \u03c6\u2212<\u03c6 | \u00ac\u03c6 |\u223c\u03c6\n\n(2.2)\n\nWe refer to the set of atoms as Atoms, and we refer to the set of BiInt formulae\nas Fml .\nThe connectives \u00ac and \u2192 are those of intuitionistic logic, and the connectives\n\u223c and \u2212< are those of dual intuitionistic logic. The connectives \u2228 and \u2227 are\nfrom both.\nDefinition 2 (Length). The length of\n\uf8f1\nif\n\uf8f21\nif\nlen(\u03c7) = len(\u03c6) + 1\n\uf8f3\nlen(\u03c6) + len(\u03c8) + 1 if\n\na BiInt formula \u03c7 is defined as:\n\u03c7 \u2208 Atoms\n\u03c7 \u2208 {\u00ac\u03c6, \u223c\u03c6}\n\u03c7 \u2208 {\u03c6 \u2228 \u03c8, \u03c6 \u2227 \u03c8, \u03c6 \u2192 \u03c8, \u03c6\u2212<\u03c8}.\n\nWe use the language of classical first-order logic when reasoning about BiInt\nat the meta-level.\nDefinition 3 (Frame). A BiInt frame is a pair hW, Ri, where:\n3\n\n\f1.\n2.\n3.\n4.\n\nW is a non-empty set of worlds;\nR \u2286 W \u00d7 W is the binary accessibility relation;\nR is reflexive, i.e., \u2200u \u2208 W.uRu;\nR is transitive, i.e., \u2200u, v, w \u2208 W.(uRv & vRw \u21d2 uRw).\n\nDefinition 4 (Model). A BiInt model is a triple M = hW, R, \u03b8i, where:\n1. hW, Ri is a BiInt frame;\n2. The truth valuation \u03b8 is a function W \u00d7 Atoms \u2192 {true, false}, which tells\nus the truth value of an atom at a world;\n3. The persistence property holds:\n\u2200u, w \u2208 W.\u2200p \u2208 Atoms.(\u03b8(w, p) = true & wRu) \u21d2 (\u03b8(u, p) = true);\n4. \u2200w \u2208 W.\u03b8(w, \u22a4) = true;\n5. \u2200w \u2208 W.\u03b8(w, \u22a5) = false.\nDefinition 5 (Forcing of atoms). Given a model M = hW, R, \u03b8i, a world\nw \u2208 W and an atom p \u2208 Atoms, we write w \u000f p if \u03b8(w, p) = true. We pronounce\n\u000f as \"forces\", and we pronounce 2 as \"rejects\".\nDefinition 6 (Forcing of formulae). Given a model M = hW, R, \u03b8i, a world\nw \u2208 W and formulae \u03c6, \u03c8 \u2208 Fml, we write:\nw \u000f\u03c6\u2228\u03c8\nw \u000f\u03c6\u2227\u03c8\nw \u000f \u00ac\u03c6\nw\u000f\u03c6\u2192\u03c8\nw \u000f \u223c\u03c6\nw \u000f \u03c6\u2212<\u03c8\n\nif\nif\nif\nif\nif\nif\n\nw \u000f \u03c6 or w \u000f \u03c8\nw\u000f\u03c6 & w\u000f\u03c8\n\u2200u \u2208 W.[wRu \u21d2 (u 2 \u03c6)]\n\u2200u \u2208 W.[wRu \u21d2 (u 2 \u03c6 or u \u000f \u03c8)]\n\u2203u \u2208 W.[uRw & u 2 \u03c6]\n\u2203u \u2208 W.[uRw & u \u000f \u03c6 & u 2 \u03c8]\n\nFrom the semantics, it can be seen that the connectives \u00ac and \u223c can be\nderived from \u2192 and \u2212< respectively. Therefore from now on we restrict our\nattention to the connectives \u2192, \u2212<, \u2227, \u2228 only.\nLemma 1. The persistence property also holds for formulae, that is:\n\u2200M = hW, R, \u03b8i.\u2200u, w \u2208 W.\u2200\u03c6 \u2208 Fml .(w \u000f \u03c6 & wRu \u21d2 u \u000f \u03c6).\nProof. By induction on the length of \u03c6.\nLemma 2. The reverse persistence property holds:\n\u2200M = hW, R, \u03b8i.\u2200u, w \u2208 W.\u2200\u03c6 \u2208 Fml .(w 2 \u03c6 & uRw \u21d2 u 2 \u03c6).\nProof. Reverse persistence follows from persistence, because the truth valuation\nis binary. That is, suppose for a contradiction that\n\u2203M = hW, R, \u03b8i, \u2203u, w \u2208 W.\u2203\u03c6 \u2208 Fml .(w 2 \u03c6 & uRw & u \u000f \u03c6).\nThen u \u000f \u03c6 and uRw together with the persistence property give us w \u000f \u03c6,\nwhich contradicts w 2 \u03c6.\n4\n\n\fWe write \u01eb to mean the empty set. Given two sets of formulae \u2206 and \u0393 , we\nwrite \u2206, \u0393 for \u2206 \u222a \u0393 . Given a set of formulae \u2206 and a formula \u03c6, we write \u2206, \u03c6\nfor \u2206 \u222a {\u03c6}.\nDefinition 7. Given a model M = hW, R, \u03b8i, a world w \u2208 W and sets of\nformulae \u0393 and \u2206, we write:\nw \u000f \u0393 if \u2200\u03c6 \u2208 \u0393.w \u000f \u03c6\nw =| \u2206 if \u2200\u03c6 \u2208 \u2206.w 2 \u03c6.\nAs a corollary, for any world w, we vacuously have w \u000f \u01eb and w =| \u01eb.\nDefinition 8 (Consequence). Given two sets \u0393 and \u2206 of formulae, \u0393\nmeans:\n\u2200M = hW, R, \u03b8i.\u2200w \u2208 W. if w \u000f \u0393 then \u2203\u03c6 \u2208 \u2206.w \u000f \u03c6.\nWe write \u0393 6\n\nBiInt\n\n\u2206 to mean that it is not the case that \u0393\n\nBiInt\n\nBiInt\n\n\u2206\n\n\u2206, that is:\n\n\u2203M = hW, R, \u03b8i.\u2203w \u2208 W.(w \u000f \u0393 & w =| \u2206).\nThus \u0393 6\n\nBiInt\n\n\u2206 means that \u0393\n\nBiInt\n\n\u2206 is falsifiable.\n\nWe wish to prove \u0393 BiInt \u2206 by failing to falsify \u0393 BiInt \u2206. By Definition 8,\n\u0393 6 BiInt \u2206 means that there exists a BiInt model M = hW, R, \u03b8i that contains a\nworld w0 \u2208 W such that w0 \u000f \u0393 and w0 =| \u2206. We therefore try to construct the\nmodel using a standard counter-model construction approach: see [7]. We shall\nstart with an initial world w0 and assume that w0 \u000f \u0393 and w0 =| \u2206, and then\nsystematically decompose the formulae in \u0393 and \u2206. The procedure will either:\n\u2013 lead to a contradiction and therefore conclude that it cannot be the case\nthat w0 \u000f \u0393 and w0 =| \u2206, therefore \u0393 BiInt \u2206 holds, OR\n\u2013 construct the counter-model successfully and therefore demonstrate that it\nis possible that w0 \u000f \u0393 and w0 =| \u2206, therefore \u0393 BiInt \u2206 does not hold.\n\n3\n\nOur Sequent Calculus GBiInt\n\nWe now present GBiInt, a Gentzen-style sequent calculus for BiInt. The sequents have a non-traditional component in the form of variables that are instantiated at the leaves of the derivation tree, and passed back to lower sequents\nfrom premises to conclusion. Note that the variables are not names for Kripke\nmodels and have no semantic content.\n3.1\n\nSequents\n\nFirst, we introduce an extended syntax that will help us in the presentation of\nsome of our sequent rules.\nDefinition 9 (Extended Syntax). The extended BiInt formulae are defined\nas follows:\n5\n\n\f1. If \u03c6 is a BiInt formula, then \u03c6 is an extended BiInt\nW formula,\nV\n2. If S and P are sets of sets of BiInt formulae, then S and P are extended\nBiInt formulae.\nIf S = {{\u03c600 , * * * , \u03c6n0 }, * * * , {\u03c60m , * * * , \u03c6km }} and\n0\nk\nP = {{\u03c800 , * * * , \u03c80n }, * * * , {\u03c8m\n, * * * , \u03c8m\n}}, then from every extended BiInt formula we can obtain a BiInt formula as follows:\nW\n0\nn\n0\nk\nV S \u2261 (\u03c600 \u2227 * * * \u2227 \u03c6n0 ) \u2228 * * * \u2228 (\u03c60m \u2227 * * * \u2227 \u03c6km )\nP \u2261 (\u03c80 \u2228 * * * \u2228 \u03c80 ) \u2227 * * * \u2227 (\u03c8m \u2228 * * * \u2228 \u03c8m ).\nFrom now on, we implicitly treat extended BiInt formulae as their BiInt\nequivalents. The following semantics follows directly from Definition 9:\nDefinition 10 (Semantics of Extended Syntax). Given a BiInt model\nM = hW, R, \u03b8i, and a world w0 \u2208 W, we write:\nW\nw \u000f V S if \u2203\u0393 \u2208 S.w \u000f \u0393\nw =| P if \u2203\u2206 \u2208 P.w =| \u2206.\nWe can now extend the definition of forcing and rejecting to extended BiInt\nformulae in the obvious way. If \u0393 and \u2206 are sets of extended BiInt formulae\nviewed as their BiInt equivalents, and \u03c6 is an extended BiInt formula viewed\nas its BiInt equivalent, then:\nw \u000f \u0393 if \u2200\u03c6 \u2208 \u0393.w \u000f \u03c6\nw =| \u2206 if \u2200\u03c6 \u2208 \u2206.w 2 \u03c6.\nDefinition 11 (Sequent). A GBiInt sequent is an expression of the form\nS\nP\n\n\u0393 \u22a2\u2206\n\nand consists of the following components:\nLeft hand side (LHS): \u0393 , a set of extended BiInt formulae;\nRight hand side (RHS): \u2206, a set of extended BiInt formulae;\nVariables: S, P, each of which is a set of sets of formulae.\nWe shall sometimes use \u0393 \u22a2 \u2206 to refer to sequents, ignoring the variable values\nfor readability. We shall only do that in cases where the values of the variables are\nnot important to the discussion. Note that the variables do not contain extended\nBiInt formulae.\nWe now define the meaning of a sequent in terms of the counter-model under\nconstruction.\nDefinition 12 (Falsifiability). A sequent\nS\nP\n\n\u0393 \u22a2\u2206\n\nis falsifiable [at w0 in M] if and only if there exists a BiInt model M =\nhW, R, \u03b8i and \u2203w0 \u2208 W such that w0 \u000f \u0393 and w0 =| \u2206.\n6\n\n\fDefinition 13 (Variable conditions). We say the variable conditions of a\nsequent\nS\n\u03b3=P\n\u0393 \u22a2\u2206\nhold if and only if \u03b3 is falsifiable at w0 in some model M = hW, R, \u03b8i and the\nfollowing conditions hold:\nS-condition: Successor condition\n\u2203\u03a3 \u2208 S.\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a3\nP-condition: Predecessor condition\n\u2203\u03a0 \u2208 P.\u2200w \u2208 W.wRw0 \u21d2 w =| \u03a0\nLemma 3. A sequent \u0393 \u22a2 \u2206 is not falsifiable if and only if \u0393\n\nBiInt\n\nProof. Applying the negation of Definition 12 to \u0393 \u22a2 \u2206 gives \u0393\n3.2\n\n\u2206.\n\nBiInt\n\n\u2206.\n\nSequent Rules\n\nDefinition 14 (Sequent Rule). A sequent rule is of one of the forms\n\u03b31 * * * \u03b3n\n(name)\n\u03b30\nside conditions\n\n\u03b31 * * * \u03b3n\n(name)\n\u03b30\nside conditions\n\nwhere \u03b3i , 0 \u2264 i \u2264 n for n \u2265 0, are sequents. The rule consists of the following\ncomponents:\nConclusion: \u03b30 , written below the horizontal line;\nPremise(s): Optional, \u03b31 , * * * , \u03b3n , written above the horizontal line;\nName: Written to the left of the horizontal line;\nSide conditions: Optional, written underneath the rule;\nBranching: Universal (indicated by a solid line) or existential (indicated by a\ndashed line); explained shortly.\nTo achieve completeness and termination for BiInt, we combine a number of\nideas from various existing systems for Int, as well as use variables for updating\nworlds with relevant information received from successors and predecessors. Our\nrules can be divided into two groups: traditional (Fig. 1) and non-traditional\n(Fig. 2).\nOur traditional rules (Fig. 1) are based on Dragalin's GHPC [5] for Int because we require multiple formulae in the succedents and antecedents of sequents\nfor completeness; we have added symmetric rules for the DualInt connective \u2212<.\nThe main difference is that our (\u2192L ) rule and the symmetric (\u2212< R ) carry their\nprincipal formula and all side formulae into the premises. Our rules for \u2227 and \u2228\nalso carry their principal formula into their premises to assist with termination.\nNote that there are other approaches to a terminating sequent calculus for Int,\ne.g., Dyckhoff's contraction-free calculi [6], or history methods by Heuerding et\nal. [10] and Howe [12]. These methods are less suitable when the interaction\n7\n\n\f(Id)\n\nS:=\u01eb  \u0328 \u0328\n\u0393, \u03c6\nP:=\u01eb\n\n \u0328 \u0328\n\n \u0328 \u0328\n\n(\u2227L )\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6\n\n(\u2228R )\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393\n\n\u22a2 \u2206, \u03c6\n\n(\u22a5L )\n\n \u0328 \u0328\n\n\u22a2 \u2206, \u03c6 \u2228 \u03c8, \u03c6, \u03c8\n \u0328 \u0328\nS:=S1  \u0328 \u0328\nP:=P  \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2228 \u03c8\n1\n\n(\u2192L )\n\n( \u2212< R )\n\n \u0328 \u0328\n\n\u22a2 \u2206, \u03c6 \u2227 \u03c8, \u03c6\n\n \u0328 \u0328\n\n\u2228 \u03c8, \u03c6 \u22a2 \u2206\n\n(\u2227R )\n\n(\u2228L )\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6\n\n \u0328 \u0328\n\n\u2192 \u03c8 \u22a2 \u03c6, \u2206\n\n \u0328 \u0328\n\n\u22a2 \u2206, \u03c6 \u2212< \u03c8\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c8\n\n(\u22a4R )\n\n\u2206\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393\n\n\u2227 \u03c8, \u03c6, \u03c8 \u22a2 \u2206\n\n \u0328 \u0328\nS:=S1  \u0328 \u0328\nP:=P1  \u0328 \u0328 \u0393, \u03c6 \u2227 \u03c8 \u22a2 \u2206\n\nS:=\u01eb  \u0328 \u0328\n\u0393, \u22a5\u22a2\nP:=\u01eb\n\n \u0328 \u0328\n\n \u0328 \u0328\n\n\u22a2 \u2206, \u22a4\n\n \u0328 \u0328\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393\n\n\u22a2 \u2206, \u03c6 \u2227 \u03c8, \u03c8\n \u0328 \u0328\nS:=S1 \u222aS2  \u0328 \u0328\nP:=P1 \u222aP2  \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2227 \u03c8\n \u0328 \u0328\n\n \u0328 \u0328\n\n \u0328 \u0328\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393, \u03c6\n\nS:=S1 \u222aS2  \u0328 \u0328\nP:=P1 \u222aP2  \u0328 \u0328 \u0393, \u03c6\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393, \u03c6\n\nS:=S1 \u222aS2  \u0328 \u0328\nP:=P1 \u222aP2  \u0328 \u0328 \u0393, \u03c6\n\nS:=\u01eb  \u0328 \u0328\n\u0393\nP:=\u01eb\n\n\u2228 \u03c8, \u03c8 \u22a2 \u2206\n\n\u2228\u03c8 \u22a2\u2206\n\n\u2192 \u03c8, \u03c8 \u22a2 \u2206\n\n\u2192\u03c8\u22a2\u2206\n\n \u0328 \u0328\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393\n\n\u22a2 \u2206, \u03c6 \u2212< \u03c8, \u03c6\n\n \u0328 \u0328\nS:=S1 \u222aS2  \u0328 \u0328\nP:=P1 \u222aP2  \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2212< \u03c8\n\nFor every rule with premises \u03c0i and conlusion \u03b3, apply the rule only if:\n\u2200\u03c0i .(LHS\u03c0i 6\u2286 LHS\u03b3 or RHS\u03c0i 6\u2286 RHS\u03b3 )\nFig. 1. GBiInt rules - traditional\n\nbetween Int and DualInt formulae needs to be considered, since they erase potentially relevant formulae too soon during backward proof search. Moreover, we\nfound it easier to prove semantic completeness with our loop-checking method\nthan with history-based methods since both [10] and [12] prove completeness\nusing syntactic transformations of derivations. Consequently, while GBiInt is\nsound and complete for the Int (and DualInt) fragment of BiInt, it is unlikely\nto be as efficient on the fragment as these specific calculi.\nOur rules for \u2192 on the right and \u2212< on the left (Fig. 2) are non-traditional.\nThe (\u2192R ) and (\u2212< L ) rules have two premises instead of one, and they are connected by existential branching as indicated by the dotted horizontal line.\nExistential branching means that the conclusion is derivable if some premise is\nderivable; thus it is dual to the conventional universal branching, where the conclusion is derivable if all premises are derivable. We chose existential branching\nrather than two separate non-invertible rules so the left premise can communicate\ninformation via variables to the right premise. This inter-premise communication and the use of variables is crucial to proving interaction formulae of BiInt,\nand it gives our calculus an operational reading.\nWhen applying an existential branching rule during backward proof search,\nwe first create the left premise. If the left premise is non-derivable, then it returns\nthe variables S1 and P1 . We then use these variables to create the right premise,\nwhich corresponds to the same world as the conclusion, but with updated infor8\n\n\f(Ret)\n\n \u0328 \u0328\n\nS:={\u0393 }  \u0328 \u0328\nP:={\u2206}  \u0328 \u0328 \u0393\n\n\u22a2\u2206\n\nwhere no other rule is applicable\n\n(\u2192IR )\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393\n\n\u22a2 \u2206, \u03c6 \u2192 \u03c8, \u03c8\n \u0328 \u0328\nS:=S1  \u0328 \u0328\nP:=P  \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8\n\n( \u2212< IL )\n\n1\n\n(\u2192R )\n\n( \u2212< L )\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6, \u03c6 \u2212< \u03c8\n\n\u22a2\u2206\n\n \u0328 \u0328\n\nS:=S1  \u0328 \u0328\nP:=P1  \u0328 \u0328 \u0393, \u03c6 \u2212< \u03c8\n\n\u22a2\u2206\n\n \u0328 \u0328\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393\n\nV\n\u22a2 \u2206, \u03c6 \u2192 \u03c8, P1\n \u0328 \u0328\n \u0328 \u0328\nif P1 = \u01eb\n \u0328 \u0328\nif right prem created  \u0328 \u0328 \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8\n \u0328 \u0328\n\u2192 \u03c8} otherwise\nright prem created only if P1 6= \u01eb & \u2200\u03a0i \u2208 P1 .\u03a0i 6\u2286 {\u2206, \u03c6 \u2192 \u03c8}\n\u22a2\u03c8\n\n8\n>\n>\n< S1 /P1\nS/P:= S2 /P2\n>\n>\n: {\u0393 }/{\u2206, \u03c6\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u03c6\n\n \u0328 \u0328\n\nW\nS2  \u0328 \u0328\nS1\nP2  \u0328 \u0328 \u0393, \u03c6 \u2212< \u03c8,\n\n\u22a2 \u2206, \u03c8\n\n\u22a2\u2206\n \u0328 \u0328\n \u0328 \u0328\nif S1 = \u01eb\n \u0328 \u0328\nif right prem created  \u0328 \u0328 \u0328 \u0328 \u0393, \u03c6 \u2212< \u03c8 \u22a2 \u2206\n \u0328 \u0328\n \u0328 \u0328\n{\u0393, \u03c6 \u2212< \u03c8}/{\u2206} otherwise\n\n8\n>\n>\n> S1 /P1\n<\nS/P:= S2 /P2\n>\n>\n>\n:\n\nright prem created only if S1 6= \u01eb & \u2200\u03a3i \u2208 S1 .\u03a3i 6\u2286 {\u0393, \u03c6 \u2212< \u03c8}\n\n(\n\nV\n\nR)\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393\n\n \u0328 \u0328\nSn  \u0328 \u0328\n\u22a2 \u2206, \u03a01 * * * P\n \u0328 \u0328 \u0393 \u22a2 \u2206, \u03a0n\nn\nS\n \u0328 \u0328\nV\nS:= n\nS\n \u0328\n \u0328\nS1 i\n\u0393 \u22a2 \u2206, \u03a0\nP:= n P  \u0328 \u0328\n1\n\n(\n\ni\n\nW\n\nL)\n\n \u0328 \u0328\n\n \u0328 \u0328\n\nS1  \u0328 \u0328\nSn  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03a31 \u22a2 \u2206 * * * Pn  \u0328 \u0328 \u0393, \u03a3n\nSn\n \u0328 \u0328 W\nS:= 1 Si  \u0328 \u0328\nS\n \u0328 \u0328 \u0393, \u03a3 \u22a2 \u2206\nP:= n\n1 Pi\n\n\u22a2\u2206\n\nFor every universally branching rule with premises \u03c0i and conlusion \u03b3,\napply the rule only if: \u2200\u03c0i .(LHS\u03c0i 6\u2286 LHS\u03b3 or RHS\u03c0i 6\u2286 RHS\u03b3 )\nFor every existentially branching rule with left premise \u03c0 and conlusion \u03b3,\napply the rule only if: LHS\u03c0 6\u2286 LHS\u03b3 or RHS\u03c0 6\u2286 RHS\u03b3\nFig. 2. GBiInt rules - non-traditional\n\nmation. Our existential branching rules work together with (Ret), which\nV assigns\nthe\nvariables\nat\nnon-derivable\nleaves\nof\nfailed\nderivation\ntrees,\nand\n(\nR ) and\nW\n( L ), which extract the different variable choices at existential branching rules.\nThe conclusion of each of our rules assigns the variables based on the\nvariables returned from the premise(s), and we use the indices i, 1, 2 to indicate\nthe premise from which the variable takes its value. For rules with a single\npremise, the variables are simply passed down from premise to conclusion. For\nexample, the conclusion of (\u2227L ) in Fig. 1 assigns S := S1 , where S1 is the\nvalue of the variable at the premise. However, for rules with multiple universally\nbranching premises, we take a union of the sets of V\nsets corresponding to each\nfalsifiable\npremise.\nFor\nexample,\nthe\nconclusion\nof\n(\nR ) in Fig. 2 assigns S :=\nSn\nS\n,\nwhere\nS\nis\nthe\nvalue\nof\nthe\nvariable\nat\nthe\ni-th\npremise.\ni\ni\n1\nThis way, the sets of sets stored in our variables determinise the return\nof formulae to lower sequents \u2013 each non-derivable premise corresponds to an\nopen branch, and at this point we do not know whether it will stay open once\n9\n\n\fprocessed in conjunction with lower sequents. Therefore, we need to temporarily\nV\nkeep all open branches: see Example 2. Then the intuition behind adding\nP\nV\nto the right premise of (\u2192R ) is that the subsequent application of ( R ) will\ncreate one or more premises, depending on the cardinality of P. Since\nP is a set\nV\nof sets representing all the open branches, all of the premises of ( R ) have to be\nderivable\nin order to obtain a derivation. On the other hand, if some premises\nV\nof ( R ) are non-derivable (open), we form the set that consists of the union\nof the variables returned by those premises, and pass the union back to lower\nsequents, and so on. The premises that are derivable contribute only \u01eb and are\nthus ignored by the union operator. Also, we only create the right premise of\n(\u2192R ) if every member of P introduces new formulae to the current world.\nOtherwise, the current world already contains one\nV of the open branches, which\nwould still remain open after an application of ( R ). To summarise, the sets-ofsets concept of variables is critical to the soundness of GBiInt, as it allows us\nto remember the required choices arising further up the tree.\nThe extended syntax allows us to syntactically encode the variable choices\ndescribed above. While the variables S and P are sets of setsWwhen we pass them\ndown the tree and combine them using set union, we use S on the\nand\nV\nW left V\nP on the right of the sequent to reflect these choices when we add\nS\nor\nVP\nW\n)\nand\n(\nto the right premise of an existentially branching\nrule.\nThen\nthe\n(\nR)\nL\nW\nV\nrules break down the extended formulae S and P to yield several premises,\neach corresponding to one variable choice. Thus the extended syntax allows us\nto give an intuitive syntactic representation of the variable choices.\nWe have also added the rule (\u2192IR ) for implication on the right (and dually,\n(\u2212< IL )) originally given by \u015avejdar [18]. Rather than immediately creating the\nsuccessor for a rejected \u03c6 \u2192 \u03c8, the (\u2192IR ) rule first pre-emptively adds \u03c8 to\nthe right hand side of the sequent. Although \u015avejdar himself does not give the\nsemantics behind this rule, and is unable to explain the precise role it plays in\nhis calculus, it is very useful in our termination proof. The rule effectively uses\nthe reverse persistence property \u2013 if some successor v forces \u03c6 and rejects \u03c8,\nthen the current world w must reject \u03c8 too, for if w forces \u03c8, then by forward\npersistence so does v, thus giving a contradiction.\nThe side condition on each of our rules is a general blocking condition,\nwhere we only explore the premise(s), if they are different from the conclusion.\nFor example, in the (\u2227R ) case, the blocking condition means that we apply the\nrule in backward proof search only if \u03c6 6\u2208 \u2206 and \u03c8 6\u2208 \u2206, since otherwise some\npremise would be equal to the conclusion.\nGBiInt also has the subformula property. This is obvious for all rules,\nexcept (\u2192VR ) and the\nW dual (\u2212< L ). For these, the right premise \"constructs\" the\nformulae P and S. However, since P and V\nS are sets W\nof sets of subformulae\nof the conclusion that are again extracted by ( R ) and ( L ), the right premise\nof (\u2192R ) and (\u2212< L ) effectively only contains subformulae of the conclusion.\nDefinition 15 (GBiInt tree). A GBiInt tree for a sequent\nS\nP\n\n\u0393 \u22a2\u2206\n10\n\n\fis a tree rooted at\n\nS\nP\n\n\u0393 \u22a2 \u2206, such that:\n\n1. Each child is obtained by a backwards application of a GBiInt rule, and\n2. Each leaf is an instance of a (\u22a5L ), (\u22a4R ), (Id) or (Ret) rule.\nDefinition 16. A GBiInt tree T rooted at \u03b3 = P\nS\n\n\u0393 \u22a2 \u2206 is a derivation if:\n\n1. \u03b3 is the conclusion of a (\u22a5L ), (\u22a4R ) or (Id) rule application, OR,\n2. \u03b3 is the conclusion of a universal branching rule application, and all its\npremises are derivations, OR,\n3. \u03b3 is the conclusion of an existential branching rule application, and some\npremise is a derivation.\nWe say that \u03b3 is derivable if there exists a derivation for \u03b3.\nWe say that \u03b3 is not derivable if \u03b3 has no derivation.\n3.3\n\nExamples\n\nIn the following examples, we use a simplified version of the (\u2227R ) rule, which\ndiscards the principal formula from the premises, merely to save horizontal space.\nAlso, we only show non-empty variable values.\nExample 1. The following is a derivation tree of Uustalu's counterexample, the\ninteraction formula p \u2192 (q \u2228 (r \u2192 ((p\u2212< q) \u2227 r)), simplified to the sequent\np \u22a2 q, r \u2192 ((p\u2212< q) \u2227 r). We abbreviate X := r \u2192 ((p\u2212< q) \u2227 r). The tree\nshould be read bottom-up while ignoring the variables S and P. At the leaves,\nthe variables are assigned and transmit information down to parents and across\nto some siblings. The top left application of (Ret) occurs because an application\nof the (\u2212< R ) rule to the bolded p\u2212< q is blocked, since its left premise would\nnot be different from its conclusion.\nNotice that the key to finding the contradiction is the bolded p\u2212<q formula\nthat is passed from the\nV left-most leaf node back to the right premise (1) of the\n(\u2192R ) rule. Also, the ( R ) rule in (1) is unary in this case, since the returned P\nvariable contains only one set of formulae.\n(Ret)\n( \u2212< R )\n\n(Id)\np, r \u22a2 p \u2212< q, p\n\u22a2 p \u2212< q\n \u0328 \u0328\nS:={{p,r,q}}  \u0328 \u0328\np, r \u22a2 p\u2212 < q\nP:={{p\u2212<q}}  \u0328 \u0328\n\n \u0328 \u0328\n\nS:={{p,r,q}}  \u0328 \u0328\nP:={{p\u2212<q}}  \u0328 \u0328 p, r, q\n\n(\u2227R )\n\n(\u2192R )\n\n(Id)\n\n \u0328 \u0328\nS:={{p,r,q}}  \u0328 \u0328\np, r \u22a2 (p \u2212< q) \u2227 r\nP:={{p\u2212<q}}  \u0328 \u0328\n\np, r \u22a2 r\n\np \u22a2 q, r \u2192 ((p \u2212< q) \u2227 r)\n\nWhere (1) is:\n(Id)\n\n(Id)\np, q \u22a2 q, X, p \u2212< q\n\np \u22a2 q, X, p \u2212< q, p\n\n( \u2212< R )\n(\n\nV\n\nR)\n\np \u22a2 q, X, p \u2212< q\nV\np \u22a2 q, X, {{p \u2212< q}}\n\n11\n\n(1)\n\n\fExample 2. The following example is a GBiInt-tree of a falsifiable sequent,\nand it shows how in the case of multiple choices for the variables, a contradiction caused by one of them does not give us a derivation. We abbreviate\nY := (\u22a4 \u2212<p) \u2227 (\u22a4 \u2212<q), and X := Y \u2192\u22a5.\n(Ret)\n(\u2227R )\n\n \u0328 \u0328\n \u0328 \u0328\n \u0328 \u0328 X \u22a2\u22a5, \u22a4 \u2212< p\n \u0328 \u0328\nP:={{\u22a4 \u2212< p}}\nS:={{X}}\n\nP:=\n\n(\u2192L )\n\n(Ret)\n\nS:={{X}}\n \u0328 \u0328\n9  \u0328 \u0328\n8\n>\n>\n>  \u0328 \u0328\n>\n>\n=\n< {\u22a4 \u2212< p}, >\n\n \u0328 \u0328\n\n \u0328 \u0328\n \u0328 \u0328\n \u0328 \u0328 X \u22a2\u22a5, \u22a4 \u2212< q\n \u0328 \u0328\nP:={{\u22a4 \u2212< q}}\nS:={{X}}\n\n \u0328 \u0328 X \u22a2\u22a5, Y\n \u0328 \u0328\n\n>\n>\n>  \u0328 \u0328\n>\n>\n;  \u0328 \u0328\n: {\u22a4 \u2212< q} >\n\nP:=\n\n(\u2192R )\n\n \u0328 \u0328\n\n \u0328 \u0328 X \u22a2\u22a5\n\n>\n>  \u0328 \u0328\n>\n>\n>\n: {\u22a4 \u2212< q} >\n;  \u0328 \u0328\n\n(2)\n\nS:={{q}}\n \u0328\n))  \u0328\n((\n \u0328 \u0328\np,X\u2192\u22a5,\n\u22a4 \u2212< q\n\nWhere (2) is:\n\n \u0328 \u0328\n\n \u0328 \u0328 \u22a2 p, X \u2192\u22a5\n \u0328 \u0328\n\n(\u22a4R )\n\n(Ret)\n(\u22a4R )\n\nS:={{q}}\n \u0328\n))  \u0328\n((\n \u0328 \u0328\np,X\u2192\u22a5,\n\n \u0328 \u0328\n\n \u0328 \u0328 q \u22a2 p, X \u2192\u22a5, \u22a4 \u2212< q\n \u0328 \u0328\n\u22a4 \u2212< q\n \u0328 \u0328\n( \u2212< R )\nS:={{q}}\n( \u2212< R )\n \u0328\n))  \u0328\n((\n \u0328 \u0328\np,X\u2192\u22a5,\n\u22a2 p, X \u2192\u22a5, \u22a4 \u2212< p\n \u0328 \u0328 \u22a2 p, X \u2192\u22a5, \u22a4 \u2212< q\nP:=\n \u0328\n \u0328\nV\n\u22a4 \u2212< q\n( R)\n \u0328\n \u0328\n\uf6be\nff\nS:={{q}}\n \u0328\n))  \u0328\n((\nV\n \u0328 \u0328\np,X\u2192\u22a5,\n{\u22a4 \u2212< p}, {\u22a4 \u2212< q}\n \u0328 \u0328 \u22a2 p, X \u2192\u22a5,\nP:=\n \u0328 \u0328\n\u22a4 \u2212< q\n.\n.\n.\n\n.\n.\n.\n\nX, \u22a5\u22a2\u22a5\n\nS:={{X}}\n \u0328 \u0328\n8\n9  \u0328 \u0328\n>\n>\n>\n>  \u0328 \u0328\n>\n< {\u22a4 \u2212< p}, >\n=  \u0328 \u0328\nP:=\n\n(Id)\n\n(\u22a5L )\n\nP:=\n\n.\n.\n.\n\nV\nP\nIn this case, the ( R ) rule in (2) has two premises, since the returned\nV\nvariable contains two sets of formulae. Since only the left premise of the ( R ) rule\nis derivable, the conclusion is not derivable. Thus, the open branch corresponding\nto the bolded member {\u22a4 \u2212< q} of P remains open. If we did not return both\nvariable choices from the left sibling of (2), then we might mistakenly derive (2)\nwithout seeing this open branch.\nLemma 4. If a GBiInt-tree T rooted at \u03b3 =\nS = P = \u01eb.\n\nP\nS\n\n\u0393 \u22a2 \u2206 is a derivation then\n\nProof. By induction on the longest branch in T .\n3.4\n\nTermination Proof\n\nWe first show that proof search in GBiInt terminates because the subsequent\nsoundness proof relies on our ability to receive the variables from the left premises\nof transitional rules.\nDefinition 17. The rules of GBiInt are categorised as follows:\nOperational: (Ret);\n12\n\n\fFunction Prove\nInput: sequent \u03b30\nOutput: Derivable (true or f alse)\n1. If \u03c1 \u2208 {(Id), (\u22a5L ), (\u22a4R )} applicable to \u03b30 then\n(a) Return true\n2. Else if any special or static rule \u03c1 applicable to \u03b30 then\n(a) Let \u03b31 , *V\n* * , \u03b3n be the premises of \u03c1\n(b) Return P rove(\u03b3i )\n3. Else for each transitional rule \u03c1 applicable to \u03b30 do\n(a) LetW\u03b31 and \u03b32 be the premises of \u03c1\n(b) If P rove(\u03b3i ) = true then return true\n4. Endif\n5. Return f alse.\nFig.\nVn 3. Proof search strategy. Note that we have left out the variables for simplicity.\nWi=1 P rove(\u03b3i ) is true iff P rove(\u03b3i ) is true for all premises \u03b3i for 1 \u2264 i \u2264 n, and\ni\u2208{1,2} P rove(\u03b3i ) is true iff P rove(\u03b3i ) is true for some premise \u03b3i for i \u2208 {1, 2}.\n\nLogical:\nStatic: (Id), (\u22a5L ), (\u22a4R ), (\u2227L ), (\u2228L ), (\u2227R ), (\u2228R ), (\u2192L ), (\u2212< R ), (\u2192IR ),\n(\u2212< IL );\nTransitional:\nVR ), (\u2212< L );\nW (\u2192\nSpecial: ( L ), ( R ).\nThe intuition behind the classification of the logical rules is that the static\nrules add formulae to the current world in the counter-model, the transitional\nrules create new worlds and add formulae to them, and the special rules decompose variables returned from non-derivable leaves. We shall prove this formally\nfor each rule later. The classification justifies the following search strategy.\nDefinition 18 (Strategy). The strategy defined in Figure 3 is used when applying the rules of our sequent calculus in backward proof search. Note that we\nhave left out the variables for simplicity.\nDefinition 19 (Subformulae). For a BiInt formula, we define the subformulae as follows, where p \u2208 Atoms and \u03c6, \u03c8 \u2208 Fml:\nsf (p)\n= {p}\nsf (\u03c6 \u2228 \u03c8) = sf (\u03c6) \u222a sf (\u03c8) \u222a {\u03c6 \u2228 \u03c8}\nsf (\u03c6 \u2227 \u03c8) = sf (\u03c6) \u222a sf (\u03c8) \u222a {\u03c6 \u2227 \u03c8}\nsf (\u03c6 \u2192 \u03c8) = sf (\u03c6) \u222a sf (\u03c8) \u222a {\u03c6 \u2192 \u03c8}\nsf (\u03c6\u2212<\u03c8) = sf\n[(\u03c6) \u222a sf (\u03c8) \u222a {\u03c6\u2212<\u03c8}\nW\nsf ( S)\n=\nsf (\u03a3)\n\u03a3\u2208S\n[\nV\nsf ( P) =\nsf (P)\n\u03a0\u2208P\n\n13\n\n\fFor a set \u0393 of extended BiInt formulae, we define sf (\u0393 ) =\n\n[\n\nsf (\u03c7).\n\n\u03c7\u2208\u0393\n\nW\nV\nNote that the subformulae of S and P do not include the conjunctions\nand disjunctions implicit in their BiInt equivalents.\nDefinition 20 (LEN). Let >len be a lexicographic ordering of sequents:\n(\u03932 \u22a2 \u22062 ) >len (\u03931 \u22a2 \u22061 ) iff\n\n|\u03932 | > |\u03931 | or\n|\u03932 | = |\u03931 | and |\u22062 | > |\u22061 |\n\nDefinition 21. Given a GBiInt-tree T and a branch B in T , we say that B is\nforward-only if B contains only applications of static and special rules, (\u2192R )\nand the right premises of (\u2212< L ). Similarly, B is backward-only if B contains\nonly applications of static and special rules, (\u2212< L ) and the right premises of\n(\u2192R ). A branch is single-directional if it is either forward-only or backwardonly. Finally, a branch contains interleaved left premises of transitional rules if\nit contains a sequence h* * * , \u03b3i , * * * , \u03b3j , * * * , \u03b3k , * * * i such that \u03b3i is the left premise\nof (\u2192R ), \u03b3j is the left premise of (\u2212< L ), and \u03b3k is the left premise of (\u2192R ).\nLemma 5. Every forward-only branch of any GBiInt-tree is finite.\nProof. We show that on every such branch, the length of a sequent defined\naccording to >len increases.\nConsider a rule \u03c1, and a backwards application of \u03c1 to some \u0393 \u22a2 \u2206, which\nyields n premises \u0393i \u22a2 \u2206i , where 1 \u2264 i \u2264 n.\nWe show that if \u03c1 is a static rule, then for all premises i, we have (\u0393i \u22a2\n\u2206i ) >len (\u0393 \u22a2 \u2206):\n\u03c1 \u2208 {(\u2227L ), (\u2228L ), (\u2212< IL )}: Then |\u0393i | > |\u0393 |;\n\u03c1 = (\u2192IR ): Then |\u03931 | = |\u0393 | and |\u22061 | > |\u2206|;\n\u03c1 = (\u2192L ): Then for the left premise, |\u03931 | = |\u0393 | and |\u22061 | > |\u2206|, and for the\nright premise, |\u03932 | > |\u0393 |;\n\u03c1 = (\u2212< R ): Then for the left premise, |\u03931 | > |\u0393 |, and for the right premise,\n|\u03932 | = |\u0393 | and |\u22062 | > |\u2206|.\nW\nV\nWe now show the cases for \u03c1 \u2208 {(\u2192R ), (\u2212< L ), ( R ), ( L )}. Even though\nthe right premise of (\u2192R ) and (\u2212< L ) itself is not greater than the conclusion,\nwe show that the lemma holds on the V\noverall GBiInt\nbranch, since according\nW\nto the strategy we immediately apply ( R ) or ( L ), thus increasing the length\nof the premise according to >len .\n\u03c1 = (\u2192R ): For every (\u2192R ) rule application:\n1. Consider the left premise \u03931 \u22a2 \u22061 . We know that according to our\nstrategy, the (\u2192IR ) rule has already been applied and thus \u03c8 \u2208 \u2206, so\n(\u2192R ) is applied only if \u03c6 6\u2208 \u0393 . Therefore, for the left premise, we have\n|\u03931 | > |\u0393 |;\n14\n\n\f2. Consider the right premise \u03932 \u22a2 \u22062 . It is created only if\nP1 6= \u01eb & \u2200\u03a0i \u2208 P1 .\u03a0i 6\u2286 {\u2206, \u03c6 \u2192 \u03c8}.\n\n(3.1)\n\nThat is, every V\nmember of P1 introduces new formulae to the RHS. V\nBut\nrecall that sf ( P1 ) \u2286 sf (\u0393 \u222a \u2206). According\nto\nour\nstrategy,\nthe\n(\nR)\nV\nrule will be immediately applied to P1 in \u22062 , giving n \u2265 1 premises\n\u03932j \u22a2 \u2206j2 where 1 \u2264 j \u2264 n. By 3.1, we will then have |\u2206j2 | > |\u2206| for\nall j. We also have |\u03932j | = |\u0393 | for all j. Therefore, according to the\nlexicographic ordering, we have (\u03932j \u22a2 \u2206j2 ) >len (\u0393 \u22a2 \u2206) for all the\nj\nj\nV premises \u03932 \u22a2V\u22062 .\n\u03c1 = ( R ): Since the ( R ) rule is only used in conjunction with the right premise\nof the (\u2192R ) rule, see case 2 above;\n\u03c1 = (\u2212< L ): For every (\u2212< L ) rule application:\n1. The assumption of the lemma does not apply to the left premise;\n2.\nV to the case for (\u2192R ) above.\nW The case for the right premise is dual\n\u03c1 = ( L ): By symmetry with the case for ( R ) above;\nSince the length of a sequent defined according to >len increases on every\nforward-only branch as shown above, and since GBiInt has the subformula\nproperty, eventually no more formulae can be added to a sequent on a forwardonly branch, and the branch will terminate.\nLemma 6. Every backward-only branch of any GBiInt-tree is finite.\nProof. By symmetry with Lemma 5.\nLemma 7. If a GBiInt-tree contains an infinite branch, then the branch contains an infinite number of interleaved left premises of transitional rules.\nProof. By Lemmas 5 and 6, single-directional branches must eventually terminate. Thus, a potential infinite loop must involve an infinite number of interleaved left premises of transitional rules (\u2192R ) and (\u2212< L ).\nDefinition 22 (Degree). The degree of a\n\uf8f1\n\uf8f20\ndeg(\u03c7) = deg(\u03c6) + deg(\u03c8)\n\uf8f3\ndeg(\u03c6) + deg(\u03c8) + 1\n\nBiInt formula \u03c7 is defined as:\nif \u03c7 \u2208 Atoms\nif \u03c7 \u2208 {\u03c6 \u2228 \u03c8, \u03c6 \u2227 \u03c8}\nif \u03c7 \u2208 {\u03c6 \u2192 \u03c8, \u03c6\u2212<\u03c8}\n\nThus, the degree of \u03c6 is the number of \u2192 and \u2212< connectives in \u03c6.\nThe degree of a sequent \u0393 \u22a2 \u2206 is defined as:\nX\ndeg(\u03c6)\ndeg(\u0393 \u22a2 \u2206) =\n\u03c6\u2208sf (\u0393 \u222a\u2206)\n\nNote that we have deliberately defined the degree of a sequent as the sum of\nthe degrees of subformulae, because it allows us to make the following observations, which will be crucial in the main termination proof.\n15\n\n\fCorollary 1. Since GBiInt has the subformula property, the degree of a sequent\ncan never increase in backward proof search. In other words, no GBiInt rule can\nincrease the degree of a sequent.\nCorollary 2. Given two sequents \u03b31 and \u03b32 , if sf (\u03b32 ) ( sf (\u03b31 ), then deg(\u03b32 ) <\ndeg(\u03b31 ). That is, removing some formula \u03c6 from a sequent during backward proof\nsearch decreases the degree of the sequent if \u03c6 is not a subformula of any other\nformula in the sequent, since \u03c6 no longer contributes to the sum of degrees of\nsubformulae.\nTheorem 1 (Termination). Every GBiInt-tree constructed according to the\nstrategy of Definition 18 is finite.\nProof. Suppose for a contradiction that there exists an infinite GBiInt-tree T .\nSince every rule has a finite number of premises, i.e., finite branching, then\nby K\u00f6nig's lemma an infinite tree can only be obtained by having a branch of\ninfinite length. Thus, T has an infinite branch B. By Lemma 7, B must contain\nan infinite number of interleaved left premises of transitional rules, as shown\nbelow:\n..\n..\n.\n.\n\u03c02 = (\u03932 , \u03c62 \u22a2 \u03c82 )\n\u03c02r\n(\u2192R )\n\u03932 \u22a2 \u22062 , \u03c62 \u2192 \u03c82\n..\n..\n.\n.\n\u03c61 \u22a2 \u03c81 , \u22061\n\u03c01r\n(\u2212< L )\n\u03931 , \u03c61 \u2212<\u03c81 \u22a2 \u22061\n..\n..\n.\n.\n\u03930 , \u03c60 \u22a2 \u03c80\n\u03c00r\n(\u2192R )\n\u03c00 = (\u03930 \u22a2 \u22060 , \u03c60 \u2192 \u03c80 )\n..\n.\nLet \u03c7 \u2208 sf (\u03c00 ) be some formula such that deg(\u03c7) = max({deg(\u03c6) | \u03c6 \u2208\nsf (\u03c00 )}), that is, \u03c7 is one of the subformulae with the maximum degree. In\nparticular, this means that \u03c7 is not a subformula of any formula with a larger\ndegree. We shall now show that \u03c7 6\u2208 sf (\u03c02 ).\nThere are two cases:\n\u03c7 6\u2208 sf (\u03930 ): Then \u03c7 \u2208 sf (\u22060 ) or \u03c7 = \u03c60 \u2192 \u03c80 . In both cases, \u03c7 6\u2208 sf (\u03c02 ).\n\u03c7 \u2208 sf (\u03930 ): Then it cannot be the case that \u03c7 \u2208 sf (\u03c61 ) or \u03c7 \u2208 sf (\u03c81 ), since\nthen deg(\u03c61 \u2212< \u03c81 ) > deg(\u03c7), contradicting our assumption that deg(\u03c7) =\nmax({deg(\u03c6) | \u03c6 \u2208 sf (\u03c00 )}). Therefore, either:\n\u2013 \u03c7 and all its occurrences in subformulae disappear from the sequent at\nthe premise of (\u2212< L ), in which case \u03c7 6\u2208 sf (\u03c02 ), or\n16\n\n\f\u2013 \u03c7 is moved to the RHS of the sequent by applying the (\u2192L ) rule to\nsome formula \u03c7 \u2192 \u03c4 . However, since deg(\u03c7 \u2192 \u03c4 ) > deg(\u03c7), it again\ncontradicts our assumption that deg(\u03c7) = max({deg(\u03c6) | \u03c6 \u2208 sf (\u03c00 )}).\nWe have shown that for some formula \u03c7 we have \u03c7 \u2208 sf (\u03c00 ) and \u03c7 6\u2208 sf (\u03c02 ).\nAlso, by the subformula property of GBiInt we have sf (\u03c02 ) \u2286 sf (\u03c00 ). Together\nwith \u03c7 \u2208 sf (\u03c00 ) and \u03c7 6\u2208 sf (\u03c02 ), this means sf (\u03c02 ) ( sf (\u03c00 ). Then by Corollary 2 we have deg(\u03c02 ) < deg(\u03c00 ). Note that the steps indicated by vertical\n.\nellipses (..) are arbitrary, since by Corollary 1 no rule can increase the degree of\na sequent.\nSince we have deg(\u03c02 ) < deg(\u03c00 ), we know that every sequence of interleaved\ntransitional rule applications must decrease the degree of the sequent. This can\nonly happen a finite number of times, until no more transitional rules are applicable. Therefore our assumption was wrong, and no branch B can be infinite.\nTherefore, every GBiInt-tree is finite.\n\n4\n4.1\n\nSoundness\nProof Outline\n\nInstead of the traditional approach of showing that each rule application preserves validity downwards, we use the notion of falsifiability and show that each\nrule application preserves falsifiability upwards. We then use Lemma 3 to make\nthe connection between falsifiability and validity.\nAlso, our addition of variables to the calculus introduces a two-way flow\nof information in the GBiInt trees, and this complicates the usually simple\nsoundness proof.\nWe separate the notion of soundness into two: local soundness, applicable\nlocally to a single rule application, and global soundness, which takes into account\nthe propagation of variables from the leaves down to some node, and possible\ninstances of the operational (Ret) rule. Note that locality here refers to locality\nin the GBiInt trees, not locality in the underlying Kripke models. We use the\nnotions of static and transitional rules to classify the rules according to this\nlatter notion.\n4.2\n\nLocal soundness\n\nDefinition 23 (Local soundness). A logical rule in GBiInt is locally sound\nif and only if:\n\u2013 For rules with universal branching: if the conclusion is falsifiable, then some\npremise is falsifiable;\n\u2013 For rules with existential branching: if the conclusion is falsifiable, then all\npremises are falsifiable.\n17\n\n\fWe shall now show that each static and special rule is locally sound, and we\nshall then use induction on the height of a derivation tree to extend our proof\nto arbitrary trees containing static rules, special rules, transitional rules and the\noperational (Ret) rule.\nLemma 8. Each static and special rule of GBiInt is locally sound.\nProof. We consider each static and special rule in turn. We assume that the\nconclusion is falsifiable, and show that some premise is falsifiable.\n1.\n\n(Id)\n\nS:=\u01eb\nP:=\u01eb\n\n\u0393, \u03c6 \u22a2 \u2206, \u03c6\n\nThe conclusion of this rule is never falsifiable, because no BiInt model can\ncontain a world w such that w \u000f \u03c6 and w 2 \u03c6.\n2.\n\n(\u22a5L )\n\nS:=\u01eb\nP:=\u01eb\n\n\u0393, \u22a5\u22a2 \u2206\n\nThe conclusion of this rule is never falsifiable, because by Property 5 of\nDefinition 4, no BiInt model can contain a world w such that w \u000f\u22a5.\n3.\n\n(\u22a4R )\n\nS:=\u01eb\nP:=\u01eb\n\n\u0393 \u22a2 \u2206, \u22a4\n\nThe conclusion of this rule is never falsifiable, because by Property 4 of\nDefinition 4, no BiInt model can contain a world w such that w 2 \u22a4.\n4.\n(\u2227R )\n\nS1\nP1\n\n\u0393 \u22a2 \u2206, \u03c6 \u2227 \u03c8, \u03c6\nS:=S1 \u222aS2\nP:=P1 \u222aP2\n\nS2\nP2\n\n\u0393 \u22a2 \u2206, \u03c6 \u2227 \u03c8, \u03c8\n\n\u0393 \u22a2 \u2206, \u03c6 \u2227 \u03c8\n\nSince the conclusion is falsifiable by assumption, we know from Definition\n12 that there exists a world w0 such that:\n(i) w0 \u000f \u0393 and\n(ii) w0 =| \u2206, \u03c6 \u2227 \u03c8.\nFrom the semantics of \u2227 in BiInt, (b) implies that either:\n(ii.1) w0 =| \u2206, \u03c6 \u2227 \u03c8, \u03c6 or\n(ii.2) w0 =| \u2206, \u03c6 \u2227 \u03c8, \u03c8.\nTo show that some premise of the (\u2227R ) rule is falsifiable, we need to show\nthat there exists a world w\u2032 such that some premise is falsifiable at w\u2032 . We\nlet w\u2032 = w0 .\nThen case (ii.1) together with (i) gives us that the left premise is falsifiable,\nor case (ii.2) together with (i) gives us that the right premise is falsifiable.\n5.\n(\u2228L )\n\nS1\nP1\n\n\u0393, \u03c6 \u2228 \u03c8, \u03c6 \u22a2 \u2206\nS:=S1 \u222aS2\nP:=P1 \u222aP2\n\nS2\nP2\n\n\u0393, \u03c6 \u2228 \u03c8, \u03c8 \u22a2 \u2206\n\n\u0393, \u03c6 \u2228 \u03c8 \u22a2 \u2206\n\nBy symmetry with the (\u2227R ) rule.\n18\n\n\f6.\n(\u2228R )\n\nS1\nP1\n\n\u0393 \u22a2 \u2206, \u03c6 \u2228 \u03c8, \u03c6, \u03c8\n\nS:=S1\nP:=P1\n\n\u0393 \u22a2 \u2206, \u03c6 \u2228 \u03c8\n\nSince the conclusion is falsifiable by assumption, we know from Definition\n12 that there exists a world w0 such that:\n(i) w0 \u000f \u0393 and\n(ii) w0 =| \u2206, \u03c6 \u2228 \u03c8\nTo show that the premise of the (\u2228R ) rule is falsifiable, we need to show\nthat there exists a world w\u2032 such that the premise is falsifiable at w\u2032 . We let\nw\u2032 = w0 .\nFrom the semantics of \u2228 in BiInt, (ii) implies that w0 =| \u2206, \u03c6 \u2228 \u03c8, \u03c6 and\nw0 =| \u2206, \u03c6\u2228\u03c8, \u03c8. Together with (i), this means that the premise is falsifiable.\n7.\n(\u2227L )\n\nS1\nP1\n\n\u0393, \u03c6 \u2227 \u03c8, \u03c6, \u03c8 \u22a2 \u2206\n\nS:=S1\nP:=P1\n\n\u0393, \u03c6 \u2227 \u03c8 \u22a2 \u2206\n\nBy symmetry with the (\u2228R ) rule.\n8.\n(\u2192L )\n\nS1\nP1\n\nS2\nP2\n\n\u0393, \u03c6 \u2192 \u03c8 \u22a2 \u03c6, \u2206\nS:=S1 \u222aS2\nP:=P1 \u222aP2\n\n\u0393, \u03c6 \u2192 \u03c8, \u03c8 \u22a2 \u2206\n\n\u0393, \u03c6 \u2192 \u03c8 \u22a2 \u2206\n\nSince the conclusion is falsifiable by assumption, we know from Definition\n12 that there exists a world w0 such that:\n(i) w0 \u000f \u0393, \u03c6 \u2192 \u03c8 and\n(ii) w0 =| \u2206.\nFrom the semantics of \u2192 in BiInt, (i) implies that for all successors w, we\nhave w 2 \u03c6 or w \u000f \u03c8.\nBy reflexivity of R, this applies to w0 too, so we have:\n(i.1) w0 2 \u03c6 or\n(i.2) w0 \u000f \u03c8.\nTo show that some premise of the (\u2192L ) rule is falsifiable, we need to show\nthat there exists a world w\u2032 such that some premise is falsifiable at w\u2032 . We\nlet w\u2032 = w0 .\nThen items (i), (ii) and (i.1) give us that the left premise is falsifiable, or\nitems (i), (ii) and (i.2) give us that the right premise is falsifiable.\n9.\n(\u2212< R )\n\nS1\nP1\n\n\u0393, \u03c8 \u22a2 \u2206, \u03c6\u2212<\u03c8\nS:=S1 \u222aS2\nP:=P1 \u222aP2\n\nS2\nP2\n\n\u0393 \u22a2 \u2206, \u03c6\u2212<\u03c8, \u03c6\n\n\u0393 \u22a2 \u2206, \u03c6\u2212<\u03c8\n\nBy symmetry with (\u2192L ).\n19\n\n\f10.\nS1\nP1\n\n(\u2192IR )\n\n\u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8, \u03c8\n\nS:=S1\nP:=P1\n\n\u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8\n\nSince the conclusion is falsifiable by assumption, we know from Definition\n12 that there exists a world w0 such that:\n(i) w0 \u000f \u0393 and\n(ii) w0 =| \u2206, \u03c6 \u2192 \u03c8.\nFrom the semantics of \u2192 in BiInt, (ii) implies that there exists a successor\nw1 such that:\n(iii) w0 Rw1 and\n(iv) w1 \u000f \u03c6 and\n(v) w1 2 \u03c8.\nThen, by the reverse persistence property of BiInt, and (iii) and (v), we\nhave:\n(vi) w0 2 \u03c8.\nTo show that the premise of the (\u2192R ) rule is falsifiable, we need to show\nthat there exists a world w\u2032 such that the premise is falsifiable at w\u2032 . We let\nw\u2032 = w0 .\nThen items (i), (ii) and (vi) give us that the premise is falsifiable.\n11.\n(\u2212< IL )\n\n12.\n\nS1\nP1\n\n\u0393, \u03c6, \u03c6\u2212<\u03c8 \u22a2 \u2206\n\nS:=S1\nP:=P1\n\n\u0393, \u03c6\u2212<\u03c8 \u22a2 \u2206\n\nBy symmetry with (\u2192IR ).\nW\n( L)\n\nS1\nP1\n\n\u0393, \u03a31 \u22a2 \u2206 * * *\nS\nS:=Sn\n1 Si\nP:= n\n1 Pi\n\n\u0393,\n\nSn\nPn\n\nW\n\n\u0393, \u03a3n \u22a2 \u2206\n\n\u03a3\u22a2\u2206\n\nSince the conclusion is falsifiable by assumption, we know from Definition\n12 that there\nW exists a world w0 such that:\n(i) w0 \u000f \u0393, \u03a3 and\n(ii) w0 =| \u2206.\nW\nFrom the semantics of \u03a3 (recall Definition 10), (i) implies that:\n(iii) for some \u03a3i \u2208 \u03a3, we have w0 \u000fW\n\u03a3i .\nTo show that some premise of the ( L ) rule is falsifiable, we need to show\nthat there exists a world w\u2032 such that this premise is falsifiable at w\u2032 . We let\nw\u2032 = w0 .\nThen items (i), (ii) and (iii) give us that the i-th premise containing \u03a3i is\nfalsifiable at w0 .\n13.\nV\n( R)\n\nS1\nP1\n\n\u0393 \u22a2 \u2206, \u03a01 * * *\nS\nS:=Sn\n1 Si\nP:= n\n1 Pi\n\nSn\nPn\n\n\u0393 \u22a2 \u2206, \u03a0n\nV\n\u0393 \u22a2 \u2206, \u03a0\n20\n\n\fW\nBy symmetry with ( L ).\nRemark 1. Note that the static rules also preserve falsifiability downwards: if\nsome premise \u03c0 is falsifiable, then the conclusion \u03b3 is falsifiable. This is easy to\nsee, since we have LHS\u03c0 \u2287 LHS\u03b3 and RHS\u03c0 \u2287 RHS\u03b3 .\n4.3\n\nGlobal soundness\n\nWe have shown that all the static and special rules preserve falsifiability upwards,\nin other words, they are locally sound. Since the S and P variables propagate\ndownwards, from the leaves to the root, we can only reason about the variable\nconditions of rules when we consider an entire tree rooted at a rule application.\nSimilarly, since the soundness of the transitional rules relies on the variables, we\ncan only reason about it we consider an entire tree rooted at a transitional rule\napplication. We shall now show that GBiInt rules are globally sound, that is,\nthey preserve falsifiability upwards and variable conditions downwards.\nLemma 9 (Global soundness). Given any GBiInt tree T , for every sequent\n\u03b30 \u2208 T , the following holds: if \u03b30 is falsifiable, then:\n1. Some universally branching, or all existentially branching, premises are falsifiable,\n2. The variable conditions hold at \u03b30 .\nProof. By induction on the length h(\u03b30 ) of the longest branch from \u03b30 to a leaf\nsequent of T .\nBase case: h(\u03b30 ) = 0. So \u03b30 itself is an instance of (Id), (\u22a5L ), (\u22a4R ), or (Ret).\n(Id), (\u22a5L ), (\u22a4R ): The conclusion of these rules is never falsifiable, so there\nis nothing to show.\n(Ret):\nThe conclusion of the (Ret) rule is \u0393 \u22a2 \u2206, and there is no premise. From\nthe side condition of the (Ret) rule, we know that no other rules are\napplicable to \u0393 \u22a2 \u2206. We will now show that \u0393 \u22a2 \u2206 is falsifiable, and\nthat it obeys the variable conditions.\nWe create a model with a single world w0 , and for every atom p in \u0393 , we\nlet \u03b8(w0 , p) = true, and for every atom q in \u2206, we let \u03b8(w0 , q) = f alse.\nNote that an atom cannot be both in \u0393 and \u2206, since the (Id) rule in\nparticular is not applicable to \u0393 \u22a2 \u2206.\nTo show that \u0393 \u22a2 \u2206 is falsifiable at w0 , we need to show that w0 \u000f \u0393\nand w0 =| \u2206. For every atom in \u0393 and \u2206, the valuation ensures this.\nFor every composite formula \u03c6, we do a simple induction on its length.\nThe fact that the (Ret) rule is applied implies that no other rules are\napplicable, therefore the required subformula \u03c8 is already in \u0393 or \u2206 as\nappropriate, and \u03c8 falls under the induction hypothesis.\nThus we know that:\n(i) w0 \u000f \u0393 and\n21\n\n\f(ii) w0 =| \u2206.\nThen (i) and the persistence property of BiInt give us that \u2200w \u2208 W :\nw0 Rw \u21d2 w \u000f \u0393 . Similarly, (ii) and the reverse persistence property of\nBiInt give us that \u2200w \u2208 W.wRw0 \u21d2 w =| \u2206. Then the conclusion of\nthe (Ret) rule obeys the variable conditions:\nS-condition: Successor condition\n\u2203\u03a3 \u2208 {\u0393 }.\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a3\nP-condition: Predecessor condition\n\u2203\u03a0 \u2208 {\u2206}.\u2200w \u2208 W.wRw0 \u21d2 w =| \u03a0\nInduction step: We assume that the lemma holds for all \u03b30 with h(\u03b30 ) \u2264 k,\nand show that it holds for all \u03b30 with h(\u03b30 ) \u2264 k + 1.\nConsider the rule application \u03c1 such that \u03b30 is the conclusion of \u03c1. By the\nassumption of the lemma, we have that the conclusion \u03b30 of \u03c1 is falsifiable\nat some w0 in some model M = hW, R, \u03b8i. The only possibilities are that \u03c1\nis a static or a special rule, or that it is a transitional rule:\n1. \u03c1 is one of the static or special rules (universally branching). Then\nLemma 8 tells us that some premise is falsifiable. We now need to show\nthat the variable conditions hold at \u03b30 . There are two cases:\n\u03c1 is unary: The premise \u03b31 of \u03c1 has h(\u03b31 ) \u2264 k, therefore the induction\nhypothesis applies to \u03b31 . By Lemma 8 and the fact that \u03b30 is falsifiable at w0 , we know that the premise \u03b31 is falsifiable at w0 , so by\nthe induction hypothesis we have that the variable conditions hold\nat \u03b31 . Since \u03b31 has the same variables as \u03b30 , and since \u03b31 is falsified\nby the same world w0 as \u03b30 , we then know that \u03b30 also obeys the\nvariable conditions.\n\u03c1 is n-ary with n > 1: We show the case for S; the case for P is symmetric. The premises \u03b31 to \u03b3n of \u03c1 each have \u03b3i \u2264 k, therefore the\ninduction hypothesis applies to each \u03b3i . By Lemma 8 and the fact\nthat \u03b30 is falsifiable at w0 , we know that some \u03b3m is falsifiable at\nw0 , too. Therefore the induction hypothesis tells us that the variable\nconditions hold at \u03b3m . That is, we know that:\n\u2203\u03a3m \u2208 Sm .\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a3m .\nTo show that the conclusion \u03b30 obeys the variable condition for S,\nwe need to show the following:\n\u2203\u03a3 \u2208\n\nn\n[\n\nSi .\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a3.\n\n1\n\nS\nS\nSince \u03a3m \u2208 Sm and Sm \u2286 n1 Si , we have \u03a3m \u2208 n1 Si and thus the\nvariable conditions hold for S at the conclusion \u03b30 .\n2. \u03c1 is one of the transitional rules (existentially branching). We show the\ncase for the (\u2192R \u0328 \u0328) rule, the case \u0328 \u0328for the (\u2212< L ) rule is symmetric:\nS1  \u0328 \u0328\nP1  \u0328 \u0328 \u0393, \u03c6\n\nS2  \u0328 \u0328\nP2  \u0328 \u0328 \u0393\n\nV\n\u22a2 \u2206, \u03c6 \u2192 \u03c8, P1\n(\u2192R )\n \u0328 \u0328\n8\n \u0328 \u0328\n>\nif P1 = \u01eb\n>\n< S1 /P1\n \u0328 \u0328\n \u0328 \u0328 \u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8\nS/P:= S2 /P2\nif\nright\nprem\ncreated\n>\n \u0328 \u0328\n>\n: {\u0393 }/{\u2206, \u03c6 \u2192 \u03c8} otherwise\n \u0328 \u0328\nright prem created only if P1 6= \u01eb & \u2200\u03a0i \u2208 P1 .\u03a0i 6\u2286 {\u2206, \u03c6 \u2192 \u03c8}\n\u22a2\u03c8\n\n22\n\n\fSo suppose that the conclusion is falsifiable. Then we know from Definition 12 that there exists a world w0 such that:\n(i) w0 \u000f \u0393 and\n(ii) w0 =| \u2206, \u03c6 \u2192 \u03c8.\nFrom the semantics of \u2192 in BiInt, (ii) implies that there exists a successor w1 such that:\n(iii) w0 Rw1 and\n(iv) w1 \u000f \u03c6 and\n(v) w1 2 \u03c8.\n(a) To show that the left premise of the (\u2192R ) rule is falsifiable, we\nneed to show that there exists a world w\u2032 such that this premise is\nfalsifiable at w\u2032 . We let w\u2032 = w1 .\nThen items (i), (iv) and (v) give us that the left premise is falsifiable.\nNow, the left premise \u03b31 is of distance \u2264 k from the furthest leaf\nnode of T , therefore the induction hypothesis applies to \u03b31 . By the\nhypothesis assumption, since \u03b31 is falsifiable at w1 , we have that the\nvariable conditions hold at \u03b31 . In particular, the P condition holds,\ngiving us:\n\u2203\u03a0 \u2208 P1 .\u2200w \u2208 W.wRw1 \u21d2 w =| \u03a0\n(4.1)\nNow there are two cases: either the right premise was created, or\nit was not (and there is nothing to show). If it was created, then\nwe need to show that it is falsifiable by exhibiting a world w\u2032\u2032 such\nthat the right premise is falsifiable at w\u2032\u2032 . We let w\u2032\u2032 = w0 . Then,\nsince w0 Rw1 , we have w0 =| \u03a0 by\nV (4.1). Since \u03a0 \u2208 P1 , then by\nDefinition 10 we have that w0 =| P1 . Together with (i) and (ii),\nthis means that the right premise is falsifiable at w0 .\nMoreover, the variable conditions hold at the right premise, since it\nalso is falsifiable, and of distance \u2264 k from the furthest leaf node of\nT , so the induction hypothesis applies to it.\n(b) We need to show that the variable conditions hold at the conclusion\n\u03b30 of the (\u2192R ) rule. We show the case for the variable S; the case\nfor P is symmetric. We need to show that:\n\u2203\u03a3 \u2208 S.\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a3\n(4.2)\n\uf8f1\n\uf8f2 S1 if P1 = \u01eb\nWhere S := S2 if right prem created\n\uf8f3\n{\u0393 } otherwise\nSince we have shown that the variable conditions hold at the left\npremise, we know that in particular P1 6= \u01eb. Therefore there are two\ncases: either the right premise was created, or it was not:\n\u2013 If the right premise \u03b32 was created, then we know that the variable conditions hold at \u03b32 , since \u03b32 falls under the induction\nhypothesis. This gives us:\n\u2203\u03a32 \u2208 S2 .\u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u03a32\nThus S := S2 obeys (4.2).\n23\n\n\f\u2013 If the right premise was not created, then we need to show that\n{\u0393 } obeys the variable conditions at the conclusion. Now, we\nhave w0 \u000f \u0393 by (i), and then the persistence property tells us\nthat \u2200w \u2208 W.w0 Rw \u21d2 w \u000f \u0393 . Thus S := {\u0393 } obeys (4.2).\n4.4\n\nMain Soundness Proof\n\nLemma 10. If \u0393 \u22a2 \u2206 is derivable then \u0393 \u22a2 \u2206 is not falsifiable.\nProof. By induction on the height k of the derivation.\nBase case: For the base case, the height is 1. A derivation of height 1 can\nonly be an instance of (\u22a5L ), (\u22a4R ) or (Id). In each case, \u03b3 is not falsifiable, as\nshown in cases 1 to 3 of Lemma 8.\nInductive step: We assume that if there is a derivation for \u03b3 of height \u2264 k,\nthen \u03b3 is not falsifiable. We show that if there is a derivation for \u03b3 of height\n\u2264 k + 1, then \u03b3 is not falsifiable.\nFor a contradiction, suppose there is a derivation T for \u03b3 of height k + 1 and\n\u03b3 is falsifiable. Consider the bottom-most rule application \u03c1 in T , then \u03b3 is the\nconclusion of \u03c1.\nThen, by Definition 16, since T is a derivation, then all universally branching\npremises, or some existentially branching premise of \u03c1 are rooted at derivations\nof height \u2264 k, so by the induction hypothesis, all universally branching premises\nare, or some existentially branching premise is not falsifiable. But since the\nconclusion \u03b3 of \u03c1 is falsifiable by supposition, then by Lemma 9, some universally\nbranching premise, or all existentially branching premises are falsifiable. Now we\nhave a contradiction, therefore our assumption was wrong and \u03b3 is not falsifiable.\nTheorem 2 (Soundness). If \u0393 \u22a2 \u2206 is derivable, then \u0393\n\nBiInt\n\n\u2206.\n\nProof. By Lemma 10, we have that \u0393 \u22a2 \u2206 is not falsifiable. Then by Lemma 3,\nwe have \u0393 BiInt \u2206.\n\n5\n5.1\n\nCompleteness\nProof Outline\n\nWe wish to prove:\nif \u0393 BiInt \u2206, then \u0393 \u22a2 \u2206 is derivable.\nInstead, we prove the contrapositive:\nif \u0393 \u22a2 \u2206 is not derivable, then there exists a counter-model for \u0393\n\nBiInt\n\n\u2206.\n\nOur proof is based on a standard technique for proving completeness of tableau\ncalculi: see [9]. We have adapted this technique to a two-sided sequent calculus\nwith variables.\nWe assume that \u0393 \u22a2 \u2206 is not derivable, meaning that none of the GBiInttrees for \u0393 \u22a2 \u2206 is a derivation. Then we choose formulae from sequents found in\npossibly different GBiInt-trees for \u0393 \u22a2 \u2206 in order to construct a counter-model\nfor \u0393 BiInt \u2206. The counter-model is constructed so that it contains a world w0\nsuch that w0 \u000f \u0393 and w0 =| \u2206, hence \u0393 BiInt \u2206 does not hold.\n24\n\n\f5.2\n\nSaturated Sets\n\nDefinition 24. Given a sequent \u0393 \u22a2 \u2206, we say that:\n\u2013 \u0393 \u22a2 \u2206 is consistent if all of the following hold:\n1. \u22a56\u2208 \u0393\n2. \u22a4 6\u2208 \u2206\n3. \u0393 \u2229 \u2206 = \u01eb\n\u2013 \u0393 \u22a2 \u2206 is closed with respect to a GBiInt rule \u03c1 if either:\n\u2022 \u03c1 is not applicable to \u0393 \u22a2 \u2206, or\n\u2022 Whenever \u0393 \u22a2 \u2206 matches the conclusion of an instance of \u03c1, then for\nsome premise \u03931 \u22a2 \u22061 of the instance of \u03c1, we have \u03931 \u2286 \u0393 and \u22061 \u2286 \u2206.\n\u2013 \u0393 \u22a2 \u2206 is saturated if it is consistent and closed with respect to the static\nrules of GBiInt.\nThe following corollaries follow directly from the definition of consistent sequents.\nCorollary 3. If \u0393 \u22a2 \u2206 is consistent, then none of the rules (Id), (\u22a5L ), (\u22a4R )\nis applicable to it.\nCorollary 4. If the sequent\nS\nP\n\n\u0393 \u22a2\u2206\n\nis not derivable, then \u0393 \u22a2 \u2206 is consistent for all values of S and P.\nRemark 2. As usual, every sequent has a set of one or more \"saturations\" due\nto the branching of (\u2227R ), (\u2228L ), etc., rules. The usual approach is to nondeterministically choose one of the non-derivable premises of each such rule.\nHowever, in the presence of the inverse relation, a branch that appears open\nmay close once we return variables to a lower sequent. Therefore, we need to\ntemporarily keep all the non-derivable premises, since we do not know which of\nthe open branches will stay open when we return to a lower sequent.\nLemma 11. For each finite non-derivable sequent \u0393 \u22a2 \u2206, there is an effective\nprocedure to construct a finite set \u03b6 = {\u03b11 , * * * , \u03b1n } of finite saturated sequents,\nwith \u0393 \u222a \u2206 \u2286 LHS(\u03b1j ) \u222a RHS(\u03b1j ) \u2286 sf (\u0393 ) \u222a sf (\u2206) for all 1 \u2264 j \u2264 n.\nProof. Since \u0393 \u22a2 \u2206 is non-derivable, we know from Corollary 4 that \u0393 \u22a2 \u2206 is\nconsistent. Then from Corollary 3 we know that the (Id), (\u22a5L ), (\u22a4R ) rules are\nnot applicable to \u0393 \u22a2 \u2206. Let T = \u0393 \u22a2 \u2206. While some static rule \u03c1 is applicable\nto a leaf of T , extend T by applying \u03c1 to the leaf to obtain new leaves. Keep\nthe non-derivable leaves only; by Corollary 4 they are consistent. By Theorem 1,\nthe saturation process will eventually terminate; let \u03b6 = {\u03b11 , * * * , \u03b1n } be the\nfinal leaves of T . Since the formulae in each premise are always subformulae\nof the conclusion, we have that LHS(\u03b1j ) \u222a RHS(\u03b1j ) \u2286 sf (\u0393 ) \u222a sf (\u2206) for all\n1 \u2264 j \u2264 n.\n25\n\n\f5.3\n\nModel Graphs and Satisfiability Lemma\n\nWe shall use model graphs as an intermediate structure between GBiInt-trees\nand BiInt models.\nDefinition 25. A model graph for a sequent \u0393 \u22a2 \u2206 is a finite BiInt frame\nhW, Ri such that all w \u2208 W are saturated sequents \u0393w \u22a2 \u2206w and all of the\nfollowing hold:\n1.\n2.\n3.\n4.\n5.\n6.\n7.\n\n\u0393\nif\nif\nif\nif\nif\nif\n\n\u2286 \u0393w0 and \u2206 \u2286 \u2206w0 for some w0 \u2208 W, where w0 = \u0393w0 \u22a2 \u2206w0 ;\n\u03c6 \u2192 \u03c8 \u2208 \u2206w then \u2203v \u2208 W with wRv and \u03c6 \u2208 \u0393v and \u03c8 \u2208 \u2206v ;\n\u03c6\u2212<\u03c8 \u2208 \u0393w then \u2203v \u2208 W with vRw and \u03c6 \u2208 \u0393v and \u03c8 \u2208 \u2206v ;\nwRv and \u03c6 \u2192 \u03c8 \u2208 \u0393w then \u03c8 \u2208 \u0393v or \u03c6 \u2208 \u2206v ;\nvRw and \u03c6\u2212<\u03c8 \u2208 \u2206w then \u03c8 \u2208 \u0393v or \u03c6 \u2208 \u2206w\u2032 ;\nwRv and \u03c6 \u2208 \u0393w then \u03c6 \u2208 \u0393v ;\nvRw and \u03c6 \u2208 \u2206w then \u03c6 \u2208 \u2206v .\n\nWe now show that given a model graph, we can use it to construct a BiInt\nmodel.\nLemma 12. If there exists a model graph hW, Ri for \u0393 \u22a2 \u2206, then there exists\na BiInt model M = hW, R, \u03b8i such that for some w0 \u2208 W, we have w0 \u000f \u0393 and\nw0 =| \u2206. We call M the counter-model for \u0393 BiInt \u2206.\nProof. Since we already have a BiInt frame hW, Ri, we need to define a valuation \u03b8 in order to construct a BiInt model M = hW, R, \u03b8i:\n1. For every world w \u2208 W and every atom p \u2208 \u0393w , let \u03b8(w, p) = true.\n2. For every world w \u2208 W and every atom q \u2208 \u2206w , let \u03b8(w, q) = false.\nThen properties 6 and 7 of Definition 25 ensure persistence and reverse persistence respectively.\nWe now need to show that for every world w \u2208 W, we have w \u000f \u0393w and\nw =| \u2206w ; we can do this by simple induction on the length of the formulae in\n\u0393 \u22a2w \u2206.\nNow let w0 be the world in the model graph such that \u0393 \u2286 \u0393w0 and \u2206 \u2286 \u2206w0 .\nSince our proof by induction has shown that for every world w \u2208 W, we have\nw \u000f \u0393w and w =| \u2206w , then in particular, we have that w0 \u000f \u0393w0 and w0 =| \u2206w0 .\nThen, since we have that \u0393 \u2286 \u0393w0 and \u2206 \u2286 \u2206w0 , we also have w0 \u000f \u0393 and\nw0 =| \u2206.\n5.4\n\nMain Completeness Proof\n\nWe now show how to construct a model graph for \u0393 \u22a2 \u2206 from a consistent \u0393 \u22a2 \u2206.\nRecall from Remark 2 that we need to keep a number of independent versions of\nworlds because of the choices arising due to disjunctive non-determinism. We do\nthis by storing one or more independent connected-components hW1 , R1 i, * * * , hWn , Rn i\nin the constructed model graph hW, Ri, and the indices (sorts) of worlds and\n26\n\n\fProcedure MGC\nInput: sequent \u0393 \u22a2 \u2206\nOutput: model graph hW f , Rf i, variables S f and P f\n1. Let \u03b6 = {\u03b11 , * * * , \u03b1n } be the result of saturating \u0393 \u22a2 \u2206 using Lemma 11;\n2. For each \u03b1i \u2208 \u03b6 do\n(a) Let hWi , Ri i = h{\u03b1i }, {(\u03b1i , \u03b1i )}i; let recompute := f alse;\n(b) For each non-blocked \u03c6 \u2192 \u03c8 \u2208 \u2206\u03b1i and while recompute = f alse do\ni. Apply (\u2192R ) to \u03c6 \u2192 \u03c8 and obtain a left premise \u03c01 = \u0393\u03b1i , \u03c6 \u22a2 \u03c8;\nii. Let hW, Ri, S, P := M GC(\u03c01 );\niii. If \u2203\u03a0j \u2208 P.\u03a0j \u2286 \u2206\u03b1i then\nA. Let uj \u2208 Wj be the root of the connected component Wj from W;\nB. Let G = hWj , Rj i[j := i]; add G to hWi , Ri i, and put \u03b1i Ri ui .\niv. else\nA. Let hWi , Ri i = h\u01eb, \u01ebi; let recompute := true;\nV\nB. Invoke the\nV right premise of (\u2192R ) to obtain \u03c02 = \u0393\u03b1i \u22a2 \u2206\u03b1i , P;\nC. Apply ( R ) to \u03c02 to obtain m \u2265 1 non-derivable premises \u03b31 , * * * , \u03b3m ;\nD. For each \u03b3k , 1 \u2264 kS\u2264 m,Slet hWk , Rk i, Sk , S\nPk := M GC(\u03b3k );S\nE. Let hWi , Ri i := h Wk , Rk i, and Si := S\u03b3k and Pi := P\u03b3k ;\n(c) For each non-blocked \u03c6 \u2212<\u03c8 \u2208 \u0393\u03b1i and while recompute = f alse do\ni. Perform a symmetric procedure to Steps 2(b)i to 2(b)ivE.\n(d) If recompute\nS\nS = f alse\nS then\nS let Si := {\u0393\u03b1i } and Pi := {\u2206\u03b1i }.\n3. Return h Wi , Ri i, Si , Pi\nFig. 4. Model Graph Construction Procedure\n\nrelations tell us the connected-component of the graph to which they belong. We\nwrite hWj , Rj i[j := i] to relabel the connected component hWj , Rj i with sort\nj to a connected component hWi , Ri i with sort i. Similarly, we also label each\nmember of the variables P and S, so we can later extract the member with sort\ni, corresponding to the component of hW, Ri with sort i. We write R-neighbour\nto mean R-predecessor or R-successor.\nOur algorithm in Fig. 4 starts by saturating the root world to obtain one\nor more saturated \"states\". For each \"state\" \u03b1i , it recursively creates all the\nR-neighbours and saturates them, and so on. If during the construction of any\nR-neighbour, new information is returned from the higher sequents (Step 2(b)iv),\nthen we delete the entire subtree (connected component of sort i) rooted at \u03b1i ,\nand recreate \u03b1i using the new information (Step 2(b)ivB). This re-creates all the\nR-neighbours of \u03b1i . Otherwise, if none of the R-neighbours of \u03b1i return any new\ninformation, or there are no R-neighbours for \u03b1i , then Step 2d instantiates the\nvariables and returns from the recursion. In the latter case, the \"state\" \u03b1i already\nhas all the required information it can possibly receive from any R-neighbours,\nthus \u03b1i is final. Note the duality: new information from a single R-neighbour\nmeans that all of the members of a variable were new, while new information at\na \"state\" \u03b1i means that some R-neighbour returned new information.\n27\n\n\fWhen we return from M GC, we form the union of the components of the\nmodel graph and the variables from the different \"states\", so that the caller of\nM GC can extract the appropriate component at Step 2(b)iiiA.\nRemark 3. Note that while the counter-model construction procedure keeps the\nwhole counter-model in memory, this procedure is only used to prove the completeness of GBiInt. Our procedure for checking the validity of BiInt formulae\n(Fig. 3) does not need the whole counter-model, and explores one branch at a\ntime, as is usual for sequent/tableaux calculi.\nTheorem 3 (Completeness). GBiInt is complete: if \u0393 \u22a2 \u2206 is not derivable,\nthen there exists a counter-model for \u0393 BiInt \u2206.\nProof. Suppose \u0393 \u22a2 \u2206 is not derivable, then by Corollary 4 we have that \u0393 \u22a2 \u2206\nis consistent. We construct a model graph for \u0393 \u22a2 \u2206 using the procedure given\nin Figure 4, and obtain hW f , Rf i. We let hW, Ri be any connected component\nof hW f , Rf i. We now show that hW, Ri satisfies the properties of a model graph\nfrom Definition 25:\n1. \u0393 \u2286 \u0393w0 and \u2206 \u2286 \u2206w0 for some w0 \u2208 W: This holds because w0 is one\nof the saturated sequents obtained from \u0393 \u22a2 \u2206. Moreover, if we delete the\noriginal w0 at Step 2(b)ivA, a final version of w0 is created at Step 2(b)iiiB\nwhich is never deleted.\n2. if \u03c6 \u2192 \u03c8 \u2208 \u2206w then \u2203v \u2208 W with wRv and \u03c6 \u2208 \u0393v and \u03c8 \u2208 \u2206v : This\nholds because we have either created v using (\u2192R ) at Step 2(b)iiiB, or had\nw fulfill the role of this successor by reflexivity if (\u2192R ) was blocked.\n3. if \u03c6\u2212< \u03c8 \u2208 \u0393w then there exists some v \u2208 W with vRw and \u03c6 \u2208 \u0393v and\n\u03c8 \u2208 \u2206v :\nBy symmetry with property 2.\n4. if wRv and \u03c6 \u2192 \u03c8 \u2208 \u0393w then \u03c8 \u2208 \u0393v or \u03c6 \u2208 \u2206v : In our construction, there\nare three ways of obtaining wRv, so we need to show that for each case, the\nproperty holds. We first show that \u03c6 \u2192 \u03c8 \u2208 \u0393v :\n(a) v was created by applying (\u2192R ) to w on some \u03b1 \u2192 \u03b2 \u2208 \u2206w . Then \u0393v\nalso contains \u03c6 \u2192 \u03c8.\n(b) w was created by applying (\u2212< L ) to some \u03b1 \u2212<\u03b2 \u2208 \u0393v . Then, when the\nfinal version of \u0393v was created, \u03c6 \u2192 \u03c8 \u2208 \u0393w was added to the S variable\nat Step 2d. There are two cases:\n\u2013 The right premise \u03c02 of (\u2212< L ) was invoked at v. Then S was added\nto \u03c02 at v by the symmetric process to Step 2(b)ivB. Thus the updated \u0393v also contains \u03c6 \u2192 \u03c8.\n\u2013 The right premise of (\u2212< L ) was not invoked at v. This means that\n\u2203\u03a3j \u2208 S.\u03a3j \u2286 \u0393v , and the j-th version of v's predecessor w is chosen\nat the symmetric process to Step 2(b)iiiA. But since Step 2d at w\nassigns \u03a3j := \u0393w , then we have \u0393w \u2286 \u0393v and thus \u03c6 \u2192 \u03c8 \u2208 \u0393v .\n(c) v = w, and wRw by reflexivity. Then \u0393v = \u0393w , so \u03c6 \u2192 \u03c8 \u2208 \u0393v .\nIn all cases, saturation for v will then ensure that \u03c8 \u2208 \u0393v or \u03c6 \u2208 \u2206v .\n28\n\n\f5. if vRw and \u03c6\u2212<\u03c8 \u2208 \u2206w then \u03c8 \u2208 \u0393v or \u03c6 \u2208 \u2206v :\nBy symmetry with property 4.\n6. if wRv and \u03c6 \u2208 \u0393w then \u03c6 \u2208 \u0393v :\nBy similar argument to property 4.\n7. if vRw and \u03c6 \u2208 \u2206w then \u03c6 \u2208 \u2206v :\nBy symmetry with property 6.\nWe can obtain a counter-model for \u0393\n\nBiInt\n\n\u2206 from hW, Ri via Lemma 12.\n\nDefinition 26. A di-tree is a directed graph such that if the direction of the\nedges is ignored, it is a tree.\nTheorem 4. Every falsifiable BiInt sequent can be falsified by a model whose\nframe is a di-tree, consisting of reflexive points.\nProof. From Lemmas 5 and 6, we know that the construction of new successors\nfor \u03c6 \u2192 \u03c8 and predecessors for \u03c6\u2212< \u03c8 stops when either there are no rejected\n\u03c6 \u2192 \u03c8-formulae or forced \u03c6\u2212< \u03c8-formulae in the current world, or the current\nworld already forces \u03c6 and rejects \u03c8. In the latter case, the world itself fulfills\nthe role of the successor or predecessor by reflexivity, and no new successors or\npredecessors are created.\nThe reason we are able to avoid proper cycles is the persistence and reverse\npersistence properties of BiInt, used in the (\u2192IR ) and (\u2212< IL ) rules.\nConsider the \u2192 case. Every time some \u03c6 \u2192 \u03c8 appears on the RHS of a\nsequent \u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8, we first add \u03c8 to the RHS to obtain \u0393 \u22a2 \u2206, \u03c6 \u2192 \u03c8, \u03c8\nusing the (\u2192IR ) rule, since by reverse persistence the current world must reject\neverything that some successor world rejects. Now that \u03c8 is on the RHS, we\nneed to apply the (\u2192R ) rule to create the \u03c6 \u2192 \u03c8-successor \u0393, \u03c6 \u22a2 \u03c8 only if \u03c6 is\nnot already on the LHS. For if \u03c6 \u2208 LHS, then the successor \u0393 \u22a2 \u03c8 that fulfills\n\u03c6 \u2192 \u03c8 can be the current world itself. So there is no point creating it explicitly.\nCorollary 5. BiInt is characterised by finite rooted reflexive and transitive ditrees of reflexive points.\n\n6\n\nConclusions and Future Work\n\nOur cut-free calculus for BiInt enjoys terminating backward proof-search and\nis sound and complete w.r.t Kripke semantics. A simple Java implementation\nof GBiInt is available at http://users.rsise.anu.edu.au/~linda. The next\nstep is to add a cut rule to GBiInt, and prove cut elimination syntactically.\nWe are also extending our work to the modal logic S5, and the tense logic\nKt.S4. Our approach of existential branching and inter-premise communication\nbears some similarities to hypersequents of Pottinger and Avron [1]. It would\nbe interesting to investigate this correspondence further. From an automated\ndeduction perspective, GBiInt is the first step towards an efficient decision\nprocedure for BiInt. The next task is to analyse the computational complexity\nof GBiInt and investigate which of the traditional optimisations for tableaux\nsystems are still applicable in the intuitionistic case.\nWe would like to thank the anonymous reviewers for their suggestions.\n29\n\n\fReferences\n1. Arnon Avron. The method of hypersequents in the proof theory of propositional\nnon-classical logics. In Wilfrid Hodges, Martin Hyland, Charles Steinhorn, and\nJohn Truss, editors, Logic: from foundations to applications. Proc. Logic Colloquium, Keele, UK, 1993, pages 1\u201332. Oxford University Press, New York, 1996.\n2. T. Crolard. Subtractive logic. Theor. Comp. Sci., 254(1\u20132):151\u2013185, March 2001.\n3. T. Crolard. A formulae-as-types interpretation of Subtractive Logic. Journal of\nLogic and Computation, 14(4):529\u2013570, August 2004.\n4. J. Czermak. A remark on Gentzen's calculus of sequents. Notre Dame Journal of\nFormal Logic, 18(3):471\u2013474, 1977.\n5. A. Dragalin. Mathematical Intuitionism: Introduction to Proof Theory, volume 68\nof Translations of Mathematical Monographs. Cambridge Univ. Press, 1988.\n6. R. Dyckhoff. Contraction-free sequent calculi for intuitionistic logic. The Journal\nof Symbolic Logic, 57(3):795\u2013807, September 1992.\n7. J. H. Gallier. Logic for Computer Science, Foundations of Automated Theorem\nProving. Computer Science and Technology Series. Harper & Row, 1986.\n8. G. Gentzen. Untersuchungen \u00fcber das Logische Schliessen. Mathematische\nZeitschrift, 39:176\u2013210 and 405\u2013431, 1935. English translation in [19].\n9. R. Gor\u00e9. Tableau methods for modal and temporal logics. In D'Agostino at al,\neditor, Handbook of Tableau Methods, pages 297\u2013396. Kluwer, 1999.\n10. A. Heuerding, M. Seyfried, and H. Zimmermann. Efficient loop-check for backward\nproof search in some non-classical propositional logics. In Analytic Tableaux and\nRelated Methods, volume 1071 of LNAI, pages 210\u2013225, 1996.\n11. I. Horrocks, U. Sattler, and S. Tobies. A PSpace-algorithm for deciding ALCN I R+ satisfiability. Technical Report LTCS-98-08, LuFG Theoretical Computer Science,\nRWTH Aachen, 1998.\n12. J. M. Howe. Proof search issues in some non-classical logics. PhD thesis, University\nof St Andrews, 1998.\n13. J. C. C. McKinsey and A. Tarski. On closed elements in closure algebras. Annals\nof Mathematics, 47(1):122\u2013162, 1946.\n14. D. Nelson. Constructible falsity. Journal of Symbolic Logic, 14(2):16\u201326, 1949.\n15. C. Rauszer. A formalization of the propositional calculus of H-B logic. Studia\nLogica, 33:23\u201334, 1974.\n16. C. Rauszer. An algebraic and Kripke-style approach to a certain extension of intuitionistic logic. Dissertationes Mathematicae, 168, 1980. Institute of Mathematics,\nPolish Academy of Sciences.\n17. S. Schwendimann. A new one-pass tableau calculus for PLTL. In Analytic Tableaux\nand Related Methods, volume 1397 of LNAI, pages 277\u2013292, 1998.\n18. V. \u015avejdar. On sequent calculi for intuitionistic propositional logic. Commentationes Mathematicae Universitatis Carolinae, 47(1):159\u2013173, 2006.\n19. M. E. Szabo, editor. The Collected Papers of Gerhard Gentzen. Studies in Logic\nand the foundations of Mathematics. North-Holland, Amsterdam, 1969.\n20. I. Urbas. Dual-intuitionistic logic. Notre Dame Journal of Formal Logic, 37(3):440\u2013\n451, Summer 1996.\n21. T. Uustalu. Personal communication. via email, 2004.\n22. T. Uustalu. Personal communication. via email, 2006.\n23. T. Uustalu and L. Pinto. Days in logic '06 conference abstract. Online at\nhttp://www.mat.uc.pt/~ kahle/dl06/tarmo-uustalu.pdf, accessed on 27th October 2006, 2006.\n\n30\n\n\f24. F. Wolter. On logics with coimplication. Journal of Philosophical Logic, 27(4):353\u2013\n387, 1998.\n\n31\n\n\f"}