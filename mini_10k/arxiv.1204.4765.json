{"id": "http://arxiv.org/abs/1204.4765v1", "guidislink": true, "updated": "2012-04-21T00:36:28Z", "updated_parsed": [2012, 4, 21, 0, 36, 28, 5, 112, 0], "published": "2012-04-21T00:36:28Z", "published_parsed": [2012, 4, 21, 0, 36, 28, 5, 112, 0], "title": "String Trees", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1204.5959%2C1204.4312%2C1204.4553%2C1204.4121%2C1204.5755%2C1204.0964%2C1204.5156%2C1204.1561%2C1204.0824%2C1204.5332%2C1204.2387%2C1204.4084%2C1204.1807%2C1204.1742%2C1204.4725%2C1204.0825%2C1204.1234%2C1204.5764%2C1204.3001%2C1204.0962%2C1204.0860%2C1204.0802%2C1204.2275%2C1204.2262%2C1204.6164%2C1204.0467%2C1204.4693%2C1204.0165%2C1204.4765%2C1204.0510%2C1204.0808%2C1204.2737%2C1204.1934%2C1204.5983%2C1204.0614%2C1204.3832%2C1204.0307%2C1204.1848%2C1204.3723%2C1204.6676%2C1204.3849%2C1204.2553%2C1204.2826%2C1204.3080%2C1204.0728%2C1204.3851%2C1204.5859%2C1204.4304%2C1204.3105%2C1204.2721%2C1204.4833%2C1204.1082%2C1204.2830%2C1204.3288%2C1204.2799%2C1204.0920%2C1204.0631%2C1204.4933%2C1204.2807%2C1204.6566%2C1204.2136%2C1204.4754%2C1204.3990%2C1204.6412%2C1204.5605%2C1204.4410%2C1204.5158%2C1204.5690%2C1204.0901%2C1204.2161%2C1204.0607%2C1204.3255%2C1204.5455%2C1204.4790%2C1204.0215%2C1204.5312%2C1204.5608%2C1204.4952%2C1204.3801%2C1204.0977%2C1204.0617%2C1204.4993%2C1204.2345%2C1204.3372%2C1204.1401%2C1204.2349%2C1204.0720%2C1204.4935%2C1204.6319%2C1204.0397%2C1204.6657%2C1204.2695%2C1204.1710%2C1204.2278%2C1204.5395%2C1204.6647%2C1204.0032%2C1204.1069%2C1204.1774%2C1204.0312%2C1204.3115&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "String Trees"}, "summary": "A string-like compact data structure for unlabelled rooted trees is given\nusing 2n bits.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1204.5959%2C1204.4312%2C1204.4553%2C1204.4121%2C1204.5755%2C1204.0964%2C1204.5156%2C1204.1561%2C1204.0824%2C1204.5332%2C1204.2387%2C1204.4084%2C1204.1807%2C1204.1742%2C1204.4725%2C1204.0825%2C1204.1234%2C1204.5764%2C1204.3001%2C1204.0962%2C1204.0860%2C1204.0802%2C1204.2275%2C1204.2262%2C1204.6164%2C1204.0467%2C1204.4693%2C1204.0165%2C1204.4765%2C1204.0510%2C1204.0808%2C1204.2737%2C1204.1934%2C1204.5983%2C1204.0614%2C1204.3832%2C1204.0307%2C1204.1848%2C1204.3723%2C1204.6676%2C1204.3849%2C1204.2553%2C1204.2826%2C1204.3080%2C1204.0728%2C1204.3851%2C1204.5859%2C1204.4304%2C1204.3105%2C1204.2721%2C1204.4833%2C1204.1082%2C1204.2830%2C1204.3288%2C1204.2799%2C1204.0920%2C1204.0631%2C1204.4933%2C1204.2807%2C1204.6566%2C1204.2136%2C1204.4754%2C1204.3990%2C1204.6412%2C1204.5605%2C1204.4410%2C1204.5158%2C1204.5690%2C1204.0901%2C1204.2161%2C1204.0607%2C1204.3255%2C1204.5455%2C1204.4790%2C1204.0215%2C1204.5312%2C1204.5608%2C1204.4952%2C1204.3801%2C1204.0977%2C1204.0617%2C1204.4993%2C1204.2345%2C1204.3372%2C1204.1401%2C1204.2349%2C1204.0720%2C1204.4935%2C1204.6319%2C1204.0397%2C1204.6657%2C1204.2695%2C1204.1710%2C1204.2278%2C1204.5395%2C1204.6647%2C1204.0032%2C1204.1069%2C1204.1774%2C1204.0312%2C1204.3115&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A string-like compact data structure for unlabelled rooted trees is given\nusing 2n bits."}, "authors": ["Julius D'souza"], "author_detail": {"name": "Julius D'souza"}, "author": "Julius D'souza", "arxiv_comment": "5 pages", "links": [{"href": "http://arxiv.org/abs/1204.4765v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1204.4765v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "E.1; G.2.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1204.4765v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1204.4765v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:1204.4765v1 [cs.DS] 21 Apr 2012\n\nString trees\nJulius D'souza\ncyrrhic@ufl.edu\nDepartment of Electrical and Computer Engineering\nUniversity of Florida\nAbstract\nA string-like compact data structure for unlabelled rooted trees is\ngiven using 2n bits.\n\nIntroduction\nClassically, the tree data structure is a dynamic version of the labelled tree\nin graph theory: each node points to parent or child nodes, and adding or\nremoving nodes from a tree is equivalent to manipulating pointers of appropriate nodes. This structural interpretation of the graph-theoretic tree\nrequires O(n log n) space since there are nn\u22122 trees with n nodes. The number of labelled trees with n nodes is given by Cayley's formula which can be\ntraced back to Borchardt [1]. Enumerating the number of unlabelled trees,\nhowever, has proven to be rather difficult. No closed formulae are presently\nknown, and aside from the discovery of the Redfield-Polya Theorem, little\nprogress on this enumeration problem was made until Otter's work in 1948.\nOtter[2] provides an asymtotic estimate for unlabelled rooted trees: given\nn nodes, there are A\u03b1n n\u22125/2 such trees where A \u2248 0.4399 and \u03b1 \u2248 2.996.\nHence, the space S(n) needed to represent an n-node unlabelled tree is:\nS(n) = log(A) + n * log(\u03b1) \u2212\n\n5\n* log(n),\n2\n\n= O(n).\nSpecifically, S(n) \u2248 n log(\u03b1). Since \u03b1 \u2248 2.996, a per-node representation\nusing an integer alphabet requires log d\u03b1e = log(3) bits per tree node. The\nrest of this work describes a data structure using 2 bits per node, or a 4-letter\nalphabet.\n1\n\n\fTree Linearization\nConsider the children C of a tree node t with some total ordering c1 \u2264 c2 \u2264\n* * * \u2264 cn , ci \u2208 C. Each x \u2208 C either has children of its own or has none, and\nx is either the last child of t, i.e. x = min C, or is not. These two facts alone\nsuffice in producing a node-based encoding for trees. Consider the following\nalphabet and semantics:\nx \u2192 The\ny \u2192 The\nX \u2192 The\nY \u2192 The\n\nnode\nnode\nnode\nnode\n\nhas\nhas\nhas\nhas\n\nno children and is not its parent's last child.\nchildren and is not its parent's last child.\nno children and is its parent's last child.\nchildren and is its parent's last child.\n\nFor notational purposes and consistency, the root node is ascribed the\nletter Y . The alphabet {x, y, X, Y } with the semantics just given completely\ndescribes the parent-child relation. Since breadth-first traversal creates a total ordering over the children of each parent node, it is combinatory with the\ngiven encoding in capturing the structure of unlabelled trees. For illustration, a level-order walk is performed on the tree T illustrated in breadth-first\ntraversal order in Figure 1 in deriving its equivalent string-tree form; refer to\nFigure 2 for an illustration of the nodal linearization performed during the\nwalk. Thus follows the walk:\n\nfirst\nsecond\nthird\nfourth\nfifth\nsixth\n\nlevel \u2192 Y,\nlevel \u2192 xyY,\nlevel \u2192 XyX,\nlevel \u2192 Y,\nlevel \u2192 xyY,\nlevel \u2192 xXxxX.\n\nConcatenation gives the string tree form of T : \"YxyYXyXYxyYxXxxX\"\n- or at least the string tree form of T with respect to breadth-first traversal\nis given. Other forms of ordered tree traversal, such as depth-first traversal,\nare employable.\n\n2\n\n\fFigure 1: The tree T\n\nFigure 2: Linearization of the tree T\n\n3\n\n\fFormalizing the described procedure, the following unlabelled encoding\nalgorithm follows:\nInput: a labelled tree T\nOutput: an unlabelled breath-first representation of T in a string S\n1. Set S to the string \"Y\".\n2. Create a list L of the nodes of T in breadth-first traversal order excluding the root node.\n3. Iterate over L, adding the following characters to S:\n\u2022 x if the node has no children and is not the last of its parent's\nchildren\n\u2022 y if the node has children and is not the last of its parent's children\n\u2022 X if the node has no children and is the last of its parent's children\n\u2022 Y if the node has children and is the last of its parent's children\n4. Return S.\nLet strings be treated as arrays that start at 0. The following algorithm\nproduces the labelled tree form from an unlabelled representation:\nInput: an unlabelled breath-first representation of T in a string S with length\nn\nOutput: a labelled tree T\n1. Create a root node for T labelled 0.\n2. If S has multiple characters, set the counters i to 1; otherwise, end.\n3. Create two empty stacks A and B, and push 0 to A.\n4. While A is not empty:\n(a) Create a node n with the label of the current value of i.\n(b) Declare n as the child of the last pushed value in A in the tree T .\n(c) If S[i] is \"y\" or \"Y\", push i to B; if S[i] is \"X\" or \"Y\", pop A.\n(d) i \u2190 i + 1.\n5. Swap A and B.\n6. If i equals n, return T ; otherwise, return to step 4.\n4\n\n\fConcluding Remarks\nThe string tree provides a tradeoff against its labelled cousins: though most\nclassical tree operations require O(n) time for the string tree, string operations are readily available for tree manipulation: i.e., concatenation, substring search, and most interestingly string replacement. Furthermore, the\nplethora of edit distance metrics for strings, i.e. Levenshtein distance, are\nusable in determining tree similarity.\nThe string tree alphabet trivially forms a regular language, so regular\nexpressions can be executed directly on a tree structure. As an example,\nthe operation s/(x)*X/X/ kills every node but the last child of a node with\nno grandchildren on a breadth-first string tree. Regular expression semantics\nwould naturally vary with the type of tree traversal used in forming the string\ntree.\n\n5\n\n\fWork Cited\nBorchardt, C.W. (1860). \"\u00dcber eine Interpolationsformel f\u00fcr eine Art Symmetrischer Functionen und \u00fcber Deren Anwendung\". Math. Abh. der\nAkademie der Wissenschaften zu Berlin: 1-20.\nOtter, Richard (1948), \"The Number of Trees\", Annals of Mathematics, Second Series 49 (3): 583-599\n\n6\n\n\f"}