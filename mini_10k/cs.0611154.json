{"id": "http://arxiv.org/abs/cs/0611154v2", "guidislink": true, "updated": "2007-03-02T12:50:34Z", "updated_parsed": [2007, 3, 2, 12, 50, 34, 4, 61, 0], "published": "2006-11-29T16:57:41Z", "published_parsed": [2006, 11, 29, 16, 57, 41, 2, 333, 0], "title": "Assessing the cognitive consequences of the object-oriented approach: a\n  survey of empirical research on object-oriented design by individuals and\n  teams", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0006043%2Ccs%2F0006021%2Ccs%2F0006006%2Ccs%2F0006028%2Ccs%2F0006013%2Ccs%2F0006012%2Ccs%2F0006042%2Ccs%2F0006033%2Ccs%2F0006038%2Ccs%2F0006009%2Ccs%2F0006037%2Ccs%2F0006016%2Ccs%2F0006041%2Ccs%2F0006015%2Ccs%2F0006039%2Ccs%2F0006047%2Ccs%2F0006029%2Ccs%2F0006044%2Ccs%2F0006003%2Ccs%2F0611055%2Ccs%2F0611144%2Ccs%2F0611090%2Ccs%2F0611051%2Ccs%2F0611021%2Ccs%2F0611078%2Ccs%2F0611061%2Ccs%2F0611156%2Ccs%2F0611085%2Ccs%2F0611044%2Ccs%2F0611149%2Ccs%2F0611052%2Ccs%2F0611066%2Ccs%2F0611064%2Ccs%2F0611092%2Ccs%2F0611060%2Ccs%2F0611095%2Ccs%2F0611026%2Ccs%2F0611079%2Ccs%2F0611001%2Ccs%2F0611150%2Ccs%2F0611080%2Ccs%2F0611081%2Ccs%2F0611025%2Ccs%2F0611007%2Ccs%2F0611137%2Ccs%2F0611027%2Ccs%2F0611134%2Ccs%2F0611048%2Ccs%2F0611121%2Ccs%2F0611154%2Ccs%2F0611022%2Ccs%2F0611038%2Ccs%2F0611097%2Ccs%2F0611113%2Ccs%2F0611152%2Ccs%2F0611133%2Ccs%2F0611120%2Ccs%2F0611029%2Ccs%2F0611063%2Ccs%2F0611014%2Ccs%2F0611086%2Ccs%2F0611083%2Ccs%2F0611106%2Ccs%2F0611004%2Ccs%2F0611076%2Ccs%2F0611088%2Ccs%2F0611124%2Ccs%2F0611035%2Ccs%2F0611148%2Ccs%2F0611009%2Ccs%2F0611122%2Ccs%2F0611037%2Ccs%2F0611050%2Ccs%2F0611040%2Ccs%2F0611068%2Ccs%2F0611023%2Ccs%2F0611075%2Ccs%2F0611111%2Ccs%2F0611057%2Ccs%2F0611039%2Ccs%2F0611049%2Ccs%2F0611077%2Ccs%2F0611129%2Ccs%2F0611030%2Ccs%2F0611108%2Ccs%2F0611045%2Ccs%2F0611042%2Ccs%2F0611017%2Ccs%2F0611036%2Ccs%2F0611058%2Ccs%2F0611008%2Ccs%2F0611112%2Ccs%2F0611018%2Ccs%2F0611104%2Ccs%2F0611011%2Ccs%2F0611094%2Ccs%2F0611141%2Ccs%2F0611006%2Ccs%2F0611065%2Ccs%2F0611015%2Ccs%2F0611091&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Assessing the cognitive consequences of the object-oriented approach: a\n  survey of empirical research on object-oriented design by individuals and\n  teams"}, "summary": "This paper presents a state-of-art review of empirical research on\nobject-oriented (OO) design. Many claims about the cognitive benefits of the OO\nparadigm have been made by its advocates. These claims concern the ease of\ndesigning and reusing software at the individual level as well as the benefits\nof this paradigm at the team level. Since these claims are cognitive in nature,\nits seems important to assess them empirically. After a brief presentation of\nthe main concepts of the OO paradigm, the claims about the superiority of OO\ndesign are outlined. The core of this paper consists of a review of empirical\nstudies of OOD. We first discuss results concerning OOD by individuals. On the\nbasis of empirical work, we (1) analyse the design activity of novice OO\ndesigners, (2) compare OO design with procedural design and, (3) discuss a\ntypology of problems relevant for the OO approach. Then we assess the claims\nabout naturalness and ease of OO design. The next part discusses results on OO\nsoftware reuse. On the basis of empirical work, we (1) compare reuse in the OO\nversus procedural paradigm, (2) discuss the potential for OO software reuse and\n(3) analyse reuse activity in the OO paradigm. Then we assess claims on\nreusability. The final part reviews empirical work on OO design by teams. We\npresent results on communication, coordination, knowledge dissemination and\ninteractions with clients. Then we assess claims about OOD at the software\ndesign team level. In a general conclusion, we discuss the limitations of these\nstudies and give some directions for future research.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0006043%2Ccs%2F0006021%2Ccs%2F0006006%2Ccs%2F0006028%2Ccs%2F0006013%2Ccs%2F0006012%2Ccs%2F0006042%2Ccs%2F0006033%2Ccs%2F0006038%2Ccs%2F0006009%2Ccs%2F0006037%2Ccs%2F0006016%2Ccs%2F0006041%2Ccs%2F0006015%2Ccs%2F0006039%2Ccs%2F0006047%2Ccs%2F0006029%2Ccs%2F0006044%2Ccs%2F0006003%2Ccs%2F0611055%2Ccs%2F0611144%2Ccs%2F0611090%2Ccs%2F0611051%2Ccs%2F0611021%2Ccs%2F0611078%2Ccs%2F0611061%2Ccs%2F0611156%2Ccs%2F0611085%2Ccs%2F0611044%2Ccs%2F0611149%2Ccs%2F0611052%2Ccs%2F0611066%2Ccs%2F0611064%2Ccs%2F0611092%2Ccs%2F0611060%2Ccs%2F0611095%2Ccs%2F0611026%2Ccs%2F0611079%2Ccs%2F0611001%2Ccs%2F0611150%2Ccs%2F0611080%2Ccs%2F0611081%2Ccs%2F0611025%2Ccs%2F0611007%2Ccs%2F0611137%2Ccs%2F0611027%2Ccs%2F0611134%2Ccs%2F0611048%2Ccs%2F0611121%2Ccs%2F0611154%2Ccs%2F0611022%2Ccs%2F0611038%2Ccs%2F0611097%2Ccs%2F0611113%2Ccs%2F0611152%2Ccs%2F0611133%2Ccs%2F0611120%2Ccs%2F0611029%2Ccs%2F0611063%2Ccs%2F0611014%2Ccs%2F0611086%2Ccs%2F0611083%2Ccs%2F0611106%2Ccs%2F0611004%2Ccs%2F0611076%2Ccs%2F0611088%2Ccs%2F0611124%2Ccs%2F0611035%2Ccs%2F0611148%2Ccs%2F0611009%2Ccs%2F0611122%2Ccs%2F0611037%2Ccs%2F0611050%2Ccs%2F0611040%2Ccs%2F0611068%2Ccs%2F0611023%2Ccs%2F0611075%2Ccs%2F0611111%2Ccs%2F0611057%2Ccs%2F0611039%2Ccs%2F0611049%2Ccs%2F0611077%2Ccs%2F0611129%2Ccs%2F0611030%2Ccs%2F0611108%2Ccs%2F0611045%2Ccs%2F0611042%2Ccs%2F0611017%2Ccs%2F0611036%2Ccs%2F0611058%2Ccs%2F0611008%2Ccs%2F0611112%2Ccs%2F0611018%2Ccs%2F0611104%2Ccs%2F0611011%2Ccs%2F0611094%2Ccs%2F0611141%2Ccs%2F0611006%2Ccs%2F0611065%2Ccs%2F0611015%2Ccs%2F0611091&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "This paper presents a state-of-art review of empirical research on\nobject-oriented (OO) design. Many claims about the cognitive benefits of the OO\nparadigm have been made by its advocates. These claims concern the ease of\ndesigning and reusing software at the individual level as well as the benefits\nof this paradigm at the team level. Since these claims are cognitive in nature,\nits seems important to assess them empirically. After a brief presentation of\nthe main concepts of the OO paradigm, the claims about the superiority of OO\ndesign are outlined. The core of this paper consists of a review of empirical\nstudies of OOD. We first discuss results concerning OOD by individuals. On the\nbasis of empirical work, we (1) analyse the design activity of novice OO\ndesigners, (2) compare OO design with procedural design and, (3) discuss a\ntypology of problems relevant for the OO approach. Then we assess the claims\nabout naturalness and ease of OO design. The next part discusses results on OO\nsoftware reuse. On the basis of empirical work, we (1) compare reuse in the OO\nversus procedural paradigm, (2) discuss the potential for OO software reuse and\n(3) analyse reuse activity in the OO paradigm. Then we assess claims on\nreusability. The final part reviews empirical work on OO design by teams. We\npresent results on communication, coordination, knowledge dissemination and\ninteractions with clients. Then we assess claims about OOD at the software\ndesign team level. In a general conclusion, we discuss the limitations of these\nstudies and give some directions for future research."}, "authors": ["Fran\u00e7oise D\u00e9tienne"], "author_detail": {"name": "Fran\u00e7oise D\u00e9tienne"}, "author": "Fran\u00e7oise D\u00e9tienne", "links": [{"href": "http://arxiv.org/abs/cs/0611154v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0611154v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.HC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.HC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0611154v2", "affiliation": "INRIA", "arxiv_url": "http://arxiv.org/abs/cs/0611154v2", "arxiv_comment": null, "journal_reference": "Interacting with Computers 9 (1997) 47-72", "doi": null, "fulltext": "Published in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n\nAssessing the cognitive consequences of the object-oriented approach: a survey of empirical\nresearch on object-oriented design by individuals and teams\n\nFran\u00e7oise D\u00e9tienne\nErgonomic Psychology Project\nINRIA\nDomaine de Voluceau,\nRocquencourt, BP 105\n78153, Le Chesnay Cedex\nFrance\nFrancoise.Detienne@inria.fr\n\nAbstract\n\nThis paper presents a state-of-art review of empirical research on object-oriented (OO) design. Many\nclaims about the cognitive benefits of the OO paradigm have been made by its advocates. These claims\nconcern the ease of designing and reusing software at the individual level as well as the benefits of this\nparadigm at the team level. Since these claims are cognitive in nature, its seems important to assess them\nempirically. After a brief presentation of the main concepts of the OO paradigm, the claims about the\nsuperiority of OO design are outlined.\n\n1\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nThe core of this paper consists of a review of empirical studies of OOD. We first discuss results\nconcerning OOD by individuals. On the basis of empirical work, we (1) analyse the design activity of\nnovice OO designers, (2) compare OO design with procedural design and, (3) discuss a typology of\nproblems relevant for the OO approach. Then we assess the claims about naturalness and ease of OO\ndesign.\nThe next part discusses results on OO software reuse. On the basis of empirical work, we (1) compare\nreuse in the OO versus procedural paradigm, (2) discuss the potential for OO software reuse and (3)\nanalyse reuse activity in the OO paradigm. Then we assess claims on reusability.\nThe final part reviews empirical work on OO design by teams. We present results on communication,\ncoordination, knowledge dissemination and interactions with clients. Then we assess claims about OOD\nat the software design team level.\nIn a general conclusion, we discuss the limitations of these studies and give some directions for future\nresearch.\n\n2\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n1.\n\nIntroduction\n\n2.\n\nConcepts of the OO paradigm\n\n3.\n3.1\n3.2\n3.3\n\nClaims about the benefits of the OO paradigm\nClaims about naturalness and ease of OO design\nClaims about reusability\nClaims about OOD at the software design team level\n\n4.\nOO design by individuals\n4.1\nDesign activity of novice OO designers\n4.1.1 Difficulties in the process of classes creation\n4.1.2 Difficulties in articulating declarative and procedural aspects of the solution\n4.1.3 Misconceptions\n4.1.4 Transfer when shifting from traditional design to OO design\n4.2\nComparing OO design with procedural design\n4.2.1 Easiness of mapping between the problem space and the design solution space\n4.2.2 Design strategies\n4.2.3 Organisation of the design activity\n4.3\nToward a typology of problems for OOD\n4.4\nAssessing claims about naturalness and ease of OOD\n5.\n5.1\n5.2\n5.3\n5.3.1\n5.3.2\n5.3.3\n5.4\n\nOO software reuse\nReuse in the OO versus procedural paradigms\nPotential of OO software reuse\nReuse activity\nCognitive typology of reuse processes\nEnrichment of the representation versus lowering of the level of control of the activity\nImportance of example and context\nAssessing claims about OO software reusability\n\n6.\n6.1\n6.2\n6.3\n6.4\n\nOO design by teams\nCommunication and coordination\nKnowledge dissemination\nInteractions with clients\nAssessing claims about OOD in design teams\n\n7.\n\nLimitations and directions for future work\nReferences\n\n3\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n1.\n\nIntroduction\n\nThis paper presents a state-of-art review of empirical research on object-oriented (OO) design. OO\ntechnology has been accepted by both academia and industry in a very short time. Ten years ago,\nthe few OO languages available were seen as interesting ideas. Since then, new languages have been\ndesigned and existing languages have been extended to become object-oriented. Many claims about\nthe cognitive benefits of the OO paradigm have been made by its advocates. These claims concern\nthe ease of designing and reusing software at the individual level as well as the benefits of this\nparadigm at the team level. Given the rapid acceptance of this new technology, it is imperative to\nunderstand the process and to evaluate the benefits of OO design. Since these claims are cognitive\nin nature, its seems important to assess them empirically (D\u00e9tienne & Rist, 1995).\nSince 1990, much empirical work has been conducted on OO design both at the individual level\nand at the software design team level. These studies are field studies and laboratory studies. They\nare mostly focused on upstream activities, e.g., design, analysis, and communication, rather than\non downstream activities, e.g., coding. This paper will present an overview of the results of these\nstudies. After a brief presentation of the main concepts of the OO paradigm, the claims about the\nsuperiority of OO design are outlined.\nThe core of this paper consists of a review of empirical studies of OOD. In section 4, we present\nresults on OO design by individuals. On the basis of empirical work, we (1) analyse the design\nactivity of novice OO designers, (2) compare OO design with procedural design and, (3) discuss a\ntypology of problems relevant for the OO approach. In a final section we assess the claims on\nnaturalness and ease of use of OO design.\nSection 5 discusses results on OO software reuse. On the basis of empirical work, we (1) compare\nreuse in the OO versus procedural paradigm, (2) discuss the potential for OO software reuse and (3)\nanalyse reuse activity in the OO paradigm. In a final section, we assess claims on reusability.\n\n4\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nSection 6 reviews empirical work on OO design of teams. We present results on communication,\ncoordination, knowledge dissemination and interactions with clients. In a final section, we assess\nclaims about OOD at the software design team level.\nIn a general conclusion, we discuss the limitations of these studies and give some directions for\nfuture research.\n2.\n\nConcepts of the OO paradigm\n\nThe main concepts of the OO paradigm are the concepts of class, inheritance, and encapsulation. A\nkey difference between the object-oriented paradigm and the procedural paradigm is that in the\nprocedural paradigm data and functions are separated, whereas in the object-oriented paradigm they\nare integrated. Objects are program entities which integrate a structure defined by a type and\nfunctionalities. The concept of class integrates both the structure and behaviour of objects. Objects\nare instances of classes. Attributes and methods are defined for the entire class. A class is defined as\na structure (a type) and a set of methods. A method is a function attached to a class that describes a\npart of the behaviour of the objects which are instances of this class.\nUsing inheritance, a hierarchy of classes can be constructed in which the most general attributes and\nmethods are specified in the higher level classes and are inherited by more specialised classes,\nIn OO programming, abstraction is obtained by the means of encapsulation, polymorphism and late\nbinding. Encapsulation means an object owns its data and methods. The data and methods are\nprivate and may be accessed and used by other objects only if the other objects send an appropriate\nmessage to the owner. The using object may send the same message to multiple objects which will\nact on it differently according to their own interpretations. This is the property of polymorphism,\nwhich aids abstraction by allowing messages to remain abstract. It is only during execution that the\nsystem decides which method will be executed according to the object with which the method is\ncalled. This is the property of late binding.\n\n5\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nAccording to Rist (Rist, 1994; Rist, 1996; Rist & Terwilliger, 1995), plans and objects are\northogonal in OO systems. This reflects the real world, where a plan can use many objects (the plan\nfor a cake uses flour, eggs, water, and so on), and an object can be used in many plans (an egg can\nbe used to make a cake, omelette, souffl\u00e9 and so on). A plan is a set of actions that, when placed in\na correct order, achieve some desired goal. In an OO system, the actions in a plan are encapsulated\nin a set of routines, and the routines are divided among a set of classes and connected by control\nflow.\n3.\n\nClaims about the benefits of the OO paradigm\n\nAdvocates of OO design have made strong claims about the naturalness, ease of use, and power of\nthis design approach (see for example: Meyer, 1988; Rosson and Alpert, 1990). Claims are also\nmade about reusability, and benefits at the software design team level.\n3.1\n\nClaims about naturalness and ease of OO design\n\nIt is claimed that mapping between the problem domain and the programming domain should be\nmore straightforward in the OO paradigm than in the procedural paradigm. The theoretical argument\nin support of OO design is that objects are clear and visible entities in the problem domain. They\nare represented as explicit entities in the solution domain, and thus the mapping between the\nproblem and solution domains is simple and clear. The domain objects are identified and used to\nstructure the software system. As a result, the OO paradigm should entail a greater focus on the\nproblem. It should facilitate object-based problem decomposition as well as object-based design\nsolutions.\nConcerning problem understanding, it is assumed that the identification of objects (or classes, as\nobjects are the instances of classes) should be easy because objects form natural representations of\nproblem entities. According to Meyer (1988), the world can be naturally structured in terms of\nobjects; thus, it seems particularly relevant to organise a model of design around a software\nrepresentation of these objects.\n\n6\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nWith an OOP language, decomposing the problem into a solution consists of identifying the\nrelations between objects and the associations between their structures and the functionalities. It is\nassumed that decomposing a problem into objects is natural. This activity is assumed to be driven\nmuch more by a designer's knowledge about world structure than by knowledge about the design\nprocess or about particular software domains. Rosson and Alpert (1990) suggest that OO may be\nespecially valuable in new domains or when practiced by relatively experienced designers. In\ncontrast, in the procedural paradigm problem decomposition is driven by generic programming\nconstructs and specialised design knowledge. In terms of the concepts of problem and solution\nspaces introduced by Kant and Newell (1984), this implies that reasoning in the problem space is\nseparate from reasoning in the software solution space; the objects are considered, but remain\nimplicit.\n3.2\n\nClaims about reusability\n\nIt has been asserted that the OO paradigm promotes reuse of software because the code is\nencapsulated into objects and the internal details of each object are hidden. The claim about reuse\nrests on an argument that the hierarchies which form the model of classes are well-suited for reuse\n(Johnson and Foote, 1988). The programmer needs only to adopt a hierarchy appropriate for the\ndomain of the problem, and then provide the specialisation needed for a particular problem by\nadding new low-level classes. Thus, much of the needed structure and functionality already present\nin the higher levels of the class hierarchy is automatically reused by inheritance.\n3.3\n\nClaims about OOD at the software design team level\n\nAdvocates of OOD assert that the OO paradigm helps to overcome problems encountered at the\nsoftware design team level, compared to traditional paradigms. These problems concern\ncommunication, coordination, and the capture and use of application (or problem) domain\nknowledge (Krasner, Curtis and Iscoe, 1987; Curtis and Walz, 1990; Herbsleb & Kuwana, 1993).\n\n7\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nCommunication and coordination is enhanced because a single representation, based on the problem\ndomain, underlies all stages of development. Also, communication between designers and clients\nshould be facilitated because the solution is structured around the application domain objects, and\nis thus easily understood by specialists in the domain (Herbsleb, Klein, Olson, Brunner, Olson &\nHarding, 1995). OO design should also help to propagate application domain knowledge through\nthe design team, because the shared representation has its basis in the concepts and vocabulary of\nthe application domain.\n4.\n\nOO design by individuals\n\nIn this section, we present results of empirical studies of the design activity of individuals. First\nwe present results concerning OO novices. Then we analyse the design activity of OO experts and\nmake a comparison between paradigms. This is followed by a discussion of a typology of problems\nfor OO design. In the final section, we assess empirically the claims about naturalness and ease of\nOO design.\n4.1\n\nDesign activity of novice OO designers\n\nFirst, it should be remarked that, in all the empirical studies of novice OO designers, as far as we\nknow, participants had previous experience with the procedural paradigm1. Therefore the claims\nabout naturalness of OO design are still to be assessed for real novices. We will see in this section\nthat the previous experience in procedural paradigm causes interference when learning an OOP\nlanguage.\n4.1.1 Difficulties in the process of classes creation\n\nEmpirical studies show that novice OO designers tend to identify first domain entities, then\nclasses, and then methods. They follow a method learned in their programming courses. They seem\n\n1 In Rist's study (1996), two subjects started programming by learning an OOP language. However, the\n\nanalysis was not focused on the specificities of these subjects' activity. In one of the experiments\nconducted by Chatel (1997), several subjects were real novices. Some preliminary results will be reported\nin 4.1.1.\n\n8\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nto hope that the classes created in this way will be useful later on (Lee & Pennington, 1994;\nPennington, Lee & Rehder, 1995)\nNovices behave this way not just because they follow a method learned in class but also because of\nenvironment constraints, i.e., order constraints which entail premature commitment (Green, 1989).\nAlthough this last aspect could not be illustrated in Pennington study, as the novices used only\npen and paper, it was illustrated in D\u00e9tienne's study (1995) in which programmers used an OO\nenvironment, the CO2 system. It was observed that the novices, like the experts, tried to define the\nclass model before they implemented the methods in detail. This behaviour was driven by specific\ncharacteristics of the version of the CO2 system which was assessed. It was not possible to use an\nobject in a method body if this object had not been completely specified beforehand. The results\nshowed that all classes created in the earliest stage of design were not useful later on. Revisions\nsuch as deletion and addition of classes were made later on.\nSeveral studies (D\u00e9tienne, 1990a; 1990b; 1995; Lee & Pennington, 1994; Pennington, Lee &\nRehder, 1995) attest of the difficulties encountered by novices in the process of class creation. In\nPennington et al.'s study, it was found that novices spent a considerable amount of time creating\nand abandoning domain entities before they actually started defining the design objects. The\nactivity of finding classes of objects consumed novices' attention, and they gave no attention to\nfunctionality until late in the design activity. In fact, novices delayed consideration of goals and the\ndefinition of methods until late in the design. The same process of creating and abandoning classes\nwas observed in D\u00e9tienne's studies.\nChatel (1997) observed that real novices, without previous experience in another programming\nparadigm, delayed consideration of goals. They start by creating classes with some typical\nfunctions associated to each class. This suggests that structural schemas representing typical\nfunctions or roles associated to classes are acquired relatively early in the acquisition process. This\nresults is similar with what was found in procedural design (Rist, 1989). However, Chatel also\nshows that novices spend much time defining and revising classes.\n\n9\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n4.1.2 Difficulties in articulating declarative and procedural aspects of the solution\n\nOne of the main difficulties experienced by novices is the articulation between declarative and\nprocedural aspects of the solution, e.g., the hierarchy of classes and the main procedure (D\u00e9tienne,\n1990a; 1990b; 1995). Based on knowledge in the problem domain, novices identify the structural\nproperties and organisation of classes. Based on knowledge in the programming domain, they\nidentify procedural aspects of the solution. As a first step, they often construct a procedure to deal\nwith the main goal (a complex plan) as well as procedures for performing typical roles (simple\nplans), e.g., initialisation. The complex plan represents a large procedure, not necessarily expressed\nat the code level yet, and not yet decomposed into individual functions which could be associated\nto classes.\nAt this phase in the design process, there is only slight integration between the declarative and the\nprocedural aspects of the solution. Our results (D\u00e9tienne, 1995) tend to show that novice OO\ndesigners describe objects and actions separately in their first draft of the solution more often than\ndo experienced OO designers, especially for a declarative problem. Associating declarative and\nprocedural aspects implies decomposing the large procedure into smaller functional units. However,\nsome novices do not do so. Instead, they associate the procedure as a whole to a single class\n(D\u00e9tienne, 1990b).\nWhen decomposing the procedure into functional units and associating them to classes, the\ndecomposition process follows either a procedure-centred strategy or a function-centred strategy.\nThis process was analysed, in our study (D\u00e9tienne, 1995), by identifying the relationship between\nmethods defined sequentially. It was found that for novice OO designers methods are defined both\nfollowing their execution order (i.e. a procedure-centred strategy) and according to their functional\nsimilarity (i.e. a function-centred strategy) regardless of the objects to which they are associated. It\nis striking that in both cases objects are secondary entities to be associated with procedure units or\nfunctions.\n\n10\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nWhen they refine the functions by writing the code of methods, novice OO designers are able to\nrefine some characteristics of the structure of objects already defined at higher levels of abstraction,\ne.g., they add attributes in a class or add parameters in a method signature. However, they also\nmake more drastic changes to the declarative model. They add new classes and new methods and\nmove methods from one class to another. Not surprisingly, more modifications are made by novice\nOO designers than by experienced OO designers. Whereas this difference is not significant when we\nconsider the total number of modification, it is significant when we consider only the methods\nmodifications, e.g., adding/modifying/removing a method and moving a method from one class to\nanother (D\u00e9tienne, 1995). These modifications concern the definition of a complex plan and the\nassociation of parts of this plan with objects.\nThis result exhibits the difficulties novices OO designers encounter in associating objects with\nprocedures. The lack of appropriate knowledge in OOP and the transfer of inappropriate plans from\nprocedural languages does not allow the construction of a correct complex plan and the allocation of\nactions of this plan among classes. When they construct a more detailed representation of the\nprocedure (developed in the procedural part), they revise the static aspects of the global solution,\ni.e., parts composing a complex plan or the association between the actions of this plan and the\nobjects. This suggests that constructing a representation of some procedural aspects of the solution\nprecedes the construction of more declarative aspects of the solution, e.g., the objects. This result\nprovides support to the hypothesis made in cognitive ergonomic, that: (1) knowledge is organised\non the basis of goals and procedures and not on the basis of relational properties of the objects and,\n(2) the procedures are properties of objects and they form the basis for objects categorisation\n(Richard, 1996).\nNovices compile their programs frequently (D\u00e9tienne, 1993). They tend to write pieces of code\ncorresponding to one or several methods then compile immediatly. Thus, they use a generate/test\nand debug strategy, the evaluated units being one method or several methods.\n4.1.3 Misconceptions\n\n11\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nNovices OO designers have misconceptions about some fundamental OO concepts (D\u00e9tienne,\n1990a; 1990b), in particular the class concept and the inheritance property. Novices OO designers\ntend to conceive a class as a set of objects. Therefore, they attribute set properties to the class\nconcept. This misconception is revealed by errors of novices. For example, when they define a\nfunction which processes a set of objects of classX, they place this function in classX instead of\ncreating a classY whose type would be \"set of objects of the classX\" and placing the function in\nclassY.\nNovices tend to think that instances of classes are created by default. This misconception is also\nrevealed by errors. Novices tend to use instances of classes without creating them beforehand. This\ntype of error is similar to forgetting to initialise variables in the procedural paradigm. Initialising a\nvariable or creating an object is a type of prerequisite which is not necessary in the world situation\nand so is not part of the knowledge transferred from the real world. In general, the novice learns by\nanalogy between the real world source situation and the OO target situation. However, here there are\npreconditions to be satisfied in the target situation which are automatically2 satisfied in the source\nsituation (Hoc & Nguyen, 1990).\nNovices have also misconceptions about inheritance. They try to use this property as often as they\ncan, and they often do it inappropriately. In particular, they tend to use the abstraction hierarchy to\nexpress a composition. There are two aspects of inheritance: the inheritance of static characteristics\nof a class, i.e., the type of the class, and the inheritance of functional characteristics, i.e., the\nmethods of a class. Our observations tend to show that, while novices have difficulties in using the\ninheritance property of static characteristics, as shown in the misconception explained before, they\nhave even more difficulties in using the inheritance of functionality.\n4.1.4 Transfer when shifting from traditional design to OO design\n\n2 In the real world, objects are usually created beforehand by somebody else. When using an object a\n\nperson does not have to worry about creating it.\n\n12\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nTransfer effects between languages and design approaches have been well documented for procedural\nprogrammers learning another procedural/functional language or a declarative language (Siddiqi,\nOsborne, Roast & Khazaei, 1996; Scholtz & Wiedenbeck, 1990, 1993; Wu & Anderson, 1991).\nFor OOD, it has been claimed that previous knowledge of the problem domain should help in\nanalyzing the problem and decomposing and structuring the solution. However, most beginners in\nOO design have previous experience with other design approaches such as procedural design, and\nthere is strong evidence of knowledge transfer not only from the problem domain but also from\nother languages and from other design approaches. Thus, one issue of concern is the transfer of\nknowledge from traditional design and the effect of this transfer when shifting from traditional\ndesign to OO design. Some studies have dealt with this transfer issue (D\u00e9tienne, 1990a; 1990b;\n1995; Pennington, Lee & Rehder, 1995) and also with the assessment of various transfer indicators\n(Chatel, D\u00e9tienne & Borne, 1992).\nIt has been shown that novices OO designers transfer knowledge from non-OO\n\ndesign\n\nmethodologies. For example, in one of our own studies (D\u00e9tienne, 1990a; 1990b), we observed\nthat a novice OO designer with previous experience in procedural programming used attributes of\ntype \"number\" in each class to link together objects, instead of using the is-part-of relationship.\nFrom the verbal protocol, it was evident that this subject constructed a solution using elements of a\nrelational approach to data base management. According to this methodology, different objects have\na number which is used as a cue to link together objects and to facilitate the search in a data base.\nEvoking this schematic knowledge, the subject added an attribute of type \"number\" to each class he\nhad constructed previously. Then he constructed a kind of \"flat\" structure of classes, without using\nthe \"is-part-of\" relationship to link together classes. Obviously the solution produced by this\nsubject did not conform to principles of OOP.\nOther evidence of transfer from procedural languages and design is provided by Pennington et al.\n(1995). They observed that OO novices retain a few procedural features in their design, such as the\nuse of input/output objects that were extensively interconnected to every other object in the design.\nIn one of our own studies (D\u00e9tienne, 1990a; 1990b), we also observed such transfer effects. For\n\n13\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nexample, a novice OO designer added a parameter \"type of object\" in a class which allowed him to\ndo different processing (method calls) according to the value taken by this parameter in a\"case of\"\nor \"ifs\" structure. This is a typical solution used in classical procedural languages. In doing so, the\nnovice failed to take into account the functionalities of OOP. By using late-binding and\ninheritance, he could have allowed the system to decide during execution which kind of object was\nbeing processed. In this way the appropriate method could have been called without using a \"type\"\nparameter and a selection structure.\nWe have been particularly interested in comparing the errors made in declarative problems and\nprocedural problems (D\u00e9tienne, 1995). In declarative problems, the program structure is strongly\nconstrained by the data structure: the representation of this structure guides problem development.\nIn procedural problems, the program structure is strongly constrained by the procedure structure: the\nrepresentation of this structure guides program development (Hoc, 1983). Thus, the nature of what\nis transferred should be different depending on the problem type.\nIn our experiment, we used two management problems: (1) a library management problem that was\na slightly modified version of a problem classified by designers in a previous experiment (Hoc,\n1983) as a procedural problem and (2) a financial management problem classified as a declarative\nproblem. Our results (D\u00e9tienne, 1995) tend to show that the definition of the structure of classes is\nmore error prone for a declarative problem. This suggests that when a strong data structure known\nfrom procedural languages is transferred, the resulting representation includes unnecessary classes\nand/or objects structured in a way more appropriate to procedural programming. For the procedural\nproblem, we more often found errors of misplaced methods. This suggests that when a strong\nprocedure structure known from procedural languages is transferred, the structure of this procedure\nis developed as a complex plan. Linking parts of this plan with classes is error prone.\n4.2\n\nComparing OO design with procedural design\n\nIn this section, we examine the processes involved in designing in the OO paradigm and the\nprocedural paradigm. We will refer to results of comparative studies and also to studies that analyse\n\n14\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nthe cognitive processes of procedural designers, on the one hand, and OO designers, on the other\nhand. It should be noted that the latter comparison is more risky as it is more difficult to control\nthe effect of other factors besides the paradigm itself.\n4.2.1\n\nMethods for comparing design across paradigms\n\nComparing design in different paradigms raises specific methodological problems. Some authors\n(Lee & Pennington, 1994; Pennington, Lee & Rehder, 1995; Rist, 1996) have made an important\ncontribution by developing methodologies, independent of the design paradigm, for the description\nand evaluation of final designs and for analysing design processes.\nThe methodology developed in the Pennington study is based on the design methodology of\nRumbaugh, Blaha, Premerlani, Eddy and Lorensen (1991). It allows the comparison of the final\ndesign across different design paradigms. It examines how design proceeds through three types of\nstructure: functional, procedural and object structure. It also allows measurement of the\ncompleteness of the final design from each of these three different views.\nRist has developed a powerful tool, called the system structure, to formalise design solutions.\nThree types of links are represented across goals and objects: control flow, data flow, and sequence.\nThis tool can be used to analyse design activity by showing the order in which nodes are added to\nthe system. Three dimensions of design capture the order in which nodes are added to the system\nstructure: link type (goal versus class), level (top-down versus bottom-up) and direction (forward\nversus backward).\nWhereas several authors used a paradigm for comparing OO design with procedural design, we can\nregret that, to date, the methodologies developped by Pennington and by Rist have been used only\nin these authors' own studies.\n4.2.2 Ease of mapping between the problem space and the design solution space\n\n15\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nSeveral comparative studies (Kim & Lerch, 1992; Boehm-Davis & Ross, 1992; Lee & Pennington,\n1994) show that OO design tends to be easier and faster than procedural design. With regard to the\nclaims made about naturalness and ease of design in the OO paradigm, an important issue is\nwhether the problem decomposition is driven by problem domain entities. In several comparative\nstudies ( Lee & Pennington, 1994; Pennington, Lee & Rehder, 1995; Rosson & Gold, 1989) it has\nbeen shown that problem decomposition is driven by problem domain entities for OO expert\ndesigners whereas for procedural designers the decomposition is driven by generic programming\nconstructs and specialised design knowledge.\nIn Pennington's studies ( Lee & Pennington, 1994; Pennington, Lee & Rehder, 1995) it was found\nthat expert OO designers analyse a situation through its objects. Compared to procedural design,\nless time is spent analysing the problem situation and more time is spent describing objects and\ntheir relationships. Differences between procedural and OO experts are noted mainly in the way in\nwhich they analyse the task domain. Expert OO designers spend as much time analysing the\ndomain as expert procedural designers but they accomplish this through the creation of classes of\nobjects rather than in general terms. Pennington et al. interpret this result as supporting the claim\nthat OO designers analyze situations through objects and their interrelations.\nThe same result was found in Rosson and Gold (1989). OO designers use knowledge of how\nproblems entities operate and interact to reason about design objects. On the basis of their\nobservations the authors suggest that much of OOD in its earlier phases is driven by an\nunderstanding of the problem itself rather than by specialised design knowledge. On the contrary,\nthe solutions of procedural designers are structured by generic programming constructs rather than\nby entities of the problem domain.\nFurthermore, it has been found that compared to procedural designers, OO designers produce more\nsimilar final solutions with similar objects and methods (Boehm-Davis & Ross, 1992; Lee &\nPennington, 1994). This similarity could be attributed to a close mapping of the problem domain.\n\n16\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nThis tends to support the claim that OO designers are able to create designs that map more closely\nto the problem domain (Rosson & Gold, 1989).\n4.2.3 Design strategies\n\nIn OO design, two classes of strategies may guide the design activity: strategies based on\nrepresentations exhibiting static characteristics and strategies based on representations exhibiting\ndynamic characteristics. We will refer to these two classes of strategies by the terms \"declarative\nplan\" and \"procedural plan\".\nWhen the plan3 which guides the design activity is declarative, static characteristics, such as\nobjects and typical functions (roles), guide solution development. The use of two strategies suggest\nthe involvement of such a plan: strategies based on typical functions or strategies based on objects.\nThese strategies (Chatel & D\u00e9tienne, 1994; 1996) are:\n-function-centred strategy: the functions are prominent in the representation guiding the design\nactivity, and objects are subordinate to functions. The subjects follow plans in which typical\nfunctions (or roles) are central. They develop one function for several objects, then another function\nfor several objects, and so on. Examples of functions are reading access, writing access,\ninitialisation, printing, etc.\n-object-centred strategy: the objects are prominent in the representation guiding the design activity,\nand functions as well as procedures are subordinate to objects. This means that objects are central.\nThe subjects tend to follow a plan in which several typical functions as well as typical calling\nstructures are associated to a generic object. The subjects develop several typical functions for one\nobjects then the same functions for another object and so on. It may also happen that the subjects\ndevelop several typical functions by following their calling links in objectA then develop several\nsimilar functions by following their calling structure again in objectB, and so on.\n\n3 Here the term \"plan\" refers to the mental representation which guides the design and does not mean a\n\nsolution plan.\n\n17\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nWhen the plan which guides the design activity is procedural, dynamic characteristics, such as\nactions organised in the temporal order of their execution, guide solution development. The use of\na strategy based on procedures (Chatel & D\u00e9tienne, 1994; 1996) suggests the involvement of such a\nplan:\n-procedure-centred strategy: the representation of the procedure guides the design activity. The\nsubjects tend to follow plans in which methods implied in a procedure are organised according to\ntheir calling structure. In OO programs such a procedure is a complex plan which is delocalised.\nActions of a complex plan correspond to single methods which are associated to different objects.\nThe client-server relationships, e.g. the calling structure, provide the links between those actions.\nAccording to the procedure-centred strategy, the subjects develop in a row several methods implied\nin a procedure for performing one main goal of the problem, even if these methods are associated to\ndifferent objects. They follow the message passing (or calling) structure.\nThese strategies have been observed with the CO2 language in D\u00e9tienne's study (1995) and with\nSmalltalk in Chatel & D\u00e9tienne's study (1994). Similar search strategies have been described in a\nstudy conducted by Rist (1996): a design strategy based on roles, a design strategy based on goals,\nand a design strategy based on objects.\n- a design strategy based on roles expands one role at a time. Similar roles exist across goals and/or\nobjects. In Chatel and D\u00e9tienne terminology, this is a function-centred strategy.\n- a design strategy based on goals expands one goal at a time, varying the role and the object. In\nChatel and D\u00e9tienne terminology, this is a procedure-centred strategy.\n- a design strategy based on objects expands one object at a time, varying the roles and goals\nrelevant to those objects. In Chatel and D\u00e9tienne terminology, this is a object-centred strategy.\nThese two kinds of plans, declarative and procedural, are also used in procedural design. The\nconcept of declarative versus procedural plans is related to Hoc's (1983) declarative/procedural\nproblem dimension. A problem is procedural if the representation of the procedure structure guides\n\n18\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nsolution development. A problem is declarative if the representation of the data structure guides\nsolution development.\nAn important issue is to determine what conditions trigger the use of one kind of plan rather than\nanother in OO design. It seems that the use of these strategies may be a function of the expertise\nand of the type of problems. Concerning the effect of expertise, D\u00e9tienne (1995) observed that\nnovice OO designers more often used a procedural plan, i.e., a procedure-centred strategy, than\nexperienced OO designers. Experienced OO designers tended to use mostly a declarative plan based\non the objects, i.e., an object-centred strategy.\nIn Chatel and D\u00e9tienne (1996) expert OO designers tended to use one strategy rather than another\ndepending on the type of problem. It was found that, for problems which had some procedural\ncharacteristics, in particular a flat structure of objects with horizontal communication between\nobjects, even experts OO designers tended to use a procedure-centred strategy. For problems which\nhad a hierachical structure, experts tended to use either an object-centred strategy or a functioncentred strategy. This issue of typology of problems for OOD is discussed in Section 4.3.\nBy contrast, Rist (1996) observed that the strategies of experienced OO designers were based most\ncommonly on goals, i.e., a procedure-centred strategy, and less commonly on objects, i.e., an\nobject-centred strategy, whatever the type of problems (data flow versus control flow problems).\nIncreased difficulty led to an increase in goal-based design (procedure-centred strategy). Here\ndifficulty4 was evaluated on the basis of the length of the program and the time spent to develop it.\nThe procedure-centred strategy is the most common strategy used by novices in the D\u00e9tienne study,\nthe most common strategy used by experienced programmers in the Rist study and it is used by\nexperts only for procedural-like problems in the Chatel and D\u00e9tienne study. An explanation of these\ncontradictory results could lie in the way in which subjects are categorised as experienced designers\nor novices in these studies. The so called \"experienced designers\" were students in the Rist study,\n\n4 This way to assess problem difficulty reflects the quantity of information to manage when solving the\n\nproblem rather than the complexity or familiarity of the problem.\n\n19\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nwhereas they were professional in the D\u00e9tienne study and in the Chatel and D\u00e9tienne study. This\nmay explain why experienced designers of the Rist study are closer to novices designers than to\nexperienced designers in the D\u00e9tienne study.\nMore generally, comparing results of different studies by subject expertise is often difficult because\ndifferent authors categorise subjects differently. Even the number of years or experience or the\nnumber of known languages may not be a good way to distinguish between different levels of\nexpertise. A good dicussion of this issue is presented in Sonnentag (1996) who defends the idea of\nusing the judgement of subject's peers as an additional way to distinguish between levels of\nexpertise.\nEach of these studies shows dominant strategies for groups of designers but also shows that\nindividual designers shift between strategies when solving a problem. Rist (1996) discusses these\nresults as showing that design is an active, local and opportunistic activity.\nAnother strategy, more related to the design evaluation, is the use of mental simulation. The use of\nthis strategy has been widely documented in studies on procedural design (see, for example,\nAdelson and Soloway, 1988; Guindon, 1990a). On this point, there are contradictory results in the\nstudies comparing OO and procedural design. In Lee and Pennington (1994), it is found that OO\ndesigners spend a greater proportion of time evaluating their designs through mental simulation\nthan do procedural experts. On the contrary, Kim and Lerch (1992) observed less mental simulation\nin OO design compared to procedural design. It is worth noting that in this latter study there was\nonly one OO designer while in the former study there were four OO designers. This should warn us\nto be cautious with hasty generalisations.\n4.2.4 Organisation of the design activity\n\nA higher level of analysis is the level of the organisation of the design activity which is a metalevel to the strategy level. At this meta-level,\n\nempirical studies of software design have\n\nhighlighted the opportunistic nature of the organisation of the design activity (Guindon, Krasner &\n\n20\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nCurtis, 1987; Guindon, 1990a; Visser, 1987; 1994). Even though OO designers may organise their\nactivity opportunistically, as observed in Rist (1996), it is still necessary to assess whether OO\ndesign is relatively more or less opportunistic than procedural design. On this point, two\ncomparative studies provide us with contradictory results.\nPennington et al. (Lee & Pennington, 1994; Pennington, Lee & Rehder, 1995) found more\nopportunistic design among procedural designers and more top-down, breadth-first design with less\nopportunistic behaviour among OO designers. On the contrary, Brangier and Bobiller-Chaumon\n(1995) found more opportunistically organised design among OO designers and more hierarchically\norganised design among procedural designers.\nAn explanation for these contradictory results may be found in the different experimental conditions\nof these two studies: use of pen and pencil in Pennington et al.'s study versus use of programming\nenvironments in Brangier and Bobiller-Chaumon's study (C++ environment versus Pacbase for\nCobol). Thus, it is not clear in fact what is measured: the effect of the environment or the effect of\nthe paradigm.\nSome OO environments allow opportunistic design, for example, the Smalltalk environment as\nshown in an empirical study on reuse (Rosson & Carroll, 1993) and in the claims analysis of the\nSmalltalk browser (Bellamy , 1994). However, we argue that OO environments do not necessarily\nallow or support opportunistic design. For example, the CO2 environment, at least in an early\nversion that we assessed (D\u00e9tienne, 1990a; 1990b), constrained designers mostly to top-down\ndesign: creation of classes in a top-down manner and creation of a method's signature in the class\ndescription before defining the method's code.\nEmpirical studies of software design have also highlighted the use of kernel concepts by expert\nprocedural designers (Guindon, 1990b). Such kernels seem to be used by OO designers as well:\nthey use plan schema or abstract design schema as an abstract description of the design from the\nbeginning of the design sessions (Lee & Pennington, 1994; Pennington, Lee & Rehder, 1995;\nRist, 1996). A question is the structure of kernel concepts in these paradigms.\n\n21\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n4.3\nToward a typology of problems for OOD\nSome problems may be better suited to a non-OO solution because the program structure created by\na language may facilitate or obscure the clear expression of a solution (Petre, 1990). Thus, it is\nimportant to look for a typology of design problems. The critical question is which dimensions of\nproblems are relevant for determining the correspondence between the problem and the design\napproach.\nHoc (1981; 1983) proposed a framework for classifying problems and strategies. Two dimensions\nare distinguished: procedural versus declarative, and prospective versus retrospective. In procedural\nproblems, the program structure is strongly constrained by the procedure structure. The\nrepresentation of this structure guides solution development. In declarative problems, the program\nstructure is strongly constrained by the data structure. The representation of this structure guides\nsolution development. Furthermore, the solution may be developed in a prospective (forward) way,\ne.g., when the data structure of the input is strong, or in a retrospective (backward) way, e.g.,\nwhen the data structure of the output is strong. These distinctions have been made in the context of\nprocedural design. It is important to analyse whether the same dimensions are relevant for OOD and\nthe conditions which influence the use of one strategy rather than another.\nA dimension which seemed, a priori, more relevant for the OO approach, is the distinction between\ndeclarative versus procedural problems. In previous work (D\u00e9tienne, 1990), we hypothesized that,\nin the OO paradigm, declarative problems would be easier to solve than procedural problems. This\nhypothesis was not confirmed by our results. For example, we observed an equivalent proportion of\nrevisions whatever the problem type. Furthermore, our study showed that experienced OO designers\ntended to use a declarative plan whatever the problem type. Rist (1996) found an effect of the\nproblem type only in early planning. Whereas early planning was done following the control flow\nfor most experienced designers, data flow was followed only for the data flow (or declarative)\nproblems. Thus, this problem dimension does not seem to influence greatly the design activity. A\n\n22\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nquestion is whether or not another dimension of the problem may influence the choice of design\nstrategies in OOD.\nAnother dimension was proposed by Chatel and D\u00e9tienne (1996). This new dimension characterises\nnot only the data structure (or objects) and the procedures, but also the way they are associated. The\nstructure of the solution and the way objects communicate within this structure is an important\nfeature of solutions in OOD.\nFor problems with a hierarchical structure of classes with vertical communications between objects,\nwe observed (Chatel & D\u00e9tienne, 1996) that experts OO designers used a declarative plan. Static\ncharacteristics such as objects and typical functions guided solution development. For problems\nwith a flat structure of classes with horizontal communications between objects, i.e., more\nprocedural-like solutions, we observed that experts OO designers used a procedural plan. Dynamic\ncharacteristics of the procedure guided solution development.\nOf course, it could be argued that the OO paradigm encourages the development of hierarchical\nsolution structures rather than flat solution structures. However, the point is that, for any large scale\nsoftware development, we could distinguish parts of the solution with a hierarchical structure from\nparts with a relatively flat structure. This being the case, it is likely that various design strategies,\nand more generally various kinds of plan (declarative versus procedural), may be used for\ndeveloping parts which have different structures.\nAnother problem dimension relevant to OO design is discussed by Herbsleb et al. (Herbsleb, Klein,\nOlson, Brunner, Olson & Harding; 1995). It characterises whether or not well understood\nabstractions have already been constructed in the task domain. These authors distinguish problems\nfor which domain knowledge is known and has just to be captured from problems for which\ndomain knowledge has to be invented. Whereas OO design may be relevant and easy for the former\ntype of problem, what happens with the latter type of problem is still not clear.\n4.4\n\nAssessing the claims about naturalness and ease of OO design\n\n23\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nWe will assess the claims on naturalness and ease of OO design first for novices and then for\nexperts. The literature on novice OO designers shows that they have difficulties in the process of\nclass creation and in articulating the declarative and procedural aspects of their solutions. These\nresults do not support the claims about naturalness and ease of OO design. First they show that the\nidentification of objects is not an easy process. On the basis of knowledge in the problem domain,\nentities are identified as objects but these entities are not necessarily useful in the design solution.\nThe mapping between the problem domain and the programming domain is not straightforward.\nThe analysis of the problem domain is not sufficient to structure the solution in terms of objects.\nThe results show that the novices need to construct a representation of the procedural aspects of the\nsolution in order to refine, evaluate and revise this decomposition into classes with actions\nassociated. Our interpretation of these results is that (1) knowledge is organised in terms of goals\nand procedures and not in terms of relational properties of the objects and (2) procedures are\nproperties of objects and they form the basis for objects categorisation.\nThe literature on novice OO designers also shows some negative effects of knowledge transfer from\nother paradigms. This kind of result was anticipated by some advocates of OO paradigm. For\nexample, Rosson and Alpert (1990) noted that \"However, there exist many designers already trained\nin traditional design methodologies, and we know little about how best to ease their transitions to\nthe object-oriented approach.\"\nThe literature on expert OO designers apparently supports the claims about naturalness and ease of\nOO design. It shows that decomposing the problem is driven by problem entities for expert OO\ndesigners, whereas for procedural designers the decomposition is driven by generic programming\nconstructs and specialised design knowledge. Expert OO designers spend as much time analysing\nthe domain as expert procedural designers but they accomplish this through the creation of classes\nof objects rather than in general terms. This supports the claim that OO designers analyze the\nsituation through the objects and their relationships. Furthermore, results support the claim that\nOO designers are able to create designs that map more closely to the problem domain.\n\n24\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nPutting all these results together makes an odd picture. If OO design decomposition is mostly\ndriven by domain knowledge then the biggest benefit of this approach should be observed in\nnovices. However, this result is not found. Two explanations cand be proposed. First, it is possible\nthat the results found for novices reflect mostly the negative effect of knowledge transfer from other\nparadigms. In this regard, studies with real novices would be extremely useful. As noted by\nRosson and Alpert (1990), an interesting test would compare novice programmers learning to\ndesign in the procedural vs object-oriented paradigms.\nA second explanation is based on the nature of knowledge constructed through experience with the\nOO paradigm. D\u00e9tienne (1995) suggests that different schemas, depending on subjects' language\nexperience, are used for planning activities. Schemas related to procedural languages group actions\nin execution order. Schemas related to OO languages integrate actions and objects, with actions\norganized around objects. The latter type of schemas may be developed through practice with OOP\nlanguages and is more adapted to the constraints that must be taken into account when designing\nwith this kind of language (e.g., making explicit the links between objects and actions).\nFurthermore, the results show that expert OO designers may shift from an object-centred to a\nprocedure-centred strategy when developing their solution. This result shows that the designers\nshift between the object view and the procedure view and that both views can be considered as\nimportant entities in the design process. This shift may also be systematic for certain types of\nproblems as shown previously in the discussion of the typology of problems. These last remarks\nare consistent with Rist's theoretical approach to OO design (Rist, 1996). He defends the idea that\nplans and objects are orthogonal which means that they are both first-class entities conceptually:\nthey present different but valid views of a system, are both important, and can both be used to\ndrive the design activity.\n5.\n\nOO software reuse\n\nThe OO design approach supports software reuse through the mechanisms of abstraction,\nencapsulation and inheritance. We will first compare reuse in the OO and the procedural paradigm.\n\n25\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nThen we will discuss results indirectly assessing the potential for reuse in OOD. The next topic\nconcerns the strategies and processes involved in OO software reuse. Finally, we will assess\nempirically the claims on OO reusability.\n5.1\n\nReuse in the OO versus procedural paradigms\n\nAs far as we know, there is only one study comparing reuse in the OO and the procedural\nparadigm. An exploratory study by Lewis, Henry, Kafura, and Schulman (1991) presented evidence\nof increased productivity in OO programming, much of which they attributed to reuse. The main\nconclusions of the authors (p 195) are:\n\"-the OO paradigm substantially improves productivity, although a significant part of this\nimprovement is due to the effect of reuse;\n-Software reuse improves productivity no matter which language paradigm is used;\n-language differences are far more important when programmers reuse than when they do not, and\n-the OO paradigm has a particular affinity to the reuse process.\"\nSome studies have assessed the modifiability of OO programs. Considering that modifying a\nprogram is part of the reuse activity5, the results of these studies may shed light on the reusability\nissue. In a study on OO system maintenance (van Hillegersberg, Kumar and Welke, 1994), it was\nfound that programmers with experience in structured development but with low experience in OO\ndevelopment had trouble understanding and maintaining an OO system. Henry and Humphrey\n(1993) found OO programs to be more easily modifiable than procedural programs for\nundergraduate students. Boehm-Davis, Holt, and Schultz (1992) found the reverse result for student\nprogrammers when they made complex modifications. They found no significant effect of the\nprogram structure, in particular functional versus OO, for professional programmers. However, in\n\n5 Three processes, traditionnally studied in analogical reasoning studies, are involved in the reuse\n\nactivity: retrieval, mapping and adaptation/modification.\n\n26\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nthis latter study, the OO programs were constructed in Pascal and did not have all the OO\nproperties, in particular, inheritance was missing.\n5.2\n\nPotential of OO software reuse\n\nA way to assess the potential for reuse in OO design is to analyse the consistency of final designs\nand representations constructed by designers. According to Lee and Pennington (1994), more\nsimilar decompositions are produced by OO designers than by procedural designers. In their study,\nOO designers produced more closely matched designs with similar objects and methods, whereas\nprocedural designers produced less closely matched designs with different types of data abstractions\nand procedural decompositions. Similarly, Boehm-Davis & Ross (1992) found more consistency in\nsolutions produced following an OO approach than a functional decomposition approach.\nThis consistency may be tied to the shared problem domain knowledge of the designers (Dvorak &\nMoher, 1991). In a study on class hierarchy construction, these authors found that differences in\ndomain experience resulted in qualitative differences in the approach to the problem and impacted\ninter-subject agreement on the structure of the resultant hierarchies.\nThis consistency decreases as the hierarchy becomes deeper. In an experiment in which subjects\nwere to construct a class hierarchy using class specifications, Dvorak (1994) found that, the deeper\nthe hierarchy is, the less agreement there is between subjects about the class's placement in the\nhierarchy. This author explains this by using the concept of conceptual entropy: \"Conceptual\nentropy is manifested by increasing conceptual inconsistencies as we travel down the hierarchy.\nThat is, the deeper the level of hierarchy, the greater the probability that a subclass will not\nconsistently extend and/or specialise the concept of its superclass.\" This concept may explain why,\nas the hierarchy becomes deeper, the performance of subjects in a maintenance task deteriorates, as\nfound in a recent study comparing 3 levels of inheritance versus 5 levels of inheritance (Daly,\nBrooks, Miller, Roper & Wood, 1996).\n\n27\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nReuse by inheritance is dependent on the organisation of objects. Reuse in OOP is based on the\nassumption that the representation of objects is most important and corresponds to the deep\nstructure of programs. However, empirical studies have found that the object view is not the most\ndominant view of the code (Davies, Gilmore & Green, 1995; Chatel & D\u00e9tienne, 1994). These\nauthors found the following results:\n-experts may organise their thinking about programs according to three views: functional,\nprocedural and object\n-the functional properties and message passing relationships are more important for experts than for\nnovices. Experts organise their thinking about programs around the algorithmic structure\n-the relationships of objects are more important for novices than for experts. Novices organise their\nthinking about programs according to the problem domain\nThese results challenge the idea that the objects form the deep structure of OO programs. In a\ngeneral way it is likely that different tasks require different perspectives on the code, not all of\nwhich are object based.\n5.3\n\nReuse activity\n\nSupporting reuse activity has become a big challenge in software engineering. At the same time,\nempirical work on design with reuse activity has been conducted in recent years, particularly on\nreuse in the OO context. A first general remark is that reusing through built-in classes is not\nspontaneous. Expert OO designers utilise reuse through built-in-classes whereas the novices do not\nspontaneously take advantage of built-in classes (Lee & Pennington, 1994). Second, contrary to the\nclaims about how OO languages might facilitate reuse, Lange and Moher (1989) and D\u00e9tienne\n(1991) found that reuse efforts did not centre on reuse by specialising the inheritance hierarchy but\nrather on literal copying and modification of code. Third, reuse involves some particular expertise\ndifferent from expertise in the programming domain and expertise in the problem (task) domain.\nProgrammers who are experienced in programming and familiar with the application domain, but\n\n28\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nnovices in the reuse task, have difficulties in selecting, and modifying a reusable component. Their\ncriteria for choosing between several reusable components are inadequate (Rouet, Deleuze-Dordron\n& Bisseret, 1995; Woodfield, Embley, & Scott, 1987). Although a greater potential for reuse may\nexist in OO programming, it may not be enough to promote reuse without the development of\nsupport tools and reuse methods/training.\n5.3.1 Cognitive typology of reuse processes\n\nFrom the software engineer's point of view, a classical typology of the reuse situation is made in\nterms of the type of reusable components (e. g. code, specialisable components, class reuse by\ninheritance). From a cognitive point of view, we have proposed a typology of reuse processes6. The\ntypology is based on the cognitive status of the reused component, which depends on the goal of\nthe designer. This typology is orthogonal to the previous typology of components.\nThree situations (Burkhardt & D\u00e9tienne, 1994; 1995a; D\u00e9tienne, 1996) can be distinguished: (1)\nthe designer analyses the software problem and then the retrieval of a reusable component allows\nthe addition of specifications to the problem at hand, the addition of constraints or the abstraction\nof constraints; (2) the designer is looking for a solution and then the retrieval of a reusable\ncomponent allows the evocation of alternative solutions, the evocation of criteria to evaluate a\ntentative solution, the construction of a plan which guides the problem solving process, or the\nrevision of the goal structure; (3) the designer has already chosen and begun implementing a\nsolution and is looking for a reusable component to avoid the coding of the chosen solution7.\nThus, at one extreme of this continuum, designers may look for a model which guides their\ndesigns and, at the other extreme, they may look for a pluggable component which allows the\nimplementation of a chosen solution without having to code it.\n6 We think that this cognitive typology of reuse situations can be related to a typology of documenting\n\nprocesses. A theoretical framework for documenting reusable components should be based both on our\ntypology of reuse processes and on our typology of documenting processes (D\u00e9tienne, Rouet, Burkhardt\n& Deleuze-Dordron, 1996) as well as on the idea of using free annotations (Green, Gilmore, Blumenthal,\nDavies & Winder, 1992).\n7 Considering separately the phases of analysis, problem solving and implementation helps us t o\nemphasize the different nature of the reuse processes which are involved in these phases. However, these\nphases are not striclty separate and there are interactions between them as shown in empirical studies o n\nopportunistic design (Guindon, 1990; Visser, 1994).\n\n29\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n5.3.2 Enrichment of the representation versus lowering of the level of control of the activity\n\nOur typology of reuse processes allows us to explain apparently contradictory results of empirical\nstudies on reuse, results which seem not to be specific to reuse in the OO context, by the way.\nSome results are that the effect of the reuse processes is an enrichment of the representations\nconstructed during design (Burkhardt & D\u00e9tienne, 1995b; De Vries, 1993; Rosson & Carrol,\n1993), e.g. by the inference of new constraints, new goals. Other results are that the effect of the\nreuse processes is the lowering of the level of control of the activity, in particular by the use of\ntest/debug strategies and comprehension avoidance strategies (Lange & Moher, 1989; D\u00e9tienne,\n1991). We defend the idea that the former type of results concern reuse processes involved during\nthe analysis and problem solving phases whereas the latter type of results concern reuse processes\ninvolved during the implementation phase.\nThe effect of the reuse processes may be an enrichment of the representations constructed during the\nproblem analysis and problem solving phases. Burkhardt and D\u00e9tienne (1995) show that evoking a\nreusable component may allow the addition of constraints, evaluation criteria, new goals. Rosson\nand Carrol (1993) note that sometimes the borrowed code is not directly reusable itself but rather is\nused more as a functional specification.\nReuse results in the lowering of the level of control of the activity during the implementation\nphase. We refer to the hierarchy of levels of control developed by Rasmussen and Lind (1982).\nThese authors distinguish between automatic activities, activities based on rules, and activities\nwhich involve high-level knowledge. The lowering of the level of control of the activity consists in\nswitching from activities which involve high-level knowledge, e.g. problem solving activities, to\nactivities based on rules and automatic activities, e.g. execution of procedures.\nThe use of the copy/edit style attests this effect. The copy/edit style does not conform to the style\nof reuse encouraged for OOP, i.e., reuse by inheritance. It reflects comprehension avoidance of the\ncopied code and use of surface-level features to construct a representation of it (Davies, Gilmore &\nGreen, 1995; Lange & Moher, 1989; Rosson & Carroll, 1993). The designers make \"probable\"\n\n30\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nmodifications and rely heavily on the debugging tools to evaluate the code. In what we called \"new\ncode reuse\" (D\u00e9tienne, 1991), the designer anticipates the reuse of a component in the same\nprogram while developing it. In new code resuse designers construct an operative representation of\nthe source as well as a procedure for modifying the code of the source into targets. Designers then\nexecute this procedure to develop targets. In this case also, there is a lowering of the level of\ncontrol of the activity, which causes errors by propagation of source errors or by omission of\nchanges.\n5.3.3 Importance of example and context\n\nStudies show the importance of examples in reuse (Burkhardt & D\u00e9tienne, 1995; De Vries, 1993)\nand, in the OO paradigm, the importance of knowledge about the context from which a reusable\nclass comes. In a field study, Rouet, Deleuze-Dordon and Bisseret (1995) found that, for selecting a\nreusable component in a library, designers were looking for information on the application from\nwhich the component was extracted. This contextual information which seems to be highly\nimportant is rarely present in the documentation of components because software engineers\ngenerally believe that reusable components must be generic and application-independent.\nRosson and Carroll (1993) also note the importance of knowledge about \"example application of a\ntarget class\". They observed that Smalltalk designers reused components indirectly through the\nreuse of uses. For example, a class might be reused indirectly through the reuse of blocks of code\nor methods embedded in an example application. The designers relied on code in example\napplications that provided them with an implicit specification, called the \"usage context\", for the\nreuse of the class. The authors observed that, quite often, the usage context was assimilated into the\ncurrent design project by copying and editing borrowed code. It also sometimes served as a model\nfor the analysis or solution design of the current problem. It is worth noting that the Smalltalk\nenvironment supports the identification and reuse of \"example usage context\" through its sender\nquery which returns a list of methods in which a target message is used.\n\n31\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nThese authors also observed that Smalltalk programmers sometimes decided to inherit rather than\nborrow from the example usage context. In this case, they reused more than just the pieces of code\ninvolving the target class. They reused the entire application context of the example. This idea has\nbeen developed in computer science under the notion of a framework (Fischer, Redmiles, Williams,\nPuhr, Aoki, and Nakakoji, 1995).\n5.4\n\nAssessing the claims about OO software reusability\n\nSome results of empirical studies support the claim that the OO paradigm promotes reuse of\nsoftware. It has been shown that the OO paradigm substantially improves productivity and that a\nsignificant part of this improvement is due to the effect of reuse. The potential of OO software\nreuse is attested by the greater consistency of final designs with this approach compared with a\nprocedural approach. This consistency is tied to the shared problem domain knowledge of the\ndesigners.\nThe style of reuse which is encouraged for OOP is reuse by inheritance. Two kinds of results cast\nsome doubts on the idea that this kind of reuse is easily performed. First, whereas reuse by\ninheritance is based on the organisation of objects, some results challenge the idea that the objects\nform the deep structure of OO programs. Three views are important: functional, procedural and\nobject. In a general way, it is likely that different tasks require different perspective on the code, not\nall of which are object based.\nSecond, contrary to the claims about how OO languages might facilitate reuse by inheritance, some\nstudies have found that reuse efforts do not centre on reuse by specialising the inheritance hierarchy\nbut on literal copying and modification of code. Furthermore reuse through built-in classes is not\nused spontaneously by novices. These results suggest that reuse may require a particular kind of\nexpertise and that training and properly documenting components are central issues.\n6.\n\nOO design by teams\n\n32\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nAs far as we know, there are only two studies (B\u00fcrkle, Gryczan & Z\u00fcllighoven, 1995; Herbsleb,\nKlein, Olson, Brunner, Olson & Harding; 1995) on OOD at the software design team level. These\nstudies have evaluated whether or not problems which have been well documented in procedural\ndesign studies also occur in OO development projects. These problems concern communication,\ncoordination, knowledge dissemination and interaction with clients.\n6.1\n\nCommunication and coordination\n\nHerbsleb et al. examined patterns of communication and coordination in design meetings. They\ncompared these patterns between teams using a traditional approach and a team using an OO\napproach. They found that the major differences associated with OOD were (p273):\n\"-fewer episodes of clarification in design discussions.\n-more episodes of summary and walk-through.\n-earlier mentions of criteria in issue discussions.\n-more integral role of summary and walk-through in design discussions.\"\nThe study found that communication between members of the team was more effective with an OO\nparadigm than a procedural paradigm: there were fewer episodes of clarification in design\ndiscussions. Issues were sometimes addressed by first figuring out what properties a good answer\nshould have, in terms of criteria, before considering alternatives. Criteria were mentioned earlier in\nissue discussions. OOD helped to focus communication on decisions affecting object interfaces and\nmethods. This suggests that OOD may ease coordination by helping developers work\nindependently and identify what needs to be communicated.\n6.2\n\nKnowledge dissemination\n\nIn the Herbsleb study, the kinds of questions that designers asked in development meetings were\nanalysed and compared between the traditional approach projects and the OO project. The authors\ndistinguish between \"what\", \"why\" and \"how\" questions and between the phase into which the\nquestions are asked, i.e. requirements versus design. They found quite different patterns of\n\n33\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nquestions based on the approach followed by the team. In particular, OO designers asked more\nquestions about design than about requirements and there was an increase in \"why\" questions. The\ninterpretation given by the authors is that the OO designers were reasoning more deeply about the\ndesign. In particular, they sought a more thorough understanding of the underlying issues as\nrevealed by the increase of \"why\" questions. It is worth noting that this can be a good way to\nimprove the design process.\n6.3 Interaction with clients\nInteraction with clients shows contradictory results. Burkle et al. found that communication\nbetween the team and clients was more effective whereas Herbsleb et al. found the contrary result.\nThese latter authors make the distinction between two types of problems (as already discussed in\nsection 4.3): problems for which domain knowledge has to be captured and problems for which\ndomain knowledge has to be invented. They argue that OOD is likely to be particularly useful for\nthe former type of problems. However, it appears that their problem was of the second type, which\ncould explain the difficulties in interaction with clients found in their study.\nHerbsleb et al. also discuss the tension between generality and understandability. To use inheritance\nand reuse effectively, the designers must design classes which are highly abstract. However, the\nmore abstract the classes are, the more difficult they are for users and domain experts to understand.\n6.4\n\nAssessing the claims about OOD at the software design team level\n\nThese results tend to show that the OO paradigm helps to overcome some problems encountered at\nthe software design team level compared with traditional paradigms. Communication between\nmembers of the team is more effective. Coordination and Knowledge dissemination are enhanced.\nInteraction with clients seems to be improved mostly for well-defined problems. However for\nproblems for which domain knowledge has to be invented there is no improvement. This casts\ndoubt on the hypothesis made by Rosson et Alpert (1990) that OO may be especially valuable in\nnew domains.\n\n34\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n7.\nLimitations and directions for future work\n\nWe would like to highlight some methodological limitations of the studies on OOD. Both\ncontrolled studies and field studies are often limited by a low number of subjects. Also, it is often\ndifficult to disentangle the effects of variables such as characteristics of the language, methods,\nenvironment, design metaphor, etc. As noted by Curtis (1995, p 341), \"we need to distinguish\nbetween OO as a computational model and OO as a cluster of mutually supportive development\nmethods, not all of which are strictly tied to the OO computational paradigm\".\nThese studies have shown some benefits of OOD both at the individual level, in particular for\nexpert OO designers, and at the team level. However, we have seen that major problems are\nencountered when shifting from the procedural to the OO paradigm. With respect to claims on\nreuse, results of empirical studies show frequent use of the copy/edit style of reuse, which is not\nthe style of reuse encouraged by proponents of OOD.\nTo go further, it seems important to view the studies presented in this paper and future studies on\nOO design from the view of methodology: for example, the language and the environment used.\nAs concern the studies presented in this survey, Pennington's studies and the Rist study were done\nusing paper and pencil. Furthermore, in Pennington's studies, the subjects made high level designs\nwithout any particular specified OO language8 whereas most other studies used a particular OO\nlanguage (and environment):\n\u2022 the Smalltalk language and environment in Chatel and D\u00e9tienne's studies (Chatel and D\u00e9tienne,\n1994; 1996; Chatel, D\u00e9tienne and Borne, 1992) and in Rosson and Carroll's study (1993),\n\u2022 the CO2 language and environment in D\u00e9tienne's studies (1990a; 199Ob; 1991; 1993; 1995),\n\u2022 the C++ language in Burkhardt and D\u00e9tienne (1995), in Davies, Gilmore and Green's study\n(1995) and the C++ language and environment in Brangier and Bobiller's study (1995)\n\n8 Even though the OO languages they were thinking of for implementation was either C++ or Smalltalk.\n\n35\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\n\u2022 the C++ and the Eiffel languages in Rist's study (1996)\nOne point could be to examine OO languages used according to their similarity with procedural\nlanguages. It is possible that the similarity between an OO language and known procedural\nlanguages encouraged transfer and intrusions from procedural languages: the C++ and CO2\nlanguages have procedural characteristics (similarity with the C language) that are not present in\nother OO languages such as Smalltalk. Most studies using either C++ or CO2 provide evidence of\nnegative effects of transfer. However even with Smalltalk, Chatel, D\u00e9tienne & Borne (1992) found\ntranfer between paradigms.\nAnother point could be to analyse languages and environments used in these studies according to\nvarious cognitive dimensions (Green,1989) and their influence on the organisation of the activity\nand on the use of design strategies. For example, it is clear that the CO2 environment and language\n(D\u00e9tienne, 1995) have order constraints (an object cannot be used in a method body if it has not\nbeen completely specifed before) which force a top down development of the solution. This causes\npremature commitments and entail many revision afterward. With Smalltalk, authors (Rosson &\nCarrol, 1993) have illustrated the opportunistic nature of the organisation of the activity which is\nencouraged by the environment characteristics.\nAs concern the use of design strategies it is clear that some environment characteristics may\nencourage the use of one strategy rather than another. For example, if we analyse the strategies used\nby OO experts, the function-centred strategy was not observed in the D\u00e9tienne study (1995), at least\nin the preliminary planning phase, and was observed in the Chatel and D\u00e9tienne study (1996). A\ndifference between these studies is the OOP language and device used, CO2 in the former study and\nSmalltalk in the latter study. It is likely that some Smalltalk environment characteristics may have\ntriggered the use of the function-centred strategy. Under this environment, methods performing the\nsame function, e.g. initialisation, can be grouped by the programmer into a category of methods\nwith the label \u00ab init \u00bb, for example.\n\n36\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nTo conclude, we should note some thematic limitations of our review. We did not review work on\nOO education and learning environments even though there is some significant work in this area\n(see for example: Carroll, Rosson & Singley, 1993; Robertson, Carroll, Mack, Rosson & Alpert,\n1993; Singley & Carroll, 1990) .\nTopics which have not yet been addressed in the literature include OO program comprehension, on\nthe one hand, and components retrieval, on the other hand. As regard OO program comprehension,\nwe note that some studies are in progress (Burkhardt, D\u00e9tienne & Wiedenbeck, 1997). Also, we\nregret that there are, as far as we know, almost no empirical studies on real novices. Future research\ncould centre on these themes.\nBackground\n\nThis paper is based on an invited talk presented by the author at ESP6 (Washington DC, January 57, 1996).\nAcknowledgements\n\nWe would like to express our thanks to Robert Rist for his helpful and constructive comments on a\nprevious draft of this paper. Special thanks to Susan Wiedenbeck who has kindly accepted to\nimprove the English of this paper.\nReferences\n\nAdelson, B., & Soloway, E. (1988) A model of software design. In M.T.H. Chi, R. Glaser, &\nM.J. Farr (Eds): The natue of expertise. Hillsdale, NJ: Laurence Erlbaum Associates Inc. p 185208.\nBellamy, R. K. E. (1994). Strategy analysis: an approach to psychological analysis of artifacts. In\nD. J. Gilmore, R. L. Winder, and F. D\u00e9tienne (Eds.), User-Centred Requirements for Software\nEngineering Environments, (pp 57-68). Berlin: Springer-Verlag.\n\n37\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nBrangier, E., and Bobiller-Chaumon, M-E. (1995) Approche psycho-ergonomique compar\u00e9e de\nl'utilisation d'environnements de programmation proc\u00e9dural et orient\u00e9-objets. Actes du congr\u00e8s\nAFCET'95.\nBrooks, R. (1977) Towards a Theory of the Cognitive Processes in Computer Programming.\nInternational Journal of Man-Machine Studies, 9, 737-751.\nBoehm-Davis, D.A. Holt, R.W., and Schultz, A.C. (1992). The role of program structure in\nsoftware maintenenace. International Journal of Man-Machine Studies, 36, 21-63.\nBoehm-Davis, D. A., and Ross, L. S. (1992) Program design methodologies and the software\ndevelopment process. International Journal of Man-Machine Studies, 36, 1-19.\nBurkhardt, J-M., and D\u00e9tienne, F. (1994) La r\u00e9utilisation en G\u00e9nie Logiciel: une d\u00e9finition d'un\ncadre de recherche en Ergonomie Cognitive. Actes du congr\u00e8s ERGO-IA 94, Biarritz, 26-28\nOctobre.\nBurkhardt, J-M., and D\u00e9tienne, F. (1995) An empirical study of software reuse by experts in\nobject-oriented design. In: K. Nordby, P.H. Helmersen, D.J. Gilmore and S.A. Arnesen (eds.),\nHuman Computer Interaction, proceedings of INTERACT'95. Chapman & Hall, 133-138.\nBurkhardt, J-M. D\u00e9tienne, F., & Wiedenbeck, S. (1997) Mental Representations constructed by\nexperts and novices in object-oriented program comprehension. INTERACT'97, Sydney, Australia,\nJuly 14-18.\nB\u00fcrkle, U., Gryczan, G., and Z\u00fcllighoven, H. (1995) Object-Oriented System Development in a\nBanking Project: Methodology, Experience, and Conclusions. Human-Computer Interaction, 10 (2\n& 3), 293-336.\nChatel, S. (1997) L'acquisition d'un langage de programmation orient\u00e9e-objet: Smalltalk-80. Th\u00e8se\nde Psychologie Cognitive, Universit\u00e9 Paris VIII, February 1997.\n\n38\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nChatel, S., and D\u00e9tienne, F (1994) Expertise in Object-Oriented Programming. Proceedings of\nECCE7, Bonn, 5-8 Septembre.\nChatel, S., and D\u00e9tienne. F. (1996) Strategies in object-oriented design. To appear in Acta\nPsychologica, special issue on Cognitive Ergonomics.\nChatel, S., D\u00e9tienne, F., and Borne, I. (1992) Transfer among programming languages: an\nassessment of various indicators. In F. D\u00e9tienne (Ed.): Proceedings of the Fifth Workshop of the\nPsychology of Programming Interest Group. Paris, F, Sept 10-12, 1992, 261-272.\nCarroll, J. M., Rosson, B., and Singley, M. K. (1993) The collaborative thread: a formative\nevaluation of object-oriented education. Research report, RC 19037, IBM, Watson Research\nCenter, Yorktown Heigths, NY.\nCurtis, B. & Walz, D. (1990) The psychology of programming in the large: team and\norganizational behavior. In J-M. Hoc, T.R.G. Green, R. Samurcay,\n\nand D. Gilmore (Eds.),\n\nPsychology of Programming (p. 253-270). Academic Press: London.\nCurtis, B. (1995) Objects of our desire: empirical research on object-oriented development. HumanComputer Interaction, 10, p 337-344.\nDaly, J., Brooks, A., Miller, J., Roper, M., and Wood, M. (1996) Evaluating the effect of\ninheritance on the maintainability of object-oriented software. In W. Gray & D. A. Boehm-Davis\n(Eds): Empirical Studies of Programmers, SixthWorkshop. Washington DC, US, 5-7 January\n1996.\nDavies, S. P., Gilmore, D. J., and Green, T. R. G. (1995) Are Objects That Important? The Effects\nof Familiarity and Expertise on the Classification of Object-Oriented Code. Human-Computer\nInteraction, 10 (2 & 3), 227-249.\n\n39\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nD\u00e9tienne, F. (1990a) Difficulties in Designing with an object-oriented language: an empirical\nstudy. In: D. Diaper, D. Gilmore, G. Cockton and B. Shacker (eds.), Human Computer\nInteraction, Proceedings of INTERACT'90. North Holland, 971-976.\nD\u00e9tienne, F. (1990b) Un exemple d'\u00e9valuation ergonomique d'un syst\u00e8me de programmation\norient\u00e9-objet, le syst\u00e8me O2. Actes du congr\u00e8s ERGO.IA'90, Biarritz, 19-21 septembre.\nD\u00e9tienne, F. (1991) Reasoning from a schema and from an analog in software code reuse. In:\nJ. Koenemann-Belliveau, T. Moher, and S.P.\n\nRobertson (Eds.): Empirical studies of\n\nprogrammers, Fourth Workshop. Norwood, NJ: Ablex Publishing Corporation, 5-22.\nD\u00e9tienne, F. (1993) Acquiring experience in object-oriented programming: on design strategies. In\nE. Lemut, B. du Boulay and G. Dettori (Eds): Cognitive Models and Intelligent Environments for\nLearning Programming. Springer-Verlag. NATO ASI Series.\nD\u00e9tienne, F. (1995) Design strategies and knowledge in object-oriented programming: effects of\nexperience. Human-Computer Interaction, 10 (2 & 3), 129-170.\nD\u00e9tienne, F. (1996) La conception et r\u00e9utilisation de logiciel: l'approche de l'Ergonomie Cognitive.\nWorkshop \"Les Sciences Cognitives et le Conception des Syst\u00e8mes Informatiques\", Florianopolis,\nBrasil, Feb 26-27, 1996.\nD\u00e9tienne, F., Borne, I., and Chatel, S. (1993) The activity of Design with Object-Oriented\nLanguages. Proceedings of the INTERCHI' 93 Research Symposium. Amsterdam, NL, April 23-24.\nD\u00e9tienne, F., and Rist. R. (1995) Introduction to this special issue on Empirical Studies of ObjectOriented Design. Human-Computer Interaction, vol 10 (2 & 3), 121-128.\nD\u00e9tienne, F., Rouet, J-F., Burkhardt, F., & Deleuze-Dordron (1996) Reusing processes and\ndocumenting processes: toward an integrated framework. Proceedings of the Eighth European\nConference on Cognitive Ergonomics (ECCE8), Granada, S, Sept 10-13, 1996.\n\n40\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nDe Vries, E. (1993). The role of case-based reasoning in architectural design : Stretching the design\nproblem space. In W. Visser (Ed.), Proceedings of the Workshop of the Thirteenth International\nJoint Conference on Artificial Intelligence \"Reuse of designs : an interdisciplinary cognitive\napproach\", (pp. B1-B13). Chambery August 29, 1993: INRIA Rocquencourt.\nDvorak, J. (1994) Conceptual entropy and its effect on class hierarchies. IEEE Computer, 27(6),\n59-63.\nDvorak, J. L., and Moher, T. G. (1991) A feasability study of early class hierarchy construction in\nobject-oriented development. In J. Koenemann-Belliveau, T. G. Moher, & S. P. Robertson (Eds):\nEmpirical studies of programmers, fourth workshop. Norwood, NJ: Ablex. 23-35.\nFischer, G., Redmiles, D., Williams, L., Puhr, G., Aoki, A., and Nakakoji, K. (1995) Beyond\nobject-oriented development: Where current object-oriented approaches fall short.\n\nHuman-\n\nComputer Interaction, t 10, 79-199.\nGreen, T. R. G. (1989) Cognitive dimensions of notations. In A. Sutcliffe and L. Macaulay (Eds):\nPeople and Computers V. Cambridge University Press.\nGreen, T. R. G., Gilmore, D. J., Blumenthal, B. B., Davies, S., and Winder, R. (1992) Towards a\nCognitive browser for OOPS. International Journal of Human-Computer Interaction. 4, 1-34.\nGuindon, R. (1990a) Designing the design process: exploiting opportunistic thoughts. HumanComputer Interaction, 5, 305-344.\nGuindon, R. (1990b) Knowledge exploited by experts during software system design. International\nJournal of Man-Machine Studies, 33(3), 279-304.\nGuindon, R. Krasner, H. & Curtis, B. (1987) Breakdowns and Processes during the Early\nActivities of Software Design by Professionals. In G. M. Olson, S. Sheppard & E. Soloway (Eds):\nEmpirical Studies of programmers: second workshop. Ablex.\n\n41\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nHenry, S. and Humphrey, M. (1993). Object-oriented vs. procedural programming languages:\nEffectiveness in program maintenance. Journal of Object-Oriented Programming, 6(3), 41-49.\nHerbsleb, J. D. & Kuwana, E. (1993) Preserving knowledge in software engineering: What\ndesigners need to know. Proceedings of INTERCHI'93, 7-14. NY: ACM.\nHerbsleb, J. D., Klein, H., Olson, G. M. , Brunner, H. Olson, J. S., and Harding, J. (1995)\nObject-Oriented Analysis and Design in Software Project Teams. Human-Computer Interaction, 10\n(2 & 3) , 249, 292.\nvan Hillegersberg, J., Kumar, K., and Welke, R. J. (1995) Maintenance of object-oriented systems:\nan empirical analysis of the performance and strategies of programmers new to object-oriented\ntechniques. Proceedings of PPIG7, University of Edinburgh, January 4-6.\nHoc, J.-M. (1981) Planning and direction of problem solving in structured programming: an\nempirical comparison between two methods. International Journal of man-Machine Studies, 15, p\n363-383.\nHoc, J.-M. (1983) Une m\u00e9thode de classification pr\u00e9alable des probl\u00e8mes d'un domaine pour\nl'analyse des strat\u00e9gies de r\u00e9solution: la programmation informatique chez des professionnels.\nLe Travail Humain, 46, 205-217.\nHoc, J-M, & Nguyen-Xuan, A. (1990) Language semantics, mental models and analogy. In J-M.\nHoc, T.R.G. Green, R. Samur\u00e7ay, & D.J. Gilmore (Eds): Psychology of Programming. Academic\nPress, Computer and People Series, p 139-156.\nJohnson, R. and Foote, B. (1988). Designing reusable classes. Journal of Object-Oriented\nProgramming, 1-2, 22-35.\nKant, E. & Newell, A. (1984) Problem solving techniques for the design of algorithms.\nInformation Processing and Management, 20, 97-118.\n\n42\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nKim, J. and J. Lerch (1992) Towards a model of cognitive process in logical design: comparing\nobject-oriented and traditionnal functional decomposition software methodologies. In P.\nBauersfeld, J. Bennett and G. Lynch (Eds.): Proceedings of CHI'92 Conference on Human Factors\nin Computing Systems. ACM Press, 489-498.\nKrasner, H., Curtis, B. & Iscoe, N. (1987). Communication Breakdowns and Boundary Spanning\nActivities on Large Programming Projects. In G. M. Olson, S. Sheppard & E. Soloway (Eds):\nEmpirical Studies of Programmers Second Workshop (p 47-64). Norwood, NJ: Ablex.\nLange, B.M. and Moher T.G. (1989) Some strategies of reuse in an object-oriented programming\nenvironment. In K. Bice and C. Lewis (Eds.): Proceedings of CHI'89 Conference on Human\nFactors in Computing Systems. ACM Press, 69-73.\nLee, A., and Pennington, N. (1994) The effects of programming on cognitive activities in design.\nInternational Journal of Human-computer Studies, 40, 577-601.\nLewis, J.A., Henry, S.M., Kafura D.G., and Schulman, R.S. (1991) An empirical study of the\nobject-oriented paradigm and software reuse. Proceedings of Object-Oriented Programming,\nSystems and Applications. ACM Press: NY, 184-196.\nMeyer, B. (1988) Object-Oriented Software Construction. Prentice Hall, International Series in\nComputer Science.\nPennington, N., A. Lee, and B. Rehder (1995) Cognitive activities and levels of abstraction in\nprocedural and object-oriented design. Human-Computer Interaction, 10 (2 & 3), 171-226.\nPetre, M. (1990) Expert programmers and programming languages. In J-M. Hoc, T.R.G. Green, R.\nSamur\u00e7ay, D. Gilmore (Eds): Psychology of programming (pp 103-116). People and Computer\nSeries, Academic Press.\nRasmussen, J., & Lind, M. (1982) A model of human decision making in complex systems and its\nuse for design of sytem control strategies. Roskilde, Danemark, RISO, M-2349.\n\n43\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nRichard, J-F. (1996) La repr\u00e9sentation mentale d'un dispositif du point de vue de son utilisation et\nde son fonctionnement. Workshop \"Les Sciences Cognitives et le Conception des Syst\u00e8mes\nInformatiques\", Florianopolis, Brasil, Feb 26-27, 1996.\nRist, R. S. (1989) Schema creation in programming. Cognitive Science, 13, 389-414.\nRist, R. S. (1994). Search through multiple representations. In D. J. Gilmore, R. L. Winder, and\nF. D\u00e9tienne (Eds.), User-Centred Requirements for Software Engineering Environments, (pp 165176). Berlin: Springer-Verlag.\nRist, R. (1996) System structure and design. In W. D. Gray, & D. A. Boehm-Davis (Eds):\nEmpirical Studies of Programmers, Sixth Workshop. Washington DC, US, 5-7 January 1996,\nAblex Publishing Corporation. p 163-194.\nRist, R. & Terwilliger, R. (1994) Object-oriented design in Eiffel. Prentice Hall: Sydney.\nRobertson, S. P., Carroll, J. M., Mack, R., Rosson, M. B. & Alpert, S. R. (1993) ODE: The\nobject design exploratorium. Research report, RC 19279, IBM, Watson Research Center,\nYorktown Heigths, NY.\nRosson, M.B. and Alpert, S.R. (1990) The cognitive consequences of object-oriented design.\nHuman-Computer Interaction, 5, 345-379.\nRosson, M. B., and Gold, E. (1989) Problem-solution mapping in object-oriented design.\nResearch Report IBM, RC 14496.\nRosson, M.B. and Carroll, J.M. (1993) Active programming strategies in reuse. Proceedings of\nECOOP'93, Object-Oriented Programming. Berlin: Springer Verlag. 4-18 .\nRouet, J-F., Deleuze-Dordron, C., & Bisseret, A. (1995) Documentation as part of design:\nexploratory field studies. In K. Nordby, P. H. Helmersen, D. J. Gilmore & S. A. Arnesen (Eds):\nProceedings of INTERACT'95. Chapman & Hall. 213-216.\n\n44\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nRumbaugh, J., Blaha, M., Premerlani, W., Eddy, F., & Lorensen, W. (1991) Object-oriented\nmodelling and design. Englewood Cliffs, NJ: Prentice-Hall.\nSiddiqi, J., Osborne, R., Roast, C. & Khazaei, B. (1996) The pitfalls of changing paradigms. In\nW. D. Gray, & D. A. Boehm-Davis (Eds): Empirical Studies of Programmers: SixthWorkshop.\nWashington DC, US, 5-7 January 1996, Ablex Publishing Corporation. p 219-232.\nSingley, M. K. & Carroll, J. M. (199O) Minimalist planning tools in an instructional system for\nSmalltalk. Research report, RC 15860, IBM, Watson Research Center, Yorktown Heigths, NY.\nScholtz, J. and Wiedenbeck, S. (1990). Learning to Program in Another Language. In D Diaper, D\nGilmore, G Cockton and B Shackel (Eds), Human Computer Interaction, Proceedings of\nINTERACT'90 (pp 925-930). North Holland: Amsterdam.\nScholtz, J. & Wiedenbeck, S. (1993). An analysis of novice programmers learning a second\nlanguage. In C. R. Cook, J. C. Scholtz, and J. C. Spohrer (eds.), Empirical studies of\nprogrammers: Fifth Workshop, (pp. 187-205). Norwood, NJ: Ablex.\nSonnentag, S. (1996) Knowledge about working strategies and errors in software professionals:\neffects of expertise and experience. In P. Vanneste, K. Bertels, B. de Decker & J-M. Jaques (Eds):\nProceedings of the Eighth Workshop the Psychology og Programming Interest Group. Ghent, B,\nApril 10-12, 1996, p 164-166.\nVisser, W. (1987) Strategies in Programming Programmable Controllers: A Field Study on a\nProfessional Programmer. In G. M. Olson, S. Sheppard & E. Soloway (Eds): Empirical Studies of\nprogrammers, second workshop. Ablex. p 217-230.\nVisser, W. (1994b) Organisation of design activities: opportunistic, with hierarchical episodes.\nInteracting with Computers, 6 (3), 239-274.\nWoodfield, S. N., Embley, D. W., & Scott, D. T. (1987) Can programmers reuse Software? IEEE\nSoftware, July 1987, 52-59.\n\n45\n\n\fPublished in Interacting with Computers, 1997, 9, p 47-72\nhttp://www.elsevier.com/wps/find/journaldescription.cws_home/525445/description#description\nWu, Q. and Anderson, J.R. (1991) Knowledge Transfer among Programming Languages.\nProceedings of the 13th Conference of the Cognitive Science Society. Hillsdale, NJ: Erlbaum, p\n376-381.\n\n46\n\n\f"}