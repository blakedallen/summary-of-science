{"id": "http://arxiv.org/abs/cs/0511094v1", "guidislink": true, "updated": "2005-11-28T13:33:14Z", "updated_parsed": [2005, 11, 28, 13, 33, 14, 0, 332, 0], "published": "2005-11-28T13:33:14Z", "published_parsed": [2005, 11, 28, 13, 33, 14, 0, 332, 0], "title": "A Machine-Independent port of the MPD language run time system to NetBSD", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0201011%2Ccs%2F0201018%2Ccs%2F0201009%2Ccs%2F0201005%2Ccs%2F0201014%2Ccs%2F0201003%2Ccs%2F0201017%2Ccs%2F0201027%2Ccs%2F0201004%2Ccs%2F0201012%2Ccs%2F0201006%2Ccs%2F0201022%2Ccs%2F0201029%2Ccs%2F0201002%2Ccs%2F0201024%2Ccs%2F0201026%2Ccs%2F0201007%2Ccs%2F0201008%2Ccs%2F0201013%2Ccs%2F0201019%2Ccs%2F0201021%2Ccs%2F0201001%2Ccs%2F0201023%2Ccs%2F0201016%2Ccs%2F0201025%2Ccs%2F0201010%2Ccs%2F0201028%2Ccs%2F0201015%2Ccs%2F0201020%2Ccs%2F0401006%2Ccs%2F0401015%2Ccs%2F0401002%2Ccs%2F0401030%2Ccs%2F0401028%2Ccs%2F0401012%2Ccs%2F0401001%2Ccs%2F0401009%2Ccs%2F0401025%2Ccs%2F0401005%2Ccs%2F0401021%2Ccs%2F0401019%2Ccs%2F0401026%2Ccs%2F0401011%2Ccs%2F0401008%2Ccs%2F0401029%2Ccs%2F0401018%2Ccs%2F0401010%2Ccs%2F0401003%2Ccs%2F0401007%2Ccs%2F0401022%2Ccs%2F0401027%2Ccs%2F0401023%2Ccs%2F0401004%2Ccs%2F0401013%2Ccs%2F0401020%2Ccs%2F0401016%2Ccs%2F0401017%2Ccs%2F0401024%2Ccs%2F0511083%2Ccs%2F0511096%2Ccs%2F0511087%2Ccs%2F0511009%2Ccs%2F0511095%2Ccs%2F0511029%2Ccs%2F0511006%2Ccs%2F0511036%2Ccs%2F0511070%2Ccs%2F0511094%2Ccs%2F0511034%2Ccs%2F0511061%2Ccs%2F0511068%2Ccs%2F0511050%2Ccs%2F0511046%2Ccs%2F0511023%2Ccs%2F0511001%2Ccs%2F0511028%2Ccs%2F0511107%2Ccs%2F0511098%2Ccs%2F0511057%2Ccs%2F0511075%2Ccs%2F0511071%2Ccs%2F0511033%2Ccs%2F0511104%2Ccs%2F0511101%2Ccs%2F0511092%2Ccs%2F0511005%2Ccs%2F0511017%2Ccs%2F0511010%2Ccs%2F0511047%2Ccs%2F0511044%2Ccs%2F0511069%2Ccs%2F0511043%2Ccs%2F0511038%2Ccs%2F0511021%2Ccs%2F0511081%2Ccs%2F0511054%2Ccs%2F0511079%2Ccs%2F0511004%2Ccs%2F0511108%2Ccs%2F0511072%2Ccs%2F0511084&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Machine-Independent port of the MPD language run time system to NetBSD"}, "summary": "SR (synchronizing resources) is a PASCAL - style language enhanced with\nconstructs for concurrent programming developed at the University of Arizona in\nthe late 1980s. MPD (presented in Gregory Andrews' book about Foundations of\nMultithreaded, Parallel, and Distributed Programming) is its successor,\nproviding the same language primitives with a different, more C-style, syntax.\n  The run-time system (in theory, identical, but not designed for sharing) of\nthose languages provides the illusion of a multiprocessor machine on a single\nUnix-like system or a (local area) network of Unix-like machines.\n  Chair V of the Computer Science Department of the University of Bonn is\noperating a laboratory for a practical course in parallel programming\nconsisting of computing nodes running NetBSD/arm, normally used via PVM, MPI\netc.\n  We are considering to offer SR and MPD for this, too. As the original\nlanguage distributions were only targeted at a few commercial Unix systems,\nsome porting effort is needed. However, some of the porting effort of our\nearlier SR port should be reusable.\n  The integrated POSIX threads support of NetBSD-2.0 and later allows us to use\nlibrary primitives provided for NetBSD's phtread system to implement the\nprimitives needed by the SR run-time system, thus implementing 13 target CPUs\nat once and automatically making use of SMP on VAX, Alpha, PowerPC, Sparc,\n32-bit Intel and 64 bit AMD CPUs.\n  We'll present some methods used for the impementation and compare some\nperformance values to the traditional implementation.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0201011%2Ccs%2F0201018%2Ccs%2F0201009%2Ccs%2F0201005%2Ccs%2F0201014%2Ccs%2F0201003%2Ccs%2F0201017%2Ccs%2F0201027%2Ccs%2F0201004%2Ccs%2F0201012%2Ccs%2F0201006%2Ccs%2F0201022%2Ccs%2F0201029%2Ccs%2F0201002%2Ccs%2F0201024%2Ccs%2F0201026%2Ccs%2F0201007%2Ccs%2F0201008%2Ccs%2F0201013%2Ccs%2F0201019%2Ccs%2F0201021%2Ccs%2F0201001%2Ccs%2F0201023%2Ccs%2F0201016%2Ccs%2F0201025%2Ccs%2F0201010%2Ccs%2F0201028%2Ccs%2F0201015%2Ccs%2F0201020%2Ccs%2F0401006%2Ccs%2F0401015%2Ccs%2F0401002%2Ccs%2F0401030%2Ccs%2F0401028%2Ccs%2F0401012%2Ccs%2F0401001%2Ccs%2F0401009%2Ccs%2F0401025%2Ccs%2F0401005%2Ccs%2F0401021%2Ccs%2F0401019%2Ccs%2F0401026%2Ccs%2F0401011%2Ccs%2F0401008%2Ccs%2F0401029%2Ccs%2F0401018%2Ccs%2F0401010%2Ccs%2F0401003%2Ccs%2F0401007%2Ccs%2F0401022%2Ccs%2F0401027%2Ccs%2F0401023%2Ccs%2F0401004%2Ccs%2F0401013%2Ccs%2F0401020%2Ccs%2F0401016%2Ccs%2F0401017%2Ccs%2F0401024%2Ccs%2F0511083%2Ccs%2F0511096%2Ccs%2F0511087%2Ccs%2F0511009%2Ccs%2F0511095%2Ccs%2F0511029%2Ccs%2F0511006%2Ccs%2F0511036%2Ccs%2F0511070%2Ccs%2F0511094%2Ccs%2F0511034%2Ccs%2F0511061%2Ccs%2F0511068%2Ccs%2F0511050%2Ccs%2F0511046%2Ccs%2F0511023%2Ccs%2F0511001%2Ccs%2F0511028%2Ccs%2F0511107%2Ccs%2F0511098%2Ccs%2F0511057%2Ccs%2F0511075%2Ccs%2F0511071%2Ccs%2F0511033%2Ccs%2F0511104%2Ccs%2F0511101%2Ccs%2F0511092%2Ccs%2F0511005%2Ccs%2F0511017%2Ccs%2F0511010%2Ccs%2F0511047%2Ccs%2F0511044%2Ccs%2F0511069%2Ccs%2F0511043%2Ccs%2F0511038%2Ccs%2F0511021%2Ccs%2F0511081%2Ccs%2F0511054%2Ccs%2F0511079%2Ccs%2F0511004%2Ccs%2F0511108%2Ccs%2F0511072%2Ccs%2F0511084&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "SR (synchronizing resources) is a PASCAL - style language enhanced with\nconstructs for concurrent programming developed at the University of Arizona in\nthe late 1980s. MPD (presented in Gregory Andrews' book about Foundations of\nMultithreaded, Parallel, and Distributed Programming) is its successor,\nproviding the same language primitives with a different, more C-style, syntax.\n  The run-time system (in theory, identical, but not designed for sharing) of\nthose languages provides the illusion of a multiprocessor machine on a single\nUnix-like system or a (local area) network of Unix-like machines.\n  Chair V of the Computer Science Department of the University of Bonn is\noperating a laboratory for a practical course in parallel programming\nconsisting of computing nodes running NetBSD/arm, normally used via PVM, MPI\netc.\n  We are considering to offer SR and MPD for this, too. As the original\nlanguage distributions were only targeted at a few commercial Unix systems,\nsome porting effort is needed. However, some of the porting effort of our\nearlier SR port should be reusable.\n  The integrated POSIX threads support of NetBSD-2.0 and later allows us to use\nlibrary primitives provided for NetBSD's phtread system to implement the\nprimitives needed by the SR run-time system, thus implementing 13 target CPUs\nat once and automatically making use of SMP on VAX, Alpha, PowerPC, Sparc,\n32-bit Intel and 64 bit AMD CPUs.\n  We'll present some methods used for the impementation and compare some\nperformance values to the traditional implementation."}, "authors": ["Ignatios Souvatzis"], "author_detail": {"name": "Ignatios Souvatzis"}, "author": "Ignatios Souvatzis", "arxiv_comment": "6 pages", "links": [{"href": "http://arxiv.org/abs/cs/0511094v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0511094v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.1.3; D.3.4", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0511094v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0511094v1", "journal_reference": "Christian Tschudin et al. (Eds.): Proceedings of the Fourth\n  European BSD Conference, 2005 Basel, Switzerland", "doi": null, "fulltext": "arXiv:cs/0511094v1 [cs.DC] 28 Nov 2005\n\nA Machine-Independent Port of the MPD Language\nRun Time System to NetBSD Operating System\nIgnatios Souvatzis\nUniversity of Bonn, Computer Science Department, Chair V\n<ignatios@cs.uni-bonn.de>\n18th November 2017\n\n1\n\nIntroduction\n\nMPD (presented in Gregory Andrews' book about Foundations of Multithreaded, Parallel, and Distributed Programming[1]) is the successor of SR[2] (\"synchronizing resources\"), a PASCAL\u2013style language enhanced with constructs for concurrent programming developed at the University of Arizona in the late 1980s[3].\nMPD as implemented provides the same language primitives as SR with a different\nsyntax which is closer to C.\nThe run-time system (in theory, identical) of both languages provides the illusion\nof a multiprocessor machine on a single single\u2013 or multi\u2013CPU Unix\u2013like system or a\n(local area) network of Unix-like machines.\nChair V of the Computer Science Department of the University of Bonn is operating\na laboratory for a practical course in parallel programming consisting of computing\nnodes running NetBSD/arm, normally used via PVM, MPI, etc.\nWe are considering to offer SR and MPD for this, too. As the original language\ndistributions are only targeted at a few commercial Unix systems, some porting effort\nis needed, outlined in the SR porting guide[7] and also applicable to MPD.\nThe integrated POSIX threads support of NetBSD-2.0 enables us to use library\nprimitives provided for NetBSD's pthread system to implement the primitives needed\nby the SR and MPD run-time systems, thus implementing 13 target CPUs with a onetime effort; once implemented, symmetric multiprocessing (SMP) would automatically\nbe used on any multiprocessor machine with VAX, Alpha, PowerPC, Sparc, 32-bit Intel\nand 64 bit AMD CPUs.\nThis paper describes mainly the MPD port. Porting SR was started earlier and\npartially described in [6] (Assembler and SVR4 cases) while only preliminary results\nfor our new approach could be presented at the conference.\nMost of the differences between our changes to SR and to MPD could be done\nby mechanically replacing mpd by sr in the code; because of this, and because the\ntest machine\narchitecture\nCPU\nclock\ncache\n\nA\ni386\nPentium 4\n1600 MHz\n2 MB\n\nB\narm\nSA-110\n233 MHz\n16kB I + 16 kB D\n\nTable 1: Test machines\n\n\fImplementation\nassembler\n. . . context u libary calls\nSVR4 system calls\n\nA\n0.013 \u03bcs\n0.138 \u03bcs\n1.453 \u03bcs\n\nB\nn/a\n0.237 \u03bcs\n9.649 \u03bcs\n\nTable 2: Raw context switch times\nmachine-independent parts of the SR and MPD run-time support are identical (according to the authors) all results (especially timing results) equally apply to the SR\nport. (This has been verified.)\n\n2\n\nGeneric Porting Problems\n\nDespite the age of SR, the latest version (2.3.3) had been changed to use <stdarg.h>\ninstead of <varargs.h>, thus cutting the number of patches needed for NetBSD 2.0\nand later by half compared to the original porting effort described in [6]. MPD 1.0.1\ncontains no traces of <varargs.h>.\nThe only patches \u2013 outside of implementing the context switching routines \u2013 were\nfor 64 bit cleanliness (see also [5]).\n\n3\n\nVerification methods\n\nMPD itself provides a verification suite for the whole system; also a small basic test for\nthe context switching primitives. There is no split between the basic and the extended\nverification suite, as in SR.\n\n3.1\n\nContext Switch Primitives\n\nThe context switch primitives can be independently tested by running make in the\nsubdirectory csw/ of the distribution; this builds and runs the cstest program, which\nimplements a small multithreaded program and checks for detection of stack overflows,\nstack underflows, correct context switching etc.[7] This test is automatically run when\nbuilding the whole system.\n\n3.2\n\nOverall System\n\nWhen the context switch primitives seem to work individually, they need to be tested\nintegrated into the run-time system. The SR and MPD authors provide a verification\nsuite in the vsuite/ subdirectory of the distributions to achieve this, as well as testing\nthe the building system used to build MPD, and the mpd compiler, mpdl linker, etc.\nIt is run by calling the driver script mpdv/mpdv, which provides options for selecting\nnormal vs. verbose output, as well as selecting the installed vs. the freshly compiled\nMPD system.\nFor all porting methods described below (assembler primitives, SVR4 system calls\nand NetBSD pthread library calls), the full verification suite has been run and any\nreported problem has been fixed.\n\n\fTest description\nloop control overhead\nlocal call, optimised\ninterresource call, no new process\ninterresource call, new process\nprocess create/destroy\nsemaphore P only\nsemaphore V only\nsemaphore pair\nsemaphore requiring context switch\nasynchronous send/receive\nmessage passing requiring context switch\nrendezvous\n\ni386 ASM\n0.002 \u03bcs\n0.011 \u03bcs\n0.270 \u03bcs\n0.650 \u03bcs\n0.540 \u03bcs\n0.011 \u03bcs\n0.008 \u03bcs\n0.019 \u03bcs\n0.110 \u03bcs\n0.300 \u03bcs\n0.400 \u03bcs\n0.600 \u03bcs\n\n. . . context u\n0.002 \u03bcs\n0.011 \u03bcs\n0.260 \u03bcs\n4.200 \u03bcs\n4.020 \u03bcs\n0.011 \u03bcs\n0.008 \u03bcs\n0.019 \u03bcs\n0.220 \u03bcs\n0.290 \u03bcs\n0.560 \u03bcs\n0.850 \u03bcs\n\nSVR4 s.c.\n0.002 \u03bcs\n0.011 \u03bcs\n0.250 \u03bcs\n4.350 \u03bcs\n4.280 \u03bcs\n0.011 \u03bcs\n0.008 \u03bcs\n0.019 \u03bcs\n1.550 \u03bcs\n0.300 \u03bcs\n1.920 \u03bcs\n4.200 \u03bcs\n\nTable 3: Run time system performance, system A (Pentium 4, 1600 MHz). The median\ntimes reported by the MPD script vsuite/timings/report.sh are shown.\n\n4\n\nPerformance evaluation\n\nMPD comes with two performance evaluation packages. The first, for the context\nswitching primitives, is in the csw/ subdirectory of the source distribution; after make\ncsloop you can start ./csloop N where N is the number of seconds the test will run\napproximately.\nTests of the language primitives used for multithreading are in the vsuite/timings/\nsubdirectory of the source tree enhanced with the verification suite. They are run by\nthree shell scripts used to compile them, executed them, and summarize the results in\na table.\n\n5\n\nEstablishing a baseline\n\nThere are two extremes possible when implementing the context switch primitives\nneeded for MPD: implementing each CPU manually in assembler code (what the MPD\nimplementation does normally) and using the SVR4-style functions getcontext(),\nsetcontext() and swapcontext() which operate on struct ucontext; these are provided as experimental code in the file csw/svr4.c of the MPD distribution.\nThe first tests were done by using the provided i386 assembler context switch routines. After verifying correctness and noting the times (see tables 2 and 3), the same\nwas done using the SVR4 module instead of the assembler module.\nThese tests were done on a Pentium 4 machine running at 1600 MHz with 2\nmegabytes of secondary cache, and 1 GB of main memory, running NetBSD-3.0 BETA\nas of end of October 2005.\nThe SVR4 tests were redone on a DNARD system (for its ARM cpu, no assembler\nstubs are provided in either the SR or MPD distributions).\nTable 3 shows a factor-of-about-ten performance hit for the operations that require\ncontext switches; note, however, that the absolute values for all such operations are still\nsmaller than 5 \u03bcs on 1600 MHz machine and will likely not be noticeable if a parallelized\nprogram is run on a LAN-coupled cluster: on the switched LAN connected to the test\nmachine, the time for an ICMP echo request to return is about 200 \u03bcs.\n\n\fTest description\nloop control overhead\nlocal call, optimised\ninterresource call, no new process\ninterresource call, new process\nprocess create/destroy\nsemaphore P only\nsemaphore V only\nsemaphore pair\nsemaphore requiring context switch\nasynchronous send/receive\nmessage passing requiring context switch\nrendezvous\n\nARM ASM\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\nn/a\n\n. . . context u\n0.057 \u03bcs\n0.376 \u03bcs\n4.300 \u03bcs\n27.250 \u03bcs\n25.240 \u03bcs\n0.304 \u03bcs\n0.254 \u03bcs\n0.506 \u03bcs\n1.570 \u03bcs\n5.550 \u03bcs\n6.740 \u03bcs\n9.600 \u03bcs\n\nSVR4 s.c.\n0.056 \u03bcs\n0.355 \u03bcs\n4.080 \u03bcs\n55.900 \u03bcs\n58.780 \u03bcs\n0.301 \u03bcs\n0.249 \u03bcs\n0.487 \u03bcs\n11.180 \u03bcs\n5.190 \u03bcs\n30.140 \u03bcs\n54.000 \u03bcs\n\nTable 4: Run time system performance, system B (StrongARM SA-110, 233 MHz). The\nmedian times reported by the MPD script vsuite/timings/report.sh are shown.\n\n6\n\nImprovements using NetBSD library calls\n\nWhile using the system calls getcontext and setcontext, as the svr4 module does,\nshould not unduly penalize an application distributed across a LAN, it might be noticeable with local applications.\nHowever, we should be able to do better than the svr4 module without writing our\nown assembler modules, since NetBSD 2.0 (and later) contains its own set of them for\nthe benefit of its native Posix threads library (libpthread), which does lots of context\nswitches within a kernel provided light weight process[8]. The primitives provided to\nlibpthread by its machine dependent part are the three functions getcontext u,\nsetcontext u and swapcontext u with similar signatures as the SVR4-style system\ncalls getcontext, setcontext and swapcontext.\nThere were a few difficulties that arose while pursuing this.\nFirst, on one architecture (i386) setcontext u and getcontext u are implemented by calling through a function pointer which is initialized depending on the\nFPU / CPU extension mode available on the particular CPU used (8087-mode vs.\nXMM). On this architecture, setcontext u and getcontext u are defined as macros\nin a private header file not installed. The developer in charge of the code has indicated\nthat he might implement public wrappers; until then, we have to check all available\nNetBSD architectures and copy the relevant code to our module csw/netbsd.c.\nSecond, we need to extract the relevant object modules from the threading library\nfor static linking (libpthread.a) without resolving any other symbols, because normal\nlibpthread is overloading some system calls thus causing failure of applications not\nproperly initializing it.\nAgain, this set of context switch code has been verified by running cstest and the\nfull verification suite.\nThe low-level as well as the high-level timings with the new context switch package\nhave again been collected in tables 2, 3 and 5.\nTo ease installation, a package for the NetBSD package system has been built for\nSR and MPD, available in the lang/sr and lang/mpd subdirectories of the pkgsrc root.\nAs the NetBSD package system is available for more operating systems than NetBSD[4], a lot more work would be needed to make the packages universal; thus they\nare restricted to be built on NetBSD 2.0 and later.\n\n\f7\n\nDiscussion\n\nOur new approach has raw context switch times that are only 10% of the SVR4 system\ncall ones. Compared to the assembler routines, they are only slower by a factor of 10\n(see table 2).\nTable 3 shows three classes of high level operations.\n1. Non-context switching operations have the same speed independent of the context\nswitch primitives used, as expected.\n2. The two operations measured requiring a process creation (in the MPD language\nsense) are about as fast as in the SVR4-system-call case. This was expected, as\nthe process creation primitive does a system call internally.\n3. Context switching operations which do not create a new process (in the MPD\nlanguage sense) are slower than in the assembler case, but faster than in the\nSVR4-style case, by an amount roughly equivalent to one (semaphore operation,\nmessage passing) or two (rendezvous) context switching primitive times.\nThe same classification can be done for the 233 MHz ARM CPU (table 5). However,\nSVR4 process creation, destruction and the rendezvous need about one third of the\nLAN two-way network latency, thus cannot be neglected anymore. We conclude that\nfor machines in the 300 MHz range and below, using assembler implementation (where\navailable) or at least our new implementation of the context switching primitives is a\nnecessity. This is also expected for even slower machines.\nMPD can be compiled in a mode where it will make use of multiple threads provided\nby the underlying OS, so that it can use more than one CPU of a single machine. This\nhas not been implemented yet for NetBSD, but should be.\n\n8\n\nSummary\n\nA method for porting SR and MPD to NetBSD has been shown, for which only preliminary results, and only for SR, were presented earlier.\nThe SR porting effort was easily adopted for the MPD case. In fact, the run time\nsystem (library and srx/mprx) could probably be factored out into a common run-time\nsystem package.\nThe new port was verified using the SR and MPD verification suites.\nAs discussed above, the SVR4-system-call approach, while feasible, creates an overhead that is clearly visible for non-networked operation of a distributed program; on\nour Pentium machine, high level context switching operations are slower by a factor\nbetween 7 and 11 (the raw context switch primitives are slower by a factor of 110).\nEven for networked operation, for a 233 MHz StrongArm CPU or slower machines,\ncontext switch latency exceeds one third of the network latency.\nThe approach using the libpthread primitives is much faster for all but the process\ncreation/destruction case and should thus be adequate for about any application in\nthe networked case, and for any in the single-machine case that does not do excessive\namounts of implicit or explicit process creation.\nFor highly communication-bound problems on a single machine, using the assembler\nprimitives might show a visible speedup, where available.\n\n\fReferences\n[1] Gregory R. Andrews, Foundations of Multithreaded, Parallel, and Distributed Programming, Addison-Wesley, 2000 (ISBN 0-201-35752-6)\n[2] Gregory R. Andrews and Ronald A. Olsson, The SR Programming Language:\nConcurrency in Practice, Benjamin/Cummings, 1993\n[3] Gregory R. Andrews, Ronald A. Olsson, Michael H. Coffin, Irving Elshoff, Kelvin\nD. Nilsen, Titus Purdin and Gregg M. Townsend, An Overview of the SR Language\nand Implementation, 1988, ACM TOPLAS Vol. 10.1, pp. 51 \u2013 86\n[4] Alistair G. Crooks, A portable package system, in: Proceedings of the 3rd European\nBSD Conference, Karlsruhe (Germany) 2004\n[5] Martin Husemann,\nFighting the Lemmings,\nin:\nthe 3rd European BSD Conference,\nKarlsruhe\nhttp://www.feyrer.de/PGC/Fighting the Lemmings.pdf\n\nProceedings of\n(Germany) 2004,\n\n[6] Ignatios Souvatzis, A machine-independent port of the SR language run time system to NetBSD, in: Proceedings of the 3rd European BSD Conference, Karlsruhe\n(Germany) 2004, arXiv:cs.DC/0411028\n[7] Gregg Townsend, Dave Bakken, Porting the SR Programming Language, 1994,\nDepartment of Computer Science, The University of Arizona\n[8] Nathan J. Williams, An Implementation of Scheduler Activations on\nthe NetBSD Operating System, in:\nProceedings of the FREENIX\nTrack, 2002 Usenix Annual Technical Conference, Monterey, CA, USA,\nhttp://www.usenix.org/events/usenix02/tech/freenix/williams.html\n\n\f"}