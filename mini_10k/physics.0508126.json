{"id": "http://arxiv.org/abs/physics/0508126v1", "guidislink": true, "updated": "2005-08-18T12:38:40Z", "updated_parsed": [2005, 8, 18, 12, 38, 40, 3, 230, 0], "published": "2005-08-18T12:38:40Z", "published_parsed": [2005, 8, 18, 12, 38, 40, 3, 230, 0], "title": "Fast Detector Simulation Using Lelaps, Detector Descriptions in GODL", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=physics%2F0508178%2Cphysics%2F0508205%2Cphysics%2F0508186%2Cphysics%2F0508174%2Cphysics%2F0508010%2Cphysics%2F0508013%2Cphysics%2F0508058%2Cphysics%2F0508219%2Cphysics%2F0508007%2Cphysics%2F0508033%2Cphysics%2F0508203%2Cphysics%2F0508165%2Cphysics%2F0508182%2Cphysics%2F0508036%2Cphysics%2F0508187%2Cphysics%2F0508168%2Cphysics%2F0508136%2Cphysics%2F0508097%2Cphysics%2F0508060%2Cphysics%2F0508090%2Cphysics%2F0508051%2Cphysics%2F0508071%2Cphysics%2F0508034%2Cphysics%2F0508170%2Cphysics%2F0508023%2Cphysics%2F0508118%2Cphysics%2F0508107%2Cphysics%2F0508093%2Cphysics%2F0508172%2Cphysics%2F0508044%2Cphysics%2F0508144%2Cphysics%2F0508067%2Cphysics%2F0508230%2Cphysics%2F0508035%2Cphysics%2F0508073%2Cphysics%2F0508190%2Cphysics%2F0508106%2Cphysics%2F0508156%2Cphysics%2F0508009%2Cphysics%2F0508173%2Cphysics%2F0508169%2Cphysics%2F0508210%2Cphysics%2F0508231%2Cphysics%2F0508063%2Cphysics%2F0508222%2Cphysics%2F0508237%2Cphysics%2F0508126%2Cphysics%2F0508095%2Cphysics%2F0508112%2Cphysics%2F0508091%2Cphysics%2F0508052%2Cphysics%2F0508057%2Cphysics%2F0508130%2Cphysics%2F0508202%2Cphysics%2F0508005%2Cphysics%2F0508221%2Cphysics%2F0508002%2Cphysics%2F0508235%2Cphysics%2F0508134%2Cphysics%2F0508131%2Cphysics%2F0508048%2Cphysics%2F0508098%2Cphysics%2F0508016%2Cphysics%2F0508029%2Cphysics%2F0508223%2Cphysics%2F0508041%2Cphysics%2F0508146%2Cphysics%2F0508160%2Cphysics%2F0508188%2Cphysics%2F0508148%2Cphysics%2F0508123%2Cphysics%2F0508031%2Cphysics%2F0508053%2Cphysics%2F0508149%2Cphysics%2F0508015%2Cphysics%2F0508064%2Cphysics%2F0508062%2Cphysics%2F0603240%2Cphysics%2F0603068%2Cphysics%2F0603239%2Cphysics%2F0603054%2Cphysics%2F0603022%2Cphysics%2F0603249%2Cphysics%2F0603081%2Cphysics%2F0603115%2Cphysics%2F0603212%2Cphysics%2F0603135%2Cphysics%2F0603228%2Cphysics%2F0603176%2Cphysics%2F0603127%2Cphysics%2F0603171%2Cphysics%2F0603213%2Cphysics%2F0603053%2Cphysics%2F0603144%2Cphysics%2F0603260%2Cphysics%2F0603003%2Cphysics%2F0603218%2Cphysics%2F0603270%2Cphysics%2F0603243%2Cphysics%2F0603269%2Cphysics%2F0603274&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Fast Detector Simulation Using Lelaps, Detector Descriptions in GODL"}, "summary": "Lelaps is a fast detector simulation program which reads StdHep generator\nfiles and produces SIO or LCIO output files. It swims particles through\ndetectors taking into account magnetic fields, multiple scattering and dE/dx\nenergy loss. It simulates parameterized showers in EM and hadronic calorimeters\nand supports gamma conversions and decays. In addition to three built-in\ndetector configurations, detector descriptions can also be read from files in\nthe new GODL file format.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=physics%2F0508178%2Cphysics%2F0508205%2Cphysics%2F0508186%2Cphysics%2F0508174%2Cphysics%2F0508010%2Cphysics%2F0508013%2Cphysics%2F0508058%2Cphysics%2F0508219%2Cphysics%2F0508007%2Cphysics%2F0508033%2Cphysics%2F0508203%2Cphysics%2F0508165%2Cphysics%2F0508182%2Cphysics%2F0508036%2Cphysics%2F0508187%2Cphysics%2F0508168%2Cphysics%2F0508136%2Cphysics%2F0508097%2Cphysics%2F0508060%2Cphysics%2F0508090%2Cphysics%2F0508051%2Cphysics%2F0508071%2Cphysics%2F0508034%2Cphysics%2F0508170%2Cphysics%2F0508023%2Cphysics%2F0508118%2Cphysics%2F0508107%2Cphysics%2F0508093%2Cphysics%2F0508172%2Cphysics%2F0508044%2Cphysics%2F0508144%2Cphysics%2F0508067%2Cphysics%2F0508230%2Cphysics%2F0508035%2Cphysics%2F0508073%2Cphysics%2F0508190%2Cphysics%2F0508106%2Cphysics%2F0508156%2Cphysics%2F0508009%2Cphysics%2F0508173%2Cphysics%2F0508169%2Cphysics%2F0508210%2Cphysics%2F0508231%2Cphysics%2F0508063%2Cphysics%2F0508222%2Cphysics%2F0508237%2Cphysics%2F0508126%2Cphysics%2F0508095%2Cphysics%2F0508112%2Cphysics%2F0508091%2Cphysics%2F0508052%2Cphysics%2F0508057%2Cphysics%2F0508130%2Cphysics%2F0508202%2Cphysics%2F0508005%2Cphysics%2F0508221%2Cphysics%2F0508002%2Cphysics%2F0508235%2Cphysics%2F0508134%2Cphysics%2F0508131%2Cphysics%2F0508048%2Cphysics%2F0508098%2Cphysics%2F0508016%2Cphysics%2F0508029%2Cphysics%2F0508223%2Cphysics%2F0508041%2Cphysics%2F0508146%2Cphysics%2F0508160%2Cphysics%2F0508188%2Cphysics%2F0508148%2Cphysics%2F0508123%2Cphysics%2F0508031%2Cphysics%2F0508053%2Cphysics%2F0508149%2Cphysics%2F0508015%2Cphysics%2F0508064%2Cphysics%2F0508062%2Cphysics%2F0603240%2Cphysics%2F0603068%2Cphysics%2F0603239%2Cphysics%2F0603054%2Cphysics%2F0603022%2Cphysics%2F0603249%2Cphysics%2F0603081%2Cphysics%2F0603115%2Cphysics%2F0603212%2Cphysics%2F0603135%2Cphysics%2F0603228%2Cphysics%2F0603176%2Cphysics%2F0603127%2Cphysics%2F0603171%2Cphysics%2F0603213%2Cphysics%2F0603053%2Cphysics%2F0603144%2Cphysics%2F0603260%2Cphysics%2F0603003%2Cphysics%2F0603218%2Cphysics%2F0603270%2Cphysics%2F0603243%2Cphysics%2F0603269%2Cphysics%2F0603274&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Lelaps is a fast detector simulation program which reads StdHep generator\nfiles and produces SIO or LCIO output files. It swims particles through\ndetectors taking into account magnetic fields, multiple scattering and dE/dx\nenergy loss. It simulates parameterized showers in EM and hadronic calorimeters\nand supports gamma conversions and decays. In addition to three built-in\ndetector configurations, detector descriptions can also be read from files in\nthe new GODL file format."}, "authors": ["Willy Langeveld"], "author_detail": {"name": "Willy Langeveld"}, "author": "Willy Langeveld", "arxiv_comment": "10 pages, 4 figures, presented at the Linear Collider Workshop\n  LCWS'05, Stanford, CA, March 2005", "links": [{"href": "http://arxiv.org/abs/physics/0508126v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/physics/0508126v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "physics.ins-det", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "physics.ins-det", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/physics/0508126v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/physics/0508126v1", "journal_reference": "ECONFC050318:1006,2005", "doi": null, "fulltext": "2005 International Linear Collider Workshop - Stanford, U.S.A.\n\nFast Detector Simulation Using Lelaps, Detector Descriptions in GODL\nWilly Langeveld\n\narXiv:physics/0508126v1 [physics.ins-det] 18 Aug 2005\n\nSLAC, Stanford, CA 94025, USA\n\nLelaps is a fast detector simulation program which reads StdHep generator files and produces SIO or LCIO output\nfiles. It swims particles through detectors taking into account magnetic fields, multiple scattering and dE/dx energy\nloss. It simulates parameterized showers in EM and hadronic calorimeters and supports gamma conversions and\ndecays. In addition to three built-in detector configurations, detector descriptions can also be read from files in the\nnew GODL file format.\n\n1. INTRODUCTION\nLelaps is a fast detector simulation that swims particles through detectors with magnetic fields, accounting for\nmultiple scattering and energy loss. It produces parameterized showers in EM and hadronic calorimeters, supports\ndecays of certain short-lived particles (\"V\" decays) and converts gammas. Lelaps performance is on the order of 1\ntypical (e.g. ZZ) event/second at 1 GHz, with everything turned on and writing an LCIO output file.\nLelaps consists of a set of C++ class libraries and a main program, which itself is called lelaps. The main class\nlibrary is called CEPack, the actual simulation toolkit. It reads StdHep generator files and produces SIO or LCIO\noutput files. Lelaps has built-in support for LDMar01, SDJan03 and SDMar04. It also reads detector geometries in\nthe new GODL format.\nFor details on Lelaps, see references [1] and [2]. In the next section, a brief reminder is provided. The rest of this\npaper gives an introduction to the GODL detector description language.\n\n2. A LELAPS REMINDER\nThe main class library for Lelaps is called CEPack and it contains the simulation tool kit. It deals with geometry,\nmaterials and tracking particles through the geometry while taking into account magnetic fields, multiple scattering,\nenergy loss, parameterized showers in EM and hadronic calorimeters, particle decays and gamma conversions. A\nLelaps-simulated ZZ event in the SiD detector is shown in figure 1. The same event simulated in the LD detector is\nshown in figure 2.\n\n2.1. Materials\nSpecifying materials is very easy in Lelaps. All elements are built in with default pressure and temperature for\ngasses or density for solids and liquids. Any compound can be specified by chemical formula and density or (for\ngasses) temperature and pressure. Mixtures can be created by mixing elements and compounds by volume or by\nweight. All needed quantities are calculated automatically. This includes constants needed for multiple scattering\nand energy loss, radiation lengths, interaction lengths and constants needed for shower parameterization.\nThe Lelaps distribution comes with a little program called matprop that allows one to view various material\nproperties. An online version of matprop is available [3].\n1006\n\n\fFigure 1: ZZ event in the SiD detector, as simulated by Lelaps.\n\nFigure 2: ZZ event in the LD detector, as simulated by Lelaps.\n\n2.2. Multiple Scattering and Energy Loss\nTracking is performed by taking steps along a linear trajectory with endpoints on a helix, such that the sagitta\nstays below a certain maximum. After each step, the amount of material traversed is checked: if enough material was\ntraversed, multiple scattering and energy loss is performed and track parameters are updated. When an intersection\noccurs within a step, the fractional step is executed, the volume is entered, and the remaining fraction of the step\nfollows.\nMultiple scattering is performed using the algorithm of Lynch and Dahl [4]. Material is saved up along the track\nuntil there is enough. dE/dx is calculated using the methods by Sternheimer and Peierls [5]. All constants are\nprecalculated by the material classes.\n\n2.3. Shower Parameterization\nElectromagnetic showers are parameterized using the algorithms of Grindhammer and Peters [6]. Calorimeters are\ntreated as homogeneous media. The longitudinal shower profile is given by a gamma distribution with coefficients\ndepending on the material (Z) and energy. The profiles are fluctuated and correlations between the coefficients are\ntaken into account.\nFor each step of one radiation length, a radial profile is computed consisting of two distributions, one describing\n1006\n\n\fFigure 3: Comparison of longitudinal shower distribution as simulated by Geant4 and Lelaps.\n\nFigure 4: Pictures of an \u03a9\u2212 decay and a gamma conversion as simulated by Lelaps.\n\nthe core of the shower and the other the tail. The energy to be deposited is divided into spots thrown in radius\naccording to the radial profile, and uniformly in \u03c6. Roughly, about 400 spots are generated per GeV of shower energy\nand reported as hits.\nHadronic showers are parameterized in a similar way, with some modifications. The location where the shower\nstarts is simulated using an exponential law with attenuation given by the interaction length. The longitudinal profile\nuses the Bock parameterization [7]. A combination of two gamma distributions, one using radiation lengths and the\nother interaction lengths, is used. The Bock parameterization does not specify radial profiles. For the moment we\nuse a radial profile similar to Grindhammer and Peters (for EM showers) but with radiation lengths replaced by\ninteraction lengths and faster spread with depth. The parameters still need to be fine-tuned.\nThese parameterizations were compared to results from Geant4 [8]. In general pretty good agreement was found\nfor EM showers (see figure 3). Hadronic showers agree pretty well longitudinally, but not as well radially. Hadronic\nshower parameterization has been tweaked since then, but needs further work.\n\n2.4. Decays and Gamma Conversions\nCEPack supports decays of unstable particles and gamma conversions. Supported unstable particles are \u03c0 0 , Ks0 ,\n\u039b, \u03a3+/\u2212/0 , \u039e\u2212,0 and \u03a9\u2212 . Only decay modes with branching fractions greater than 2% are supported (mostly \"V\ndecays\"). See figure 4.\n1006\n\n\f3. GENERALIZED OBJECT DESCRIPTION LANGUAGE (GODL)\nA new feature in Lelaps is the ability to read in detector descriptions written in a new language called GODL.\nThis language was especially designed to describe all aspects of detector geometry, materials, detector-subdetector\nrelationships, as well as the output formats for any hits produced in sensitive parts of the detectors. We will start\nwith a subsection on the features of GODL and conclude with the current status of implementation.\n\n3.1. Features\nGODL is a more or less complete programming language with variables and operations. This means that one does\nnot have to hard-code dimensions and locations but can instead compute dimensions and locations from previously\ndefined ones. GODL has control constructs (loops, if) which make repetitive operations easier. There are built-in\nmath functions, which allows calculating derived quantities (e.g. the tangent of an angle). The language is human\nreadable and editable (like XML but more so) and portable (since it is in plain text). The interpreter catches mistakes\n(like XML but better).\nGODL knows about units and enforces them. For example, one can mix microns and meters. One can define\nnew units based on built-in ones and use them. The interpreter enforces consistent usage of units in operations and\nfunction calls.\nGODL has list objects. Built-in objects describe materials, objects, placements etc. GODL supports volume\nhierarchies. This saves simulation time by allowing embedding of sub-detector elements into mother volumes. GODL\nallows specification of arbitrary calorimeter segmentation and encoding of tracker and calorimeter ID's. For this, it\nhas a built-in, PostScript-like, parser which \"compiles\" a suitable ID code specification to byte-code for fast execution.\nThis allows one to change encoding and/or segmentation without modifying the simulator source code.\nGODL supports levels of detail. This allows one to use a low level of detail for fast simulation and higher level of\ndetail for full simulation, all encoded in the same GODL source file.\nGODL comes with a simple API which currently comprises 11 virtual methods, which are all fully implemented in\nLelaps. Lelaps comes with a GODL-to-HepRep converter (these HepReps require the newest Wired4 for viewing).\nA Geant4 implementation is planned.\nGODL supports (in principle) all Geant4 solid types (with the possible exception of BREPS). Not all of them\nare implemented at this time, but it would be easy to do. And finally, GODL supports (in principle) combinatorial\n(\"boolean\") geometry (\"CSG\" in Geant4). This is not yet implemented, but should be straightforward.\n\n3.2. Variables and Arrays\nGODL is an extensible typeless programming language. Type is determined by assignment:\na\nb\nc\nd\n\n=\n=\n=\n=\n\n2.4;\n2;\n\"text\";\ntrue;\n\n#\n#\n#\n#\n\nreal\ninteger\nstring\nboolean\n\nIt has variables and operations that can be performed on them:\na\nb\nd\ne\nb\n\n+= 1;\n= a * 12;\n= c + \" more text\";\n= false;\n= e != true;\n\nIt also supports array-like constructs:\n1006\n\n\fi = 5; foo.i = 12;\n\n#\n\nSame as foo.5 = 12;\n\nThese arrays are much like \"stem\" variables in REXX.\n\n3.3. Operators\nGODL supports the following set of operators, although some cannot be used in some contexts:\n+ - * / = += -= *= /= == < > <= >= != ! && ||\nThe meaning of these operators is just like in C. Note the absence of ++ and \u2212\u2212 operators.\nThere is also a reference operator @:\na = 12;\nb = @a; print(b, \"\\n\");\nwhich would print out:\n@a->(12)\nThis is useful for referencing objects multiple times without recreating them, see later.\n\n3.4. Built-in Functions\nGODL knows about the usual set of math functions:\nexp, log, sqrt, pow, cos, sin, tan, acos, asin, atan, atan2, cosh, sinh, tanh,\nacosh, asinh, atanh, log10, abs, fabs, ceil, floor and mod.\nIn addition there is a list function:\na = list(a, b, c, d);\n\n# Creates unnamed list\n\nand a print function:\nprint(a, \"\\n\");\nprint(a, \"\\n\", b, \"\\n\");\nIt is possible to use a GODL parser as a \"shell\". When arguments are provided, argc and argv work more or less\nlike they do in C.\nThere is also a \"unit\" function, see later.\n\n3.5. Control Constructs\nGODL has a limited set of C-style control constructs:\nfor (i = 0; i < 25; i += 1) {\nwhile (true) {\n...\nif (something) break;\n}\nif (a < b) {\n1006\n\n...\n\n}\n\n...\n\n}\n\n\f3.6. List Objects\nVariables can be list objects. To construct a generic list with name \"foo\":\na = foo(a, b, c, d);\nLists can contain objects of any type, including other lists. To add objects to a list:\na += e;\na += f;\nNote that this is not necessarily the same as:\na += e + f;\nwhich would first add f to e and then the result to a. If e and f are list objects, this adds to \"a\" a single list \"e\"\nwhich in turn contains \"f\".\nNote that the GODL parser built into Lelaps will disallow any named lists whose names do not match one of the\nset of lists it recognizes (see later).\n\n3.7. Units\nVariables can have units, and units are enforced across operations and in arguments to function calls and list\nobjects:\nm = _meter;\nunit(\"m\");\na = 2 m;\nb = 12 * a;\narea = a * b;\narea += 5;\nd = cos(area);\n\n# _meter is a built-in unit\n# Declare as unit\n\n# Error: incorrect units\n# Error: cos() only takes angles\n\nAvailable basic units are (like CLHEP):\n_meter, _second, _joule, _coulomb, _kelvin, _mole, _candela, _radian, and _steradian.\nBuilt-in units derived from these are:\n_angstrom, _parsec, _barn, _degree, _hertz, _becquerel, _curie, _electronvolt,\n_gram, _watt, _newton, _pascal, _bar, _atmosphere, _ampere, _volt, _ohm,\n_farad, _weber, _tesla, _gauss, _henry, _gray, _lumen, and _lux.\nOne can create new units:\nm = _meter; g = _gram; # For convenience\nunit(\"m\", \"g\")\n# Declare as units\ngcc = g/cm3;\n# New unit of density\nunit(\"gcc\");\n# Declare\nSI prefixes and powers are automatically converted:\na = 1 cm2;\n\n# = 0.0001 _meter squared\n\nThere are some built-in constants:\n_pi (3.14...) (has units of rad)\n_e_SI\n(electron charge, 1.6...10-19 C)\n_e (2.71...) (dimensionless)\n1006\n\n\f3.8. Miscellaneous Functions and Variables\nFor debugging, there are two functions:\nverbose\n__printvars\n\nprints a lot of debugging information to stdout\nprints a list of all variables to stdout\n\nFurther, there are some control variables for the print() function:\nprintlevel_: (default 1) controls how much information to print (mostly for for object lists).\nprecision_: controls how many digits are displayed for floating point numbers.\nfieldwidth_: controls how much space a printed number takes up.\n\n3.9. Materials\nMaterials are declared using the element, material or mixture list objects (note the use of the @ operator to pass\nby reference):\nSi\nvacuum\nO2\nTyvek\nAir\n\n=\n=\n=\n=\n=\n\nelement(\"Si\");\nmaterial(\"vacuum\");\nmaterial(formula(\"O2\"), pressure(1.0 atm), temperature(293.15 K));\nmaterial(name(\"Tyvek\"), formula(\"CH2CH2\"), density(0.935 g/cm3));\nmixture(part(@O2, 20.946), part(@N2, 78.084), part(@Ar, 0.934), by(\"volume\"));\n\n3.10. Volumes and Placements\nIn order to construct a geometry, we first define a World Volume:\nWorld = cylinder(radius(700.0 cm), length(14.0 m), @vacuum);\nTo define another volume we use, for example:\nem_ec_irad\nem_b_irad\nem_b_orad\nem_sampfrac\n\n=\n=\n=\n=\n\n21.0 cm;\nem_ec_orad + 2.0 cm;\nem_b_irad + em_thickness;\n0.02664;\n\nem_ec_orad\nem_thickness\nem_nlayers\nem_b_length\n\n=\n=\n=\n=\n\n125.0 cm;\n15 cm;\n30;\n368.0 cm;\n\nEM_Barrel = cylinder(name(\"EM Barrel\"), innerRadius(em_b_irad), outerRadius(em_b_orad),\nlength(em_b_length), @SiW, type(\"emcal\"), nLayers(em_nlayers),\nsamplingFraction(em_sampfrac));\nNow we add this to World using a placement:\nWorld += placement(@EM_Barrel);\nWe can use loops to do repetitive tasks and if statements for conditionals:\nVertex_Barrel = cylinder(name(\"Vertex Barrel\"), innerRadius(v_irad),\nouterRadius(v_orad), length(v_lenmax));\nfor (i = 1; i <= v_nlayers; i += 1) {\nvlen = v_leninner;\nif (i > 1) vlen = v_lenmax;\nVertex_Barrel.i = cylinder(name(\"Vertex Barrel \" + i), ... );\nVertex_Barrel += placement(@Vertex_Barrel.i); # Notice hierarchy\n}\nWorld += placement(@Vertex_Barrel);\n\n1006\n\n\fTable I: Level of detail specification syntax\nLevel syntax:\n<not specified>\n\nCreate object when: Used for:\nalways\n\nFundamental objects that are always present\n\nlevel(min(2))\n\nlevel \u2265 2\n\nDetailed objects that should not be simulated\nat lower levels\n\nlevel(max(4))\n\nlevel \u2264 4\n\nFundamental objects that are replaced with other\nobjects at higher levels\n\nlevel(min(2), max(4))\nlevel(range(2, 4))\nlevel(mask(0x1C))\n\n2 \u2264 level \u2264 4\n\nCombinations: objects relevant only in a\ncertain level range\n\n3.11. Levels of Detail\nTo specify levels of detail we use the \"level\" tag:\nHad_Endcap = cylinder(name(\"Had Endcap\"), level(1), ...);\nHad_Endcap += placement(@something, ..., level(max(0)), ...);\nHad_Endcap += placement(@something_else, ..., level(min(1)), ...);\nWorld += placement(@Had_Endcap, translate(0, 0, 0.5 * (had_b_length - had_thickness)));\nWorld += placement(@Had_Endcap, rotate(axis(\"y\"), angle(180 degrees)),\ntranslate(0, 0, -0.5 * (had_b_length - had_thickness)));\nThe full level syntax is described in table I.\n\n3.12. ID Calculation\nID calculation (such as CalorimeterID and TrackerID) is generally used for two purposes: to specify segmentation\nof a detector-hits with the same ID are combined to a single energy deposition-and to specify an abbreviated\nversion of the location of an energy deposition. The problem is: how can one change the amount or method of\nsegmentation without changing the C++ source code of the simulator? One solution is the ability to specify the\nsegmentation method in the geometry file and \"interpret\" it inside the simulator. The GODL API provides a simple,\nfast, interpreter to do that. In fact, it \"compiles\" the segmentation specification into byte-code, and runs the byte\ncode for each hit during the simulation. In practice, this is fast enough to not cause a significant overall performance\nhit.\nAs an example let us consider tracker IDs. For the Vertex detector barrel we would use:\nVertex_Barrel.i = cylinder(name(\"VXD\"), ...,\nidCode(code(tb_code), data(\"system\", 1), data(\"id\", i - 1)));\nThe ID calculation in idCode is specified as a string in a \"code\" list object. The algorithm for the vertex and barrel\ntrackers is:\ntb_code = \"x: fp0 y: fp1 z: fp2 layer: d3 id z H 0x40000000 mul or system 28 bitshift\nor stop\"\nFor the tracker end cap it is:\n\"x: fp0 y: fp1 z: fp2 layer: d3 id 0x80000000 or z H 0x40000000 mul or system 28 bitshift\nor stop\";\n1006\n\n\fHere, \"x: fp0\" means that the API routine that evaluates the byte code associated with the above, expects x to be\ngiven in the first floating point \"register\". Similarly, \"layer\" is provided as an integer in the fourth register.\nThe code itself is a reverse polish, PostScript-like, language with some limitations and some extras: some named\nvariables must be provided by the simulator as standard arguments (x, y, z, layer), and some named variables are\nprovided using \"data\" object lists in the specification. In the above, H is the Heaviside step function: 1 if the\nargument is positive, 0 otherwise. The language includes a standard set of math functions that may be used.\nThere is slightly more work for the calorimeter ID's. For the end caps we have:\ncal_code_ec = \"x x mul y y mul add sqrt z atan2 theta_seg mul _pi div \" + standard_code;\nFor the barrel we have:\ncal_code_b = \"x x mul y y mul add sqrt z atan2 cos 1.0 add theta_seg mul 2.0 div \"\n+ standard_code;\nwhere standard code is:\nstandard_code = \"truncate 11 bitshift y x atan2m phi_seg mul 0.5 mul _pi div truncate\nor layer 21 bitshift or system 28 bitshift or stop\";\nHere, atan2m is the same as atan2, except that the result is given in the range 0 to 2\u03c0. We have to add standard\nargument specifications to this, for example:\ncal_code_ec = \"x: fp0 y: fp1 z: fp2 layer: d3 \" + cal_code_ec;\n\n3.13. GODL API\nThe GODL API consists of four classes: GODLParser, MCode, MStack and MVar. There are (currently) 11 virtual\nfunctions that the API implementer must write. For example:\nvirtual int constructCylinder(\nconst char\n*nameForFutureReference,\nconst char\n*objectName,\ndouble\ninnerRadius,// length units: meter\ndouble\nouterRadius,\ndouble\nlength,\nconst char\n*materialRefName,\nconst char\n*type,\nint\nnLayers,\nint\nnSlices,\ndouble\nsamplingFraction,\nconst MStack &IDCode)\nOther functions that must be implemented are:\nconstructCone(...),\naddField(...), addPlacement(...),\nconstructPlacement(...),\nrotate(...),\ntranslate(...), constructElement(...), constructCompound(...),\nconstructMixture(...), addMixture(...)\nThe API reads the GODL file (which typically has extension .godl) and calls the \"construct\" routines to construct\nobjects and placements. It then calls rotate and translate on the placements, and addMixtures to add materials to\nthe mixtures. Finally it calls addPlacement to instantiate an actual placement of an object.\n1006\n\n\f3.14. Status\nThe GODL parser and evaluator are essentially complete and the API layer to access the volume list exists.\nGODL was first completely implemented in Lelaps V03-23-26, including levels of detail and hit ID calculation.\nGODL representations of the SDMar04 and SDJan03 detectors exist, the latter with two different levels of detail.\nAs mentioned, a GODL-to-HepRep converter exists and comes with the Lelaps distribution.\n\n4. FUTURE\nNew features that are planned for Lelaps1 /CEPack include support for combinatorial geometry and the ability\nfor shower continuation into the next volume. More tuning of hadronic showers is needed. For GODL, planned\nnew features include adding the remaining standard geometrical shapes and implementing support for combinatorial\ngeometry\n\nAcknowledgments\nThis work was supported by Department of Energy contract DE-AC02-76SF00515.\n\nReferences\n[1] W.G.J. Langeveld, \"Fast detector simulation using Lelaps\", SLAC-PUB-10663 and arXiv:physics/0408108, Submitted to Proceedings of the International Conference on Linear Colliders (LCWS '04), Paris, France, 19-24 April\n2004.\n[2] http://lelaps.freehep.org/index.html\n[3] http://www.slac.stanford.edu/comp/physics/matprop.html\n[4] Gerald R. Lynch and Orin I. Dahl, Nucl. Instr. Meth. B58 (1991) 6.\n[5] R.M. Sternheimer and R.F. Peierls, Phys. Rev. B3 (1971) 3681.\n[6] G. Grindhammer and S. Peters, arXiv:hep-ex/0001020v1 (2000).\n[7] R.K. Bock, T. Hansl-Kozanecka and T.P. Shah, Nucl. Instr. And Meth. 186 (1981) 533.\n[8] D. Birt, A. Nicholson, W. Langeveld, D. Wright, SLAC-TN-03-005, Aug 2003.\n\n1 Lelaps (storm wind) was a dog with such speed that, once set upon a chase, he could not fail to catch his prey. Having forged him\nfrom bronze, Hephaestus gave him to Zeus, who in turn gave him to Athena, the goddess of the hunt. Athena gave Lelaps as a wedding\npresent to Procris, daughter of Thespius, and the new bride of famous hunter Cephalus. A time came when a fox created havoc for the\nshepherds in Thebes. The fox had the divine property that its speed was so great that it could not be caught. Procris sent Lelaps to\ncatch the fox. But because both were divine creatures, a stalemate ensued, upon which Zeus turned both into stone. Feeling remorse,\nZeus elevated Lelaps to the skies, where he now shines as the constellation Canis Major, with Sirius as the main star.\n\n1006\n\n\f"}