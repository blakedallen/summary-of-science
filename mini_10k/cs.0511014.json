{"id": "http://arxiv.org/abs/cs/0511014v1", "guidislink": true, "updated": "2005-11-03T13:40:22Z", "updated_parsed": [2005, 11, 3, 13, 40, 22, 3, 307, 0], "published": "2005-11-03T13:40:22Z", "published_parsed": [2005, 11, 3, 13, 40, 22, 3, 307, 0], "title": "Flat and One-Variable Clauses: Complexity of Verifying Cryptographic\n  Protocols with Single Blind Copying", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0511003%2Ccs%2F0511065%2Ccs%2F0511030%2Ccs%2F0511045%2Ccs%2F0511007%2Ccs%2F0511086%2Ccs%2F0511100%2Ccs%2F0511051%2Ccs%2F0511040%2Ccs%2F0511066%2Ccs%2F0511058%2Ccs%2F0511048%2Ccs%2F0511090%2Ccs%2F0511064%2Ccs%2F0511102%2Ccs%2F0511059%2Ccs%2F0511052%2Ccs%2F0511105%2Ccs%2F0511063%2Ccs%2F0511020%2Ccs%2F0511053%2Ccs%2F0511011%2Ccs%2F0511035%2Ccs%2F0511026%2Ccs%2F0511093%2Ccs%2F0511037%2Ccs%2F0511019%2Ccs%2F0511041%2Ccs%2F0511103%2Ccs%2F0511082%2Ccs%2F0511106%2Ccs%2F0511076%2Ccs%2F0511027%2Ccs%2F0511002%2Ccs%2F0511074%2Ccs%2F0511085%2Ccs%2F0511099%2Ccs%2F0511008%2Ccs%2F0511056%2Ccs%2F0511024%2Ccs%2F0511060%2Ccs%2F0511039%2Ccs%2F0511022%2Ccs%2F0511080%2Ccs%2F0511013%2Ccs%2F0511067%2Ccs%2F0511062%2Ccs%2F0511073%2Ccs%2F0511025%2Ccs%2F0511012%2Ccs%2F0511014%2Ccs%2F0511091%2Ccs%2F0511089%2Ccs%2F0511078%2Ccs%2F0511042%2Ccs%2F0511055%2Ccs%2F0511097%2Ccs%2F0511032%2Ccs%2F0511077%2Ccs%2F0511088%2Ccs%2F0511016%2Ccs%2F0608088%2Ccs%2F0608004%2Ccs%2F0608110%2Ccs%2F0608049%2Ccs%2F0608118%2Ccs%2F0608065%2Ccs%2F0608075%2Ccs%2F0608102%2Ccs%2F0608035%2Ccs%2F0608059%2Ccs%2F0608076%2Ccs%2F0608067%2Ccs%2F0608078%2Ccs%2F0608124%2Ccs%2F0608012%2Ccs%2F0608097%2Ccs%2F0608036%2Ccs%2F0608071%2Ccs%2F0608043%2Ccs%2F0608109%2Ccs%2F0608058%2Ccs%2F0608034%2Ccs%2F0608042%2Ccs%2F0608090%2Ccs%2F0608113%2Ccs%2F0608121%2Ccs%2F0608083%2Ccs%2F0608047%2Ccs%2F0608079%2Ccs%2F0608087%2Ccs%2F0608011%2Ccs%2F0608041%2Ccs%2F0608040%2Ccs%2F0608100%2Ccs%2F0608031%2Ccs%2F0608091%2Ccs%2F0608103%2Ccs%2F0608032%2Ccs%2F0608115%2Ccs%2F0608114&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Flat and One-Variable Clauses: Complexity of Verifying Cryptographic\n  Protocols with Single Blind Copying"}, "summary": "Cryptographic protocols with single blind copying were defined and modeled by\nComon and Cortier using the new class $\\mathcal C$ of first order clauses. They\nshowed its satisfiability problem to be in 3-DEXPTIME. We improve this result\nby showing that satisfiability for this class is NEXPTIME-complete, using new\nresolution techniques. We show satisfiability to be DEXPTIME-complete if\nclauses are Horn, which is what is required for modeling cryptographic\nprotocols. While translation to Horn clauses only gives a DEXPTIME upper bound\nfor the secrecy problem for these protocols, we further show that this secrecy\nproblem is actually DEXPTIME-complete.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0511003%2Ccs%2F0511065%2Ccs%2F0511030%2Ccs%2F0511045%2Ccs%2F0511007%2Ccs%2F0511086%2Ccs%2F0511100%2Ccs%2F0511051%2Ccs%2F0511040%2Ccs%2F0511066%2Ccs%2F0511058%2Ccs%2F0511048%2Ccs%2F0511090%2Ccs%2F0511064%2Ccs%2F0511102%2Ccs%2F0511059%2Ccs%2F0511052%2Ccs%2F0511105%2Ccs%2F0511063%2Ccs%2F0511020%2Ccs%2F0511053%2Ccs%2F0511011%2Ccs%2F0511035%2Ccs%2F0511026%2Ccs%2F0511093%2Ccs%2F0511037%2Ccs%2F0511019%2Ccs%2F0511041%2Ccs%2F0511103%2Ccs%2F0511082%2Ccs%2F0511106%2Ccs%2F0511076%2Ccs%2F0511027%2Ccs%2F0511002%2Ccs%2F0511074%2Ccs%2F0511085%2Ccs%2F0511099%2Ccs%2F0511008%2Ccs%2F0511056%2Ccs%2F0511024%2Ccs%2F0511060%2Ccs%2F0511039%2Ccs%2F0511022%2Ccs%2F0511080%2Ccs%2F0511013%2Ccs%2F0511067%2Ccs%2F0511062%2Ccs%2F0511073%2Ccs%2F0511025%2Ccs%2F0511012%2Ccs%2F0511014%2Ccs%2F0511091%2Ccs%2F0511089%2Ccs%2F0511078%2Ccs%2F0511042%2Ccs%2F0511055%2Ccs%2F0511097%2Ccs%2F0511032%2Ccs%2F0511077%2Ccs%2F0511088%2Ccs%2F0511016%2Ccs%2F0608088%2Ccs%2F0608004%2Ccs%2F0608110%2Ccs%2F0608049%2Ccs%2F0608118%2Ccs%2F0608065%2Ccs%2F0608075%2Ccs%2F0608102%2Ccs%2F0608035%2Ccs%2F0608059%2Ccs%2F0608076%2Ccs%2F0608067%2Ccs%2F0608078%2Ccs%2F0608124%2Ccs%2F0608012%2Ccs%2F0608097%2Ccs%2F0608036%2Ccs%2F0608071%2Ccs%2F0608043%2Ccs%2F0608109%2Ccs%2F0608058%2Ccs%2F0608034%2Ccs%2F0608042%2Ccs%2F0608090%2Ccs%2F0608113%2Ccs%2F0608121%2Ccs%2F0608083%2Ccs%2F0608047%2Ccs%2F0608079%2Ccs%2F0608087%2Ccs%2F0608011%2Ccs%2F0608041%2Ccs%2F0608040%2Ccs%2F0608100%2Ccs%2F0608031%2Ccs%2F0608091%2Ccs%2F0608103%2Ccs%2F0608032%2Ccs%2F0608115%2Ccs%2F0608114&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Cryptographic protocols with single blind copying were defined and modeled by\nComon and Cortier using the new class $\\mathcal C$ of first order clauses. They\nshowed its satisfiability problem to be in 3-DEXPTIME. We improve this result\nby showing that satisfiability for this class is NEXPTIME-complete, using new\nresolution techniques. We show satisfiability to be DEXPTIME-complete if\nclauses are Horn, which is what is required for modeling cryptographic\nprotocols. While translation to Horn clauses only gives a DEXPTIME upper bound\nfor the secrecy problem for these protocols, we further show that this secrecy\nproblem is actually DEXPTIME-complete."}, "authors": ["Helmut Seidl", "Kumar Neeraj Verma"], "author_detail": {"name": "Kumar Neeraj Verma"}, "author": "Kumar Neeraj Verma", "arxiv_comment": "Long version of paper presented at LPAR 2004", "links": [{"href": "http://arxiv.org/abs/cs/0511014v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0511014v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0511014v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0511014v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:cs/0511014v1 [cs.LO] 3 Nov 2005\n\nFlat and One-Variable Clauses: Complexity of\nVerifying Cryptographic Protocols with Single\nBlind Copying\nHelmut Seidl Kumar Neeraj Verma\nInstitut f\u00fcr Informatik, TU M\u00fcnchen, Germany\n{seidl,verma}@in.tum.de\nSeptember 13, 2018\nAbstract\nCryptographic protocols with single blind copying were defined and modeled\nby Comon and Cortier using the new class C of first order clauses. They showed\nits satisfiability problem to be in 3-DEXPTIME. We improve this result by showing that satisfiability for this class is NEXPTIME-complete, using new resolution\ntechniques. We show satisfiability to be DEXPTIME-complete if clauses are Horn,\nwhich is what is required for modeling cryptographic protocols. While translation\nto Horn clauses only gives a DEXPTIME upper bound for the secrecy problem for\nthese protocols, we further show that this secrecy problem is actually DEXPTIMEcomplete.\n\n1 Introduction\nSeveral researchers have pursued modeling of cryptographic protocols using first order\nclauses [3, 6, 17] and related formalisms like tree automata and set constraints[5, 12,\n13]. While protocol insecurity is NP-complete in case of a bounded number of sessions\n[16], this is helpful only for detecting some attacks. For certifying protocols, the number of sessions cannot be bounded, although we may use other safe abstractions. The\napproach using first order clauses is particularly useful for this class of problems. A\ncommon safe abstraction is to allow a bounded number of nonces, i.e. random numbers,\nto be used in infinitely many sessions. Security however still remains undecidable [5].\nHence further restrictions are necessary to obtain decidability.\nIn this direction, Comon and Cortier [6, 8] proposed the notion of protocols with\nsingle blind copying. Intuitively this restriction means that agents are allowed to copy\nat most one piece of data blindly in any protocol step, a restriction satisfied by most\nprotocols in the literature. Comon and Cortier modeled the secrecy problem for these\nprotocols using the new class C of first order clauses, and showed satisfiability for C\nto be decidable [6] in 3-DEXPTIME [8]. The NEXPTIME lower bound is easy. We\n\n1\n\n\fshow in this paper that satisfiability of this class is in NEXPTIME, thus NEXPTIMEcomplete. If clauses are restricted to be Horn, which suffices for modeling of cryptographic protocols, we show that satisfiability is DEXPTIME-complete (again the lower\nbound is easy). While translation to clauses only gives a DEXPTIME upper bound for\nthe secrecy problem for this class of protocols, we further show that the secrecy problem for these protocols is also DEXPTIME-complete.\nFor proving our upper bounds, we introduce several variants of standard ordered\nresolution with selection and splitting [2]. Notably we consider resolution as consisting\nof instantiation of clauses, and of generation of propositional implications. This is in\nthe style of Ganzinger and Korovin [10], but we adopt a slightly different approach, and\ngenerate interesting implications to obtain optimal complexity. More precisely, while\nthe approach of [10], emphasizes a single phase of instantiation followed by propositional satisfiability checking, we interleave generation of interesting instantiations and\npropositional implications in an appropriate manner to obtain optimal complexity. We\nfurther show how this technique can be employed also in presence of rules for replacement of literals in clauses, which obey some ordering constraints. To deal with the\nnotion of single blind copying we show how terms containing a single variable can be\ndecomposed into simple terms whose unifiers are of very simple forms. As byproducts,\nwe obtain optimal complexity for several subclasses of C, involving so called flat and\none-variable clauses.\nOutline: We start in Section 2 by recalling basic notions about first order logic and\nresolution refinements. In Section 3 we introduce cryptographic protocols with single\nblind copying, discuss their modeling using the class C of first order clauses, and show\nthat their secrecy problem is DEXPTIME-hard. To decide the class C we gradually\nintroduce our techniques by obtaining DEXPTIME-completeness and NEXPTIMEcompleteness for one-variables clauses and flat clauses in Sections 4 and 5 respectively.\nIn Section 6, the techniques from the two cases are combined with further ideas to show\nthat satisfiability for C is NEXPTIME-complete. In Section 7 we adapt this proof to\nshow that satisfiability for the Horn fragment of C is DEXPTIME-complete.\n\n2 Resolution\nWe recall standard notions from first order logic. Fix a signature \u03a3 of function symbols\neach with a given arity, and containing at least one zero-ary symbol. Let r be the maximal arity of function symbols in \u03a3. Fix a set X = {x1 , x2 , x3 , . . .} of variables. Note\nthat x1 , x2 , . . . (in bold face) are the actual elements of X, where as x, y, z, x1 , y1 , . . .\nare used to represent arbitrary elements of X. The set T\u03a3 (X) of terms built from \u03a3\nand X is defined as usual. T\u03a3 is the set of ground terms, i.e. those not containing\nany variables. Atoms A are of the form P (t1 , . . . , tn ) where P is an n-ary predicate\nand ti 's are terms. Literals L are either positive literals +A (or simply A) or negative\nliterals \u2212A, where A is an atom. \u2212(\u2212A) is another notation for A. \u00b1 denotes + or\n\u2212 and \u2213 denotes the opposite sign (and similarly for notations \u00b1\u2032 , \u2213\u2032 , . . .). A clause\nis a finite set of literals. A negative clause is one which contains only negative literals. If M is any term, literal or clause then the set fv(M ) of variables occurring in\nthem is defined as usual. If C1 and C2 are clauses then C1 \u2228 C2 denotes C1 \u222a C2 .\n2\n\n\fC \u2228 {L} is written as C \u2228 L (In this notation, we allow the possibility of L \u2208 C).\nIf C1 , . . . , Cn are clauses such that fv(Ci ) \u2229 fv(Cj ) = \u2205 for i 6= j, and if Ci is nonempty for i \u2265 2, then the clause C1 \u2228 . . . \u2228 Cn is also written as C1 \u2294 . . . \u2294 Cn to\nemphasize this property. Ground literals and clauses are ones not containing variables.\nA term, literal or clause is trivial if it contains no function symbols. A substitution\nis a function \u03c3 : X \u2192 T\u03a3 (X). Ground substitutions map every variable to a ground\nterm. We write \u03c3 = {x1 7\u2192 t1 , . . . , xn 7\u2192 tn } to say that xi \u03c3 = ti for 1 \u2264 i \u2264 n\nand x\u03c3 = x for x \u2208\n/ {x1 , . . . , xn }. If M is a term, literal, clause, substitution or\nset of such objects, then the effect M \u03c3 of applying \u03c3 to M is defined as usual. Renamings are bijections \u03c3 : X \u2192 X. If M is a term, literal, clause or substitution,\nthen a renaming of M is of the form M \u03c3 for some renaming \u03c3, and an instance of\nM is of the form M \u03c3 for some substitution \u03c3. If M and N are terms or literals then\na unifier of M and N is a substitution \u03c3 such that M \u03c3 = N \u03c3. If such a unifier exists then there is also a most general unifier (mgu), i.e. a unifier \u03c3 such that for every\nunifier \u03c3 \u2032 of M and N , there is some \u03c3 \u2032\u2032 such that \u03c3 \u2032 = \u03c3\u03c3 \u2032\u2032 . Most general unifiers\nare unique upto renaming: if \u03c31 and \u03c32 are two mgus of M and N then \u03c31 is a renaming of \u03c32 . Hence we may use the notation mgu(M, N ) to denote one of them.\nWe write M [x1 , . . . , xn ] to say that fv(M ) \u2286 {x1 , . . . , xn }. If t1 , . . . , tn are terms\nthen M [t1 , . . . , tn ] denotes M {x1 7\u2192 t1 , . . . , xn 7\u2192 tn }. If N is a set of terms them\nM [N ] = {M [t1 , . . . , tnS] | t1 , . . . , tn \u2208 N }. If M is a set of terms, atoms, literals or\nclauses them M [N ] = m\u2208M m[N ]. A Herbrand interpretation H is a set of ground\natoms. A clause C is satisfied in H if for every ground substitution \u03c3, either A \u2208 H\nfor some A \u2208 C\u03c3, or A \u2208\n/ H for some \u2212A \u2208 C\u03c3. A set S of clauses is satisfied in H\nif every clause of S is satisfied in H. If such a H exists then S is satisfiable, and H is\na Herbrand model of S. A Horn clause is one containing at most one positive literal.\nIf a set of Horn clauses is satisfiable then it has a least Herbrand model wrt the subset\nordering.\nResolution and its refinements are well known methods for testing satisfiability of\nclauses. Given a strict partial order < on atoms, a literal \u00b1A is maximal in a clause\nC if there is no literal \u00b1\u2032 B \u2208 C with A < B. Binary ordered resolution and ordered\nfactorization wrt ordering < are defined by the following two rules respectively:\nC1 \u2228 A\n\n\u2212 B \u2228 C2\n\nC1 \u2228 \u00b1A \u2228 \u00b1B\n\nC1 \u03c3 \u2228 C2 \u03c3\n\nC1 \u03c3 \u2228 A\u03c3\n\nwhere \u03c3 = mgu(A, B) in both rules, A and B are maximal in the left and right\npremises respectively of the first rule, and A and B are both maximal in the premise of\nthe second rule. We rename the premises of the first rule before resolution so that they\ndon't share variables. The ordering < is stable if: whenever A1 < A2 then A1 \u03c3 < A2 \u03c3\nfor all substitutions \u03c3. We write S \u21d2< S \u222a {C} to say that C is obtained by one application of the binary ordered resolution or binary factorization rule on clauses in S (the\nsubscript denotes the ordering used).\nAnother resolution rule is splitting. This can be described using tableaux. A\ntableau is of the form S1 | . . . | Sn , where n \u2265 0 and each Si , called a branch\nof the tableau, is a set of clauses (the | operator is associative and commutative). A\ntableau is satisfiable if at least one of its branches is satisfiable. The tableau is called\n3\n\n\fclosed if each Si contains the empty clause, denoted \u2737. The splitting step on tableaux\nis defined by the rule\nT | S \u2192spl T | (S \\ {C1 \u2294 C2 }) \u222a {C1 } | (S \\ {C1 \u2294 C2 }) \u222a {C2 }\nwhenever C1 \u2294C2 \u2208 S and C1 and C2 are non-empty. C1 and C2 are called components\nof the clause C1 \u2294C2 being split. It is well known that splitting preserves satisfiability of\ntableaux. We may choose to apply splitting eagerly, or lazily or in some other fashion.\nHence we define a splitting strategy to be a function \u03c6 such that T \u2192spl \u03c6(T ) for all\ntableaux T . The relation \u21d2< is extended to tableaux as expected. Ordered resolution\nwith splitting strategy is then defined by the rule\nT1 \u21d2<,\u03c6 \u03c6(T2 ) whenever T1 \u21d2< T2\nThis provides us with a well known sound and complete method for testing satisfiability. For any binary relation R, R\u2217 denotes the reflexive transitive closure of R, and R+\ndenotes the transitive closure of R.\nLemma 1 For any set S of clauses, for any stable ordering <, and for any splitting\nstrategy \u03c6, S is unsatisfiable iff S \u21d2\u2217<,\u03c6 T for some closed T .\nIf all predicates are zero-ary then the resulting clauses are propositional clauses. In\nthis case we write S \u000fp T to say that every Herbrand model of S is a Herbrand model\nof T . This notation will also be used when S and T are sets of first order clauses,\nby treating every (ground or non-ground) atom as a zero-ary predicate. For example\n{P (a), \u2212P (a)} \u000fp \u2737 but {P (x), \u2212P (a)} 2p \u2737. S \u000fp {C} is also written as S \u000fp C.\nIf S \u000fp C then clearly S\u03c3 \u000fp C\u03c3 for all substitution \u03c3.\n\n3 Cryptographic Protocols\nWe assume that \u03a3 contains the binary functions { } and h , i denoting encryption and\npairing. Messages are terms of T\u03a3 (X). A state is of the form S(M1 , . . . , Mn ) where\nS with arity n is from a finite set of control points and Mi are messages. It denotes\nan agent at control point S with messages Mi in its memory. An initialization state is\na state not containing variables. We assume some strict partial order < on the set of\ncontrol points. A protocol rule is of the form\nS1 (M1 , . . . , Mm ) : recv(M ) \u2192 S2 (N1 , . . . , Nn ) : send(N )\nwhere S1 < S2 , Mi , Nj are messages, and M and N are each either a message, or a\ndummy symbol ? indicating nothing is received (resp. sent). For secrecy analysis we\ncan replace ? by some public message, i.e. one which is known to everyone including the adversary. The rule says that an agent in state S1 (M1 , . . . , Mm ) can receive\nmessage M , send a message N , and then move to state S2 (N1 , . . . , Nn ), thus also\nmodifying the messages in its memory. A protocol is a finite set of initialization states\nand protocol rules. This model is in the style of [9] and [5]. The assumption of single\nblind copying then says that each protocol rule contains at most one variable (which\n4\n\n\fmay occur anywhere any number of times in that rule). For example, the public-key\nNeedham-Schroeder protocol\nA \u2192 B : {A, NA }KB\nB \u2192 A : {NA , NB }KB\nA \u2192 B : {NB }KB\nis written in our notation as follows. For every pair of agents A and B in our system\n(finitely many of them suffice for finding all attacks against secrecy [7, 6]) we have\n1\n2\ntwo nonces NAB\nand NAB\nto be used in sessions where A plays the initiator's role\n1\nand B plays the responder's role. We have initialization states Init0 (A, NAB\n) and\n2\nResp0 (B, NAB ) for all agents A and B. Corresponding to the three lines in the protocol\nwe have rules for all agents A and B\n1\n1\n1\nInit0 (A, NAB\n):recv(?)\n\u2192\nInit1 (A, NAB\n):send({hA, NAB\ni}KB )\n2\n2\n2\nResp0 (B, NAB ):recv({hA, xi}KB ) \u2192Resp1 (B, x, NAB ):send({hx, NAB i}KA )\n1\n1\n1\n, x):send({x}KB )\nInit1 (A, NAB\n):recv({hNAB\n, xi}KA )\u2192 Init2 (A, NAB\n2\n2\n2\n\u2192Resp2 (B, x, NAB\n):send(?)\nResp1 (B, x, NAB ):recv({NAB }KB )\n\nAny initialization state can be created any number of times and any protocol rule\ncan be executed any number of times. The adversary has full control over the network: all messages received by agents are actually sent by the adversary and all messages sent by agents are actually received by the adversary. The adversary can obtain new messages from messages he knows, e.g. by performing encryption and decryption. To model this using Horn clauses, we create a unary predicate reach to\nmodel reachable states, and a unary predicate known to model messages known to\nthe adversary. The initialization state S(M1 , . . . , Mn ) is then modeled by the clause\nreach(S(M1 , . . . , Mn )), where S is a new function symbol we create. The protocol\nrule\nS1 (M1 , . . . , Mm ) : recv(M ) \u2192 S2 (N1 , . . . , Nn ) : send(N )\nis modeled by the clauses\nknown(N ) \u2228 \u2212reach(S1 (M1 , . . . , Mm )) \u2228 \u2212known(M )\nreach(S2 (N1 , . . . , Nn )) \u2228 \u2212reach(S1 (M1 , . . . , Mm )) \u2228 \u2212known(M )\nUnder the assumption of single blind copying it is clear that all these clauses are onevariable clauses, i.e. clauses containing at most one variable. We need further clauses\nto express adversary capabilities. The clauses\nknown({x1 }x2 ) \u2228 \u2212known(x1 ) \u2228 \u2212known(x2 )\nknown(x1 ) \u2228 \u2212known({x1 }x2 ) \u2228 \u2212known(x2 )\nexpress the encryption and decryption abilities of the adversary. We have similar\nclauses for his pairing and unpairing abilities, as well as clauses\nknown(f (x1 , . . . , xn )) \u2228 \u2212known(x1 ) \u2228 . . . \u2228 \u2212known(xn )\n\n5\n\n\ffor any function f that the adversary knows to apply. All these are clearly flat clauses,\ni.e. clauses of the form\nC=\n\nk\n_\n\n\u00b1i Pi (fi (xi1 , . . . , xini ))\n\n\u2228\n\nl\n_\n\n\u00b1j Qj (xj )\n\nj=1\n\ni=1\n\nwhere {xi1 , . . . , xini } = fv(C) for 1 \u2264 i \u2264 k. Asymmetric keys, i.e. keys K such\nthat message {M }K can only be decrypted with the inverse key K \u22121 , are also easily\ndealt with using flat and one-variable clauses. The adversary's knowledge of other\ndata c like agent's names, public keys, etc are expressed by clauses known(c). Then\nthe least Herbrand model of this set of clauses describes exactly the reachable states\nand the messages known to the adversary. Then to check whether some message M\nremains secret, we add the clause \u2212known(M ) and check whether the resulting set is\nsatisfiable.\nA set of clauses is in the class V1 if each of its members is a one-variable clause. A\nset of clauses is in the class F if each of its members is a flat clause. More generally\nwe have the class C proposed by Comon and Cortier [6, 8]: a set of clauses S is in the\nclass C if for each C \u2208 S one of the following conditions is satisfied.\n1. C is a one-variable clause\nWl\nWk\n2. C = i=1 \u00b1i Pi (ui [fi (xi1 , . . . , xini )]) \u2228 j=1 \u00b1j Qj (xj ), where for 1 \u2264 i \u2264 k\nwe have {xi1 , . . . , xini } = fv(C) and ui contains at most one variable.\nIf all clauses are Horn then we have the corresponding classes V1 Horn, F Horn and\nCHorn. Clearly the classes V1 (resp. V1 Horn) and F (resp. F Horn) are included\nin the class C (resp. CHorn) since the ui 's above can be trivial. Conversely any\nclause set in C can be considered as containing just flat and one-variable clauses.\nThis is because we can replace a clause C \u2228 \u00b1P (u[f (x1 , . . . , xn )]) by the clause\nC \u2228 \u00b1P u(f (x1 , . . . , xn )) and add clauses \u2212P u(x) \u2228 P (u[x]) and P u(x) \u2228 \u2212P (u[x])\nwhere P u is a fresh predicate. This transformation takes polynomial time and preserves satisfiability of the clause set. Hence now we need to deal with just flat and\none-variable clauses. In the rest of the paper we derive optimal complexity results for\nall these classes.\nStill this only gives us an upper bound for the secrecy problem of protocols since\nthe clauses could be more general than necessary. It turns out, however, that this is not\nthe case. In order to show this we rely on a reduction of the reachability problem for\nalternating pushdown systems (APDS). In form of Horn clauses, an APDS is a finite set\nof clauses of the form\n(i) P (a) where a is a zero-ary symbol\n(ii) P (s[x]) \u2228 \u2212Q(t[x]) where s and t involve only unary function symbols, and\n(iii) P (x) \u2228 \u2212P1 (x) \u2228 \u2212P2 (x)\nGiven any set S of definite clauses (i.e. Horn clauses having some positive literal), a\nground atom A is reachable if A is in the least Herbrand model of S, i.e. if S \u222a{\u2212A} is\n6\n\n\funsatisfiable. Reachability in APDS is DEXPTIME-hard [4]. We encode this problem\ninto secrecy of protocols, as in [9]. Let K be a (symmetric) key not known to the\nadversary. Encode atoms P (t) as messages {hP, ti}K , by treating P as some data.\nCreate initialization states S1 and S2 (no message is stored in the states). Clauses (i-iii)\nabove are translated as\nS1 : recv(?)\nS1 : recv({hQ, t[x]i}K )\nS1 : recv(h{hP1 , xi}K , {hP2 , xi}K i)\n\n\u2192 S2 : send({hP, ai}K )\n\u2192 S2 : send({hP, s[x]i}K )\n\u2192 S2 : send({hP, xi}K )\n\nThe intuition is that the adversary cannot decrypt messages encrypted with K. He also\ncannot encrypt messages with K. He can only forward messages which are encrypted\nwith K. However he has the ability to pair messages. This is utilized in the translation\nof clause (iii). Then a message {M }K is known to the adversary iff M is of the form\nhP, ti and P (t) is reachable in the APDS.\nTheorem 1 Secrecy problem for cryptographic protocols with single blind copying,\nwith bounded number of nonces but unbounded number of sessions is DEXPTIMEhard, even if no message is allowed to be stored at any control point.\n\n4 One Variable Clauses: Decomposition of Terms\nWe first show that satisfiability for the classes V1 and V1 Horn is DEXPTIME-complete.\nWe recall also that although we consider only unary predicates, this is no restriction in the case of one-variable clauses, since we can encode atoms P (t1 , . . . , tn ) as\nP \u2032 (fn (t1 . . . , tn )) for fresh P \u2032 and fn for every P of arity n. As shown in [6, 8], ordered resolution on one-variable clauses, for a suitable ordering, leads to a linear bound\non the height of terms produced. This does not suffice for obtaining a DEXPTIME upper bound and we need to examine the forms of unifiers produced during resolution.\nWe consider terms containing at most one variable (call them one-variable terms) to\nbe compositions of simpler terms. A non-ground one-variable term t[x] is called reduced if it is not of the form u[v[x]] for any non-ground non-trivial one-variable terms\nu[x] and v[x]. The term f (g(x), h(g(x))) for example is not reduced because it can be\nwritten as f (x, h(x))[g(x)]. The term f \u2032 (x, g(x), a) is reduced. Unifying it with the\nreduced term f \u2032 (h(y), g(h(a)), y) produces ground unifier {x 7\u2192 h(y)[a], y 7\u2192 a} and\nboth h(y) and a are strict subterms of the given terms. Indeed we find:\nLemma 2 Let s[x] and t[y] be reduced, non-ground and non-trivial terms where x 6= y\nand s[x] 6= t[x]. If s and t have a unifier \u03c3 then x\u03c3, y\u03c3 \u2208 U [V ] where U is the set\nof non-ground (possibly trivial) strict subterms of s and t, and V is the set of ground\nstrict subterms of s and t.\nProof: See Appendix A.\nIn case both terms (even if not reduced) have the same variable we have the following easy result:\nLemma 3 Let \u03c3 be a unifier of two non-trivial, non-ground and distinct one-variable\nterms s[x] and t[x]. Then x\u03c3 is a ground strict subterm of s or of t.\n7\n\n\fProof: See Appendix A.\nIn the following one-variable clauses are simplified to involve only reduced terms.\nLemma 4 Any non-ground one-variable term t[x] can be uniquely written as t[x] =\nt1 [t2 [. . . [tn [x]] . . .]] where n \u2265 0 and each ti [x] is non-trivial, non-ground and reduced. This decomposition can be computed in time polynomial in the size of t.\nProof: We represent t[x] as a DAG by doing maximal sharing of subterms. If t[x] = x\nthen the result is trivial. Otherwise let N be the position in this graph, other than the\nroot node, closest to the root such that N lies on every path from the root to the node\ncorresponding to the subterm x. Let t\u2032 be the strict subterm of t at position N and let\nt1 be the term obtained from t by replacing the sub-DAG at N by x. Then t = t1 [t\u2032 ]\nand t1 is reduced. We then recursively decompose t\u2032 .\nUniqueness of decomposition follows from Lemma 2.\n\u2737\nAbove and elsewhere, if n = 0 then t1 [t2 [. . . [tn [x]] . . .]] denotes x. Now if a\nclause set contains a clause C = C \u2032 \u2228 \u00b1P (t[x]), with t[x] being non-ground, if\nt[x] = t1 [. . . [tn [x]] . . .] where each ti is non-trivial and reduced, then we create\nfresh predicates P t1 . . . ti for 1 \u2264 i \u2264 n \u2212 1 and replace C by the clause C \u2032 \u2228\n\u00b1P t1 . . . tn\u22121 (tn [x]). Also we add clauses P t1 . . . ti (ti+1 [x]) \u2228 \u2212P t1 . . . ti+1 (x) and\n\u2212P t1 . . . ti (ti+1 [x])\u2228P t1 . . . ti+1 (x) for 0 \u2264 i \u2264 n\u22122 to our clause set. Note that the\npredicates P t1 . . . ti are considered invariant under renaming of terms tj . For i = 0,\nP t1 . . . ti is same as P . Our transformation preserves satisfiability of the clause set. By\nLemma 4 this takes polynomial time and eventually all non-ground literals in clauses\nare of the form \u00b1P (t) with reduced t. Next if the clause set is of the form S\u222a{C1 \u222aC2 },\nwhere C1 is non-empty and has only ground literals, and C2 is non-empty and has only\nnon-ground literals, then we do splitting to produce S \u222a {C1 } | S \u222a {C2 }. This process produces at most exponentially many branches each of which has polynomial size.\nNow it suffices to decide satisfiability of each branch in DEXPTIME. Hence now we\nassume that each clause is either:\n(Ca) a ground clause, or\n(Cb) a clause containing exactly one variable, each of whose literals is of the form\n\u00b1P (t[x]) where t is non-ground and reduced.\nConsider a set S of clauses of type Ca and Cb. We show how to decide satisfiability of\nthe set S. Wlog we assume that all clauses in S of type Cb contain the variable x1 . Let\nNg be the set of non-ground terms t[x1 ] occurring as arguments in literals in S. Let\nNgs be the set of non-ground subterms t[x1 ] of terms in Ng. We assume that Ng and\nNgs always contain the trivial term x1 , otherwise we add this term to both sets. Let\nG be the set of ground subterms of terms occurring as arguments in literals in S. The\nsizes of Ng, Ngs and G are polynomial. Let S \u2020 be the set of clauses of type Ca and Cb\nwhich only contain literals of the form \u00b1P (t) for some t \u2208 Ng \u222a Ng[Ngs[G]] (observe\nthat G \u2286 Ngs[G] \u2286 Ng[Ngs[G]]). The size of S \u2020 is at most exponential.\nFor resolution we use ordering \u227a: P (s) \u227a Q(t) iff s is a strict subterm of t. We\ncall \u227a the subterm ordering without causing confusion. This is clearly stable. This is\nthe ordering that we are going to use throughout this paper. In particular this means\nthat if a clause contains literals \u00b1P (x) and \u00b1\u2032 Q(t) where t is non-trivial and contains\n8\n\n\fx, then we cannot choose the literal \u00b1P (x) to resolve upon in this clause. Because of\nthe simple form of unifiers of reduced terms we have:\nLemma 5 Binary ordered resolution and ordered factorization, wrt the subterm ordering, on clauses in S \u2020 produces clauses which are again in S \u2020 (upto renaming).\nProof: Factorization on a ground clause doesn't produce any new clause. Now suppose\nwe factorize the non-ground clause C[x1 ] \u2228 \u00b1P (s[x1 ]) \u2228 \u00b1P (t[x1 ]) to produce the\nclause C[x1 ]\u03c3 \u2228 \u00b1P (s[x1 ])\u03c3 where \u03c3 = mgu(s[x1 ], t[x1 ]). If the premise has only\ntrivial literals then factorization is equivalent to doing nothing. Otherwise by ordering\nconstraints, s and t are non-trivial. By Lemma 3 either s[x1 ] = t[x1 ] in which case\nfactorization does nothing, or x1 \u03c3 is a ground subterm of s[x1 ] or of t[x1 ]. In the latter\ncase all literals in (C[x1 ]\u2228P (s[x1 ])\u03c3 are of the form \u00b1\u2032 Q(t\u2032 [x1 ]\u03c3)) where t\u2032 [x1 ] \u2208 Ng\nand x1 \u03c3 \u2208 G \u2286 Ngs[G].\nNow we consider binary resolution steps. We have the following cases:\n\u2022 If both clauses are ground then the result is clear.\n\u2022 Now consider both clauses C1 [x1 ] and C2 [x1 ] to be non-ground. Before resolution we rename the second clause to obtain C2 [x2 ]. Clearly all literals in\nC1 [x1 ] and C2 [x1 ] are of the form \u00b1Q(u[x1 ]) where u[x1 ] \u2208 Ng. Let C1 [x1 ] =\nC1\u2032 [x1 ] \u2228 P (s[x1 ]) and C2 [x2 ] = \u2212P (t[x2 ]) \u2228 C2\u2032 [x2 ] where P (s[x1 ]) and\n\u2212P (t[x2 ]) are the literals to be resolved upon in the respective clauses. If s[x1 ]\nand t[x2 ] are unifiable then from Lemma 2, one of the following cases hold:\n\u2013 s[x1 ] = x1 (the case where t[x2 ] = x2 is treated similarly). From the definition of \u227a, for P (s[x1 ]) to be chosen for resolution, all literals in C1\u2032 [x1 ]\nare of the form \u00b1Q(x1 ). The resolvent is C[x2 ] = C1\u2032 [x1 ]\u03c3 \u222a C2\u2032 , where\n\u03c3 = {x1 7\u2192 t[x2 ]}. Each literal in C1\u2032 [x1 ]\u03c3 is of the form \u00b1Q(t[x2 ]) and\neach literal in C2\u2032 [x2 ] is of the form \u00b1Q(t\u2032 [x2 ]) where t\u2032 \u2208 Ng. Hence\nC[x1 ] \u2208 S \u2020 .\n\u2013 s[x1 ] = t[x1 ]. Then the resolvent is C1\u2032 [x1 ] \u2228 C2\u2032 [x1 ].\n\u2013 s[x1 ] and t[x2 ] have a mgu \u03c3 such that x1 \u03c3, x2 \u03c3 \u2208 Ngs[G]. The resolvent\nC1\u2032 [x1 ]\u03c3 \u2228 C2\u2032 [x2 ]\u03c3 has only ground atoms of the form \u00b1Q(t\u2032 ) where t\u2032 \u2208\nNg[Ngs[G]].\n\u2022 Now let the first clause C1 [x1 ] = C1\u2032 [x1 ] \u2228 \u00b1P (t[x1 ]) be non-ground, and the\nsecond clause C2 = \u2213P (s) \u2228 C2\u2032 be ground with \u00b1P (t[x1 ]) and \u2213P (s) being\nthe respective literals chosen from C1 [x1 ] and C2 for resolution. All literals in\nC1 [x1 ] are of the form \u00b1\u2032 Q(t\u2032 [x1 ]) with t\u2032 \u2208 Ng. All literals in C2 are of the\nform \u00b1\u2032 Q(t\u2032 ) with t\u2032 \u2208 Ng[Ngs[G]]. Suppose that s and t[x1 ] do unify. We have\nthe following cases:\n\u2013 s \u2208 Ngs[G]. Then the resolvent C = C1\u2032 [x1 ]\u03c3 \u222a C2\u2032 where \u03c3 = {x1 7\u2192 g}\nwhere g is subterm of s. As s \u2208 Ngs[G] hence g \u2208 Ngs[G]. Hence all\nliterals in C1\u2032 [x1 ]\u03c3 are of the form \u00b1Q(t\u2032 ) where t\u2032 \u2208 Ng[Ngs[G]]. Hence\nC \u2208 S \u2020.\n9\n\n\f\u2013 Now suppose s \u2208 Ng[Ngs[G]] \\ Ngs[G]. We must have s = s1 [s2 ] for some\nnon-trivial s1 [x1 ] \u2208 Ng and some s2 \u2208 Ngs[G]. This is the interesting case\nwhich shows why the terms remain in the required form during resolution.\nThe resolvent is C = C1\u2032 [x1 ]\u03c3 \u2228 C2\u2032 where \u03c3 = {x1 7\u2192 g} is the mgu\nof t[x1 ] and s for some ground term g. As t[g] = s1 [s2 ], \u03c31 = {x1 7\u2192\ng, x2 7\u2192 s2 } is a unifier of the terms t[x1 ] and s1 [x2 ]. By Lemma 2 we\nhave the following cases:\n\u2217 t[x1 ] = x1 , so that g = s \u2208 Ng[Ngs[G]]. By definition of \u227a, for\n\u00b1P (t[x1 ]) to be chosen for resolution, all literals in C1 [x1 ] must be of\nthe form \u00b1\u2032 Q(x1 ). Hence all literals in C1\u2032 \u03c3 are of the form \u00b1\u2032 Q(g).\nHence C \u2208 S \u2020 .\n\u2217 t[x1 ] = s1 [x1 ]. Then g = s2 \u2208 Ngs[G]. Hence all literals in C1\u2032 \u03c3 are\nof the form \u00b1\u2032 Q(t\u2032 [g]) where t\u2032 [x1 ] \u2208 Ng. Hence C \u2208 S \u2020 .\n\u2217 g = x1 \u03c3 \u2208 Ngs[G]. Hence all literals in C1\u2032 \u03c3 are of the form \u00b1\u2032 Q(t\u2032 [g])\nwhere t\u2032 \u2208 Ng. Hence C \u2208 S \u2020 .\n\u2737\nHence to decide satisfiability of S \u2286 S \u2020 , we keep generating new clauses of S \u2020\nby doing ordered binary resolution and ordered factorization wrt the subterm ordering\ntill no new clause can be generated, and then check whether the empty clause has been\nproduced. Also recall that APDS consist of Horn one-variable clauses. Hence:\nTheorem 2 Satisfiability for the classes V1 and V1 Horn is DEXPTIME-complete.\n\n5 Flat Clauses: Resolution Modulo Propositional Reasoning\nNext we show how to decide the class F of flat clauses in NEXPTIME. This is well\nknown when the maximal arity r is a constant, or when all non-trivial literals in a clause\nhave the same sequence (instead of the same set) of variables. But we are not aware\nof a proof of NEXPTIME upper bound in the general case. We show how to obtain\nNEXPTIME upper bound in the general case, by doing resolution modulo propositional reasoning. While this constitutes an interesting result of its own, the techniques\nallow us to deal with the full class C efficiently. Also this shows that the generality of the class C does not cost more in terms of complexity. An \u01eb-block is a onevariable clause which contains only trivial literals. A complex clause C is a flat clause\nWl\nWk\ni\ni\ni=1 \u00b1i Pi (fi (x1 , . . . , xni )) \u2228 j=1 \u00b1j Qj (xj ) in which k \u2265 1. Hence a flat clause is\neither a complex clause, or an \u01eb-clause which is defined to be a disjunction of \u01eb-blocks,\ni.e. to be of the form B1 [x1 ] \u2294 . . . \u2294 Bn [xn ] where each Bi is an \u01eb-block. \u01eb-clauses are\ndifficult to deal with, hence we split them to produce \u01eb-blocks. Hence define \u01eb-splitting\nas the restriction of the splitting rule in which one of the components is an \u01eb-block.\nRecall that r is the maximal arity of symbols in \u03a3. Upto renaming, any complex\nclause C is such that fv(C) \u2286 Xr = {x1 , . . . , xr }, and any \u01eb-block C is such that\nfv(C) \u2286 {xr+1 }. The choice of xr+1 is not crucial. Now notice that ordered resolution\nbetween complex clauses and \u01eb-blocks only produces flat clauses, which can then be\n\n10\n\n\fsplit to be left with only complex and \u01eb-blocks. E.g. Resolution between\nP1 (x1 ) \u2228 \u2212P2 (x2 ) \u2228 P3 (f (x1 , x2 )) \u2228 \u2212P4 (g(x2 , x1 ))\nand\nP4 (g(x1 , x1 )) \u2228 \u2212P5 (h(x1 )) \u2228 P6 (x1 )\nproduces\nP1 (x1 ) \u2228 \u2212P2 (x1 ) \u2228 P3 (f (x1 , x1 )) \u2228 \u2212P5 (h(x1 )) \u2228 P6 (x1 )\nResolution between\nP2 (xr+1 )\n\nand\n\n\u2212 P2 (f (x1 , x2 )) \u2228 P3 (x1 ) \u2228 P4 (x2 )\n\nproduces P3 (x1 )\u2228P4 (x2 ) which can then be split. The point is that we always choose a\nnon-trivial literal from a clause for resolution, if there is one. As there are finitely many\ncomplex clauses and \u01eb-blocks this gives us a decision procedure. Note however that the\nnumber of complex clauses is doubly exponential. This is because we allow clauses\nof the form P1 (f1 (x1 , x1 , x2 )) \u2228 P2 (f2 (x2 , x1 )) \u2228 P3 (f3 (x2 , x1 , x2 )) \u2228 ..., i.e. the\nnontrivial terms contain arbitrary number of repetitions of variables in arbitrary order.\nThe number of such variable sequences of r variables is exponentially many, hence the\nnumber of clauses is doubly exponential. Letting the maximal arity r to be a constant,\nor forcing all non-trivial literals in a clause to have the same variable sequence would\nhave produced only exponentially many clauses. In presence of splitting, this would\nhave given us the well-known NEXPTIME upper bound, which is also optimal. But\nwe are not aware of a proof of NEXPTIME upper bound in the general case. To obtain\nNEXPTIME upper bound in the general case we introduce the technique of resolution\nmodulo propositional reasoning.\nFor a clause C, define the set of its projections as \u03c0(C) = C[Xr ]. Essentially\nprojection involves making certain variables in a clause equal. As we saw, resolution between two complex clauses amounts to propositional resolution between their\nprojections. Define the set U = {f (x1 , . . . , xn ) | f \u2208 \u03a3 and each xi \u2208 Xr } of size exponential in r. Resolution between \u01eb-block C1 and a good complex clause C2 amounts\nto propositional resolution of a clause from C[U] with C2 . Also note that propositional\nresolution followed by further projection is equivalent to projection followed by propositional resolution. Each complex clause has exponentially many projections. This suggests that we can compute beforehand the exponentially many projections of complex\nclauses and exponentially many instantiations of \u01eb-blocks. All new complex clauses\ngenerated by propositional resolution are ignored. But after several such propositional\nresolution steps, we may get an \u01eb-clause, which should then be split and instantiated\nand used for obtaining further propositional resolvents. In other words we only compute such propositionally implied \u01eb-clauses, do splitting and instantiation and iterate\nthe process. This generates all resolvents upto propositional implication. We now formalize our approach. We start with the following observation which is used in this and\nfurther sections.\nLemma 6 Let x1 , . . . , xn , y1 , . . . , yn be variables, not necessarily distinct, but with\n{x1 , . . . , xn } \u2229 {y1 , . . . , yn } = \u2205. Then the terms f (x1 , . . . , xn ) and f (y1 , . . . , yn )\nhave an mgu \u03c3 such that {x1 , . . . , xn }\u03c3 \u2286 {x1 , . . . , xn } and yi \u03c3 = xi \u03c3 for 1 \u2264 i \u2264 n.\n11\n\n\fFor a set S of clauses, comp(S)\nis the set of complex clauses in S, eps(S) the\nS\nset of \u01eb-blocks in S, \u03c0(S) = C\u2208S \u03c0(C) and I(S) = \u03c0(comp(S)) \u222a eps(S)[xr+1 ] \u222a\neps(S)[U]. For sets S and T of complex clauses and \u01eb-blocks, S \u2291 T means that:\n\u2013 if C \u2208 S is a complex clause then I(T ) \u000fp \u03c0(C), and\n\u2013 if C \u2208 S is an \u01eb-block then C[xr+1 ] \u2208 eps(T )[xr+1 ].\nFor tableaux T1 and T2 involving only complex clauses and \u01eb-blocks we write T1 \u2291 T2\nif T1 can be written as S1 | . . . | Sn and T2 can be written as T1 | . . . | Tn (note\nsame n) such that Si \u2291 Ti for 1 \u2264 i \u2264 n. Intuitively T2 is a succinct representation\nof T1 . Define the splitting strategy \u03c6 as the one which repeatedly applies \u01eb-splitting\non a tableau as long as possible. The relation \u21d2\u227a,\u03c6 provides us a sound and complete\nmethod for testing unsatisfiability. We define the alternative procedure for testing unsatisfiability by using succinct representations of tableaux. We define \u25ee by the rule:\nT | S \u25ee T | S \u222a{B1 } | . . . | S \u222a{Bk } whenever I(S) \u000fp C = B1 [xi1 ]\u2294. . .\u2294Bk [xik ],\nC is an \u01eb-clause, and 1 \u2264 i1 , . . . , ik \u2264 r + 1. Then \u25ee simulates \u21d2\u227a,\u03c6 :\nLemma 7 If S is a set of complex clauses and \u01eb-blocks, S \u2291 T and S \u21d2\u227a,\u03c6 T , then\nall clauses occurring in T are complex clauses or \u01eb-blocks and T \u25ee\u2217 T \u2032 for some T \u2032\nsuch that T \u2291 T \u2032 .\nProof: We have the following ways in which T is obtained from S by doing one\nresolution step followed by splitting:\n\u2022 We resolve two \u01eb-blocks C1 and C2 of S to get an \u01eb-block C, and T = S \u222a\n{C}. Then {C1 [xr+1 ], C2 [xr+1 ]} \u000fp C[xr+1 ]. Also as S \u2291 T we have\n{C1 [xr+1 ], C2 [xr+1 ]} \u2286 eps(T )[xr+1 ]. We have I(T ) \u000fp C[xr+1 ]. Hence\nT \u25ee T \u222a {C[xr+1 ]} and clearly S \u222a {C} \u2291 T \u222a {C}.\n\u2022 We resolve an \u01eb-block C1 [xr+1 ] with a complex clause C2 [x1 , . . . , xr ], both\nfrom S upto renaming, and we have C1 [xr+1 ] \u2208 eps(T )[xr+1 ] and I(T ) \u000fp\n\u03c0(C2 ). By ordering constraints, we have C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 \u00b1P (xr+1 )\nand C2 [x1 , . . . , xr ] = \u2213P (f (x1 , . . . , xn )) \u2228 C2\u2032 [x1 , . . . , xr ] so that resolution\nproduces C[x1 , . . . , xr ] = C1\u2032 [f (x1 , . . . , xn )]\u2228C2\u2032 [x1 , . . . , xr ]. Clearly C1 [U]\u222a\n{C2 [x1 , . . . , xr ]} \u000fp C[x1 , . . . , xr ]. Also \u03c0(C1 [U]) = C1 [U]. Hence I(T )C1 [U]\u222a\n\u03c0(C2 ) \u000fp \u03c0(C) \u2287 {C[x1 , . . . , xr ]}.\n\u2013 If C1\u2032 is not empty or if C2\u2032 has some non-trivial literal then C is a complex\nclause and T = S \u222a {C} \u2291 T .\n\u2013 If C1\u2032 is empty and C2\u2032 has only trivial literals then C[x1 , . . . , xr ] is an\n\u01eb-clause of the form B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] with 1 \u2264 i1 , . . . , ik \u2264 r.\nT = S \u222a {B1 } | . . . | S \u222a {Bk }. Since I(T ) \u000fp C[x1 , . . . , xr ], hence\nT \u25ee T \u2032 where T \u2032 = T \u222a {B1 } | . . . | T \u222a {Bk } and we have T \u2291 T \u2032 .\n\u2022 We resolve two complex clauses C1 [x1 , . . . , xr ] and C2 [x1 , . . . , xr ], both from\nS upto renaming, and we have I(T ) \u000fp \u03c0(C1 ) and I(T ) \u000fp \u03c0(C2 ). First we\nrename the second clause as C2 [xr+1 , . . . , x2r ] by applying the renaming \u03c30 =\n{x1 7\u2192 xr+1 , . . . , xr 7\u2192 x2r }. By ordering constraints, C1 [x1 , . . . , xr ] is of\nthe form C1\u2032 [x1 , . . . , xr ] \u2228 \u00b1P (f (x1 , . . . , xn )) and C2 [xr+1 , . . . , x2r ] is of the\n12\n\n\fform \u2213P (f (y1 , . . . , yn )) \u2228 C2\u2032 [xr+1 , . . . , x2r ] so that \u00b1P (f (x1 , . . . , xn )) and\n\u2213P (f (y1 , . . . , yn )) are the literals to be resolved from the respective clauses. By\nLemma 6, the resolvent is C = C1\u2032 [x1 , . . . , xr ]\u03c3 \u2228 C2\u2032 [xr+1 , . . . , x2r ]\u03c3 where\n\u03c3 is such that {x1 , . . . , xn }\u03c3 \u2286 {x1 , . . . , xn } and yi \u03c3 = xi \u03c3 for 1 \u2264 i \u2264 n.\nC is obtained by propositional resolution from C1 [x1 , . . . , xr ]\u03c3 \u2208 \u03c0(C1 ) and\nC2 [xr+1 , . . . , x2r ]\u03c3 = C2 [x1 , . . . , xr ]\u03c30 \u03c3 \u2208 \u03c0(C2 ). Hence \u03c0(C1 ) \u222a \u03c0(C2 ) \u000fp\nC[x1 , . . . , xr ]. Hence \u03c0(\u03c0(C1 )) \u222a \u03c0(\u03c0(C2 )) = \u03c0(C1 ) \u222a \u03c0(C2 ) \u000fp \u03c0(C). As\nI(T ) \u000fp \u03c0(C1 ) and I(T ) \u000fp \u03c0(C2 ). hence I(T ) \u000fp \u03c0(C) \u2287 {C[x1 , . . . , xr ])}.\n\u2013 If either C1\u2032 or C2\u2032 contains a non-trivial literal then C is a complex clause\nand T = S \u222a {C} \u2291 T .\n\u2013 If C1\u2032 and C2\u2032 contain only trivial literals then C[x1 , . . . , xr ] is an \u01eb-clause\nof the form B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] with 1 \u2264 i1 , . . . , ik \u2264 r. T = S \u222a\n{B1 } | . . . | S \u222a {Bk }. As I(T ) \u000fp C[x1 , . . . , xr ] we have T \u25ee T \u2032 where\nT \u2032 = T \u222a {B1 } | . . . | T \u222a {Bk }. Also T \u2291 T \u2032 .\n\u2022 C[x1 , . . . , xr ] is a renaming of a complex clause in S, and we factor C[x1 ,\n. . . , xr ] to get a complex clause C[x1 , . . . , xr ]\u03c3 where Xr \u03c3 \u2286 Xr , and T =\nS \u222a{C[x1 , . . . , xr ]\u03c3}. C[x1 , . . . , xr ]\u03c3 \u2208 \u03c0(C). Hence \u03c0({C[x1 , . . . , xr ]\u03c3}) \u2286\n\u03c0(\u03c0(C)) = \u03c0(C). As S \u2291 T hence I(T ) \u000fp \u03c0(C). Hence I(T ) \u000fp \u03c0({C[x1 ,\n. . . , xr ]\u03c3}). Hence we have T = S \u222a {C[x1 , . . . , xr ]\u03c3} \u2291 T .\n\u2737\nHence we have completeness of \u25ee:\nLemma 8 If a set S of good complex clauses and \u01eb-blocks is unsatisfiable then S \u25ee\u2217 T\nfor some closed T .\nProof: By Lemma 1, S \u21d2\u2217\u227a,\u03c6 S1 | . . . | Sn such that each Si \u220b \u2737. As S \u2291 S, hence\nby Lemma 7, we have some T1 , . . . , Tn such that S \u25ee\u2217 T1 | . . . | Tn and Si \u2291 Ti for\n1 \u2264 i \u2264 n. Since \u2737 \u2208 Si and \u2737 is an \u01eb-block, hence \u2737 \u2208 Ti for 1 \u2264 i \u2264 n.\n\u2737\nCall a set S of complex clauses and \u01eb-blocks saturated if the following condition\nis satisfied: if I(S) \u000fp B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] with 1 \u2264 i1 , . . . , ik \u2264 r + 1, each Bi\nbeing an \u01eb-block, then there is some 1 \u2264 j \u2264 k such that Bj [xr+1 ] \u2208 S[xr+1 ].\nLemma 9 If S is a satisfiable set of complex clauses and \u01eb-blocks then S \u25ee\u2217 T | T for\nsome T and some saturated set T of complex clauses and \u01eb-blocks, such that \u2737 \u2208\n/ T.\nProof: We construct a sequence S = S0 \u2286 S1 \u2286 S2 \u2286 . . . of complex clauses\nand \u01eb-blocks such that Si is satisfiable and Si \u25ee\u2217 Si+1 | Ti for some Ti for each i.\nS = S0 is satisfiable by assumption. Now assume we have already defined S0 , . . . , Si\nand T0 , . . . , Ti\u22121 . Let C l = B1l [xil1 ] \u2294 . . . \u2294 Bkl [xilk ] for 1 \u2264 l \u2264 N be all the possible\nl\n\n\u01eb-clauses such that I(Si ) \u000fp C l , 1 \u2264 il1 , . . . , ilkl \u2264 r + 1. Since Si is satisfiable,\nSi \u222a {C l | 1 \u2264 l \u2264 N } is satisfiable. Since xil1 , . . . , xilk are mutually distinct for\nl\n\n1 \u2264 l \u2264 N , there are 1 \u2264 jl \u2264 kl for 1 \u2264 l \u2264 N such that Si \u222a {Bjll | 1 \u2264 l \u2264 N }\nis satisfiable. Let Si+1 = Si \u222a {Bjll | 1 \u2264 l \u2264 N }. Si+1 is satisfiable. Also it is clear\n13\n\n\fthat Si \u25ee\u2217 Si+1 | Ti for some Ti . If Si+1 = Si then Si is saturated, otherwise Si+1\nhas strictly more \u01eb-blocks upto renaming. As there are only finitely many \u01eb-blocks\nupto renaming, eventually we will end up with a saturated set T in this way. Since\nT is satisfiable, \u2737 \u2208\n/ T . From construction it is clear that there is some T such that\nS \u25ee\u2217 T | T .\n\u2737\nTheorem 3 Satisfiability for the class F is NEXPTIME-complete.\nProof: The lower bound comes from reduction of satisfiability of positive set constraints which is NEXPTIME-complete [1]. For the upper bound let S be a finite set\nof flat clauses. Repeatedly apply \u01eb-splitting to obtain f (S) = S1 | . . . | Sm . S is\nsatisfiable iff some Si is satisfiable. The number m of branches in f (S) is at most exponential. Also each branch has size linear in the size of S. We non-deterministically\nchoose some Si and check its satisfiability in NEXPTIME.\nHence wlog we may assume that the given set S has only complex clauses and\n\u01eb-blocks. We non-deterministically choose a certain number of \u01eb-blocks B1 , . . . , BN\nand check that T = S1 \u222a {B1 , . . . , BN } is saturated and \u2737 \u2208\n/ T . By Lemma 9, if S is\nsatisfiable then clearly there is such a set T . Conversely if there is such a set T , then\nwhenever T \u25ee\u2217 T , we will have T = T | T \u2032 for some T \u2032 . Hence we can never have\nT \u25ee\u2217 T where T is closed. Then by Lemma 8 we conclude that T is satisfiable. Hence\nS \u2286 T is also satisfiable.\nGuessing the set T requires non-deterministically choosing from among exponentially many \u01eb-blocks. To check that T is saturated, for every \u01eb-clause C = B1 [xi1 ] \u2294\n. . . \u2294 Bk [xik ], with 1 \u2264 i1 , . . . , ik \u2264 r + 1, and Bj [xr+1 ] \u2208\n/ T [xr+1 ] for 1 \u2264 j \u2264\nk, we check that I(T ) 2p C, i.e. I(T ) \u222a \u00acC is propositionally satisfiable (where\n\u00ac(L1 \u2228. . .\u2228Ln ) denotes {\u2212L1 , . . . , \u2212Ln }). This can be checked in NEXPTIME since\npropositional satisfiability can be checked in NPTIME. We need to do such checks for\nat most exponentially many possible values of C.\n\u2737\n\n6 Combination: Ordered Literal Replacement\nCombining flat and one-variable clauses creates additional difficulties. First observe\nthat resolving a one variable clause C1 \u2228 \u00b1P (f (s1 [x], . . . , sn [x])) with a complex\nclause \u2213P (f (x1 , . . . , xn )) \u2228 C2 produces a one-variable clause. If si [x] = sj [x] for\nall xi = xj , and if C2 contains a literal P (xi ) then the resolvent contains a literal\nP (si [x]). The problem now is that even if f (s1 [x], . . . , sn [x]) is reduced, si [x] may\nnot be reduced. E.g. f (g(h(x)), x) is reduced but g(h(x)) is not reduced. Like in\nSection 4 we may think of replacing this literal by simpler literals involving fresh predicates. Firstly we have to ensure that in this process we do not generate infinitely many\npredicates. Secondly it is not clear that mixing ordered resolution steps with replacement of literals is still complete. Correctness is easy to show since the new clause is in\nsome sense equivalent to the old deleted clause. However deletion of clauses arbitrarily\ncan violate completeness of the resolution procedure. The key factor which preserves\ncompleteness is that we replace literals by smaller literals wrt the given ordering <.\nFormally a replacement rule is of the form A1 \u2192 A2 where A1 and A2 are (not necessarily ground) atoms. The clause set associated with this rule is {A1 \u2228 \u2212A2 , \u2212A1 \u2228\n14\n\n\fA2 }. Intuitively such a replacement rule says that A1 and A2 are equivalent. The\nclause set cl(R) associated with a set R of replacement rules is the union of the clause\nsets associated with the individual replacement rules in R. Given a stable ordering\n< on atoms, a replacement rule A1 \u2192 A2 is ordered iff A2 < A1 . We define the\nrelation \u2192R as: S \u2192R (S \\ {\u00b1A1 \u03c3 \u2228 C}) \u222a {\u00b1A2 \u03c3 \u2228 C} whenever S is a set of\nclauses, \u00b1A1 \u03c3 \u2228 C \u2208 S, A1 \u2192 A2 \u2208 R and \u03c3 is some substitution. Hence we replace\nliterals in a clause by smaller literals. The relation is extended to tableaux as usual.\nThis is reminiscent of the well-studied case of resolution with some equational theory\non terms. There, however, the ordering < used for resolution is compatible with the\nequational theory and one essentially works with the equivalence classes of terms and\natoms. This is not the case here.\nNext note that in the above resolution example, even if f (s1 [x], . . . , sn [x]) is nonground, some si may be ground. Hence the resolvent may have ground as well as\nnon-ground literals. We avoided this in Section 4 by initial preprocessing. Now we\nmay think of splitting these resolvents during the resolution procedure. This however will be difficult to simulate using the alternative resolution procedure on succinct representations of tableaux because we will generate doubly exponentially many\none-variable clauses. To avoid this we use a variant of splitting called splitting-withnaming [15]. Instead of creating two branches after splitting, this rule puts both components into the same set, but with tags to simulate branches produced by ordinary\nsplitting. Fix a finite set P of predicate symbols. P-clauses are clauses whose predicates are all from P. Introduce fresh zero-ary predicates C for P-clauses C modulo renaming, i.e. C1 = C2 iff C1 \u03c3 = C2 for some renaming \u03c3. Literals \u00b1C\nfor P-clauses C are splitting literals. The splitting-with-naming rule is defined as:\nS \u2192nspl (S \\ {C1 \u2294 C2 }) \u222a {C1 \u2228 \u2212C2 , C2 \u2228 C2 } where C1 \u2294 C2 \u2208 S, C2 is\nnon-empty and has only non-splitting literals, and C1 has at least one non-splitting\nliteral. Intuitively C2 represents the negation of C2 . We will use both splitting and\nsplitting-with-naming according to some predefined strategy. Hence for a finite set Q\nof splitting atoms, define Q-splitting as the restriction of the splitting-with-naming rule\nwhere the splitting atom produced is restricted to be from Q. Call this restricted relation as \u2192Q\u2212nspl . This is extended to tableaux as usual. Now once we have generated\nthe clauses C1 \u2228 \u2212C2 and C2 \u2228 C2 we would like to keep resolving on the second\npart of the second clause till we are left with the clause C2 (possibly with other positive splitting literals) which would then be resolved with the first clause to produce C1\n(possibly with other positive splitting literals) and only then the literals in C1 would\nbe resolved upon. Such a strategy cannot be ensured by ordered resolution, hence we\nintroduce a new rule. An ordering < over non-splitting atoms is extended to the ordering <s by letting q <s A whenever q is a splitting atom and A is a non-splitting atom,\nand A <s B whenever A, B are non-splitting atoms and A < B. We define modified\nordered binary resolution by the following rule:\nC1 \u2228 A \u2212 B \u2228 C2\nC1 \u03c3 \u2228 C2 \u03c3\nwhere \u03c3 = mgu(A, B) and the following conditions are satisfied:\n(1) C1 has no negative splitting literal, and A is maximal in C1 .\n(2) (a) either B \u2208 Q, or\n\n15\n\n\f(b) C2 has no negative splitting literal, and B is maximal in C2 .\nAs usual we rename the premises before resolution so that they don't share variables.\nThis rule says that we must select a negative splitting literal to resolve upon in any\nclause, provided the clause has at least one such literal. If no such literal is present in the\nclause, then the ordering <s enforces that a positive splitting literal will not be selected\nas long as the clause has some non-splitting literal. We write S \u21db<s S \u222a {C} to say\nthat C is obtained by one application of the modified binary ordered resolution or the\n(unmodified) ordered factorization rule on clauses in S. This is extended to tableaux\nas usual. A Q-splitting-replacement strategy is a function \u03c6 such that T (\u2192Q\u2212nspl\n\u222a \u2192spl \u222a \u2192R )\u2217 \u03c6(T ) for any tableaux T . Hence we allow both normal splitting\nand Q-splitting. Modified ordered resolution with Q-splitting-replacement strategy \u03c6\nis defined by the relation: S \u21db<s ,\u03c6,R \u03c6(T ) whenever S \u222a cl(R) \u21db<s T . This\nis extended to tableaux as usual. The above modified ordered binary resolution rule\ncan be considered as an instance of ordered resolution with selection [2], which is\nknown to be sound and complete even with splitting and its variants. Our manner of\nextending < to <s is essential for completeness. We now show that soundness and\ncompleteness hold even under arbitrary ordered replacement strategies. It is not clear\nto the authors if such rules have been studied elsewhere. Wlog we forbid the useless\ncase of replacement rules containing splitting symbols. The relation < is enumerable\nif the set of all ground atoms can be enumerated as A1 , A2 , . . . such that if Ai < Aj\nthen i < j. The subterm ordering is enumerable.\nTheorem 4 Modified ordered resolution, wrt a stable and enumerable ordering, with\nsplitting and Q-splitting and ordered literal replacement is sound and complete for\nany strategy. I.e. for any set S of P-clauses, for any strict stable and enumerable\npartial order < on atoms, for any set R of ordered replacement rules, for any finite\nset Q of splitting atoms, and for any Q-splitting-replacement strategy \u03c6, S \u222a cl(R) is\nunsatisfiable iff S \u21db\u2217<s ,\u03c6,R T for some closed T .\nProof: See Appendix B.\nFor the rest of this section fix a set S of one-variable P-clauses and complex Pclauses whose satisfiability we need to decide. Let Ng be the set of non-ground\nterms occurring as arguments in literals in the one-variable clauses of S. We rename all terms in Ng to contain only the variable xr+1 . Wlog assume xr+1 \u2208 Ng.\nLet Ngs be the set of non-ground subterms of terms in Ng, and Ngr = {s[xr+1 ] |\ns is non-ground and reduced,and for some t, s[t] \u2208 Ngs}. Define Ngrr = {s1 [. . . [sm\n] . . .] | s1 [. . . [sn ] . . .] \u2208 Ngs, m \u2264 n, and each si is non-trivial and reduced}. Define\nthe set of predicates Q = {P s | P \u2208 P, s \u2208 Ngrr}. Note that P \u2286 Q. Define\nthe set of replacement rules R = {P s1 . . . sm\u22121 (sm [xr+1 ]) \u2192 P s1 . . . sm ([xr+1 ]\n) | P s1 . . . sm \u2208 Q}. They are clearly ordered wrt \u227a. Let G be the set of ground subterms of terms occurring as arguments in literals in S. Define the set Q0 = {\u00b1P (t) |\nP \u2208 P, t \u2208 G} of splitting atoms. Their purpose is to remove ground literals from\na non-ground clause. All sets defined above have polynomial size. Let Q \u2287 Q0\nbe any set of splitting atoms. For dealing with the class C we only need Q = Q0 ,\nbut for a more precise analysis of the Horn fragment in the next Section, we need Q\nto also contain some other splitting atoms. We also need the set Ngr1 = {xr+1 } \u222a\n16\n\n\f{f (s1 , . . . , sn ) | \u2203g(t1 , . . . , tm ) \u2208 Ngr * {s1 , . . . , sn } = {t1 , . . . , tm }} which has\nexponential size. These terms are produced by resolution of non-ground one-variable\nclauses with complex clauses, and are also reduced. In the ground case we have the\nset G1 = {f (s1 , . . . , sn ) | \u2203g(t1 , . . . , tm ) \u2208 G | {s1 , . . . , sn } = {t1 , . . . , tm }} of\nexponential size. For a set P\u2032 of predicates and a set U of terms, the set P\u2032 [U ] of atoms\nis defined as usual. For a set V of atoms the set \u2212V and \u00b1V of literals is defined as\nusual. The following types of clauses will be required during resolution:\n(C1) clauses C \u2228 D, where C is an \u01eb-block with predicates from Q, and D \u2286 \u00b1Q.\n(C2) clauses C \u2228 D where C is a renaming of a one-variable clause with literals from\n\u00b1Q(Ngr1 ), C has at least one non-trivial literal, and D \u2286 \u00b1Q.\n(C3) clauses C\u2228D where C is a non-empty clause with literals from \u00b1Q(Ngr1 [Ngrr[G1 ]]),\nand D \u2286 \u00b1Q.\nWl\nWk\n(C4) clauses C \u2228 D where C = i=1 \u00b1i Pi (fi (xi1 , . . . , xini )) \u2228 j=1 \u00b1j Qj (xj ) is a\ncomplex clause with each Pi \u2208 Q, each ni \u2265 2, each Qj \u2208 P and D \u2286 \u00b1Q\nWe have already argued why we need splitting literals in the above clauses, and why\nwe need Ngr1 instead of Ngr in type C2. In type C3 we have Ngrr in place of the set\nNgs that we had in Section 4, to take care of interactions between one-variable clauses\nand complex clauses. In type C4 the trivial literals involve predicates only from P (and\nnot Q). This is what ensures that we need only finitely many fresh predicates (those\nfrom Q \\ P) because these are the literals that are involved in replacements when this\nclause is resolved with a one-variable clause. We have also required that each ni \u2265 2.\nThis is only to ensure that types C2 and C4 are disjoint. The clauses that are excluded\nbecause of this condition are necessarily of type C2.\nThe Q0 -splitting steps that we use in this section consist of replacing a tableau\nT | S by the tableau T | (S \\ {C \u2228 L}) \u222a {C \u2228 \u2212L, L \u2228 L}, where C is non-ground,\nL \u2208 \u00b1P(G) and C \u2228 L \u2208 S. The replacement steps we are going to use are of the\nfollowing kind:\n(1) replacing clause C1 [x] = C \u2228 \u00b1P (t1 [. . . [tn [s[x]]] . . .]) by clause C2 [x] = C \u2228\n\u00b1P t1 . . . tn (s[x])} where P \u2208 P, s[xr+1 ] \u2208 Ngr is non-trivial, and t1 [. . . [tn ] . . .] \u2208\nNgrr. We have {C1 [xr+1 ]} \u222a cl(R)[Ngrr] \u000fp C2 [xr+1 ].\n(2) replacing ground clause C1 = C \u2228 \u00b1P (t1 [. . . [tn [g]] . . .]) by clause C2 = C \u2228\n\u00b1P t1 . . . tn [g]} where P \u2208 P, g \u2208 Ngrr[G1 ] and t1 [. . . [tn ] . . .] \u2208 Ngrr. This replacement is done only when t1 [. . . [tn [g]] . . .] \u2208 Ngrr[Ngrr[G1 ]] \\ Ngr1 [Ngrr[G1 ]]. We have\n{C1 } \u222a cl(R)[Ngrr[Ngrr[G1 ]]] \u000fp C2 .\nDefine the Q0 -splitting-replacement strategy \u03c6 as one which repeatedly applies first\n\u01eb-splitting, then the above Q0 -splitting steps, then the above two replacement steps till\nno further change is possible. Then \u21db\u227as ,\u03c6,R gives us a sound and complete method\nfor testing unsatisfiability.\nAs in Section 5 we now define a succinct representation of tableaux and an alternative resolution procedure for them. As we said, a literal L \u2208 Q0 represents \u2212L. Hence\nfor a clause C we define C as the clause obtained by replacing every \u00b1L by the literal\n\u2213L. This is extended to sets of clauses as usual. Observe that if S \u000fp C then S \u000fp C.\nAs before U = {f (x1 , . . . , xn ) | f \u2208 \u03a3, and each xi \u2208 Xr }. The functions eps and\n17\n\n\fcomp of Section 5 are now modified to return clauses of type C1 and C2 respectively.\nFor a set S of clauses, define ov(S) as the set of clauses of type C2 in S. The function \u03c0\nis as before. We need to define which kinds of instantiations are to be used to generate\npropositional implications. For a clause C, define\nI1 (C) =\nI2 (C) =\nI3 (C) =\nI4 (C) =\n\nC[U[Ngrr \u222a Ngrr[Ngrr[G1 ]]]] \u222a C[Ngr1 ] \u222a C[Ngr1 [Ngrr[G1 ]]]\n{C[xr+1 ]} \u222a C[Ngrr[G1 ]]\n{C}\n\u03c0(C) \u222a C[Ngrr \u222a Ngrr[Ngrr[G1 ]]]\n\nThe instantiations defined by Ii are necessary for clauses\nS of type Ci. Observe that\nC[U ] \u2286 I1 (C). For a set S of clauses, define Ii (S) = C\u2208S Ii (C). For a set S of\nclauses of type C1-C4 define I(S) = I1 (eps(S))\u222aI2 (ov(S))\u222aI3 (gr(S))\u222aI4 (comp(S))\u222a\ncl(R)[Ngrr\u222aNgrr[Ngrr[G1 ]]]. Note that instantiations of clauses in cl(R) are necessary\nfor the replacement rules, as argued above. For a set T of clauses define the following\nproperties:\n\u2022 C satisfies property P1T iff C[xr+1 ] \u2208 T .\n\u2022 C satisfies property P2T iff I(T ) \u000fp I2 (C).\n\u2022 C satisfies property P3T iff I(T ) \u000fp I3 (C).\n\u2022 C satisfies property P4T iff I(T ) \u000fp I4 (C).\nFor sets of clauses S and T , define S \u2291 T to mean that every C \u2208 S is of type\nCi and satisfies property PiT for some 1 \u2264 i \u2264 4. This is extended to tableaux as\nusual. We first consider the effect of one step of the above resolution procedure without\nsplitting. Accordingly let \u03c60 be the variant of \u03c6 which applies replacement rules and\nQ0 -splitting, but no \u01eb-splitting.\nLemma 10 Let S be a set of clauses of type C1-C4. If S \u21db\u227as ,\u03c60 ,R S \u2032 then one of the\nfollowing statements holds.\n\u2022 S\u2032 \u2291 S\n\u2022 S \u2032 = S \u222a {C} \u222a S \u2032\u2032 , C is a renaming of B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2294 D, each Bi is\nan \u01eb-block, 1 \u2264 i1 , . . . , ik \u2264 r, D \u2286 \u00b1Q, I(S) \u000fp C, and S \u2032\u2032 is a set of clauses\nof type C3 and \u2205 \u000fp S \u2032\u2032 . If k \u2265 2 then D has no literals \u2212q with q \u2208 Q \\ Q0 .\nProof: The set S \u2032\u2032 in the second statement will contain the clauses L \u2228 L added by\nQ0 -splitting, while C will be the clause produced by binary resolution or factoring,\npossibly followed by applications of replacement rules and by replacement of ground\nliterals L by \u2212L. Hence S \u2032\u2032 = \u2205 in all cases except when we need to perform Q0 splitting.\nFirst we consider resolution steps where splitting literals are resolved upon. A\npositive splitting literal cannot be chosen to resolve upon in a clause unless the clause\nhas no literals other than positive splitting literals. Hence this clause is C1 = q \u2228 q1 \u2228\n. . . \u2228 qm of type C1, The other clause must be C2 = C2\u2032 \u2228 \u2212q of type Ci for some\n18\n\n\f1 \u2264 i \u2264 4. Resolution produces clause C = C2\u2032 \u2228 q1 \u2228 . . . \u2228 qm of type Ci, and no\nreplacement or splitting rules apply. We have {C1 , C2 } \u000fp C and {C1 , C2 } \u000fp C.\nHence I(S) \u2287 C1 \u222a Ii (C2 ) \u000fp Ii (C). If i = 1 then the second statement of the lemma\nholds because Ii (C) contains a renaming of C. If i > 1 then the first statement holds.\nNow we consider binary resolution steps where no splitting literals are resolved\nupon. This is possible only when no negative splitting literals are present in the\npremises. Then the resolvent has no negative splitting literals. Q0 splitting may create\nnegative splitting literals, but none of them are from Q \\ Q0 . Hence the last part of\nthe second statement of the lemma is always true. In the following D, D1 , . . . denote\nsubsets of Q0 . When we write C \u2228 D, it is implicit that C has no splitting literals. We\nhave the following cases:\n1. We do resolution between two clauses C1 and C2 from S, both of type C1, and\nthe resolvent C is of type C1. Hence no splitting or replacement rules apply,\nS \u2032 = S \u222a {C}, I(S) \u2287 {C1 [xr+1 ], C2 [xr+1 ]} \u000fp C[xr+1 ]. Hence the second\nstatement holds.\n2. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 D1 \u2228 \u00b1P (xr+1 ),\nof type C1, and a clause C2 [xr+1 ] = \u2213P (t[xr+1 ]) \u2228 C2\u2032 [xr+1 ] \u2228 D2 , of type\nC2, both from S upto renaming, and the resolvent is C[xr+1 ] = C1\u2032 [t[xr+1 ]] \u2228\nC2\u2032 [xr+1 ] \u2228 D1 \u2228 D2 . By ordering constraints t[xr+1 ] \u2208 Ngr1 is non-trivial. All\nliterals in C1\u2032 [t[xr+1 ]] \u2228 C2\u2032 [xr+1 ] are of the form \u00b1\u2032 Q(t\u2032 [xr+1 ]) with t\u2032 [xr+1 ] \u2208\nNgr1 . Hence no splitting or replacement rules apply and S \u2032 = S\u222a{C}. C1 [Ngr1 ]\u222a\n{C2 [xr+1 ]} \u000fp C[xr+1 ]. Hence I(S) \u2287 I1 (C1 ) \u222a I2 (C2 ) \u2287 C1 [Ngr1 ] \u222a C2 [\nNgr1 [Ngrr[G1 ]]] \u222a {C2 [xr+1 ]} \u222a C2 [Ngrr[G1 ]] \u000fp {C[xr+1 ]} \u222a C[Ngrr[G1 ]] =\nI2 (C[xr+1 ]). If C1\u2032 is non-empty or C2\u2032 has some non-trivial literal then C[xr+1 ]\nis of type C2, S \u2032 \u2291 S and the first statement holds. If C1\u2032 is empty and C2\u2032 has\nonly trivial literals, then C is of type C1 and the second statement holds.\n3. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 D1 \u2228 \u00b1P (xr+1 )\nof type C1, and a clause C2 = \u2213P (t) \u2228 C2\u2032 \u2228 D2 of type C3, both from S\nupto renaming, and the resolvent is C = C1\u2032 [t] \u2228 C2\u2032 \u2228 D1 \u2228 D2 . We know\nthat t \u2208 Ngr1 [Ngrr[G1 ]]. Hence no splitting or replacement rules apply, and\nS \u2032 = S \u222a {C}. {C1 [t], C2 } \u000fp C. Hence I(S) \u2287 I1 (C1 [xr+1 ]) \u222a I3 (C2 ) \u2287\nC1 [Ngr1 [Ngrr[G1 ]]] \u222a {C2 } \u000fp I3 (C) = {C}. If C1\u2032 or C2\u2032 is non-empty. then\nC[xr+1 ] is of type C3, S \u2032 \u2291 S and the first statement holds. If C1\u2032 and C2\u2032 are\nempty then C is of type C1 and the second statement holds.\n4. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 D1 \u2228 \u00b1P (xr+1 ) of\ntype C1, and a clause C2 [x1 , . . . , xr ] = \u2213P (x1 , . . . , xn ) \u2228 C2\u2032 [x1 , . . . , xr ] \u2228 D2\nof type C4, both from S upto renaming, and the resolvent is C[x1 , . . . , xr ] =\nC1\u2032 [f (x1 , . . . , xn )] \u2228 C2\u2032 [x1 , . . . , xr ] \u2228 D1 \u2228 D2 . (By ordering constraints we\nhave chosen a non trivial literal from C2 for resolution). No splitting or replacement rules apply and S \u2032 = S \u222a {C}. We have C1 [U] \u222a {C2 [x1 , . . . , xr ]} \u2287\n{C1 [f (x1 , . . . , xn )], C2 [x1 , . . . , xr ]} \u000fp C[x1 , . . . , xr ]. Hence C1 [U]\u222a\u03c0(C2 [x1 ,\n. . . , xr ]) \u000fp \u03c0(C[x1 , . . . , xr ]) and C1 [U[Ngrr \u222a Ngrr[Ngrr[G1 ]]] \u222a C2 [Ngrr \u222a\nNgrr[Ngrr[G1 ]]]) \u000fp C[Ngrr\u222aNgrr[Ngrr[G1 ]]]. Hence I(S) \u2287 I1 (C1 )\u222aI4 (C2 ) \u000fp\nI4 (C).\n19\n\n\f\u2022 Suppose C1\u2032 is non-empty or C2\u2032 has some non-trivial literal. Then C is of\ntype C4. The only trivial literals in C[x1 , . . . , xr ] are those in C2\u2032 [x1 , . . . , xr ]\nand hence they involve predicates from P. Hence C[x1 , . . . , xr ] if of type\nC4 and the first statement holds.\n\u2022 Suppose C1\u2032 is empty and C2\u2032 has only trivial literals. Then C[x1 , . . . , xr ] =\nB1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2228 D1 \u2228 D2 where 1 \u2264 i1 , . . . , ik \u2264 r, and each Bi\nis an \u01eb-block. The second statement holds.\n5. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 D1 \u2228 \u00b1P (s[xr+1 ])\nand a clause C2 [xr+1 ] = \u2213P (t[xr+1 ]) \u2228 C2\u2032 [xr+1 ] \u2228 D2 , both of type C2,\nand both from S upto renaming, and the resolvent is C[xr+1 ] = C1\u2032 [xr+1 ]\u03c3 \u2228\nC2\u2032 [xr+2 ]\u03c3 \u2228 D1 \u2228 D2 where \u03c3 = mgu(s[xr+1 ], t[xr+2 ]) (we renamed the second clause before resolution). We know that s[xr+1 ], t[xr+1 ] \u2208 Ngr1 , and by\nordering constraints both s and t are non-trivial. By Lemma 2 one of the following cases holds:\n\u2022 xr+1 \u03c3 = xr+2 \u03c3 = xr+1 . C[xr+1 ] = C1\u2032 [xr+1 ] \u2228 C2\u2032 [xr+1 ]. Hence\nno splitting or replacement rules apply and S \u2032 = S \u222a {C}. We have\n{C1 [xr+1 ], C2 [xr+1 ]} \u000fp C[xr+1 ]. Hence I2 (C1 [xr+1 ])\u222aI2 (C2 [xr+1 ]) \u000fp\nI2 (C[xr+1 ]) \u220b C[xr+1 ]. If C1\u2032 or C2\u2032 contains some non-trivial literal then\nC[xr+1 ] is of type C2 and the first condition holds. If C1\u2032 and C2\u2032 contain\nonly trivial literals then C is of type C1 and the second condition holds.\n\u2022 xr+1 \u03c3, xr+2 \u03c3 \u2208 Ngrr[G] \u2286 Ngrr[G1 ]. Then every literal in C[xr+1 ] is of\nthe form \u00b1\u2032 Q(u) with u \u2208 Ngr1 [Ngrr[G1 ]]. No splitting or replacement\nrules apply and S \u2032 = S \u222a {C}. I(S) \u2287 C1 [Ngrr[G1 ]] \u222a C2 [Ngrr[G1 ]] \u000fp\n{C} = I3 (C). If C1\u2032 or C2\u2032 is non-empty then C is of type C3 and the\nfirst statement holds. If C1\u2032 and C2\u2032 are empty then C is of type C1 and the\nsecond statement holds.\n6. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ] \u2228 D1 \u2228 \u00b1P (s[xr+1 ])\nof type C2, and a ground clause \u2213P (t) \u2228 C2\u2032 \u2228 D2 of type C3, both from S upto\nrenaming, and the resolvent is C = C1\u2032 [xr+1 ]\u03c3 \u2228 C2\u2032 \u2228 D1 \u2228 D2 where \u03c3 is a\nunifier of s[xr+1 ] and t. We know that s[xr+1 ] \u2208 Ngr1 , t \u2208 Ngr1 [Ngrr[G1 ]], and\nby ordering constraints, s is non-trivial. We have the following cases:\n\u2022 t \u2208 G1 . Then xr+1 \u03c3 is a strict subterm of t hence xr+1 \u03c3 \u2208 G \u2286 Ngrr[G1 ].\n\u2022 t \u2208 Ngr1 [Ngrr[G1 ]] \\ G1 . Hence we have t = t1 [t\u2032 ] for some non-trivial\nt1 [xr+1 ] \u2208 Ngr1 and some t\u2032 \u2208 Ngrr[G1 ]. Let s\u2032 = xr+1 \u03c3. As s[s\u2032 ] =\nt1 [t\u2032 ] hence s[xr+1 ] and t1 [xr+2 ] have a unifier \u03c3 = {xr+1 7\u2192 s\u2032 , xr+2 7\u2192\nt\u2032 }. From Lemma 2, one of the following is true:\n\u2013 s[xr+1 ] = t1 [xr+1 ]. Hence we have xr+1 \u03c3 = s\u2032 = t\u2032 \u2208 Ngrr[G1 ].\n\u2013 xr+1 \u03c31 , xr+2 \u03c31 \u2208 Ngrr[G] \u2286 Ngrr[G1 ]. Hence s\u2032 \u2208 Ngrr[G1 ].\nIn each case we have xr+1 \u03c3 = s\u2032 \u2208 Ngrr[G1 ]. Hence all literals in C1\u2032 [xr+1 ]\u03c3\nare of the form \u00b1Q(t) with t \u2208 Ngr1 [Ngrr[G1 ]]. All literals in C2\u2032 are of the form\n\u00b1\u2032 Q(t) with t \u2208 Ngr1 [Ngrr[G1 ]]. Hence no splitting or replacement rules apply\n20\n\n\fand S \u2032 = S \u222a {C}. I(S) \u2287 I2 (C1 [xr+1 ]) \u222a I3 (C2 ) \u2287 C1 [Ngrr[G1 ]] \u222a {C2 } \u000fp\n{C} = I3 (C). If C1\u2032 or C2\u2032 is non-empty then C is of type C3 and the first\nstatement holds. If C1\u2032 and C2\u2032 are empty then C is of type C1 and the second\nstatement holds.\n7. We do resolution between a clause C1 [xr+1 ] = C1\u2032 [xr+1 ]\u2228D1 \u2228\u00b1P (s[xr+1 ]) of\ntype C2, and a clause C2 [x1 , . . . , xr ] = \u2213P (f (x1 , . . . , xn )) \u2228 C2\u2032 [x1 , . . . , xr ] \u2228\nD2 of type C4, both from S upto renaming, and \u00b1P (s[xr+1 ]) and \u2213P (f (x1 ,\n. . . , xn )) are the literals resolved upon from the respective clauses. (By ordering\nconstraints we have chosen a non-trivial literal to resolve upon in the second\nclause). By ordering constraints s[xr+1 ] \u2208 Ngr1 is non-trivial. Hence we have\nthe following two cases for s[xr+1 ] = f (s1 [xr+1 ], . . . , sn [xr+1 ]).\n\u2022 We have some 1 \u2264 i, j \u2264 n such that xi = xj but si [xr+1 ] 6= sj [xr+1 ]. By\nLemma 3, the only possible unifier of the terms s[xr+1 ] and f (x1 , . . . , xn )\nis \u03c3 such that xr+1 \u03c3 = g is a ground subterm of si or sj and xk \u03c3 =\nsk [g] for 1 \u2264 k \u2264 n. As s[xr+1 ] \u2208 Ngr1 , we have g \u2208 G and each\nsk [xr+1 ] \u2208 Ngrr \u222a G. Hence xr+1 \u03c3 \u2208 G and each xk \u03c3 \u2208 Ngrr[G] \u222a\nG \u2286 Ngrr[G1 ]. The resolvent C = C1\u2032 [xr+1 ]\u03c3 \u222a C2\u2032 [x1 , . . . , xr ]\u03c3 \u2228 D1 \u2228\nD2 is ground. Each literal in C1\u2032 [xr+1 ]\u03c3 is of the form \u00b1\u2032 Q(t) with t \u2208\nNgr1 [G] \u2286 Ngr1 [Ngrr[G1 ]]. Each literal in C2\u2032 [x1 , . . . , xr ]\u03c3 is of the form\n\u00b1\u2032 Q(t) where the following cases can arise:\n\u2013 t = f \u2032 (xi1 , . . . , xim )\u03c3 such that {xi1 , . . . , xim } = {x1 , . . . , xn }.\nThen t = f \u2032 (si1 , . . . , sim )[g] \u2208 Ngr1 [G1 ] \u2286 Ngr1 [Ngrr[G1 ]].\n\u2013 t = xk \u03c3 \u2208 Ngrr[G1 ] \u2286 Ngr1 [Ngrr[G1 ]] for some 1 \u2264 k \u2264 n, where\nthe literal \u00b1\u2032 Q(xk ) is from C2 .\nWe conclude that all non-splitting literals in C are of the form \u00b1\u2032 Q(t) with\nt \u2208 Ngr1 [Ngrr[G1 ]], and no splitting or replacement rules apply. We have\nS \u2032 = S\u222a{C}. I(S) \u2287 I2 (C1 [xr+1 ])\u222aI4 (C2 [x1 , . . . , xr ]) \u2287 C1 [Ngrr[G1 ]]\u222a\nC2 [Ngrr[G1 ]] \u000fp {C} = I3 (C). If C1\u2032 or C2\u2032 is non-empty then C is of type\nC3, and the first statement holds. If C1\u2032 and C2\u2032 are empty then C of type\nC1 and the second condition holds.\n\u2022 For all 1 \u2264 i, j \u2264 n, if xi = xj then si [xr+1 ] = sj [xr+1 ]. Then\ns[xr+1 ] and f (x1 , . . . , xn ) have mgu \u03c3 such that xk \u03c3 = sk [xr+1 ] \u2208\nNgrr \u222a G for 1 \u2264 k \u2264 n and x\u03c3 = x for x \u2208\n/ {x1 , . . . , xn }. The resolvent C[xr+1 ] = C1\u2032 [xr+1 ] \u2228 C2\u2032 \u03c3 \u2228 D1 \u2228 D2 is a one-variable clause.\n{C1 [xr+1 ]} \u222a C2 [Ngrr \u222a G] \u000fp C[xr+1 ]. All literals in C1\u2032 [xr+1 ] are of\nthe form \u00b1\u2032 Q(t) with t \u2208 Ngr1 , and no replacement rules apply on them.\nAll literals in C2\u2032 [x1 , . . . , xr ]\u03c3 are of the form \u00b1\u2032 Q(t[xr+1 ]) where the\nfollowing cases can arise:\n\u2013 t[xr+1 ] = f \u2032 (xi1 , . . . , xim )\u03c3 such that {xi1 , . . . , xim } = {x1 , . . . , xn }.\nThen t[xr+1 ] \u2208 Ngr1 . No replacement rules apply on such a literal.\n\u2013 t[xr+1 ] = xk \u03c3 = sk [xr+1 ] \u2208 Ngrr for some 1 \u2264 k \u2264 n, where the literal \u00b1\u2032 Q(xk ) is from C2 . Hence we must have Q \u2208 P. Let sk [xr+1 ] =\nt1 [. . . [tp [xr+1 ]] . . .] for some p \u2265 0 where each ti [xr+1 ] \u2208 Ngr is\n21\n\n\fnon-trivial and reduced. Such a literal is replaced by the literal \u00b1\u2032\nQt1 . . . tp\u22121 (tp [xr+1 ]) and we know that tp \u2208 Ngr \u2286 Ngr1 . This\nnew clause is obtained by propositional resolution between the former\nclause and clauses from cl(R)[Ngrr].\n\u2013 t[xr+1 ] = xk \u03c3 = sk \u2208 G for some 1 \u2264 k \u2264 n, where the literal\n\u00b1\u2032 Q(xk ) is from C2 . Hence we must have Q \u2208 P. No replacement\nrules apply on such a literal. If C contains only ground literals then\nthis literal is left unchanged. Otherwise we perform Q0 -splitting and\nthis literal is replaced by the literal \u2212\u00b1\u2032 Q(sk ) and also a new clause\nC \u2032\u2032 = \u00b1\u2032 Q(sk ) \u2228 \u00b1\u2032 Q(sk ) of type C3 is added to S. If C \u2032 is the\nnew clause obtained by this splitting then C \u2032 is clearly propositionally\nequivalent to the former clause. Also C \u2032\u2032 = \u2213\u2032 Q(sk ) \u2228 \u00b1\u2032 Q(sk ) is a\npropositionally valid statement.\nWe conclude that after zero or more replacement and splitting rules, we\nobtain a clause C \u2032 [xr+1 ], together with a set S \u2032\u2032 of clauses of type C3,\n{C[xr+1 ]}\u222acl(R)[Ngrr] \u000fp {C[xr+1 ]}, \u2205 \u000fp S \u2032\u2032 , and S \u2032 = S\u222a{C \u2032 }\u222aS \u2032\u2032 .\n{C1 [xr+1 ]} \u222a C2 [Ngrr \u222a G] \u222a cl(R)[Ngrr] \u000fp C \u2032 [xr+1 ]. Hence I(S) \u2287\nI2 (C1 )\u222aI4 (C2 ) \u2287 {C1 [xr+1 ]}\u222aC1 [Ngrr[G1 ]]\u222aC2 [Ngrr\u222aNgrr[Ngrr[G1 ]]]\u222a\ncl(R)[Ngrr] \u222a cl(R)[Ngrr[Ngrr[G1 ]]] \u000fp I2 (C \u2032 ) \u222a I3 (S \u2032\u2032 ) = C \u2032 [xr+1 ] \u222a\nC \u2032 [Ngrr[G1 ]] \u222a S \u2032\u2032 . If C \u2032 is of type C2 or C3 then the first statement holds.\nOtherwise C \u2032 is of type C1 and the second statement holds.\n8. We do resolution between a clause C1 = C1\u2032 \u2228 D1 \u2228 \u00b1P (s) and a clause C2 =\n\u2213P (s) \u2228 C2\u2032 \u2228 D2 , both ground clauses of type C3 from S, and the resolvent is\nC = C1\u2032 \u2228 C2\u2032 \u2228 D1 \u2228 D2 . No replacement or splitting rules apply and we have\nS \u2032 = S \u222a {C}. I(S) \u2287 {C1 , C2 } \u000fp I3 (C) = {C}. If C1\u2032 or C2\u2032 is non-empty\nthen C is of type C3, and the first statement holds. If C1\u2032 and C2\u2032 are empty then\nC is of type C1 and the second statement holds.\n9. We do resolution between a ground clause C1 = C1\u2032 \u2228 D1 \u2228 \u00b1P (s) of type\nC3, and a clause C2 [x1 , . . . , xr ] = \u2213P (f (x1 , . . . , xn )) \u2228 C2\u2032 [x1 , . . . , xr ] \u2228 D2\nof type C4, both from S upto renaming, and \u00b1P (s) and \u2213P (f (x1 , . . . , xn ))\nare the literals resolved upon from the respective clauses. We know that s \u2208\nNgr1 [Ngrr[G1 ]]. Hence we have the following two cases for s.\n\u2022 s \u2208 Ngr1 [Ngrr[G1 ]] \\ G1 . Hence s must be of the form f (s1 , . . . , sn )[g]\nfor some f (s1 , . . . , sn ) \u2208 Ngr1 and some g \u2208 Ngrr[G1 ] (The symbol f\nis same as in the literal \u2213P (f (x1 , . . . , xn )) otherwise this resolution step\nwould not be possible). We have each si \u2208 Ngrr \u222a G. The mgu \u03c3 of s and\nf (x1 , . . . , xn ) is such that xi \u03c3 = si [g] \u2208 Ngrr[Ngrr[G1 ]]. The resolvent\nC = C1\u2032 \u2228 C2\u2032 [x1 , . . . , xr ]\u03c3 \u2228 D1 \u2228 D2 is a ground clause. All literals in\nC1\u2032 are of the form \u00b1\u2032 Q(t) with t \u2208 Ngr1 [Ngrr[G1 ]] hence no replacement\nrules apply on them. The literals in C2\u2032 [x1 , . . . , xr ]\u03c3 are of the form \u00b1\u2032 Q(t)\nwhere the following cases are possible:\n\u2013 t = f \u2032 (xi1 , . . . , xim )\u03c3 where {xi1 , . . . , xim } = {x1 , . . . , xn }. Then\nf \u2032 (si1 , . . . , sim ) \u2208 Ngr1 . Hence t \u2208 Ngr1 [Ngrr[G1 ]]. No replacement\nrules apply on such a literal.\n22\n\n\f\u2013 t = xi \u03c3 \u2208 Ngrr[Ngrr[G1 ]] for some 1 \u2264 i \u2264 n. If t \u2208 Ngr1 [Ngrr[G1 ]]\nthen no replacement rules apply on this literal. Otherwise suppose\nt \u2208 Ngrr[Ngrr[G1 ]]\\Ngr1[Ngrr[G1 ]]. We have t = t1 [. . . [tp [t\u2032 ]] . . .] for\nsome reduced non-trivial non-ground terms t1 , . . . , tp \u2208 Ngr with p \u2265\n0 such that t1 [. . . [tp [y]]] \u2208 Ngrr and t\u2032 \u2208 Ngrr[G1 ], and the replacement strategy replaces this literal by the literal \u00b1\u2032 Qt1 . . . tp\u22121 (tp [t\u2032 ]),\nand we know that tp \u2208 Ngr \u2286 Ngr1 so that tp [t\u2032 ] \u2208 Ngr1 [Ngrr[G1 ]].\nThis new clause can be obtained by propositional resolution between\nthe former clause and clauses from cl(R)[Ngrr[Ngrr[G1 ]]]\nWe conclude that after zero or more replacement rules, we obtain a ground\nclause C \u2032 , all of whose non-splitting literals are of the form \u00b1\u2032 Q(t) with\nt \u2208 Ngr1 [Ngrr[G1 ]], and which is obtained by propositional resolution\nfrom {C} \u222a cl(R)[Ngrr[Ngrr[G1 ]]]. No splitting rules apply and S \u2032 =\nS \u222a{C \u2032 }. {C1 }\u222aC2 [Ngrr[Ngrr[G1 ]]] \u000fp C hence I(S) \u2287 I3 (C1 )\u222aI4 (C2 )\u222a\ncl(R)[Ngrr[Ngrr[G1 ]]] \u000fp I3 (C \u2032 ) = {C \u2032 }. If C1\u2032 or C2\u2032 is non-empty then\nC is of type C3, and the first statement holds. If C1\u2032 and C2\u2032 are empty then\nC is of type C1 and the second statement holds.\n\u2022 s \u2208 G1 . For the resolution step to be possible we must have s = f (s1 , . . . , sn ).\nEach si \u2208 G. The mgu \u03c3 of s and f (x1 , . . . , xn ) is such that each xi \u03c3 = si .\nThe resolvent C = C1\u2032 \u2228C2\u2032 [x1 , . . . , xr ]\u03c3 \u2228D1 \u2228D2 is a ground clause. All\nliterals in C1\u2032 are of the form \u00b1\u2032 Q(t) with t \u2208 Ngr1 [Ngrr[G1 ]]. The literals\nin C2\u2032 [x1 , . . . , xr ]\u03c3 are of the form \u00b1\u2032 Q(t) where the following cases are\npossible:\n\u2013 t = f \u2032 (xi1 , . . . , xim )\u03c3 where {xi1 , . . . , xim } = {x1 , . . . , xn }. Then\nt = f \u2032 (si1 , . . . , sim ) \u2208 G1 \u2286 Ngr1 [Ngrr[G1 ]].\n\u2013 t = xi \u03c3 = si \u2208 G \u2286 Ngr1 [Ngrr[G1 ]] for some 1 \u2264 i \u2264 n.\nHence all non-splitting literals in C are of the form \u00b1\u2032 Q(t) with t \u2208 Ngr1 [\nNgrr[G1 ]]. No replacement rules or splitting rules apply and S \u2032 = S \u222a {C}.\n{C1 }\u222aC2 [G] \u000fp C hence I(S) \u000fp I3 (C) = {C}. If C1\u2032 or C2\u2032 is non-empty\nthen C is of type C3 and the first statement holds. If C1\u2032 and C2\u2032 are empty\nthen C is of type C1 and the second statement holds.\n10. We do resolution between two clauses C1 [x1 , . . . , xr ] and C2 [x1 , . . . , xr ], both\nof type C4, and both from S upto renaming. First we rename the second clause\nas C2 [xr+1 , . . . , x2r ] by applying the renaming \u03c30 = {x1 7\u2192 xr+1 , . . . , xr 7\u2192\nx2r }. By ordering constraints, C1 [x1 , . . . , xr ] = C1\u2032 [x1 , . . . , xr ]\u2228D1 \u2228P (f (x1 ,\n. . . , xn )) and C2 [xr+1 , . . . , x2r ] = \u2212P (f (y1 , . . . , yn )) \u2228 C2\u2032 [xr+1 , . . . , x2r ] \u2228\nD2 and the resolvent is C[x1 , . . . , xr ] = C1\u2032 [x1 , . . . , xr ]\u03c3\u2228C2\u2032 [xr+1 , . . . , x2r ]\u03c3\u2228\nD1 \u2228 D2 where, by Lemma 6, \u03c3 is such that {x1 , . . . , xn }\u03c3 \u2286 {x1 , . . . , xn }\nand yi \u03c3 = xi for 1 \u2264 i \u2264 n. \u03c0(C1 ) \u222a \u03c0(C2 ) \u000fp C[x1 , . . . , xr ]. Hence\nI(S) \u2287 I4 (C1 [x1 , . . . , xr ])\u222aI4 (C2 [x1 , . . . , xr ]) = \u03c0(C1 [x1 , . . . , xr ])\u222aC1 [Ngrr\n\u222a Ngrr[Ngrr[G1 ]]] \u222a \u03c0(C2 [x1 , . . . , xr ]) \u222a C2 [Ngrr \u222a Ngrr[Ngrr[G1 ]]] \u000fp \u03c0(C[x1 ,\n. . . , xr ]) \u222a C[Ngrr \u222a Ngrr[Ngrr[G1 ]]] = I4 (C[x1 , . . . , xr ]).\n\u2022 Suppose C1\u2032 or C2\u2032 has a non-trivial literal. Then C is of type C4, no replacement or splitting rules apply, S \u2032 = S \u222a {C} and the first statement\n23\n\n\fholds.\n\u2022 Suppose C1\u2032 and C2\u2032 contain no non-trivial literal. Then C[x1 , . . . , xr ] =\nB1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2228 D1 \u2228 D2 with 1 \u2264 i1 , . . . , ik \u2264 r, each Bi being\nan \u01eb-block. No splitting or replacement rules apply (\u01eb-splitting is forbidden\nby \u03c60 ), and S \u2032 = S \u222a {C}. The second statement holds.\n11. We do a resolution step in which one of the premises is a clause from cl(R).\nEvery clause in cl(R) is of type C2. Also trivially I2 (C) \u2286 I(T ). Hence this\ncase can be dealt with in the same way as in the case where one of the premises\nof resolution is a clause of type C2.\nNext we consider factoring steps. Factoring on a clause of type C1 or C3 is possible\nonly if the two involved literals are the same, hence this is equivalent to doing nothing.\n1. We do factoring on a clause C1 [xr+1 ] = C1\u2032 [xr+1 ]\u2228\u00b1P (s[xr+1 ])\u2228\u00b1P (t[xr+1 ])\nof type C2, and from S upto renaming. We know that s[xr+1 ], t[xr+1 ] \u2208 Ngr1 ,\nand by ordering constraints s and t are non trivial. The clause obtained is\nC[xr+1 ] = C1\u2032 [xr+1 ]\u03c3 \u2228 \u00b1P (s[xr+1 ])\u03c3 where \u03c3 is a unifier of s[xr+1 ] and\nt[xr+1 ]. If s[xr+1 ] 6= t[xr+1 ] then by Lemma 3 xr+1 \u03c3 is a ground strict subterm of s or t, hence xr+1 \u03c3 \u2208 G \u2286 Ngrr[G1 ]. Each literal in C is of the\nform \u00b1\u2032 Q(t\u2032 ) where t\u2032 \u2208 Ngr1 [Ngrr[G1 ]]. Hence C is of type C3. No splitting or replacement rules apply and S \u2032 = S \u222a {C}. We have C \u2208 C1 [Ngrr[G1 ]].\nI(S) \u2287 I2 (C1 [xr+1 ]) \u2287 C1 [xr+1 ][Ngrr[G1 ]] \u2287 I3 (C) = {C}. The first statement holds.\n2. We do factoring on a clause C1 [x1 , . . . , xr ] of type C4, and from S upto renaming, to obtain the clause C[x1 , . . . , xr ]. By ordering constraints non-trivial\nliterals must be chosen for factoring. Then C[x1 , . . . , xr ] is again of type C4 and\nC[x1 , . . . , xr ] \u2208 \u03c0(C1 ). I(S) \u2287 I4 (C1 ) = \u03c0(C1 )\u222aC1 [Ngrr\u222aNgrr[Ngrr[G1 ]]] \u000fp\n\u2737\nI4 (C). The first statement holds.\nThe alternative resolution procedure for testing unsatisfiability by using succinct\nrepresentations of tableaux is now defined by the rule: T | S \u25ee T | S \u222a {B1 \u2294 D} |\nS \u222a {B2 } | . . . | S \u222a {Bk } whenever I(S) \u000fp B1 \u2294 . . . \u2294 Bk \u2294 D, each Bi is an \u01eb-block,\n1 \u2264 i1 , . . . , ik \u2264 r and D \u2286 \u00b1Q. The simulation property now states:\nLemma 1 If S \u2291 T and S \u21db\u227as ,\u03c6,R T then T \u25ee\u2217 T \u2032 for some T \u2032 such that T \u2291 T \u2032 .\nProof: As S \u21db\u227as ,\u03c6,R T , we have some S \u2032 such that S \u21db\u227as ,\u03c60 ,R S \u2032 and T is obtained\nfrom S \u2032 by \u01eb-splitting steps. From Lemma 10, one of the following cases holds.\n\u2022 S \u2032 \u2291 S. Then S \u2032 contains only clauses of type C1-C4 and no \u01eb-splitting is\napplicable. Hence T = S \u2032 \u2291 S. As T \u2291 S and S \u2291 T hence T \u2291 T because\nof transitivity of \u2291. Thus T is the required T \u2032 .\n\u2022 S \u2032 = S \u222a {C} \u222a S \u2032\u2032 , C is a renaming of B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2294 D where\neach Bi is an \u01eb-block, 1 \u2264 i1 , . . . , ik \u2264 r, D \u2286 \u00b1Q, I(S) \u000fp C and S \u2032\u2032 is a\nset of clauses of type C3 and \u2205 \u000fp S \u2032\u2032 . We have T = S \u222a S \u2032\u2032 \u222a {B1 \u2294 D} |\n24\n\n\fS \u222aS \u2032\u2032 \u222a{B2 } | . . . | S \u222aS \u2032\u2032 \u222a{Bk }. We have S \u222aS \u2032\u2032 \u222a{B1 \u2294D} \u2291 T \u222a{B1 \u2294D}\nand S \u222a S \u2032\u2032 \u222a {Bi } \u2291 T \u222a {Bi } for 1 \u2264 i \u2264 k. We show that the required T \u2032\nis T \u222a {B1 \u2294 D} | T \u222a {B1 } | . . . | S \u222a S \u2032\u2032 \u222a {Bk }. As S \u2291 T hence\nI(T ) \u000fp I(S) \u000fp C. Hence T \u25ee T \u2032 .\n\u2737\nHence as for flat clauses we obtain:\nTheorem 5 Satisfiability for the class C is NEXPTIME-complete.\nProof: Let S be a finite set in C whose satisfiability we want to show. We proceed\nas in the proof of Theorem 3. Wlog if C \u2208 S then C is either a complex clause\nor a one-variable clause. Clearly S is satisfiable iff S \u222a cl(R) is satisfiable. At the\nbeginning we apply the replacement steps using R as long as possible and then Q0 splitting as long as possible. Hence wlog all clauses in S are of type C1-C4. Then\nwe non-deterministically add a certain number of clauses of type C1 to S. Then we\ncheck that the resulting set S \u2032 does not contain \u2737, and is saturated in the sense that: if\nC = B1 [xi1 ]\u2294. . .\u2294Bk [xik ]\u2294D, each Bi is an \u01eb-block, 1 \u2264 i1 , . . . , ik \u2264 r, D \u2286 \u00b1Q0 ,\nand Bj [xr+1 ] \u2208\n/ S \u2032 for 1 \u2264 j \u2264 k, then I(S \u2032 ) 2p C. There are exponentially many\nsuch C to check for since the number of splitting literals in polynomially many. The\nsize of I(S \u2032 ) is exponential.\n\u2737\n\n7 The Horn Case\nWe show that in the Horn case, the upper bound can be improved to DEXPTIME.\nThe essential idea is that propositional satisfiability of Horn clauses is in PTIME instead of NPTIME. But now we need to eliminate the use of tableaux altogether. To\nthis end, we replace the \u01eb-splitting rule of Section 6 by splitting-with-naming. Accordingly we instantiate the set Q used in Section 6 as Q = Q0 \u222a Q1 where Q1 =\n{C | C is a non-empty negative \u01eb-block with predicates from P}. We know that binary resolution and factorization on Horn clauses produces Horn clauses. Replacements on Horn clauses using the rules from R produces Horn clauses. Q1 -splitting\non Horn clauses produces Horn clauses. E.g. clause P (x1 ) \u2228 \u2212Q(x1 ) \u2228 \u2212R(x2 )\nproduces P (x1 ) \u2228 \u2212Q(x1 ) \u2228 \u2212\u2212R(x2 ) and \u2212R(x2 ) \u2228 \u2212R(x2 ). Q0 -splitting on\nP (f (x))\u2228\u2212Q(a) produces P (f (x1 ))\u2228\u2212\u2212Q(a) and \u2212Q(a)\u2228\u2212Q(a) which are Horn.\nHowever Q0 -splitting on C = \u2212P (f (x1 ))\u2228Q(a) produces C1 = \u2212P (f (x1 ))\u2228\u2212Q(a)\nand C2 = Q(a)\u2228Q(a). C2 is not Horn. However C1 = C and C2 = \u2212Q(a)\u2228Q(a) are\nHorn. Finally, as Q1 has exponentially many atoms, we must restrict their occurrences\nin clauses. Accordingly, for 1 \u2264 i \u2264 4, define clauses of type Ci' to be clauses C of the\ntype Ci, such that C is Horn and has at most r negative literals from Q1 . (C is defined\nas before, hence it leaves atoms from Q1 unchanged). Now the Q-splitting-replacement\nstrategy \u03c6h first applies the replacement steps of Section 6 as long as possible, then applies Q0 -splitting as long as possible and then applies Q1 -splitting as long as possible.\nSuccinct representations are now defined as: S \u2291h T iff for each C \u2208 S, C is of type\nCi' and satisfies PiT for some 1 \u2264 i \u2264 4. The abstract resolution procedure is defined\nas: T \u25eeh T \u222a {B1 \u2228 \u2212q2 \u2228 . . . \u2228 \u2212qk \u2294 D \u2294 E} \u222a {Bi \u2228 Bi | 2 \u2264 i \u2264 k} whenever\nI(T ) \u000fp C, C = B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2294 D \u2294 E, C is Horn, 1 \u2264 i1 , . . . , ik \u2264 r, B1\n25\n\n\fis an \u01eb-block, Bi is a negative \u01eb-block and 2 \u2264 i \u2264 k, D \u2286 \u00b1Q0 and E \u2286 \u00b1Q1 such\nthat if k = 1 then E has at most r negative literals, and if k > 1 then E has no negative\nliteral. The \u2291 and \u25ee relations are as in Section 6.\nLemma 2 If S \u2291h T and S \u21db\u227as ,\u03c6h ,R S1 then T \u25eeh \u2217 T1 and S1 \u2291h T1 for some T1 .\nProof: Let \u03c60 be as in Section 6. As S \u21db\u227as ,\u03c6h ,R S1 hence we have some S \u2032 such\nthat S \u21db\u227as ,\u03c60 ,R S \u2032 and S1 is obtained from S \u2032 by applying Q1 -splitting steps. As\ndiscussed above, all clauses C \u2208 S1 \u222a S \u2032 are such that C is also Horn. If S \u2032 is obtained\nby resolving upon splitting literals, then one of the premises must be just a positive\nsplitting literal. The other premise has at most r literals of the form \u2212q with q \u2208 Q1 ,\nhence the resolvent has at most r literals of the form \u2212q with q \u2208 Q1 . In case nonsplitting literals are resolved upon then the premises cannot have any negative splitting\nliteral and the resolvent has no negative splitting literal. Q0 -splitting does not create\nliterals from \u00b1Q1 . Hence all clauses in S \u2032 have at most r literals of the form \u2212q with\nq \u2208 Q1 . Now by Lemma 10, one of the following conditions holds.\n\u2022 S \u2032 \u2291 S. Then Q1 -splitting is not applicable on clauses in S \u2032 and S1 = S \u2032 \u2291 S.\nFrom transitivity of \u2291 we have S1 \u2291 T . Then from the above discussion we\nconclude that S1 \u2291h T .\n\u2022 S \u2032 = S \u222a {C} \u222a S \u2032\u2032 , C is a renaming of B1 [xi1 ] \u2294 . . . \u2294 Bk [xik ] \u2294 D, each\nBi is an \u01eb-block, 1 \u2264 i1 , . . . , ik \u2264 r, D \u2286 \u00b1Q, I(S) \u000fp C, and S \u2032\u2032 is a set\nof clauses of type C3 and \u2205 \u000fp S \u2032\u2032 . Also if k \u2265 2 then D has no literals \u2212q\nwith q \u2208 Q1 . As C is Horn, wlog Bi is negative for i \u2265 2. Hence S1 =\nS \u2032 \u222a {B1 \u2228 \u2212q2 \u2228 . . . \u2228 \u2212qk \u2294 D} \u222a {Bi \u222a Bi | 2 \u2264 i \u2264 k}. We show that the\nrequired T1 is T \u222a {B1 \u2228 \u2212q2 \u2228 . . . \u2228 \u2212qk \u2294 D} \u222a {Bi \u222a Bi | 2 \u2264 i \u2264 k}. Each\nBi \u222aBi is of type C1'. As C \u2208 S \u2032 hence D has at most r literals \u2212q with q \u2208 Q1 .\nHence if k = 1 then B1 \u2228 \u2212q2 \u2228 . . . \u2228 \u2212qk \u2294 D is also of type C1'. If k \u2265 2 then\nD has no negative literals \u2212q with q \u2208 Q1 , and B1 \u2228 \u2212q2 \u2228 . . . \u2228 \u2212qk \u2294 D is\nagain of type C1' since k \u2264 r. As S \u2291h T we have I(T ) \u000fp I(S) \u000fp C. Hence\nT \u25eeh T1 . Finally, clearly S1 \u2291 T1 hence S1 \u2291h T1 .\n\u2737\nNow for deciding satisfiability of a set of flat and one-variable clauses we proceed\nas in the non-Horn case. But now instead of non-deterministically adding clauses,\nwe compute a sequence S = S0 \u25eeh S1 \u25eeh S2 . . . starting from the given set S, and\nproceeding don't care non-deterministically, till no more clauses can be added, and\nthen check whether \u2737 has been generated. The length of this sequence is at most\nexponential. Computing Si+1 from Si requires at most exponential time because the\nnumber of possibilities for C in the definition of \u25ee above is exponential. (Note that\nthis idea of Q1 -splitting would not have helped in the non-Horn case because we cannot\nbound the number of positive splitting literals in a clause in the non-Horn case, whereas\nHorn clauses by definition have at most one positive literal). Also note that APDS can\nbe encoded using flat Horn clauses. Hence:\nTheorem 6 Satisfiability for the classes CHorn and F Horn is DEXPTIME-complete.\n\n26\n\n\fTogether with Theorem 1, this gives us optimal complexity for protocol verification:\nTheorem 7 Secrecy of cryptographic protocols with single blind copying, with bounded\nnumber of nonces but unbounded number of sessions is DEXPTIME-complete.\n\n7.1 Alternative Normalization Procedure\nWhile Theorem 6 gives us the optimum complexity for the Horn case, we outline here\nan alternative normalization procedure for deciding satisfiability in the Horn case, in\nthe style of [14]. Our goal is to show that the Horn case can be dealt with using\nsimpler techniques. This may also be interesting for implementations, since it avoids\nexhaustive generation of instantiations of clauses. Since we already have the optimum\ncomplexity from Theorem 6, we restrict ourselves to giving only the important ideas\nhere. Define normal clauses to be clauses which have no function symbol in the body,\nhave no repetition of variables in the body, and have no variables in the body other than\nthose in the head. Sets of normal definite clauses involving unary predicates can be\nthought of as generalizations of tree automata, by adopting the convention that term t\nis accepted at state P iff atom P (t) is reachable. I.e. states are just unary predicates.\n(Intersection-)emptiness and membership properties are defined as usual.\nLemma 3 Emptiness and membership properties are decidable in polynomial time for\nsets of normal definite clauses.\nProof: Let S be the set of clauses. To test emptiness of a state P , we remove arguments\nof predicate symbols in clauses, and treat predicates as proposition symbols. Then we\nadd the clause \u2212P and check satisfiability of the resulting propositional Horn clause\nset.\nTo test if t is accepted at P , let T be the set of subterms of t. Define a set S \u2032 of\nclauses as follows. If Q(s) \u2228 \u2212Q1 (x1 ) \u2228 . . . \u2228 \u2212Qn (xn ) \u2208 S and s\u03c3 \u2208 T for some\nsubstitution \u03c3 then we add the Horn clause Q(s\u03c3) \u2228 \u2212Q1 (x1 \u03c3) \u2228 . . . \u2228 \u2212Qn (xn \u03c3)\nto S \u2032 . Finally we add \u2212P (t) to S \u2032 and test its unsatisfiability. S \u2032 is computable in\npolynomial time. Also S \u2032 has only ground clauses, hence satisfiability is equivalent to\npropositional unsatisfiability, by treating each ground literal as a propositional symbol.\n\u2737\nThe intuition behind the normalization procedure is as follows. We use new states\nwhich are sets {P1 , P2 , . . . , }, where P1 , P2 , . . . are states in the given clauses set. The\nstate {P1 , P2 , . . . , } represents intersection of the states P1 , P2 , . . .. These new states\nare denoted by p, q, p1 , . . .. The states P in clauses are replaced by {P }. We try to\nmake non-normal clauses redundant by resolving them with normal clauses. Hence\na clause C \u2228 \u2212p(t), where t has some function symbol, is resolved with a normal\nclause p(s) \u2228 D to obtain a clause C\u03c3 \u2228 D\u03c3 where \u03c3 = mgu(s, t). Normal clauses\np(s) \u2228 C and p(t) \u2228 D are used to produce clause (p \u222a q)(s\u03c3) \u2228 C\u03c3 \u2228 D\u03c3 where\n\u03c3 = mgu(s, t). In this process if we get a clause C \u2228 \u2212p(t) where t is ground, then\neither t is accepted at p using the normal clauses and we remove the literal \u2212p(t) from\nthe clause, or t is not accepted at p using the normal clauses, and we reject the clause.\n27\n\n\fFrom clauses C \u2228 \u2212p(x) \u2228 \u2212q(x) we derive the clause C \u2228 \u2212(p \u2228 q)(x). If a clause\np(x1 ) \u2228 \u2212q(x1 ) \u2228 \u2212q1 (x2 ) \u2228 . . . \u2228 \u2212qn (xn ) is produced where the xi are mutually\ndistinct, then either each qi is non-empty using the normal clauses and we replace this\nclause by p(x) \u2228 \u2212q(x), or we reject this clause. The normal clauses p(x) \u2228 \u2212q(x)\nand q(t) \u2228 C produce the clause q(t) \u2228 C. Replacement rules are also applied as in\nthe non-Horn case. We continue this till no more new clauses can be produced. Then\nwe remove all non-normal clauses. We claim that this process takes exponential time\nand each state p in the resulting clause set accepts exactly the terms accepted by each\nP \u2208 p in the original clause set. This also gives us a DEXPTIME algorithm for the\nsatisfiability problem for the class C.\nExample 1 Consider the set S = {C1 , . . . , C5 } of clauses where\nC1\nC2\nC3\nC4\nC5\n\n=\n=\n=\n=\n=\n\nP (a)\nQ(a)\nP (f (g(x1 , a), g(a, x1 ), a)) \u2228 \u2212 P (x1 )\nP (f (g(x1 , a), g(a, x1 ), b)) \u2228 \u2212 P (x1 )\nR(x1 ) \u2228 \u2212 P (f (x1 , x1 , x2 )) \u2228 \u2212Q(x2 )\n\nWe first get the following normal clauses.\nC1\u2032\nC2\u2032\nC3\u2032\nC4\u2032\n\n=\n=\n=\n=\n\n{P }(a)\n{Q}(a)\n{P }(f (g(x1 , a), g(a, x1 ), a)) \u2228 \u2212 {P }(x1 )\n{P }(f (g(x1 , b), g(a, x1 ), b)) \u2228 \u2212 {P }(x1 )\n\nThe clause\nC5\u2032 = {R}(x1 ) \u2228 \u2212{P }(f (x1 , x1 , x2 )) \u2228 \u2212{Q}(x2 )\nis not normal. Resolving it with C3\u2032 gives the clause\n{R}(g(a, a)) \u2228 \u2212{P }(a) \u2228 \u2212{Q}(a)\nAs a is accepted at {P } and {Q} using the normal clauses C1\u2032 and C2\u2032 , hence we get a\nnew normal clause\nC6 = {R}(g(a, a))\nResolving C5\u2032 with C4\u2032 gives\n{R}(g(a, a)) \u2228 \u2212{P }(a) \u2228 \u2212{Q}(b)\nBut b is not accepted at {Q} using the normal clauses hence this clause is rejected.\nFinally C1\u2032 and C2\u2032 also give the normal clause\nC7 = {P, Q}(a)\nThe resulting set of normal clauses is {C1\u2032 , . . . , C4\u2032 , C6 , C7 }.\n\n28\n\n\f8 Conclusion\nWe have proved DEXPTIME-hardness of secrecy for cryptographic protocols with single blind copying, and have improved the upper bound from 3-DEXPTIME to DEXPTIME. We have improved the 3-DEXPTIME upper bound for satisfiability for the class\nC to NEXPTIME in the general case and DEXPTIME in the Horn case, which match\nknown lower bounds. For this we have invented new resolution techniques like ordered\nresolution with splitting modulo propositional reasoning, ordered literal replacements\nand decompositions of one-variable terms. As byproducts we obtained optimum complexity for several fragments of C involving flat and one-variable clauses. Security\nfor several other decidable classes of protocols with unbounded number of sessions\nand bounded number of nonces is in DEXPTIME, suggesting that DEXPTIME is a\nreasonable complexity class for such classes of protocols.\n\nReferences\n[1] A. Aiken, D. Kozen, M. Vardi, and E. Wimmers. The complexity of set constraints. In CSL'93, volume 832 of LNCS, pages 1\u201317. Springer-Verlag, 1993.\n[2] L. Bachmair and H. Ganzinger. Resolution theorem proving. In J. A. Robinson\nand A. Voronkov, editors, Handbook of Automated Reasoning, volume I, chapter 2, pages 19\u201399. North-Holland, 2001.\n[3] B. Blanchet. An efficient cryptographic protocol verifier based on Prolog rules. In\n14th IEEE Computer Security Foundations Workshop (CSFW'01), pages 82\u201396.\nIEEE Computer Society Press, Cape Breton, Nouvelle-\u00c9cosse, Canada, 2001.\n[4] A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation. Journal of the\nACM, 28(1), Jan. 1981.\n[5] H. Comon and V. Cortier. Tree automata with one memory, set constraints and\ncryptographic protocols. Theoretical Computer Science, 331(1):143\u2013214, 2005.\n[6] H. Comon-Lundh and V. Cortier. New decidability results for fragments of firstorder logic and application to cryptographic protocols. In R. Nieuwenhuis, editor, 14th International Conference on Rewriting Techniques and Applications\n(RTA'03), volume 2706 of LNCS, pages 148\u2013164, Valencia, Spain, June 2003.\nSpringer-Verlag.\n[7] H. Comon-Lundh and V. Cortier. Security properties: Two agents are sufficient. In 12th European Symposium on Programming (ESOP'03), volume 2618\nof LNCS, pages 99\u2013113, Warsaw, Poland, Apr. 2003. Springer-Verlag.\n[8] V. Cortier. V\u00e9rification Automatique des Protocoles Cryptographiques. PhD thesis, ENS Cachan, France, 2003.\n[9] N. A. Durgin, P. Lincoln, J. Mitchell, and A. Scedrov. Undecidability of bounded\nsecurity protocols. In Workshop on Formal Methods and Security Protocols\n(FMSP'99), Trento, Italy, 1999.\n29\n\n\f[10] H. Ganzinger and K. Korovin. New directions in instantiation-based theorem\nproving. In P. G. Kolaitis, editor, 18th Annual IEEE Symposium on Logic in\nComputer Science (LICS'03), pages 55\u201364, Ottawa, Canada, June 2003. IEEE\nComputer Society Press.\n[11] J. Goubault-Larrecq.\nR\u00e9solution ordonn\u00e9e avec s\u00e9lection et classes\nd\u00e9cidables de la logique du premier ordre. Lecture notes for the course\n\"d\u00e9monstration automatique et v\u00e9rification de protocoles cryptographiques\"\n(with Hubert Comon-Lundh), DEA \"programmation\", 2004.\n71 pages,\nhttp://www.lsv.ens-cachan.fr/ \u0303goubault/SOresol.ps.\n[12] J. Goubault-Larrecq, M. Roger, and K. N. Verma. Abstraction and resolution\nmodulo AC: How to verify Diffie-Hellman-like protocols automatically. Journal\nof Logic and Algebraic Programming, 64(2):219\u2013251, Aug. 2005.\n[13] D. Monniaux. Abstracting cryptographic protocols with tree automata. In\nA. Cortesi and G. Fil\u00e9, editors, 6th International Static Analysis Symposium\n(SAS'99), volume 1694 of LNCS, pages 149\u2013163, Venice, Italy, September 1999.\nSpringer-Verlag.\n[14] F. Nielson, H. R. Nielson, and H. Seidl. Normalizable Horn clauses, strongly recognizable relations and Spi. In 9th Static Analysis Symposium (SAS'02), volume\n24477 of LNCS, pages 20\u201335. Springer-Verlag, 2002.\n[15] A. Riazanov and A. Voronkov. Splitting without backtracking. In IJCAI'01, pages\n611\u2013617, 2001.\n[16] M. Rusinowitch and M. Turuani. Protocol insecurity with finite number of\nsessions is NP-complete. In P. Pandya and J. Radhakrishnan, editors, 14th\nIEEE Computer Security Foundations Workshop (CSFW'01), Cape Breton, NovaScotia, Canada, June 2001. IEEE Computer Society Press.\n[17] C. Weidenbach. Towards an automatic analysis of security protocols. In\nH. Ganzinger, editor, 16th International Conference on Automated Deduction\n(CADE'99), number 1632 in LNAI, pages 378\u2013382. Springer-Verlag, 1999.\n\nA\n\nProofs of Section 4\n\nWe use the following unification algorithm, due to Martelli and Montanari. It is described by the following rewrite rules on finite multisets of equations between terms;\nwe let M be any such multiset, and comma denote multiset union:\n.\n(Delete) M, u = u \u2192 M\n.\n.\n.\n(Decomp) M, f (u1 , . . . , un ) = f (v1 , . . . , vn ) \u2192 M, u1 = v1 , . . . , un = vn\n.\n.\n(Bind) M, x = v \u2192 M [x := v], x = v provided x is not free in v, but is free in M .\n.\n(Fail1) M, x = v \u2192 \u22a5 provided x is free in v and x 6= v.\n30\n\n\f.\n(Fail2) M, f (u1 , . . . , um ) = g(v1 , . . . , vn ) \u2192 \u22a5 provided f 6= g.\n.\nWe consider that equations u = v are unordered pairs of terms u, v, so that in particular\n.\n.\nu = v and v = u are the same equation. \u22a5 represents failure of unification. If s and\n.\nt are unifiable, then this rewrite process terminates, starting from s = t, on a so-called\n.\n.\nsolved form z1 = u1 , . . . , zk = uk ; then \u03c3 = {z1 7\u2192 u1 , . . . , zk 7\u2192 uk } is an mgu of\n.\ns = t.\nLemma 4 Let s[x] and t[y] be two non-ground non-trivial one-variable terms, and\nx 6= y. Let U be the set of non-ground strict subterms of s and t and let V be the set of\nground strict subterms of s and t. If s[x] and t[y] are unifiable then they have a mgu \u03c3\nsuch that one of the following is true:\n\u2022 \u03c3 = {x 7\u2192 u[y]} where u \u2208 U .\n\u2022 \u03c3 = {y 7\u2192 u[x]} where u \u2208 U .\n\u2022 \u03c3 = {x 7\u2192 u, y 7\u2192 v} where u, v \u2208 U [V ].\nProof: Note that V \u2286 U [V ] since U contains the trivial terms also. We use the above\n.\nunification algorithm. We start with the multiset M0 = s = t. We claim that if\nM0 \u2192+ M then M is of one of the following forms:\n1. s1 [x] = t1 [y], . . . , sn [x] = tn [y], where each si , ti \u2208 U \u222a V , some si \u2208 U and\nsome tj \u2208 U .\n2. s1 [u[y \u2032 ]] = t1 [y \u2032 ], . . . , sn [u[y \u2032 ]] = tn [y \u2032 ], x\u2032 = u[y \u2032 ] where u \u2208 U , each si , ti \u2208\nU \u222a V , x\u2032 \u2208 {x, y} and y \u2032 \u2208 {x, y} \\ {x\u2032 }.\n3. s1 [u] = t1 [y \u2032 ], . . . , sn [u] = tn [y \u2032 ], x\u2032 = u where u \u2208 V , each si , ti \u2208 U \u222a V ,\nsome ti \u2208 U , x\u2032 \u2208 {x, y} and y \u2032 \u2208 {x, y} \\ {x\u2032 }.\n4. M \u2032 , x = u, y = v where u, v \u2208 U [V ], and no variables occur in M \u2032 .\n5. \u22a5.\nAs s and t are non-trivial, and x and y are distinct, hence (Delete) and (Bind) don't\napply on M0 . Applying (Decomp) on M0 leads us to type (1). Applying (Fail1) or\n(Fail2) on any M leads us to \u22a5. Applying (Delete) and (Decomp) on type (1) keeps us\nin type (1). Applying (Bind) on type (1) leads to type (2) or (3) depending on whether\nthe concerned variable is replaced by a non-ground or ground term. Applying (Delete)\non type (2) leads to type (2) itself. Applying (Decomp) on type (2) leads to type (2)\n.\nitself. (Bind) applies on M of type (2) only if M contains some y \u2032 = v where v\nis ground. We must have v \u2208 V . The result is of type (4). Applying (Delete) and\n(Decomp) rules on type (3) leads to type (3) itself. (Bind) applies on M of type (3)\n.\nonly if M contains some y \u2032 = v where v is ground. We must have v \u2208 U [V ]. The\nresult is of type (4). Applying (Delete) and (Decomp) on type (4) leads to type (4)\nitself, and (Bind) does not apply.\nNow we look at the solved forms. Solved forms of type (1) are of the form either\n.\n.\n.\n.\nx = u[y] with u \u2208 U , or y = u[x] with u \u2208 U , or x = u, y = v with u, v \u2208 V \u2286 U [V ].\n31\n\n\fM of type (2) is in solved form only if n = 0. Hence the solved forms are again of the\n.\n.\nform x = u[y] or y = u[x] with u \u2208 U . M of type (3) is in solved form only if n = 1,\n.\n.\nhence M is of the form x = u, y = v with u, v \u2208 U [V ]. Solved forms of type (4) are\n.\n.\nagain of type x = u, y = v with u, v \u2208 U [V ] (i.e. M \u2032 is empty).\n\u2737\nLemma 2 Let s[x] and t[y] be reduced, non-ground and non-trivial terms where x 6= y\nand s[x] 6= t[x]. If s and t have a unifier \u03c3 then x\u03c3, y\u03c3 \u2208 U [V ] where U is the set\nof non-ground (possibly trivial) strict subterms of s and t, and V is the set of ground\nstrict subterms of s and t.\nProof: By Lemma 4, s[x] and t[y] have a mgu \u03c3 \u2032 such that one of the following is true:\n\u2022 \u03c3 \u2032 = {x 7\u2192 u[y]} where u \u2208 U . We have s[u[y]] = t[y]. As t is reduced,\nthis is possible only if u is trivial. Hence s[y] = t[y], so s[x] = t[x]. This is a\ncontradiction.\n\u2022 \u03c3 \u2032 = {y 7\u2192 u[x]} where u \u2208 U . This case is similar to the previous case.\n\u2022 \u03c3 \u2032 = {x 7\u2192 u, y 7\u2192 v} where u, v \u2208 U [V ]. As \u03c3 \u2032 is the mgu and maps x and y\nto ground terms, hence \u03c3 = \u03c3 \u2032 .\n\u2737\nLemma 3 Let \u03c3 be a unifier of two non-trivial, non-ground and distinct one-variable\nterms s[x] and t[x]. Then x\u03c3 is a ground strict subterm of s or of t.\nProof: We use the above unification algorithm. We start with the multiset M0 =\ns[x] = t[x]. If M0 \u2192+ M then M is of one of the following forms:\n1. s1 [x] = t1 [x], . . . , sn [x] = tn [x] where each si is a strict subterm of s and each\nti is a strict subterm of t\n2. M, x = u where u is a ground strict subterm of s or t, and no variables occur in\nM\n3. \u22a5.\n.\nThen it is easy to see that the only possible solved form is x = u where u is a\nground strict subterm of s or t.\n\u2737\n\nB Proofs of Section 6\nTheorem 4 Modified ordered resolution, wrt a stable and enumerable ordering, with\nsplitting and Q-splitting and ordered literal replacement is sound and complete for\nany strategy. I.e. for any set S of P-clauses, for any strict stable and enumerable\npartial order < on atoms, for any set R of ordered replacement rules, for any finite\nset Q of splitting atoms, and for any Q-splitting-replacement strategy \u03c6, S \u222a cl(R) is\nunsatisfiable iff S \u21db\u2217<s ,\u03c6,R T for some closed T .\n\n32\n\n\fProof: A standard Herbrand interpretation is a Herbrand interpretation H such that\nC \u2208 H iff H does not satisfy C. This leads us to the notion of standard satisfiability\nas expected. The given set S of P-clauses is satisfiable iff it is standard-satisfiable.\nOrdered resolution, factorization and splitting preserve satisfiability in any given Herbrand interpretation, and Q-splitting preserves satisfiability in any given standardHerbrand interpretation. Also if T \u2192R T \u2032 then T \u222a cl(R) is satisfiable in a Herbrand\ninterpretation iff T \u2032 \u222acl(R) is satisfiable in that interpretation. This proves correctness:\nif S \u21db\u2217<s ,\u03c6,R T and T is closed then S \u222a cl(R) is unsatisfiable.\nFor completeness we replay the proof of [11] for ordered resolution with selection\nspecialized to our case, and insert the arguments required for the replacement rules.\nSince < is enumerable, hence we have an enumeration A\u20321 , A\u20322 , . . . of all ground atoms\nsuch that if A\u2032i < A\u2032j then i < j. Also there are only finitely many splitting atoms in\nQ, all of which are smaller than non-splitting atoms. Hence the set of all (splitting as\nwell as non-splitting) atoms can be enumerated as A1 , A2 , . . . such that if Ai <s Aj\nthen i < j. Clearly all the splitting atoms occur before the non-splitting atoms in this\nenumeration. Consider the infinite binary tree T whose nodes are literal sequences of\nthe form \u00b11 A1 \u00b12 A2 . . . \u00b1k Ak for k \u2265 0. The two successors of the node N are\nN + Ak+1 (the left child) and N \u2212 Ak+1 (the right child). If k = 0 then N is a root\nnode. Furthermore we write \u2212N = \u22131 Ai \u22132 A2 . . . \u2213k Ak . A clause fails at a node\nN if there is some ground substitution \u03c3 such that for every literal L \u2208 C, L\u03c3 is in\n\u2212N . For any set T of clauses define TT as the tree obtained from T by deleting the\nsubtrees below all nodes of T where some clause of T fails. A failure-witness for a\nset T of clauses is a tuple (T\u2032 , C\u2022 , \u03b8\u2022 ) such that T\u2032 = TT is finite, CN is a clause\nfor each leaf node N of T\u2032 , and \u03b8N is a ground substitution for each leaf node N of\nT\u2032 such that for \u2212N contains every L \u2208 CN \u03b8N . We define \u03bd(T\u2032 ) as the number of\nnodes in T\u2032 . For any failure witness of the form (T\u2032 , C\u2022 , \u03b8\u2022 ) and for any leaf node\nN = \u00b11 A1 \u00b12 A2 . . . \u00b1k Ak of T\u2032 , define \u03bc1 (CN , \u03b8N ) as follows:\n\u2013 If CN \u2208\n/ cl(R) then \u03bc1 (CN , \u03b8N ) is the multiset of integers which contains the integer\ni as many times as there are literals \u00b1A\u2032 \u2208 CN such that A\u2032 \u03b8N = Ai .\n\u2013 If CN \u2208 cl(R) then \u03bc1 (CN , \u03b8N ) is the empty multiset.\nWe define \u03bc\u2212 (T\u2032 , C\u2022 , \u03b8\u2022 ) as the multiset of the values \u03bc1 (CN , \u03b8N ) where N ranges\nover all leaf nodes of T\u2032 . We define \u03bc(T\u2032 , C\u2022 , \u03b8\u2022 ) = (\u03bd(T\u2032 ), \u03bc\u2212 (T\u2032 , C\u2022 , \u03b8\u2022 )). We\nconsider the lexicographic ordering on pairs, i.e. (x1 , y1 ) < (x2 , y2 ) iff either x1 < x2 ,\nor x1 = x2 and y1 < y2 . Since S \u222a cl(R) is unsatisfiable, from K\u00f6nig's Lemma:\nLemma 5 S \u222a cl(R) has a failure witness.\nLemma 6 If T has a failure witness (TT , C\u2022 , \u03b8\u2022 ) such that TT is not just the root\nnode, then there is some T \u2032 with a failure witness (TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) such that T \u21db<s T \u2032\nand \u03bc(TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) < \u03bc(TT , C\u2022 , \u03b8\u2022 ).\n.\n.\nProof: In the following the notion of mgu is generalized and we write mgu(s1 = . . . =\nsn ) for the most general substitution which makes s1 , . . . , sn equal. We iteratively\ndefine a sequence R0 , R1 , . . . of nodes, none of which is a leaf node. R0 is the empty\nsequence which is not a leaf node. Suppose we have already defined Ri . As Ri is not\na leaf node, Ri has a descendant Ni such that Ni \u2212 Bi is rightmost leaf node in the\nsubtree of TT rooted at Ri .\n33\n\n\f(1) If Bi is a non-splitting atom then stop the iteration.\n(2) Otherwise Bi is a splitting atom.\n(2a) If the subtree rooted at Ni + Bi has some leaf node N such that \u2212Bi \u2208 CN\nthen stop the iteration.\n(2b) Otherwise Ni + Bi cannot be a leaf node. Define Ri+1 = Ni + Bi and\ncontinue the iteration.\nTT is finite hence the iteration terminates. Let k be the largest integer for which\nRk , and hence Nk and Bk are defined. For 0 \u2264 i \u2264 k \u2212 1, Bi is a splitting literal. The\nonly positive literals in the sequence Nk are from the set {B0 , . . . , Bk\u22121 }. Nk \u2212 Bk is\na leaf node of TT .\nSuppose the iteration stopped in case (1) above. Then Nk has some descendant\nN such that its two children N \u2212 B and N + B are leaf nodes of TT , and B is a\nnon-splitting literal. As Bk is a non-splitting literal, no negative splitting literals are\n\u2032\npresent in CN \u2212B or CN +B . CN \u2212B is of the form C1 \u2228 B1\u2032 \u2228 . . . \u2228 Bm\n(m \u2265 1)\n\u2032\n\u2032\nsuch that B1 \u03b8N \u2212B = . . . = Bm \u03b8N \u2212B = B and each literal in C1 \u03b8N \u2212B is present\n\u2032\nin \u2212N . The literals B1\u2032 , . . . , Bm\nare then maximal in CN \u2212B and can be selected for\nresolution. CN +B is of the form C2 \u2228 \u2212B1\u2032\u2032 \u2228 . . . \u2228 \u2212Bn\u2032\u2032 (n \u2265 1) such that B1\u2032\u2032 \u03b8N +B =\n. . . = Bn\u2032\u2032 \u03b8N +B = B and each literal in C2 \u03b8N +B is present in \u2212N . The literals\nB1\u2032\u2032 , . . . , Bn\u2032\u2032 are then maximal in CN +B and can be selected for resolution. We assume\nthat CN \u2212B and CN +B are renamed apart so as not to share variables. Let \u03b8 be a\nground substitution which maps each x \u2208 fv(CN \u2212B ) to x\u03b8N \u2212B and x \u2208 fv(CN +B ) to\n.\n\u2032\nx\u03b8N +B . We have B1\u2032 \u03b8 = . . . = Bm\n\u03b8 = B1\u2032\u2032 \u03b8 = . . . = Bn\u2032\u2032 \u03b8. Then \u03c3 = mgu(B1\u2032 =\n.\n.\n.\n\u2032\u2032\n\u2032\u2032 .\n\u2032\n. . . = Bm = B1 = . . . = Bn ) exists. Hence we have some ground substitution\n\u03b8\u2032 such that \u03c3\u03b8\u2032 = \u03b8. Hence by repeated applications of the ordered factorization\nand ordered binary resolution rule, we obtain the resolvent C = C1 \u03c3 \u2228 C2 \u03c3, and\nT \u21db<s T \u2032 = T \u222a {C}. We have C\u03b8\u2032 = C1 \u03b8 \u2228 C2 \u03b8. Hence C fails at node N .\nThen TT \u2032 is finite and \u03bd(TT \u2032 ) < \u03bd(TT ). Hence by choosing any C\u2022\u2032 and \u03b8\u2022\u2032 such that\n(TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) is a failure witness for T \u2032 , we have \u03bc(TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) < \u03bc(TT , C\u2022 , \u03b8\u2022 ).\nIf the iteration didn't stop in case (1) but in case (2a) then it means that Bk is a\nsplitting literal. Then CNk \u2212Bk = C1 \u2228 +Bk (with Bk \u2208\n/ C1 ). C1 has no negative\nsplitting literals. Hence the only literals in C1 are positive splitting literals. Hence the\nliteral Bk can be chosen from CNk \u2212Bk for resolution. The subtree rooted at Nk + Bk\nhas some leaf node N such that \u2212Bk \u2208 CN . Then CN = C2 \u2228 \u2212Bk (and \u2212Bk \u2208\n/ C2 ).\nHence \u2212Bk can be selected from CN for resolution. We obtain the resolvent C2 \u2228 C1\nwhich fails at N . Let T \u2032 = T \u222a {C1 \u2228 C1 }. We have \u03bd(TT \u2032 ) \u2264 \u03bd(TT ). If N \u2032 is\nthe highest ancestor of N where C2 \u2228 C1 fails then N \u2032 is a leaf of TT \u2032 and we define\n\u2032\n\u2032\n\u2032\n\u2032\nCN\n\u2032 = C2 \u2228C1 and \u03b8N \u2032 = \u03b8N . We have \u03bc1 (CN \u2032 , \u03b8N \u2032 ) < \u03bc1 (CN , \u03b8N ) since all literals\nin C1 are splitting literals \u00b1q such that q occurs strictly before Bk in the enumeration\nA1 , A2 , . . .. (Also note that CN \u2208\n/ cl(R) because CN contains a splitting literal).\n\u2032\nAll other leaf nodes N \u2032\u2032 of TT \u2032 are also leaf nodes of TT and we define CN\n\u2032\u2032 =\n\u2032\n\u2032\n\u2032\n\u2032\nCN \u2032\u2032 and \u03b8N \u2032\u2032 = \u03b8N \u2032\u2032 . Then (TT \u2032 , C\u2022 , \u03b8\u2022 ) is a failure witness for T and we have\n\u03bc\u2212 (TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) < \u03bc\u2212 (TT , C\u2022 , \u03b8\u2022 ). Hence we have \u03bc(TT \u2032 , C\u2022\u2032 , \u03b8\u2022\u2032 ) < \u03bc(TT , C\u2022 , \u03b8\u2022 ).\n\u2737\n\n34\n\n\fLemma 7 If T has a failure witness (TT , C\u2022 , \u03b8\u2022 ) and T \u2192Q\u2212nspl T \u2032 then T \u2032 \u222a cl(R)\nhas a failure witness (TT \u2032 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) with \u03bc(TT \u2032 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ).\nProof: Let C = C1 \u2294 C2 \u2208 T , C2 is a non-empty P-clause, C1 has at least one nonsplitting literal, and T \u2192Q\u2212nspl T \u2032 = (T \\ {C}) \u222a {C1 \u2228 \u2212C2 , C2 \u2228 C2 }. If C 6= CN\nfor any leaf node N of TT then there is nothing to show. Now suppose C = CN where\nN is a leaf node of TT . If CN \u2208 cl(R) then there is nothing to prove. Now suppose\nCN \u2208\n/ cl(R). As C is constrained to contain at least one non-splitting literal, hence\nthe literal sequence N has at least one non-splitting literal. By the chosen enumeration\nA1 , A2 , . . ., either C2 or \u2212C2 occurs in the literal sequence N .\n\u2022 If C2 occurs in N then C1 \u2228 \u2212C2 fails at N . Let N \u2032 be the highest ancestor\n\u2032\u2032\nof N where it fails. N \u2032 is a leaf node of TT \u2032 . We define CN\n\u2032 = C1 \u2228 \u2212C2\n\u2032\u2032\n\u2032\u2032\nand \u03b8N \u2032 = \u03b8N . All other leaf nodes N of TT \u2032 are also leaf nodes of TT and\n\u2032\u2032\n\u2032\u2032\n\u2032\u2032 \u2032\u2032\nwe define CN\n\u2032\u2032 = CN \u2032\u2032 and \u03b8N \u2032\u2032 = \u03b8N \u2032\u2032 . (TT \u2032 , C\u2022 , \u03b8\u2022 ) is a failure witness\n\u2032\n\u2032\u2032\n\u2032\u2032\nfor T . As C2 has at least one non-splitting literal, we have \u03bc1 (CN\n\u2032 , \u03b8N \u2032 ) <\n\u2032\u2032\n\u2032\u2032\n\u03bc1 (CN , \u03b8N ) (recall that CN \u2208\n/ cl(R)) so that \u03bc(TT \u2032 , C\u2022 , \u03b8\u2022 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ).\nAs T \u2032 \u2286 T \u2032 \u222a cl(R) hence the result follows.\n\u2022 If \u2212C2 occurs in N then C2 \u2228 C2 fails at N . Since C1 has at least one nonsplitting literal, as in the previous case, we obtain a failure witness (TT \u2032 , C\u2022\u2032\u2032 , \u03b8\u2022\u2032\u2032 )\nsuch that \u03bc(TT \u2032 , C\u2022\u2032\u2032 , \u03b8\u2022\u2032\u2032 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ).\n\u2737\nLemma 8 If T has a failure witness (TT , C\u2022 , \u03b8\u2022 ) and T \u2192spl T1 | T2 then T1 \u222a cl(R)\nand T2 \u222a cl(R) have failure witnesses (TT1 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) and (TT2 \u222acl(R) , C\u2022\u2032\u2032 , \u03b8\u2022\u2032\u2032 )\nsuch that \u03bc(TT1 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ) and \u03bc(TT2 \u222acl(R) , C\u2022\u2032\u2032 , \u03b8\u2022\u2032\u2032 ) \u2264\n\u03bc(TT , C\u2022 , \u03b8\u2022 ).\nProof: Let C = C1 \u2294 C2 \u2208 T such that C1 and C2 share no variables, and we have\nT \u2192spl T1 | T2 where Ti = T \u222a {Ci }. We prove the required result for T1 , the\nother part is symmetric. If C 6= CN for any leaf node N of TT then there is nothing\nto show. Now suppose C = CN for some leaf node N of TT . If CN \u2208 cl(R) then\nthere is nothing to show. Now suppose CN \u2208\n/ cl(R). Since C1 \u2286 C, hence C1 also\nfails at N . Let N \u2032 be the highest ancestor of N where C1 fails. N \u2032 is a leaf node of\n\u2032\u2032\u2032\n\u2032\u2032\u2032\n\u2032\u2032\nTT1 . We define CN\nof TT1 are also leaf\n\u2032 = C and \u03b8N \u2032 = \u03b8. All other leaf nodes N\n\u2032\u2032\u2032\n\u2032\u2032\u2032\nnodes of TT , and we define CN \u2032\u2032 = CN \u2032\u2032 and \u03b8N \u2032\u2032 = \u03b8N \u2032\u2032 . (TT1 , C\u2022\u2032\u2032\u2032 , \u03b8\u2022\u2032\u2032\u2032 ) is a failure\n\u2032\u2032\u2032\n\u2032\u2032\u2032\nwitness for T1 . Also \u03bc1 (CN\n/ cl(R)). Hence\n\u2032 , \u03b8N \u2032 ) \u2264 \u03bc1 (CN , \u03b8N ) (recall that CN \u2208\n\u2032\u2032\u2032\n\u2032\u2032\u2032\n\u03bc(TT \u2032 , C\u2022 , \u03b8\u2022 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ). As T1 \u2286 T1 \u222a cl(R), hence the result follows.\nThe following arguments are the ones that take care of replacement steps.\nLemma 9 If T has a failure witness (TT , C\u2022 , \u03b8\u2022 ) and T \u2192R T \u2032 then T \u2032 \u222a cl(R) has\na failure witness (TT \u2032 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) with \u03bc(TT \u2032 \u222acl(R) , C\u2022\u2032 , \u03b8\u2022\u2032 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ).\nProof: Let C1 = C1\u2032 \u2228 \u00b1A\u03c3 \u2208 T , R = A \u2192 B \u2208 R, and T \u2192R T \u2032 = (T \\\n{C1 }) \u222a {C} where C = C1\u2032 \u2228 \u00b1B\u03c3. If C1 6= CN for any leaf node of TT then\nthere is nothing to prove. Now suppose that C1 = CN for some leaf node N of\nTT . Let N = \u00b11 A1 . . . \u00b1k Ak . If C1 \u2208 cl(R) then T \u2286 T \u2032 \u222a cl(R), and there\nis nothing to prove. Now suppose C1 \u2208\n/ cl(R). We have a ground substitution \u03b8\n35\n\n\fsuch that C1 \u03b8 = C1\u2032 \u03b8 \u2228 \u00b1A\u03c3\u03b8 \u2286 {\u22131 A1 , . . . , \u2213k Ak }. As R is ordered we have\nA \u2265 B. Hence A\u03c3\u03b8 \u2265 B\u03c3\u03b8. Hence either \u00b1B\u03c3\u03b8 \u2208 {\u22131 A1 , . . . , \u2213k Ak } or \u2213B\u03c3\u03b8 \u2208\n{\u22131 A1 , . . . , \u2213k Ak }.\n\u2022 Suppose \u00b1B\u03c3\u03b8 \u2208 {\u22131 A1 , . . . , \u2213k Ak }. Since C1 \u03b8 = C1\u2032 \u03b8 \u2228 \u00b1A\u03c3\u03b8 \u2286 {\u22131 A1 ,\n. . . , \u2213k Ak }, hence C\u03b8 = C1\u2032 \u03b8 \u2228 \u00b1B\u03c3\u03b8 \u2286 {\u22131 A1 , . . . , \u2213k Ak }. Hence C fails\nat N . Let N \u2032 be the highest ancestor of N where C fails. N \u2032 is a leaf node of\n\u2032\u2032\n\u2032\u2032\n\u2032\u2032\nTT \u2032 . We define CN\nof TT \u2032 are also\n\u2032 = C and \u03b8N \u2032 = \u03b8. All other leaf nodes N\n\u2032\u2032\n\u2032\u2032\nleaf nodes of TT , and we define CN \u2032\u2032 = CN \u2032\u2032 and \u03b8N \u2032\u2032 = \u03b8N \u2032\u2032 . (TT \u2032 , C\u2022\u2032\u2032 , \u03b8\u2022\u2032\u2032 )\n\u2032\u2032\n\u2032\u2032\nis a failure witness for T \u2032 . Also \u03bc1 (CN\n/\n\u2032 , \u03b8N \u2032 ) \u2264 \u03bc1 (CN , \u03b8N ) (recall that CN \u2208\n\u2032\n\u2032\ncl(R)). Hence \u03bc(TT \u2032 , C\u2022 , \u03b8\u2022 ) \u2264 \u03bc(TT , C\u2022 , \u03b8\u2022 ). As T \u2032 \u2286 T \u2032 \u222a cl(R), hence the\nresult follows.\n\u2022 Suppose \u2213B\u03c3\u03b8 \u2208 {\u22131 A1 , . . . , \u2213k Ak }. Since \u00b1A\u03c3\u03b8 =\u2208 {\u22131 A1 , . . . , \u2213k Ak },\nhence the clause \u2213A \u2228 \u00b1B \u2208 cl(R) fails at N . Let N \u2032 be the highest ancestor of\n\u2032\u2032\nN where \u2213A \u2228 \u00b1B fails. N \u2032 is a leaf node of TT \u2032 \u222a{\u2213A\u2228\u00b1B} . We define CN\n\u2032 =\n\u2032\u2032\n\u2032\u2032\nC and \u03b8N \u2032 = \u03b8. All other leaf nodes N of TT \u2032 \u222a{\u2213A\u2228\u00b1B} are also leaf nodes\n\u2032\u2032\n\u2032\u2032\n\u2032\u2032 \u2032\u2032\nof TT , and we define CN\n\u2032\u2032 = CN \u2032\u2032 and \u03b8N \u2032\u2032 = \u03b8N \u2032\u2032 . (TT \u2032 \u222a{\u2213A\u2228\u00b1B} , C\u2022 , \u03b8\u2022 )\n\u2032\n\u2032\u2032\n\u2032\u2032\nis a failure witness for T \u222a {\u2213A \u2228 \u00b1B}. Also \u03bc1 (CN \u2032 , \u03b8N \u2032 ) \u2264 \u03bc1 (CN , \u03b8N )\n\u2032\u2032\n\u2032\u2032\n\u2032\u2032 \u2032\u2032\nsince \u03bc1 (CN\n\u2032 , \u03b8N \u2032 ) is the empty multiset. Hence \u03bc(TT \u2032 \u222a{\u2213A\u2228\u00b1B} , C\u2022 , \u03b8\u2022 ) \u2264\n\u2032\n\u2032\n\u03bc(TT , C\u2022 , \u03b8\u2022 ). As T \u222a {\u2213A \u2228 \u00b1B} \u2286 T \u222a cl(R), hence the result follows. \u2737\nFor a tableaux T = S1 | . . . | Sn , define T \u222aS = S1 \u222aS | . . . | Sn \u222aS. We define a\nfailure witness for such a T to be a multiset {(TS1 , C\u20221 , \u03b8\u20221 ), . . . , (TSn , C\u20221 , \u03b8\u2022n )} where\neach (TSi , C\u2022i , \u03b8\u2022i ) is a failure witness of Si . We define\n\u03bc({TS1 , C\u20221 , \u03b8\u20221 ), . . . , (TSn , C\u20221 , \u03b8\u2022n }) = {\u03bc(TS1 , C\u20221 , \u03b8\u20221 ), . . . , \u03bc(TSn , C\u20221 , \u03b8\u2022n )}.\nThen it is clear that S \u222a cl(R) has a failure witness and whenever any T has a failure\nwitness in which one of the trees has at least two nodes, then T \u21db<s ,\u03c6,R T \u2032 for some\nT \u2032 such that T \u2032 \u222a cl(R) has a strictly smaller failure witness. Hence we have some T\nsuch that S \u21db\u2217<s ,\u03c6,R T and T \u222a cl(R) has a failure witness in which each tree is a\nroot node. Then T \u222a cl(R) is closed. Hence T is closed.\n\u2737\n\n36\n\n\f"}