{"id": "http://arxiv.org/abs/1104.4279v2", "guidislink": true, "updated": "2013-04-03T12:14:49Z", "updated_parsed": [2013, 4, 3, 12, 14, 49, 2, 93, 0], "published": "2011-04-21T15:01:02Z", "published_parsed": [2011, 4, 21, 15, 1, 2, 3, 111, 0], "title": "Satisfiability of Acyclic and Almost Acyclic CNF Formulas", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.4740%2C1104.1976%2C1104.1095%2C1104.0687%2C1104.2291%2C1104.3988%2C1104.2587%2C1104.0148%2C1104.0772%2C1104.4949%2C1104.4270%2C1104.5705%2C1104.1312%2C1104.1969%2C1104.2263%2C1104.4669%2C1104.3279%2C1104.0303%2C1104.2645%2C1104.2148%2C1104.1217%2C1104.1096%2C1104.5701%2C1104.4575%2C1104.3775%2C1104.3489%2C1104.4945%2C1104.4279%2C1104.1595%2C1104.3058%2C1104.3039%2C1104.3020%2C1104.4007%2C1104.1304%2C1104.1515%2C1104.2725%2C1104.1418%2C1104.3727%2C1104.5547%2C1104.4968%2C1104.3807%2C1104.3912%2C1104.1214%2C1104.3245%2C1104.0957%2C1104.5103%2C1104.3720%2C1104.4416%2C1104.1518%2C1104.0984%2C1104.3671%2C1104.2839%2C1104.5004%2C1104.0459%2C1104.2224%2C1104.5021%2C1104.1963%2C1104.4921%2C1104.0380%2C1104.1084%2C1104.0066%2C1104.5283%2C1104.5022%2C1104.3909%2C1104.4727%2C1104.2870%2C1104.5089%2C1104.2741%2C1104.1813%2C1104.5676%2C1104.3018%2C1104.5165%2C1104.0728%2C1104.3182%2C1104.3876%2C1104.4134%2C1104.0203%2C1104.2521%2C1104.0240%2C1104.0522%2C1104.4923%2C1104.3806%2C1104.1964%2C1104.2092%2C1104.3708%2C1104.0478%2C1104.4787%2C1104.0467%2C1104.4383%2C1104.2035%2C1104.3731%2C1104.4223%2C1104.0026%2C1104.5094%2C1104.4096%2C1104.3850%2C1104.5401%2C1104.1425%2C1104.2247%2C1104.1550%2C1104.1076&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Satisfiability of Acyclic and Almost Acyclic CNF Formulas"}, "summary": "We show that the Satisfiability (SAT) problem for CNF formulas with\n{\\beta}-acyclic hypergraphs can be solved in polynomial time by using a special\ntype of Davis-Putnam resolution in which each resolvent is a subset of a parent\nclause. We extend this class to CNF formulas for which this type of\nDavis-Putnam resolution still applies and show that testing membership in this\nclass is NP-complete. We compare the class of {\\beta}-acyclic formulas and this\nsuperclass with a number of known polynomial formula classes. We then study the\nparameterized complexity of SAT for \"almost\" {\\beta}-acyclic instances, using\nas parameter the formula's distance from being {\\beta}-acyclic. As distance we\nuse the size of a smallest strong backdoor set and the {\\beta}-hypertree width.\nAs a by-product we obtain the W[1]-hardness of SAT parameterized by the\n(undirected) clique-width of the incidence graph, which disproves a conjecture\nby Fischer, Makowsky, and Ravve.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.4740%2C1104.1976%2C1104.1095%2C1104.0687%2C1104.2291%2C1104.3988%2C1104.2587%2C1104.0148%2C1104.0772%2C1104.4949%2C1104.4270%2C1104.5705%2C1104.1312%2C1104.1969%2C1104.2263%2C1104.4669%2C1104.3279%2C1104.0303%2C1104.2645%2C1104.2148%2C1104.1217%2C1104.1096%2C1104.5701%2C1104.4575%2C1104.3775%2C1104.3489%2C1104.4945%2C1104.4279%2C1104.1595%2C1104.3058%2C1104.3039%2C1104.3020%2C1104.4007%2C1104.1304%2C1104.1515%2C1104.2725%2C1104.1418%2C1104.3727%2C1104.5547%2C1104.4968%2C1104.3807%2C1104.3912%2C1104.1214%2C1104.3245%2C1104.0957%2C1104.5103%2C1104.3720%2C1104.4416%2C1104.1518%2C1104.0984%2C1104.3671%2C1104.2839%2C1104.5004%2C1104.0459%2C1104.2224%2C1104.5021%2C1104.1963%2C1104.4921%2C1104.0380%2C1104.1084%2C1104.0066%2C1104.5283%2C1104.5022%2C1104.3909%2C1104.4727%2C1104.2870%2C1104.5089%2C1104.2741%2C1104.1813%2C1104.5676%2C1104.3018%2C1104.5165%2C1104.0728%2C1104.3182%2C1104.3876%2C1104.4134%2C1104.0203%2C1104.2521%2C1104.0240%2C1104.0522%2C1104.4923%2C1104.3806%2C1104.1964%2C1104.2092%2C1104.3708%2C1104.0478%2C1104.4787%2C1104.0467%2C1104.4383%2C1104.2035%2C1104.3731%2C1104.4223%2C1104.0026%2C1104.5094%2C1104.4096%2C1104.3850%2C1104.5401%2C1104.1425%2C1104.2247%2C1104.1550%2C1104.1076&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We show that the Satisfiability (SAT) problem for CNF formulas with\n{\\beta}-acyclic hypergraphs can be solved in polynomial time by using a special\ntype of Davis-Putnam resolution in which each resolvent is a subset of a parent\nclause. We extend this class to CNF formulas for which this type of\nDavis-Putnam resolution still applies and show that testing membership in this\nclass is NP-complete. We compare the class of {\\beta}-acyclic formulas and this\nsuperclass with a number of known polynomial formula classes. We then study the\nparameterized complexity of SAT for \"almost\" {\\beta}-acyclic instances, using\nas parameter the formula's distance from being {\\beta}-acyclic. As distance we\nuse the size of a smallest strong backdoor set and the {\\beta}-hypertree width.\nAs a by-product we obtain the W[1]-hardness of SAT parameterized by the\n(undirected) clique-width of the incidence graph, which disproves a conjecture\nby Fischer, Makowsky, and Ravve."}, "authors": ["Sebastian Ordyniak", "Daniel Paulusma", "Stefan Szeider"], "author_detail": {"name": "Stefan Szeider"}, "author": "Stefan Szeider", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1016/j.tcs.2012.12.039", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1104.4279v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1104.4279v2", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "Extended abstracts appeared in the Proceedings of FSTTCS 2010 and SAT\n  2011. The latter corresponds to revision 1 of this arXiv paper\n  (arXiv:1104.4279v1)", "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1104.4279v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1104.4279v2", "journal_reference": "Theoretical Computer Science, vol. 481, pp. 85-99, 2013", "doi": "10.1016/j.tcs.2012.12.039", "fulltext": "Satisfiability of Acyclic and Almost Acyclic CNF Formulas\u2217\nSebastian Ordyniak\u2020\n\nDaniel Paulusma\u2021\n\nMasaryk University, Brno, Czech Republic\n\nDurham University, Durham, UK\n\nStefan Szeider\u2020\n\narXiv:1104.4279v2 [cs.DS] 3 Apr 2013\n\nVienna University of Technology, Vienna, Austria\n\nAbstract\nWe show that the S ATISFIABILITY (SAT) problem for CNF formulas with \u03b2-acyclic hypergraphs can be\nsolved in polynomial time by using a special type of Davis-Putnam resolution where each resolvent is a subset\nof a parent clause. We extend this class to CNF formulas for which this type of Davis-Putnam resolution still\napplies and show that testing membership in this class is NP-complete. We compare the class of \u03b2-acyclic\nformulas and this superclass with a number of known polynomial formula classes. We then study the parameterized complexity of SAT for \"almost\" \u03b2-acyclic instances, using as parameter the formula's distance from\nbeing \u03b2-acyclic. As distance we use the size of smallest strong backdoor sets and the \u03b2-hypertree width. As a\nby-product we obtain the W[1]-hardness of SAT parameterized by the (undirected) clique-width of the incidence\ngraph, which disproves a conjecture by Fischer, Makowsky, and Ravve.\nKeywords acyclic hypergraph, chordal bipartite graph, Davis-Putnam resolution.\n\n1 Introduction\nWe consider the S ATISFIABILITY (SAT) problem on classes of CNF formulas (formulas in Conjunctive Normal\nForm) with restrictions on their associated hypergraphs, which are obtained from these formulas by ignoring\nnegations and considering clauses as hyperedges on variables. This is a natural study, because many computationally hard problems can be solved efficiently on acyclic instances. However, there are several notions of\nacyclicity for hypergraphs: \u03b1-acyclicity, \u03b2-acyclicity, \u03b3-acyclicity, and Berge acyclicity. We provide the relevant\ndefinitions in Section 2 and refer to Fagin [9] for a detailed description. The notions of acyclicity are strictly\nordered with respect to their generality:\n\u03b1-ACYC ) \u03b2-ACYC ) \u03b3-ACYC ) Berge-ACYC\n\n(1)\n\nwhere X -ACYC denotes the class of X-acyclic hypergraphs, which are in 1-to-1 correspondence to a class of\nCNF formulas called X-acyclic formulas. It is known that SAT is NP-complete for \u03b1-acyclic formulas [26] and\npolynomial-time solvable for Berge-acyclic formulas [10, 26].\nOur Results In Section 3 we determine the boundary between NP-completeness and polynomial-time tractability in the chain (1) by showing that SAT is polynomial-time solvable for \u03b2-acyclic formulas. Consequently, the\nsame holds for \u03b3-acyclic formulas. To prove our result we use a fundamental procedure called the Davis-Putnam\nprocedure, which successively eliminates variables using Davis-Putnam resolution [7]. In general, this procedure\nis not efficient, because the number of clauses may increase after each application of Davis-Putnam resolution.\nHowever, \u03b2-acyclic formulas are related to chordal bipartite graphs [30], and this allows us to compute an elimination ordering of the variables with the property that each obtained resolvent is a subset of a parent clause. This\ntype of resolution is known as subsumption resolution [19].\n\u2217 This is the author's self-archived copy of a paper that appeared in Theoretical Computer Science, vol. 481, pp. 85-99, 2013. Extended\nabstracts appeared in the Proceedings of FSTTCS 2010 and SAT 2011.\n\u2020 Supported by ERC (COMPLEX REASON, 239962).\n\u2021 Supported by EPSRC (EP/G043434/1).\n\n1\n\n\fIn Section 4 we show that there are CNF formulas that are not \u03b2-acyclic but that still admit an elimination\nordering of their variables based on subsumption resolution, such that the Davis-Putnam procedure takes polynomial time. We call such an elimination ordering DP-simplicial. This leads to a new class DPS of CNF formulas\nthat contains the class of \u03b2-acyclic formulas. In Section 5 we show that testing membership in this class is an NPcomplete problem. The reason for the NP-hardness is that a formula may have several so-called DP-simplicial\nvariables, one of which must be chosen to be eliminated but we do not know which one. In Section 6 we show\nhow to work around this obstacle to some extent, i.e., we identify a subclass of DPS that is a proper superclass of\nthe class of \u03b2-acyclic formulas for which SAT is polynomial-time solvable. In Section 7 we show that the class\nof \u03b2-acyclic formulas and its superclass DPS are incomparable with other known polynomial classes of CNF\nformulas. Hence, \u03b2-acyclic formulas form a new \"island of tractability\" for SAT.\nIn Section 8 we study the complexity of SAT for formulas that are parameterized by their \"distance\" from\nthe class of \u03b2-acyclic CNF formulas. We use two distance measures. The first distance measure is based on the\nnotion of a strong backdoor set. For a CNF formula F we define its \"distance to \u03b2-acyclicity\" as the size k of a\nsmallest set B of variables such that for each partial truth assignment to B, the reduct of F under the assignment\nis \u03b2-acyclic; such a set B is a strong backdoor set. If we know B, then deciding the satisfiability of F reduces\nto deciding the satisfiability of at most 2k \u03b2-acyclic CNF formulas, and is thus fixed-parameter tractable with\nrespect to k. We show, however, that finding such a set B of size k (if it exists) is W[2]-hard, thus unlikely\nfixed-parameter tractable for parameter k, which limits the algorithmic usefulness of this distance measure.\nThe second distance measure we consider is the \u03b2-hypertree width, a hypergraph invariant introduced by\nGottlob and Pichler [15]. The classes of hypergraphs of \u03b2-hypertree width k = 1, 2, 3, . . . form an infinite\nchain of proper inclusions. Hypergraphs of \u03b2-hypertree width 1 are exactly the \u03b2-acyclic hypergraphs. Thus \u03b2hypertree width is also a way to define a \"distance to \u03b2-acyclicity.\" The complexity of determining the \u03b2-hypertree\nwidth of a hypergraph is open [15]. However, we show that SAT parameterized by an upper bound on the \u03b2hypertree width is W[1]-hard even if we are given the CNF formula together with a \u03b2-hypertree decomposition\nof width k. As a side effect, we obtain from this result that SAT is also W[1]-hard when parameterized by the\nclique-width (of the undirected incidence graph) of the CNF formula. This disproves a conjecture by Fischer,\nMakowsky, and Ravve [10].\n\n2 Preliminaries\nIn this section we state our basic terminology and notations. We also present some known results that will be\nuseful at several places in the paper.\n\n2.1 Formulas and Resolution\nWe assume an infinite supply of propositional variables. A literal is a variable x or a negated variable x; if y = x\nis a literal, then we write y = x. For a set S of literals we put S = { x | x \u2208 S }; S is tautological if S \u2229 S 6= \u2205.\nA clause is a finite non-tautological set of literals. A finite set of clauses is a CNF formula (or formula, for short).\nA variable x occurs in a clause C if x \u2208 C \u222a C; var(C) denotes the set of variables\nS which occur in C. A variable\nx occurs in a formula F if it occurs in one of its clauses, and we put var(F ) = C\u2208F var(C). If F is a formula\nand X a set of variables, then we denote by F \u2212 X the formula obtained from F after removing all literals x and\nx with x \u2208 B from the clauses in F . If X = {x} we simply write F \u2212 x instead of F \u2212 {x}.\nLet F be a formula and X \u2286 var(F ). A truth assignment is a mapping \u03c4 : X \u2192 { 0, 1 } defined on some set\nX of variables; we write var(\u03c4 ) = X. For x \u2208 var(\u03c4 ) we define \u03c4 (x) = 1 \u2212 \u03c4 (x). For a truth assignment \u03c4 and\na formula F , we define\nF [\u03c4 ] = { C \\ \u03c4 \u22121 (0) | C \u2208 F, C \u2229 \u03c4 \u22121 (1) = \u2205 },\ni.e., F [\u03c4 ] denotes the result of instantiating variables according to \u03c4 and applying the usual simplifications. A\ntruth assignment \u03c4 satisfies a clause C if C contains some literal x with \u03c4 (x) = 1; \u03c4 satisfies a formula F if\nit satisfies all clauses of F . A formula is satisfiable if it is satisfied by some truth assignment; otherwise it is\nunsatisfiable. Two formulas F and F \u2032 are equisatisfiable if either both are satisfiable or both are unsatisfiable.\nThe S ATISFIABILITY (SAT) problem asks whether a given CNF formula is satisfiable.\n\n2\n\n\fLet C, D be two clauses such that C \u2229 D = {x} for a variable x. The clause (C \u222a D) \\ {x, x} is called the\nx-resolvent (or resolvent) of C and D; the clauses C and D are called parent clauses of the x-resolvent. Note\nthat by definition any two clauses have at most one resolvent. Let F be a formula. A sequence C1 , . . . , Cn is\na resolution derivation of Cn from F if every Ci is either in F or the resolvent of two clauses Cj and Cj \u2032 for\nsome 1 \u2264 j < j \u2032 \u2264 i \u2212 1. If Cn is the empty clause, then the sequence is called a resolution refutation of F .\nThe derivation is minimal if we cannot delete a clause from it and still have a resolution derivation of Cn from\nF . We call a clause Cn a resolution descendant of a clause C1 \u2208 F if there is a minimal resolution derivation\nC1 , . . . , Cn of Cn from F .\nConsider a formula F and a variable x of F . Let DPx (F ) denote the formula obtained from F after adding\nall possible x-resolvents and removing all clauses in which x occurs. We say that DPx (F ) is obtained from F by\nDavis-Putnam resolution, and that we eliminated x. It is well known (and easy to show) that F and DPx (F ) are\nequisatisfiable.\nFor an ordered sequence of variables x1 , . . . , xk of F , we set DPx1 ,...,xk (F ) = DPxk (* * * (DPx1 (F )) * * * ) and\nDP\u2205 (F ) = F . The Davis-Putnam procedure [7] is a well-known algorithm that solves SAT. In its most basic\nform, it takes an ordering of the variables x1 , . . . , xn of a formula F and checks whether DPx1 ,...,xn (F ) is empty\nor contains the empty clause. In the first case F is satisfiable, and in the second case F is unsatisfiable. Note that\nthis procedure computes a certificate for the (un)satisfiability of F ; we can obtain a satisfying truth assignment of\nF from a satisfying truth assignment of DPx (F ), and we can obtain a resolution refutation of F from a resolution\nrefutation of DPx (F ). However, DPx (F ) contains in general more clauses than F . Hence, repeated application\nof Davis-Putnam resolution to F may cause an exponential growth in the number of clauses. As a result, the\nDavis-Putnam procedure has an exponential worst-case running time.\n\n2.2 Graphs and Hypergraphs\nA hypergraph H is a pair (V, E) where V is the set of vertices and E is the set of hyperedges, which are subsets\nof V . If |e| = 2 then we call e an edge; we denote an edge e = {u, v} simply as uv or vu. If all hyperedges of\na hypergraph are edges then we call it a graph. We say that a hypergraph H \u2032 = (V \u2032 , E \u2032 ) is a partial hypergraph\nof H = (V, E) if V \u2032 \u2286 V and E \u2032 \u2286 E. The incidence graph I(H) of hypergraph H = (V, E) is the bipartite\ngraph with partition classes V and E such that e \u2208 E is adjacent to v \u2208 V if and only if v \u2208 e. A hypergraph is\n\u03b1-acyclic if it can be reduced to the empty hypergraph by repeated application of the following rules:\n1. Remove hyperedges that are empty or contained in other hyperedges.\n2. Remove vertices that appear in at most one hyperedge.\nA hypergraph H is \u03b2-acyclic if every partial hypergraph of H is \u03b1-acyclic. The hypergraph H(F ) of a formula\nF has vertex set var(F ) and hyperedge set { var(C) | C \u2208 F }. We say that F is \u03b1-acyclic or \u03b2-acyclic if H(F )\nis \u03b1-acyclic or \u03b2-acyclic, respectively.\nLet F be a formula. The incidence graph of F is the bipartite graph I(F ) with vertex set var(F ) \u222a F and\nedge set { Cx | C \u2208 F and x \u2208 var(C) }. The directed incidence graph of F is the directed graph D(F ) with\nvertex set var(F ) \u222a F and arc set { (C, x) | C \u2208 F and x \u2208 C } \u222a { (x, C) | C \u2208 F and x \u2208 C }. We can also\nrepresent the orientation of edges by labeling them with the signs +, \u2212, such that an edge between a variable x\nand a clause C is labeled + if x \u2208 C and labeled \u2212 if x \u2208 C. This gives rise to the signed incidence graph which\ncarries exactly the same information as the directed incidence graph.\nThe graph parameter clique-width measures in a certain sense the structural complexity of a directed or undirected graph [4]. The parameter is defined via a graph construction process where only a limited number of vertex\nlabels are available; vertices that share the same label at a certain point of the construction process must be treated\nuniformly in subsequent steps. In particular, one can use the following four operations: the creation of a new vertex with label i, the vertex-disjoint union of already constructed labeled graphs, the relabeling of all vertices of\nlabel i with label j denoted \u03c1i\u2192j , and the insertion of all possible edges between vertices of label i and label j\ndenoted \u03b7i,j (either undirected, in which case we can also write \u03b7j,i , or directed from label i to j). The cliquewidth cw(G) of a graph G is the smallest number k of labels that suffice to construct G by means of these four\noperations. An algebraic term representing such a construction of G is called a k-expression of G. The (directed)\nclique-width of a CNF formula is the clique-width of its (directed) incidence graph. The directed clique-width of\n3\n\n\fa CNF formula can also be defined in terms of the signed incidence graph and is therefore sometimes called the\nsigned clique-width.\nLet G = (V, E) be a graph. For a subset U \u2286 V , the subgraph of G induced by U is the graph with vertex\nset U and edge set {uv | u, v \u2208 U with uv \u2208 E}. A cycle is a graph, the vertices of which can be ordered as\nv1 , . . . , vn such that E = {vi vi+1 | 1 \u2264 i \u2264 n \u2212 1} \u222a {vn v1 }. A graph is chordal bipartite if it has no induced\ncycle on 6 vertices or more. A vertex v in a graph G is weakly simplicial if (i) the neighborhood of v in G forms\nan independent set, and (ii) the neighborhoods of the neighbors of v form a chain under set inclusion. Uehara [31]\nshowed the following, which also follows from results of Hammer, Maffray, and Preismann [17], see [24]. We\ncall a bipartite graph nontrivial if it contains at least one edge.\nProposition 1 ([17, 31]). A graph is chordal bipartite if and only if every induced subgraph has a weakly simplicial vertex. Moreover, a nontrivial chordal bipartite graph has a weakly simplicial vertex in each partition\nclass.\nThe following proposition shows how \u03b2-acyclic CNF formulas and chordal bipartite graphs are related. The\nequivalence between statement (i) and (ii) is due to Tarjan and Yannakakis [30], who presented this relationship\nin terms of \u03b2-acyclic hypergraphs. The equivalence between statement (ii) and (iii) follows from the facts that\nI(H(F )) is obtained from I(F ) after removing all but one clause vertices in I(F ) with the same neighbors, i.e.,\nclauses with the same set of variables in F , and that a chordal bipartite graph remains chordal bipartite under\nvertex deletion.\nProposition 2 ([30]). For a CNF formula F , statements (i)-(iii) are equivalent:\n(i) F is \u03b2-acyclic;\n(ii) I(H(F )) is chordal bipartite;\n(iii) I(F ) is chordal bipartite.\nWe also call a vertex of a hypergraph or a variable of a CNF formula weakly simplicial if the corresponding vertex\nin the associated incidence graph is weakly simplicial.\n\n3 Polynomial-time SAT Decision for \u03b2-acyclic CNF Formulas\nNote that we can make a hypergraph \u03b1-acyclic by adding a universal hyperedge that contains all vertices; by\nrule 1 we remove all other hyperedges, by rule 2 all vertices. By this observation, it is easy to see that SAT is\nNP-complete for the class of \u03b1-acyclic CNF formulas [26]. In contrast, it is well known that the satisfiability of \u03b1acyclic instances of the C ONSTRAINT S ATISFACTION P ROBLEM (CSP) can be decided in polynomial time [13].\nThus SAT and CSP behave differently with respect to \u03b1-acyclicity (representing a clause with k literals as a\nrelational constraint requires exponential space of order k2k ). However, in this section, we give a polynomialtime algorithm that solves SAT for \u03b2-acyclic CNF formulas.\nIf we can reduce a hypergraph H to the empty graph by repeated deletion of weakly simplicial vertices, then\nwe say that H admits a weakly simplicial elimination ordering. If H = H(F ) for some formula F , then we also\nsay that F admits a weakly simplicial ordering of its variables. The first key ingredient of our algorithm is the\nfollowing lemma.\nLemma 1. If F is a \u03b2-acyclic formula, then F admits a weakly simplicial elimination ordering. Moreover, such\nan ordering can be found in polynomial time.\nProof. Let F be a \u03b2-acyclic formula. We must show that H(F ) admits a weakly simplicial elimination ordering.\nProposition 2 tells us that I(H(F )) is chordal bipartite. Then I(H(F )) has a weakly simplicial vertex in each\npartition class due to Proposition 1. We choose the partition class of I(H(F )) that corresponds to the vertices\nof H. Then the lemma readily follows after observing that the class of chordal bipartite graphs is closed under\nvertex deletion and that weakly simplicial vertices can be identified in polynomial time by brute force.\nThe following lemma is the second key ingredient for our algorithm. Recall that DPx (F ) denotes the formula\nobtained from a formula F after eliminating x by Davis-Putnam resolution.\n4\n\n\fLemma 2. If x is a weakly simplicial variable of a formula F , then |DPx (F )| \u2264 |F |.\nProof. Let x be a weakly simplicial variable of a CNF formula F . Let F \u2212 x := { C \\ {x, x} | C \u2208 F }. We\nshow that DPx (F ) \u2286 F \u2212 x.\nAssume C1 , C2 \u2208 F have a resolvent C with respect to x. Consequently we have C1 \u2229 C2 \u2286 {x, x}. Because\nx is weakly simplicial, var(C1 ) \u2286 var(C2 ) or var(C2 ) \u2286 var(C1 ). Without loss of generality, assume the former\nis the case. If x \u2208 C1 , then we have C1 \u2229 C2 = {x}, and so C = C2 \\ {x} \u2208 F \u2212 x. Similarly, if x \u2208 C1 ,\nthen we have C1 \u2229 C2 = {x}, and so C = C2 \\ {x} \u2208 F \u2212 x. Thus indeed DPx (F ) \u2286 F \u2212 x. From\n|DPx (F )| \u2264 |F \u2212 x| \u2264 |F | the result now follows.\nWe are now ready to present our algorithm.\nAlgorithm solving SAT for \u03b2-acyclic formulas\nInput\nOutput\n\n:\n:\n\na \u03b2-acyclic formula F\nYes if F is satisfiable\nNo otherwise\n\nStep 1. compute a weakly simplicial elimination ordering x1 , . . . , xn of F\nStep 2. apply the Davis-Putnam procedure on ordering x1 , . . . , xn\nWe let BAC denote the class of all \u03b2-acyclic formulas and state the main result of this section.\nTheorem 1. SAT can be solved in polynomial time for BAC.\nProof. Let F be a \u03b2-acyclic CNF formula. We apply our algorithm. Its correctness follows from Lemma 1\ncombined with the correctness of the Davis-Putnam procedure [7]. Steps 1 and 2 run in polynomial time due to\nLemmas 1 and 2, respectively. Hence, Theorem 1 follows.\n\n4 Generalizing \u03b2-Acyclic Formulas\nLemma 2 is one of the two key ingredients than ensures that our algorithm for solving SAT on BAC runs in\npolynomial time. It states that the number of clauses does not increase after applying Davis-Putnam resolution if\nx is a weakly simplicial variable of a formula F . We can ensure this by requiring the following property that is\nmore general than being weakly simplicial. We say that a variable x \u2208 var(F ) is DP-simplicial in a formula F if\n(*) for any two clauses C, D \u2208 F that have an x-resolvent, this x-resolvent is a subset of C or a subset of D.\nObserve that whenever an x-resolvent is a subset of a parent clause C then it is equal to C \\ {x, x}. The\nfollowing lemma immediately follows from (\u2217).\nLemma 3. If x is a DP-simplicial variable of a formula F , then |DPx (F )| \u2264 |F |.\nAn ordering x1 , . . . , xn of the variables of F is a DP-simplicial elimination ordering if xi is DP-simplicial\nin DPx1 ,...,xi\u22121 (F ) for all 1 \u2264 i \u2264 n. We let DPS denote the class of all formulas that admit a DP-simplicial\nelimination ordering. We observe that every weakly simplicial elimination ordering of H(F ) is a DP-simplicial\nelimination ordering of F . This means that BAC \u2286 DPS. However, due to Example 4.1 below, the reverse is not\ntrue. Hence, we found the following result.\nProposition 3. BAC ( DPS.\nGiven a DP-simplicial ordering, the Davis-Putnam procedure runs in polynomial time due to Lemma 3. This\nleads to the following result.\nProposition 4. SAT can be solved in polynomial time for DPS provided that a DP-simplicial elimination ordering is given.\n5\n\n\fy\n+\n+\n+\n\u2212\n\u2212\n\u2212\n0\n0\n0\n0\n0\n0\n0\n\nb\n+\n\u2212\n\u2212\n+\n\u2212\n\u2212\n\u2212\n\u2212\n\u2212\n0\n0\n0\n0\n\nb\u2032\n0\n0\n+\n+\n0\n0\n+\n0\n0\n+\n+\n+\n\u2212\n\nb\u2217\n+\n0\n0\n0\n0\n+\n0\n0\n0\n+\n+\n\u2212\n+\nF\n\nc\n+\n0\n0\n\u2212\n0\n0\n0\n0\n0\n+\n\u2212\n0\n0\n\nz\n0\n0\n+\n0\n0\n\u2212\n0\n+\n\u2212\n0\n0\n0\n0\n\nb\n\u2212\n\u2212\n\u2212\n\u2212\n\u2212\n\u2212\n0\n0\n0\n0\n\nb\u2032\n+\n0\n0\n+\n0\n0\n+\n+\n+\n\u2212\n\nb\u2217\n0\n0\n+\n0\n0\n0\n+\n+\n\u2212\n+\n\nc\n0\n0\n0\n0\n0\n0\n+\n\u2212\n0\n0\n\nz\n+\n0\n\u2212\n0\n+\n\u2212\n0\n0\n0\n0\n\nDPy (F )\n\nb\u2032\n+\n+\n+\n\u2212\n\nb\u2217\n+\n+\n\u2212\n+\n\nc\n+\n\u2212\n0\n0\n\nDPy,b (F )\n\nz\n0\n0\n0\n0\n\nb\u2217\n+\n+\n\nc\n+\n\u2212\n\nz\n0\n0\n\nDPy,b,b\u2032 (F )\n\nFigure 1: The example formula F and the first three subformulas obtained from F using the DP-simplicial\nelimination ordering y, b, b\u2032 , b\u2217 , c, z. The formulas are given as matrices in which each row corresponds to a\nclause of the formula and each column corresponds to a variable. Each matrix entry is either \"+\", \"\u2212\" or \"0\"\nindicating whether a variable appears positively, negatively, or is absent, respectively, in a clause.\n\n4.1 An Example\nWe give an example of a formula in DPS \\ BAC. Consider the formula F that has variables y, z, b, b\u2032 , b\u2217 and\nc and clauses {y, b, b\u2217 , c}, {y, b}, {y, b, b\u2032 , z}, {y, b, b\u2032 , c}, {y, b}, {y, b, b\u2217 , z}, {b, b\u2032 }, {b, z}, {b, z}, {b\u2032 , b\u2217 , c},\n{b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 }, and {b\u2032 , b\u2217 }; see Figure 1 for an illustration.\nWe observe first that none of the variables of F are weakly simplicial. Consequently, there is no weakly\nsimplicial elimination ordering of F . Hence F \u2208\n/ BAC. However, we will show below that y, b, b\u2032 , b\u2217 , c, z is a\nDP-simplicial elimination ordering of F . Then F \u2208 DPS, as desired (see Figure 1 for an illustration).\nWe find that y is DP-simplicial in F and obtain DPy (F ) = {{b, b\u2032 , z}, {b}, {b, b\u2217 , z}, {b, b\u2032 }, {b, z},\n{b, z}, {b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 }, {b\u2032 , b\u2217 }}. We then find that b is DP-simplicial in DPy (F ) and obtain\nDPy,b (F ) = {{b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 }, {b\u2032 , b\u2217 }}. We then find that b\u2032 is DP-simplicial in DPy,b (F )\nand obtain DPy,b,b\u2032 (F ) = {{b\u2217 , c}, {b\u2217 , c}}. We then find that b\u2217 is DP-simplicial in DPy,b,b\u2032 (F ) and obtain\nDPy,b,b\u2032 ,b\u2217 (F ) = \u2205. Hence, y, b, b\u2032 , b\u2217 , c, z is a DP-simplicial elimination ordering of F .\nWe note that z is also DP-simplicial in F . Suppose that we started with z instead of y. We first derive that\nDPz (F ) = {{y, b, b\u2217, c}, {y, b}, {y, b, b\u2032 }, {y, b, b\u2032 , c}, {y, b}, {y, b, b\u2217 }, {b, b\u2032 }, {b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 , c}, {b\u2032 , b\u2217 },\n{b\u2032 , b\u2217 }}. In contrast to DPy (F ), the clauses {y, b, b\u2217 , c} and {y, b, b\u2032 , c} are still contained in DPz (F ). This\nimplies that DPz (F ) has no DP-simplicial variables. Consequently, F has no DP-simplicial elimination ordering\nthat starts with z.\nWe conclude that in contrast to weakly simplicial elimination orderings it is important to choose the right\nvariable when we want to obtain a DP-simplicial elimination ordering. In the next section we will extend this\nconsideration and show that making the right choice is in fact an NP-hard problem.\n\n5 Recognizing Formulas in DPS\nWe prove that the problem of testing whether a given CNF formula belongs to the class DPS, i.e., admits a DPsimplicial elimination ordering, is NP-complete. This problem is in NP, because we can check in polynomial\ntime whether an ordering of the variables of a CNF formula is a DP-simplicial elimination ordering. In order\nto show NP-hardness we reduce from SAT. In Section 5.1 we construct a CNF formula F \u2032 from a given CNF\n\n6\n\n\fformula F . We also show a number of properties of F \u2032 . In Section 5.2 we use these properties to prove that F is\nsatisfiable if and only if F \u2032 admits a DP-simplicial elimination ordering.\n\n5.1 The Gadget and its Properties\nFor a given CNF formula F with variables x1 , . . . , xn called the x-variables and clauses C1 , . . . , Cm , we construct a CNF formula F \u2032 as follows. For every xi we introduce two variables yi and zi . We call these variables\nthe y-variables and z-variables, respectively. For every Cj we introduce a variable cj . We call these variables\nthe c-variables. We also add three new variables b, b\u2032 and b\u2217 called the b-variables. We let var(F \u2032 ) consist of all\nb-variables, c-variables, y-variables, and z-variables.\nLet Cj be a clause of F . We replace every x-variable in C by its associated y-variable if the occurrence of\nx in C is positive; otherwise we replace it by its associated z-variable. This yields a clause Dj . For instance, if\nCj = {x1 , x2 , x3 } then Dj = {y1 , z2 , y3 }.\nWe let F \u2032 consist of the following 6n + 4m + 3 clauses:\n\u2022 {yi , b} and {yi , b} for i = 1, . . . , n called by-clauses\n\u2022 {zi , b} and {zi , b} for i = 1, . . . , n called bz-clauses\n\u2022 {yi , zi , b, b\u2032 } and {yi , zi , b, b\u2217 } for i = 1, . . . , n called byz-clauses\n\u2022 {cj , b\u2032 , b\u2217 } and {cj , b\u2032 , b\u2217 } for j = 1, . . . , m called bc-clauses\n\u2022 Dj \u222a {b, b\u2217, cj } \u222a { ck | k 6= j } and Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j } for j = 1, . . . , m\ncalled bcD-clauses\n\u2022 {b, b\u2032 }, {b\u2032 , b\u2217 } and {b\u2032 , b\u2217 } called b-clauses.\nWe call a pair Dj \u222a {b, b\u2217 , cj } \u222a { ck | k 6= j } and Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j } for some 1 \u2264 j \u2264 m a\nbcD-clause pair. We call a CNF formula M a yz-reduction formula of F \u2032 if there exists a sequence of variables\nv 1 , . . . , v k , where every v i is either a y-variable or a z-variable, such that DPv1 ,...,vk (F \u2032 ) = M , and v i is DPsimplicial in DPv1 ,...,vi\u22121 (F \u2032 ) for i = 1, . . . , k. We say that two clauses C and D violate (*) if they have a\nresolvent that is neither a subset of C nor a subset of D, i.e., C \u2229 D = {v} for some variable v but neither\n(C \u222a D) \\ {v, v} = C \\ {v} nor (C \u222a D) \\ {v, v} = D \\ {v}. We will now prove five useful lemmas valid for\nyz-reduction formulas.\nLemma 4. Let M be a yz-reduction formula of F \u2032 . If M contains both clauses of some bcD-clause pair, then\nneither any b-variable nor any c-variable is DP-simplicial in M .\nProof. Let E1 = Dj \u222a {b, b\u2217 , cj } \u222a { ck | k 6= j } and E2 = Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j } for some 1 \u2264 j \u2264 m\nbe a bcD-clause pair in M . We observe that by definition M contains all b-clauses and bc-clauses. This enables\nus to prove the lemma. Let v be a b-variable or c-variable. Then we must distinguish 5 cases. If v = b, then\n{b, b\u2032 } and E1 violate (*). If v = b\u2032 , then {b\u2032 , b\u2217 } and E2 violate (*). If v = b\u2217 , then {b\u2032 , b\u2217 } and E1 violate (*).\nIf v = cj , then {cj , b\u2032 , b\u2217 } and E1 violate (*). If v = ck for some 1 \u2264 k \u2264 m with k 6= j, then {ck , b\u2032 , b\u2217 } and\nE1 violate (*).\nLemma 5. Let M be a yz-reduction formula of F \u2032 . Then yi \u2208 var(M ) or zi \u2208 var(M ) for i = 1, . . . , n.\nProof. Suppose that M does not contain yi or zi for some 1 \u2264 i \u2264 m, say yi \u2208\n/ var(M ). We show that\nzi \u2208 var(M ). Let M \u2032 be the formula obtained from F \u2032 just before the elimination of yi . Because M is a yzreduction formula, M \u2032 is a yz-reduction formula as well. Hence, var(M \u2032 ) contains all b-variables. Because yi\nand zi are in var(M \u2032 ), we then find that M \u2032 contains the clauses {yi , zi , b, b\u2032 }, {yi , b}, {yi , zi , b, b\u2217 } and {yi , b}.\nBecause the first two clauses resolve into {zi , b, b\u2032 }, and the last two resolve into {zi , b, b\u2217 }, we obtain that\nDPyi (M \u2032 ) contains {zi , b, b\u2032 } and {zi , b, b\u2217 }, which violate (*). Because M contains all b-variables by definition,\nzi will never become DP-simplicial when we process DPyi (M \u2032 ) until we obtain M . Hence, zi \u2208 var(M ), as\ndesired.\n7\n\n\fLemma 6. Let M be a yz-reduction formula of F \u2032 , and let 1 \u2264 j \u2264 m. If there is a variable that occurs in Dj\nbut not in M , then M neither contains Dj \u222a {b, b\u2217 , cj } \u222a { ck | k 6= j } nor Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j } nor\ntheir resolution descendants.\nProof. Let v be a variable that occurs in Dj but not in M . We may assume without loss of generality that v is the\nfirst variable in Dj that got eliminated and that v = yi for some 1 \u2264 i \u2264 n. Let S be the set that consists of all\nclauses Dj \u2032 \u222a {b, b\u2217 , cj \u2032 } \u222a { ck | k 6= j \u2032 } and Dj \u2032 \u222a {b, b\u2032 , cj \u2032 } \u222a { ck | k 6= j \u2032 } in which yi occurs.\nLet M \u2032 be the formula obtained from F \u2032 just before the elimination of yi . Because M is a yz-reduction\nformula, M \u2032 is a yz-reduction formula as well. Hence, by definition, all b-variables and all c-variables occur\nin M \u2032 . Then the clauses in M \u2032 , in which yi occurs, are {yi , b}, {yi , b}, {yi , zi , b, b\u2032 },{yi , zi , b, b\u2217 }, together with\nclauses that are either from S or resolution descendants of clauses in S. Note that these resolution descendants\nstill contain all their b-variables and c-variables.\nWhen we eliminate yi , we remove all clauses in M \u2032 in which yi occurs. Hence, DPyi (M \u2032 ), and consequently,\nM neither contains E1 = Dj \u222a {b, b\u2217 , cj } \u222a { ck | k 6= j } nor E2 = Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j }. We\nshow that DPyi (M \u2032 ) does not contain a resolvent of one of these two clauses either. This means that M \u2032 does\nnot contain one of their resolution descendants, as desired. We only consider E1 , because we can deal with E2 in\nthe same way. There is no yi -resolvent of E1 and a clause C from {{yi , b}, {yi , b}, {yi , zi , b, b\u2032 },{yi , zi , b, b\u2217 }},\nbecause E1 \u2229 C contains b. There is no yi -resolvent of E1 and a (resolution descendant from a) clause C of S\neither, because E1 \u2229 C contains cj .\nLemma 7. Let M be a yz-reduction formula of F \u2032 , and let 1 \u2264 i \u2264 n. If var(M ) contains yi and zi , then both\nyi and zi are DP-simplicial in M .\nProof. By symmetry, we only have to show that yi is DP-simplicial in M . Let S be the set of all clauses\nDj \u2032 \u222a {b, b\u2217 , cj \u2032 } \u222a { ck | k 6= j \u2032 } and Dj \u2032 \u222a {b, b\u2032 , cj \u2032 } \u222a { ck | k 6= j \u2032 } in which yi occurs. By definition,\nvar(M ) contains all b-variables and all c-variables. This has the following two consequences. First, as var(M )\nalso contains yi and zi , we find that M contains the clauses {yi , b}, {yi , b}, {yi , zi , b, b\u2032 }, and {yi , zi , b, b\u2217 }.\nSecond, by Lemma 6, the other clauses of M in which yi occurs form a subset of S. This means that there are\nonly 3 pairs of clauses C1 , C2 in M with C1 \u2229 C2 = {yi }, namely the pair {yi , b}, {yi , b}, the pair {yi , b},\n{yi , zi , b, b\u2217 }, and the pair {yi , b}, {yi , zi , b, b\u2032 }. Each of these pairs satisfies (*). This completes the proof of\nLemma 7.\nLemma 8. Let M be a yz-reduction formula of F \u2032 . If M contains neither bcD-clauses nor resolution descendants of such clauses, then M has a DP-simplicial elimination ordering b, c1 , . . . , cm , b\u2032 , b\u2217 , v 1 , . . . , v l , where\nv 1 , . . . , v l form an arbitrary ordering of the y-variables and z-variables in var(M ).\nProof. By our assumptions, the only clauses in M in which b occurs are by-clauses, bz-clauses, byz-clauses, and\nthe clause {b, b\u2032 }. In all these clauses b occurs as b. Hence, b is (trivially) DP-simplicial in M . We then find\nthat DPb (M ) consists of {b\u2032 , b\u2217 }, {b\u2032 , b\u2217 } and all bc-clauses. For every cj , there exists exactly one bc-clause,\nnamely {cj , b\u2032 , b\u2217 }, in which cj occurs as cj , and exactly one bc-clause, namely {cj , b\u2032 , b\u2217 }, in which cj occurs\nas cj . Hence, cj is DP-simplicial in DPb,c1 ,...,cj\u22121 (M ) for j = 1, . . . , m. We deduce that DPb,c1 ,...,cm (M ) =\n{{b\u2032 , b\u2217 }, {b\u2032, b\u2217 }, {b\u2032 , b\u2217 }}. Then b\u2032 is DP-simplicial in DPb,c1 ,...,cm (M ), and we find that DPb,c1 ,...,cm ,b\u2032 (M ) =\n{{b\u2217 }}. Then b\u2217 is DP-simplicial in DPb,c1 ,...,cm ,b\u2032 (M ), and we find that DPb,c1 ,...,cm ,b\u2032 ,b\u2217 (M ) = \u2205. Consequently, v i is DP-simplicial in DPb,c1 ,...,cm ,b\u2032 ,b\u2217 ,v1 ,...,vi\u22121 (M ) for i = 1, . . . , l. This concludes the proof of\nLemma 8.\n\n5.2 The Reduction\nWe are now ready to prove the main result of Section 5.\nTheorem 2. The problem of testing whether a CNF formula belongs to DPS is NP-complete.\nProof. Recall that the problem is in NP. Given a CNF formula F that has variables x1 , . . . , xn and clauses\nC1 , . . . , Cm , we construct in polynomial time the CNF formula F \u2032 . We claim that F is satisfiable if and only\nif F \u2032 admits a DP-simplicial elimination ordering.\n\n8\n\n\fFirst suppose that F is satisfiable. Let \u03c4 be a satisfying truth assignment of F . We define functions f and g\nthat map every x-variable to a y-variable or z-variable in the following way. If \u03c4 (xi ) = 1, then f (xi ) = yi and\ng(xi ) = zi . If \u03c4 (xi ) = 0, then f (xi ) = zi and g(xi ) = yi . Let x1 , . . . , xn be the x-variables in an arbitrary\nordering. Then, for every 1 \u2264 i \u2264 n, the formula DPf (x1 ),...,f (xi ) (F \u2032 ) is a yz-reduction formula. From Lemma 7\nwe deduce that f (xi ) is DP-simplicial in DPf (x1 ),...,f (xi\u22121 ) (F \u2032 ) for every 1 \u2264 i \u2264 n. Because \u03c4 satisfies F ,\nvar(Dj ) contains a variable that is not in var(DPf (x1 ),...,f (xn ) (F \u2032 )), for every 1 \u2264 j \u2264 m. Lemma 6 implies\nthat M does not contain any bcD-clause or any of their resolution descendants. Then, by Lemma 8, we find that\nf (x1 ), . . . , f (xn ), b, c1 , . . . , cm , b\u2032 , b\u2217 , g(x1 ), . . . , g(xn ) is a DP-simplicial elimination ordering of F \u2032 .\n\u2032\nNow suppose that F \u2032 admits a DP-simplicial elimination ordering v 1 , . . . , v |var(F )| . Let v k be the first\n\u2032\nvariable that is neither a y-variable nor a z-variable. Then M = DPv1 ,...,vk\u22121 (F ) is a yz-reduction formula. Let\nA = {v 1 , . . . , v k\u22121 }, and let X consist of all x-variables that have an associated y-variable or z-variable in A.\nWe define a truth assignment \u03c4 : X \u2192 {0, 1} by setting \u03c4 (xi ) = 1 if yi \u2208 A and \u03c4 (xi ) = 0 if zi \u2208 A, for every\nxi \u2208 X. By Lemma 5, we find that \u03c4 is well defined. Because v k is a DP-simplicial b-variable or a DP-simplicial\nc-variable in M , we can apply Lemma 4 and find that, for every 1 \u2264 j \u2264 m, at least one of the two clauses\nDj \u222a {b, b\u2217 , cj } \u222a { ck | k 6= j } and Dj \u222a {b, b\u2032 , cj } \u222a { ck | k 6= j } is not in M . This means that every clause\nCj contains a literal x with \u03c4 (x) = 1. Hence, F is satisfiable. This completes the proof of Theorem 2.\n\n6 Intermediate Classes\nWe discuss a possibility for coping with the NP-hardness result of the previous section. The ultimate reason for\nthis hardness is that a formula may have several DP-simplicial variables, and it is hard to choose the right one. A\nsimple workaround is to assume a fixed ordering of the variables and always choose the DP-simplicial variable\nwhich comes first according to this ordering. In this way we loose some generality but win polynomial time\ntractability. This idea is made explicit in the following definitions.\nLet \u03a9 denote the set of all strict total orderings of the propositional variables. Let \u227a \u2208 \u03a9 and F be a\nCNF formula. A variable x \u2208 var(F ) is \u227a-DP-simplicial in F if x is DP-simplicial in F , and var(F ) contains\nno variable y \u227a x that is DP-simplicial in F . A strict total ordering x1 , . . . , xn of the variables of F is a\n\u227a-DP-simplicial elimination ordering if xi is \u227a-DP-simplicial in DPx1 ,...,xi\u22121 (F ) for all 1 \u2264 i \u2264 n. We\nlet DPS\u227aTdenote the class of all CNF formulas that admit a \u227a-DP-simplicial elimination ordering, and we set\nDPS\u2200 = \u227a\u2208\u03a9 DPS\u227a .\nProposition 5. DPS\u227a can be recognized in polynomial time for every \u227a \u2208 \u03a9. More precisely, it is possible to\nfind in polynomial time a \u227a-DP-simplicial elimination ordering for a given CNF formula F , or else to decide\nthat F has no such ordering.\nProof. Let x1 , . . . , xn be the variables of F , ordered according to \u227a. By brute force we check whether xi is\nDP-simplicial in F , for i = 1, . . . , n. This takes polynomial time for each check. When we have found the first\nDP-simplicial variable xi , we replace F by DPxi (F ). We iterate this procedure as long as possible. Let F \u2032 be\nthe formula we end up with. If var(F \u2032 ) = \u2205 then F \u2208 DPS\u227a and the sequence of variables as they have been\neliminated provides a \u227a-DP-simplicial elimination ordering. If var(F \u2032 ) 6= \u2205 then F \u2208\n/ DPS\u227a .\nS\nProposition 6. BAC ( DPS\u2200 ( DPS = \u227a\u2208\u03a9 DPS\u227a .\nProof. First we show that BAC ( DPS\u2200 . Let F \u2208 BAC and \u227a \u2208 \u03a9. We use induction on the number of variables\nof F to show that F \u2208 DPS\u227a . The base case |var(F )| = 0 is trivial. Let |var(F )| \u2265 1. Because F \u2208 BAC\nand var(F ) 6= \u2205, we find that F has at least one weakly simplicial variable. Recall that each weakly simplicial\nvariable is DP-simplicial. Consequently, F has at least one DP-simplicial variable. Let x be the first DP-simplicial\nvariable in the ordering \u227a. By definition, x is a \u227a-DP-simplicial variable. We consider F \u2032 = DPx (F ). Because a\n\u03b2-acyclic hypergraph remains \u03b2-acyclic under vertex and hyperedge deletion, F \u2032 \u2208 BAC. Because F \u2032 has fewer\nvariables than F , we use the induction hypothesis to conclude that F \u2032 \u2208 DPS\u227a . Hence BAC \u2286 DPS\u227a follows.\nBecause \u227a \u2208 \u03a9 was chosen arbitrarily, BAC \u2286 DPS\u2200 follows.\nIn order to see that BAC 6= DPS\u2200 , we take a hypergraph H that is not \u03b2-acyclic and consider H as a CNF\nformula with only positive clauses. All variables of H are DP-simplicial and can be eliminated in an arbitrary\norder. Thus H \u2208 DPS\u2200 \\ BAC.\n9\n\n\fNext we show that DPS\u2200 ( DPS. Inclusion holds by definition. In order to show that the inclusion is strict,\nwe consider the formula F of the example in Section 4.1. In that section we showed that y, b, b\u2032 , b\u2217 , c, z is a\nDP-simplicial elimination ordering of F . Hence, F \u2208 DPS\u227a for any ordering \u227a with y \u227a b \u227a b\u2032 \u227a b\u2217 \u227a c \u227a z.\nWe also showed that z is DP-simplicial in F but that F has no DP-simplicial ordering starting with z. Hence,\n\u2032\n\u2032\n\u2032\nF \u2208\n/ DPS\nS \u227a for any ordering \u227a with z \u227a y. We conclude that F \u2208 DPS \\ DPS\u2200 . Finally, the equality\nDPS = \u227a\u2208\u03a9 DPS\u227a holds by definition.\n\n6.1 Grades of Tractability\nWhat properties do we require from a class C of CNF formulas to be a \"tractable class\" for SAT? Clearly we want\nC to satisfy the property:\n1. Given a formula F \u2208 C, we can decide in polynomial time whether F is satisfiable.\nThis alone is not enough, since even the class of all satisfiable CNF formulas has this property. Therefore we\nmight wish that a tractable class C should also satisfy the property:\n2. Given a formula F , we can decide in polynomial time whether F \u2208 C.\nHowever, if C is not known to satisfy property 2, then it may still satisfy the property:\n3. There exists a polynomial-time algorithm that either decides whether a given a formula F is satisfiable or\nnot, or else decides that F does not belong to C.\nThe algorithm mentioned in property 3 may decide the satisfiability of some formulas outside of C, hereby avoiding the recognition problem. Such algorithms are called robust algorithms [29]. In addition we would also assume\nfrom a tractable class C to be closed under isomorphisms, i.e., to satisfy the property:\n4. If two formulas differ only in the names of their variables, then either both or none belong to C.\nThis leaves us with two notions of a tractable class for SAT, a strict one where properties 1, 2, and 4 are required,\nand a permissive one where only properties 3 and 4 are required. Every strict class is permissive, but the converse\ndoes not hold in general (unless P = NP). For instance, the class of Horn formulas is strictly tractable, but the\nclass of extended Horn formulas is only known to be permissively tractable [27].\nWhere are the classes from our paper located within this classification? As a result of Theorem 1, we find\nthat BAC is strictly tractable. By Theorem 2, DPS is not strictly tractable (unless P = NP). The classes DPS\u227a\ndo not satisfy property 4. Hence they are not considered as tractable classes. However, DPS\u2200 is permissively\ntractable, because an algorithm for DPS\u227a for an arbitrary ordering \u227a is a robust algorithm for DPS\u2200 . It remains\nopen whether DPS is permissively tractable.\n\n7 Comparisons\nWe compare the classes of our paper with other known (strictly or permissively) tractable classes. We say that\ntwo classes C1 and C2 of CNF formulas are incomparable if for every n larger than some fixed constant there\nexist formulas in C1 \\ C2 and in C2 \\ C1 with at least n variables.\nWe show that each of the classes mentioned in Proposition 6 is incomparable with a wide range of classes of\nCNF formulas, in particular with all the tractable classes considered in Speckenmeyer's survey [28], and classes\nbased on graph width parameters [16]. For showing this it suffices to consider the classes BAC and DPS only,\nwhich are boundary classes as shown in Proposition 6.\nThe following four families of formulas will be sufficient for showing most of our incomparability results.\nHere, n \u2265 1 is an integer, x1 , . . . , xn and y1 , . . . , y2n are variables, and C1 , . . . , C2n are all possible clauses\nwith variables x1 , . . . , xn .\n\n10\n\n\fFa (n) =\n\n{C1 , . . . , C2n }\n\nFs (n) =\n\n{{x1 , . . . , x\u2308 n2 \u2309 }, {x\u2308 n2 \u2309 , . . . , xn }}\n\nFc (n) =\n\n{ {xi , xi+1 } | 1 \u2264 i \u2264 n \u2212 1 } \u222a {{xn , x1 }}\n\nFac (n) =\n\n{ {yj\u22121 , yj } \u222a Cj | 1 < j \u2264 2n } \u222a {{y2n , y 1 } \u222a C1 } \u222a\n{ {yj , yj+1 } \u222a Cj | 1 \u2264 j \u2264 2n } \u222a {{y2n , y1 } \u222a C2n }.\n\nWe observe that every I(Fa (n)) is a complete bipartite graph with partition classes of size n and 2n , respectively, and that every I(Fs (n)) is a tree. Because complete bipartite graphs and trees are chordal bipartite, we can\napply Proposition 2 to obtain the following lemma.\nLemma 9. Fa (n), Fs (n) \u2208 BAC for all n \u2265 1.\nBy the following lemma, the other two classes of formulas do not intersect with DPS. Recall that two clauses C\nand D violate (*) if they have a resolvent that is neither a subset of C nor a subset of D.\nLemma 10. Fc (n), Fac (n) \u2208\n/ DPS for all n \u2265 3.\nProof. Throughout the proof we compute indices of modulo n for the vertices xi , and modulo 2n+1 for the\nvertices yj .\nFirst we show that Fc (n) \u2208\n/ DPS. The clauses C = {xi , xi+1 } and C \u2032 = {xi\u22121 , xi } \u2208 Fc (n) have the\nxi -resolvent {xi\u22121 , xi+1 } which is not a subset of C or C \u2032 . Hence, C and C \u2032 violate (*). Consequently, xi is not\nDP-simplicial for any 1 \u2264 i \u2264 n. Because Fc (n) has no other resolvents, Fc (n) has no DP-simplicial variables.\nBecause var(Fc (n)) 6= \u2205 either, we conclude that Fc (n) \u2208\n/ DPS for all n \u2265 3.\nNext we show that Fac (n) \u2208\n/ DPS. Let 1 \u2264 i \u2264 n for some n \u2265 3. Let 1 \u2264 j1 , j2 \u2264 2n such that Cj1 \u2229 Cj2 =\n{xi }. By definition, Fac (n) contains the clauses C = {yj1 , yj1 +1 }\u222aCj1 and C \u2032 = {yj2 , yj2 +1 }\u222aCj2 , which have\n6 {yj2 , yj2 +1 },\nxi -resolvent C \u2217 = {yj1 , yj1 +1 , yj2 , yj2 +1 }\u222a(Cj1 \u222aCj2 )\\{xi , xi } . However, since {yj1 , yj1 +1 } =\nwe find that C \u2217 is not a subset of C or C \u2032 . Hence, C and C \u2032 violate (*). Consequently, xi is not DP-simplicial\nfor any 1 \u2264 i \u2264 n.\nLet 1 \u2264 j \u2264 2n for some n \u2265 3. Then Fac (n) contains the two clauses C = {yj , yj+1 } \u222a Cj and\n\u2032\nC = {yj\u22121 , y j } \u222a Cj , which have yj -resolvent C \u2217 = {yj\u22121 , yj+1 } \u222a Cj . However, yj\u22121 \u2208 C \u2217 \\ C and\nyj+1 \u2208 C \u2217 \\ C \u2032 . Hence, C \u2217 is not a subset of C or C \u2032 . Consequently yj is not DP-simplicial for any 1 \u2264 j \u2264 2n .\nBecause Fac (n) has no other resolvents, Fac (n) has no DP-simplicial variables. Because var(Fac (n)) 6= \u2205 either,\nwe conclude that Fac (n) \u2208\n/ DPS for all n \u2265 3.\nSuppose that we want to show that BAC and DPS are incomparable with a class C of CNF formulas. Then,\nProposition 6 combined with Lemmas 9 and 10 implies that we only have to show the validity of the following\ntwo statements:\n(i) Fa (n) \u2208\n/ C or Fs (n) \u2208\n/ C for every n larger than some fixed constant;\n(ii) Fc (n) \u2208 C or Fac (n) \u2208 C for every n larger than some fixed constant.\n\n7.1 Easy Classes\nWe use (i) and (ii) to show that BAC and DPS are incomparable with the classes considered by Speckenmeyer [28]. For example, consider the class of 2-CNF formulas, i.e., CNF formulas where every clause contains\nat most two literals. For every n \u2265 3, Fa (n) is not a 2-CNF formula. This shows (i). Furthermore, (ii) follows\nfrom the fact that Fc (n) is a 2-CNF formula for every n \u2265 3. Consequently, the class of 2-CNF formulas is\nincomparable with BAC and DPS.\nAs a second example we consider the class of hitting formulas, i.e., CNF formulas where C \u2229 C \u2032 6= \u2205 holds\nfor any two of their clauses [28]. Now, for every n \u2265 3 the formula Fs (n) is not a hitting formula. This shows (i).\n\n11\n\n\fIt is not difficult to see that for n \u2265 3, Fac (n) is a hitting formula. This shows (ii). Consequently, the class of\nhitting formulas is incomparable with BAC and DPS.\nThe proofs for other classes of formulas considered in [28] are similar. In particular, for the classes Horn, renameable Horn, extended Horn, CC-balanced, Q-Horn, SLUR, Matched, bounded deficiency, nested, co-nested,\nand BRLRk formulas we can utilize the formulas Fa (n) to show (i) and the formulas Fc (n) to show (ii).\n\n7.2 Classes of Bounded Width\nIt is known [16] that SAT is tractable for various classes of formulas that are defined by bounding certain widthmeasures of graphs associated with formulas. Besides the incidence graph I(F ) and the directed incidence graph\nD(F ), the other prominent graph associated with a CNF formula F is the primal graph P (F ) of F , which is the\ngraph with vertex set var(F ) and edge set { x, y | x, y \u2208 var(C) for some C }. We restrict our scope to the graph\ninvariants treewidth (tw), and clique-width (cw). Recall that the latter notion has been defined in Section 2. For\nthe definition of treewidth we refer to other sources [16], as we do not need it here.\nFor a graph invariant \u03c0, a graph representation G \u2208 {P, I, D} and an integer k, we consider the class\nCNFG\nk (\u03c0) of CNF formulas F with \u03c0(G(F )) \u2264 k. For every fixed k \u2265 0, SAT can be solved in polynomial\nD\nI\ntime for the classes CNFP\nk (tw), CNFk (tw), and CNFk (cw) [16]. We show that these classes are incomparable\nwith BAC and DPS.\nProposition 7. For every k \u2265 2, CNFP\nk (tw) is incomparable with BAC and DPS.\nProof. We prove that (i) and (ii) hold with respect to CNFP\nk (tw). Because P (Fa (n)) is the complete graph on n\nvertices, it has treewidth n \u2212 1 [1, 18]. Hence, Fa (n) \u2208\n/ CNFP\nk (tw) for all n \u2265 k + 2. This proves (i). Because\nP (Fc (n)) is a cycle of length n, it has treewidth 2 [1, 18]. Hence, Fc (n) \u2208 CNFP\n2 (tw). This proves (ii).\nProposition 8. For every k \u2265 2, CNFIk (tw) is incomparable with BAC and DPS.\nProof. We prove that (i) and (ii) hold with respect to CNFIk (tw). Because I(Fa (n)) is a complete bipartite graph\nwith partition classes of size n and 2n , respectively, it has treewidth n [1, 18]. Hence, Fa (n) \u2208\n/ CNFIk (tw) for\nall n \u2265 k + 1. This proves (i). Because I(Fc (n)) is a cycle of length 2n, it has treewidth 2 [1, 18]. Hence,\nFc (n) \u2208 CNFI2 (tw). This proves (ii).\nProposition 9. For every k \u2265 4, CNFD\nk (cw) is incomparable with BAC and DPS.\nProof. First we show that BAC \\ CNFD\nk (cw) contains formulas with an arbitrary large number of variables. For\nall n \u2265 1, Brandst\u00e4dt and Lozin [3] showed that there is a bipartite permutation graph G(n) with clique-width\nn. We do not need the definition of a bipartite permutation graph; it suffices to know that bipartite permutation\ngraphs are chordal bipartite [29].\nLet G\u2032 (n) = (Un \u222a Wn , En ) denote the graph obtained from G(n) by deleting twin vertices as long as\npossible; two vertices are twins if they have exactly the same neighbors. The deletion of twins does not change\nthe clique-width of a graph [6]. Hence, G\u2032 (n) has clique-width n. It is well known and easy to see that the cliquewidth of a bipartite graph with partition classes of size r and s, respectively, is not greater than min(r, s) + 2.\nHence |Un | \u2265 n \u2212 2. Because we only deleted vertices, G\u2032 (n) is also chordal bipartite.\nLet F (n) = { N (w) | w \u2208 Wn } where N (w) denotes the set of neighbors of w in G\u2032 (n). Then G\u2032 (n) is the\nincidence graph of F (n), because G\u2032 (n) has no twins. Hence F (n) \u2208 BAC follows from Proposition 2. Recall\nthat the clique-width of G\u2032 (n) = I(F (n)) is n and that |Un | \u2265 n \u2212 2. Since all clauses of F (n) are positive,\nI(F (n)) and D(F (n)) have the same clique-width. We conclude that F (n) is a formula on at least n\u22122 variables\nthat belongs to BAC \\ CNFD\nk (cw) for n \u2265 k + 1.\nFor the converse direction we observe that D(Fc (n)) is an oriented cycle and clearly has clique-width at\nmost 4. This means that D(Fc (n)) \u2208 CNFD\n/ DPS for all n \u2265 3.\n4 (cw). By Lemma 10, we have that D(Fc (n)) \u2208\nWe then conclude that CNFD\n(cw)\n\\\nDPS\ncontains\nD(F\n(n))\nfor\nall\nn\n\u2265\n3.\nWe\nare\nleft\nto\napply\nProposition 6 to\nc\n4\ncomplete the proof of Proposition 9.\nResults similar to Propositions 7\u20139 also hold for the graph invariants branchwidth and rank-width, since a\nclass of graphs has bounded branchwidth if and only if it has bounded treewidth [1], and a class of directed\ngraphs has bounded rank-width if and only if it has bounded clique-width [12].\n12\n\n\f8 Parameterized Complexity\nWe study the complexity of SAT for formulas that are \"almost\" \u03b2-acyclic. We define what it means to be almost \u03b2acyclic in two different ways. We base the distance measure on the notion of a strong backdoor set in Section 8.1,\nand on the notion of \u03b2-hypertree width in Section 8.2. We start with a short introduction into Parameterized\nComplexity and refer to other sources [8, 11] for an in-depth treatment.\nA parameterized problem can be considered as a set of pairs (I, k), the instances, where I is the main part\nand k is the parameter. The parameter is usually a non-negative integer. The complexity class XP consists\nof parameterized decision problems \u03a0 such that for each instance (I, k) it can be decided in f (k)|I|g(k) time\nwhether (I, k) \u2208 \u03a0, where f and g are computable functions depending only on the parameter k, and |I| denotes\nthe size of I. So XP consists of parameterized decision problems which can be solved in polynomial time if\nthe parameter is a constant. A parameterized decision problem is fixed-parameter tractable if there exists a\ncomputable function f such that instances (I, k) of size n can be decided in time f (k)nO(1) . The class FPT\ndenotes the class of all fixed-parameter tractable decision problems.\nParameterized complexity offers a completeness theory, similar to the theory of NP-completeness, that allows the accumulation of strong theoretical evidence that some parameterized problems are not fixed-parameter\ntractable. This theory is based on a hierarchy of complexity classes FPT \u2286 W[1] \u2286 W[2] \u2286 . . . \u2286 XP. Each\nclass W[i] contains all parameterized decision problems that can be reduced to a certain fixed parameterized\ndecision problem under parameterized reductions. These are many-to-one reductions where the parameter for\none problem maps into the parameter for the other. More specifically, problem L reduces to problem L\u2032 if there\nis a mapping R from instances of L to instances of L\u2032 such that (i) (I, k) is a yes-instance of L if and only if\n(I \u2032 , k \u2032 ) = R(I, k) is a yes-instance of L\u2032 , (ii) k \u2032 = g(k) for a computable function g, and (iii) R can be computed\nin time f (k)nO(1) where f is a computable function and n denotes the size of (I, k). The class W[1] is considered\nas the parameterized analog to NP.\n\n8.1 Strong Backdoor Sets\nLet C be a class of CNF formulas. Consider a CNF formula F together with a set of variables B \u2286 var(F ).\nWe say that B is a strong backdoor set of F with respect to C if for all truth assignments \u03c4 : B \u2192 {0, 1} we\nhave F [\u03c4 ] \u2208 C. In that case we also say that B is a strong C-backdoor set. For every CNF formula F and every\nset B \u2286 var(F ) it holds that F is satisfiable if and only if F [\u03c4 ] is satisfiable for at least one truth assignment\n\u03c4 : B \u2192 {0, 1}. Thus, if B is a strong C-backdoor set of F , then determining whether F is satisfiable reduces to\nthe S ATISFIABILITY problem for at most 2|B| reduced CNF formulas F [\u03c4 ] \u2208 C.\nNow consider a strictly or permissively tractable class C of CNF formulas. Then, if we have found a strong\nC-backdoor set of F of size k, deciding the satisfiability of F is fixed-parameter tractable for parameter k. Hence,\nthe key question is whether we can find a strong backdoor set of size at most k if it exists. To study this question,\nwe consider the following parameterized problem; note that this problem belongs to XP for every fixed strictly\ntractable class C.\nS TRONG C-BACKDOOR\nInstance: A formula F and an integer k > 0.\nParameter: The integer k.\nQuestion: Does F have a strong C-backdoor set of size at most k?\nIt is known that S TRONG C-BACKDOOR is fixed-parameter tractable for the class C of Horn formulas and for the\nclass C of 2CNF formulas [21]. Contrary to these results, we show that S TRONG BAC-BACKDOOR is W[2]-hard.\nTheorem 3. The problem S TRONG BAC-BACKDOOR is W[2]-hard.\nS\nProof. Let S be a family of finite sets S1 , . . . , Sm . Then a subset R \u2286 m\ni=1 Si is called a hitting set of S if\nR \u2229 Si 6= \u2205 for i = 1, . . . , m. The H ITTING S ET problem is defined as follows.\nH ITTING S ET\nInstance: A family S of finite sets S1 , . . . , Sm and an integer k > 0.\n13\n\n\fParameter: The integer k.\nQuestion: Does S have a hitting set of size at most k?\nIt is well known that H ITTING S ET is W[2]-complete [8]. We reduce from this problem to\nprove the theorem.\nSm\nLet S = { S1 , . . . , Sm } and k be an instance of H ITTING S ET. We write V (S) = i=1 Si and construct a\nformula F as follows. For each s \u2208 V (S) we introduce a variable xs , and we write X = { xs | s \u2208 V (S) }. For\neach Si we introduce two variables h1i and h2i . Then, for every 1 \u2264 i \u2264 m, the formula F contains three clauses\nCi , Ci1 , and Ci2 such that:\n\u2022 Ci = { h1i , h2i };\n\u2022 Ci1 = { h1i } \u222a { xs | s \u2208 Si } \u222a { xs | s \u2208 V (S) \\ Si ) };\n\u2022 Ci2 = { h2i } \u222a { xs | s \u2208 V (S) }.\nWe need the following claims. The first claim characterizes the induced cycles in I(F ) with length at least 6.\nWe need it to prove the second claim.\nClaim 1. Let D be an induced cycle in I(F ). Then |V (D)| \u2265 6 if and only if V (D) = {h1i , h2i , xs , Ci , Ci1 , Ci2 }\nfor some 1 \u2264 i \u2264 m and s \u2208 V (S).\nWe prove Claim 1 as follows. Suppose that D is an induced cycle in I(F ) with |V (D)| \u2265 6. By construction, D\ncontains at least one vertex from X. Because any two vertices in X have exactly the same neighbors in I(F ), D\ncontains at most one vertex from X. Hence, D contains exactly one vertex from X, let xs be this vertex. Let Cij\n\u2032\nand Cij\u2032 be the two neighbors of xs on D. Because xs is the only of D that belongs to X, we find that hji and\n\u2032\nhji\u2032 belong to D. By our construction, Ci and Ci\u2032 then belong to D as well. If Ci 6= Ci\u2032 , then D contains at least\ntwo vertices from X, which is not possible. Hence Ci = Ci\u2032 , as desired. The reverse implication is trivial, and\nClaim 1 is proven.\nClaim 2. Let B be a strong BAC-backdoor set that contains variable hji . Then, for any s\u2217 \u2208 Si , the set (B\\{hji })\u222a\n{xs\u2217 } is a strong BAC-backdoor set.\nWe prove Claim 2 as follows. Let s\u2217 \u2208 Si and define B \u2032 = (B\\{hji }) \u222a {xs\u2217 }. Suppose that B \u2032 is not a strong\nBAC-backdoor set. Then there is a truth assignment \u03c4 : B \u2032 \u2192 {0, 1} with F [\u03c4 ] \u2208\n/ BAC. This means that I(F [\u03c4 ])\ncontains an induced cycle D with |V (D)| \u2265 6. Because B is a strong BAC-backdoor set, hji must belong to\nV (D). We apply Claim 1 and obtain V (D) = {h1i , h2i , xs , Ci , Ci1 , Ci2 } for some xs \u2208 X. Suppose \u03c4 (xs\u2217 ) = 1.\n/ F [\u03c4 ]. This contradiction proves Claim 2.\nThen Ci1 \u2208\n/ F [\u03c4 ]. Hence \u03c4 (xs\u2217 ) = 0, but then Ci2 \u2208\nWe are ready to prove the claim that S has a hitting set of size at most k if and only if F has a strong\nBAC-backdoor set of size at most k.\nSuppose that S has a hitting set R of size at most k. We claim that B = { xs | s \u2208 R } is a strong BACbackdoor set of F . Suppose not. Then there is a truth assignment \u03c4 with F [\u03c4 ] \u2208\n/ BAC. This means that I(F [\u03c4 ])\ncontains an induced cycle D with |V (D)| \u2265 6. By Claim 1, we obtain V (D) = {h1i , h2i , xs , Ci , Ci1 , Ci2 } for\nsome 1 \u2264 i \u2264 m and s \u2208 S. Because Ci1 , Ci2 are in I(F [\u03c4 ]), we find that R \u2229 Si = \u2205. This is not possible,\nbecause R is a hitting set of S.\nConversely, suppose that F has a strong BAC-backdoor set B of size at most k. By Claim 2, we may without\nloss of generality assume that B \u2286 X. We claim that R = { s | xs \u2208 B } is a hitting set of S. Suppose not. Then\nR \u2229 Si = \u2205 for some 1 \u2264 i \u2264 m. This means that B contains no vertex from { xs | s \u2208 Si }. Let \u03c4 : B \u2192 {0, 1}\nbe the truth assignment with \u03c4 (xs ) = 1 for all xs \u2208 B. Then Ci1 and Ci2 are in F [\u03c4 ]. Let s \u2208 Si . Then the cycle\nD with V (D) = {h1i , h2i , xs , Ci , Ci1 , Ci2 } is an induced 6-vertex cycle in I(F [\u03c4 ]). This means that F [\u03c4 ] \u2208\n/ BAC,\nwhich is not possible. Hence, we have proven Theorem 3.\nWe finish Section 8.1 by considering another type of backdoor sets. Let F be a formula and let B \u2286 var(F )\nbe a set of variables. Recall that F \u2212 B denotes the formula obtained from F after removing all literals x and x\nwith x \u2208 B from the clauses in F . We call B a deletion backdoor set with respect to a class C if F \u2212 B \u2208 C.\n\n14\n\n\fDeletion C-backdoor sets can be seen as a relaxation of strong C-backdoor sets if the class C is clause-induced,\ni.e., if for every F \u2208 C and F \u2032 \u2286 F , we have F \u2032 \u2208 C. In that case every deletion C-backdoor set B is also a\nstrong C-backdoor set. This is well known [22] and can easily be seen as follows. Let \u03c4 : B \u2192 {0, 1} be a truth\nassignment. Then by definition F [\u03c4 ] \u2286 F \u2212 B. Because B is a deletion C-backdoor set, F \u2212 B \u2208 C. Because C\nis clause-induced and F [\u03c4 ] \u2286 F \u2212 B, this means that F [\u03c4 ] \u2208 C, as required.\nNow let C be a clause-induced class. Let B be a smallest deletion C-backdoor set and let B \u2032 be a smallest\nstrong C-backdoor set. Then, from the above, we deduce |B \u2032 | \u2264 |B|. The following example shows that |B|\u2212|B \u2032 |\ncan be arbitrarily large for C = BAC, which is obviously clause-induced. Let F be the formula with var(F ) =\n{x1 , . . . , xp , y1 , . . . , yp , z1 , . . . , zp } for some p \u2265 1 and clauses\nC1\nC2\nC3\n\n=\n=\n=\n\n{x1 , . . . , xp , y1 , . . . , yp },\n{y1 , . . . , yp , z1 , . . . , zp },\n{x1 , . . . , xp , z1 , . . . , zp }.\n\nThen B = {y1 } is a smallest strong BAC-backdoor set. However, a smallest deletion BAC-backdoor set must\ncontain at least p variables.\nAnalogously to the S TRONG C-BACKDOOR problem we define the following problem, where C is a fixed\nclause-induced class.\nD ELETION C-BACKDOOR\nInstance: A formula F and an integer k > 0.\nParameter: The integer k.\nQuestion: Does F have a deletion C-backdoor set of size at most k?\nDetermining the parameterized complexity of D ELETION BAC-BACKDOOR is interesting, especially in the light\nof our W[2]-hardness result for S TRONG BAC-BACKDOOR. In other words, is the problem of deciding whether a\ngraph can be modified into a chordal bipartite graph by deleting at most k vertices fixed-parameter tractable in k?\nMarx [20] showed that the version of this problem in which the modified graph is required to be chordal instead\nof chordal bipartite is fixed-parameter tractable.\n\n8.2 \u03b2-Hypertree Width\nThe hypergraph invariant hypertree width was introduced by Gottlob, Leone, and Scarcello [14]. It is defined via\nthe notion of a hypertree decomposition of a hypergraph H, which is a triple T = (T, \u03ba, \u03bb) where T is a rooted\ntree and \u03c7 and \u03bb are labelling functions with \u03c7(t) \u2286 V (H) and \u03bb(t) \u2286 E(H), respectively, for every t \u2208 V (T ),\nsuch that the following conditions hold:\n1. For every e \u2208 E(H) there is a t \u2208 V (T ) such that e \u2286 \u03c7(t).\n2. For every v \u2208 V (H), the set { t \u2208 V (T ) | v \u2208 \u03c7(t) } induces a connected subtree of T .\nS\n3. For every t \u2208 V (T ), it holds that \u03c7(t) \u2286 e\u2208\u03bb(t) e.\n4. For every t \u2208 V (T ), if a vertex v occurs in some hyperedge e \u2208 \u03bb(t) and if v \u2208 \u03c7(t\u2032 ) for some node t\u2032 in\nthe subtree below t, then v \u2208 \u03c7(t).\nThe width of a hypertree decomposition (T, \u03c7, \u03bb) is max{ |\u03bb(t)| | t \u2208 V (T ) }. The hypertree width, denoted\nhw(H), of a hypergraph H is the minimum width over all its hypertree decompositions. Many NP-hard problems such as CSP or Boolean database queries can be solved in polynomial time for instances with associated\nhypergraphs of bounded hypertree width [13].\nGottlob and Pichler [15] defined \u03b2-hypertree width as a \"hereditary variant\" of hypertree width. The \u03b2hypertree width, denoted \u03b2-hw(H), of a hypergraph H is defined as the maximum hypertree width over all\npartial hypergraphs H \u2032 of H. Using the fact that \u03b1-acyclic hypergraphs are exactly the hypergraphs of hypertree\nwidth 1 [14], one deduces that the hypergraphs of \u03b2-hypertree width 1 are exactly the \u03b2-acyclic hypergraphs.\nUnfortunately, the complexity of determining the \u03b2-hypertree width of a hypergraph is not known [15]. However,\nwe show the following. Here, a \u03b2-hypertree decomposition of width k of a hypergraph H is an oracle that\nproduces for every partial hypergraph H \u2032 of H a hypertree decomposition of width at most k.\n15\n\n\fTheorem 4. SAT, parameterized by an upper bound k on the \u03b2-hypertree width of a CNF formula F , is W[1]hard even if a \u03b2-hypertree decomposition of width k for H(F ) is given.\nProof. A clique in a graph is a subset of vertices that are mutually adjacent. A k-partite graph is balanced if its k\npartition classes are of the same size. A partitioned clique of a balanced k-partite graph G = (V1 , . . . , Vk , E) is\na clique K with |K \u2229 Vi | = 1 for i = 1 . . . , k. We devise a parameterized reduction from the following problem,\nwhich is W[1]-complete [25].\nPARTITIONED C LIQUE\nInstance: A balanced k-partite graph G = (V1 , . . . , Vk , E).\nParameter: The integer k.\nQuestion: Does G have a partitioned clique?\nBefore we describe the reduction we introduce some auxiliary concepts. For any three variables z, x1 , x2 , let\nF (z, x1 , x2 ) denote the formula consisting of the clauses\n{z, x1 , x2 }, {z, x1 , x2 }, {z, x1 , x2 }, {z, x1 , x2 }, {z, x1 , x2 }.\nThis formula has exactly three satisfying assignments, corresponding to the vectors 000, 101, and 110. Hence\neach satisfying assignment sets at most one out of x1 and x2 to true, and if one of them is set to true, then z\nis set to true as well (\"z = x1 + x2 \"). Taking several instances of this formula we can build a \"selection\ngadget.\" Let x1 , . . . , xm and z1 , . . . , zm\u22121 be variables. We define F =1 (x1 , . . . , xm ; z1 , . . . , zm\u22121 ) as the union\nSm\u22121\nof F (z1 , x1 , x2 ), i=2 F (zi , zi\u22121 , xi+1 ), and {{zm\u22121}}. Now each satisfying assignment of this formula sets\nexactly one variable out of {x1 , . . . , xm } to true, and, conversely, for each 1 \u2264 i \u2264 m there exists a satisfying\nassignment that sets exactly xi to true and all other variables from {x1 , . . . , xm } to false.\nNow we describe the reduction. Let G = (V1 , . . . , Vk ) be a balanced k-partite graph for k \u2265 2. We write\nVi = {v1i , . . . , vni }. We construct a CNF formula F . As the variables of F we take the vertices of G plus new\nSk\nvariables zji for 1 \u2264 i \u2264 k and 1 \u2264 j \u2264 n \u2212 1. We put F = i=0 Fi where the formulas Fi are defined as\nfollows: F0 contains for any u \u2208 Vi and v \u2208 Vj (i 6= j) with uv \u2208\n/ E the clause Cu,v = { u, v } \u222a { w | w \u2208\ni\n(Vi \u222a Vj ) \\ { u, v } }; for i > 0 we define Fi = F =1 (v1i , . . . , vni ; z1i , . . . , zn\u22121\n). To prove Theorem 4 it suffices to\nshow the following two claims.\nClaim 1. \u03b2-hw(H(F )) \u2264 k.\nWe prove Claim 1 as follows. First we show that that \u03b2-hw(H(F0 )) \u2264 k. Let H0\u2032 be a partial hypergraph\nof H(F0 ). Let I be the set of indices 1 \u2264 i \u2264 k such that some hyperedge of H0\u2032 contains Vi . For each\ni \u2208 I we choose a hyperedge ei of H0\u2032 that contains Vi . The partial hypergraph H0\u2032 admits a trivial hypertree\ndecomposition (T0 , \u03c70 , \u03bb0 ) of width at most k with a single tree node t0 where \u03c70 (t0 ) contains all vertices of H0\u2032\nand \u03bb0 (t0 ) = { ei | i \u2208 I }. Second we observe that \u03b2-hw(H(Fi )) = 1 for 1 \u2264 i \u2264 k: H(Fi ) is \u03b2-acyclic, and\n\u03b2-acyclic hypergraphs have \u03b2-hypertree width 1.\nNow let H \u2032 be an arbitrarily chosen partial hypergraph of H(F ). For i = 0, . . . , k, we let Hi\u2032 denote the\n(maximal) partial hypergraph of H \u2032 that is contained in H(Fi ). We let T0 = (T0 , \u03c70 , \u03bb0 ) be a hypertree decomposition of width at most k of H0\u2032 as defined above. For i = 1, . . . , k we let Ti = (Ti , \u03c7i , \u03bbi ) be a hypertree\ndecomposition of width 1 of Hi\u2032 . We combine these k + 1 hypertree decompositions to a hypertree decomposition\nof width at most k for H \u2032 . We will do this by adding the decompositions T1 , . . . , Tk to T0 one by one and without\nincreasing the width of T0 .\nLet Ti\u2217 = (Ti\u2217 , \u03c7\u2217i , \u03bb\u2217i ) denote the hypertree decomposition of width at most k obtained from T0 by adding\nthe first i hypertree decompositions. For i = 0 we let T0\u2217 = T0 . For i > 0 we proceed as follows.\nFirst we consider the case where there is a hyperedge e \u2208 H0\u2032 with Vi+1 \u2286 e. Observe that there exists a node\n\u2217\n\u2217\n\u2217\nt \u2208 V (Ti\u2217 ) with e \u2286 \u03c7(t). We define Ti+1\n= (Ti+1\n, \u03c7\u2217i+1 , \u03bb\u2217i+1 ) as follows. We obtain Ti+1\nfrom the disjoint\n\u2217\nunion of Ti\u2217 and Ti+1 by adding an edge between t and the root of Ti+1 . As the root of Ti+1\nwe choose the root\nof Ti\u2217 . We set \u03c7\u2217i+1 (t) = \u03c7\u2217i (t) for every t \u2208 V (Ti\u2217 ), and \u03c7\u2217i+1 (t) = \u03c7i+1 (t) \u222a Vi+1 for every t \u2208 V (Ti+1 );\nwe set \u03bb\u2217i+1 (t) = \u03bb\u2217i (t) for every t \u2208 V (Ti\u2217 ), and \u03bb\u2217i+1 (t) = \u03bbi+1 (t) \u222a {e} for every t \u2208 V (Ti+1 ) (hence\n\u2217\n|\u03bb\u2217i+1 (t)| \u2264 max(2, k) = k). Consequently Ti+1\nhas width at most k.\n\n16\n\n\f\u2217\nIt remains to consider the case where there is no hyperedge e \u2208 H0\u2032 with Vi+1 \u2286 e. We define Ti+1\nas\n\u2217\nfollows. We obtain Ti+1\nfrom the disjoint union of Ti\u2217 and Ti+1 by adding an edge between an arbitrary node\n\u2217\nt \u2208 V (Ti\u2217 ) and the root of Ti+1 . As the root of Ti+1\nwe choose the root of Ti\u2217 . We set \u03c7\u2217i+1 = \u03c7\u2217i \u222a \u03c7i+1 and\n\u2217\n\u03bb\u2217i+1 = \u03bb\u2217i \u222a \u03bbi+1 . Clearly Ti+1\nhas width at most k. This completes the proof of Claim 1.\n\nClaim 2. G has a partitioned clique if and only if F is satisfiable.\nTo prove Claim 2 we first suppose that G has a partitioned clique K. We define a partial truth assignment\n\u03c4 : V \u2192 {0, 1} by setting \u03c4 (v) = 1 for v \u2208 K, and \u03c4 (v) = 0 for v \u2208\n/ K. This partial assignment satisfies\nF0 , and it is easy to extend \u03c4 to a satisfying truth assignment of F . Conversely, suppose that F has a satisfying\ntruth assignment \u03c4 . Because of the formulas Fi , 1 \u2264 i \u2264 k, \u03c4 sets exactly one variable vjii \u2208 Vi to true. Let\n\u2032\nK = {vj11 , . . . , vjkk }. The clauses in F0 ensure that vjii and vjii\u2032 are adjacent in G for each pair 1 \u2264 i < i\u2032 \u2264 k,\nhence K is a partitioned clique of G. This proves Claim 2.\nWe finish this section by showing some consequences of Theorem 4 with respect to the clique-width and\nrank-width of a formula. By definition, the clique-width of a CNF formula is always bounded by its directed\nclique-width. However, in general the directed clique-width can be much higher than the undirected one. It\nis well known that SAT is fixed-parameter tractable for the parameter directed clique-width [5, 10]. Fischer,\nMakowsky, and Ravve [10] developed a dynamic programming algorithm that counts the number of satisfying\ntruth assignments in linear time for CNF formulas of bounded directed clique-width. They also conjectured that\ntheir method can be extended to work for formulas of bounded (undirected) clique-width. However, the reduction\nin the proof of Theorem 4 shows that this is not possible unless FPT = W[1].\nCorollary 1. SAT, parameterized by an upper bound k on the clique-width of the incidence graph of a formula\nF , is W[1]-hard even if a k-expression for I(F ) is given.\nProof. We use the same parameterized reduction as in the proof of Theorem 4. Hence it remains to prove that the\nclique-width of the incidence graph of the formula F in the proof of Theorem 4 is at most k \u2032 = O(k). In fact, we\nshow that a k + 4-expression for the incidence graph of F can be obtained in polynomial time.\nWe start with the following claim. Let n \u2265 3, and for i = 1, . . . , k, let Ti be the tree with vertices\ni\ni\ni\ni\nC1i , . . . , Cn\u22121\n, v1i , . . . , vni , z1i , . . . , zn\u22121\n, and edges C1i v1i , C1i v2i , C1i z1i , and Cji vj+1\n, Cji zj\u22121\n, Cji zji for j =\n2, . . . , n \u2212 1.\nClaim 1. Every Ti allows a 5-expression resulting in a labeling in which every Cji has label d, every vji has label\ni\ni, zn\u22121\nhas label e, whereas every other zji has label d.\nLet 1 \u2264 i \u2264 k. We prove Claim 1 by induction on n. Let n = 3. We get a desired 5-expression of Ti in the\nfollowing way. We introduce v1i and v2i , each with label i. Then we introduce C1i with label b. We perform the\noperation \u03b7b,i resulting in edges between C1i and v1i , v2i , respectively. We introduce z1i with label c and perform\nthe operation \u03b7b,c resulting in an edge between C1i and z1i . We perform the operation \u03c1b\u2192d resulting in a change\nof label of C1i from b to d. We introduce C2i with label b and perform the operation \u03b7b,c resulting in an edge\nbetween C2i and z1i . We perform the operation \u03c1c\u2192d resulting in a change of label of z1i from c to d. We introduce\nv3i with label c and perform the operation \u03b7b,c resulting in an edge between C2i and v3i . We perform the operation\n\u03c1c\u2192i resulting in a change of label of v3i from c to i. We introduce z2i with label e and perform the operation\n\u03b7b,e resulting in an edge between C2i and z2i . Hence, we have obtained T3 . What is left to do is to perform the\noperation \u03c1b\u2192d resulting in a change of label of C2i from b to d.\nLet n \u2265 4. Suppose that we have a labeling of Ti\u22121 as in the statement of the claim. Then we do as follows.\ni\ni\ni\nwith label b and perform the operation \u03b7b,e resulting in an edge between Cn\u22121\nand zn\u22122\n. We\nWe introduce Cn\u22121\ni\ni\nperform the operation \u03c1e\u2192d resulting in a change of label of zn\u22122 from e to d. We introduce vn with label c and\ni\nperform the operation \u03b7b,c resulting in an edge between Cn\u22121\nand vni . We perform the operation \u03c1c\u2192i resulting\ni\ni\nin a change of label of vn from c to i. We introduce zn\u22121 with label e and perform the operation \u03b7b,e resulting\ni\ni\nin an edge between Cn\u22121\nand zn\u22121\n. Hence, we have obtained Tn . What is left to do is to perform the operation\ni\n\u03c1b\u2192d resulting in a change of label of Cn\u22121\nfrom b to d. This completes the proof of Claim 1.\nNote that in the proof of Claim 1 we never performed an operation \u03b7d,x for some x \u2208 {b, c, d, e, i}. Hence, we\ncan consider the trees in order T1 , . . . , Tk to obtain a (k + 4)-expression for their disjoint union where v1i , . . . , vki\nare the (only) vertices of label i for i = 1, . . . , k. Moreover, we may assume that all other vertices have label\n17\n\n\fd because we can apply the operation \u03c1e\u2192d afterwards. For s = 1 and t = 2 we now introduce a new vertex\nDs,t with label b and perform the operations \u03b7b,s , \u03b7b,t to connect Ds,t to every vis and every vjt , respectively.\nAfterwards we perform the operation \u03c1b\u2192d resulting in a change of label of Ds,t from b to d. In this way, we\ncan add a vertex Ds,t for every other index pair 1 \u2264 s < t \u2264 k as well while using no new labels. We call the\nresulting graph I \u2032 .\nWe now return to the incidence graph I(F ) of the formula F in the proof of Theorem 4. Observe that I(F )\ncan be obtained from I \u2032 by adding a number of copies of the vertices Cji and Ds,t . This does not increase the\nclique-width of I \u2032 as explained in the proof of Proposition 9. Hence, the clique-width of I(F ) is at most k + 4,\nas required. This completes the proof of Corollary 1.\nThe already mentioned graph parameter rank-width was introduced by Oum and Seymour [23] for approximating the clique-width of graphs. A certain structure that certifies that a graph has rank-width at most k is\ncalled a rank-width decomposition of width k. Similar to clique-width, one can define the rank-width of a directed graph that takes the orientation of edges into account. The directed (or signed) rank-width of a CNF\nformula is the rank-width of its directed incidence graph. Ganian, Hlin\u011bn\u00fd, and Obdr\u017e\u00e1lek [12] developed an efficient dynamic programming algorithm that counts in linear time the number of satisfying assignments of a CNF\nformula of bounded directed rank-width. Because bounded undirected rank-width implies bounded undirected\nclique-width [23], the following is a direct consequence of Corollary 1.\nCorollary 2. SAT, parameterized by an upper bound k on the rank-width of the incidence graph of F , is W[1]hard even if a rank-decomposition of width k for I(F ) is given.\n\n9 Conclusion\nWe have studied new classes of CNF formulas: the strictly tractable class BAC, the permissively tractable class\nDPS\u2200 , and the hard-to-recognize class DPS. Our results show that the classes are incomparable with previously\nstudied classes. Moreover, they establish an interesting link between SAT and algorithmic graph theory: the\nformulas in BAC are exactly the formulas whose incidence graphs belong to the class of chordal bipartite graphs,\na prominent and well-studied graph class. It would be interesting to study systematically other classes of bipartite\ngraphs, e.g., the classes described by Brandst\u00e4dt, Le and Spinrad [2], in order to determine the complexity of SAT\nrestricted to CNF formulas whose incidence graphs belong to the class under consideration.\nWe have also established hardness results for two natural strategies for gradually extending BAC: extensions\nvia strong backdoor sets and extensions via \u03b2-hypertree decompositions. The first extension is fixed-parameter\nintractable because it is W[2]-hard to find a strong backdoor set. The second extension is fixed-parameter intractable because SAT is W[1]-hard when parameterized by an upper bound on the \u03b2-hypertree width even if the\n\u03b2-hypertree decomposition is provided. It would be interesting to know whether SAT belongs to XP for CNF\nformulas of bounded \u03b2-hypertree width, if a \u03b2-hypertree decomposition is provided.\n\nReferences\n[1] Hans L. Bodlaender. A partial k-arboretum of graphs with bounded treewidth. Theoret. Comput. Sci.,\n209(1-2):1\u201345, 1998.\n[2] Andreas Brandst\u00e4dt, Van Bang Le, and Jeremy P. Spinrad. Graph classes: a survey. SIAM Monographs on\nDiscrete Mathematics and Applications. SIAM, Philadelphia, PA, 1999.\n[3] Andreas Brandst\u00e4dt and Vadim V. Lozin. On the linear structure and clique-width of bipartite permutation\ngraphs. Ars Combinatoria, 67:273\u2013281, 2003.\n[4] B. Courcelle, J. Engelfriet, and G. Rozenberg. Context-free handle-rewriting hypergraph grammars. In\nHartmut Ehrig, Hans-J\u00f6rg Kreowski, and Grzegorz Rozenberg, editors, Graph-Grammars and their Application to Computer Science, 4th International Workshop, Bremen, Germany, March 5\u20139, 1990, Proceedings,\nvolume 532 of Lecture Notes in Computer Science, pages 253\u2013268, 1991.\n\n18\n\n\f[5] B. Courcelle, J. A. Makowsky, and U. Rotics. On the fixed parameter complexity of graph enumeration\nproblems definable in monadic second-order logic. Discr. Appl. Math., 108(1-2):23\u201352, 2001.\n[6] B. Courcelle and S. Olariu. Upper bounds to the clique-width of graphs. Discr. Appl. Math., 101(1-3):77\u2013\n114, 2000.\n[7] M. Davis and H. Putnam. A computing procedure for quantification theory. J. ACM, 7(3):201\u2013215, 1960.\n[8] R. G. Downey and M. R. Fellows. Parameterized Complexity. Monographs in Computer Science. Springer\nVerlag, New York, 1999.\n[9] Ronald Fagin. Degrees of acyclicity for hypergraphs and relational database schemes. J. ACM, 30(3):514\u2013\n550, 1983.\n[10] E. Fischer, J. A. Makowsky, and E. R. Ravve. Counting truth assignments of formulas of bounded tree-width\nor clique-width. Discr. Appl. Math., 156(4):511\u2013529, 2008.\n[11] J\u00f6rg Flum and Martin Grohe. Parameterized Complexity Theory, volume XIV of Texts in Theoretical Computer Science. An EATCS Series. Springer Verlag, Berlin, 2006.\n[12] Robert Ganian, Petr Hlinen\u00fd, and Jan Obdrz\u00e1lek. Better algorithms for satisfiability problems for formulas\nof bounded rank-width. In Kamal Lodaya and Meena Mahajan, editors, IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2010, December 15-18, 2010,\nChennai, India, volume 8 of LIPIcs, pages 73\u201383. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,\n2010.\n[13] Georg Gottlob, Nicola Leone, and Francesco Scarcello. Hypertree decompositions: a survey. In Mathematical Foundations of Computer Science, 2001 (Mari\u00e1nsk\u00e9 L\u00e1zn\u0115), volume 2136 of Lecture Notes in Computer\nScience, pages 37\u201357. Springer, 2001.\n[14] Georg Gottlob, Nicola Leone, and Francesco Scarcello. Hypertree decompositions and tractable queries. J.\nof Computer and System Sciences, 64(3):579\u2013627, 2002.\n[15] Georg Gottlob and Reinhard Pichler. Hypergraphs in model checking: acyclicity and hypertree-width versus\nclique-width. SIAM J. Comput., 33(2):351\u2013378, 2004.\n[16] Georg Gottlob and Stefan Szeider. Fixed-parameter algorithms for artificial intelligence, constraint satisfaction, and database problems. The Computer Journal, 51(3):303\u2013325, 2006. Survey paper.\n[17] Peter L. Hammer, Frederic Maffray, and Myriam Preismann. A characterization of chordal bipartite graphs.\nTechnical report, Rutgers University, New Brunswick, NJ, 1989.\n[18] Ton Kloks and Hans Bodlaender. Approximating treewidth and pathwidth of some classes of perfect graphs.\nIn Algorithms and Computation (Nagoya, 1992), volume 650 of Lecture Notes in Computer Science, pages\n116\u2013125. Springer Verlag, 1992.\n[19] Oliver Kullmann and Horst Luckhardt. Algorithms for SAT/TAUT decision based on various measures,\nmanuscript, 1999.\n[20] D\u00e1niel Marx. Chordal deletion is fixed-parameter tractable. Algorithmica, 57(4):747\u2013768, 2010.\n[21] Naomi Nishimura, Prabhakar Ragde, and Stefan Szeider. Detecting backdoor sets with respect to Horn and\nbinary clauses. In Proceedings of SAT 2004 (Seventh International Conference on Theory and Applications\nof Satisfiability Testing, 10\u201313 May, 2004, Vancouver, BC, Canada), pages 96\u2013103, 2004.\n[22] Naomi Nishimura, Prabhakar Ragde, and Stefan Szeider. Solving #SAT using vertex covers. Acta Informatica, 44(7-8):509\u2013523, 2007.\n[23] Sang-il Oum and Paul Seymour. Approximating clique-width and branch-width. J. Combin. Theory Ser. B,\n96(4):514\u2013528, 2006.\n19\n\n\f[24] Michael J. Pelsmajer, Jacent Tokazy, and Douglas B. West. New proofs for strongly chordal graphs and\nchordal bipartite graphs. Unpublished Manuscript, 2004.\n[25] Krzysztof Pietrzak. On the parameterized complexity of the fixed alphabet shortest common supersequence\nand longest common subsequence problems. J. of Computer and System Sciences, 67(4):757\u2013771, 2003.\n[26] Marko Samer and Stefan Szeider. Algorithms for propositional model counting. J. Discrete Algorithms,\n8(1):50\u201364, 2010.\n[27] John S. Schlipf, Fred S. Annexstein, John V. Franco, and R. P. Swaminathan. On finding solutions for\nextended Horn formulas. Information Processing Letters, 54(3):133\u2013137, 1995.\n[28] Ewald Speckenmeyer. Classes of easy expressions. In Armin Biere, Marijn Heule, Hans van Maaren, and\nToby Walsh, editors, Handbook of Satisfiability, chapter 13, Section 1.19, pages 27\u201331. IOS Press, 2009.\n[29] Jeremy P. Spinrad. Efficient Graph Representations. Fields Institute Monographs. AMS, 2003.\n[30] R. E. Tarjan and M. Yannakakis. Simple linear-time algorithms to test chordality of graphs, test acyclicity\nof hypergraphs, and selectively reduce acyclic hypergraphs. SIAM J. Comput., 13(3):566\u2013579, 1984.\n[31] Ryuhei Uehara. Linear time algorithms on chordal bipartite and strongly chordal graphs. In Automata, languages and programming, volume 2380 of Lecture Notes in Computer Science, pages 993\u20131004. Springer,\n2002.\n\n20\n\n\f"}