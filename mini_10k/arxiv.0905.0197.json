{"id": "http://arxiv.org/abs/0905.0197v2", "guidislink": true, "updated": "2010-01-11T20:12:14Z", "updated_parsed": [2010, 1, 11, 20, 12, 14, 0, 11, 0], "published": "2009-05-02T10:43:30Z", "published_parsed": [2009, 5, 2, 10, 43, 30, 5, 122, 0], "title": "An Application of Proof-Theory in Answer Set Programming", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0905.2382%2C0905.3176%2C0905.1756%2C0905.1600%2C0905.4435%2C0905.0925%2C0905.4073%2C0905.4802%2C0905.1218%2C0905.3027%2C0905.1784%2C0905.2564%2C0905.0373%2C0905.1437%2C0905.0259%2C0905.0397%2C0905.0197%2C0905.3507%2C0905.0370%2C0905.4897%2C0905.0867%2C0905.4800%2C0905.2066%2C0905.1470%2C0905.4086%2C0905.1661%2C0905.3188%2C0905.1338%2C0905.1388%2C0905.0321%2C0905.4177%2C0905.2399%2C0905.4831%2C0905.2616%2C0905.1253%2C0905.2917%2C0905.2166%2C0905.4580%2C0905.3143%2C0905.1190%2C0905.0692%2C0905.1165%2C0905.3759%2C0905.0304%2C0905.0202%2C0905.4835%2C0905.0460%2C0905.1850%2C0905.4063%2C0905.0831%2C0905.3098%2C0905.0206%2C0905.1541%2C0905.2077%2C0905.0092%2C0905.0008%2C0905.4445%2C0905.4470%2C0905.3673%2C0905.1346%2C0905.1331%2C0905.4306%2C0905.2224%2C0905.1890%2C0905.4726%2C0905.0638%2C0905.4866%2C0905.4579%2C0905.3309%2C0905.0175%2C0905.2607%2C0905.0666%2C0905.4717%2C0905.1114%2C0905.2852%2C0905.4808%2C0905.2501%2C0905.1359%2C0905.0272%2C0905.1727%2C0905.1851%2C0905.2912%2C0905.2758%2C0905.1351%2C0905.0369%2C0905.3813%2C0905.4625%2C0905.2376%2C0905.3577%2C0905.4188%2C0905.2264%2C0905.1562%2C0905.1223%2C0905.4217%2C0905.0860%2C0905.2944%2C0905.3856%2C0905.0419%2C0905.4801%2C0905.0500%2C0905.2486&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "An Application of Proof-Theory in Answer Set Programming"}, "summary": "We apply proof-theoretic techniques in answer Set Programming. The main\nresults include: 1. A characterization of continuity properties of\nGelfond-Lifschitz operator for logic program. 2. A propositional\ncharacterization of stable models of logic programs (without referring to loop\nformulas.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0905.2382%2C0905.3176%2C0905.1756%2C0905.1600%2C0905.4435%2C0905.0925%2C0905.4073%2C0905.4802%2C0905.1218%2C0905.3027%2C0905.1784%2C0905.2564%2C0905.0373%2C0905.1437%2C0905.0259%2C0905.0397%2C0905.0197%2C0905.3507%2C0905.0370%2C0905.4897%2C0905.0867%2C0905.4800%2C0905.2066%2C0905.1470%2C0905.4086%2C0905.1661%2C0905.3188%2C0905.1338%2C0905.1388%2C0905.0321%2C0905.4177%2C0905.2399%2C0905.4831%2C0905.2616%2C0905.1253%2C0905.2917%2C0905.2166%2C0905.4580%2C0905.3143%2C0905.1190%2C0905.0692%2C0905.1165%2C0905.3759%2C0905.0304%2C0905.0202%2C0905.4835%2C0905.0460%2C0905.1850%2C0905.4063%2C0905.0831%2C0905.3098%2C0905.0206%2C0905.1541%2C0905.2077%2C0905.0092%2C0905.0008%2C0905.4445%2C0905.4470%2C0905.3673%2C0905.1346%2C0905.1331%2C0905.4306%2C0905.2224%2C0905.1890%2C0905.4726%2C0905.0638%2C0905.4866%2C0905.4579%2C0905.3309%2C0905.0175%2C0905.2607%2C0905.0666%2C0905.4717%2C0905.1114%2C0905.2852%2C0905.4808%2C0905.2501%2C0905.1359%2C0905.0272%2C0905.1727%2C0905.1851%2C0905.2912%2C0905.2758%2C0905.1351%2C0905.0369%2C0905.3813%2C0905.4625%2C0905.2376%2C0905.3577%2C0905.4188%2C0905.2264%2C0905.1562%2C0905.1223%2C0905.4217%2C0905.0860%2C0905.2944%2C0905.3856%2C0905.0419%2C0905.4801%2C0905.0500%2C0905.2486&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We apply proof-theoretic techniques in answer Set Programming. The main\nresults include: 1. A characterization of continuity properties of\nGelfond-Lifschitz operator for logic program. 2. A propositional\ncharacterization of stable models of logic programs (without referring to loop\nformulas."}, "authors": ["V. W. Marek", "J. B. Remmel"], "author_detail": {"name": "J. B. Remmel"}, "author": "J. B. Remmel", "arxiv_comment": "22 pages. Short version was published in ICLP08. New version slightly\n  shorter than the previous version", "links": [{"href": "http://arxiv.org/abs/0905.0197v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0905.0197v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0905.0197v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0905.0197v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:0905.0197v2 [cs.AI] 11 Jan 2010\n\nAn Application of Proof-Theory in Answer Set\nProgramming\nV. W. Marek Department of Computer Science\nUniversity of Kentucky\nLexington, KY 40506\nJ.B. Remmel\nDepartments of Computer Science and Mathematics\nUniversity of California\nLa Jolla, CA 92093\nOctober 30, 2018\n\nAbstract\nUsing a characterization of stable models of logic programs P as satisfying valuations of a suitably chosen propositional theory, called the set of\nreduced defining equations r\u03a6P , we show that the finitary character of that\ntheory r\u03a6P is equivalent to a certain continuity property of the GelfondLifschitz operator GLP associated with the program P .\nWe discuss possible extensions of techniques proposed in this paper to the\ncontext of cardinality constraints.\n\n1\n\nIntroduction\n\nThe use of proof theory in logic based formalisms for constraint solving is pervasive. For example, in Satisfiability (SAT), proof theoretic methods are used to\nfind lower bounds on complexity of various SAT algorithms. However, prooftheoretic methods have not played as prominent role in Answer Set Programming\n(ASP) formalisms. This is not to say that there were no attempts to apply prooftheoretic methods in ASP. To give a few examples, Marek and Truszczynski in\n[MT93] used the proof-theoretic methods to characterize Reiter's extensions in\n1\n\n\fDefault Logic (and thus stable semantics of logic programs). Bonatti [Bo04] and\nseparately Milnikel [Mi05] devised non-monotonic proof systems to study skeptical consequences of programs and default theories. Lifschitz [Li96] used prooftheoretic methods to approximate well-founded semantics of logic programs. Bondarenko et.al. [BTK93] studied an approach to stable semantics using methods\nwith a clear proof-theoretic flavor. Marek, Nerode, and Remmel in a series of\npapers, [MNR90a, MNR90b, MNR91, MNR92, MNR94a, MNR94b], developed\nproof theoretic methods to study what they termed non-monotonic rule systems\nwhich have as special cases almost all ASP formalisms that have been seriously\nstudied in the literature. Recently the area of proof systems for ASP (and more\ngenerally, nonmonotonic logics) received a lot of attention [GS07, JO07]. It is\nclear that the community feels that an additional research of this area is necessary.\nNevertheless, there is no clear classification of proof systems for nonmonotonic\nreasoning analogous to that present in classical logic, and SAT in particular.\nIn this paper, we define a notion of P -proof schemes, which is a kind of a proof system that was previously used by Marek, Nerode, and Remmel to study complexity\nissues for stable semantics of logic programs [MNR94a]. This proof system abstracts of M -proofs of [MT93] and produces Hilbert-style proofs. The nonmonotonic character of our P -proofs is provided by the presence of guards, called the\nsupport of the proof scheme, to insure context-dependence. A different but equivalent, presentation of proof schemes, using a guarded resolution is also possible\n[MR09].\nWe shall show that we can use P -proof schemes to find a characterization of stable\nmodels via reduced defining equations. While in general these defining equations\nmay be infinite, we study the case of programs for which all these equations are\nfinite. This resulting class of programs, called FSP-programs, turn out to be characterized by a form of continuity of the Gelfond-Lifschitz operator.\n\n1.1 Contributions of the paper\nThe contributions of this paper consist, primarily of investigations that elucidate\nthe proof-theoretical character of the stable semantics for logic programs, an area\nwith 20 years history [GL88]. The principal results of this paper are:\n1. We show that the Gelfond-Lifschitz operator GLP is, in fact a proof-theoretical\nconstruct (Proposition 4.3)\n2. As a result of the analysis of the Gelfond-Lifschitz operator we are able to\nshow that the upper-half continuity of that operator is equivalent to finiteness\nof (propositional) formulas in a certain class associated with the program P\n(Proposition 4.6)\n2\n\n\fWe also discuss possible extension of these results to the case of programs with\ncardinality constraints.\n\n2\n\nPreliminaries\n\nLet At be a countably infinite set of atoms. We will study programs consisting of\nclauses built of the atoms from At. A program clause C is a string of the form\np \u2190 q1 , . . . , qm , \u00acr1 , . . . , \u00acrn\n\n(1)\n\nThe integers m or n or both can be 0. The atom p will be called the head of\nC and denoted head (C). We let posBody (C) denote the set {q1 , . . . , qm } and\nnegBody (C) denote the set {r1 , . . . , rn }. For any set of atoms X, we let \u00acX\ndenote the conjunction of negations of atoms from X. Thus, we can write clause\n(1) as\nhead (C) \u2190 posBody (C), \u00acnegBody (C).\nLet us stress that the set negBody(C) is a set of atoms, not a set of negated atoms\nas is sometimes used in the literature. A normal propositional program is a set P\nof such clauses. For any M \u2286 At, we say that M is model of C if whenever\nq1 , . . . , qm \u2208 M and {r1 , . . . , rn } \u2229 M = \u2205, then p \u2208 M . We say that M is a\nmodel of a program P if M is a model of each clause C \u2208 P . Horn clauses are\nclauses with no negated literals, i.e. clauses of the form (1) where n = 0. We\nwill denote by Horn(P ) the part of the program P consisting of its Horn clauses.\nHorn programs are logic programs P consisting entirely of Horn clauses. Thus for\na Horn program P , P = Horn(P ).\nEach Horn program P has a least model over the Herbrand base and the least model\nof P is the least fixed point of a continuous operator TP representing one-step Horn\nclause logic deduction ([L89]). That is, for any set I \u2286 At, we let TP (I) equal\nthe set of all p \u2208 At such that there is a clause C = p \u2190 q1 , . . . , qm in P and\nq1 , . . . , qm \u2208 I. Then TP has a least fixed point FP which\nS is obtained by iterating\nTP starting at the empty set for \u03c9 steps, i.e., FP = n\u2208\u03c9 TPn (\u2205) where for any\nI \u2286 At, TP0 (I) = I and TPn+1 (I) = TP (TPn (I)). Then FP is the least model of P .\nThe semantics of interest for us is the stable semantics of normal programs, although we will discuss some extensions in Section ??. The stable models of a\nprogram P are defined as fixed points of the operator TP,M . This operator is defined on the set of all subsets of At, P(At ). If P is a program and M \u2286 At is a\nsubset of the Herbrand base, define operator TP,M : P(At) \u2192 P(At) as follows:\nTP,M (I) = {p : there exist a clause C = p \u2190 q1 , . . . , qm , \u00acr1 , . . . , \u00acrn\nin P such that q1 \u2208 I, . . . , qm \u2208 I, r1 \u2208\n/ M, . . . , rn \u2208\n/ M}\n3\n\n\fThe following is immediate, see [Ap90] for unexplained notions.\nProposition 2.1 For every program P and every set M of atoms the operator TP,M\nis monotone and continuous.\nThus the operator TP,M like all monotonic continuous operators, possesses a least\nfixed point FP,M .\nGiven program P and M \u2286 At, we define the Gelfond-Lifschitz reduct of P , PM ,\nas follows. For every clause C = p \u2190 q1 , . . . , qm , \u00acr1 , . . . , \u00acrn of P , execute the\nfollowing operations.\n(1) If some atom ri , 1 \u2264 i \u2264 n, belongs to M , then eliminate C altogether.\n(2) In the remaining clauses that have not been eliminated by operation (1), eliminate all the negated atoms.\nThe resulting program PM is a Horn propositional program. The program PM\npossesses a least Herbrand model. If that least model of PM coincides with M ,\nthen M is called a stable model for P . This gives rise to an operator GLP which\nassociates to each M \u2286 At, the least fixed point of TP,M . We will discuss the\noperator GLP and its proof-theoretic connections in section 4.2.\n\n3\n\nProof schemes and reduced defining equations\n\nIn this section we recall the notion of a proof scheme as defined in [MNR90a,\nMT93] and introduce a related notion of defining equations.\nGiven a propositional logic program P , a proof scheme is defined by induction on\nits length. Specifically, a proof scheme w.r.t. P (in short P -proof scheme) is a\nsequence S = hhC1 , p1 i, . . . , hCn , pn i, U i subject to the following conditions:\n(I) when n = 1, hhC1 , p1 i, U i is a P -proof scheme if C1 \u2208 P , p1 = head (C1 ),\nposBody (C1 ) = \u2205, and U = negBody(C1 ) and\n(II) when hhC1 , p1 i, . . . , hCn , pn i, U i is a P -proof scheme,\nC = p \u2190 posBody (C), \u00acnegBody (C) is a clause in the program P , and posBody (C) \u2286\n{p1 , . . . , pn }, then\nhhC1 , p1 i, . . . , hCn , pn i, hC, pi, U \u222a negBody (C)i\nis a P -proof scheme.\nWhen S = hhC1 , p1 i, . . . , hCn , pn i, U i is a P -proof scheme, then we call (i) the\ninteger n \u2013 the length of S, (ii) the set U \u2013 the support of S, and (iii) the atom pn\n\u2013 the conclusion of S. We denote U by supp(S).\nExample 3.1 Let P be a program consisting of four clauses: C1 = p \u2190, C2 =\nq \u2190 p, \u00acr, C3 = r \u2190 \u00acq, and C4 = s \u2190 \u00act. Then we have the following\nexamples of P -proof schemes:\n4\n\n\f(a) hhC1 , pi, \u2205i is a P -proof scheme of length 1 with conclusion p and empty\nsupport.\n(b) hhC1 , pi, hC2 , qi, {r}i is a P -proof scheme of length 2 with conclusion q and\nsupport {r}.\n(c) hhC1 , pi, hC3 , ri, {q}i is a P -proof scheme of length 2 with conclusion r and\nsupport {q}.\n(d) hhC1 , pi, hC2 , qi, hC3 , ri, {q, r}i is a P -proof scheme of length 3 with conclusion r and support {q, r}.\nProof scheme in (c) is an example of a proof scheme with unnecessary items (the\nfirst term). Proof scheme (d) is an example of a proof scheme which is not internally consistent in that r is in the support of its proof scheme and is also its\nconclusion.\n\u2737\nA P -proof scheme carries within itself its own applicability condition. In effect,\na P -proof scheme is a conditional proof of its conclusion. It becomes applicable\nwhen all the constraints collected in the support are satisfied. Formally, for any set\nof atoms M , we say that a P -proof scheme S is M -applicable if M \u2229supp(S) = \u2205.\nWe also say that M admits S if S is M -applicable.\nThe fundamental connection between proof schemes and stable models [MNR90a,\nMT93] is given by the following proposition.\nProposition 3.1 For every normal propositional program P and every set M of\natoms, M is a stable model of P if and only if the following conditions hold.\n(i) For every p \u2208 M , there is a P -proof scheme S with conclusion p such that\nM admits S.\n(ii) For every p \u2208\n/ M , there is no P -proof scheme S with conclusion p such that\nM admits S.\nProposition 3.1 says that the presence and absence of the atom p in a stable model\ndepends only on the supports of proof schemes. This fact naturally leads to a\ncharacterization of stable models in terms of propositional satisfiability. Given\np \u2208 At, the defining equation for p w.r.t. P is the following propositional formula:\np \u21d4 (\u00acU1 \u2228 \u00acU2 \u2228 . . .)\n\n(2)\n\nwhere hU1 , U2 , . . .i is the list of all supports of P -proof schemes. Here for any\nfinite set S = {s1 , . . . , sn } of atoms, \u00acS = \u00acs1 \u2227 * * * \u2227 \u00acsn . If p is not the\n5\n\n\fconclusion of any proof scheme, then we set the defining equation of p to be p \u21d4\n\u22a5. In the case, where all the supports of proof schemes of p are empty, we set\nthe defining equation of p to be p \u21d4 \u22a4. Up to a total ordering of the finite sets\nof atoms such a formula is unique. For example, suppose we fix a total order on\nAt, p1 < p2 < * * * . Then given two sets of atoms, U = {u1 < * * * < um } and\nV = {v1 < * * * < vn }, we say that U \u227a V , if either (i) um < vn , (ii) um = vn\nand m < n, or (iii) um = vn , n = m, and (u1 , . . . , un ) is lexicographically less\nthan (v1 , . . . , vn ). We say that (2) is the defining equation for p relative to P if\nU1 \u227a U2 \u227a * * * . We will denote the defining equation for p with respect to P by\nEq Pp .\nFor example, if P is a Horn program, then for every atom p, either the support of\nall its proof schemes are empty or p is not the conclusion of any proof scheme. The\nfirst of these alternatives occurs when p belongs to the least model of P , lm(P ).\nThe second alternative occurs when p \u2208\n/ lm(P ). The defining equations are p \u21d4 \u22a4\n(that is p) when p \u2208 lm(P ) and p \u21d4 \u22a5 (that is \u00acp) when p \u2208\n/ lm(P ). When P\nis a stratified program the defining equations are more complex, but the resulting\ntheory is logically equivalent to\n{p : p \u2208 Perf P } \u222a {\u00acp : p \u2208\n/ Perf P }\nwhere Perf P is the unique stable model of P .\nLet \u03a6P be the set {Eq Pp : p \u2208 At}. We then have the following consequence of\nProposition 3.1.\nProposition 3.2 Let P be a normal propositional program. Then stable models of\nP are precisely the propositional models of the theory \u03a6P .\nWhen P is purely negative, i.e. all clauses C of P have PosBody (C) = \u2205, the\nstable and supported models of P coincide [DK89] and the defining equations\nreduce to Clark's completion [Cl78] of P .\nLet us observe that in general the propositional formulas on the right-hand-side of\nthe defining equations may be infinite.\nExample 3.2 Let P be an infinite program consisting of clauses p \u2190 \u00acpi , for all\ni \u2208 n. In this case, the defining equation for p in P is infinite. That is, it is\np \u21d4 (\u00acp1 \u2228 \u00acp2 \u2228 \u00acp3 \u2228 . . .)\n\u2737\nThe following observation is quite useful. If U1 , U2 are two finite sets of propositional atoms then\nU1 \u2286 U2 if and only if \u00acU2 |= \u00acU1\n6\n\n\fHere |= is the propositional consequence relation. The effect of this observation is\nthat not all the supports of proof schemes are important, only the inclusion-minimal\nones.\nExample 3.3 Let P be an infinite program consisting of clauses p \u2190 \u00acp1 , . . . , \u00acpi ,\nfor all i \u2208 N . The defining equation for p in P is\np \u21d4 [\u00acp1 \u2228 (\u00acp1 \u2227 \u00acp2 ) \u2228 (\u00acp1 \u2227 \u00acp2 \u2227 \u00acp3 ) \u2228 . . . ]\nwhich is infinite. But our observation above implies that this formula is equivalent\nto the formula\np \u21d4 \u00acp1\n\u2737\nMotivated by the Example 3.3, we define the reduced defining equation for p relative to P to be the formula\np \u21d4 (\u00acU1 \u2228 \u00acU2 \u2228 . . .)\n\n(3)\n\nwhere Ui range over inclusion-minimal supports of P -proof schemes for the atom\np and U1 \u227a U2 \u227a * * * . Again, if p is not the conclusion of any proof scheme,\nthen we set the defining equation of p to be p \u21d4 \u22a5. In the case, where there is\na proof scheme of p with empty support, then we set the defining equation of p\nto be p \u21d4 \u22a4. We denote this formula as rEq Pp , and define r\u03a6P to be the theory\nconsisting of rEq Pp for all p \u2208 At. We then have the following strengthening of\nProposition 3.2.\nProposition 3.3 Let P be a normal propositional program. Then stable models of\nP are precisely the propositional models of the theory r\u03a6P .\nIn our example 3.3, the theory \u03a6P involved formulas with infinite disjunctions, but\nthe theory r\u03a6P contains only normal finite propositions.\nGiven a normal propositional program P , we say that P is a finite support program\n(FSP-program) if all the reduced defining equations for atoms with respect to P\nare finite propositional formulas. Equivalently, a program P is an FSP-program if\nfor every atom p there is only finitely many inclusion-minimal supports of P -proof\nschemes for p.\n\n4\n\nContinuity properties of operators and proof schemes\n\nIn this section we investigate continuity properties of operators and we will see that\none of those properties characterizes the class of FSP programs.\n7\n\n\f4.1 Continuity properties of monotone and antimonotone operators\nLet us recall that P(At) denotes the set of all subsets of At. We say that any\nfunction O : P(At) \u2192 P(At) is an operator on the set At of propositional atoms.\nAn operator O is monotone if for all sets X, Y \u2286 At, X \u2286 Y implies O(X) \u2286\nO(Y ). Likewise an operator O is antimonotone if for all sets X, Y \u2286 At, X \u2286 Y\nimplies O(Y ) \u2286 O(X). For a sequence hXn in\u2208N of sets of atoms, we say that\nhXn in\u2208N is monotonically increasing if for all i, j \u2208 N , i \u2264 j implies Xi \u2286 Xj\nand we say that hXn in\u2208N is monotonically decreasing if for all i, j \u2208 N , i \u2264 j\nimplies Xj \u2286 Xi .\nThere are four distinct classes of operators that we shall consider in this paper.\nFirst, we shall consider two types of monotone operators, upper-half continuous\nmonotone operators and lower-half continuous monotone operators. That is, we\nsay that a monotone operator O is upper-half\ncontinuous\nS\nS if for every monotonically increasing sequence hXn in\u2208N , O( n\u2208N Xn ) = n\u2208N O(Xn ). We say that\na monotone operator O is lower-half\nT continuousT if for every monotonically decreasing sequence hXn in\u2208N , O( n\u2208N Xn ) = n\u2208N O(Xn ). In the Logic Programming literature the first of these properties is called continuity. The classic\nresult due to van Emden and Kowalski is the following.\nProposition 4.1 For every Horn program P , the operator TP is upper-half continuous.\nIn general, the operator TP for Horn programs is not lower-half continuous. For\nexample, let P be the program consisting of the clauses p \u2190 pi for i \u2208 N . Then\nthe operator TP is not lower-half continuous.\nThat is, if Xi = {pi , pi+1 , . . .}, then\nT\nclearly p \u2208 TP (Xi ) for all i. However, i Xi = \u2205 and p 6\u2208 TP (\u2205).\nLower-half continuous monotone operators have appeared in the Logic Programming literature [Do94]. Even more generally, for a monotone operator O, let us\ndefine its dual operator Od as follows:\nOd (X) = At \\ O(At \\ X).\nThen an operator O is upper-half continuous if and only if Od is lower-half continuous [JT51]. Therefore, for any Horn program P , the operator TPd is lower-half\ncontinuous.\nIn case of antimonotone operators, we have two additional notions of continuity.\nWe say an antimonotone operator O is upper-half\ncontinuous\nS\nT if for every monotonically increasing sequence hXn in\u2208N , O( n\u2208N Xn ) = n\u2208N O(Xn ). Similarly,\nwe say an antimonotone operator O is lower-half\ncontinuous\nT\nS if for every monotonically decreasing sequence hXn in\u2208N , O( n\u2208N Xn ) = n\u2208N O(Xn ).\n8\n\n\f4.2 Gelfond-Lifschitz operator GLP and proof-schemes\nFor the completeness sake, let us recall that the Gelfond-Lifschitz operator for a\nprogram P which we denote GLP , assigns to a set of atoms M the least fixpoint\nof of the operator TP,M or, equivalently, the least model NM of the program PM\nwhich is the Gelfond-Lifschitz reduct of P via M [GL88]. The following fact is\ncrucial.\nProposition 4.2 ([GL88]) The operator GL is antimonotone.\nHere is a useful proof-theoretic characterization of the operator GLP .\nProposition 4.3 Let P be a normal propositional program and M be a set of\natoms. Then\nGLP (M ) = {p : there exists a P -proof scheme S such that M admits S,\nand p is the conclusion of S}\nProof: Let us assume that p \u2208 GLP (M )Sthat is p \u2208 NM . As NM is the least\nmodel of the Horn program PM , NM = n\u2208N TPnM (\u2205). Then it is easy to prove\nby induction on n, that if p \u2208 TPnM (\u2205), then there is a P -proof scheme Sp such\nthat p is the conclusion of Sp and Sp is admitted by M . Conversely, we can show,\nby induction on the length of the P -proof schemes, that whenever such P -proof\nscheme S is admitted by M , then p belongs to GLP (M ).\n\u2737\n\n4.3 Continuity properties of the operator GLP\nThis section will be devoted to proving results on the continuity properties of the\noperator GLP . First, we prove that for every program P , the operator GLP is\nlower-half continuous. We then show that if f is a lower-half continuous antimonotone operator, then f = GLP for a suitably chosen program P . Finally, we\nshow that the operator GLP is upper-half continuous if and only if P is an FSPprogram. That is, GLP is upper-half continuous if for all atoms p the reduced\ndefining equation for any p (w.r.t. P ) is finite.\nProposition 4.4 For every normal program P , the operator GLP is lower-half\ncontinuous.\nProof: We need to prove that for every program P and every monotonically decreasing sequence hXn in\u2208N ,\n\\\n[\nGLP (\nXn ) =\nGLP (Xn ).\nn\u2208N\n\nn\u2208N\n\n9\n\n\fOur goal is to prove two inclusions: \u2286, and \u2287.\nWe first show \u2287. Since\n\\\nXj \u2286 Xn\nj\u2208N\n\nfor every n \u2208 N , by antimonotonicity of GLP we have\n\\\nGLP (Xn ) \u2286 GLP (\nXj ).\nj\u2208N\n\nAs n is arbitrary,\n\n[\n\nGLP (Xn ) \u2286 GLP (\n\nn\u2208N\n\n\\\n\nXj ).\n\nj\u2208N\n\nThus the inclusion \u2287 holds.T\nConversely, let p \u2208 GLP ( n\u2208N Xn ). Then, by Proposition 4.3, there must be a\nproof scheme S with support support U and conclusion p such that\n\\\nU\u2229\nXn = \u2205.\nn\u2208N\n\nBut the family hXn in\u2208n is monotonically descending and the set U is finite. Thus\nthere is an integer n0 so that\nU \u2229 Xn0 = \u2205.\nThis, however, implies that p \u2208 GLP (Xn0 ), and thus\n[\np\u2208\nGLP (Xn ).\nn\u2208N\n\nS\nT\nAs p is arbitrary, the inclusion \u2286 holds. Thus GLP ( n\u2208N Xn ) = n\u2208N GLP (Xn ).\n\u2737\nThe lower-half continuity of antimonotone operators is closely related to programs,\nas shown in the following result.\nProposition 4.5 Let At be a denumerable set of atoms. Let f be an antimonotone\nand lower-half continuous operator on P(At). Then there exists a normal logic\nprogram P such that f = GLP .\nProof.\nWe define the program P = Pf as follows:\nP = {p \u2190 \u00acq1 , . . . , \u00acqi : p \u2208 f (At \\ {q1 , . . . , qi })}.\nWe claim that f = GLP , that is, for all X, f (X) = GLP (X).\n10\n\n\fLet X \u2286 At be given. We consider two cases.\nCase 1: X is cofinite, X = At \\ {q1 , . . . , qi }. We need to prove two inclusions,\n(a) f (X) \u2286 GLP (X) and (b) GLP (X) \u2286 f (X).\nFor (a), note that if p \u2208 f (X), then the clause p \u2190 \u00acq1 , . . . , \u00acqi belongs to P .\nHence p \u2190 belongs to PX and p \u2208 GLP (X).\nFor (b), note that if p \u2208 GLP (X), then given the form of the clauses in P , there\nmust be some clause p \u2190 \u00acqi1 , . . . , \u00acqij in P where {qi1 , . . . , qij } \u2286 {q1 , . . . , qi }.\nBut this means that p \u2208 f (At \\ {qi1 , . . . , qij }). Since f is antimonote and At \\\n{q1 , . . . , qi } \u2286 At \\ {qi1 , . . . , qij }, we must have\nf (At \\ {qi1 , . . . , qij }) \u2286 f (At \\ {q1 , . . . , qi }) = f (X)\nand, hence, p \u2208 f (X). Thus GLP (X) \u2286 f (X).\nCase 2: X is not cofinite. Let {q0 , q1 , . . .} be an enumeration of At \\ X. Let\nYi = At \\ {q0 , . . . , qi }. Then, clearly, X \u2286 Yi T\nfor all i \u2208 N . Moreover the sequence hYi ii\u2208N is monotonically decreasing and i\u2208N Yi = X. Therefore, by our\nassumptions on the operator f ,\n[\nf (X) =\nf (Yi ).\ni\u2208N\n\nAgain, we need to prove two inclusions, (a) f (X) \u2286 GLP (X) and (b) GLP (X) \u2286\nf (X). For (a), note that if p \u2208 f (X), then for some i \u2208 N , p \u2208 F (Yi ). Therefore,\nfor that i, p \u2190 \u00acq0 , . . . , \u00acqi is a clause in P . But then X \u2229 {q0 , . . . , qi } = \u2205 so\nthat the clause p \u2190 is in PX and p \u2208 GLP (X).\nFor the proof of (b), note that if p \u2208 GLP (X), then because of the syntactic form\nof the clauses in our program there are atoms r0 , . . . , rk so that the clause p \u2190\n\u00acr0 , . . . , \u00acrk belongs to the program P , and r0 , . . . , rk \u2208\n/ X. Thus {r0 , . . . , rk } \u2286\n{q0 , q1 , . . .} and, hence, for some i \u2208 N , {r0 , . . . , rk } \u2286 {q0 , . . . , qi }. Now, consider such a Yi . Since Yi is cofinite, it follows from Case 1 that f (Yi ) = GLP (Yi ).\nSince X \u2286 Yi , f (Yi ) \u2286 f (X) by the antimonotonicity of f . But p \u2208 GLP (Yi ) because r0 , . . . , rk \u2208\n/ Yi and, hence, p \u2208 f (Yi ). But since f (Yi ) \u2286 f (X), p \u2208 f (X)\nas desired.\n\u2737\nWe are now ready to prove the next result of this paper.\nProposition 4.6 Let P be a normal propositional program. The following are\nequivalent:\n(a) P is an FSP-program.\n11\n\n\f(b) The operator GLP is upper-half continuous, i.e.\n[\n\\\nGLP (\nXn ) =\nGLP (Xn )\nn\u2208N\n\nn\u2208N\n\nfor every monotonically increasing sequence hXn in\u2208N .\nProof: Two implications need to be proved: (a) \u21d2 (b), and (b) \u21d2 (a).\nProof of the implication (a) \u21d2 (b). Here, assuming (a), we need to prove two\ninclusions:\nS\nT\n(i) GL\n(\nX\n)\n\u2286\nGLP (Xn ), and\nP\nn\nn\u2208N\nn\u2208N S\nT\n(ii) n\u2208N GLP (Xn ) \u2286 GLP ( n\u2208N\nS Xn ).\nTo prove (i), note that since Xn \u2286 j\u2208N Xj , we have\n[\nGLP (\nXj ) \u2286 GLP (Xn ).\nj\u2208N\n\nAs n is arbitrary,\nGLP (\n\n[\n\n\\\n\nXj ) \u2286\n\nj\u2208N\n\nGLP (Xn ).\n\nn\u2208N\n\nThis proves (i).\nT\nTo prove (ii), let p \u2208 n\u2208N GLP (Xn ). Then, for every n \u2208 N , p \u2208 GLP (Xn )\nand so, for every n \u2208 N , there is an inclusion-minimal support U for p such that\nU \u2229 Xn = \u2205.\nBut by (a) there are only finitely many inclusion-minimal supports for P -proof\nschemes for p. Therefore there is a support of an inclusion minimal support of a\nproof scheme of p, U0 , such that for infinitely many n's\nU0 \u2229 Xn = \u2205.\nBut the sequence hXn in\u2208N is monotonically increasing. Therefore for all n \u2208 N ,\nU0 \u2229 Xn = \u2205. But then\n[\nU0 \u2229\nXn = \u2205,\nn\u2208N\n\nS\nso that p \u2208 GLP ( n\u2208N Xn ). Thus (ii) holds and the implication (a) \u21d2 (b) follows.\nTo prove that (b) \u21d2 (a), assume that the operator GLP is upper-half continuous.\nWe need to show that for every p, the reduced defining equation for p is finite.\nSo let us assume that rEq Pp is not finite. This means that there is an infinite set\nX = {U1 , U2 , . . .}, where U1 \u227a U2 \u227a * * * , such that\n12\n\n\f1. each Ui is finite,\n2. the elements of X are pairwise inclusion-incompatible, and\n3. for every set of atoms M , p \u2208 GLP (M ) if and only if for some Ui \u2208 X ,\nUi \u2229 M = \u2205.\nWe will now define two sequences:\n1. a sequence hKn in\u2208N of infinite sets of integers and\n2. a sequence hpn in\u2208N \\{0} of atoms.\nWe define K0 = N , and we define p1 as the first element of U1 such that\n{j : p \u2208\n/ Uj }\nis infinite. Clearly, K0 is well-defined. We need to show that p1 is well-defined.\nIf p1 is not well-defined, then for every p \u2208 U1 there is an integer ip such that for\nall m > ip , p \u2208 Um . But U1 is finite so taking n = maxp\u2208U1 ip , we find that for\nall m > n, U1 \u2286 Um - which contradicts the fact that the sets in X are pairwise\ninclusion-incompatible. Thus p1 is well-defined. We now set\nK1 = {n \u2208 K0 : p1 \u2208\n/ Un } = {n \u2208 K0 : {p1 } \u2229 Un = \u2205}.\nClearly. K1 is infinite.\nNow, let us assume that we already defined pl and Kl so that Kl = {n : Un \u2229\n{p1 , . . . , pl } = \u2205} is an infinite subset of N . We select pl+1 as the first element\np \u2208 Ul+1 so that\n{j : j \u2208 Kl and p \u2208\n/ Uj }\nis infinite. Clearly, by an argument as above, there is such p, and so pl+1 is welldefined. We then set\nKl+1 = {j \u2208 Kl : pl+1 \u2208\n/ Uj }.\nSince {p1 , . . . , pl } \u2229 Uj = \u2205 for all j \u2208 Kl , {p1 , . . . , pl+1 } \u2229 Uj = \u2205 for all\nj \u2208 Kl+1 . By construction, the set Kl+1 is infinite.\nNow, we complete the argument as follows. We set Xn = {p1 , . . . , pn }. The\nsequence hXn in\u2208N is monotonically increasing. For each n there is j (in fact\ninfinitely many\nT j's) so that Xn \u2229 Uj = \u2205. Therefore, for each n, p \u2208 GLP (Xn ).\nHence p \u2208 n\u2208N GLP (Xn ).S\nOn the other hand, let X = n\u2208N Xn . Then\nX = {p1 , p2 , ...}.\n13\n\n\fBy our construction, pn \u2208 Un , and so Un \u2229 X 6= \u2205. Therefore\nS X does not admit\nany P -proof scheme for p. Thus p \u2208\n/ GLP (X) = GLP ( n\u2208N Xn ). But this\nwould contradict our assumption that GLP is upper-half continuous. Thus there\ncan be no such p and hence P must be a FSP-program.\n\u2737\n\n5\n\nExtensions to CC -programs\n\nIn [SNS02] Niemel\u00e4 and coauthors defined a significant extension of logic programming with stable semantics which allows for programming with cardinality\nconstraints, and, more generally, with weight constraints. This extension has been\nfurther studied in [MR04, MNT07]. To keep things simple, we will limit our discussion to cardinality constraints only, although it is possible to extend our arguments to any class of convex constraints [LT05]. Cardinality constraints are\nexpressions of the form lXu, where l, u \u2208 N , l \u2264 u and X is a finite set of atoms.\nThe semantics of an atom lXu is that a set of atoms M satisfies kXl if and only if\nk \u2264 |M \u2229 X|. When l = 0, we do not write it, and, likewise, when u \u2265 |X|, we\nomit it, too. Thus an atom p has the same meaning as 1{p} while \u00acp has the same\nmeaning as {p}0.\nThe stable semantics for CC -programs is defined via fixpoints of an analogue of\nthe Gelfond-Lifschitz operator GLP ; see the details in [SNS02] and [MR04]. The\noperator in question is neither monotone nor antimonotone. But when we limit\nour attention to the programs P where clauses have the property that the head consists of a single atom (i.e. are of the form 1{p}), then one can define an operator\nCCGLP which is antimonotone and whose fixpoints are stable models of P . This\nis done as follows.\nGiven a clause C\np \u2190 l1 X1 u1 , . . . , lm Xm um ,\nwe transform it into the clause\np \u2190 l1 X1 , . . . , lm Xm , X1 u1 , . . . , Xm um\n\n(4)\n\n[MNT07]. We say that a clause C of the form (4) is a CC -Horn clause if it is of\nthe form\np \u2190 l1 X1 , . . . , lm Xm .\n(5)\nA CC -Horn program is a CC -program all of whose clauses are of the form (5). If\nP is a CC -Horn program, we can define the analogue of the one step provability\noperator TP by defining that for a set of atom M ,\nTP (M ) = {p : (\u2203C = p \u2190 l1 X1 , . . . , lm Xm )(\u2200i \u2208 {1, . . . m})(|Xi \u2229 M | \u2265 li )}\n(6)\n14\n\n\fIt is easy to see that TP is monotone operator that the least fixed point of TP is\ngiven by\n[\nlfp(TP ) =\nTPn (\u2205).\n(7)\nn\u22650\n\nWe can define the analogue of the Gelfond-Lifschitz reduct of a CC -program,\nwhich we call the NSS -reduct of P , as follows. Let P\u0304 denote the set of all transformed clauses derived from P . Given a set of atoms M , we eliminate from\nP\u0304 those clauses where some upper-constraint (Xi ui ) is not satisfied by M , i.e.\n|M \u2229 Xi | > ui . In the remaining clauses, the constraints of the form Xi ui are\neliminated altogether. This leaves us with a CC -Horn program PM . We then define CCGLP (M ) to be the least fixed point of TPM and say that M is a CC -stable\nmodel if M = CCGLP (M ). The equivalence of this construction and the original\nconstruction in [SNS02] for normal CC -programs is shown in [MNT07].\nNext we define the analogues of P -proof schemes for normal CC -programs, i.e.\nprograms which consists entirely of clauses of the form (4). This is done by induction as follows. When\nC = p \u2190 X1 u1 , . . . , Xk uk\nis a normal CC -clause without the cardinality-constraints of the form li Xi then\nhhC, pi, {X1 u1 , . . . , Xk uk }i\nis a P -CC -proof scheme with support {X1 u1 , . . . , Xk uk }. Likewise, when\nS = hhC1 , p1 i, . . . , hCn , pn i, U i\nis a P -CC -proof scheme,\np \u2190 l1 X1 , . . . , lm Xm , X1 u1 , . . . , Xm um\nis a clause in P , and |X1 \u2229 {p1 , . . . , pn }| \u2265 l1 , . . ., |Xm \u2229 {p1 , . . . , pn }| \u2265 lm ,\nthen\nhhC1 , p1 i, . . . , hCn , pn i, hC, pi, U \u222a {X1 u1 , . . . , Xm um }i\nis a P -CC -proof scheme with support U \u222a {X1 u1 , . . . Xm um }. The notion of admittance of a P -CC -proof scheme is similar to the notion of admittance of P -proof\nscheme for normal programs P . That is, if S = hhC1 , p1 i, . . . , hCn , pn i, hC, pi, U i\nis a CC -proof scheme with support U = {X1 u1 , . . . Xn un }, then S is admitted by\nM if for every Xi ui \u2208 U , M |= Xi ui , i.e. |M \u2229 Xi | \u2264 ui .\nSimilarly, we can associate a propositional formula \u03c6U so that M admits S if and\nonly if M |= \u03c6U as follows:\n\u03c6U =\n\nn\n^\n\n_\n\ni=1 W \u2286Xi ,|W |=|Xi|\u2212ui\n\n15\n\n\u00acW.\n\n(8)\n\n\fThen we can define a partial ordering on the set of possible supports of proof\nscheme by defining U1 \u0016 U2 \u21d0\u21d2 \u03c6U2 |= \u03c6U1 . For example if U1 = h{1, 2, 3}2,\n{4, 5, 6}2i and U2 = h{1, 2, 3, 4, 5, 6}, 4i, then\n\u03c6U1 = (\u00ac1 \u2228 \u00ac2 \u2228 \u00ac3) \u2227 (\u00ac4 \u2228 \u00ac5 \u2228 \u00ac6)\n_\n\u03c6U2 =\n(\u00aci \u2227 \u00acj).\n1\u2264i<j\u22646\n\nThen clearly \u03c6U1 |= \u03c6U2 so that U2 \u0016 U1 . We then define a normal propositional\nCC -program to be FPS CC -program if for each p \u2208 At, there are finitely many\n\u0016-minimal supports of P -CC -proof schemes with conclusion p.\nWe can also define analogue of the defining equation CCEqpP of p relative to a\nnormal CC -program P as\np \u21d4 (\u03c6U1 \u2228 \u03c6U2 \u2228 * * * )\n\n(9)\n\nwhere hU1 , U2 , . . .i is a list of supports of all P -CC -proofs schemes with conclusion p. Again up to a total ordering of possible finite supports, this formula is\nunique. Let \u03a6P be the set {CCEqpP : p \u2208 At}. Similarly, we define the reduced\ndefining equation for p relative to P to be the formula\np \u21d4 (\u00ac\u03c6U1 \u2228 \u00ac\u03c6U2 \u2228 . . .)\n\n(10)\n\nwhere Ui range over \u0016-minimal supports of P -CC -proof schemes for the atom p.\nThen we have the following analogues of Propositions 3.1 and 3.2.\nProposition 5.1 For every normal propositional CC -program P and every set M\nof atoms, M is a CC -stable model of P if and only if the following two conditions\nhold:\n(i) for every p \u2208 M , there is a P -CC -proof scheme S with conclusion p such\nthat M admits S and\n(ii) for every p \u2208\n/ M , there is no P -CC -proof scheme S with conclusion p such\nthat M admits S.\nProposition 5.2 Let P be a normal propositional CC -program. Then CC -stable\nmodels of P are precisely the propositional models of the theory \u03a6P .\nWe also can prove the analogues of Propositions 4.2 and 4.3.\nProposition 5.3 For any CC-program P , the operator CCGLP is antimonotone.\n16\n\n\fProof: It is easy to see that if M1 \u2286 M2 , then for any clause\nC = p \u2192 l1 X1 , . . . , lm Xm , X1 u1 , . . . Xm lm ,\nM2 |= Xi ui implies M1 |= Xi ui . Thus it follows that PM2 \u2286 PM1 and hence\nlfp(TPM2 ) \u2286 lfp(TPM1 ).\n\u2737\nProposition 5.4 Let P be a normal propositional CC -program and M be a set of\natoms. Then\nCCGLP (M ) = {p : there exists a P -proof scheme S such that M admits S,\nand p is the conclusion of S}\nProof: Let us assume that p \u2208 CCGLP (M ), i.e. p \u2208 lfp(TPM ). Since lfp(TPM ) =\nS\nn\nn\nn\u22651 TPM (\u2205), we can easily show by induction on n that if p \u2208 TPM (\u2205), then there\nis a P -CC -proof scheme Sp such p is the conclusion of Sp and Sp is admitted by\nM.\nConversely, we can show, by induction on the length of the P -CC -proof schemes,\nthat whenever there is P -CC -proof scheme S admitted by M , then p belongs to\nlfp(TPM ).\n\u2737\nNext we prove that analogue of Proposition 4.4.\nProposition 5.5 For every normal CC -program P , the operator CCGLP is lowerhalf continuous.\nProof: We need to prove that for every normal CC -program P and every monotonically decreasing sequence hXn in\u2208N\n[\n\\\nCCGLP (Xn ).\nXn ) =\nCCGLP (\nn\u2208N\n\nn\u2208N\n\nWe need to prove two inclusions: \u2286, and \u2287.\nWe first show \u2287. Since\n\\\nXj \u2286 Xn\nj\u2208N\n\nfor every n \u2208 N , it follows from the antimonotonicity of CCGLP that we have\n\\\nCCGLP (Xn ) \u2286 GLP (\nXj ).\nj\u2208N\n\nAs n is arbitrary,\n\n[\n\nCCGLP (Xn ) \u2286 CCGLP (\n\nn\u2208N\n\n\\\n\nj\u2208N\n\n17\n\nXj ).\n\n\fThus the inclusion \u2287 holds. T\nConversely, let p \u2208 CCGLP ( n\u2208N Xn ). Then, by Proposition 5.4, there must be a\nCC -proof scheme S with support support U = {Y1 u1 , . . . , Yn un } and conclusion\np such that\n\\\n|Yi \u2229\nXn | \u2264 ui for i = 1, . . . , n.\nn\u2208N\n\nSince the family hXn in\u2208n is monotonically descending, it follows that\nYi \u2229 X1 \u2287 Yi \u2229 X2 \u2287 * * * .\nT\nSince Yi is finite, it is the case that if |Yi \u2229 n\u2208N Xn | \u2264 ui , then there is some mi\nsuch that |Yi \u2229 Xmi | \u2264 ui . Hence if m = max(m1 , . . . , mn ), then\n|Yi \u2229 Xm | \u2264 ui for i = 1, . . . , n.\nThis, however, implies that p \u2208 CCGLP (Xm ), and thus\n[\np\u2208\nCCGLP (Xn ).\nn\u2208N\n\nT\nS\nAs p is arbitrary, the inclusion \u2286 holds. Thus CCGLP ( n\u2208N Xn ) = n\u2208N CCGLP (Xn ).\n\u2737\nNext we can prove the analogue of the first half of Proposition 4.6.\nProposition 5.6 Let P be a normal propositional CC -program. Then if P is an\nFSP-program, the operator CCGLP is upper-half continuous, i.e.\n[\n\\\nCCGLP (\nXn ) =\nCCGLP (Xn )\nn\u2208N\n\nn\u2208N\n\nfor every monotonically increasing sequence hXn in\u2208N .\nProof: Two implications need to be proved: (a) \u21d2 (b), and (b) \u21d2 (a).\nProof of the implication (a) \u21d2 (b). Here, assuming (a) we need to prove two\ninclusions:\nS\nT\n(i) GL\n(\nX\n)\n\u2286\nGLP (Xn ), and\nP\nn\nn\u2208N\nn\u2208N S\nT\n(ii) n\u2208N GLP (Xn ) \u2286 GLP ( n\u2208N\nS Xn ).\nTo prove (i), note that since Xn \u2286 j\u2208N Xj , we have\nCCGLP (\n\n[\n\nXj ) \u2286 CCGLP (Xn ).\n\nj\u2208N\n\n18\n\n\fAs n is arbitrary,\nCCGLP (\n\n[\n\nj\u2208N\n\n\\\n\nXj ) \u2286\n\nCCGLP (Xn ).\n\nn\u2208N\n\nThis proves (i).\nT\nTo prove (ii), let p \u2208 n\u2208N CCGLP (Xn ). Then, for every n \u2208 N , p \u2208 CCGLP (Xn )\n(n) (n)\n\n(n) (n)\n\nand so, for every n \u2208 N , there is a minimal support Un = {Y1 u1 , . . . , Ymn uMn }\nfor p such that\n(n)\n(n)\n|Yi \u2229 Xn | \u2264 ui for i = 1, . . . , mn .\nBut there are only finitely many \u0016-minimal supports for P -CC -proof schemes for\np. Therefore there is a support U0 = {Z1 w1 , . . . , Zt wt } for a P -CC -proof scheme\nwith conclusion p such that for infinitely many n's\n|Zi \u2229 Xn | \u2264 wi for i = 1, . . . , t.\nBut the sequence hXn in\u2208N is monotonically increasing. Therefore for all n \u2208 N ,\n|Zi \u2229 Xn | \u2264 wi for i = 1, . . . , t.\nBut since each Zi is finite, then it must be the case that\n[\n|Zi \u2229\nXn | \u2264 wi for i = 1, . . . , t.\nninN\n\nS\n\u2737\nso that p \u2208 CCGLP ( n\u2208N Xn ).\nWe note that, alternatively, one can easily give a direct reduction of our CC programs to normal logic programs using the methods of [FL05] and the distributivity result of [LTT99]. Such reduction, of course, lead to an exponential blow up\nin the size of the representation.\n\n6\n\nConclusions\n\nWe note that investigations of proof systems in a related area, SAT, play a key role\nin establishing lower bounds on the complexity of algorithms for finding the models. We wonder if there are analogous results in ASP. For achieving such a goal, we\nneed to find and investigate proof systems for ASP. One candidate for such a proof\nsystem is provided in this paper by using P -proof schemes. We wonder if such\na proof system can be used to develop a deeper understanding of the complexity\nissues related to finding stable models.\n\n19\n\n\fAcknowledgments\nThis research of the first author was supported by the National Science Foundation\nunder Grant IIS-0325063. This research of the second author was supported by the\nNational Science Foundation under Grant DMS 0654060.\n\nReferences\n[Ap90]\n\nApt, K.. Logic programming, In: J. van Leeuven, ed, Handbook of\nTheoretical Computer Science, pages 493\u2013574, MIT Press, 1990.\n\n[Bo04]\n\nBonatti, P.A. Reasoning with infinite stable models. Artificial Intelligence 156:75\u2013111, 2004.\n\n[BTK93]\n\nBondarenko, A., Toni, F. and Kowalski, R.A., An Assumption-Based\nFramework for Non-Monotonic Reasoning. Proceedings of LPNMR93, MIT Press, pages 171\u2013189, 1993.\n\n[Cl78]\n\nClark, K. Negation as failure. In Logic and data bases, H. Gallaire\nand J. Minker, Eds. Plenum Press, pages 293\u2013322, 1978.\n\n[DP92]\n\nDavey, B.A., and Priestley, H.A., Introduction to Lattices and Order,\nCambridge University Press, 1992.\n\n[DK89]\n\nDung, P.M. and Kanchanasut, K., On the generalized predicate completion of non-Horn programs, Logic programming. Proceedings of\nthe North American Conference, 1989.\n\n[Do94]\n\nDoets, K., From Logic to Logic Programming, MIT Press, 1994.\n\n[FL05]\n\nFerraris, P., and Lifschitz, V., Weight constraints as nested expressions, Theory and Practice of Logic Programming, 5:45-74, 2005.\n\n[FLL06]\n\nFerraris, P., Lee, J. and Lifschitz, V. A generalization of Lin-Zhao\ntheorem. Annals of Mathematics and Artificial Intelligence 47:79\u2013\n101, 2006.\n\n[GS07]\n\nGebser, M. and Schaub, T., Generic Tableaux for Answer Set Programming, Proceedings of International Conference on Logic Programming, 2007, pages 119\u2013133, 2007.\n\n[GL88]\n\nGelfond, M. and Lifschitz, V. The stable model semantics for logic\nprogramming. In Proceedings. of the International Joint Conference\nand Symposium on Logic Programming, pages 1070\u20131080, 1988.\n20\n\n\f[JT51]\n\nJonsson, B. and Tarski, A. Boolean Algebras with Operators. American Journal of Mathematics 73:891\u2013939, 1951.\n\n[JO07]\n\nJ\u00e4rvisalo, M. and Oikarinen, E., Extended ASP Tableaux and Rule\nRedundancy in Normal Logic Programs, Proceedings of International Conference on Logic Programming, 2007 pages 134\u2013148,\n2007.\n\n[LT05]\n\nLiu, L. and Truszczy\u0144ski, M., Properties of programs with monotone\nand convex constraints, Proceedings of the 20th National Conference\non Artificial Intelligence, pages 701-706, 2005.\n\n[Li96]\n\nLifschitz, V., Foundations of logic programming, in Principles of\nKnowledge Representation, CSLI Publications, pages 69-127, 1996.\n\n[LR06]\n\nV. Lifschitz and A. Razborov. Why are there so many loop formulas.\nAnnals of Mathematics and Artificial Intelligence 7:261\u2013268, 2006.\n\n[LTT99]\n\nV. Lifschitz, L. R. Tang and H. Turner. Nested expressions in logic\nprograms, Annals of Mathematics and Artificial Intelligence, 25:369389, 1999.\n\n[LZ02]\n\nF. Lin and Y. Zhao. ASSAT: Computing answer sets of a logic program by SAT solvers. Proceedings of AAAI 2002, pages 112\u2013117.\n2002\n\n[L89]\n\nJ. Lloyd, Foundations of Logic Programming, Springer-Verlag, 1989.\n\n[MNR90a]\n\nMarek, W., Nerode, A., and Remmel, J.B., Nonmonotonic Rule Systems I. Annals of Mathematics and Artificial Intelligence, 1:241\u2013273,\n1990.\n\n[MNR90b]\n\nMarek, W., Nerode, A., and Remmel, J.B., Nonmonotonic Rule Systems II. Annals of Mathematics and Artificial Intelligence, 5:229264, 1992.\n\n[MNR91]\n\nMarek, W., Nerode, A., and Remmel, J.B., A Context for Belief Revision: Normal Logic Programs (Extended Abstract) Proceedings,\nWorkshop on Defeasible Reasoning and Constraint Solving, International Logic Programming Symposium, San Diego, CA., 1991.\n\n[MNR92]\n\nMarek, W., Nerode, A., and Remmel, J.B., How Complicated is\nthe Set of Stable Models of a Logic Program? Annals of Pure and\nApplied Logic, 56:119-136, 1992.\n21\n\n\f[MNR94a]\n\nMarek, W., Nerode, A., and Remmel, J.B., The stable models of\npredicate logic programs. Journal of Logic Programming 21:129154, 1994.\n\n[MNR94b]\n\nMarek, W., Nerode, A., and Remmel, J.B., Context for belief revision: Forward chaining-normal nonmonotonic rule systems, Annals\nof Pure and Applied Logic 67:269-324, 1994.\n\n[MNR94]\n\nMarek, W., Nerode, A., and Remmel, J.B., The stable models of\npredicate logic programs. Journal of Logic Programming 21:129154, 1994.\n\n[MNT07]\n\nMarek, V.W., Niemel\u00e4, I. and Truszczynski, M. Logic programs with\nmonotone abstract constraint atoms, Theory and Practice of Logic\nProgramming, 8:167\u2013199, 2008.\n\n[MR04]\n\nMarek, V.W. and Remmel, J.B. Set Constraints in Logic Programming. In Logic Programming and Nonmonotonic Reasoning, Proceedings of the 7th International Conference (LPNMR-04). LNAI\n2923, pages 154\u2013167, Springer-Verlag, 2004.\n\n[MR09]\n\nMarek, V.W. and Remmel, J.B. Guarded resolution and Answer Set\nProgramming, Unpublished manuscript, 2009.\n\n[MT93]\n\nMarek, W. and Truszczy\u0144ski, M. Nonmonotonic Logic, SpringerVerlag, Berlin, 1993.\n\n[Mi05]\n\nMilnikel, R.S., Sequent Calculi for Skeptical Reasoning in Predicate\nDefault Logic and Other Nonmonotonic Systems, Annals of Mathematics and Artificial Intelligence 44:1-34, 2005.\n\n[SNS02]\n\nSimons, P., Niemel\u00e4, I., and Soininen, T. 2002. Extending and implementing the stable model semantics. Artificial Intelligence 138:181\u2013\n234, 2002.\n\n22\n\n\f"}