{"id": "http://arxiv.org/abs/0710.5794v2", "guidislink": true, "updated": "2019-01-21T18:29:12Z", "updated_parsed": [2019, 1, 21, 18, 29, 12, 0, 21, 0], "published": "2007-10-31T02:11:05Z", "published_parsed": [2007, 10, 31, 2, 11, 5, 2, 304, 0], "title": "Quantum Algorithms for Evaluating MIN-MAX Trees", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0710.4190%2C0710.4157%2C0710.4586%2C0710.5716%2C0710.0644%2C0710.4544%2C0710.5718%2C0710.1319%2C0710.5242%2C0710.2436%2C0710.1803%2C0710.0192%2C0710.3950%2C0710.3076%2C0710.5440%2C0710.2887%2C0710.0823%2C0710.2438%2C0710.2170%2C0710.3691%2C0710.5668%2C0710.5462%2C0710.3873%2C0710.4487%2C0710.4282%2C0710.0241%2C0710.1792%2C0710.2929%2C0710.4683%2C0710.3048%2C0710.4562%2C0710.5589%2C0710.1021%2C0710.4403%2C0710.2229%2C0710.0272%2C0710.1682%2C0710.5829%2C0710.5389%2C0710.1200%2C0710.4416%2C0710.0428%2C0710.4937%2C0710.3061%2C0710.5909%2C0710.0497%2C0710.2828%2C0710.5142%2C0710.2252%2C0710.5536%2C0710.4837%2C0710.3450%2C0710.4449%2C0710.4478%2C0710.5794%2C0710.2470%2C0710.0483%2C0710.5066%2C0710.2260%2C0710.4510%2C0710.0691%2C0710.1984%2C0710.5391%2C0710.3694%2C0710.3272%2C0710.1922%2C0710.0304%2C0710.5433%2C0710.5343%2C0710.1099%2C0710.2650%2C0710.1551%2C0710.4090%2C0710.1878%2C0710.4652%2C0710.1199%2C0710.1867%2C0710.3994%2C0710.1925%2C0710.1751%2C0710.4821%2C0710.2655%2C0710.1955%2C0710.2272%2C0710.4998%2C0710.0140%2C0710.0333%2C0710.3903%2C0710.4258%2C0710.4254%2C0710.2392%2C0710.2839%2C0710.1786%2C0710.3030%2C0710.2365%2C0710.0422%2C0710.0937%2C0710.3086%2C0710.0363%2C0710.5314%2C0710.5007&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Quantum Algorithms for Evaluating MIN-MAX Trees"}, "summary": "We present a bounded-error quantum algorithm for evaluating Min-Max trees.\nFor a tree of size N our algorithm makes N^{1/2+o(1)} comparison queries, which\nis close to the optimal complexity for this problem.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0710.4190%2C0710.4157%2C0710.4586%2C0710.5716%2C0710.0644%2C0710.4544%2C0710.5718%2C0710.1319%2C0710.5242%2C0710.2436%2C0710.1803%2C0710.0192%2C0710.3950%2C0710.3076%2C0710.5440%2C0710.2887%2C0710.0823%2C0710.2438%2C0710.2170%2C0710.3691%2C0710.5668%2C0710.5462%2C0710.3873%2C0710.4487%2C0710.4282%2C0710.0241%2C0710.1792%2C0710.2929%2C0710.4683%2C0710.3048%2C0710.4562%2C0710.5589%2C0710.1021%2C0710.4403%2C0710.2229%2C0710.0272%2C0710.1682%2C0710.5829%2C0710.5389%2C0710.1200%2C0710.4416%2C0710.0428%2C0710.4937%2C0710.3061%2C0710.5909%2C0710.0497%2C0710.2828%2C0710.5142%2C0710.2252%2C0710.5536%2C0710.4837%2C0710.3450%2C0710.4449%2C0710.4478%2C0710.5794%2C0710.2470%2C0710.0483%2C0710.5066%2C0710.2260%2C0710.4510%2C0710.0691%2C0710.1984%2C0710.5391%2C0710.3694%2C0710.3272%2C0710.1922%2C0710.0304%2C0710.5433%2C0710.5343%2C0710.1099%2C0710.2650%2C0710.1551%2C0710.4090%2C0710.1878%2C0710.4652%2C0710.1199%2C0710.1867%2C0710.3994%2C0710.1925%2C0710.1751%2C0710.4821%2C0710.2655%2C0710.1955%2C0710.2272%2C0710.4998%2C0710.0140%2C0710.0333%2C0710.3903%2C0710.4258%2C0710.4254%2C0710.2392%2C0710.2839%2C0710.1786%2C0710.3030%2C0710.2365%2C0710.0422%2C0710.0937%2C0710.3086%2C0710.0363%2C0710.5314%2C0710.5007&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a bounded-error quantum algorithm for evaluating Min-Max trees.\nFor a tree of size N our algorithm makes N^{1/2+o(1)} comparison queries, which\nis close to the optimal complexity for this problem."}, "authors": ["Richard Cleve", "Dmitry Gavinsky", "David L. Yonge-Mallo"], "author_detail": {"name": "David L. Yonge-Mallo"}, "author": "David L. Yonge-Mallo", "arxiv_comment": "Re-submitted due to name change. Besides the name of one of the\n  authors, this version is identical to that of 31 Oct 2007: in particular,\n  some of the authors' affiliations and the references given in the document\n  are outdated", "links": [{"href": "http://arxiv.org/abs/0710.5794v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0710.5794v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0710.5794v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0710.5794v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:0710.5794v2 [quant-ph] 21 Jan 2019\n\nQuantum Algorithms for\nEvaluating MIN-MAX Trees\nRichard Cleve\u2217\u2020\n\nDmitry Gavinsky\u2217\n\nDavid L. Yonge-Mallo\u2217\n\n31 Oct 2007\nAbstract\nWe present a bounded-error quantum algorithm for evaluating Min-Max trees with\n1\nN 2 +o(1) queries, where N is the size of the tree and where the allowable queries are\ncomparisons of the form [xj < xk ]. This is close to tight, since there is a known quantum\n1\nlower bound of \u03a9(N 2 ).\n\nA Min-Max tree is a tree whose internal nodes are minimum and maximum gates, at alternating levels, and whose leaves are values from some underlying ordered set. The size N of\nsuch a tree the number of its leaves, whose values are referred to as x1 , . . . , xN . The value of a\nMin-Max tree is the value of its root, a function of x1 , . . . , xN . In the input value query model,\nqueries explicitly access the values of the leaves. In the comparison query model, the values of\nx1 , . . . , xN are not directly accessible; rather, queries are comparisons of the form [xj < xk ]. In\nthis latter model, the appropriate output is any j \u2208 {1, . . . , N} such that xj is the value of the\ntree.\nNote that, when the ordered set is {0, 1}, a Min-Max tree reduces to an And-Or tree. This\n1\nimplies that Barnum and Saks's lower bound of \u03a9(N 2 ) [2] for the quantum query complexity\nof And-Or trees applies to Min-Max trees.\nRecent results initiated by Farhi et al. have shown that quantum algorithms can evaluate\n1\nall And-Or trees with order N 2 +o(1) queries [8, 5, 6, 1]. We show that these results carry over\nto Min-Max trees in both the input value model and the comparison model.\nLet W (N) be the query complexity for And-Or trees of size N. We show that Min-Max\ntrees can be evaluated with O(W (N) log(N)) queries in both the input value model and the\ncomparison model. Our algorithm combines the results on And-Or trees in Refs. [1, 6] with\nthe lemma below and Grover's search algorithm [9].\nLemma 1 Let T be a Min-Max tree with inputs x1 , x2 , . . . , xN . Let T v be an And-Or tree\nwith identical structure to T , but with And and Or gates in place of Min and Max gates\n(respectively), and with the k th input assigned to 1 if and only if xk \u2265 v. Then value(T v ) = 1\nif and only if value(T ) \u2265 v.\n\u2217\n\nDavid R. Cheriton School of Computer Science and Institute for Quantum Computing, University of Waterloo.\n\u2020\nPerimeter Institute, Waterloo, Ontario, Canada.\n\n1\n\n\fLemma 1 is easy to prove by induction. It implies that, if the underlying ordered set is\na numerical range of size N O(1) , then the tree can be evaluated in log(N) stages by a simple\nbinary search. Each stage can be implemented with O(W (N) log log(N)) queries, which reflects\nthe cost of evaluating an And-Or tree amplified so that its error probability is O(1/ log(N)).\nThe result is an O(W (N) log(N) log log(N)) query algorithm.\nA complication arises in performing such a binary search in the comparison model, where it\nis not possible to directly compute the midpoint of an interval like [xj , xk ]. Problems can also\narise in the input value model when the numerical range is too large: the binary search may\nnot converge in a logarithmic number of steps. For this reason, we avoid the standard binary\nsearch approach where a midpoint is chosen as a pivot. Instead, we take a random input value\namong those that that lie within a current interval as our pivot. What is noteworthy about\nthis simple approach is that it does not work efficiently in the classical case: given an interval\n[xj , xk ], finding an interior point is as hard as searching, which can cost \u03a9(N) queries to do even\nonce [3]. In the\u221asetting of quantum algorithms, we can utilize Grover's search algorithm [9, 4]\nwhich costs O( N ).\nAs an aside, we note that there is a classical reduction from Min-Max trees to And-Or\ntrees that yields an O(N 0.753 ) query algorithm for balanced Min-Max trees [10]. We can use\n1\nthat reduction with an N 2 query quantum algorithm for balanced And-Or trees; however,\nthe resulting algorithm for Min-Max costs \u03a9(N 0.58 ). Our alternate approach yields exponent\n1\n+ o(1) and is not restricted to balanced trees.\n2\nWhat follows is a description of our algorithm with the analysis of its error. For convenience,\nlet \u22a5 and \u22a4 be such that x\u22a5 < xj and x\u22a4 > xj for any j \u2208 {1, . . . , N} and let c be a constant.\nQuantum Min-Max tree evaluation\n1. Let \u03b3 \u2190 \u22a5 and \u03b4 \u2190 \u22a4, and initialize the stack.\n2. Repeat the following steps for c log(N) iterations, then go to Step 3:\n(a) Find a random pivot:\nCall the quantum search subroutine to find a random pivot index j with x\u03b3 < xj <\nx\u03b4 . If no value is found, go to Step 2(c).\n(b) Refine the search:\nCall the And-Or tree subroutine to check if value(T ) < xj . If so, let \u03b4 \u2190 j;\notherwise, let \u03b3 \u2190 j.\n\n(c) Backtrack if out of range:\nCall the And-Or subroutine to check if x\u03b3 \u2264 value(T ) < x\u03b4 . If so, push (\u03b3, \u03b4) onto\nthe stack. Otherwise, pop (\u03b3, \u03b4) off the stack. (If the stack is empty, let \u03b3 \u2190 \u22a5 and\n\u03b4 \u2190 \u22a4.)\n\n3. Return \u03b3 as an index corresponding to the value of the Min-Max tree.\nClearly, the algorithm makes O(W (N) log(N)) queries. We claim the following.\nTheorem 1 The algorithm returns the value of the Min-Max tree with probability at least 23 .\n2\n\n\fTo prove Theorem 1, we must consider the progress made by the random choices of pivots\nas well as the error probabilities of the subroutines for And-Or and the searches (each errs\nwith constant probability).\nTo begin with, assume that the subroutines for And-Or and search never err (thus, x\u03b3 \u2264\nvalue(T ) < x\u03b4 at all times). Under this assumption, the progress of the algorithm is determined\nby how quickly the subinterval converges. Once no value in Step 2(a) is found the algorithm\nhas converged (with x\u03b3 = value(T )) and can go to Step 3 and terminate (however it is harmless\nto perform more iterations before doing this).\nLet C(m) denote the expected number of iterations of the algorithm until it converges,\nassuming that m of its inputs are within its current range.\nThen, for m > 1, C(m) satisfies the recurrence\n\uf8eb\n\uf8f6\nm\u22121\nX\n2 \uf8ed\nC(m) \u2264\nC(k)\uf8f8 + 1.\n(1)\nm\nk=\u230am/2\u230b\n\nThis can be seen by assuming that the pivot is uniformly selected among all m possible positions within the subinterval and that value(T ) always lies in the larger side of the pivot.\nIt is straightforward to verify that the recurrence implies C(m) \u2208 O(log(m)). Therefore, the\nexpected number of iterations of Step 2 made by the algorithm before x\u03b3 = value(T ), under\nthe assumption that the subroutines never err, is O(log(N)). By the Markov bound, O(log(N))\niterations suffice to obtain error probability less than any particular constant.\nWe now consider the fact that the subroutines for And-Or and searching can fail. First,\nnote that, by incurring a multiplicative factor of only O(log log(N)), each call to the And-Or\nand search algorithm can be amplified so that its error probability is O(1/ log(N)). This results\nin an O(W (N) log(N) log log(N)) algorithm for Min-Max.\nThese amplification costs are not necessary in our algorithm, since it can cope with a\nconstant fraction of errors in subroutine calls. To see why this is so, let \u03b5 be the probability\nthat one or more subroutines err during one iteration of Step 2 of the algorithm. The algorithm\nbegins some O(log(N)) steps away from reaching a good state - of the form (\u03b3 \u2032 , \u03b4) such that\nx\u03b3 \u2032 = value(T ). Before reaching a good state, an \"incorrect\" step for the algorithm places\nvalue(T ) outside the search interval, and a \"correct\" step either narrows the search interval\nor backtracks from a previous error. After reaching a good state, a \"correct\" step pushes a\npair of the form (\u03b3 \u2032 , \u03b4) onto the stack and an \"incorrect\" step pops it off. In each iteration,\nthe algorithm takes a correct step with probability at least 1 \u2212 \u03b5 and an incorrect step with\nprobability at most \u03b5. Therefore, with all but exponentially small probability, the number of\ncorrect steps minus the number of incorrect ones after c log(N) iterations is at least 2c log(N).\nFor suitably large c this means that, with constant probability, when the algorithm terminates,\nx\u03b3 = value(T ) (typically with many copies of pairs of the form (\u03b3 \u2032 , \u03b4) on the top of its stack).\nFinally, we note that, in game-playing contexts, it is useful to determine optimal moves.\nThis corresponds to finding the subtree of a Min-Max tree that attains its value. If the leaf\nvalues x1 , . . . , xN are distinct, this is easily deduced from value(T ). Otherwise, one can use a\nslightly modified version of the minimum/maximum finding algorithm in Ref. [7] to find the\nappropriate subtree.\n\n3\n\n\fAcknowledgements\nWe would like to thank Peter van Beek, Peter H\u00f8yer and Pascal Poupart for helpful discussions.\nThis research was supported in part by Canada's NSERC, CIAR, MITACS, QuantumWorks,\nand the U.S. ARO/DTO.\n\nReferences\n[1] A. Ambainis. A nearly optimal discrete query quantum algorithm for evaluating NAND\nformulas. arXiv:quant-ph/0704.3628.\n[2] H. Barnum and M. Saks. A lower bound on the query complexity of read-once functions.\nJournal of Computer and System Science, 69(2):244\u2013258, 2004.\n[3] C.H. Bennett, E. Bernstein, G. Brassard, and U. Vazirani. Strengths and weaknesses of\nquantum computing. SIAM Journal on Computing, 26(5):1510\u20131523, 1997.\n[4] M. Boyer, G. Brassard, P. H\u00f8yer and A. Tapp. Tight bounds on quantum searching.\nFortschritte Der Physik, 46(4\u20135):493\u2013505, 1998.\n[5] A.M. Childs, R. Cleve, S.P. Jordan and D.L. Yeung. Discrete-query quantum algorithm\nfor NAND trees. arXiv:quant-ph/0702160.\n[6] A.M. Childs, B.W. Reichardt, R. \u0160palek and S. Zhang. Every NAND formula on N\n1\nvariables can be evaluated in time O(N 2 +\u03b5 ). arXiv:quant-ph/0703015.\n[7] C. D\u00fcrr and P. H\u00f8yer.\narXiv:quant-ph/9607014.\n\nA quantum algorithm for finding the minimum.\n\n[8] E. Farhi, J. Goldstone and S. Gutmann. A Quantum Algorithm for the Hamiltonian\nNAND Tree. arXiv:quant-ph/0702144.\n[9] L.K. Grover. A fast quantum mechanical algorithm for database search. In Proceedings of\nthe 28th Annual ACM Symposium on Theory of Computing (STOC 1996), pages 212\u2013219,\n1996.\n[10] M. Saks and A. Wigderson. Probabilistic Boolean Decision Trees and the Complexity of\nEvaluating Game Trees. In Proceedings of the 27th Annual IEEE Symposium on Foundations of Computer Science (FOCS 1986), pages 29\u201338, 1986.\n\n4\n\n\f"}