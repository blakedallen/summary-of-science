{"id": "http://arxiv.org/abs/cs/0607006v1", "guidislink": true, "updated": "2006-07-02T17:16:37Z", "updated_parsed": [2006, 7, 2, 17, 16, 37, 6, 183, 0], "published": "2006-07-02T17:16:37Z", "published_parsed": [2006, 7, 2, 17, 16, 37, 6, 183, 0], "title": "Applying and Combining Three Different Aspect Mining Techniques", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Applying and Combining Three Different Aspect Mining Techniques"}, "summary": "Understanding a software system at source-code level requires understanding\nthe different concerns that it addresses, which in turn requires a way to\nidentify these concerns in the source code. Whereas some concerns are\nexplicitly represented by program entities (like classes, methods and\nvariables) and thus are easy to identify, crosscutting concerns are not\ncaptured by a single program entity but are scattered over many program\nentities and are tangled with the other concerns. Because of their crosscutting\nnature, such crosscutting concerns are difficult to identify, and reduce the\nunderstandability of the system as a whole.\n  In this paper, we report on a combined experiment in which we try to identify\ncrosscutting concerns in the JHotDraw framework automatically. We first apply\nthree independently developed aspect mining techniques to JHotDraw and evaluate\nand compare their results. Based on this analysis, we present three interesting\ncombinations of these three techniques, and show how these combinations provide\na more complete coverage of the detected concerns as compared to the original\ntechniques individually. Our results are a first step towards improving the\nunderstandability of a system that contains crosscutting concerns, and can be\nused as a basis for refactoring the identified crosscutting concerns into\naspects.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Understanding a software system at source-code level requires understanding\nthe different concerns that it addresses, which in turn requires a way to\nidentify these concerns in the source code. Whereas some concerns are\nexplicitly represented by program entities (like classes, methods and\nvariables) and thus are easy to identify, crosscutting concerns are not\ncaptured by a single program entity but are scattered over many program\nentities and are tangled with the other concerns. Because of their crosscutting\nnature, such crosscutting concerns are difficult to identify, and reduce the\nunderstandability of the system as a whole.\n  In this paper, we report on a combined experiment in which we try to identify\ncrosscutting concerns in the JHotDraw framework automatically. We first apply\nthree independently developed aspect mining techniques to JHotDraw and evaluate\nand compare their results. Based on this analysis, we present three interesting\ncombinations of these three techniques, and show how these combinations provide\na more complete coverage of the detected concerns as compared to the original\ntechniques individually. Our results are a first step towards improving the\nunderstandability of a system that contains crosscutting concerns, and can be\nused as a basis for refactoring the identified crosscutting concerns into\naspects."}, "authors": ["Mariano Ceccato", "Marius Marin", "Kim Mens", "Leon Moonen", "Paolo Tonella", "Tom Tourwe"], "author_detail": {"name": "Tom Tourwe"}, "author": "Tom Tourwe", "arxiv_comment": "28 pages", "links": [{"href": "http://arxiv.org/abs/cs/0607006v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0607006v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0607006v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0607006v1", "journal_reference": null, "doi": null, "fulltext": "Delft University of Technology\nSoftware Engineering Research Group\nTechnical Report Series\n\nApplying and Combining Three Different\nAspect Mining Techniques\nM. Ceccato, M. Marin, K. Mens, L. Moonen,\nP. Tonella, and T. Tourw\u00e9\n\nReport TUD-SERG-2006-002\n\nSERG\n\n\fTUD-SERG-2006-002\nPublished, produced and distributed by:\nSoftware Engineering Research Group\nDepartment of Software Technology\nFaculty of Electrical Engineering, Mathematics and Computer Science\nDelft University of Technology\nMekelweg 4\n2628 CD Delft\nThe Netherlands\nISSN 1872-5392\nSoftware Engineering Research Group Technical Reports:\nhttp://www.se.ewi.tudelft.nl/techreports/\nFor more information about the Software Engineering Research Group:\nhttp://www.se.ewi.tudelft.nl/\n\nc copyright 2006, Software Engineering Research Group, Department of Software Technology, Faculty\nof Electrical Engineering, Mathematics and Computer Science, Delft University of Technology. All rights\nreserved. No part of this series may be reproduced in any form or by any means without prior written\npermission of the publisher.\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nApplying and Combining Three Different\nAspect Mining Techniques\nM. Ceccato1 , M. Marin2 , K. Mens3 , L. Moonen2,4 , P. Tonella1 , and T. Tourw\u00e94\n1\n\nITC-irst, Trento, Italy\nDelft University, The Netherlands\n3\nUniversit\u00e9 catholique de Louvain, Belgium\n4\nCWI, The Netherlands\nceccato@itc.it, a.m.marin@ewi.tudelft.nl, kim.mens@uclouvain.be,\nleon.moonen@computer.org, tonella@itc.it, tom.tourwe@cwi.nl\n2\n\nAbstract. Understanding a software system at source-code level requires understanding the different concerns that it addresses, which in\nturn requires a way to identify these concerns in the source code. Whereas\nsome concerns are explicitly represented by program entities (like classes,\nmethods and variables) and thus are easy to identify, crosscutting concerns are not captured by a single program entity but are scattered over\nmany program entities and are tangled with the other concerns. Because\nof their crosscutting nature, such crosscutting concerns are difficult to\nidentify, and reduce the understandability of the system as a whole.\nIn this paper, we report on a combined experiment in which we try to\nidentify crosscutting concerns in the JHotDraw framework automatically.\nWe first apply three independently developed aspect mining techniques\nto JHotDraw and evaluate and compare their results. Based on this analysis, we present three interesting combinations of these three techniques,\nand show how these combinations provide a more complete coverage of\nthe detected concerns as compared to the original techniques individually. Our results are a first step towards improving the understandability\nof a system that contains crosscutting concerns, and can be used as a\nbasis for refactoring the identified crosscutting concerns into aspects.\n\n1\n\nIntroduction\n\nThe increasing popularity of aspect-oriented software development (AOSD) is\nlargely due to the fact that it recognises that some concerns cannot be captured\nadequately using the abstraction mechanisms provided by traditional programming languages. Several examples of such crosscutting concerns have been identified, ranging from simple ones such as logging, to more complex ones such as\ntransaction management [1] and exception handling [2, 3].\nAn important problem with such crosscutting concerns is that they affect the\nunderstandability of the software system, and as a result reduce its evolvability\nand maintainability. First of all, crosscutting concerns are difficult to understand,\nbecause their implementation can be scattered over many different packages,\n\nTUD-SERG-2006-002\n\n1\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nII\n\nclasses and methods. Second, in the presence of crosscutting concerns, ordinary\nconcerns become harder to understand as well, because they get tangled with\nthe crosscutting ones: particular classes and methods do not only deal with the\nprimary concern they address, but also may need to take into account some\nsecondary, crosscutting concerns.\nSeveral authors have presented automated code mining techniques, generally\nreferred to as aspect mining techniques, that are able to identify crosscutting\nconcerns in the source code [4]. The goal of these techniques is to provide an\noverview of the source-code entities that play a role in a particular crosscutting concern. This not only improves the understandability of the concern in\nparticular and of the software in general, but also provides a first step in the\nmigration towards applying aspect-oriented software development techniques.\nHowever, since the research field is still in its infancy, very few experiments have\nbeen conducted on real-world case studies, comparisons of different techniques\nare lacking, and no agreed-upon benchmark is available that allows to evaluate\nthe existing techniques.\nThis paper reports on an experiment involving three independently developed aspect mining techniques: fan-in analysis [5, 6], identifier analysis [7, 8] and\ndynamic analysis [9]. In the experiment, each of these techniques is applied to\nthe same case study: the JHotDraw graphical editor framework. The goal of the\nexperiment is not to identify the \"best\" aspect mining technique, but rather to\nmutually compare the individual techniques and assess their major strengths\nand weaknesses. Additionally, by identifying where the techniques overlap and\nwhere they are complementary, the experiment allows us to propose interesting\ncombinations and to apply these combinations on the same benchmark to verify\nwhether they actually perform better.\nThe JHotDraw framework which we selected as benchmark case was originally developed to illustrate good use of object-oriented design patterns [10] in\nJava programs. This implies that the case study has been well-designed and that\ncare has been taken to cleanly separate concerns and make it as understandable\nas possible. Nevertheless, JHotDraw exposes some of the modularisation limitations present even in well-designed systems, and contains some quite interesting\ncrosscutting concerns.\nThe contributions of this paper can be summarised as follows:\n\u2013 We provide an overview of the major strengths and weaknesses of three aspect mining techniques. This information is valuable for developers using\nthese techniques, as it can help them choosing a technique that suits their\nneeds. Other aspect mining researchers can take this information into account to compare their techniques to ours, or to fine-tune our techniques;\n\u2013 We discuss how the individual techniques can be combined in order to perform better, and validate whether this is indeed the case by applying the\ncombined techniques on the same benchmark application and comparing\nthe results;\n\u2013 We present a list of all crosscutting concerns that the three techniques identified in the JHotDraw framework. Such information is valuable for other\n\n2\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nIII\ninterface A {\npublic void m();\n}\nclass B implements A {\npublic void m() {};\n}\nclass C1 extends B {\npublic void m() {};\n}\nclass C2 extends B {\npublic void m() { super.m();};\n}\nclass D {\nvoid f1(A a) { a.m(); }\nvoid f2(B b) { b.m(); }\nvoid f3(C1 c) { c.m(); }\n}\n\nFig. 1. Various (polymorphic) method calls.\n\naspect mining researchers who want to validate their techniques, and might\nlead to JHotDraw becoming a de-facto benchmark for aspect mining techniques;\nThe paper is structured as follows. Section 2 introduces the necessary background concepts required to understand the three aspect mining techniques explained in Section 3. Section 4 presents the results of applying each technique on\nthe common benchmark, while Section 5 uses these results for discussing the benefits and drawbacks of each technique with respect to the others. Based on this\ndiscussion, Section 6 presents useful combinations of the techniques, and reports\non the experience of applying such combinations on the benchmark application.\nSection 7 presents our conclusions. For an overview of related work concerning\naspect mining, we refer to the papers discussing the individual techniques [5\u20139]\nand to an initial survey on aspect mining [4].\n\n2\n2.1\n\nBackground concepts\nFan-in\n\nThe fan-in metric, as defined by Henderson-Sellers, counts the number of locations from which control is passed into a module [11]. In the context of objectorientation, the module-type to which this metric is applied is the method. We\ndefine the fan-in of a method M as the number of distinct method bodies that\ncan invoke M . Because of polymorphism, one call site can affect the fan-in of\nseveral methods: a call to method M contributes to the fan-in of M , but also to\nall methods refined by M , as well as to all methods that are refining M [6].\n\nTUD-SERG-2006-002\n\n3\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nIV\nMethod\nA.m\nB.m\nC1.m\nC2.m\n\nPotential\nD.f1, D.f2,\nD.f1, D.f2,\nD.f1, D.f2,\nD.f1, D.f2\n\ncallers\nFan-in\nD.f3\n3\nD.f3, C2.m\n4\nD.f3\n3\n2\n\nFig. 2. Fan-in values for program in Figure 1.\n\nAs an example, Figure 2 shows the calculated fan-in for the methods named\nm in the program of Figure 1. Note that D.f 3 is reported among the potential\ncallers of B.m, even though this situation cannot actually occur at run-time.\nHowever, the resulting effect of having higher fan-in values reported for methods\nin super-classes is arguably positive for the purpose of the present analysis, as it\nemphasizes the concern implemented by the super-class method, which generally\nis addressed by its overriding methods as well.\n2.2\n\nConcept analysis\n\nFormal concept analysis (FCA) [12] is a branch of lattice theory that can be used\nto identify meaningful groupings of elements that have common properties.5\n\nProgramming lang. object-oriented functional logic static typing dynamic typing\n\u221a\n\u221a\nJava\n\u221a\n\u221a\nSmalltalk\n\u221a\n\u221a\nC++\n\u221a\n\u221a\nScheme\n\u221a\n\u221a\nProlog\nTable 1. Programming languages and their supported programming paradigms.\n\nFCA takes as input a so-called context, which consists of a (potentially large,\nbut finite) set of elements E, a set of properties P on those elements, and a\nBoolean incidence relation T between E and P . An example of such a context is\ngiven in \u221a\nTable 1, which relates different programming languages and properties.\nA mark in a table cell means that the element (programming language) in the\ncorresponding row has the property of the corresponding column.\nStarting from such a context, FCA determines maximal groups of elements\nand properties, called concepts, such that each element of the group shares the\nproperties, every property of the group holds for all of its elements, no other\n5\n\n4\n\nWe use the terms element and property instead of object and attribute used in\ntraditional FCA literature, because these latter terms have a very specific meaning\nin OO software development.\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nV\n\nelement outside the group has those same properties, nor does any property\noutside the group hold for all elements in the group.\n\u221a Intuitively, a concept corresponds to a maximal 'rectangle' containing only\nmarks in the table, modulo\nany permutation of the table's rows and columns.\nFormally, the starting context is a triple (E, P, T ), where T \u2286 E \u00d7 P is a\nbinary relation between the set of all elements E and the set of all considered\nelement properties P . A concept c is defined as a pair of sets (X, Y ) such that:\nX = {e \u2208 E | \u2200p \u2208 Y : (e, p) \u2208 T }\n\n(1)\n\nY = {p \u2208 P | \u2200e \u2208 X : (e, p) \u2208 T }\n\n(2)\n\nwhere X is said to be the extent of the concept (Ext[c]) and Y is said to be\nits intent (Int[c]). It should be noticed that the definition above is not \"constructive\", being mutually recursive between X and Y . However, given a pair\n(X, Y ), it allows deciding whether it is a concept or not. FCA algorithms provide\nconstructive methods to determine all pairs (X, Y ) satisfying the constraints (1)\nand (2).\n\n{}\n{Java, Smalltalk, C++, Scheme, Prolog}\n\n{OO}\n\n{dynamic typing}\n\n{Java, C++, Smalltalk}\n\n{Scheme, Prolog, Smalltalk}\n\n{static typing, OO}\n\n{dyn. typing, OO}\n\n{dyn. typing, funct.}\n\n{dyn. typing, logic}\n\n{Java, C++}\n\n{Smalltalk}\n\n{Scheme}\n\n{Prolog}\n\n{OO, funct., logic, static typing, dyn. typing}\n{}\n\nFig. 3. The concept lattice for Table 1.\n\nThe containment relationship between concept extents (or, equivalently, intents) defines a partial order over the set of all concepts, which can be shown to\nbe a lattice [12]. Figure 3 shows the concept lattice corresponding to Table 1.\nThe lattice's bottom concept contains those elements that have all properties.\nSince there is no such programming language in our example, that concept contains no elements (its extent is empty). Similarly, the top concept contains those\nproperties that hold for all elements. Again, there is no such property (the concept's intent is empty). Other concepts represent related groups of programming\nlanguages, such as the concept ({Java, C++}, {static typing, OO }), which\ngroups all statically-typed object-oriented languages, a sub-concept of all OO\nlanguages. Intuitively, the sub-concept relationship can thus be interpreted as a\nspecialization of more general notions. Elements (resp. properties) in boldface\n\nTUD-SERG-2006-002\n\n5\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nVI\n\nare those that are most concept-specific, being attached to the largest lower\nbound (resp. least upper bound) concept. When using the so-called sparse labeling of the concept lattice, only these boldface labels are retained, without loss\nof information.\nMore precisely, when using sparse labeling, a node c is marked with an element\ne \u2208 Ext[c] only if it is associated with the most specific (i.e., lowest) concept c\nhaving e in the extent; a node c is marked with a property p \u2208 Int[c] only if it is\nassociated with the most general (i.e., highest) concept c having p in its intent.\nThe (unique) node of a lattice L marked with a given element e is thus:\n\u03b3(e) = inf{c \u2208 L | e \u2208 Ext[c]}\n\n(3)\n\nwhere inf gives the infimum (largest lower bound) of a set of concepts. Similarly,\nthe unique lattice node marked with a given property p is:\n\u03bc(p) = sup{c \u2208 L | p \u2208 Int[c]}\n\n(4)\n\nwhere sup gives the supremum (least upper bound) of a set of concepts. The set\nof elements in the extent of a lattice node c can then be computed as the set\nof all elements at or below c, while the set of properties in its intent are those\nmarking c or any node above c.\nThe labeling introduced by the functions \u03bc and \u03b3 give the most specific\nconcept for a given element (resp. property). Thus, with sparse labeling, the\nelements and properties that label a given concept are those that characterize it\nmost specifically. Sometimes it is convenient to get the labels of a given concept\nthrough the following functions:\n\u03b1(c) = {p \u2208 P | \u03bc(p) = c}\n\n(5)\n\n\u03b2(c) = {e \u2208 E | \u03b3(e) = c}\n\n(6)\n\n\u03b1(c) gives the set of properties labeling a concept c, while \u03b2(c) gives the concept's\nelements, according to the sparse labeling.\n2.3\n\nTerminology\n\nWe conclude this background section by introducing some terminology that will\nbe used throughout the remainder of this paper.\nA concern is a collection of related source-code entities, such as classes, methods, statements or expressions, that implement a particular functionality or\nfeature of the application. A crosscutting concern is a concern whose entities\nare not captured into a single localised abstraction, but are scattered over\nmany different locations and tangled with other concerns.\nA (concern) seed is a single source-code entity, such as a method, or a collection of such entities, that strongly connotes a crosscutting concern. It offers\na starting point for further exploration and understanding the whole extent\nof that concern's implementation.\n\n6\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nVII\n\nA candidate seed is identified by an automated aspect mining technique as a\npotential concern seed but is not yet confirmed to be an actual concern seed\nor rather a false positive.\nSeed expansion is the manual or automated process of completing the set\nof source-code entities constituting a seed into the entire set of source-code\nentities of which the crosscutting concern corresponding to that seed consists.\n\n3\n\nThe three aspect mining techniques\n\nIn this section, we give a brief overview of three techniques, developed independently by different research groups, that support the automated discovery of\ncrosscutting concerns in the source code of a software system that is written in\na non aspect-oriented way.\n3.1\n\nFan-in analysis\n\nCrosscutting functionality can occur at different levels of modularity. Classes,\nfor instance, can assimilate new concerns by implementing multiple interfaces or\nby implementing new methods specific to super-imposed roles. At the method\nlevel, crosscutting in many cases resides in calls to methods that address a different concern than the core logic of the caller. Typical examples include logging,\ntracing, pre- and post-condition checks, and exception handling. It is exactly\nthis type of crosscutting that fan-in analysis tries to capture.\nWhen we study the mechanics of AOSD, we see that it employs the so-called\nadvice construct to eliminate crosscutting at method level. This construct is used\nto acquire control of program execution and to add crosscutting functionality to\nmethods without an explicit invocation from those methods. Rather, the crosscutting functionality is isolated in a separate module, called aspect, and woven\nwith the method implicitly based on the advice specification.\nFan-in analysis reverses this line of reasoning and looks for crosscutting\nfunctionality that is explicitly invoked from many different methods scattered\nthroughout the code. The hypothesis is that the amount of calls to a method\nimplementing this crosscutting functionality (fan-in) is a good measure for the\nimportance and scattering of the discovered concern.\nTo perform the fan-in analysis, a fan-in metric was implemented as a plug-in\nfor the Eclipse platform6 , and integrated it into an iterative process that consists\nof three steps:\n1. Automatic computation of the fan-in metric for all methods in the investigated system.\n2. Filtering of the results from the previous step by\n\u2013 eliminating all methods with fan-in values below a chosen threshold (in\nthe experiment, a threshold of 10 was used);\n6\n\nhttp://swerl.tudelft.nl/view/AMR/FINT\n\nTUD-SERG-2006-002\n\n7\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nVIII\n\n\u2013 eliminating the accessor methods (methods whose signature matches a\nget* /set* pattern and whose implementation only returns or sets a reference);\n\u2013 eliminating utility methods, like toString() and collection manipulation methods, from the remaining subset.\n3. (Partially automated) analysis of the methods in the resulting, filtered set by\nexploring the callers, call sites, naming convention used, the implementation\nand the comments in the source code.\nBesides code exploration, the tool supports automatic recognition of a number of relations between the callers of a method, such as common roles,\nconsistent call positions, etc.\nThe result of the fan-in analysis is a set of candidate seeds, represented as methods with high fan-in.\n3.2\n\nIdentifier analysis\n\nIn the absence of designated language constructs for aspects, naming conventions are the primary means for programmers to associate related but distant\nprogram entities. This is especially the case for object-oriented programming,\nwhere polymorphism allows methods belonging to different classes to have the\nsame signature, where it is good practice to use intention-revealing names [13],\nand where design and other programming patterns provide a common vocabulary known by many programmers.\nIdentifier analysis relies on this assumption and identifies candidate seeds\nby grouping program entities with similar names. More specifically, it applies\nFCA with as elements all classes and methods in the analyzed program (except\nthose that generate too much noise in the results, like test classes and accessor\nmethods), and as properties the identifiers associated with those classes and\nmethods.\nThe identifiers associated with a method or class are computed by splitting\nup its name based on where capitals appear in it. For example, a method named\ncreateUndoActivity yields three identifiers create, undo and activity. In addition, we apply the Porter stemming algorithm [14] to make sure that identifiers\nwith the same root form (like undo and undoable) are mapped to one single representative identifier or 'stem'. It is these stems that are used as properties for\nthe concept analysis.\nThe FCA algorithm then groups entities with the same identifiers. When such\na group contains a certain minimum number of elements (in the experiment, a\nthreshold of 4 was used) and the entities contained in it cut across multiple class\nhierarchies, the group is considered a candidate seed. The only remaining but\nmost difficult task is that of deciding manually whether a candidate seed is a\nreal seed or a false positive. To help the developer in this last task, the DelfSTof\nsource-code mining tool presents the concepts in such a way that they can be\nbrowsed easily by a software engineer and so that he or she can readily access\nthe code of the classes and methods belonging to a discovered seed.\n\n8\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nIX\n\n3.3\n\nDynamic analysis\n\nFormal concept analysis has been used to locate 'features' in procedural programs [15]. In that work, the goal was to identify the computational units (procedures) that specifically implement a feature (i.e., requirement) of interest. Execution traces obtained by running the program under given scenarios provided\nthe input data (dynamic analysis).\nIn a similar way, dynamic analysis can be used to locate aspects in program\ncode [9] according to the following procedure. Execution traces are obtained\nby running an instrumented version of the program under analysis, for a set of\nscenarios (use-cases). The relationship between execution traces and executed\ncomputational units (methods) is subjected to concept analysis. The execution\ntraces associated with the use-cases are the elements of the concept analysis\ncontext, while the executed methods are the properties. In the resulting concept\nlattice (with sparse labeling), the use-case specific concepts are those labeled by\nat least one trace for some use-case (i.e. \u03b1 contains at least one element), while\nthe concepts with zero or more properties as labels (those with an empty \u03b1) are\nregarded as generic concepts. Thus, use-case specific concepts are a subset of the\ngeneric ones.\nBoth use-case specific concepts and generic concepts carry information potentially useful for aspect mining, since they group specific methods that are\nalways executed under the same scenarios. When the methods that label one\nsuch concept (using the sparse labeling) crosscut the principal decomposition, a\ncandidate aspect is determined.\nFormally, let C be the set of all the concepts and let Cs be the set of use-case\nspecific concepts (|\u03b1(c)| > 0). A concept c is considered a candidate seed iff:\nScattering: \u2203p, p0 \u2208 \u03b2(c) | pref (p) 6= pref (p0 )\nTangling: \u2203p \u2208 \u03b2(c), \u2203c0 \u2208 \u03a9, \u2203p0 \u2208 \u03b2(c0 ) | c 6= c0 \u2227 pref (p) = pref (p0 )\nwhere \u03a9 = Cs for the use-case specific seeds, while \u03a9 = C for the generic seeds.\nThe first condition (scattering) requires that more than one class contributes to\nthe functionality associated with the given concept (pref(p) is the fully scoped\nname of the class containing the method p). The second condition (tangling)\nrequires that the same class addresses more than one concern.\nIn summary, a concept is a candidate seed if: (1) scattering: more than one\nclass contributes to the functionality associated with the given concept; (2) tangling: the class itself addresses more than one concern.\nThe first condition alone is typically not sufficient to identify crosscutting\nconcerns, since it is possible that a given functionality is allocated to several\nmodularized units without being tangled with other functionalities. In fact, it\nmight be decomposed into sub-functionalities, each assigned to a distinct module.\nIt is only when the modules specifically involved in a functionality contribute\nto other functionalities as well (i.e. the second condition) that crosscutting is\ndetected, hinting for a candidate seed.\n\nTUD-SERG-2006-002\n\n9\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nX\nConcern type\n\n# Seed's description\n\nConsistent behavior\n\n4 Methods implementing the consistent behavior\nshared by different callers, such as checking and refreshing figures/views that have been affected by the\nexecution of a command.\n4 Method implementing a contract that needs to be enforced, such as checking the reference to the editor's\nactive view before executing a command.\n\nContract enforcement\n\nUndo\n\n1 Methods checking whether a command is undoable/redoable and the undo method in the superclass, which is invoked from the overriding methods\nin subclasses.\nPersistence and resurrection 1 Methods implementing functionality common to persistent elements, such as read/write operations for\nprimitive types wrappers (e.g., Double, Integer, etc.)\nwhich are referenced by the scattered implementations of persistence/resurrection.\nCommand design pattern\nObserver design pattern\nComposite design pattern\nDecorator design pattern\nAdapter design pattern\n\n1 The execute method in the command classes and command constructors.\n1 The observers' manipulation methods and notify\nmethods in classes acting as subject.\n2 The composite's methods for manipulating child components, such as adding a new child.\n1 Methods in the decorator that pass the calls on to the\ndecorated components.\n1 Methods that manipulate the reference from the\nadapter (Handle) to the adaptee (Figure).\n\nTable 2. Summary of the results of the fan-in analysis experiment.\n\n4\n\nResults of the aspect mining\n\nIn this section, we present the results of applying each technique to version\n5.4b1 of JHotDraw, a Java program with approximately 18,000 non-commented\nlines of code and around 2800 methods. We mutually compare the results of\nthe techniques, and discuss the limitations of each technique as well as their\ncomplementarity.\n4.1\n\nThe fan-in analysis experiment\n\nAs described in Subsection 3.1, fan-in analysis first performs a number of successive steps to filter the methods in the analyzed system. The threshold-based\nfiltering, which selects methods with high fan-in values, kept around 7% of the\ntotal number of methods. The filters for accessors and utility methods eliminated\naround half of the remaining methods. In the remaining subset, more than half\nof the methods (52%) were categorized as seeds, based on manual analysis.\n\n10\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXI\n\nTable 2 gives an overview of the types of crosscutting concerns that were\nidentified and the seeds that led to their identification. Several of these concern\ntypes, such as consistent behavior or contract enforcement [16], have more than\none instance in JHotDraw; that is, multiple unrelated (crosscutting) concerns\nexist that conform to the same general description. For example, one instance of\ncontract enforcement checks a priori conditions to a command's execution, while\nanother instance verifies common requirements for activating drawing tools. The\nnumber of different instances that were detected is indicated in the # column.\nWe distinguish three different ways in which the fan-in metric can be associated with the crosscutting structure of a concern implementation (also indicated\nin Table 2):\n1. The crosscutting functionality is implemented through a method and the\ncrosscutting behavior resides in the explicit calls to this method. Examples\nin this category include consistent behavior and contract enforcement.\n2. The implementation of the crosscutting concern is scattered throughout the\nsystem, but makes use of a common functionality. The crosscutting resides\nin the call sites, and can be detected by looking at the similarities between\nthe calling contexts and/or the callers. Examples of concerns in this category\nare persistence and undo [6].\n3. The methods reported by the fan-in analysis are part of the roles superimposed to classes that participate in the implementation of a design pattern.\nMany of these roles have specific methods associated to them: the subject\nrole in an Observer design pattern is responsible to notify and manage the\nobserver objects, while the composite role defines specific methods for manipulating child components. In general, establishing a relation between these\nseed-methods and the complete concern to which they appertain might require a better familiarity of the human analyzer with the code being explored,\nthan for the previous two categories. However, many of these patterns are\nwell-known and have a clear defined structure, which eases their recognition [17].\nFor more details regarding fan-in analysis and a complete discussion of the JHotDraw results, we refer to [6].\n4.2\n\nThe identifier analysis experiment\n\nApplying the identifier analysis technique of Subsection 3.2 on JHotDraw yielded\n230 concepts and took about 31 seconds when using a threshold of 4 for the\nminimum number of elements in a concept. With a threshold of 10, the number\nof concepts produced was significantly less: only 100 concepts remained after\nfiltering, for a similar execution time.7 In both cases, 2193 elements and 507\nproperties were considered. It is a good sign that the number of properties is\n7\n\nWhereas the threshold of 4 was chosen arbitrarily, the threshold of 10 was determined\nexperimentally: below that threshold the amount of concepts that were regarded as\nnoise was significantly higher than above the threshold.\n\nTUD-SERG-2006-002\n\n11\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXII\nCrosscutting concern Concept(s)\n\n#elements Some elements\n\nObserver\n\nchange(d)\ncheck\nlistener\nrelease\ncommand executed\nexecut(abl)e\nundo(able)\nredo(able)\nvisit\nfile\nstorable\nload\nregister\n\n67\n14\n65\n12\n4\n51\n53\n14\n12\n15\n5\n8\n7\n\nfigureChanged(e)\ncheckDamage()\ncreateDesktopListener()\n...\ncommandExecuted(...)\ncommandExecutable(...)\ncreateUndoActivity()\nredo()\nvisit(FigureVisitor)\nregisterFileFilters(c)\nreadStorable()\nloadRegisteredImages\nloadRegisteredImages\n\ndraw\nmove\n\n112\n36\n\ndraw(g)\nmoveBy(x,y)\nmoveSelection(dx,dy)\n\n5\n\niterator(), listIterator(), . . .\n\nCommand execution\nUndo\nVisitor\nPersistence\n\nDrawing figures\nMoving figures\n\nIterating over collections iterator\n\nTable 3. Selection of results of the identifier analysis experiment.\n\nsignificantly smaller than the total number of elements considered, as it implies\nthat there is quite some overlap in the identifiers of the different source-code\nentities, which was one of the premisses of the identifier analysis technique.\nThe manual part of the experiment, i.e. deciding which concepts were real\nseeds, was much more time-consuming. Overall, this took about three days for\nthe experiment with threshold 4, where 230 seed candidates needed to be investigated. For each of the discovered concepts, the code of the entities in its\nextent had to be inspected to decide whether (most of) these entities addressed a\nsimilar concern. Other than allowing to browse the source code of the elements\nin the extent of a concept, the DelfSTof code mining tool provided no direct\nsupport for this.\nTable 3 presents some of the seeds discovered by manually analyzing the\nclasses and methods belonging to the extent of the concepts produced by the\nFCA algorithm. The first column names the concern, the second column shows\nthe identifiers shared by the elements belonging to the concept(s) corresponding\nto that concern. The third column shows the size of the extent for each concept.\nFinally, for illustration purposes, the fourth column shows some program entities\nappearing in the extent of the discovered concepts.\nOut of 230 candidate seeds, 41 seeds were retained, when using a threshold of\n4 for the minimum number of elements in a concept. These discovered concerns\nwere classified in three different categories:\n1. Some of these concerns looked like aspects in the more traditional sense (e.g.,\nobserver, undo and persistence).\n\n12\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXIII\n\n2. Many other concerns seemed to represent a crosscutting functionality that\nwas part of the business logic (e.g., drawing figures, moving figures). The\ndistinction between these two first categories was somewhat subjective, however.\n3. Three Java-specific concerns were discovered (e.g., iterating over collections)\nthat are difficult to factor out into an aspect because they rely on or extend\nspecific Java code libraries.\n4.3\n\nThe dynamic analysis experiment\n\nThe dynamic analysis technique of Subsection 3.3 is supported by the Dynamo\naspect mining tool8 . The first step required by Dynamo is the definition of a\nset of use-cases. To accomplish this task, the documentation associated with\nthe main functionalities of JHotDraw was used to define a use-case for each\nfunctionality described in the documentation. Amongst others, a use-case was\ncreated to draw a rectangle, one to draw a line using the scribble tool, one\nto create a connector between two existing figures, one to attach a URL to\na graphical element, and so on. In total, 27 use-cases were obtained. When\nexecuted they exercised 1262 methods belonging to JHotDraw classes, so that\nthe initial context for the concept analysis algorithm contained 27 elements and\n1262 properties. The resulting concept lattice contained 1514 nodes.\n\nCrosscutting concern\n\nConcepts Methods\n\nUndo\nBring to front\nSend to back\nConnect text\n\n2\n1\n1\n1\n\n36\n3\n3\n18\n\nPersistence\nManage handles\nManage figure change event\nMove figure\nCommand executability\nConnect figures\nFigure observer\nAdd text\nAdd URL to figure\nManage figures outside drawing\nGet attribute\nSet attribute\nManage view rectangle\nVisitor\n\n1\n4\n3\n1\n1\n1\n4\n1\n1\n1\n1\n1\n1\n1\n\n30\n60\n8\n7\n25\n55\n11\n26\n10\n2\n2\n2\n2\n6\n\nTable 4. Summary of the results of the dynamic analysis experiment.\n8\n\nAvailable from http://star.itc.it/dynamo/ under GPL.\n\nTUD-SERG-2006-002\n\n13\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXIV\n\nAmong the concepts in the lattice, 11 satisfied the crosscutting conditions\n(scattering and tangling), described in Section 3, for the use-case specific concepts, while 56 (including the 11 above) satisfied the conditions for the generic\nconcepts. Next, both the use-case specific and generic concepts were revisited\nmanually, to determine which ones could be regarded as plausible seeds and\nwhich ones should be considered false positives. The criterion followed in this\nassessment was the following: a concept satisfying the crosscutting conditions is\nconsidered a seed if\n\u2013 it can be associated to a single, well-identified functionality (this usually\naccounts for the possibility to give it a short description that labels it), and\n\u2013 some of the classes involved in such a functionality have a different primary\nresponsibility (indicating crosscutting with respect to the principal decomposition).\nOf course, due to the nature of crosscutting concerns and the related design\ndecisions, some level of subjectivity still remains (as is the case for the other\ntechniques).\nIn the end, the list of candidate seeds shown in Table 4 was obtained. The\nfour topmost concerns are use-case specific. As apparent from the second column\nof the table, and as was the case for the identifier analysis experiment, some\ncrosscutting concerns were detected by multiple concepts. In total, among the 56\ngeneric concepts satisfying the crosscutting conditions, 24 concepts were judged\nto be associated with 18 crosscutting concerns.\nThe methods associated with each candidate seed (counted in the last column\nof Table 4) are indicative of the \"aspectizable\" functionality. Although they may\nbe not the complete list (dynamic analysis is partial) and may contain false\npositives, they represent a good starting point for a refactoring intervention\naimed at migrating the application to AOSD.\n\n5\n\nComparing the results\n\nIn this section we discuss some selected concerns that were identified by the\ndifferent techniques. We selected some concerns that were detected by all three\ntechniques, as well as a representative set of concerns that were detected by some\ntechniques but not by others. This allows us to clearly pinpoint the strengths\nand weaknesses of each individual technique.\n5.1\n\nSelected concerns\n\nTable 5 summarises the concerns we selected. The first column names the concern. The other columns show by what technique(s) the concern was discovered:\nif a technique discovered the concern, we put a + sign in the corresponding\ncolumn, otherwise a - sign is in the table.\n\n14\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXV\nConcern\nObserver\nUndo\nPersistence\nConsistent behavior /\nContract enforcement\nCommand execution\nBring to front / Send to back\nManage handles\nMove Figures\n\nFan-In\nAnalysis\n+\n+\n+\n+\n+\n+ (discarded)\n\nIdentifier Dynamic\nAnalysis Analysis\n+\n+\n+\n+\n+\n+\n+\n+\n+\n\n+\n+\n+\n+\n\nTable 5. A selection of detected concerns in JHotDraw.\n\nObserver The Observer design pattern is an example of a concern reported by\nall techniques. Other examples include Command execution, Undo functionality\nand Persistence, whose implementation in JHotDraw is described in [6]. Their\nidentification should come as no surprise, because they correspond to well-known\naspects, frequently mentioned in AOSD literature, or to functionalities for which\nan AOSD implementation looks quite natural.\nConcerns identified by all three techniques are probably the best starting\npoint for migrating a given application to AOSD, because developers can be\nquite confident that the concern is very likely to be an aspect. However, the\nfact that only four of such concerns were discovered, stresses the need for an\napproach that combines the strengths of different techniques.\nContract enforcement / consistent behavior The contract enforcement\nand consistent behavior concerns [16] generally describe common functionality\nrequired from, or imposed on, the participants in a given context, such as a\nspecific pre-condition check on certain methods in a class hierarchy. An example from the JHotDraw case is the Command hierarchy for which the execute\nmethods contain code to ensure the pre-condition that an 'active view' reference\nexists (is not null).\nWe classify these concerns as a combination of contract enforcement and\nconsistent behavior since these types often have very similar implementations,\nand choosing a particular type depends mainly on the context and on (personal)\ninterpretation.\nFan-in analysis is particularly suited to address this kind of scattered, crosscutting functionalities, which involve a large number of calls to the same method,\nwhile the other two techniques potentially miss it. In fact, contract enforcement\nand consistent behavior are usually associated with method calls that occur in\nevery execution scenario, so that they cannot be discriminated by any specific\nuse-case. On the other hand, identifier analysis will miss those cases where the\nmethods that enforce a given contract or ensure consistent behavior do not share\na common naming scheme.\n\nTUD-SERG-2006-002\n\n15\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXVI\n\nCommand execution This concern deals with the executability and the actual execution of objects whose class belongs to the Command hierarchy. Identifier analysis identified a concept which contains exactly the execute methods\nin the Command hierarchy. Dynamic analysis identified the classes containing\nisExecutable methods. Indeed, the execute methods all have the same name and\nmanual inspection showed they exhibit similar behavior: they nearly all make\na super call to an execute method, invoke a checkDamage method and (though\nnot always) invoke a setUndoAcivity and getUndoActivity method. A similar\nargument can be made for isExecutable.\nHence, whereas identifier and dynamic analysis may not detect the more\ngeneric Contract enforcement / Consistent behavior aspect directly, they can\nidentify some locations (pointcuts) where potentially such an aspect could be\nintroduced.\nBring to front / Send to back The functionality associated with this concern\nconsists of the possibility to bring figures to the front or send them to the back\nof an image. When exercised, it executes specific methods that have a low fan-in,\nhence they were not detected by fan-in analysis. Identifier analysis also missed\nthem, because there were not enough methods with a sufficiently similar name\nto surpass the threshold. Hence, dynamic analysis is the only technique that\nidentified this concern. This example is a good representative of crosscutting\nconcerns that are reported only by dynamic analysis: whenever the methods\ninvolved in a functionality are not characterized by a unifying naming scheme\n(or there are not enough of them), neither do they have high fan-in, the other\ntwo techniques are likely to fail.\nManage handles A crosscutting functionality is responsible for managing the\nhandles associated with the graphical elements. Such handles support interactive\noperations, such as resizing of an element, conducted by clicking on the handle\nand dragging the mouse. This seed is interesting because it is detected by dynamic analysis and by identifier analysis, but in different ways. Identifier analysis\ndetects this concern based on the presence of the word 'handle' in identifiers.\nConsequently, it misses methods such as north(), south(), east(), west(),\nwhich are clearly related to this concern, but do not share the lexicon with the\nothers. On the other hand, dynamic analysis reports both the latter methods\nand (some of) those containing the word 'handle'. However, since not all possible handle interactions have been exercised, the output of dynamic analysis is\npartial and does not include all the methods reported by identifier analysis.\nThe manage handles concern was missed by the fan-in analysis because the\ncalls are too specific: they are similar but different calls instead of one single\ncalled method with a high fan-in.\nMoving figures The three techniques discard concerns on different bases: some\nof the concerns are filtered automatically while others are excluded manually.\n\n16\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXVII\n\nThe move figures concern, seeded by the moveBy method in the Figure classes,\nis one example where different, subjective decisions can be made depending on\nwhether the concept is classified either as a candidate aspect or as part of the\nprincipal decomposition. The moveBy methods allow to move a figure with a\ngiven offset. The team which used fan-in analysis argued that the original design\nseems to consider this functionality as part of a Figure's core logic. The other\ntwo teams considered it as part of a crosscutting functionality and included it\nin the list of reported seeds.\nThis example highlights the difficulty of deciding objectively on what is and\nwhat is not an aspect and corroborates our choice to conduct a qualitative,\ninstead of a quantitative, comparison.\n5.2\n\nLimitations\n\nAs a consequence of applying each technique to the same case, some of the\nlimitations of the respective techniques have become obvious. For example, we\nobtained a better idea of potential 'false negatives', i.e. concerns that were not\nidentified by a particular technique but that were identified by another. Below, we summarise some of the discovered limitations. In the next section we\nthen describe how to partly overcome these limitations by combining different\ntechniques.\nFan-in analysis mainly addresses crosscutting concerns that are largely scattered and that have a significant impact on the modularity of the system. The\ndownside of this characteristic is that concerns with a small code footprint and\nthus with low fan-in values associated, will be missed. For example, the identification of Observer design pattern instances is dependent on the number of\nclasses implementing the observer role. These classes contain calls to specific\nmethods in the subject class for registering as listeners to the subject's changes.\nThe number of observer classes will determine to a large extent the number of\ncalls to the registration method in the subject role. A collateral effect is the\nanticipated unsuitability of the technique for analysing small case studies.\nIdentifier analysis tends to produce a lot of detailed results. However, these\nresults typically contain too much noise (false positives), so a more effective filtering of the discovered concepts, as well as of the elements inside those concepts,\nis needed. In addition, the discovered concepts are often incomplete, in the sense\nthat they do not completely \"cover\" an aspect or crosscutting concern. Often,\nmore than one concept is needed to describe a single concern, as was the case\nfor the Observer aspect. The individual concepts themselves may also need to\nbe completed with additional elements that are not contained in those concepts.\nThis was the case for the Undo aspect: in addition to the methods with 'undo'\nor 'undoable' in their name, some of the methods calling these undo methods\nneed to be considered as part of the core aspect as well.\n\nTUD-SERG-2006-002\n\n17\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXVIII\n\nDynamic analysis is partial (i.e., not all methods involved in an aspect are\nretrieved), being based on specific executions, and it can determine only aspects\nthat can be discriminated by different execution scenarios (e.g., aspects that are\nexercised in every program execution cannot be detected). Additionally, it does\nnot deal with code that cannot be executed (e.g., code that is part of a larger\nframework, but that is not used in a specific application).\n5.3\n\nComplementarity\n\nThe three proposed techniques address symptoms of crosscutting functionality,\nsuch as scattering and tangling, in quite different ways. As shown in Table 6,\nfan-in analysis and dynamic analysis show largely complementary result sets:\namong the 30 concerns identified by either dynamic or fan-in analysis, only 4\nare identified by both techniques. This is an expected result. Fan-in analysis focuses on identifying those methods that are called at multiple places. However,\nwhen a method is called many times, it is likely to occur in most (if not all) execution traces. Hence, no specific use-case can be defined to isolate the associated\nfunctionality, and dynamic analysis will fail to identify it as a seed.\nIdentifier analysis is the least discriminating of the three techniques and has\na large overlap with the other two techniques. When a concern can be identified\nthrough fan-in analysis and/or dynamic analysis, identifier analysis can often\nisolate it too, since a common lexicon is often used in the names of the involved\nmethods.\nIn the next section, we will use these observations to propose a new aspect\nmining technique that is a clever combination of the three individual techniques.\nTechnique\nConcerns\nDynamic analysis\n18\nFan-in analysis S\n16\nDynamic analysis T Fan-in analysis\n30\nDynamic analysis\nFan-in analysis\n4\nTable 6. Concerns identified by either dynamic or fan-in analysis.\n\n6\n\nToward interesting combinations\n\nBased on the discussion in the previous section, this section presents three combined aspect mining techniques and reports on the results of applying these\ncombined techniques on the JHotDraw application. Based on the analysis indicators of recalled methods and seed quality we compare whether these combined\ntechniques provide a more complete coverage of the detected concerns than each\nof the original techniques individually.\n\n18\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXIX\n\n6.1\n\nMotivation\n\nAs has been explained in the previous sections, the fan-in analysis and dynamic\nanalysis techniques are largely complementary, and address different symptoms\nof crosscutting. An obvious and interesting combination of these techniques thus\nconsists of simply applying each technique individually and taking the union of\nthe results. Additionally, the seeds in the intersection of the results (if any) are\nlikely to represent the best aspect candidates, because both techniques identify\nthem. This was illustrated in our experiment, in which both techniques identified\nthe Observer, Undo, Persistence and Command execution candidates.\nAs for other combinations of the techniques, two interesting observations were\nconsidered. First, the manual intervention required by identifier analysis is very\ntime-consuming and is not justified by the fact that it produces more interesting\nresults. This makes the technique less suited than the others for large(r) cases.\nSecond, both fan-in analysis and dynamic analysis identify only candidate seeds\nthat serve as a starting point for seed expansion. Dynamic analysis in particular\nsuffers from this problem as it is based on a (necessarily partial) list of execution\nscenarios. Similarly, fan-in analysis is only focused on invocations of high fanin methods, which represent just a portion of the whole concern. Interestingly,\nwhile performing fan-in analysis and dynamic analysis, we observed that the\nclasses and methods in the seed expansion often exhibited similar identifiers.\nConsequently, we believe better results can be obtained if we use identifier\nanalysis as a seed expansion technique for the seeds identified by either fan-in\nanalysis or dynamic analysis, or by the seeds identified by both these techniques.\nIn this way, the search space for identifier analysis is reduced significantly, and\nmore automation is provided for the manual seed expansion needed by both\nfan-in analysis and dynamic analysis. A final manual refinement step is anyway\nnecessary, since the expanded seeds may contain false positives and negatives.\nIn the remainder of this section, we will present three different techniques: a\ncombination of fan-in analysis with identifier analysis, of dynamic analysis with\nidentifier analysis, and of the union of fan-in analysis and dynamic analysis with\nidentifier analysis.\n6.2\n\nDefinition of the combined techniques\n\nThe combined techniques work as follows:\n1. Identify interesting candidate seeds by applying fan-in analysis, dynamic\nanalysis or both to the application;\n\u2013 For candidate seeds identified by dynamic analysis, (manually) filter out\nthose methods that do not pertain to the concern;\n2. For each method in the candidate seed, find its enclosing class, and compute\nthe identifiers occurring in the method and the class name, according to the\nalgorithm used by identifier analysis;\n3. Apply identifier analysis to the application, and search for a concept, among\nthe concepts it reports, that is \"nearest\". The nearest concept is the concept\n\nTUD-SERG-2006-002\n\n19\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXX\n\nthat contains most of the identifiers generated in the previous step. If more\nthan one nearest concept exists, take the union of all their elements.\n4. Add the methods contained in the nearest concept(s) to the candidate seed.\n5. Revise the expanded list of candidate seeds manually to remove false positives and add missing seeds (false negatives).\nIn what follows, we experimentally validate these techniques on the JHotDraw case.\n6.3\n\nAnalysis indicators\n\nBefore applying the combined techniques, we define two measures to validate\nthe results. The goal is to measure how identified seeds change in terms of precision and recall. Unfortunately, this requires information about all crosscutting\nconcerns present in the application, and this is not available. Therefore, we have\nchosen alternative metrics, which we call recalled methods and seed quality.\nRecalled methods is the number of methods reported in a seed that actually\nbelong to the crosscutting concern.\nSeed quality is the percentage of a seed's recalled methods with respect to the\ntotal number of methods in the seed. This indicator estimates how difficult\nit is to spot a concern in the methods provided by the seed.\nWith respect to the definitions above, it is important to remark that for fanin, two interpretations of seeds are possible: the first takes only the callees with\nhigh fan-in into account; the second interpretation includes, besides the callees\nwith high fan-in, also all callers to these methods. These differences stem from\nthe fact that the fan-in technique is actually based on the call-relation and the\ninterpretations use either one or both sides of the relation in seed representations.\nDuring exploration these differences aren't that important because we can easily\nnavigate from caller to callee and vise versa. However, when we start assessments\nbased on counting elements, these interpretations do have considerable impact.\nIn the first case, the number of recalled methods will be low (since callsites are not considered in the seeds), and the seed quality will always be 100%\nsince the high fan-in callees belong to the concern by definition. The second\ninterpretation will result in higher values of recall and yields a more complete\npicture of the concern. However lower values for seed quality are possible since\nnot all calls may be caused by a crosscutting concern.\nSection 6.4 describes the results of applying combined techniques on the\nJHotDraw appication, and evaluates the above indicators before and after the\nexperiment. We include results for both interpretations of fan-in seeds discussed\nabove.\n6.4\n\nExperimental results\n\nTable 7 shows the values of the indicators before and after the completion experiment (based on the first interpretation of seeds for fan-in). Although the\n\n20\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXXI\nConcerns\nTechnique\n\nUndo\nCommand execution\nRecalled\nSeed\nRecalled\nSeed\nMethods? Quality? Methods? Quality?\nDynamic analysis\n23\n64%\n20\n80%\nFan-in\nanalysis\n3\n100%\n3\n100%\nS\nDyn\nFan-in\n24\n63%\n22\n81%\nDyn + Identifier\n183\n55%\n132\n80%\nFan-inS+ Identifier\n94\n100%\n132\n80%\n(Dyn\nFan-in) + Identifier\n183\n55%\n132\n80%\nConcerns\nTechnique\n\nPersistence\nObserver\nRecalled\nSeed\nRecalled\nSeed\nMethods? Quality? Methods? Quality?\nDynamic analysis\n29\n97%\n3\n100%\nFan-in\nanalysis\n6\n100%\n10\n100%\nS\nDyn\nFan-in\n32\n97%\n13\n100%\nDyn + Identifier\n104\n100%\n121\n14%\nFan-inS+ Identifier\n104\n100%\n146\n15%\n(Dyn\nFan-in) + Identifier\n104\n100%\n146\n15%\n\nTable 7. Recalled methods and seed quality before and after completion (? based on\nthe first interpretation of seeds for fan-in)\n\ncompletion technique can be applied to all concerns identified by either fan-in\nanalysis or dynamic analysis, we performed the experiment only on the concerns\nidentified by all three techniques. The sole reason is that we need to assess how\nthe completion technique influences the recalled methods and seed quality indicators as compared to their initial values, which can only be done for the Undo,\nCommand execution, Persistence and Observer concerns.\nWhen looking at the common results, it is important to note that fan-in\nseeds point to distinct crosscutting concerns sorts that can occur as parts of\nmore complex structures like implementations of the Observer pattern [18, 19].\nIn the experiments, these are grouped to obtain the same level of granularity\nobtained by the other techniques.\nA deeper look into the results of the completion with identifier analysis reveals interesting information: For the Undo concern, the results of both fan-in\nanalysis and dynamic analysis improve a lot in terms of recalled methods (from\n23 and 3 up to 183 and 94). There is a negative impact on the seed quality for\n(completed) dynamic analysis (from 64% down to 55%), but the seed quality for\nfan-in plus identifier analysis remains at 100%. For the Command execution and\nPersistence concerns, the number of recalled methods increases significantly for\nthe completion technique (from 20 and 3 up to 132 and from 29 and 6 up to\n104), while the seed quality remains at the same level.\nFor the Observer concern, the results are less encouraging than for the other\nconcerns. Even though the number of recalled methods increases for the completion technique, the quality of the seeds drops to an unacceptable level (from\n\nTUD-SERG-2006-002\n\n21\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXXII\nSeed\n\nRecalled Seed\nMethods Quality\n\nUndo (callee #1)\nUndo (callee #2)\nUndo (callee #3)\n\n24\n25\n24\n\n92%\n88%\n83%\n\nUndo (combined)\n\n73\n\n88%\n\nObserver (combined) 83\n\n100%\n\nTable 8. Recalled methods and seed quality for fan-in analysis based on the second\ninterpretation of seeds for fan-in\n\n100% down to 14% and 15%). Clearly, the completion does not provide a good expansion of the original seeds. Closer inspection reveals that no clearly distinctive\nnaming convention has been used to implement the Observer concern. The Undo,\nCommand execution and Persistence concerns employ distinctive identifiers such\nas undo/undoable, execute/command and store/storable, which are used extensively only within the concern implementation. Consequently, the completion\nprovided by identifier analysis gives good seed expansions. However, the identifiers used for the Observer concern are the more general figure/update/...\nthat are used extensively in throughout the application, and not only in the\nconcern implementation. Therefore, identifier analysis is not able to provide a\ngood expansion for the seeds found by the other techniques.\nAn overview of results based on the second interpretation of seeds for fan-in,\ni.e. taking also the call-sites into account, is shown in Table 8. For the Undo\nconcern, we show both the individual values for each of the three high fan-in\ncallees reported as seeds earlier and the recall and seed quality of the combination\nof these three. The seed quality is lower than 100% in these cases since some of\nthe calls found were not considered to be part of the actual crosscutting concern.\nFor the Observer concern we only show the value for the combined high fan-in\ncallees since it would go too far to go over all individual values here. The seed\nquality is 100% in these cases since there are no calls from outside this concern\nto the reported callees.\nFor a detailed discussion of these measurements and an assessment of various\nquality metrics, we refer to [20] and the fan-in website9 .\n\n7\n\nSummary and future work\n\nThe purpose of the paper was to compare three different aspect mining techniques, discuss their respective strengths and weaknesses by applying them to\na common benchmark application, and develop combined techniques based on\nthis discussion.\n9\n\n22\n\nhttp://swerl.tudelft.nl/amr/\n\nTUD-SERG-2006-002\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXXIII\n\nWe observed that all three techniques were able to identify seeds for wellknown crosscutting concerns, but that interesting differences arose for other\nconcerns. These differences are largely due to the different ways in which the\ntechniques work. Fan-in analysis is good at identifying seeds that are largely\nscattered throughout the system and that involve a lot of invocations of the\nsame method, but it cannot be used to analyse smaller applications. Identifier\nanalysis is able to identify seeds when the associated methods have low fanin, but only if these methods share a common lexicon. The main drawback of\nthis technique is the large number of reported seeds that had to be inspected\nmanually. Finally, dynamic analysis is able to find seeds in the absence of high\nfan-in values and common identifiers, but the technique is only partial because\nit relies on execution traces.\nWe also observed that the three techniques are quite complementary: fan-in\nanalysis and dynamic analysis require a manual effort to expand the seeds into\nfull concerns, whereas identifier analysis covers a large part of a concern, but\nrequires extensive filtering of the reported seeds. Hence, to improve automation\nof both fan-in analysis and dynamic analysis, and to reduce the search space for\nidentifier analysis, we proposed a combined technique in which seeds from either\nfan-in analysis or dynamic analysis are expanded automatically by applying\nidentifier analysis. To verify the performance of this combined technique, we\napplied it to JHotDraw and interpreted the results in terms of two indicators:\nrecalled methods and seed quality. The measures show that for three out of the\nfour concerns we considered, the combined technique outperforms the individual\ntechniques. In only one case, the combined technique performed worse.\nFuture work mainly consists of extending our comparison with other aspect\nmining techniques, and potentially proposing new interesting combinations with\nsuch techniques. This will not only allow us to come up with better (combined)\naspect mining techniques, but will also allow us to evaluate the three considered\ntechniques even better, as new concerns will be identified that we were not aware\nof. Additionally, we could come up with extra quality indicators that complement\nthe recalled methods and seed quality indicators, and empirically establish their\nvalidity by considering other benchmark applications as well.\n\nReferences\n1. Fabry, J.: Modularizing Advanced Transaction Management - Tackling Tangled\nAspect Code. PhD thesis, Vrije Universiteit Brussel (2005)\n2. Lippert, M., Lopes, C.V.: A study on exception detection and handling using\naspect-oriented programming. In: Proceedings of the International Conference on\nSoftware Engineering (ICSE), ACM Press (2000) 418\u2013427\n3. Bruntink, M., Deursen, A., Tourw\u00e9, T.: Discovering faults in idiom-based exception handling. In: Proceedings of the 28th International Conference on Software\nEngineering (ICSE) (to appear), ACM Press (2006)\n4. Kellens, A., Mens, K.: A survey of aspect mining tools and techniques. Technical\nreport, INGI 2005-07, Universit\u00e9 catholique de Louvain, Belgium (2005)\n\nTUD-SERG-2006-002\n\n23\n\n\fSERG\n\nCeccato et al \u2013 Applying and Combining Three Different Aspect Mining Techniques\n\nXXIV\n5. Deursen, A., Marin, M., Moonen, L.: Aspect mining and refactoring. In: Proceedings of the First International Workshop on REFactoring: Achievements, Challenges, Effects (REFACE03). (2003)\n6. Marin, M., Deursen, A., Moonen, L.: Identifying aspects using fan-in analysis.\nIn: Proc. of the 11th IEEE Working Conference on Reverse Engineering (WCRE\n2004), IEEE Computer Society (2004)\n7. Mens, K., Tourw\u00e9, T.: Delving source-code with formal concept analysis. Elsevier\nJournal on Computer Languages, Systems & Structures 31(3\u20134) (2005) 183\u2013198\nSpecial Issue: Smalltalk.\n8. Tourw\u00e9, T., Mens, K.: Mining aspectual views using formal concept analysis. In:\nProc. of the Fourth IEEE International Workshop on Source Code Analysis and\nManipulation (SCAM 2004), IEEE Computer Society (2004)\n9. Tonella, P., Ceccato, M.: Aspect mining through the formal concept analysis of\nexecution traces. In: Proceedings of the 11th IEEE Working Conference on Reverse\nEngineering (WCRE 2004), IEEE Computer Society (2004)\n10. Gamma, E., Helm, R., Johnson, R., Vlissides, J.: Design Patterns: Elements of\nReusable Object-Oriented Software. Addison-Wesley (1994)\n11. Henderson-Sellers, B.: Object-oriented metrics: measures of complexity. PrenticeHall (1996)\n12. Ganter, B., Wille, R.: Formal Concept Analysis: Mathematical Foundations.\nSpringer-Verlag (1999)\n13. Beck, K.: Smalltalk: best practice patterns. Prentice-Hall (1997)\n14. Porter, M.: An algorithm for suffix stripping. Program 14(3) (1980) 130\u2013137\n15. Eisenbarth, T., Koschke, R., Simon, D.: Locating features in source code. IEEE\nTransactions on Software Engineering 29(3) (2003) 195\u2013209\n16. The AspectJ Team: The AspectJ Programming Guide. Palo Alto Research Center.\n(2003) Version 1.2.\n17. Hannemann, J., Kiczales, G.: Design pattern implementation in Java and AspectJ.\nIn: Proceedings of the 17th Annual ACM conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), ACM Press (2002) 161\u2013\n173\n18. Marin, M., Moonen, L., Deursen, A.: An approach to aspect refactoring based on\ncrosscutting concern types. In: Proceedings of the First International Workshop\non the Modeling and Analysis of Concerns in Software, International Conference\non Software Engineering, St. Louis, USA (2005)\n19. Marin, M., L.Moonen, Deursen, A.: A classification of crosscutting concerns.\nIn: Proceedings International Conference on Software Maintenance (ICSM 2005),\nIEEE Computer Society (2005)\n20. Marin, M.: Reasoning about assessing and improving the seed quality of a generative aspect mining technique. In: Proc. of the Second Workshop on Linking Aspect\nTechnology and Evolution at AOSD 2006. (2006)\n\n24\n\nTUD-SERG-2006-002\n\n\f\fTUD-SERG-2006-002\nISSN 1872-5392\n\nSERG\n\n\f"}