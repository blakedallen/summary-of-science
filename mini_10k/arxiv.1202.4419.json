{"id": "http://arxiv.org/abs/1202.4419v2", "guidislink": true, "updated": "2014-03-06T13:47:13Z", "updated_parsed": [2014, 3, 6, 13, 47, 13, 3, 65, 0], "published": "2012-02-20T19:00:14Z", "published_parsed": [2012, 2, 20, 19, 0, 14, 0, 51, 0], "title": "Induced Disjoint Paths in Claw-Free Graphs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1202.0364%2C1202.5682%2C1202.0456%2C1202.0546%2C1202.0837%2C1202.6578%2C1202.5557%2C1202.1726%2C1202.3831%2C1202.4707%2C1202.1317%2C1202.2805%2C1202.4985%2C1202.3019%2C1202.1732%2C1202.1770%2C1202.2464%2C1202.3326%2C1202.2281%2C1202.4305%2C1202.6277%2C1202.0513%2C1202.0312%2C1202.2466%2C1202.4743%2C1202.6563%2C1202.2223%2C1202.4038%2C1202.0109%2C1202.3595%2C1202.2652%2C1202.2087%2C1202.5080%2C1202.4807%2C1202.2188%2C1202.0644%2C1202.4143%2C1202.3104%2C1202.2419%2C1202.0732%2C1202.4606%2C1202.4064%2C1202.3187%2C1202.1782%2C1202.0219%2C1202.1172%2C1202.4981%2C1202.6057%2C1202.5071%2C1202.3793%2C1202.3505%2C1202.0813%2C1202.4750%2C1202.5738%2C1202.2638%2C1202.0009%2C1202.4419%2C1202.4942%2C1202.3383%2C1202.4381%2C1202.5857%2C1202.4116%2C1202.5832%2C1202.2835%2C1202.0555%2C1202.1086%2C1202.4837%2C1202.3059%2C1202.4412%2C1202.1962%2C1202.2278%2C1202.2687%2C1202.4259%2C1202.3811%2C1202.5171%2C1202.2345%2C1202.5229%2C1202.5509%2C1202.5151%2C1202.1464%2C1202.0430%2C1202.3118%2C1202.1436%2C1202.3572%2C1202.2073%2C1202.3172%2C1202.6157%2C1202.3659%2C1202.0270%2C1202.1663%2C1202.2258%2C1202.3614%2C1202.1700%2C1202.0512%2C1202.3447%2C1202.4080%2C1202.3530%2C1202.4790%2C1202.2426%2C1202.5784%2C1202.1980&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Induced Disjoint Paths in Claw-Free Graphs"}, "summary": "Paths P1,...,Pk in a graph G=(V,E) are said to be mutually induced if for any\n1 <= i < j <= k, Pi and Pj have neither common vertices nor adjacent vertices\n(except perhaps their end-vertices). The Induced Disjoint Paths problem is to\ntest whether a graph G with k pairs of specified vertices (si,ti) contains k\nmutually induced paths Pi such that Pi connects si and ti for i=1,...,k. We\nshow that this problem is fixed-parameter tractable for claw-free graphs when\nparameterized by k. Several related problems, such as the k-in-a-Path problem,\nare proven to be fixed-parameter tractable for claw-free graphs as well. We\nshow that an improvement of these results in certain directions is unlikely,\nfor example by noting that the Induced Disjoint Paths problem cannot have a\npolynomial kernel for line graphs (a type of claw-free graphs), unless NP\n\\subseteq coNP/poly. Moreover, the problem becomes NP-complete, even when k=2,\nfor the more general class of K_1,4-free graphs. Finally, we show that the\nn^O(k)-time algorithm of Fiala et al. for testing whether a claw-free graph\ncontains some k-vertex graph H as a topological induced minor is essentially\noptimal by proving that this problem is W[1]-hard even if G and H are line\ngraphs.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1202.0364%2C1202.5682%2C1202.0456%2C1202.0546%2C1202.0837%2C1202.6578%2C1202.5557%2C1202.1726%2C1202.3831%2C1202.4707%2C1202.1317%2C1202.2805%2C1202.4985%2C1202.3019%2C1202.1732%2C1202.1770%2C1202.2464%2C1202.3326%2C1202.2281%2C1202.4305%2C1202.6277%2C1202.0513%2C1202.0312%2C1202.2466%2C1202.4743%2C1202.6563%2C1202.2223%2C1202.4038%2C1202.0109%2C1202.3595%2C1202.2652%2C1202.2087%2C1202.5080%2C1202.4807%2C1202.2188%2C1202.0644%2C1202.4143%2C1202.3104%2C1202.2419%2C1202.0732%2C1202.4606%2C1202.4064%2C1202.3187%2C1202.1782%2C1202.0219%2C1202.1172%2C1202.4981%2C1202.6057%2C1202.5071%2C1202.3793%2C1202.3505%2C1202.0813%2C1202.4750%2C1202.5738%2C1202.2638%2C1202.0009%2C1202.4419%2C1202.4942%2C1202.3383%2C1202.4381%2C1202.5857%2C1202.4116%2C1202.5832%2C1202.2835%2C1202.0555%2C1202.1086%2C1202.4837%2C1202.3059%2C1202.4412%2C1202.1962%2C1202.2278%2C1202.2687%2C1202.4259%2C1202.3811%2C1202.5171%2C1202.2345%2C1202.5229%2C1202.5509%2C1202.5151%2C1202.1464%2C1202.0430%2C1202.3118%2C1202.1436%2C1202.3572%2C1202.2073%2C1202.3172%2C1202.6157%2C1202.3659%2C1202.0270%2C1202.1663%2C1202.2258%2C1202.3614%2C1202.1700%2C1202.0512%2C1202.3447%2C1202.4080%2C1202.3530%2C1202.4790%2C1202.2426%2C1202.5784%2C1202.1980&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Paths P1,...,Pk in a graph G=(V,E) are said to be mutually induced if for any\n1 <= i < j <= k, Pi and Pj have neither common vertices nor adjacent vertices\n(except perhaps their end-vertices). The Induced Disjoint Paths problem is to\ntest whether a graph G with k pairs of specified vertices (si,ti) contains k\nmutually induced paths Pi such that Pi connects si and ti for i=1,...,k. We\nshow that this problem is fixed-parameter tractable for claw-free graphs when\nparameterized by k. Several related problems, such as the k-in-a-Path problem,\nare proven to be fixed-parameter tractable for claw-free graphs as well. We\nshow that an improvement of these results in certain directions is unlikely,\nfor example by noting that the Induced Disjoint Paths problem cannot have a\npolynomial kernel for line graphs (a type of claw-free graphs), unless NP\n\\subseteq coNP/poly. Moreover, the problem becomes NP-complete, even when k=2,\nfor the more general class of K_1,4-free graphs. Finally, we show that the\nn^O(k)-time algorithm of Fiala et al. for testing whether a claw-free graph\ncontains some k-vertex graph H as a topological induced minor is essentially\noptimal by proving that this problem is W[1]-hard even if G and H are line\ngraphs."}, "authors": ["Petr A. Golovach", "Daniel Paulusma", "Erik Jan van Leeuwen"], "author_detail": {"name": "Erik Jan van Leeuwen"}, "author": "Erik Jan van Leeuwen", "arxiv_comment": "Minor revision. Submitted to journal", "links": [{"href": "http://arxiv.org/abs/1202.4419v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1202.4419v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1202.4419v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1202.4419v2", "journal_reference": null, "doi": null, "fulltext": "Induced Disjoint Paths in Claw-Free Graphs\u22c6\nPetr A. Golovach1, Dani\u00ebl Paulusma2, and Erik Jan van Leeuwen3\n\narXiv:1202.4419v2 [cs.DM] 6 Mar 2014\n\n1\n\n2\n\nDepartment of informatics, University of Bergen, Norway\npetr.golovach@ii.uib.no\nSchool of Engineering and Computer Science, Durham University, UK\ndaniel.paulusma@durham.ac.uk\n3\nMax-Planck Institut f\u00fcr Informatik, Saarbr\u00fccken, Germany,\nerikjan@mpi-inf.mpg.de\n\nAbstract. Paths P1 , . . . , Pk in a graph G = (V, E) are said to be mutually induced if for any 1 \u2264 i < j \u2264 k, Pi and Pj have neither common\nvertices nor adjacent vertices (except perhaps their end-vertices). The\nInduced Disjoint Paths problem is to test whether a graph G with\nk pairs of specified vertices (si , ti ) contains k mutually induced paths\nPi such that Pi connects si and ti for i = 1, . . . , k. We show that this\nproblem is fixed-parameter tractable for claw-free graphs when parameterized by k. Several related problems, such as the k-in-a-Path problem, are proven to be fixed-parameter tractable for claw-free graphs as\nwell. We show that an improvement of these results in certain directions\nis unlikely, for example by noting that the Induced Disjoint Paths\nproblem cannot have a polynomial kernel for line graphs (a type of clawfree graphs), unless NP \u2286 coNP/poly. Moreover, the problem becomes\nNP-complete, even when k = 2, for the more general class of K1,4 -free\ngraphs. Finally, we show that the nO(k) -time algorithm of Fiala et al. for\ntesting whether a claw-free graph contains some k-vertex graph H as\na topological induced minor is essentially optimal by proving that this\nproblem is W[1]-hard even if G and H are line graphs.\n\n1\n\nIntroduction\n\nThe problem of finding disjoint paths of a certain type in a graph has received\nconsiderable attention in recent years. The regular Disjoint Paths problem is\nto test whether a graph G with k pairs of specified vertices (si , ti ) contains a\nset of k mutually vertex-disjoint paths P1 , . . . , Pk such that Pi has end-vertices\nsi and ti for i = 1, . . . , k. The subgraph of G induced by the vertices of these\npaths is called a linkage. This problem is included in Karp's list of NP-compete\nproblems [27], provided that k is part of the input. If k is any fixed integer,\nthat is, not part of the input, the problem is called k-Disjoint Paths and\n\u22c6\n\nThis work is supported by EPSRC (EP/G043434/1) and Royal Society (JP100692).\nThe research leading to these results has also received funding from the European Research Council under the European Union's Seventh Framework Programme\n(FP/2007-2013) / ERC Grant Agreement n. 267959. A preliminary version of this\npaper appeared as an extended abstract in the proceedings of ESA 2012 [20].\n\n1\n\n\fcan be solved in O(n3 ) time for n-vertex graphs, as shown by Robertson and\nSeymour [37] in one of their keystone papers on graph minor theory.\nIn this paper, we study a generalization of the Disjoint Paths problem\nby considering its induced version. We say that paths P1 , . . . , Pk in a graph\nG = (V, E) are mutually induced if for any 1 \u2264 i < j \u2264 k, Pi and Pj have neither\ncommon vertices, i.e. V (Pi ) \u2229 V (Pj ) = \u2205, nor adjacent vertices, i.e. uv \u2208\n/ E for\nany u \u2208 V (Pi ), v \u2208 V (Pj ), except perhaps their end-vertices. The subgraph of G\ninduced by the vertices of such paths is called an induced linkage. We observe that\nthe paths P1 , . . . , Pk are not required to be induced paths in G. However, this\nmay be assumed without loss of generality, because we can replace non-induced\npaths by shortcuts.\nWe can now define the following problem, where we call the vertex pairs\nspecified in the input terminal pairs and their vertices terminals.\nInduced Disjoint Paths\nInstance: a graph G with k terminal pairs (si , ti ) for i = 1, . . . , k.\nQuestion: does G contain k mutually induced paths Pi such that Pi connects\nterminals si and ti for i = 1, . . . , k?\nWhen k is fixed, we call this the k-Induced Disjoint Paths problem.\nObserve that the Induced Disjoint Paths problem can indeed be seen as\na generalization of the Disjoint Paths problem, since the latter can be reduced\nto the former by subdividing every edge of the graph. This generalization makes\nthe problem significantly harder. In contrast to the original, non-induced version,\nthe k-Induced Disjoint Paths problem is NP-complete even for k = 2 [2,12].\nThe hardness of the k-Induced Disjoint Paths problem motivates an investigation into graph classes for which it may still be tractable. Below, we briefly\nsurvey existing results.\n1.1\n\nKnown Results for Special Graph Classes\n\nFor planar graphs, Induced Disjoint Paths stays NP-complete, as it generalizes Disjoint Paths for planar graphs, which is NP-complete as shown by\nLynch [33]. However, Kobayashi and Kawarabayashi [30] presented an algorithm\nfor k-Induced Disjoint Paths on planar graphs that runs in linear time for\nany fixed k, improving on an earlier algorithm by Reed, Robertson, Schrijver and\nSeymour [36]. For AT-free graphs [19] and chordal graphs [1], Induced Disjoint\nPaths is polynomial-time solvable, whereas the problem is linear-time solvable\nfor circular-arc graphs [18].\nFor claw-free graphs (graphs where no vertex has three pairwise nonadjacent\nneighbors), Fiala et al. [14] showed that the Induced Disjoint Paths problem\nis NP-complete. They showed that this holds even for line graphs, a subclass\nof the class of claw-free graphs. They also gave a polynomial-time algorithm\nfor k-Induced Disjoint Paths for any fixed k. Their approach is based on a\nmodification of the claw-free input graph to a special type of claw-free graph,\nnamely to a quasi-line graph, in order to use the characterization of quasi-line\ngraphs by Chudnovsky and Seymour [5]. This transformation may require \u03a9(n2k )\n2\n\n\ftime due to some brute-force guessing, in particular as claw-freeness must be\npreserved.\n1.2\n\nRelated Problems\n\nA study on induced disjoint paths can also be justified from another direction,\none that focuses on detecting induced subgraphs such as cycles, paths, and trees\nthat contain some set of k specified vertices, which are also called terminals. The\ncorresponding decision problems are called k-in-a-Cycle, k-in-a-Path, and kin-a-Tree, respectively. These problems are closely related to each other and\nto the k-Induced Disjoint Paths problem.\nFor general graphs, even the problems 2-in-a-Cycle and 3-in-a-Path are\nNP-complete [2,12], whereas the k-in-a-Tree problem is polynomial-time solvable for k = 3 [6], open for any fixed k \u2265 4, and NP-complete when k is part of\nthe input [8]. Several polynomial-time solvable cases are known for graph classes,\nsee e.g. [9,19,29,32,36]. For claw-free graphs, the problems k-in-a-Tree and kin-a-Path are equivalent and polynomial-time solvable for any fixed integer\nk [14]. Consequently, the same holds for the k-in-a-Cycle problem [14].\nAs a final motivation for our work, we note that just as disjoint paths are\nimportant for (topological) graph minors, one may hope that induced disjoint\npaths are useful for finding induced (topological) minors in polynomial time\non certain graph classes. Whereas the problems of detecting whether a graph\ncontains some fixed graph H as a minor or topological minor can be solved\nin cubic time for any fixed graph H [21,37], the complexity classifications of\nboth problems with respect to some fixed graph H as induced minor or induced\ntopological minor are still wide open. So far, only partial results [13,16,31], which\nconsist of both polynomial-time solvable and NP-complete cases, are known for\nthe latter two problems on general graphs. In contrast, Fiala et al. [14] use their\nalgorithm for the k-Induced Disjoint Paths problem to obtain an nO(k) -time\nalgorithm that solves the problem of testing whether a claw-free graph G on n\nvertices contains a graph H on k vertices as a topological induced minor. This\nproblem is also called the Induced Topological Minor problem. For fixed\ngraphs H, the Induced Topological Minor problem is also known to be\npolynomial-time solvable for AT-free graphs [19] and chordal graphs [1]. When\nparameterized by |V (H)|, it has been proven to be W[1]-hard for cobipartite\ngraphs [19] (which form a subclass of AT-free graphs) and for split graphs [17]\n(which form a subclass of chordal graphs).\n1.3\n\nOur Results\n\nWe provide new insights into the computational complexity of the Induced\nDisjoints Paths problem and the related problems k-in-a-Path and Induced\nTopological Minor for claw-free and line graphs.\nIn Section 3 we improve on the aforementioned result of Fiala et al. [14] by\nshowing that Induced Disjoint Paths is fixed-parameter tractable on clawfree graphs when parameterized by the number of terminal pairs k, that is, can\n3\n\n\fbe solved in time f (k)nO(1) on n-vertex claw-free graphs with k terminal pairs,\nwhere f is some computable function f that only depends on k. Our approach\ncircumvents the time-consuming transformation to quasi-line graphs of Fiala et\nal. [14], and is based on an algorithmic application of the characterization for\nclaw-free graphs by Chudnovsky and Seymour. Hermelin et al. [25] recently applied such an algorithmic structure theorem to Dominating Set on claw-free\ngraphs. However, their algorithm reduces the strip-structure to have size polynomial in k and then follows an exhaustive enumeration strategy. For k-Induced\nDisjoint Paths, such an approach seems unsuitable, and our arguments thus\ndiffer substantially from those in [25].\nIn Section 3 we also prove that the problems k-in-a-Path (or equivalently\nk-in-a-Tree) and k-in-a-Cycle are fixed-parameter tractable when parameterized by k. This gives some answer to an open question of Bruhn and Saito [4].\nThey gave necessary and sufficient conditions for the existence of a path through\nthree given vertices in a claw-free graph and asked whether such conditions also\nexist for k-in-a-Path with k \u2265 4. However, as this problem is NP-complete even\nfor line graphs when k is part of the input [14], showing that it is fixed-parameter\ntractable may be the best answer we can hope for.\nRecall that Fiala et al. [14] gave an nO(k) -time algorithm for testing whether a\nclaw-free graph G on n vertices contains a graph H on k vertices as a topological\ninduced minor. We prove in Section 5 that Induced Topological Minor is\nW[1]-hard when parameterized by |V (H)|, even if G and H are line graphs.\nThis means that this problem is unlikely to be fixed-parameter tractable for this\ngraph class.\nIn Section 5 we also show that our results for the Induced Disjoint Paths\nproblem for claw-free graphs are best possible in the following ways. First,\nwe show that the problem does not allow a polynomial kernel even for line\ngraphs, unless NP \u2286 coNP/poly. Second, we observe that a result from Derhy\nand Picouleau [8] immediately implies that 2-Induced Disjoint-Paths is NPcomplete on K1,4 -free graphs (graphs in which no vertex has four pairwise nonadjacent neighbors). We also state some related open problems in this section.\n\n2\n\nPreliminaries\n\nBasic Graph Terminology. We only consider finite undirected graphs that\nhave no loops and no multiple edges. We refer to the text-book of Diestel [11]\nfor any standard graph terminology not used in our paper.\nFor a subset S \u2286 V , the graph G[S] denotes the subgraph of G = (V, E)\ninduced by S, that is, the graph with vertex set S and edge set {uv \u2208 E | u, v \u2208\nS}. We write G \u2212 S = G[V \\ S]. For a vertex u and a subgraph F of G that does\nnot contain u we write F + u = G[VF \u222a {u}]. We call the vertices v1 and vr of a\npath P = v1 * * * vr the ends or end-vertices of P .\nAn independent set in a graph G is a set of vertices that are mutually nonadjacent. We denote the maximum size of an independent set in a graph G by\n\u03b1(G). A clique in a graph G is a set of vertices that are mutually adjacent.\n4\n\n\fLet G = (V, E) be a graph. We denote the (open) neighborhood of a vertex u\nby NG (u) = {v | uv \u2208 E} and its closed neighborhood by NG [u] = NG (u) \u222a {u}.\nWe denote the neighborhood of a set U \u2286 V by NG (U ) = {v \u2208 V \\ U | uv \u2208\nE for some u \u2208 U }, and NG [U ] = U \u222a NG (U ). We omit indices if it does not\ncreate confusion.\nGraph Operations and Containment Relations. Let e = uv be an edge in\na graph G. The edge contraction of e removes u and v from G, and replaces them\nby a new vertex adjacent to precisely those vertices to which u or v were adjacent.\nIn the case that one of the two vertices, say u, has exactly two neighbors that in\naddition are nonadjacent, then we call this operation the vertex dissolution of u.\nLet G and H be two graphs. Then G contains H as an induced minor or\ninduced topological minor if G can be modified into H by a sequence of edge\ncontractions and vertex deletions, or vertex dissolutions and vertex deletions,\nrespectively.\nThe problems Induced Minor and Induced Topological Minor are to\ntest whether a graph G contains a graph H as an induced minor or induced topological minor, respectively. Both problems are NP-complete even when G and H\nare restricted to be line graphs [15]. Hence, it is natural to study the computational complexity after excluding the graph H from the input; when H is fixed\nthe problems are denoted H-Induced Minor and H-Induced Topological\nMinor.\nThe edge subdivision operation replaces an edge vw in a graph G by a new\nvertex u with edges uv and uw. A graph H \u2032 is a subdivision of a graph H if\nH can be modified into H \u2032 by a sequence of edge subdivisions. We note that\nan edge subdivision is the \"dual\" operation of a vertex dissolution. Hence, a\ngraph G contains a graph H as an induced topological minor if and only if G\ncontains an induced subgraph that is isomorphic to a subdivision of H. This\nalternative definition brings us to the following variant. Let G be a graph in\nwhich we specify k distinct vertices ordered as u1 , . . . , uk . Let H be a k-vertex\ngraph, the vertices of which are ordered as x1 , . . . , xk . Then G contains H as\nan induced topological minor anchored in u1 , . . . , uk if G contains an induced\nsubgraph isomorphic to a subdivision of H such that the isomorphism maps ui to\nxi for i = 1, . . . , k. The corresponding decision problem is called the Anchored\nInduced Topological Minor problem.\nMutually Induced Paths. In the remainder of our paper we consider a slight\ngeneralization of the standard definition given in Section 1. We say that paths\nP1 , . . . , Pk in a graph G = (V, E) are mutually induced if\n(i) each Pi is an induced path in G;\n(ii) any distinct Pi , Pj may only share vertices that are ends of both paths;\n(iii) no inner vertex u of any Pi is adjacent to a vertex v of some Pj for j 6= i,\nexcept when v is an end-vertex of both Pi and Pj .\nThis more general definition is exactly what we need later when detecting induced topological minors. In particular, this definition allows terminal pairs\n(s1 , t1 ), . . . , (sk , tk ) to have the following two properties:\n5\n\n\f1) for all i < j, a terminal of (si , ti ) may be adjacent to a terminal of (sj , tj );\n2) for all i < j, it holds that 0 \u2264 |{si , ti } \u2229 {sj , tj }| \u2264 1.\nProperty 2 means that terminal pairs may overlap but not coincide, that is, the\nset of terminal pairs is not a multiset. This suffices for our purposes regarding\ndetecting induced paths or cycles through specified vertices and detecting socalled anchored induced topological minors, as we will explain later.\nFor the remainder of the paper, we assume that the input of Induced Disjoint Paths consists of a graph G with a set of terminal pairs (s1 , t1 ), . . . , (sk , tk )\nhaving Properties 1 and 2, and that the desired output is a set of paths P1 , . . . , Pk\nthat are mutually induced, such that Pi has end-vertices si and ti for i = 1, . . . , k.\nWe say that Pi is the si ti -path and also call it a solution path. We still call the\nsubgraph of G induced by the vertices of such paths an induced linkage and say\nthat it forms a solution for G.\nWe observe that for general graphs, we can easily transform the variant with\nadjacent terminals or overlapping terminals pairs to the variant with neither adjacent terminals nor overlapping terminal pairs. First, adjacent terminals can be\navoided by subdividing the edge between them. Second, a vertex u representing\nl \u2265 2 terminals can be replaced by l new mutually non-adjacent vertices, each\nconnected to all neighbors of u via subdivided edges; even a situation with coinciding terminal pairs can be processed in this way. Third, let us recall that we\nmay without loss of generality assume that every path Pi is induced. However,\nthese operations might not preserve claw-freeness, and hence we need different\ntechniques in this paper (as we show later).\nOur algorithm in Section 3 makes use of the aforementioned result of Robertson and Seymour on the k-Disjoint Paths problem.\nLemma 1 ([37]). For any fixed integer k, the k-Disjoint Paths problem is\nsolvable in O(n3 ) time for n-vertex graphs.\nWe also need the following terminology. Let G = (V, E) be a graph with\nterminal pairs (s1 , t1 ), . . . , (sk , tk ). By Property 2, a vertex v can be a terminal\nin more than one terminal pair, e.g., v = si and v = sj is possible for some i 6= j.\nFor clarity reasons, we will view si and sj as two different terminals placed on\nvertex v. We then say that a vertex u \u2208 V represents terminal si or ti if u = si or\nu = ti , respectively. We call such a vertex a terminal vertex; the other vertices\nof G are called non-terminal vertices. We let Tu denote the set of terminals\nrepresented by u and observe that |Tu | \u2265 2 is possible. We call two terminals\nthat belong to the same terminal pair partners. We note that two partners may\nbe represented by the same vertex, that is, si and ti may belong to Tu for some\nu\u2208V.\nFor our algorithm to work we first need to apply certain preprocessing operations. To this end, we introduce the following notation. Let G be a graph\nthat together with terminal pairs (s1 , t1 ), . . . , (sk , tk ) forms an instance I1 of the\nInduced Disjoint Paths problem. We say that an instance I2 that consists\nof a graph G\u2032 with terminal pairs (s\u20321 , t\u20321 ), . . . , (s\u2032k\u2032 , t\u2032k\u2032 ) is equivalent to the first\ninstance if the following three conditions hold:\n6\n\n\f(i) k \u2032 \u2264 k;\n(ii) |V (G\u2032 )| \u2264 |V (G)|;\n(iii) I2 is a Yes-instance if and only if I1 is a Yes-instance.\nWe say that an operation that transforms an instance of Induced Disjoint\nPaths into a new instance preserves the solution if the new instance is equivalent\nto the original instance. Most operations in our algorithm will be deletions of\nnon-terminal vertices. In such cases preserving the solution just comes down to\nchecking if the new instance still has a solution whenever the original instance\nhas one.\nIn our algorithm, we sometimes have to solve the Induced Disjoint Paths\nproblem on a graph that contain no terminals as a subproblem. We consider\nsuch instances Yes-instances (that have an empty solution).\nGraph Classes. The graph K1,k denotes the star with k rays. In particular, the\ngraph K1,3 = ({a1 , a2 , a3 , b}, {a1 b, a2 b, a3 b}) is called a claw. A graph is K1,k -free\nif it has no induced subgraph isomorphic to K1,k . If k = 3, then we usually call\nsuch a graph claw-free.\nThe line graph of a graph G with edges e1 , . . . , ep is the graph L(G) with\nvertices u1 , . . . , up such that there is an edge between any two vertices ui and uj\nif and only if ei and ej share one end vertex in G. Every line graph is claw-free.\nWe call G the preimage of L(G). It is well known that every connected line graph\nexcept K3 has a unique preimage (see e.g. [24]).\nAs a subroutine of our algorithm in Section 3, we must compute the preimage\nof a line graph. For doing this we can use the linear-time algorithm of Roussopoulos [38].\nLemma 2 ([38]). There exist an O(max{m, n}) algorithm for determining the\npreimage from a line graph G on n vertices and m edges.\nWe also need the following lemma (see e.g. Ryj\u00e1\u010dek [39], who showed that a\ngraph as in the lemma statement even has a triangle-free preimage).\nLemma 3. Every graph in which the neighborhood of every vertex induces a\ndisjoint union of at most two cliques is a line graph.\nA graph is an interval graph if intervals of the real line can be associated with\nits vertices such that two vertices are adjacent if and only if their corresponding\nintervals intersect. An interval graph is proper if it has an interval representation\nin which no interval is properly contained in any other interval. Analogously, we\ncan define the class of circular-arc graphs and proper circular-arc graphs by\nconsidering a set of intervals (arcs) on the circle instead of a real line. Proper\ninterval graphs and proper circular-arc graphs are also known as linear interval\ngraphs and circular interval graphs, respectively (cf. [14]). Note that proper\ncircular-arc graphs are claw-free. We will use the following lemma due to Deng,\nHell and Huang [7].\nLemma 4 ([7]). Proper circular-arc graphs can be recognized in linear time. A\ncorresponding interval representation of such graphs can be constructed in linear\ntime as well.\n7\n\n\fWe also need the following result due to Golovach et al. [18].4\nLemma 5 ([18]). The Induced Disjoint Paths problem can be solved in\nO(n + m + k) time on circular-arc graphs on n vertices and m edges with k\nterminal pairs.\nStructure of Claw-Free Graphs. Chudnovsky and Seymour have given a\nstructural characterization for claw-free graphs, the proof of which can be found\nin a series of seven papers called Claw-free graphs I through VII. We refer to\ntheir survey [5] for a summary. Hermelin et al. [25] gave an algorithmic version\nof their result. This version plays an important role in the proof of our main\nresult in Section 3. In order to state it we need some additional terminology.\nTwo adjacent vertices u and v in a graph G are called (true) twins if they\nshare the same neighbors, i.e. N [u] = N [v]. The equivalence classes of the twin\nrelation are called twin sets.\nThe following result is implicit in a paper by Habib, Paul and Viennot [23].\nLemma 6 ([23]). The problem of detecting all twin sets in an n-vertex graph\nwith m edges is solvable in O(n + m) time.\nTwo disjoint cliques A and B form a proper W-join in a graph G if |A| \u2265 2,\n|B| \u2265 2, every vertex v \u2208 V (G) \\ (A \u222a B) is either adjacent to all vertices of A\nor to no vertex of A, every vertex in A is adjacent to at least one vertex in B\nand non-adjacent to at least one vertex in B, and the above also holds with A\nand B reversed.\nWe need the following result by King and Reed [28].\nLemma 7 ([28]). The problem of detecting a proper W-join in an n-vertex\ngraph with m edges is solvable in O(n2 m) time.\nA hypergraph is a pair R = (VR , ER ) where VR is a set of elements called\nvertices and ER is a collection of subsets of VR called hyperedges. Two hyperedges\ne1 and e2 are parallel if they contain the same vertices of VR . Graphs can be\nseen as hypergraphs in which all hyperedges have size two.\nA strip-structure (R, {(Je , Ze ) | e \u2208 E(R)}) for a claw-free graph G is a\nhypergraph R, with possibly parallel and empty hyperedges, and a set of tuples\n(Je , Ze ) for each e \u2208 E(R) called strips such that\n\u2022 Je is a claw-free graph and Ze \u2286 V (Je ),\n\u2022 {V (Je ) \\ Ze | e \u2208 E(R)} is a partition of V (G) and each V (Je ) \\ Ze is\nnonempty,\n\u2022 Je [V (Je ) \\ Ze ] equals G[V (Je ) \\ Ze ],\n\u2022 each v \u2208 e corresponds to a unique\nS zv \u2208 Ze and vice versa.\n\u2022 for each v \u2208 V (R), the set Cv := zv \u2208Ze :v\u2208e NJe (zv ) induces a clique in G,\n4\n\nIt should be noted that our algorithm for claw-free graphs will only apply Lemma 5\nfor proper circular-arc graphs, and for those graphs we already showed that Induced\nDisjoint Paths is linear-time solvable in the extended abstract of this paper [20].\n\n8\n\n\f\u2022 each edge of G is either in G[Cv ] for some v \u2208 V (R) or in Je [V (Je ) \\ Ze ] for\nsome e \u2208 E(R).\nNote that a vertex v \u2208 V (R) may be in more than one hyperedge of R, say v\nbelongs to e1 , . . . , er for some r \u2265 1. Then v corresponds to some unique vertex\nzv (ei ) in every Zei , and the union of the neighbors of these z-vertices form a\nclique in G. When there is no confusion about e, we drop the subscript e and\njust talk about strips (J, Z).\nA strip (J, Z) is called a stripe if the vertices of Z are pairwise nonadjacent\nand any vertex in V (J) \\ Z is adjacent to at most one vertex of Z. A strip (J, Z)\nis called a spot if J is a three-vertex path and Z consists of both ends of this\npath.\nWe can now state the required lemma, which is easily derived from Lemma C.20\nin [26] or Theorem 1 in [25].\nLemma 8 ([25,26]). Let G be a connected claw-free graph, such that G does\nnot admit twins or proper W-joins and \u03b1(G) > 4. Then either\n1. G is a proper circular-arc graph, or\n2. G admits a strip-structure such that each strip (J, Z) either is\n(a) a spot, or\n(b) a stripe with |Z| = 1 and J is proper circular-arc or has \u03b1(J) \u2264 3, or\n(c) a stripe with |Z| = 2, and J is proper interval or has \u03b1(J) \u2264 4.\nMoreover, it is possible to distinguish the cases and to find the strip-structure in\npolynomial time.\nParameterized Complexity Theory. In this theory, we consider the problem\ninput as a pair (I, k), where I is the main part and k the parameter. A problem \u03a0\nis fixed-parameter tractable if an instance (I, k) can be solved in time O(f (k)|I|c ),\nwhere f denotes a computable function and c a constant independent of k. A\nreduced instance (I \u2032 , k \u2032 ) of a problem \u03a0 for an instance (I, k) of \u03a0 is called a\nkernel if the following three conditions hold:\n(i) k \u2032 \u2264 k and |I \u2032 | \u2264 g(k) for some computable function g;\n(ii) the reduction from (I, k) to (I \u2032 , k \u2032 ) is computable in polynomial time;\n(iii) (I, k) is a Yes-instance of \u03a0 if and only if (I \u2032 , k \u2032 ) is a Yes-instance of \u03a0.\nThe upper bound g(k) of |I \u2032 | is called the kernel size. It is well known that a\nparameterized problem is fixed-parameter tractable if and only if it is decidable and kernelizable (cf. [35]). In the latter case, the next step is to research\nwhether the problem has a polynomial kernel, that is, allows a kernel size which\nis polynomial in k. We refer to the monographs of Downey and Fellows [10] and\nNiedermeier [35] for more on the theory of parameterized complexity.\n9\n\n\f3\n\nMutually Induced Disjoint Paths\n\nIn this section we present the following result.\nTheorem 1. The Induced Disjoint Paths problem is fixed-parameter tractable\non claw-free graphs when parameterized by k.\nBelow, we outline the general approach of our algorithm, and then give the\ndetails of the subroutines that we use. First, we need some definitions. Let G be a\ngraph with terminal pairs (s1 , t1 ), . . . (sk , tk ) that forms an instance of Induced\nDisjoint Paths. We call this instance claw-free, twin-free, or proper W-joinfree if G is claw-free, twin-free, or proper W-join-free, respectively. In addition,\nwe call the instance independent if the terminal vertices form an independent\nset, and no terminal vertex represents two terminals of the same terminal pair.\nNote that in this definition it is still possible for a terminal vertex to represent\nmore than one terminal. However, no terminal vertex in an independent instance\ncan represent more than two terminals if the instance has a solution and G is\nclaw-free. Otherwise, any solution would induce a claw in the neighborhood of\nthis terminal vertex.\nIn our algorithm, it may happen that the graph under consideration gets\ndisconnected. In that case we make the following implicit check. We stop considering this graph if there is a terminal pair of which the terminals are in two\ndifferent connected components. Otherwise we consider each connected component separately. Hence, we may assume that the graph is connected.\nThe Algorithm and Proof of Theorem 1\nLet a claw-free graph G on n vertices with terminal pairs (s1 , t1 ), . . . , (sk , tk ) for\nsome k \u2265 1 form an instance.\nStep 1. Reduce to an independent instance.\nWe apply Lemma 9 (stated later) and obtain in O(k 2 n) time an independent and\nequivalent instance that consists of a claw-free graph with at most k terminal\npairs. For simplicity, we denote this graph and these terminals pairs by G and\n(s1 , t1 ),. . ., (sk , tk ) as well.\nStep 2. Solve the problem if \u03b1 is small.\nBecause all terminal vertices are independent, we find that k \u2264 \u03b1(G) holds.\nHence, if \u03b1(G) \u2264 4, we can solve the problem by applying the aforementioned\nnO(k) time algorithm of Fiala et al. [14]. From now on we assume that \u03b1(G) > 4.\nStep 3. Remove twins.\nWe apply Lemma 10 and obtain in linear time an independent and equivalent\ninstance that consists of a claw-free, twin-free graph with the same k terminal\npairs as before. For simplicity, we denote the new graph by G as well.\nStep 4. Remove proper W-joins.\nWe apply Lemma 11 and obtain in O(n5 ) time an independent and equivalent\n10\n\n\finstance that consists of a claw-free, twin-free, proper W-join-free graph with\nthe same k terminal pairs as before. For simplicity, we denote the new graph by\nG as well.\nStep 5. Solve the problem for a proper circular-arc graph.\nBy Lemma 4 we can check in linear time if G is a proper circular-arc graph. If\nso, then we apply Lemma 5 to solve the problem in linear time. From now on we\nassume that G is not a circular-arc graph, and hence not a proper circular-arc\ngraph.\nStep 6. Reduce to a collection of line graphs.\nBy Lemma 8 we find in polynomial time a strip-structure of G, in which each\nstrip (J, Z) is either a spot, or a stripe with |Z| = 1, and J is proper circulararc or has \u03b1(J) \u2264 3, or a stripe with |Z| = 2, and J is proper interval or has\n\u03b1(J) \u2264 4. We apply Lemma 12, and in 6k nO(1) time either find that the instance\nhas no solution, or obtain at most 6k line graphs on at most n vertices and with\nat most k terminals each, such that G has a solution if and only if at least one\nof these line graphs has a solution.\nStep 7. Solve the problem for each line graph.\nFor each of the 6k line graphs G\u2032 created we can do this in O(g(k)|VG\u2032 |6 ) time\ndue to Lemma 13. Here, g(k) is a function that only depends on k. We conclude\nthat our algorithm runs in 6k g(k)nO(1) time, as desired.\nTo finish the correctness proof and running time analysis of our algorithm, it\nremains to state and prove the missing lemmas, namely Lemmas 9\u201313. We do\nthis as follows. In Section 3.1 we show Lemmas 9\u201311, which are related to the\npreprocessing of the input graph, that is, which are used in Steps 1\u20134. In Section 3.2 we show Lemma 12, which we used in Step 6 where we obtain a set of\nline graphs. Finally, in Section 3.3 we show Lemma 13, which we used in Step 7\nwhere we solve the problem for line graphs.\n3.1\n\nIndependent, Twin-Free, and Proper W-Join-Free Instances\n\nIn this section we state and prove Lemmas 9\u201311 used in Steps 1,3,4, respectively.\nLemma 9. There is a O(k 2 n)-time algorithm that transforms an instance consisting of an n-vertex claw-free graph G with k terminal pairs into an equivalent\ninstance that is independent and claw-free.\nProof. Let G = (V, E) be a claw-free graph that has terminal pairs (s1 , t1 ),. . .,\n(sk , tk ) for some k \u2265 1.SLet |V | = n, |E| = m, and let T denote the set of all\nterminals, that is, T = u\u2208V Tu .\nWe apply a number of operations on G in order to obtain a new instance that\nconsists of a graph G\u2032 with terminal pairs (s\u20321 , t\u20321 ), . . . , (s\u2032k\u2032 , t\u2032k\u2032 ). These operations\nare of three different types: the first type of operation removes one or more\nnon-terminal vertices from G, the second type of operation only removes one\n11\n\n\for more terminals with their partners from T without modifying G, and the\nthird type of operation removes edges from G. Hence, we will have k \u2032 \u2264 k and\n|V (G\u2032 )| \u2264 |V (G)|. We will prove that the new instance is a Yes-instance if and\nonly if the original instance is by showing that our operations preserve solutions\nand claw-freeness. Afterwards, we will see that the new instance is independent,\nand we will analyze the overall running time.\nThe following four rules describe the operations in detail. They must be\napplied consecutively, starting with Rule 1 and ending with Rule 4.\nRule 1. Remove every non-terminal vertex u from G that is adjacent to two\nadjacent terminal vertices v and w.\nSuch an operation preserves the solution as the removed vertices cannot be part\nof any solution path for G. This can be seen as follows. If v and w represent\nterminals from different pairs, then u cannot be used as (inner) vertex for any\nsolution path. Suppose that v and w each represent a terminal of the same pair,\nsay si \u2208 Tv and ti \u2208 Tw . Then we may assume without loss of generality that\nPi = vw. Since the set of terminal pairs is not a multiset, u cannot be used as an\n(inner) vertex of some other solution path Pj . Because we only removed vertices\nfrom G and claw-free graphs are closed under vertex deletion, the resulting graph\nremains claw-free.\nRule 2. Find the set U of all terminal vertices u such that u only represents\nterminals whose partners are in NG [u]. Remove U and all non-terminal vertices\nof NG (U ) from G. Remove from T the terminals of all terminal pairs (si , ti ) such\nthat si \u2208 Tu or ti \u2208 Tu for u \u2208 U .\nBy the same argument that we used for Rule 1, the resulting graph is claw-free.\nTo show that this rule preserves the solution, we prove first that if the original\ninstance has a solution, then the new instance has a solution. Let Pi be an si ti path in a solution for the original instance with {si , ti } \u2229 Tu = \u2205 for all u \u2208 U .\nThen Pi contains no internal vertices in NG [U ]. Observe also that the terminal\nvertices representing si and ti are not deleted by Rule 2. This means that Pi is\na path in the graph for the new instance. Consequently, the paths Pi for those\nterminal pairs (si , ti ) with {si , ti } \u2229 Tu = \u2205 for all u \u2208 U compose a solution for\nthe new instance.\nAssume now that the new instance has a solution. Let Pi be an si ti -path in\nthe solution, and let x, y be the vertices that represent si , ti respectively. Then\n{si , ti } \u2229 Tu = \u2205 for all u \u2208 U . Let v be an internal vertex of Pi . We show that\nif v is adjacent to a vertex z that represents a terminal in the original instance,\nthen z = x or z = y. Suppose that z \u2208\n/ {x, y}. Since Pi is a path in a solution for\nthe new instance, z does not represent a terminal in the new instance. Therefore,\nz may only represent terminals that were deleted from T using Rule 2. Then z\nis in U , because if it would only represent the partner of terminals that are in\nU , then by the definition of U these partners are all in NG (z) and thus z must\nbelong to U as well. However, as Pi cannot have any internal vertices in NG [U ]\nby Rule 2, z cannot belong to U , a contradiction.\n12\n\n\fNow we can construct the solution for the original instance from the solution\nfor the new instance by adding new paths as follows. For any terminal pair\n(sj , tj ) such that sj , tj are represented by u, v respectively and u \u2208 U or v \u2208 U ,\nlet Pj = u if u = v and let Pj = uv if u 6= v, and add Pj to the solution. Then,\nbecause all paths from the solution to the new instance avoid the neighborhood\nof terminals that were deleted by Rule 2 (as argued above), the constructed set\nof paths is indeed a solution to the original instance.\nRule 3. Remove the terminals of every terminal pair (si , ti ) with si \u2208 Tu for\nsome u \u2208 V (G) and ti \u2208 Tv for some v \u2208 NG [u] from T .\nThis preserves the solution because of the following reasons. If the original instance has a solution, then the new instance has a solution. Now suppose that\nthe new instance has a solution. We extend this solution by adding the path\nPi = u if v = u or Pi = uv otherwise. Because we already applied Rule 2, we\nfind that Tu must contain at least one terminal whose partner is not represented\nby a vertex in NG [u]. In that case, u is only adjacent to inner vertices of other\nsolution paths that start in u. Similarly, if v 6= u, then v is only adjacent to\ninner vertices of other solution paths that start in v. Hence, we may extend the\nsolution of the new instance by the path Pi in order to obtain a solution of the\noriginal instance. The resulting graph is claw-free, as we did not touch G and\nonly modified T .\nRule 4. For every pair of adjacent terminal vertices, remove the edge between\nthem.\nThis preserves the solution, because in this stage two adjacent terminal vertices\ndo not represent two terminals from the same pair; otherwise we would have\napplied Rule 3 already. Now suppose that the resulting graph contains a claw\nwith center u and leaves v, w, x. Because we preserved claw-freeness so far, there\nmust have been an edge between two leaves, say between v and w. This implies\nthat v and w are terminal vertices. Then u must be a non-terminal vertex, as\notherwise we would have removed the edges uv and uw as well. However, this is\nnot possible, because we would have removed u when applying Rule 1. Hence,\nthe resulting graph is claw-free.\nAlready after applying Rule 3, there is no terminal vertex that represents two\nterminals from the same terminal pair. After applying Rule 4, all terminal vertices are independent.\nIt remains to analyze the running time. We assume that the graph is given as\nan adjacency list and an adjacency matrix. Rule 1 can be implemented in O(k 2 n)\ntime: for each pair of adjacent terminal vertices, we check all non-terminal vertices for being a common neighbor. Rule 2 can be implemented in O(k 2 + kn)\ntime: we first find the set U (which has size at most k) in time k 2 and then delete\nU together with the non-terminal vertices of NG (U ) in time O(kn) and modify\nT in time O(k). Rule 3 can be implemented in O(k) time by testing whether the\nterminals in each terminal pair are represented by the same vertex or by two\nadjacent vertices. Rule 4 can be implemented in O(k 2 ) time by testing whether\n13\n\n\fany two terminals from different terminal pairs are represented by adjacent vertices. We conclude that the total running time is O(k 2 n). This completes the\nproof of Lemma 9.\n\u2293\n\u2294\nLemma 10. There is a linear-time algorithm that transforms an independent\ninstance consisting of an n-vertex, claw-free graph G with k terminal pairs into\nan equivalent instance that is independent, claw-free, and twin-free.\nProof. Let G = (V, E) be a claw-free graph on n vertices with k terminal pairs\n(s1 , t1 ), . . . , (sk , tk ) for some k \u2265 1 that forms an independent instance. We first\nfind all twin sets of G in linear time using Lemma 6. Let A be a twin set of size\nat least two. Because the terminal vertices form an independent set, at most one\nvertex of A is a terminal vertex. If one vertex of A, say u, is a terminal vertex,\nthen we remove A \\ {u} from G. In the other case, i.e. if A does not contain\na terminal vertex, we arbitrarily choose a vertex v from A and remove A \\ {v}\nfrom G. In both cases we preserve the solution, because all removed vertices are\nnon-terminal vertices that cannot occur as an (inner) vertex in a solution path\nof a solution for G. We let G\u2032 denote the twin-free graph obtained after applying\nthis operation as long as possible.\nBecause we only removed non-terminal vertices, we find that G\u2032 has the same\nset of k terminals, which still form an independent set. Moreover, |V (G\u2032 )| \u2264\n|V (G)| holds. Because G is claw-free and the class of claw-free graphs is closed\nunder vertex deletion, we find that G\u2032 is claw-free. Clearly, the above procedure\nruns in linear time. This completes the proof of Lemma 10.\n\u2293\n\u2294\nLemma 11. There is an O(n5 )-time algorithm that transforms an independent\ninstance consisting of an n-vertex, claw-free, twin-free graph G with k terminal\npairs into an equivalent instance that is independent, claw-free, twin-free, and\nproper W-join-free.\nProof. Let G = (V, E) be a claw-free, twin-free graph on n vertices with k\nterminal pairs (s1 , t1 ), . . . , (sk , tk ) for some k \u2265 1 that forms an independent\ninstance. Because of the latter property, every clique in every proper W-join\nin G contains at most one terminal vertex. This means that we only have to\ndistinguish between the following four cases for every proper W-join (A, B). In\nthis case analysis, we also assume that every terminal vertex represents at most\ntwo terminals, because our instance is independent and G is claw-free.\nCase 1. At least one of A, B, say A, contains a terminal vertex u that represents\nexactly two terminals.\nWe remove all vertices of A \\ {u} from G. This preserves the solution, which\ncan be seen as follows. Let (si , ti ) and (sj , tj ) be the two terminal pairs with a\nterminal represented by u. Without loss of generality, u represents si and sj . Let\nv 6= u be a vertex of A. Suppose that we have a solution for G that has a solution\npath P containing v. By the definition of a solution, P must have u as one of\nits two end-vertices. Then we may assume without loss of generality that P is\nthe si ti -path. Let w 6= u be the other neighbor of v on P . This neighbor exists,\n14\n\n\fbecause v is not a terminal vertex. Since every vertex not in A \u222a B is either\nadjacent to all vertices of A or to none of them, w must be in B; otherwise P is\nnot induced.\nNow consider the solution path P \u2032 of this solution that connects terminals sj\nand tj . Because u represents sj , we find that P \u2032 also starts in u. Since sj and tj\nare represented by two different non-adjacent vertices, we find that the neighbor\nof u on P \u2032 is an inner vertex of P \u2032 . Let v \u2032 be this neighbor. If v \u2032 \u2208 V \\ (A \u222a B),\nthen v \u2032 is adjacent to v by the definition of a proper W -join. This is not possible,\nbecause inner vertices of two different solution paths are not adjacent. For exactly\nthe same reason we find that v \u2032 \u2208\n/ A. Hence, v \u2032 \u2208 B. But then v \u2032 and w are\nadjacent. This is not possible either by the definition of a solution. We conclude\nthat removing all vertices in A \\ {u} preserves the solution. As A now has size\n1, (A, B) is no longer a proper W-join.\nCase 2. The cliques A and B each have exactly one terminal vertex u and v,\nrespectively, that each represent exactly one terminal.\nFirst suppose that the two terminals represented by u and v are from different\nterminal pairs. We assume without loss of generality that u represents terminal\nsi and that v represents terminal sj , where i 6= j. We remove all vertices of\nA \\ {u} from G. We claim that this preserves the solution. In order to obtain a\ncontradiction, assume that we have a solution for G that has a solution path P\ncontaining a vertex w \u2208 A \\ {u}. Because u and w both belong to A, they are\nadjacent. Hence, P must be the si ti -path. Because terminal vertices are nonadjacent and u is a terminal vertex, w is not a terminal vertex. This means\nthat w has a neighbor w\u2032 6= u on P . If w\u2032 \u2208 A, then P is not induced. Also\nif w\u2032 \u2208 V \\ (A \u222a B), then P is not induced; this follows from the definition of\na proper W-join. Hence, we find that w\u2032 \u2208 B. Because v is the only terminal\nvertex in B, this means that w\u2032 is not a terminal vertex. Because v and w both\nbelong to B, they are adjacent. However, v only represents sj and i 6= j. Hence,\nwe obtain a contradiction.\nNow suppose that the two terminals represented by u and v are from the same\nterminal pair, and say u represents terminal si and v represents terminal ti . Let\nw be a neighbor of u in B; note that w 6= v as our instance is independent. We\nremove N [A \u222a B] and the terminal pair (si , ti ). We claim that this preserves the\nsolution. This can be seen as follows. Suppose that we have a solution for G. Let P\nbe the si ti -path. Because (A, B) is a proper W-join, N [u]\u222aN [v] = N [A\u222aB]. Since\nu and v only represent si and ti , respectively, and are the only terminal vertices\nin A\u222aB, the only solution path that can use a vertex from N [u]\u222aN [v] = N [A\u222aB]\nis P . Consequently, removing P results in a solution for the resulting instance.\nMoreover, if we have a solution for the resulting instance, we extend it to a\nsolution for G by adding the si ti -path uwv.\nCase 3. Exactly one of A, B, say A, contains a terminal vertex, and this terminal\nvertex represents exactly one terminal.\nLet u \u2208 A be this terminal vertex. Let si be the terminal represented by u. We\nremove all vertices of A \\ {u} from G. We claim that this preserves the solution.\n15\n\n\fThis can be seen as follows. Suppose that we have a solution for G. Let P be\nthe si ti -path. Because u is the only terminal vertex and u represents only one\nterminal, the only solution path that uses a vertex from A \\ {u} is P . Let v be\nthe neighbor of u on P . If v \u2208\n/ A, then we are done. Suppose that v \u2208 A. Because\nA only contains u as a terminal vertex, v is an inner vertex of P . Consequently,\nv has another neighbor on P besides u. Let w be this neighbor. Because u and\nv are in A, we find that w \u2208\n/ N (A) \\ B. Hence w \u2208 B. Then we reroute P\nby replacing v and w by a neighbor of u in B; such a neighbor exists by the\ndefinition of a proper W-join.\nCase 4. Neither A nor B contains a terminal vertex.\nBy definition, A contains two vertices u and v such that u has a neighbor w \u2208 B\nthat is not adjacent to v. We remove all vertices of (A \u222a B) \\ {u, v, w}. We claim\nthat this preserves the solution. This can be seen as follows. Suppose that we\nhave a solution for G. Then at most one vertex of A and at most one vertex\nof B is used as an (inner) vertex of some solution path; otherwise we would\nhave a solution path that is not induced, because (A, B) is a proper W-join.\nIf no solution path uses an edge between a vertex from A and a vertex from\nB, then we can reroute solution paths by replacing a vertex in A by v and a\nsolution vertex in B by w if necessary. In the other case, if there is a solution\npath that uses such an edge, then we can reroute this solution path by replacing\nthe end-vertices of this edge by u and w if necessary.\nIn each of the four cases, we destroy the proper W-join. Note that we do\nthis by removing one or more non-terminal vertices from G, and in addition by\nremoving two terminal vertices representing terminals of a terminal pair if the\nsecond subcase of Case 2 occurred. As such, the resulting graph has fewer vertices\nthan G and together with the remaining terminal pairs (s1 , t1 ), . . . , (s\u2032k , t\u2032k ) forms\nan independent and claw-free instance.\nWe may have created new twins. However, Lemma 10 tells us that we can\nmake the resulting graph twin-free, while preserving all the other properties.\nHence, applying the two rules \"destroy a proper W-join\" and \"make the graph\ntwin-free\" consecutively and as long as possible yields an equivalent instance\nthat is independent, claw-free, twin-free, and proper W-join-free.\nWe are left to analyze the running time. We can find a proper W-join in O(n4 )\ntime by Lemma 7. Distinguishing the right case and applying the corresponding\nrule takes O(n) time. Afterwards, we have removed at least one vertex. Every\ncall to Lemma 10 takes O(n2 ) time. We conclude that the total running time is\nO(n(n4 + n + n2 )) = O(n5 ). This completes the proof of Lemma 11.\n\u2293\n\u2294\n3.2\n\nStrips, Spots, and Stripes\n\nIn this section we state and prove Lemma 12 used in Step 6.\nLemma 12. Let G be a graph that together with a set S of k terminal pairs\nforms a claw-free, independent, and twin-free instance of Induced Disjoint\n16\n\n\fPaths. Let (R, {(Je , Ze ) | e \u2208 E(R)}) be a strip-structure for G, in which each\nstrip (J, Z) either is\n1. a spot, or\n2. a stripe with |Z| = 1, and J is proper circular-arc or has \u03b1(J) \u2264 3, or\n3. a stripe with |Z| = 2, and J is proper interval or has \u03b1(J) \u2264 4.\nThere is a 6k nO(1) -time algorithm that either shows that (G, S) has no solution,\nor produces a set G of at most 6k graphs, such that each G\u2032 \u2208 G is a line graph\nwith at most |V (G)| vertices and at most k terminal pairs, and such that G has\na solution if only if at least one graph in G has a solution.\nProof. Let G be an n-vertex graph with a set of k terminal pairs that has the\nproperties as described in the statement of the lemma.\nOur algorithm is a branching algorithm that applies a sequence of graph\nmodifications to G until a line graph remains in each leaf of the branching tree.\nWhile branching, the algorithm keeps the terminal set and the strip structure\nup to date with the modifications being performed. This is possible dynamically,\ni.e. without needing to recompute a strip structure from scratch, and no new\nstrips are created in the algorithm. Moreover, the modifications ensure that all\nintermediate instances are claw-free and independent, i.e. it is not necessary to\nreapply Lemma 9. Finally, we note that the modifications may remove some or\nall of the vertices of a strip. For example, for a strip (J, Z), it may be that we\nremove N [z] for some z \u2208 Z, thus reducing the size of Z. Hence, at any time\nduring the algorithm, a strip (J, Z) is either\n1. a spot, or\n2. a stripe with |Z| = 1, and J is proper circular-arc or has \u03b1(J) \u2264 3, or\n3. a stripe with |Z| = 2, and J is proper interval or has \u03b1(J) \u2264 4.\nObserve that, for example, the deletion of N [z] for some z \u2208 Z preserves membership of one of these categories. It is also worth noting that such a deletion\nmay create twins in an intermediate instance. However, the algorithm only relies\non the original instance being twin-free, and hence this poses no problem.\nThe algorithm considers each strip at most once in any path of the branching\ntree. The branching strategy that the algorithm follows for a strip (J, Z) depends\non a complex case analysis. The main distinction is between the case |Z| = 1\nand the case |Z| = 2. As we shall see, we do not have to branch in the first case.\nHowever, in the second case we may have to do so. After processing a strip and\npossibly branching, we obtain for each branch a new, intermediate instance of\nthe problem that consists of the induced subgraph G\u2032 of remaining vertices of G\ntogether with those terminal pairs of G that are represented by terminal vertices\nin G\u2032 . We call this reducing to G\u2032 . Then the algorithm considers the next strip\nof the updated strip structure. This strip is arbitrarily chosen from the set of\nremaining unprocessed strips.\nBefore we begin, we first recall a number of properties that we will use\nthroughout the case analysis and prove one additional claim. We recall that\nTu denotes the set of terminals represented by u and that no two partners are\n17\n\n\frepresented by u, as G and its set of terminal pairs form an independent instance. The definition of being an independent instance also means that the set\nof terminal vertices is independent. The latter property together with the clawfreeness of G implies that every terminal vertex represents at most two different\nterminals.\nIn the claim below, J \u2032 denotes a (not necessarily proper) induced subgraph of\nJ and SJ \u2032 denotes a set of at most k terminal pairs in J \u2032 , which is not necessarily\na subset of S.\nClaim 1. We can decide in nO(1) time whether an instance (J \u2032 , SJ \u2032 ) is a Yesinstance.\nWe prove Claim 1 as follows. Either J \u2032 is a proper circular-arc graph (or even\na proper interval graph) or \u03b1(J \u2032 ) \u2264 4 (or even \u03b1(J \u2032 ) \u2264 3). In the first case, we\nuse Lemma 5. In the second case, we deduce that k \u2264 \u03b1(J \u2032 ) \u2264 4, and we can\nuse the nO(k) time algorithm of Fiala et al. [14] for solving Induced Disjoint\nPaths. This proves Claim 1.\nWe are now ready to start our case analysis. In this analysis, we sometimes write\nthat we solve the problem on an induced subgraph G\u2032 of G. Then we implicitly\nassume that we solve the Induced Disjoint Paths problem on G\u2032 , where G\u2032\nhas inherited those terminal pairs of G that are represented by terminal vertices\nin G\u2032 .\nCase 1. |Z| = 1.\nWe write H = G[J \\ Z] and F = G \u2212 H. Assume that Z = Ze1 with e1 = {v}.\nLet e2 , . . . , ep be the other hyperedges of R that contain v. For i = 1, . . . , p, we\nlet zv (ei ) denote the vertex in Zei corresponding to v. Let X = NJe1 (zv (e1 ))\nand Y = NJe2 (zv (e2 )) \u222a * * * \u222a NJep (zv (ep )). By definition, X and Y are both\nnonempty, X \u2229 Y = \u2205 and X \u222a Y is a clique in G. Moreover, Y separates V (H)\nfrom V (F ) \\ Y if V (F ) \\ Y is non-empty.\nIf H contains no terminal vertices, then we remove all vertices of H from G.\nWe may do this, because no path in a solution for G will use a vertex from H.\nThe reason is that such a path will need to pass through Y at least twice. This\nis not possible, because Y is a clique. From now on we assume that H contains\nat least one terminal vertex.\nBelow we split Case 1 in a number of subcases. In these subcases we solve the\nproblem for H or the graph obtained from H by adding a new vertex adjacent to\nevery vertex in X. The latter graph is isomorphic to J, whereas H is an induced\nsubgraph of J. Hence, this subroutine takes nO(1) time due to Claim 1.\nCase 1a. X contains at least one terminal vertex.\nBecause X is a clique, X contains exactly one terminal vertex. Let u be this\nterminal vertex.\nSuppose that there is a pair (si , ti ) with si \u2208 V (H) \\ X and ti \u2208 F \\ Y . Then\n{si , ti } \u2229 Tu = \u2205. We conclude that G has no solution, because the si ti -path of\nany solution for G must pass X and as such contain a neighbor of the terminal\nvertex u as one of its inner vertices. This is not allowed as u is an end-vertex of\nat least one other solution path. From now on, suppose that no such pair exists.\n18\n\n\fFirst suppose that all partners of the terminals in Tu belong to H \u2212 NH [u].\nThen no path in any solution for G will use a vertex from Y . Hence, we first\nsolve the problem for H. If the answer is No, then G has no solution. Otherwise,\nwe reduce to F \u2212 Y .\nNow suppose that all partners of the terminals in Tu belong to F \u2212 Y . If u\nrepresents more than one terminal, then we return No. The reason is that u then\nrepresents two terminals from different terminal pairs. The corresponding paths\nin any solution for G must both contain a vertex from Y . This is not possible,\nbecause Y is a clique. Hence u represents exactly one terminal. Then no path in\nany solution for G will use a vertex from NH [u]. Hence, we can first solve the\nproblem for H \u2212 NH [u]. If H has no solution, then we return No. Otherwise, we\nreduce to F + u.\nFinally, in the remaining case, we may assume without loss of generality\nthat u represents two terminals si and sj , such that ti \u2208 V (H) \\ NH [u] and\ntj \u2208 V (F ) \\ Y . This means that we can first solve the problem for H \u2212 (X \\ {u}).\nIf H \u2212 (X \\ {u}) has no solution, then we return No. Otherwise, we reduce to\nF + u.\nCase 1b. X contains no terminal vertices.\nFirst suppose that there is no terminal pair that is mixed, i.e., has one of its\nterminals in H \u2212 X and the other one in F . Then we first solve the problem for\nH and H \u2212 X. If neither H nor H \u2212 X has a solution, then we return No. If\nH \u2212 X has a solution, then we reduce to F . If H \u2212 X has no solution but H has,\nthen there is a solution path in every solution for G that uses a vertex from X.\nHence, in that case, we reduce to F \u2212 Y .\nNow suppose that there is exactly one mixed terminal pair. Let (si , ti ) be\nthis pair, where we assume that si \u2208 H \u2212 X and ti \u2208 F . Let v \u2032 denote a new\nvertex added to H by making it adjacent to every vertex in X. Let H \u2217 denote\nthe resulting graph. Assume that v \u2032 represents exactly one terminal, which is a\nnew terminal t\u2032i that replaces the partner ti of si . We first solve the problem for\nH \u2217 ; note that H \u2217 is isomorphic to J. If H \u2217 has no solution, then we return No.\nOtherwise we reduce to the graph F \u2217 that is obtained from F by adding a\nnew vertex u\u2032 and a new vertex adjacent to all vertices of Y and to u\u2032 , and letting\nu\u2032 represent a new terminal s\u2032i that is the new partner of ti . Note that the above\nmodification of F into F \u2217 ensures that the resulting instance is independent.\nFinally, suppose that there are two or more mixed terminal pairs. Then we\nreturn No. The reason is that in that case every solution must contain at least\ntwo different paths that use a vertex from X. This is not possible, because X is\na clique.\nCase 2. |Z| = 2.\nIf (J, Z) is a spot, we do nothing. Hence we assume that (J, Z) is a stripe. We\nwrite H = G[J \\Z] and F = G\u2212H. Assume that Z = Ze1 with e1 = {v1 , v2 }. Let\neh2 , . . . , ehph be the other hyperedges of R that contain vh for h = 1, 2. For h = 1, 2\nand i = 1, . . . , ph , we let zv (ehi ) denote the vertex in Zehi corresponding to vh . For\nh = 1, 2, let Xh = NJeh (zv (eh1 )) and Yh = NJeh (zv (eh2 )) \u222a * * * \u222a NJeh (zv (ehph )).\n1\n\n2\n\n19\n\np\n\n\fBecause (J, Z) is a stripe, X1 \u2229 X2 = \u2205. Also by definition, we have that for\nh = 1, 2, the sets Xh and Yh are both nonempty, (X1 \u222a X2 ) \u2229 (Y1 \u222a Y2 ) = \u2205, and\nXh \u222aYh is a clique in G. Moreover, Y1 \u222aY2 separates V (H) from V (F )\\ (Y1 \u222aY2 ),\nshould V (F ) \\ (Y1 \u222a Y2 ) be nonempty. As an aside, we note that Y1 and Y2 may\nshare some vertex. In that case, such a vertex corresponds to a spot. Because G\nis twin-free, there can be at most one such vertex.\nIf H contains no terminal vertices, then we remove all vertices of H from G\nexcept the vertices on a shortest path from a vertex u1 \u2208 X1 to a vertex u2 \u2208 X2 .\nWe may do this, because every path P in any solution for G cannot use just one\nvertex from H; in that case such a vertex will be in X1 or X2 and then two\nvertices of Y1 or of Y2 are on P , which is not possible because Y1 and Y2 are\ncliques. This means that P will pass through X1 and X2 , and thus through H.\nBecause X1 \u222a Y1 and X2 \u222a Y2 are cliques, we can safely mimic this part of P by\nthe path from u1 to u2 in the subgraph of H that we did not remove. From now\non we assume that H contains at least one terminal vertex.\nBelow we split Case 2 in a number of subcases. In these subcases we solve the\nproblem for a graph that is either H or the graph obtained from H by adding\na new vertex adjacent to every vertex in X1 and/or a new vertex adjacent to\nevery vertex in X2 . Hence, this graph is isomorphic to a (not necessarily proper)\ninduced subgraph of J. As such, this subroutine takes nO(1) time, due to Claim 1.\nCase 2a. Both X1 and X2 contain a terminal vertex.\nBecause X1 and X2 are cliques, X1 and X2 each contain exactly one terminal\nvertex. Let uh be the terminal vertex of Xh for h = 1, 2.\nIf there is a terminal pair (sj , tj ) with one of sj , tj in V (H) \\ (X1 \u222a X2 ) and\nthe other one in V (F ) \\ (Y1 \u222a Y2 ), then we return No. The reason is that in this\ncase any sj tj -path must either pass through X1 or through X2 . Because X1 and\nX2 are cliques each containing a terminal vertex, this is not possible. From now\non we assume that such a terminal pair (sj , tj ) does not exist.\nCase 2ai. u1 and u2 represent terminals of the same pair.\nLet this pair be (si , ti ). Because (G, S) is an independent instance, si and ti\nare not represented by the same vertex. Hence, we may assume without loss of\ngenerality that u1 represents s1 and that u2 represents t2 . The fact that (G, S)\nis an independent instance also implies that u1 and u2 are not adjacent.\nCase 2ai-1. All partners of the terminals in Tu1 and all partners of the terminals\nin Tu2 belong to H.\nThen we first solve the problem for H. If we find a solution, then we reduce\nto F \u2212 (Y1 \u222a Y2 ). Otherwise, the si ti -path of any solution for G only contains\nvertices from F besides u1 and u2 . In particular, such a path would use one\nvertex from Y1 and one vertex from Y2 (which may be the same vertex in case\nY1 and Y2 have a common vertex). We now proceed as follows.\nIf Tu1 = {si } and Tu2 = {ti }, then no neighbors of u1 in H and no neighbor\nof u2 in H can be used as an inner vertex of some solution path. Hence, we first\nsolve the problem for H \u2212 (NH [u1 ] \u222a NH [u2 ]). If the answer is No, then G has\nno solution. Otherwise, we reduce to F + u1 + u2 .\n20\n\n\fIf Tu1 = {si } and |Tu2 | = 2, then no neighbor of u1 in H is used as an inner\nvertex of some solution path in any solution for G, whereas one neighbor w of\nu2 in H will be used as an inner vertex, because |Tu2 | = 2. However, such a\nvertex w cannot be in X2 , because then it would still be adjacent to the inner\nvertex of the si ti -path that is in Y2 , as X2 \u222a Y2 is a clique. Hence, we first solve\nthe problem for H \u2212 (NH [u1 ] \u222a (X2 \\ {u2 }). If the answer is No, then G has no\nsolution. Otherwise, we reduce to F + u1 + u2 .\nIf |Tu1 | = |Tu2 | = 2, then no vertex of X \u2217 = (X1 \\ {u1 }) \u222a (X2 \\ {u2 }) can\nbe used as an (inner) vertex of some solution path in any solution for G for\nthe same reason as in the previous case. Hence, we first solve the problem for\nH \u2212 X \u2217 . If the answer is No, then G has no solution. Otherwise, we reduce to\nF + u1 + u2 .\nCase 2ai-2. All partners of the terminals of one of Tu1 , Tu2 , say of Tu1 , belong\nto H, while Tu2 contains a terminal, the partner of which is not in H.\nThen Tu2 consists of exactly two terminals. Suppose that sj \u2208 Tu2 for some j 6= i.\nThen the si ti -path of any solution for G uses no vertices from F , whereas the\nsj tj -path of any solution for G uses only vertices from F besides u2 . Moreover,\nan si ti -path cannot use a vertex from X2 as an inner vertex, because such a\nvertex would be adjacent to the inner vertex of the sj tj -path that is in Y2 , and\nX2 \u222a Y2 is a clique. Hence we first solve the problem for H \u2212 (X2 \\ {u2 }). If the\nanswer is No, then G has no solution. Otherwise, we reduce to F \u2212 Y1 + u2 .\nCase 2ai-3. Both Tu1 and Tu2 contain a terminal, the partner of which does\nnot belong to H.\nBecause two terminal pairs do not coincide, we find that the other terminals\nrepresented by u1 and u2 belong to a different pair. Hence, we may without loss\nof generality assume that sh with h 6= i is the other terminal represented by u1 ,\nand that sj with j \u2208\n/ {h, i} is the other terminal represented by u2 .\nBy the same arguments as in the Case 2ai-2, we can first solve the problem\nfor H \u2212 X \u2217 , where X \u2217 = (X1 \\ {u1 }) \u222a (X2 \\ {u2 }). If the answer is No, then G\nhas no solution. Otherwise, we reduce to F + u1 + u2 .\nCase 2aii. u1 and u2 do not represent terminals of the same pair.\nWe say that ui with 1 \u2264 i \u2264 2 is mixed if a partner of one terminal represented\nby ui is in H, and a partner of one terminal represented by ui is in F . If all\npartners of the terminals represented by ui are in H, then we say that ui is\nH-homogeneous. If all partners of the terminals represented by ui are in F , then\nwe say that ui is F -homogeneous. In this way, we can distinguish a number of\ncases, where we use arguments that we already used in the previous cases.\nSuppose that u1 and u2 are both H-homogeneous. Then we first solve the\nproblem for H. If the answer is No, then G has no solution. Otherwise, we reduce\nto F \u2212 (Y1 \u222a Y2 ).\nSuppose that u1 and u2 are both F -homogeneous. Then we first solve the\nproblem for H \u2212 (NH [u1 ] \u222a NH [u2 ]). If the answer is No, then G has no solution.\nOtherwise, we reduce to F + u1 + u2 .\n21\n\n\fSuppose that one of u1 , u2 , say u1 , is H-homogeneous, whereas u2 is F homogeneous. Then we first solve the problem for H \u2212 NH [u2 ]. If the answer is\nNo, then G has no solution. Otherwise, we reduce to F \u2212 Y1 + u2 .\nSuppose that one of u1 , u2 , say u1 , is H-homogeneous, whereas u2 is mixed.\nThen we first solve the problem for H \u2212 (X2 \\ {u2 }). If the answer is No, then G\nhas no solution. Otherwise, we reduce to F \u2212 Y1 + u2 .\nSuppose that one of u1 , u2 , say u1 , is F -homogeneous, whereas u2 is mixed.\nThen we first solve the problem for H \u2212 NH [u1 ] \u2212 (X2 \\ {u2 }). If the answer is\nNo, then G has no solution. Otherwise, we reduce to F + u1 + u2 .\nSuppose that both u1 and u2 are mixed. Then we first solve the problem for\nH \u2212 X \u2217 , where X \u2217 = (X1 \\ {u1 }) \u222a (X2 \\ {u2 }). If the answer is No, then G has\nno solution. Otherwise, we reduce to F + u1 + u2 .\nThis completes Case 2a. Note that we never branched in this case.\nCase 2b. Only one of the sets X1 , X2 contains a terminal vertex.\nWe assume without loss of generality that X1 contains a terminal vertex u, and\nconsequently, that X2 contains no terminal vertex. If the vertices of V (H) \\ {u}\nrepresent two or more terminals whose partners are in F , then G has no solution.\nFrom now on, we assume that there is at most one terminal that is represented\nby a vertex in V (H) \\ {u} and that has its partner in F .\nWe now start to branch for the first time. We do this into four directions.\nIn the first three directions we check whether G has a solution that contains no\nvertex from X2 , Y1 , or Y2 , respectively. In these cases we may remove X2 , Y1 ,\nor Y2 , respectively, from G and return to Case 1. In the remaining branch we\ncheck whether G has a solution in which a solution path uses a vertex from each\nof the sets X2 , Y1 , and Y2 ; note that these three vertices will be inner vertices\nof one or more solution paths. This is the branch we analyze below.\nWe borrow the notions of u being F -homogeneous, H-homogeneous, or mixed\nfrom Case 2aii. Recall that, because our instance is independent, u does not\nrepresent two terminals of the same pair. Hence, we may denote the terminals\nin Tu by si , or by si , sj depending on whether u represents one or two terminals.\nWe also use the following notations. Let F \u2217 denote the graph obtained from F\nby adding a new vertex u\u20321 adjacent to all vertices of Y1 , a new vertex u\u20322 , and\na new vertex adjacent to all vertices of Y2 and to u\u20322 . Let H \u2217 denote the graph\nobtained from H by removing NH [u] from H and adding a vertex v \u2032 adjacent\nto all vertices in X2 . Let H \u2032 denote the graph obtained from H by removing\nX1 \\ {u} from H and adding a vertex v \u2032 adjacent to all vertices in X2 . Note that\nH \u2217 and H \u2032 are induced subgraphs of J, and thus Claim 1 can be used.\nWe distinguish the following subcases.\nCase 2bi. u is F -homogeneous.\nRecall that in this stage of the algorithm we investigate whether G has a solution,\nsuch that X1 , X2 , Y1 , and Y2 each contain a vertex that will be used on a solution\npath. Then in this case, such a solution must contain a solution path that starts\nin u and uses a vertex from Y1 . Since this solution path cannot end in H, it\ncannot use a vertex from X2 . Then there must exist some other solution path\n22\n\n\fthat uses a vertex from X2 and a vertex from Y2 . This solution path cannot\nhave both end-vertices in H due to the solution path starting from u. Hence, H\nmust contain a terminal vertex representing a terminal whose partner is not in\nH; otherwise we can stop considering this branch. Let (sh , th ) be this terminal,\nwhere we assume that sh is represented by a terminal vertex in H. So, the\nsh th -solution path will use a vertex from X2 and a vertex from Y2 .\nCase 2bi-1. Tu = {si }.\nThen the si ti -path uses a vertex from Y1 . We now proceed as follows. We let v \u2032\nrepresent a new terminal t\u2032h that is the new partner of sh in H \u2217 . Then we solve\nthe problem for H \u2217 . If the answer is No, then we stop considering this branch.\nOtherwise, we let u\u20321 , u\u20322 represent new terminals s\u2032i and s\u2032h , respectively, that\nform the new terminals for ti and th , respectively, in F \u2217 , and we reduce to F \u2217 .\nCase 2bi-2. Tu = {si , sj }.\nWe must branch into two directions, as either only the si ti -path or only the\nsj tj -path can use a vertex from Y1 .\nSuppose that only the si ti -path will use a vertex from Y1 (the other case is\nsymmetric). Then h = j, because u is F -homogeneous. We remove si from the\nset of terminals in H \u2032 , and we let v \u2032 represent a new terminal t\u2032h that is the new\npartner of sh in H \u2032 . Then we solve the problem for H \u2032 . If the answer is No, then\nwe stop considering this branch. Otherwise we let u\u20321 , u\u20322 represent new terminals\ns\u2032i and s\u2032h , respectively, that form the new terminals for ti and th , respectively,\nin F \u2217 , and we reduce to F \u2217 .\nCase 2bii. u is H-homogeneous.\nIn this case one of the solution paths starting in u consecutively passes through\nY1 , Y2 , and X2 . This path does not use any vertex from NH (u), as otherwise\nit would not be induced. If H contains a vertex that represents a terminal of\nwhich the partner is not in H, we stop with considering this branch. Otherwise,\nwe proceed as follows.\nFirst suppose that Tu = {si }. We let v \u2032 represent a new terminal s\u2032i that is\nthe new partner of ti in H \u2217 . Then we solve the problem for H \u2217 . If the answer\nis No, then we stop considering this branch. Otherwise, we let u\u20321 , u\u20322 represent\nnew terminals s\u2032i and t\u2032i , respectively, that form a new terminal pair in F \u2217 , and\nwe reduce to F \u2217 .\nNow suppose that Tu = {si , sj }. We branch into two directions. In the first\nbranch, we remove si from the set of terminals in H \u2032 , and we let v \u2032 represent a\nnew terminal s\u2032i as the new partner of ti in H \u2032 . Then we solve the problem for\nH \u2032 . If the answer is No, then we stop considering this branch. Otherwise, we let\nu\u20321 , u\u20322 represent new terminals s\u2032i and t\u2032i , respectively, that form a new terminal\npair in F \u2217 , and we reduce to F \u2217 . In the second branch, we do the same thing as\nin the first branch, but with (sj , tj ) instead of (si , ti ).\nCase 2biii. u is mixed.\nSuppose that ti is represented by a terminal vertex in H, and hence, tj is represented by a terminal vertex in F . In that case the si ti -path belongs to H and\nthe sj tj -path belongs to F + u. As such, the latter path cannot use a vertex\n23\n\n\ffrom X2 . Because the solution path that uses a vertex from X2 must also be\nthe solution path that uses a vertex from Y2 , this solution path cannot have\nboth end-vertices in H. Hence, H must contain a terminal vertex representing\na terminal whose partner is not in H; otherwise we can stop considering this\nbranch. Let (sh , th ) be this terminal, where we assume that sh is represented by\na terminal vertex in H, and consequently, th is represented by a terminal vertex\nin F .\nWe now proceed as follows. We remove sj from Tu . We let v \u2032 represent a new\nterminal t\u2032h as the new partner of sh in H \u2032 . Then we solve the problem for H \u2032 . If\nthe answer is No, then we stop considering this branch. Otherwise, we let u\u20321 , u\u20322\nrepresent new terminals s\u2032j and s\u2032h , respectively, that form a new terminal pair\nin F \u2217 , and we reduce to F \u2217 .\nThis completes Case 2b. Note that we branched into at most five directions.\nCase 2c. Neither X1 nor X2 contains a terminal vertex.\nRecall that in this stage of the algorithm H is assumed to contain at least one\nterminal vertex. We branch in five directions. In the first four directions, we\ncheck whether G has a solution that contains no vertex from X1 , X2 , Y1 , Y2 ,\nrespectively. In these cases we may remove X1 , X2 , Y1 , or Y2 , respectively, from\nG and return to Case 1. In the remaining branch we check whether G has a\nsolution in which a solution path uses a vertex from each of the sets X1 , X2 ,\nY1 , and Y2 . Note that these four vertices will be inner vertices of one or more\nsolution paths. This is the branch that we analyze below.\nWe say that a terminal that is represented by a vertex in H but whose partner\nis represented by a vertex in F is unpaired in H. If at least three terminals are\nunpaired in H, then G has no solution. This leads to three subcases, in which\nwe use the following additional notations. Let H \u2032\u2032 be the graph obtained from\nH by adding a new vertex v1\u2032 adjacent to all vertices in X1 and a new vertex v2\u2032\nadjacent to all vertices in X2 . Note that H \u2032 is isomorphic to J. We let F \u2217 denote\nthe graph obtained from F by adding a new vertex u\u20321 , a new vertex adjacent to\nall vertices of Y1 and to u\u20321 , a new vertex u\u20322 , and a new vertex adjacent to all\nvertices of Y2 and to u\u20322 .\nCase 2ci. No terminal is unpaired in H.\nWe first verify the following. Let v1\u2032 and v2\u2032 represent new terminals s\u2032h and t\u2032h\nthat form a new terminal pair in H \u2032\u2032 . We then solve the problem for H \u2032\u2032 .\nFirst suppose that H \u2032\u2032 has a solution. Then we remove all vertices of H from\nG except the vertices from a shortest path from a vertex u1 \u2208 X1 to a vertex\nu2 \u2208 X2 . We may do so, because the resulting graph G\u2032 has a solution if and only\nif G has a solution, as we just confirmed that we can always \"fit\" the solution\npaths between terminals in H.\nNow suppose that H \u2032\u2032 has no solution. Because we investigate whether G has\na solution such that X1 , X2 , Y1 , and Y2 each contain a vertex that is used on\na solution path, we must now check whether G has a solution that contains a\nsolution path that starts in a vertex of H, passes through the four aforementioned\n24\n\n\fsets in order X1 , Y1 , Y2 , X2 or in order X2 , Y2 , Y1 , X1 , and finally ends in a vertex\nof H again.\nFor each terminal pair (si , ti ) that is represented in H, we check whether\nH \u2032\u2032 has a solution, after letting v1\u2032 , v2\u2032 represent new terminals t\u2032i , s\u2032i , respectively,\nthat are the new partners of si and ti , respectively, in H \u2032\u2032 . We also check the\npossibility if H \u2032\u2032 has a solution after letting v1\u2032 , v2\u2032 represent new terminals s\u2032i , t\u2032i ,\nrespectively, that are the new partners of ti and si , respectively, in H \u2032\u2032 . If the\nanswer is No for both possibilities for all terminal pairs represented in H, then\nwe stop considering this branch. Otherwise, we reduce to F \u2217 after letting u\u20321 , u\u20322\nrepresent new terminals s\u2032h , t\u2032h , respectively, that form a new terminal pair in\nF \u2217 . Note that we did not do any further branching in this subcase, that is, we\neither stop this branch, or we continue with graph G\u2032 or F \u2217 .\nCase 2cii. Exactly one terminal is unpaired in H.\nLet si be this terminal. Then the si ti -path must pass through Xi and Yi for\ni = 1 or i = 2. However, then it is not possible for any other solution path to\npass through Xj and Yj for j 6= i. Hence, we do not have to consider this case\nin our branching algorithm.\nCase 2ciii. Exactly two terminals are unpaired in H.\nBecause these two terminals are unpaired, we may denote them by si and sj ,\nrespectively. Note that they may be represented by the same vertex. We further\nbranch in two directions.\nFirst, we check whether H \u2032\u2032 has a solution after letting v1\u2032 , v2\u2032 represent new\nterminals t\u2032i , t\u2032j , respectively, that are the new partners of si and sj , respectively,\nin H \u2032\u2032 . If the answer is No, then we stop considering this branch. Otherwise, we\nreduce to F \u2217 after letting u\u20321 , u\u20322 represent new terminals s\u2032i , s\u2032j , respectively, that\nare the new partners of ti and tj in F \u2217 .\nSecond, we check the possibility if H \u2032\u2032 has a solution after letting v1\u2032 , v2\u2032\nrepresent new terminals t\u2032j , t\u2032i , respectively, that are the new partners of sj and\nsi , respectively, in H \u2032\u2032 . If the answer is No, then we stop considering this branch.\nOtherwise, we reduce to F \u2217 after letting u\u20321 , u\u20322 represent new terminals s\u2032j , s\u2032i ,\nrespectively, that are the new partners of tj and ti in F \u2217 .\nThis completes Case 2c, which was the last case in our analysis. Note that we\nbranched into at most six directions in Case 2c.\nAfter our branching algorithm we have either found in k 6 nO(1) time that G\nhas no solution, or a set G of at most 6k graphs. This can be seen as follows. First,\nwe processed each strip in nO(1) time. Second, our algorithm neither recomputed\na strip structure from scratch nor created any new strips when going through the\niterations. Moreover, for each stripe (J, Z) with no terminal vertices in J \\ Z, the\nalgorithm did not branch at all, and for each strip (J, Z) with terminal vertices\nin J \\ Z, it branched into at most six directions. Hence, the corresponding search\ntree of our branching algorithm has depth k and at most 6k leaves.\nBecause we only removed vertices from G, we find that every graph in G has\nat most n vertices. Because we only removed terminal pairs from S or replaced\na terminal pair by another terminal pair, we find that every graph in G has\n25\n\n\fat most k terminal pairs. Moreover, for each graph G\u2032 \u2208 G, it holds that the\nneighborhood of each of its vertices is the disjoint union of at most two cliques.\nThis is true, because every stripe corresponds to a path of three vertices and\nevery spot corresponds to a vertex that is in exactly two maximal cliques, which\nare disjoint, because of the twin-freeness. Hence, G\u2032 is a line graph by Lemma 3.\nThis completes the proof of Lemma 12.\n\u2293\n\u2294\n3.3\n\nLine Graphs\n\nIn this section we state and prove Lemma 13 used in Step 7.\nLemma 13. The Induced Disjoint Paths problem can be solved in g(k)n6\ntime for line graphs on n vertices and with k terminal pairs, where g is a function\nthat only depends on k.\nProof. Let G be a line graph with terminal pairs (s1 , t1 ), . . . , (sk , tk ). Let H be\nthe preimage of G, which we can obtain in linear time due to Lemma 2. Recall\nthat by definition there is a bijection between vertices of G and edges of H. Let\nev \u2208 E(H) denote the edge corresponding to vertex v \u2208 V (G). Furthermore,\ngiven a vertex h \u2208 V (H), let Vh denote the set of vertices in G corresponding to\nthe edges of H that are incident to h. Observe that Vh is a clique in G.\nWe first preprocess the instance in O(k 2 n + n2 ) time using the rules of\nLemma 9 in order to obtain an independent instance. Observe that the class\nof line graphs is closed under vertex deletion, and thus Rules 1, 2, and 3 of\nLemma 9 preserve membership of the class of line graphs. It remains to verify\nthat Rule 4, which potentially removes edges, is also safe. This can be seen as\nfollows. Consider two adjacent terminal vertices u, v \u2208 V (G). Then eu and ev are\nboth incident to a vertex h \u2208 V (H). Since Rule 1, 2, and 3 have been applied,\nevery vertex of Vh is a terminal vertex in G. As Rule 4 will thus remove all edges\nbetween vertices of Vh , we can update the preimage by deleting h and replacing\neach incident edge f with an edge f \u2032 to a new vertex hf . It follows that the rules\nof Lemma 9 preserve membership of the class of line graphs.\nBy abuse of notation, we still use G and (s1 , t1 ), . . . , (sk , tk ) to denote the\ngraph and the terminal pairs, respectively, of the preprocessed instance, and\nH to denote the preimage of G. Consider a terminal vertex x of G and its\ncorresponding edge ex = ui vi in H. If x represents one terminal, then we choose\none of ui , vi , say ui . Then we let ui represent the terminal represented by x in G\nand remove all neighbors of ui except vi from H. If x represents two terminals,\nthen they must be from distinct terminal pairs, say (si , ti ) and (sj , tj ). We may\nassume that x represents si and sj . Then we replace the edge ex with the edges\nui a and bvi , where a and b are new vertices, and consider the two possible\nassignments of si , sj to a, b for which each of a, b represents exactly one terminal.\nBecause we have at most 2k terminal vertices in G, this leads to at most 22k\nnew graphs H \u2032 .\nWe claim that G has a solution if and only if one of the new graphs H \u2032 with\ncorresponding terminal pairs forms a Yes-instance of Disjoint Paths; in that\n26\n\n\fcase we also say that a graph H \u2032 has a solution. Our claim can be seen as follows.\nFirst, we observe that mutually induced paths in a line graph are in one-to-one\ncorrespondence with vertex-disjoint paths in its preimage. Because we consider\nboth options for picking an end-vertex of each \"terminal edge\" in H, this means\nthat a solution for G can be translated to a solution for at least one of the graphs\nH \u2032 . Second, by letting a terminal edge be the only edge incident to the chosen\nend-vertex, we guarantee that a solution for a graph H \u2032 can be translated to a\nsolution for G.\nWe are left to apply Lemma 1 at most 22k times. Note that H contains O(n2 )\nvertices and that each call to Lemma 1 takes h(k) |VH |3 time, where h(k) is a\nfunction that only depends on k. Hence, the total running time is g(k) n6 for\ng(k) = 22k h(k). This completes the proof of Lemma 13.\n\u2293\n\u2294\nLemma 13 completes the proof of Theorem 1. A similar result has also been\nused by Fiala et al. [14], but we had to do a more careful running time analysis\nin order to show our fpt-result.\n3.4\n\nParameterized Complexity of Related Problems\n\nTheorem 1 implies a similar result for the problems k-in-a-Cycle, k-in-a-Path,\nand k-in-a-Tree for claw-free graphs.\nCorollary 1. The problems k-in-a-Cycle, k-in-a-Path, and k-in-a-Tree\nare fixed-parameter tractable for claw-free graphs when parameterized by k.\nProof. First we consider the k-in-a-Cycle problem. Let G be a claw-free graph\nwith a set U = {u1 , . . . , uk } of k specified vertices. Recall that k-in-a-Cycle can\nbe solved in polynomial time for any fixed k, as shown by Fiala et al. [14]. Hence,\nwe may assume that k \u2265 3. We fix an order of the vertices in U , say U is ordered\nas u1 , . . . , uk . We define terminal pairs (si , ti ) = (ui , ui+1 ) for i = 1, . . . , k\u22121 and\n(sk , tk ) = (uk , u1 ). Then we apply Theorem 1. If this does not yield a solution,\nthen we consider a different order of the vertices of U until we considered them\nall. This adds an extra factor of k! to the running time of the fpt-algorithm of\nTheorem 1.\nThe proof for the k-in-a-Path problem uses the same arguments as for the\nk-in-a-Cycle problem when k \u2265 3. The only difference is that we do not have\na terminal pair (sk , tk ). Finally, recall that for claw-free graphs the k-in-a-Path\nproblem is equivalent to the k-in-a-Tree problem.\n\u2293\n\u2294\n\n4\n\nInduced Topological Minors\n\nIn this section we investigate to what extent we can apply Theorem 1 to detect\ninduced containment relations. We first show the following result.\nTheorem 2. The Anchored Induced Topological Minor problem is fixedparameter tractable for pairs (G, H), where G is a claw-free graph, H is an\n(arbitrary) graph, and |V (H)| is the parameter.\n27\n\n\fProof. Let G be a claw-free graph with k specified vertices ordered as u1 , . . . , uk\nfor some integer k. Let H be an arbitrary k-vertex graph, whose vertices are\nordered as x1 , . . . , xk . For each isolated vertex xi \u2208 V (H), we define a terminal\npair (ui , ui ). For each edge xi xj \u2208 E(H), we define a terminal pair (ui , uj ).\nThis leads to a set of terminal pairs T = {(s1 , t1 ), . . . , (sl , tl )}, where l is the\nnumber of edges and isolated vertices of H. Because H has no multiple edges,\nno two terminal pairs in G coincide. Hence the created set of terminal pairs\nhas Properties 1 and 2. Then G contains an induced subgraph isomorphic to a\nsubdivision of H such that the isomorphism maps ui to xi for i = 1, . . . , k if and\nonly if G contains a set of l mutually induced paths P1 , . . . , Pl , such that Pj\nhas end-vertices sj and tj for j = 1, . . . , l. Because H is fixed, l is a constant.\nHence, we may apply Theorem 1, and the result follows.\n\u2293\n\u2294\nObserve that, using Theorem 2, it is easy to solve the Induced Topological Minor problem for pairs (G, H) (where G is a claw-free graph) in\nO(f (|V (H)|) n|V (H)|+O(1) ) time. We simply guess the anchors of the topological minor in n|V (H)| time and then run the algorithm of Theorem 2 in\nO(f (|V (H)|) nO(1) ) time, for some function f . However, this algorithm is hardly\nan improvement over the existing nO(|VH |) -time algorithm for the Induced\nTopological Minor problem for pairs (G, H) (where G is a claw-free graph)\nthat was developed by Fiala et al. [14]. We show in fact that any substantial\nimprovement on this result is unlikely, since we prove below that the problem is\nW[1]-hard.\nTheorem 3. The Induced Topological Minor problem is W[1]-hard for\npairs (G, H) where G and H are line graphs, and |V (H)| is the parameter.\nProof. We give a reduction from the Clique problem, which asks whether a\ngraph has a clique of size at least k. This problem is W[1]-complete when parameterized by k (cf. Downey and Fellows [10]).\nLet G be a graph and k an integer; we may assume without loss of generality\nthat k \u2265 4. We claim that G has a clique of size k if and only if L(G) contains\nL(Kk ) as an induced topological minor.\nFirst suppose that G has a clique of size k. Then it contains a graph G\u2032\nisomorphic to Kk as an induced subgraph. In L(G) we remove all vertices that\ncorrespond to edges incident with at least one vertex in V (G) \\ V (G\u2032 ). This\nleads to an induced subgraph in L(G) that is isomorphic to L(Kk ). It remains\nto observe that any induced subgraph of a graph is also an induced topological\nminor of that graph.\nNow suppose that L(G) contains L(Kk ) as an induced topological minor.\nThen there exists a sequence S of vertex deletions and vertex dissolutions that\nmodifies L(G) into L(Kk ). We claim that S only consists of vertex deletions.\nIn order to obtain a contradiction, suppose that S contains at least one vertex\ndissolution. We may without loss of generality assume that all vertex deletions\nin S occur before the vertex dissolutions in S. Let F be the graph obtained from\nL(G) after these vertex deletions. Because the class of line graphs is closed under\n28\n\n\fvertex deletions, F is a line graph. Moreover, by construction, F is a subdivision\nof L(Kk ).\nBy our assumption, F contains at least one vertex e of degree two that must\nbe dissolved in order to obtain a graph isomorphic to L(Kk ). Let f be one of the\ntwo neighbors of e in F . Note that L(Kk ) is the union of k cliques S1 , . . . , Sk of\nsize k \u2212 1 \u2265 3 that pairwise share exactly one vertex in such a way that every\nvertex of L(Kk ) belongs to exactly two cliques Si and Sj . This implies that ef\nmust be an edge inside one of these cliques. However, then f is the center of\na claw. Because H is a line graph, this is not possible. Hence, S contains no\nvertex dissolutions, and consequently, F is isomorphic to L(Kk ). Because the\nvertex deletions in S translate to edge deletions in G, we then find that Kk is a\nsubgraph of G. In other words, G contains a clique of size k. This completes the\nproof of Theorem 3.\n\u2293\n\u2294\nIt is less clear to what extent induced linkages can be used to find some fixed\ninduced minor in a claw-free graph. So far, limited progress has been made on\nthe H-Induced Minor problem for claw-free graphs, although more polynomial\ncases are known for this graph class than for general graphs [15].\n\n5\n\nConclusions\n\nWe showed that the Induced Disjoint Paths problem is fixed-parameter\ntractable in k for claw-free graphs. As a consequence, we also proved that the\nproblems k-in-a-Cycle, k-in-a-Path, and k-in-a-Tree are fixed-parameter\ntractable in k, and that the same result applies to Anchored Induced Topological Minor when parameterized by the number of vertices in the target\ngraph H. We also showed that our results cannot be applied to the Induced\nTopological Minor problem, which turned out to be W[1]-hard even on line\ngraphs. In this section, we show that our result for the Induced Disjoint\nPaths problem is also tight from two other perspectives, and we state some\nopen problems.\nIt is natural to ask whether our results generalize to K1,l -free graphs for\nl \u2265 4. We show that this is unlikely.\nProposition 1. The problems 2-Induced Disjoint Paths, 2-in-a-Cycle,\nand 3-in-a-Path are NP-complete even for K1,4 -free graphs.\nProof. Derhy and Picouleau [8] proved that 3-in-a-Path is NP-complete even\nfor graphs with maximum degree at most three. L\u00e9v\u00eaque et al. [31] proved that 2in-a-Cycle is NP-complete even for graphs with maximum degree at most three\nand terminals of degree two. From this, it follows immediately that 2-Induced\nDisjoint Paths is NP-complete for graphs with maximum degree at most three,\nbecause we can subdivide the two edges incident with each terminal and then\nplace terminals s1 , s2 , t1 , t2 on the four newly created vertices. It remains to\nobserve that graphs of maximum degree at most three are K1,4 -free.\n\u2293\n\u2294\n29\n\n\fThe next step would be to try to construct a polynomial kernel for Induced\nDisjoint Paths restricted to claw-free graphs. However, we show that this\nis not likely even for line graphs. This follows from the work of Bodlaender,\nThomass\u00e9, and Yeo [3], who showed that Disjoint Paths has no polynomial\nkernel when parameterized by k, unless NP \u2286 coNP/poly, together with the fact\nthat an instance (G, (s1 , t1 ), . . . , (sk , tk )) of Disjoint Paths can be translated\nto an instance (L(G), (s\u20321 , t\u20321 ), . . . , (s\u2032k , t\u2032k )) as follows. For each vertex in G that\nrepresent p \u2265 1 terminals we introduce a new vertex only adjacent to this vertex,\nand we let this new vertex represent the p terminals instead. Then the added\nedges become the vertices that represent the terminals in L(G).\nProposition 2. The Induced Disjoint Paths problem restricted to line graphs\nhas no polynomial kernel when parameterized by k, unless NP \u2286 coNP/poly.\nThe question whether the same result as in Proposition 2 holds for k-in-aCycle and k-in-a-Path restricted to line graphs is open.\nInstead of improving our result for the Induced Disjoint Paths problem,\nwe could also work towards solving a more general problem. In the definition of\ninduced disjoint paths, we explicitly disallowed duplicate terminal pairs, that is,\nthe set of terminal pairs is not a multiset.\nIf we generalize to allow duplicate terminal pairs, then we can solve the kInduced Disjoint Paths problem for claw-free graphs in polynomial time for\nfixed k as follows. In a nutshell, we may assume without loss of generality that\nno vertex represents more than two terminals (otherwise we have a no-instance).\nThen, for any two terminal pairs (si , ti ) and (sj , tj ) with si = sj and ti = tj ,\nwe replace (sj , tj ) by a new pair (s\u2032j , tj ) where s\u2032j is a neighbor of si = sj . This\nonly adds an extra O(n) factor to the running time for each pair of coinciding\nterminal pairs, because we just have to explore all possible choices of such a\nneighbor.\nDetermining the parameterized complexity of the general case is still an open\nproblem. As a partial result towards answering this question, we consider the\nvariation of Induced Disjoint Paths where all terminal pairs coincide. For\nk = 2, this problem is equivalent to the 2-in-a-Cycle problem, which is NPcomplete [2,12] for general graphs and solvable in O(n2 ) time for n-vertex planar\ngraphs [34]. For claw-free graphs, recall that no terminal vertex can represent\nmore than two terminals in any Yes-instance. Hence the problem can be reduced\nto the 2-in-a-Cycle problem, which is polynomial-time solvable on claw-free\ngraphs [14].\nFinally, we note that there may be other natural parameters for the problems\nconsidered. For example, Haas and Hoffmann [22] consider the 3-in-a-Path\nproblem and prove W[1]-completeness for general graphs if the parameter is the\nlength of an induced path that is a solution for 3-in-a-Path.\n\nReferences\n1. R. Belmonte, P.A. Golovach, P. Heggernes, P. van 't Hof, M. Kaminski and D.\nPaulusma, Detecting fixed patterns in chordal graphs in polynomial time, Algo-\n\n30\n\n\frithmica, to appear.\n2. D. Bienstock. On the complexity of testing for odd holes and induced odd paths.\nDiscrete Mathematics 90 (1991) 85\u201392. See also Corrigendum, Discrete Mathematics 102 (1992) 109.\n3. H.L. Bodlaender, S. Thomass\u00e9, and A. Yeo. Kernel bounds for disjoint cycles and\ndisjoint paths. Theoretical Computer Science 412 (2011) 4570\u20134578.\n4. H. Bruhn and A. Saito. Clique or hole in claw-free graphs. Journal of Combinatorial\nTheory, Series B 102 (2012) 1\u201313.\n5. M. Chudnovsky and P.D. Seymour. The structure of claw-free graphs. In:\nB.S. Webb (ed.) Surveys in combinatorics, 2005, London Mathematical Society\nLecture Notes Series, vol. 327, Cambridge University Press, Cambridge (2005)\n153\u2013171.\n6. M. Chudnovsky and P.D. Seymour. The three-in-a-tree problem. Combinatorica\n30 (2010) 387\u2013417.\n7. X. Deng, P. Hell, and J. Huang. Linear time representation algorithm for proper\ncircular-arc graphs and proper interval graphs. SIAM Journal on Computing 25\n(1996) 390\u2013403.\n8. N. Derhy and C. Picouleau. Finding induced trees. Discrete Applied Mathematics\n157 (2009) 3552\u20133557.\n9. N. Derhy, C. Picouleau, and N. Trotignon. The four-in-a-tree problem in trianglefree graphs. Graphs and Combinatorics 25 (2009) 489\u2013502.\n10. R.G. Downey and M.R. Fellows, Parameterized complexity, Monographs in Computer Science, Springer-Verlag, New York, 1999.\n11. R. Diestel, Graph Theory, Springer-Verlag, Electronic Edition, 2005.\n12. M.R. Fellows. The Robertson\u2013Seymour theorems: A survey of applications. In:\nR.B. Richter (ed.) Proceedings of the AMS-IMS-SIAM Joint Summer Research\nConference, Contemporary Mathematics, vol. 89, American Mathematical Society,\nProvidence (1989) 1\u201318.\n13. M.R. Fellows, J. Kratochv\u0131\u0301l, M. Middendorf, and F. Pfeiffer. The Complexity of\nInduced Minors and Related Problems. Algorithmica 13 (1995) 266\u2013282.\n14. J. Fiala, M. Kami\u0144ski, B. Lidicky, and D. Paulusma. The k-in-a-path problem for\nclaw-free graphs. Algorithmica 62 (2012) 499-519.\n15. J. Fiala, M. Kami\u0144ski, and D. Paulusma, A note on contracting claw-free graphs.\nDiscrete Mathematics & Theoretical Computer Science 15 (2013) 223\u2013232.\n16. J. Fiala, M. Kami\u0144ski, and D. Paulusma, Detecting induced star-like minors in\npolynomial time. Journal of Discrete Algorithms 17 (2012) 74\u201385.\n17. P. A. Golovach, M. Kami\u0144ski, D. Paulusma and D. M. Thilikos. Containment\nrelations in split graphs. Discrete Applied Mathematics 160 (2012) 155\u2013163.\n18. P.A. Golovach, D. Paulusma and E.J. van Leeuwen, Induced Disjoint Paths in\nCircular-Arc Graphs in Linear Time, manuscript, arXiv:1403.0789.\n19. P.A. Golovach, D. Paulusma and E.J. van Leeuwen, Induced disjoint paths in\nAT-free graphs, In: Proc. SWAT 2012, LNCS 7357, Springer-Verlag, Berlin (2012)\n153\u2013164.\n20. P.A. Golovach, D. Paulusma and E.J. van Leeuwen, Induced disjoint paths in\nclaw-free graphs, In: Proc. ESA 2012, LNCS 7501, Springer-Verlag, Berlin (2012)\n515\u2013526.\n21. M. Grohe, K. Kawarabayashi, D. Marx, and P. Wollan. Finding topological subgraphs is fixed-parameter tractable. In: Proc. STOC 2011, 479\u2013488.\n22. R. Haas and M. Hoffmann. Chordless paths through three vertices. Theoretical\nComputer Science 351 (2006) 360\u2013371.\n\n31\n\n\f23. M. Habib, C. Paul, and L. Viennot, A synthesis on partition refinement: A useful\nroutine for strings, graphs, boolean matrices and automata. In: Proc. STACS 1998,\nLNCS 1373, Springer-Verlag, Berlin (1998) 25\u201338.\n24. F. Harary. Graph Theory. Addison-Wesley, Reading MA, 1969.\n25. D. Hermelin, M. Mnich, E.J. van Leeuwen, and G.J. Woeginger. Domination when\nthe stars are out. In Proc. ICALP 2011, LNCS 6755, Springer-Verlag, Berlin (2011)\n462\u2013473.\n26. D. Hermelin, M. Mnich, E.J. van Leeuwen, and G.J. Woeginger. Domination when\nthe stars are out. arXiv:1012.0012v1 [cs.DS].\n27. R.M. Karp. On the complexity of combinatorial problems. Networks 5 (1975) 45\u2013\n68.\n28. A. King and B. Reed. Bounding \u03c7 in terms of \u03c9 and \u03b4 for quasi-line graphs. Journal\nof Graph Theory 59 (2008) 215\u2013228.\n29. Y. Kobayashi and K. Kawarabayashi. Algorithms for finding an induced cycle in\nplanar graphs and bounded genus graphs. In: Proc. SODA 2009, ACM Press, New\nYork (2009) 1146\u20131155.\n30. Y. Kobayashi and K. Kawarabayashi. A linear time algorithm for the induced\ndisjoint paths problem in planar graphs. Journal of Computer and System Sciences\n78 (2012) 670\u2013680.\n31. B. L\u00e9v\u00eaque, D.Y. Lin, F. Maffray, and N. Trotignon. Detecting induced subgraphs.\nDiscrete Applied Mathematics. 157 (2009) 3540\u20133551.\n32. W. Liu and N. Trotignon. The k-in-a-tree problem for graphs of girth at least k.\nDiscrete Applied Mathematics 158 (2010) 1644\u20131649.\n33. J.F. Lynch. The equivalence of theorem proving and the interconnection problem.\nSIGDA Newsletter 5 (1975) 31\u201336.\n34. C.J.H. McDiarmid, B.A. Reed, A. Schrijver, F.B. Shepherd. Induced Circuits in\nPlanar Graphs. JCTB 60 (1994) 169\u2013176.\n35. R. Niedermeier, Invitation to Fixed-Parameter Algorithms. Oxford Lecture Series\nin Mathematics and its Applications, Oxford University Press, 2006.\n36. B.A. Reed, N. Robertson, A. Schrijver, P.D. Seymour. Finding disjoint trees in\nplanar graphs in linear time. In: Contemp. Math. vol. 147, Amer. Math. Soc. (1993)\n295\u2013301.\n37. N. Robertson and P.D. Seymour. Graph minors. XIII. The disjoint paths problem.\nJournal of Combinatorial Theory, Series B 63 (1995) 65\u2013110.\n38. N.D. Roussopoulos. A max{m, n} algorithm for determining the graph H from its\nline graph G. Information Processing Letters 2 (1973) 108\u2013112.\n39. Z. Ryj\u00e1\u010dek, On a closure concept in claw-free graphs, Journal of Combinatorial\nTheory, Series B 70 (1997) 217\u2013224.\n\n32\n\n\f"}