{"id": "http://arxiv.org/abs/1012.3704v1", "guidislink": true, "updated": "2010-12-16T18:10:26Z", "updated_parsed": [2010, 12, 16, 18, 10, 26, 3, 350, 0], "published": "2010-12-16T18:10:26Z", "published_parsed": [2010, 12, 16, 18, 10, 26, 3, 350, 0], "title": "A Decidable Timeout based Extension of Propositional Linear Temporal\n  Logic", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1012.0003%2C1012.3153%2C1012.0767%2C1012.1729%2C1012.5896%2C1012.1992%2C1012.5270%2C1012.3647%2C1012.1878%2C1012.0104%2C1012.2164%2C1012.5803%2C1012.4796%2C1012.4611%2C1012.4190%2C1012.5350%2C1012.2228%2C1012.1073%2C1012.5866%2C1012.5745%2C1012.4737%2C1012.4219%2C1012.3229%2C1012.0778%2C1012.1187%2C1012.2518%2C1012.4006%2C1012.0590%2C1012.1128%2C1012.5601%2C1012.4075%2C1012.4154%2C1012.0046%2C1012.0949%2C1012.3999%2C1012.5179%2C1012.2935%2C1012.1932%2C1012.1120%2C1012.3017%2C1012.5090%2C1012.3704%2C1012.0279%2C1012.4718%2C1012.5369%2C1012.2759%2C1012.4428%2C1012.1908%2C1012.3970%2C1012.2583%2C1012.4704%2C1012.1986%2C1012.5833%2C1012.2275%2C1012.3940%2C1012.2812%2C1012.0551%2C1012.5731%2C1012.0819%2C1012.4993%2C1012.2902%2C1012.4227%2C1012.2611%2C1012.0747%2C1012.5343%2C1012.0357%2C1012.4478%2C1012.1087%2C1012.0171%2C1012.5826%2C1012.5487%2C1012.5888%2C1012.1715%2C1012.4095%2C1012.2494%2C1012.0997%2C1012.0398%2C1012.0132%2C1012.1093%2C1012.2348%2C1012.4294%2C1012.0649%2C1012.5561%2C1012.0766%2C1012.5012%2C1012.1449%2C1012.2667%2C1012.5405%2C1012.4238%2C1012.5545%2C1012.3557%2C1012.4223%2C1012.5341%2C1012.0854%2C1012.3642%2C1012.1797%2C1012.4776%2C1012.3867%2C1012.5307%2C1012.1589%2C1012.2638&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Decidable Timeout based Extension of Propositional Linear Temporal\n  Logic"}, "summary": "We develop a timeout based extension of propositional linear temporal logic\n(which we call TLTL) to specify timing properties of timeout based models of\nreal time systems. TLTL formulas explicitly refer to a running global clock\ntogether with static timing variables as well as a dynamic variable abstracting\nthe timeout behavior. We extend LTL with the capability to express timeout\nconstraints. From the expressiveness view point, TLTL is not comparable with\nimportant known clock based real-time logics including TPTL, XCTL, and MTL,\ni.e., TLTL can specify certain properties, which cannot be specified in these\nlogics (also vice-versa). We define a corresponding timeout tableau for\nsatisfiability checking of the TLTL formulas. Also a model checking algorithm\nover timeout Kripke structure is presented. Further we prove that the validity\nchecking for such an extended logic remains PSPACE-complete even in the\npresence of timeout constraints and infinite state models. Under discrete time\nsemantics, with bounded timeout increments, the model-checking problem that if\na TLTL-formula holds in a timeout Kripke structure is also PSPACE complete. We\nfurther prove that when TLTL is interpreted over discrete time, it can be\nembedded in the monadic second order logic with time, and when TLTL is\ninterpreted over dense time without the condition of non-zenoness, the\nresulting logic becomes $\\Sigma_1^1$-complete.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1012.0003%2C1012.3153%2C1012.0767%2C1012.1729%2C1012.5896%2C1012.1992%2C1012.5270%2C1012.3647%2C1012.1878%2C1012.0104%2C1012.2164%2C1012.5803%2C1012.4796%2C1012.4611%2C1012.4190%2C1012.5350%2C1012.2228%2C1012.1073%2C1012.5866%2C1012.5745%2C1012.4737%2C1012.4219%2C1012.3229%2C1012.0778%2C1012.1187%2C1012.2518%2C1012.4006%2C1012.0590%2C1012.1128%2C1012.5601%2C1012.4075%2C1012.4154%2C1012.0046%2C1012.0949%2C1012.3999%2C1012.5179%2C1012.2935%2C1012.1932%2C1012.1120%2C1012.3017%2C1012.5090%2C1012.3704%2C1012.0279%2C1012.4718%2C1012.5369%2C1012.2759%2C1012.4428%2C1012.1908%2C1012.3970%2C1012.2583%2C1012.4704%2C1012.1986%2C1012.5833%2C1012.2275%2C1012.3940%2C1012.2812%2C1012.0551%2C1012.5731%2C1012.0819%2C1012.4993%2C1012.2902%2C1012.4227%2C1012.2611%2C1012.0747%2C1012.5343%2C1012.0357%2C1012.4478%2C1012.1087%2C1012.0171%2C1012.5826%2C1012.5487%2C1012.5888%2C1012.1715%2C1012.4095%2C1012.2494%2C1012.0997%2C1012.0398%2C1012.0132%2C1012.1093%2C1012.2348%2C1012.4294%2C1012.0649%2C1012.5561%2C1012.0766%2C1012.5012%2C1012.1449%2C1012.2667%2C1012.5405%2C1012.4238%2C1012.5545%2C1012.3557%2C1012.4223%2C1012.5341%2C1012.0854%2C1012.3642%2C1012.1797%2C1012.4776%2C1012.3867%2C1012.5307%2C1012.1589%2C1012.2638&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We develop a timeout based extension of propositional linear temporal logic\n(which we call TLTL) to specify timing properties of timeout based models of\nreal time systems. TLTL formulas explicitly refer to a running global clock\ntogether with static timing variables as well as a dynamic variable abstracting\nthe timeout behavior. We extend LTL with the capability to express timeout\nconstraints. From the expressiveness view point, TLTL is not comparable with\nimportant known clock based real-time logics including TPTL, XCTL, and MTL,\ni.e., TLTL can specify certain properties, which cannot be specified in these\nlogics (also vice-versa). We define a corresponding timeout tableau for\nsatisfiability checking of the TLTL formulas. Also a model checking algorithm\nover timeout Kripke structure is presented. Further we prove that the validity\nchecking for such an extended logic remains PSPACE-complete even in the\npresence of timeout constraints and infinite state models. Under discrete time\nsemantics, with bounded timeout increments, the model-checking problem that if\na TLTL-formula holds in a timeout Kripke structure is also PSPACE complete. We\nfurther prove that when TLTL is interpreted over discrete time, it can be\nembedded in the monadic second order logic with time, and when TLTL is\ninterpreted over dense time without the condition of non-zenoness, the\nresulting logic becomes $\\Sigma_1^1$-complete."}, "authors": ["Janardan Misra", "Suman Roy"], "author_detail": {"name": "Suman Roy"}, "author": "Suman Roy", "links": [{"href": "http://arxiv.org/abs/1012.3704v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1012.3704v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "68Q60", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.3.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1012.3704v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1012.3704v1", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "A Decidable Timeout based Extension of\nPropositional Linear Temporal Logic\n\narXiv:1012.3704v1 [cs.LO] 16 Dec 2010\n\nJanardan Misra\nEMCSS India Pvt. Ltd., Bangalore 560048, India.\nEmail: janmishra@gmail.com\nSuman Roy\nSETLABS, Infosys Tech. Ltd., #44 Electronic City,\nBangalore 560100, India.\nEmail: suman roy@infosys.com\nApril 5, 2019\nAbstract\nWe develop a timeout based extension of propositional linear temporal logic (which we call TLTL) to specify timing properties of timeout\nbased models of real time systems. TLTL formulas explicitly refer to\na running global clock together with static timing variables as well as\na dynamic variable abstracting the timeout behavior. We extend LTL\nwith the capability to express timeout constraints. From the expressiveness view point, TLTL is not comparable with important known clock\nbased real-time logics including TPTL, XCTL, and MTL, i.e., TLTL can\nspecify certain properties, which cannot be specified in these logics (also\nvice-versa). We define a corresponding timeout tableau for satisfiability\nchecking of the TLTL formulas. Also a model checking algorithm over\ntimeout Kripke structure is presented. Further we prove that the validity\nchecking for such an extended logic remains PSPACE-complete even in the\npresence of timeout constraints and infinite state models. Under discrete\ntime semantics, with bounded timeout increments, the model-checking\nproblem that if a TLTL-formula holds in a timeout Kripke structure is\nalso PSPACE complete. We further prove that when TLTL is interpreted\nover discrete time, it can be embedded in the monadic second order logic\nwith time, and when TLTL is interpreted over dense time without the\ncondition of non-zenoness, the resulting logic becomes \u03a311 -complete.\n\nKeywords: Timeout systems, Real time logics, Model checking, Timing properties, Timeout constraints, Tableau satisfiability, Undecidability\n\n1\n\nIntroduction\n\nReal-time systems are an important class of mission critical systems, which have\nbeen well studied for their design, implementation, and performance [OD08].\nDesigning faithful models for real-time systems essentially requires representing\ndifferent kinds of timing behavior e.g., relative delays and timing constraints.\n1\n\n\fIn a timeout based design framework for real-time systems, timing requirements\nare modeled by defining the execution of an action in terms of an expiration of\na delay, often represented as a timeout (or timer). Traditionally, timeouts have\nbeen used in real-time system designs for handling various timing scenarios\nincluding (forced) expiration of a waiting state. Dutertre and Sorea [DS04]\nused timeout based modeling to formally verify safety properties of the realtime systems with discrete dynamics. A timeout model contains a finite set\nof timeouts and a variable x which keeps track of the current (global) time.\nTimeouts define the time points when discrete transitions are enabled in the\nfuture. In practice, a typical real-time system may contain n concurrently active\nprocesses. Each process is associated with one timeout which denotes the future\npoint of time when the next discrete transition for the corresponding process\nwill occur. Transitions in this model are classified into two types - time progress\ntransitions and discrete transitions. In a time progress transition, the time\nvariable x is advanced to the minimum valued timeout(s). A discrete transition\noccurs when x is equal to the minimum valued timeout(s). If there are more\nthan one processes, which have their timeouts equal to the minimum value, then\nsome of them are randomly selected and corresponding discrete transitions take\nplace with the values of the corresponding timeouts are set in the future.\n(x =\u03c4i) \u21d2 \u3008\u03c4i := x + \u03b1ilisten \u3009\nInit\n\n(x =\u03c4i) \u21d2 \u3008send(cs_frame), \u03c4i := x + \u03b1ics \u3009\n(x=\u03c4i) \u21d2 \u3008\u03c4i := x + \u03b1ics, w \u3009\nColdStart\n\nListen\n\nTrue \u21d2\n\u3008receive(cs_frame), \u03c4i := x + \u03b1round \u3009\n\nTrue \u21d2 \u3008receive(cs_frame),\n\u03c4i := x + \u03b1ics \u3009\n\n(x = w) \u21d2 \u3008send(cs_frame)\u3009\n\nTrue \u21d2\n\u3008receive(i_frame), \u03c4i := x + \u03b1round \u3009\n\nActive\n\n(x = \u03c4i) \u21d2\n\u3008send(i_frame), \u03c4i := x +\u03b1round \u3009\n\nTrue \u21d2 \u3008receive(cs_frame), \u03c4i := x +\u03b1round\u3009\n\nFigure 1: State transition diagram of TTA startup algorithm at ith node. Edges\nare labeled as: guard\u21d2 h[send/receive], timeout update, [record time var]i, where\n(optional) record time var records the time when a transition occurs on the edge.\nStartup algorithm for Time-triggered Architecture (TTA) is an example of a\nsystem where timeouts are explicitly used in the design. TTA start-up algorithm\nexecutes on a logical bus meant for safety critical application in both automotive\nand aerospace industries. In a normal operation, N nodes share a TTA bus\nusing a TDMA schedule. The state-machine of the startup algorithm executed\non the nodes is shown in Figure 1. Each node i \u2208 [1, N ] has a local timeout \u03c4i .\nTimeout increments in various states are defined in terms of timeout increment\nparameters: \u03b1ilisten = (2N +i\u22121)\u03bb, \u03b1ics = (N +i\u22121)\u03bb, and \u03b1iround = N \u03bb, where\n2\n\n\f\u03bb refers to the (fixed) duration of each slot in a TDMA schedule. When a node is\npowered-on, it transits from init state to listen state and listens for the duration\n\u03b1ilisten to determine if there is a synchronous set of nodes communicating on the\nmedium. Similarly a node in coldstart state waits for reception of frames until\nclock x reaches the value of its timeout. If it receives such a frame, it enters\nthe active state, else it broadcasts another frame, loops into the coldstart state,\nand waits for another \u03b1ics time units. For a brief description of the TTA startup\nalgorithm, the reader is referred to [DS04]. For a detailed exposition to startup\nprotocols, we refer the reader to [SP02].\nDenoting the minimum of all timeout values in any state by y, a timeout\nevent in a state can be characterized by constraint x = y. Also the following\nproperties might be of interest1 .\n\u2022 In each state, either a timeout occurs or it is set in the future:\n2((x = y) \u2228 (x < y))\n\u2022 If a node i comes to the listen state (characterized by plis ) at time x = t0 ,\nit will move to the coldstart state (characterized by pcs ) in time no later\nthan x = t0 + \u03b1ilisten :\n\u2200t0 .2(plis \u2227 (x = t0 ) \u21d2 3(pcs \u2227 (x \u2264 t0 + \u03b1ilisten ))).\nClearly ordinary linear temporal logic (LTL) [Pnu77, LP85] would not allow\nexpressing such properties. One needs to extend LTL with the capability to\nexpress timeout constraints. Even the popular real-time extensions of LTL,\ne.g., TPTL [AH94] cannot be used in a straightforward manner to express these\nconstraints. For example, in order to use TPTL for model checking the TTA\nstart-up model discussed above, the model would have to be redesigned using\nexplicit clock based frameworks e.g., timed automata [AD94]. These clock based\nmodels in turn need to explicitly simulate the timeout semantics as discussed\nbefore. Also, as we shall discuss in Section 4.2, certain liveness properties on\nglobal timeout events cannot be expressed using TPTL.\nThe primary objective of this work is to develop a real-time extension of\nLTL that can handle timeout contraints and possesses an efficient model checking algorithm as well. Over the past decade, there has been a sustained effort\nto increase the expressive power of temporal logic, which is a popular mechanism for specifying and verifying temporal properties of reactive and real-time\nsystems. As we discuss further in Section 4, several attempts have been made\nto incorporate time explicitly into LTL, and to interpret the resulting logics\nover models that associate a time with every state. Examples of such logics\nare RTTL [Ost89], XCTL [HLP90], TPTL [AH94], MTL [Koy90] etc. Quite\na few verification tools have been developed based on these logics, e.g., DTSPIN [BD98], RT-SPIN [TC96], UPPAAL [BDL04]. Since these tools adopt\nclock-based modeling approaches they can be used to formalize timeout systems only by first converting the timeout models into clock-based models (e.g.,\ntimed automata with clocks). On the other hand, the infinite bounded model\nchecker of SAL (Symbolic Analysis Laboratory) [dMOR+ 04] can model timeout\n1 For\n\nthe formal semantic interpretation of these formulas see Section 2.\n\n3\n\n\fsystems, however supports only LTL model checking and demands considerable manual efforts while defining supporting lemmas and abstractions during\nthe model checking process. In order to alleviate such problems timeout based\nmodeling was earlier formalized by the authors in [SMR07] in terms of predicate\ntransition diagrams and the current work deals with defining the corresponding\nspecification logic and model checking procedure.\nThe remainder of the paper is organized as follows: The logic TLTL is\nintroduced in the Section 2. In Section 3, we introduce a monadic second\norder (MSO) theory of timeout state sequences and prove that TLTL when\ninterpreted over discrete time can be embedded in it. In Section 4, we compare\nTLTL with other real-time extensions of LTL including XCTL, TPTL, and\nMTL. In Section 5, we describe a tableau based decision procedure for the\nvalidity (and satisfiability) checking of TLTL formulas followed by its complexity\nanalysis. Model checking of TLTL formulas over timeout Kripke structures is\ndiscussed in Section 6 with associated complexity analysis. In Section 7 we prove\nan undecidability result under dense time interpretation without time progress\nconstraint. We conclude with a discussion on the directions for future work in\nSection 8.\n\n2\n\nThe Logic TLTL\n\nIn this section we will define the syntax and semantics of Timeout based Propositional Linear Temporal Logic, TLTL.\n\n2.1\n\nSyntax of TLTL\n\nThe basic vocabulary of TLTL consists of a finite set P of propositions true,\nfalse, p, q, . . ., a finite set T of (global) static timing variables t1 , t2 , . . . In\naddition, we allow a dynamic variable x which represents the clock and a dummy\nvariable y 2 . Assume \u2206 = {<, =, >}, and let v range over \u2206. We use R\u22650 to\ndenote the set of non negative real numbers, and N to denote the set of non\nnegative integers.\n\u2022 The set of atomic formulas (Af ) consists of propositions in P and atomic\nconstraints of the form x < y, x = y, x < u, x = u, and x > u where\nu ::= t + c | c, t ranges over T and c \u2208 N is a constant. We will refer\nx < u, x = u and x > u as static constraints and x < y and x = y as\ndynamic constraints.\n\u2022 (unquantified) Formulas are built using the following grammar\n\u03c6 ::= af | \u03c6 \u2228 \u03c6 | \u00ac\u03c6 |\n\n\u03c6 | \u03c6 U\u03c6\n\nwhere af ranges over Af .\n2 Variable y is essentially a place holder for minimum of the timeouts in a timeout program, which will be introduced in Section 6.1. This abstraction is adopted primarily because,\naccording to the behavior of a timeout system as discussed in Section 1, a discrete transition\nin a state may occur only when the current time is equal to the minimum valued timeout.\nFor convenience, y will also be referred sometimes as 'minimum of the timeouts'.\n\n4\n\n\f\u2022 Finally, a quantified formula is built using universal quantification over\ntiming variables at the outermost level as:\n\u03c8 ::= \u2200t1 t2 . . . tk .\u03c6,\nwhere T\u03c8 = {t1 , t2 , . . . , tk } \u2286 T is the set of timing variables appearing in\nthe (unquantified) formula \u03c6.\n\u2022 The additional operators \u2227, \u21d2, \u21d4 and modal operators 3, 2 are introduced as abbreviations, p \u21d2 q \u2261 \u00acp \u2228 q, 3\u03c6 \u2261 true U\u03c6, 2\u03c6 \u2261 \u00ac(3\u00ac\u03c6).\n\n2.2\n\nSemantics of TLTL\n\nWe consider the following point-wise or (timeout) event based semantics for\nTLTL. Towards defining a model for a TLTL formula consider a sequence of\nstates of the form\n\u03c3 : s0 s1 . . . ,\nsuch that each si gives a boolean interpretation (true, false) to the propositions, and non negative real valued interpretation to the timing variables in T ,\nto the clock variable x, and the variable y.\nIn a state si , let us assume that si (x) denotes the value of the clock variable\nx, si (y) the value of variable y, and si (tj ) the value of timing variable tj \u2208 T .\nIt is further required that\n(m1 ) Monotonicity: Clock x and variable y do not decrease:\n\u2200i : si (x) \u2264 si+1 (x) and si (y) \u2264 si+1 (y)\n(m2 ) Time Progress: To ensure effective time progress in the model a divergence\ncondition3 , which says that time eventually increases, is required:\n\u2200\u03b4 \u2208 R\u22650 : \u2203i such that si (x) > \u03b4\n(m3 ) State Transition: Upon a change of state either timeout variables stay\nconstant or some of them increase, that is, for each i:\n\u2022 if the clock in state si is less than the minimum of the timeouts, i.e.\ny, clock advances to this value in the next state si+1 :\n[(si (x) < si (y)) \u21d2 (si+1 (y) = si (y)) \u2227 (si+1 (x) = si (y))]\n\u2022 else, if the clock in state si is equal to the value of y, in the next\nstate si+1 , y advances in the future:\n[(si (x) = si (y)) \u21d2 (si+1 (y) > si (y)) \u2227 (si+1 (x) = si (x))]\nAs a consequence we have for each i, si (x) \u2264 si (y), that is, timeouts are\nalways set in the future.\n3 This\n\nis also known in the literature as 'non-zenoness' or 'finite-variability' condition.\n\n5\n\n\f(m4 ) Initiality: For the initial state s0 the following hold: either, s0 (x) =\ns0 (y) = 0 (when x = y holds in s0 ) or 0 = s0 (x) < s0 (y) (when x < y\nholds in s0 ).\n(m5 ) Constant Interpretation for Static Variables: All the states are required\nto assign the same interpretation to the static timing variables, that is,\nfor a given formula \u03c8,\n\u2200tj \u2208 T\u03c8 : si (tj ) = s0 (tj ), for each i.\nThus a model for a TLTL formula may contain infinitely many different\nstates with different values of the clock and timeout variables. Boolean and\nmodal operators are given the usual interpretation. We mention only atomic\nformulas in Af which are interpreted in a state as follows.\nsi |= p\nsi |= x v tj + c\nsi |= x v0 y\n\niff\niff\niff\n\nsi (p) = true\nsi (x) v si (tj ) + c\nsi (x) v0 si (y)\n\nFinally, we define \u03c3 |= \u03c8 iff s0 |= \u03c6 for any interpretation of the static timing\nvariables appearing in \u03c6 given in state s0 . The formula \u03c8 is satisfiable (valid)\nif \u03c3 |= \u03c8 for some (all) sequence(s) \u03c3.\nFor example, consider time bounded response property, which specifies that\n\"event q is always followed by event p within 5 time units\". It can be expressed\nby a TLTL formula\n\u2200t0 .2(p \u2227 (x = t0 ) \u21d2 3(q \u2227 (x \u2264 t0 + 5)))\n\n(1)\n\nWe can also consider a variant of this as a bounded timeout response property\nstating that \"timeout event q is always followed by timeout event p within 5\ntime units\", which would be expressed by a TLTL formula\n\u2200t0 .2(p \u2227 (x = y) \u2227 (x = t0 ) \u21d2 3(q \u2227 (x = y) \u2227 (x \u2264 t0 + 5)))\n\n(2)\n\nA quantified formula \u03c8 is termed as closed if all the timing variables appearing\nin it are bounded by a universal quantifier. In the rest of the discussion we will\nonly consider closed quantified formulas. Also we will follow usual notational\nconvention [Ost89, PH88, HLP90] of implicit universal quantification and would\noften drop the outermost universal quantification over global static timing variables in T . For example, the time bounded response property, specified by the\nTLTL formula (1) would actually be written as\n2(p \u2227 (x = t0 ) \u21d2 3(q \u2227 (x \u2264 t0 + 5)))\n\n(\u03c6BRT LT L )\n\nA formula of the form x \u2264 z (z := u|y) is an abbreviation for (x < z) \u2228 (x = z).\nSimilarly x \u2265 u abbreviates (x > u) \u2228 (x = u). Note that x > y is not a valid\nformula in TLTL.\n\n3\n\nAn Embedding of TLTL in MSO\n\nIn this section we explore the relationship of TLTL with monadic second order\nlogic (MSO) with time. Towards that we consider an interpretation of MSO\nin integer time structure. Subsequently we provide a straightforward meaning\npreserving translation between TLTL and monadic logic.\n6\n\n\f3.1\n\nMonadic Second Order Theory of Timeout State Sequences\n\nNext we briefly recall the theory of timed state sequences LT2 as introduced\nin [AH93] and extend it slightly. This is defined by adding a linearly ordered time\ndomain (T IM E, \u227a) with the theory of state sequences, S1S [Buc60], through a\nmonotonically non decreasing function f : N 7\u2192 T IM E that associates a time\nwith every state in the sequence. Thus a timed state sequence is a pair (\u03c3 0 , f )\nconsisting of an infinite sequence of states \u03c3 0 = s00 s01 . . . and function f .\nLet us additionally consider monotonically non decreasing function g : N 7\u2192\nT IM E representing the minimum of the timeouts in a state. This defines a\ntimeout state sequence as a triple (\u03c3 0 , f, g).\nLet LT2 be a second-order language with two sorts, a state sort and a time sort\nas considered in [AH93]. The vocabulary of the congruence free sub language\nof LT2 consists of:\n\u2022 The sets Var1 and Var2 for state sort. Set Var1 = {i, j, . . .} consists of\nindividual (first order) variables and the set Var2 = {p, q, . . .} contains\n(second-order) set or predicate variables.\n\u2022 The binary predicate symbol < over the state and time sort;\n\u2022 The unary function symbol f from the state sort into the time sort;\n\u2022 The quantification over individual variables in Var1 and over predicate\nvariables in Var2 .\nLet LT2 O be the language which in addition to LT2 also contains:\n\u2022 The unary function symbols g from the state sort into the time sort;\n\u2022 The set of additional unary function symbols Var2t = {t1 , t2 , . . .} from\nthe state sort into the time sort;\nWe consider only those formulas which do not contain any free individual variables. Further, we restrict our attention to structures that choose the set of\nnatural numbers N as domain for both sorts with usual linear order < on them.\nGiven a formula \u03c6 of LT2 O with the free predicate variables p1 , . . . , pn \u2208 Var2 and\nfree function symbols T\u03c8 = {t1 , . . . , tk } \u2286 Var2t , an interpretation I for \u03c6 specifies the sets pI1 , . . . pIn \u2286 N, monotonically non decreasing functions f I : N 7\u2192 N\nand g I : N 7\u2192 N, tI1 : N 7\u2192 N, . . . , tIk : N 7\u2192 N. The satisfaction relation |= is\ndefined in a standard fashion.\nEvery interpretation I for \u03c6 implicitly defines a timeout state sequence\n(\u03c3 0 , f, g): Let \u03c3 0 be the infinite sequence of states s00 s01 . . ., where s0i \u2208 2{p1 ,...,pn } \u00d7\nNk such that (pj , (n1 , . . . , nk )) \u2208 s0i \u21d4 i \u2208 pIj and \u22001 \u2264 j \u2264 k.tj I (i) = nj . Also\nlet f = f I and g = g I for notational convenience.\nLT2 O -formulas define properties of timeout state sequences. For example, a\nbounded timeout response property discussed earlier (ref. Eq. (2)), and can be\ndefined by a formula\n\u2200i.(p(i) \u2227 (f (i) = g(i)) \u21d2 \u2203j \u2265 i.(q(j) \u2227 (f (j) = g(j)) \u2227 (f (j) \u2264 f (i) + 5)))\n(\u03c6BRLT )\n\n7\n\n\fAn LT2 O -formula \u03c6 is satisfiable (valid) if it is satisfied by some (every) timeout\nstate sequence. The (second-order) theory of timeout state sequences is the set\nof all valid formulas of LT2 O . The following result is an immediate adaptation\nof the decidability result from [AH93]:\nFact 1 (Decidability) The validity problem for the language LT2 O is decidable.\n\n3.2\n\nTLTL as a fragment of LT2 O\n\nNow we provide a meaning preserving compositional translation of TLTL formulas into LT2 O . Every TLTL-formula \u03c8 := \u2200t1 . . . tk .\u03c6 can be translated\ninto LT2 O , while preserving the set of models of \u03c8. The translation will use\nT\u03c8 = {t1 , . . . , tk } to capture the static timing variables in T\u03c8 = {t1 , . . . , tk },\nand a free individual variable i \u2208 Var1 acting as a state counter. For every\nproposition p of TPTL, we use a corresponding unary predicate p(i) of state\nsort. We translate a TLTL-formula \u03c8 to the LT2 O -formula\nTr (\u03c8) = \u2200i.\u2200tj \u2208 T\u03c8 . [\u039bm2 \u2227 \u039bm3 \u2227 \u039bm4 \u2227 \u039bm5 \u2227 Tr0 (\u03c6)]\nwhere semantic constraints of TLTL as defined in Section 2.2 are encoded by\n\u039bm2 . . . \u039bm5 :\n\u039bm2 : \u2200l \u2208 N.\u2203m \u2208 N.f (m) > l\n\u039bm3 : W\n[f (i) < g(i) \u21d2 (g(i + 1) = g(i)) \u2227 (f (i + 1) = g(i))]\nW[f (i) = g(i) \u21d2 (g(i + 1) > g(i)) \u2227 (f (i + 1) = f (i))]\n\u00ac[f (i) > g(i)]\n\u039bm4 : \uf8eb\n[(f (0) = 0) \u2227 (g(0) = 0)]\n\uf8f6 \u2228 [(f (0) \u2265 0) \u2227 (f (0) < g(0))]\n^\n\u039bm5 : \uf8ed\n(tj (i) = tj (0))\uf8f8\n1\u2264j\u2264k\n\nThe mapping T ri , for i \u2265 0, is defined by induction on the structure of TLTLformulas.\nT ri (false)\nT ri (p)\nT ri (x v y)\nT ri (x v tj + c)\nT ri (\u03c6 \u2228 \u03c6)\nT ri ( \u03c6)\nT ri (\u03c6 U\u03c6)\n\n=\n=\n=\n=\n=\n=\n=\n\nfalse\np(i)\nf (i) v g(i)\nf (i) v tj (0) + c\nT ri (\u03c6) \u2228 T ri (\u03c6)\nT ri+1 (\u03c6)\n\u2203j \u2265 i.(T rj (\u03c6) \u2227 \u2200i \u2264 k < j.T rk (\u03c6))\n\nGiven a model \u03c3 = s0 , s1 , . . . of TLTL-formula \u03c8, we can associate an LT2 O\ninterpretation I = (\u03c3 0 , f, g) with Tr (\u03c8) by making p(i) = 1 if si |= p and f (i) =\nsi (x), g(i) = si (y), and tj (i) = s0 (tj ). Similarly, given an LT2 O interpretation\nI = (\u03c3 0 , f, g) we generate a model \u03c3 = s0 , s1 , . . .. Now by structural induction\non \u03c6 we can prove the following:\nTheorem 1 Let \u03c8 be a TLTL formula. Then for a given model \u03c3 of \u03c8, we\nhave, \u03c3 |= \u03c8 if and only if (\u03c3 0 , f, g) |= Tr (\u03c8).\n\n8\n\n\f4\n\nA Comparison of TLTL with Other Logical\nFormalisms\n\nThe most popular formalism for specifying properties of reactive systems is\nthe linear temporal logic [Pnu77, LP85]. The automatic verification and synthesis for finite state systems is usually carried out using the tableau-based\nsatisfiability algorithm for a propositional version of the linear temporal logic\n(PLTL) [LP85]. PLTL is interpreted over models which retain only temporal\nordering of the states by abstracting away the actual time instants at which\nevents occur. However real-time systems call for explicitly expressing real-time\nconstraints to reason about them, such as the bounded response property which\nnecessitates the development of formalisms which can express explicit time.\nThere are several approaches to extend LTL to express timing constraints.\nThe first approach incorporates an explicit variable x, which expresses the current time without introducing any extra temporal operators. This is referred to\nas explicit clock approach, since the only new element introduced is the explicit\nclock variable. An example of a first-order explicit clock logic is Real Time\nTemporal Logic (RTTL) [Ost89], which is defined without restrictions on the\nassertion language for atomic timing constraints. A propositional version of this\nlogic, called XCTL (Explicit Clock Temporal Logic), is discussed in [HLP90].\nThis logic allows integer variables to record the values of the global clock at\ndifferent states, and integer expressions over these variables.\nAn alternative approach to express timing properties in a temporal logic has\nbeen to introduce a bounded version of the temporal operators. For example, a\nbounded operator 3[2,4] is interpreted as \"eventually within 2 to 4 time units\".\nUsing this notation we can write the time-bounded response property discussed\nearlier as:\n2(p \u21d2 3[0,5] q)\n(\u03c6BRM T L )\nThis approach for the specification of timing properties has been advocated by\nKoymans [Koy90] and is known as as Metric Temporal Logic (MTL).\nIn yet another approach, time in a state is accessed through a quantifier,\nwhich binds (\"freezes\") a variable to the corresponding time. This idea of\nfreeze quantification was introduced by Alur and Henzinger in [AH94] in a logic\nknown as TPTL (Timed Propositional Temporal Logic). The freeze quantifier\n\"x.\" binds the associated variable x to the time of the current temporal context;\nthe formula x.\u03c6(x) holds at time t0 iff \u03c6(t0 ) does. Thus in a formula 3x.\u03c6, time\nvariable x is bound to the time of the state at which \u03c6 is \"eventually\" true. By\nadmitting atomic formulas that relate the time instants of different states, the\ntime-bounded response property can be written as:\n2xp .(p \u21d2 3xq .(q \u2227 xq \u2264 xp + 5))\n\n4.1\n\n(\u03c6BRT P T L )\n\nTLTL vs XCTL\n\nThe logic XCTL as described in [HLP90], contains static timing variables and\nan explicit clock variable in its vocabulary. An atomic formula af is either an\natomic proposition in P or a constraint of the form x \u223c u or c \u223c u, where\nu = a0 + a1 \u2217 t1 + * * * am \u2217 tm with constants a0 , a1 . . . \u2208 N and c \u2208 N, and\nt0 , t1 , . . . , tm being static timing variables.\n\n9\n\n\fXCTL formulas are built using the following grammar\n\u03c6 ::= af | \u03c6 \u2228 \u03c6 | \u00ac\u03c6 |\n\n\u03c6 | \u03c6 U\u03c6\n\nwhere af ranges over Af .\nA model for XCTL consists of a sequence of states,\n\u03c3 : s0 s1 . . . ,\nsuch that each state si gives a boolean interpretation to the propositions and an\ninteger interpretation to the timing variables and to the clock variable x. Similar\nto TLTL, all static timing variables appearing in a XCTL formula assume the\nsame valuation in all the states.\nWhen compared to TLTL, it turns out that there exist properties involving\nthe dynamic variable y, which cannot be expressed in XCTL. For example, for\na timeout model of a real-time system the following property can be expressed\nin TLTL, - \"timeout occurs infinitely often\":\n23(x = y)\n\n(3)\n\nThe following sequence of states satisfies (3),\n{0, 0}, {0, 3}, {3, 3}, {3, 5}, {5, 5}, . . .\n\n(4)\n\nIn case of XCTL, only way to effectively characterize the state sequences satisfying (3) is by using constraints of the form x \u223c u or u \u223c c. However, since\nstatic timing variables need to be given the same value in all the states in a state\nsequence, an equality of the form x = u involving only static timing variables\nand constants in the r.h.s. expression u can hold true only for a single value of\nx (and u) in only finitely manly states in a state sequence, where x assumes this\nvalue. Therefore, we need an infinite disjunction of such equalities to express\n(3) in XCTL, implying that there cannot exist any syntactically correct XCTL\nformula which can effectively characterize the state sequences similar to the one\ngiven in (4) satisfying (3).\nOn the other hand, consider XCTL formula\n2(p \u2227 (x = tp ) \u21d2 2(q \u2227 (x = tq ) \u21d2 2(r \u2227 (x = tr ) \u21d2 [tq \u2212 tp \u2264 tr \u2212 tq ]))) (5)\nThis formula specifies that delay between events p and q is always less than the\ndelay between q and r. This property cannot be specified in TLTL owing to the\nexclusion of the inequalities involving more than one static timing variable.\n\n4.2\n\nTLTL vs TPTL\n\nIn [AH94], Alur and Henzinger proposed an extension of LTL that is capable of\nrelating the times of different states. For this purpose, they use freeze quantification by which every variable is bound to the time of a particular state. TPTL\nallows infinite number of variables V = {x1 , x2 , x3 , . . .} over which freeze quantification can be applied. The formulas of TPTL are built using the following\ngrammar,\n\u03c6 ::= af | \u03c6 \u2228 \u03c6 | \u00ac\u03c6 |\n\u03c6 | \u03c6 U\u03c6 | xi .\u03c6\n\n10\n\n\fwhere af is either an atomic proposition from P or a constraint of the form\nu1 \u2264 u2 , u1 \u2261d u2 , where u1 , u2 := xi + c | c and c \u2265 0, d \u2265 2 are integer\nconstants. Together they form the set of atomic formulas Af . A variable xi can\nbe bound by a freeze quantifier as \"xi .\", which \"freezes\" xi to the time of local\ntemporal context. Only closed formulas, where every occurrence of a variable is\nunder the scope of a freeze quantifier, are considered.\nThe semantics for TPTL formulas is given by a sequence of states \u03c3 =\ns0 , s1 , . . . and an interpretation (environment) for the variables in V , E : V \u2192 N.\nThe underlying time domain is taken to be the set of natural numbers N. As\nbefore, each state assigns a Boolean interpretation to the propositions, and a\n(weakly) monotonic integer interpretation to a (hidden) global timing variable\n\u03c4 , which is not used in the syntax of the formulas. We consider only atomic\nformulas in Af and formulas with freeze quantifiers. Let E(xi + c) = E(xi ) + c\nand E(c) = c. Also let E[xi := a] denote the environment that agrees with the\nenvironment E on all variables except xi , and maps xi to a \u2208 N.\nsi\nsi\nsi\nsi\n\n|=E\n|=E\n|=E\n|=E\n\np\nu1 \u2264 u2\nu1 \u2261d u2\nxi .\u03c6\n\niff\niff\niff\niff\n\nsi (p) = true\nE(u1 ) \u2264 E(u2 )\nE(u1 ) \u2261d E(u2 )\nsi |= \u03c6[E(xi ) = si (\u03c4 )]\n\nA timed state sequence \u03c3 is a model of a closed formula \u03c6 iff s0 |=E \u03c6 for any\nenvironment E.\nAs already noticed in [AH92], the static constraints in TLTL can play the\nsame role as the freeze quantifier plays in TPTL. For example, consider the\ntime-bounded response property \u03c6BRT LT L again. This will be satisfied by only\nthose models, which exactly assign a value to t0 , which is also the clock valuation\nat the instance of the occurrence of the event p, and therefore it is equivalent\nto the TPTL formula \u03c6BRT P T L . In general, assuming the same set of atomic\nconstraints, a TPTL formula\nx.\u03c6\nis equivalent to the TLTL formula\n\u2200t0 .(x = t0 \u21d2 \u03c6)\n\n(6)\n\nHowever, this apparent syntactic correspondence is not without its problems.\nTPTL allows defining timing constraints referring to time instances of two past\nstates e.g.,\n2t1 . t2 .3(alarm \u2227 t2 > t1 + 5)\nThis formula states that from now, if the time difference between two successive\nstates is more than 5 units, eventually an alarm would be raised. Since TLTL\ndoes not allow referring to two past time instances, there is no syntactically\nstraightforward translation for such formulas in TLTL using (6) above. However\nas it turns out, this is really not a problem because such formulas involving\nreference to two past timing instances are semantically equivalent to formulas\nwhich demand referring to only one previous time instance in the state, where\nthe second timing instance would be frozen. In this example an semantically\nequivalent TPTL formula would be\n2t1 .\n\nt2 .(t2 > t1 + 5 \u21d2 3(alarm))\n11\n\n\fwhich can be translated into an equivalent TLTL formula using (6) (omitting\nthe outermost quantification)\n2(x = t1 \u21d2\n\n(x = t2 \u21d2 ((x > t1 + 5) \u21d2 3(alarm))))\n\nIt may be also noted that TLTL is suitable in case where one needs to express\nformulas about timed systems with timeouts as the following kinds of condition\ncannot be expressed in TPTL - \"timeout always occurs in the next state of time\nincrement.\"\n2((x < y) \u21d2 (x = y))\n(7)\nThe reason that there cannot be any formula in TPTL, which can characterize\nexactly the same set of models as the formula (7) does is as follows. Since x\nrefers to the time(s) when (7) holds, these can only be captured using freeze\nquantifier in TPTL. Now since TPTL inequalities only involve (frozen) variables\nor constants, for variable y also, we need to use these. However, y being a\ndynamic variable would assume infinitely many different values in a model of\nthe formula (7), these values cannot be captured using constants (or else would\ndemand infinitely many constant based inequalities of the form [x < c \u21d2 (x =\nc)]). Therefore, the only option is to potentially use variables under freeze\nquantifier. However, the inequality x < y would demand that such variable\n(that is y) must refer to a future state, since time flows only in the forward\ndirection, in particular, the next state itself. A formula like the one below may\n(appear to) capture such a scenario.\n2x.((x < y) \u21d2\n\ny.(x = y))\n\n(8)\n\nHowever atomic constraints in TPTL cannot refer to the time points of the\nfuture states as is evident from the very syntax of the freeze quantifier, e.g., in\ncase of the TPTL formula (8). First, y is a free variable and then y is bound\nby the (second) freeze quantifier and therefore, both ys are actually different\nvariables - such formulas involving free variables are in any case not allowed in\nTPTL. Thus, neither constants nor timing variables based inequalities can be\nused to express the inequalities appearing in the formula (7). That is why, the\nstate sequences satisfying TLTL formula (7) cannot be characterized in TPTL.\nOn the other hand, there are formulas in TPTL, which cannot be characterized in TLTL. For example, consider the state sequences, in which \"an event\np occurs at all even time points.\" This can be characterized by the TPTL formula 2x.(x \u22612 0 \u21d2 p). However, as proved in [AH93], this property is not\nexpressible without congruences. This in turn, implies that due to the nature\nof arithmetical constraints, this TPTL formula cannot be expressed in TLTL.\n\n4.3\n\nTLTL vs MTL\n\nMTL [Koy90] extends LTL by constraining the temporal operators on (bounded\nor unbounded) intervals of the real numbers specified as subscripts. The formulas in MTL are inductively built using the following grammar\n\u03c6 ::= p | \u03c6 \u2228 \u03c6 | \u00ac\u03c6 | \u03c6 UI \u03c6\nwhere p \u2208 P is a proposition and I is a (bounded or unbounded) interval with\ninteger (or rational) end-points. An interval is a nonempty convex subset of\n12\n\n\fR\u22650 , which may assume one of the following forms: [a, b], [a, b), [a, \u221e), (a, b],\n(a, b), (a, \u221e), where a \u2264 b for a, b \u2208 R\u22650 . The interval I is singular iff it is of\nthe form [a, a] (also written as = a).\nThe formulas of MTL can be interpreted over a timed state sequence (\u03c3, f ),\nwhere \u03c3 = s00 , s01 , . . . is a untimed state sequence giving Boolean interpretation\nto the propositions and f : N 7\u2192 R\u22650 is a mapping such that f (i) denotes the\ntime at state s0i . The satisfaction relation (\u03c3, f ) |= \u03c6 is defined in a usual way.\nWe only mention the case of the formula \u03c6 UI \u03c6:\n(si , f (i)) |= \u03c6 UI \u03c6 iff \u2203j \u2265 i.[((sj , f (j)) |= \u03c6)\n^\n(\u2200i \u2264 k < j.(sk , f (k)) |= \u03c6) \u2227 (f (j) \u2208 f (i) + I)],\nwhere f (i) + I is defined using simple rules of interval arithmetic, e.g., if I =\n[a, b], then f (i) + I stands for the interval [f (i) + a, f (i) + b].\nSince it is well known that the satisfiability and model-checking problems\nfor MTL are undecidable over the state-based semantics (under R\u22650 ), we will\nconsider a fragment of MTL known as Metric Interval Temporal Logic (MITL)\nintroduced by Alur et al. [AFH96], in which the temporal operators can only be\nconstrained by nonsingular intervals. Thus 'punctuality properties' like 3=3 p\n(\"eventually exactly after 3 time units p would hold\") cannot be specified in\nMITL.\nIt is known that any MITL formula can also be expressed in TPTL [AH93].\nSpecifically, if the atomic constraints permit comparison and addition of constants, then MITL formula\n\u03c6 UI \u03c6\n(9)\nis equivalent to the TPTL formula\nx.\u03c6 Uz.(\u03c6 \u2227 z \u2208 x + I)\nwhere z \u2208 x+I can be expressed using TPTL constraints given the boundaries of\nI. It has been shown recently in [BCM05] that TPTL is strictly more expressive\nthan MTL for both point-wise and interval-based semantics. Now in the light\nof the discussion presented in previous Section 4.2, it is easy to see that any\nMITL formula can also be expressed in TLTL. Specifically, MITL formula (9)\nis equivalent to the TLTL formula\n\u2200t0 .(x = t0 \u21d2 \u03c6 U(\u03c6 \u2227 x \u2208 t0 + I)\nwhere x \u2208 t0 + I can be expressed using atomic constraints in TLTL, given the\nboundaries of I. For example, MITL formula, 2(p \u21d2 3[2,5] q) can be expressed\nin TLTL as\n\u2200t0 .2(p \u2227 x = t0 \u21d2 3(q \u2227 x \u2265 t0 + 2 \u2227 x \u2264 t0 + 5)).\nAlso, on the other hand, there exist TLTL formulas (e.g., one given in (7)),\nwhich cannot be expressed in MTL under point-wise semantics.\n\n5\n\nDecision Procedure for Validity of TLTL formulas\n\nWe consider a decision procedure for checking the validity of TLTL formulas\nemploying similar techniques used in [HLP90]. In order to check the validity\n13\n\n\fof a given TLTL formula \u03c8 = \u2200t1 . . . tk .\u03c6, we take the negated formula \u00ac\u03c6 and\nactually check for its satisfiability using a tableau like construction by posing\nthe question, 'are there positive real values for the timing variables t1 , . . . , tk\nthat will make the formula \u00ac\u03c6 satisfiable?'\n\n5.1\n\nClosure of a Formula\n\nLet \u03c6 be a TLTL formula, which is to be checked for satisfiability. We define\nthe Fischer-Ladner closure Cl(\u03c6) as the least set containing \u03c6 and closed under\nthe following:\n(c1 ) true, false,\n\ntrue \u2208 Cl(\u03c6),\n\n(c2 ) \u2200p \u2208 P\u03c6 , p, \u00acp \u2208 Cl(\u03c6), where P\u03c6 is the set of atomic propositions appearing in \u03c6,\n(c3 ) \u00ac\u03c8 \u2208 Cl(\u03c6) \u21d4 \u03c8 \u2208 Cl(\u03c6) \u2013 we identify \u00ac\u00ac\u03c8 with \u03c8 and \u00actrue with false,\n(c4 ) \u03c8 \u2228 \u03c8 0 \u2208 Cl(\u03c6) \u21d2 \u03c8, \u03c8 0 \u2208 Cl(\u03c6),\n(c5 )\n(c6 ) \u00ac\n\n\u03c8 \u2208 Cl(\u03c6) \u21d2 \u03c8 \u2208 Cl(\u03c6),\n\u03c8 \u2208 Cl(\u03c6) \u21d2\n\n\u00ac\u03c8 \u2208 Cl(\u03c6),\n\n(c7 ) \u03c8 U\u03c8 0 \u2208 Cl(\u03c6) \u21d2 \u03c8, \u03c8 0 ,\n\n(\u03c8 U\u03c8 0 ) \u2208 Cl(\u03c6),\n\n(c8 ) x v y \u2208 Cl(\u03c6) \u21d2 x < y, x = y \u2208 Cl(\u03c6),\n(c9 ) x v u \u2208 Cl(\u03c6) \u21d2 x v0 u \u2208 Cl(\u03c6) for every v0 \u2208 \u2206,\n(c10 ) x < y \u2208 Cl(\u03c6) \u21d2\n\n(x = y), 3(x < y) \u2208 Cl(\u03c6)\n\n(c11 ) x = y \u2208 Cl(\u03c6) \u21d2\n\n(x < y), 3(x = y) \u2208 Cl(\u03c6)\n\n(c12 ) x v u \u2208 Cl(\u03c6) \u21d2 3(x > u) \u2208 Cl(\u03c6).\nIntuitively Cl(\u03c6) includes all the formulae that play some role in deciding the\nsatisfiability of \u03c6. Using structural induction on \u03c6, it can be shown that |Cl(\u03c6)|\n\u2264 7|\u03c6| + 3.\n\n5.2\n\nAtoms\n\nAn atom A \u2286 Cl(\u03c6) is a consistent set of formulas such that\n(a1 ) true,\n\ntrue \u2208 A.\n\n(a2 ) For every \u03c8 \u2208 A \u21d4 \u00ac\u03c8 6\u2208 A.\n(a3 ) For every \u03c8 \u2228 \u03c8 0 \u2208 A \u21d4 \u03c8 \u2208 A or \u03c8 0 \u2208 A.\n(a4 ) For every \u03c8 U\u03c8 0 \u2208 A \u21d4 \u03c8 0 \u2208 A or \u03c8,\n\n(\u03c8 U\u03c8 0 ) \u2208 A.\n\n(a5 ) For every x < y, x = y \u2208 Cl(\u03c6), precisely one of them is in A.\n(a6.1 ) For every x < y \u2208 A \u21d2\n\n(x = y) \u2208 A.\n\n(a6.2 ) For every x = y \u2208 A \u21d2\n\n(x < y) \u2208 A.\n14\n\n\f(a7 ) For every x v u \u2208 Cl(\u03c6), exactly one of x < u, x = u, or x > u is in A.\n(a8 ) If C(A) denotes the set of all constraints in A, it is required that C(A)\nforms a consistent set. In particular, for every x v ui \u2208 Cl(\u03c6), x v\nu\nVi \u2208 C(A) only if exactly one of the following holds, where we let HA =\nxvuj \u2208C(A) (x v uj ):\n\uf8f1\n\uf8f2 x < y \u2208 A and (x < y) \u2227 (x v ui ) \u2227 HA is satisfiable over R\u22650 OR\nx = y \u2208 A and (x = y) \u2227 (x v ui ) \u2227 HA is satisfiable over R\u22650 OR\n\uf8f3\nx < y, x = y \u2208\n/ A and (x v ui ) \u2227 HA is satisfiable over R\u22650\nInformally, we include a static constraint x v ui \u2208 Cl(\u03c6) in atom A only\nif the resultant set of constraints in A remains consistent.\n(a9 ) For every x v u \u2208 A \u21d2 true U(x > u) \u2208 A.\nThe requirement that every atom contains the formula true is to ensure that\nonly infinite sequences will be considered as possible models.\nAdditionally, we define two special atoms.\nA0= = {true,\n\ntrue, x = 0, x = y,\n\n(x < y), trueU(x > 0),\n\n(trueU(x > 0))}, and\nA0< = {true,\n\ntrue, x = 0, x < y,\n\n(x = y), trueU(x > 0),\n\n(trueU(x > 0)),\n\n(x > 0)}.\n\nWe denote the set of all atoms by At, which also contains A0= and A0< .\n\n5.3\n\nTableau Construction\n\nWe construct a structure A\u03c6 = (At, R), which is a directed graph with atoms\nas nodes; and its edges are defined by the relation R as follows:\n\uf8f1\n\uf8f4\n\uf8f4 1. for every a \u2208 Cl(\u03c6),\n\uf8f4\n\uf8f4\na \u2208 A \u21d4 a \u2208 B, where a \u2208 P\u03c6 \u222a C(\u03c6);\n\uf8f4\n\uf8f4\n\uf8f2\n2. for every x = u \u2208 Cl(\u03c6),\n(A, B) \u2208 R \u21d4\nx = u \u2208 A \u21d2 x = u \u2208 B or x > u \u2208 B;\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n3.\nfor\nevery x > u \u2208 Cl(\u03c6),\n\uf8f4\n\uf8f4\n\uf8f3\nx > u \u2208 A \u21d2 x > u \u2208 B;\nwhere C(\u03c6) refers to the set of atomic constraints appearing in \u03c6.\nIt is not difficult to see that under the definition of R, the following facts\nhold.\nFact 2 There is no atom A \u2208 At such that (A, A0= ) \u2208 R.\nFact 3 There is no atom A \u2208 At \\ {A0= } such that (A, A0< ) \u2208 R.\nIn other words, atom A0= has no incoming edges and the only permissible\nincoming edge to atom A0< is (A0= , A0< ) \u2208 R. A0= and A0< will be referred\nfrom now on as initial atoms. Also note that only states, where atom A0=\nmay hold are those which interpret both clock variable x and minimum of the\ntimeout variable y as 0.\nLet A0 = (W 0 , R0 ) be a substructure of A\u03c6 and let C be a strongly connected\nsubgraph (SCS) of A0 .\n15\n\n\f\u2022 C is said to be terminal in A0 if it has no outgoing edges.\n\u2022 C is said to be self-fulfilling if every atom has a successor in C, and\nfor every p Uq \u2208 A \u2208 C, there exists B \u2208 C such that q \u2208 B.\n\u2022 C is said to be useless in A0 if it is terminal in A0 but is not self-fulfilling.\n\n5.4\n\nThe Timing Relation between Atoms\n\nRelation between Successive Atoms:\nConsider two atoms A, B from A\u03c6 such that (A, B) \u2208 R. Assume the set of\nconstraints in A to be C(A) = T (A) \u222a S(A), where T (A) = {Tout } contains\nthe (unique) dynamic constraint and S(A) = {S1 , . . . , Sm } the set of static constraints. Further, the set of constraints in B is C(B) = T (B) \u222a S(B) where\n0\n0\nT (B) = {Tout\n}, and S(B) = {S10 , . . . , Sm\n}. For every Si there is a corre0\n0\nsuch that:\nsponding Si and for Tout there is a corresponding Tout\n\u2022 if Si is x < u, Si0 is x v u. This follows from the condition (a7 ) in\nSection 5.2 for defining an atom,\n\u2022 if Si is x = u, Si0 is either x = u or x > u. This follows from the condition\n(2) for defining R in Section 5.3,\n\u2022 if Si is x > u, Si0 is also x > u. This follows from the condition (3) for\ndefining R in Section 5.3, and\n0\n0\n\u2022 if Tout is x < y, Tout\nis x = y. Else if, Tout is x = y, Tout\nis x < y. This\nfollows from conditions (a6.1 ), (a6.2 ) in Section 5.2 and condition (1) for\ndefining R in Section 5.3.\n\nThe temporal relation between two atoms produces the following results,\nwhich allow us to select values for x, y satisfying constraints in one atom, once\nthe values for which these variables satisfy other constraints are known. Let us\nassume that \u03c7, \u03c70 denote valuations for clock x, \u03c8, \u03c8 0 for y, and \u03b11 , \u03b12 , . . . , \u03b1k\nfor timing variables t1 , t2 , . . . , tk .\nLemma 2 If \u03c70 , \u03c8 0 , \u03b11 , \u03b12 , . . . , \u03b1k are non negative reals satisfying C(B), there\nexist non negative reals \u03c7, \u03c8 such that \u03c7, \u03c8, \u03b11 , \u03b12 , . . . , \u03b1k satisfy C(A) and \u03c7 \u2264\n\u03c70 , \u03c8 \u2264 \u03c8 0 .\nProof. Assume \u03c70 , \u03c8 0 , \u1fb1 satisfy C(B), where \u1fb1 = \u03b11 , \u03b12 , . . . , \u03b1k . We need to\nshow that there exist \u03c7 \u2264 \u03c70 , \u03c8 \u2264 \u03c8 0 such that \u03c7, \u03c8, \u1fb1 satisfy C(A). We consider different cases.\nCase 0: If C(A) = \u2205, that is, \u03c6 is a purely qualitative formula not involving\nany of static or dynamic constraints, choose \u03c7 = \u03c70 and \u03c8 = \u03c8 0 .\nCase 1: If S(A) = \u2205 but T (A) 6= \u2205. We choose \u03c7, \u03c8 based upon the nature\nof Tout .\n\u2022 Let Tout \u2261 x = y \u2208 C(A). Now by the definition of timing relation\n0\nbetween atoms A and B, we have Tout\n\u2261 x < y implying that \u03c70 < \u03c8 0 .\n0\nSo, choose \u03c8 = \u03c7 = \u03c7 .\n16\n\n\f\u2022 Let Tout \u2261 x < y \u2208 C(A). Again by the definition of timing relation\n0\nbetween atoms A and B, we have Tout\n\u2261 x = y \u2208 C(B). Therefore\n\u03c70 = \u03c8 0 . We choose \u03c8 = \u03c8 0 and some arbitrary value \u03c7 \u2208 [0, \u03c70 ). Note that\nthis is always feasible since in the only exceptional case when \u03c70 = \u03c8 0 = 0,\nB would be an initial atom A0= and thus A cannot be present (see Fact 2).\nCase 2: S(A) 6= \u2205 and there exists a constraint Si \u2208 S(A) of the form x = ti + ci\nor x = c (ci , c are constants) as the case may be, then choose \u03c7 as \u03b1i + ci or c\nwhich would necessarily satisfy all of S1 , . . . , Sm following the definition of an\natom (condition (a8 )). Now based upon the nature of Tout , we will choose \u03c8\nand prove the consistency of the choice.\n\u2022 Let Tout \u2261 x = y \u2208 C(A). Choose \u03c8 = \u03c7. Now by the definition of\n0\ntiming relation between atoms A and B, we have Tout\n\u2261 x < y. Therefore\n0\n0\n\u03c7 < \u03c8 . Now (x = ti + ci ) \u2208 S(A) \u21d2 (x = ti + ci ) or (x > ti + ci ) \u2208 S(B)\nimplying \u03c70 \u2265 \u03b1i +ci . Thus we have, \u03c8 = \u03c7 = \u03b1i +ci \u2264 \u03c70 < \u03c8 0 . Similarly,\nfor (x = c) \u2208 S(A).\n\u2022 Let Tout \u2261 x < y \u2208 C(A). Choose \u03c8 such that \u03b1i < \u03c8 \u2264 \u03c8 0 . Again by the\n0\n\u2261x=\ndefinition of timing relation between atoms A and B, we have Tout\n0\n0\ny \u2208 C(B). Therefore \u03c7 = \u03c8 . Also (x = ti + ci ) \u2208 C(A) \u21d2 (x = ti + ci )\nor (x > ti + ci ) \u2208 C(B), which also means \u03c70 \u2265 \u03b1i + ci , i.e., \u03c70 \u2265 \u03c7.\nSimilarly, for (x = c) \u2208 S(A).\n\u2022 T (A) = \u2205. Choose \u03c8 = \u03c7.\nSo, in all the situations we can choose \u03c7 and \u03c8 such that \u03c7 \u2264 \u03c70 and \u03c8 \u2264 \u03c8 0 .\nCase 3: S(A) 6= \u2205 and there does not exist any constraint Si \u2208 S(A) of the\nform x = ti + ci or x = c. Let\n\u2022 El = {\u03b1j + cj | (x > tj + cj ) \u2208 C(A)} \u222a {c | (x > c) \u2208 C(A)} and\nl = max(El ) if El 6= \u2205 else l = \u2212\u221e,\n\u2022 Em = {\u03b1j + cj | (x < tj + cj ) \u2208 C(A)} \u222a {c | (x < c) \u2208 C(A)} and\nm = min(Em ) if Em 6= \u2205 else m = \u221e.\nV\nNote that l < m since i Si is satisfiable. Again, by the definition of timing\nrelation between atoms A and B, we have \u2200w \u2208 El . (x > w) \u2208 S(A) \u21d2 (x >\nw) \u2208 S(B) implying that l < \u03c70 . Therefore, choose \u03c7 such that\nl < \u03c7 \u2264 \u03c70 if \u03c70 < m\nl < \u03c7 < m if \u03c70 \u2265 m\n\n(10)\n\nSuch a choice of \u03c7 satisfies all of S1 , . . . , Sm . Now based upon the nature of\nTout , we choose the values of \u03c7 and \u03c8 and prove the consistency of such a choice.\n\u2022 Let Tout \u2261 x = y \u2208 C(A). Choose any value for \u03c7 satisfying (10) and\nchoose \u03c8 = \u03c7. Since \u03c7 \u2264 \u03c70 < \u03c8 0 , we have \u03c7 \u2264 \u03c70 and \u03c8 < \u03c8 0 .\nV\n\u2022 Let Tout \u2261 x < y \u2208 C(A). Choose \u03c8 = \u03c70 . Because Tout \u2227 i Si is\nsatisfiable, we must be able to choose \u03c7 such that \u03c7 < \u03c8, which implies\nthat \u03c7 < \u03c70 .\n\u2022 T (A) = \u2205. Choose any value for \u03c7 satisfying (10) then choose \u03c8 = \u03c7.\nSo in both the situations we can choose \u03c7 and \u03c8 such that \u03c7 \u2264 \u03c70 and \u03c8 \u2264 \u03c8 0 .\nHence.\n17\n\n\fRelation between Atoms in a Self-Fulfilling SCS:\nIn a self-fulfilling SCS every two atoms have the same set of static constraints,\nbut they differ in the dynamic constraint.\nLemma 3 Let A and B be two atoms in some self-fulfilling SCS C, then S(A) =\nS(B), and all the static constraints must be of the form x > u.\nProof. Since A, B \u2208 C and C is a SCS, hence by definitions of atom and relation\nR, x > u \u2208 S(A) \u21d4 x > u \u2208 S(B). It remains to show that (x v0 u) 6\u2208 S(A),\nwhere v0 \u2208 {<, =}. Assume that it is not the case, which means, x v0 u \u2208 C(A).\nBy the definition of an atom, true U(x > u) \u2208 A. Since C is a self-fulfilling\nSCS, there must be an atom D \u2208 C such that (x > u) \u2208 S(D). It follows that\n(x > u) \u2208 S(A) as well because A is reachable from D, a fact that contradicts\nthe definition of an atom. Therefore, we conclude that x v0 u 6\u2208 S(A). Since\nthis will be true for atom B as well, it follows S(A) = S(B).\nLemma 4 If \u03c7, \u03c8, \u1fb1 is a satisfying solution for C(A) and A \u2208 C (a self-fulfilling\nSCS), for every B \u2208 C such that (A, B) \u2208 R, there exist \u03c70 , \u03c8 0 , such that \u03c70 , \u03c8 0 , \u1fb1\nsatisfy C(B) and \u03c70 \u2265 \u03c7, \u03c8 0 \u2265 \u03c8.\nProof. We consider only dynamic constraints appearing in A and B:\n\u2022 (x = y) \u2208 C(A) \u2227 (x < y) \u2208 C(B). Choose \u03c70 = \u03c7 and any \u03c8 0 > \u03c8.\n\u2022 (x < y) \u2208 C(A) \u2227 (x = y) \u2208 C(B). Choose \u03c70 = \u03c8 0 = \u03c8.\n\u2022 T (A) = T (B) = \u2205. Choose arbitrarily \u03c70 , \u03c8 0 \u2208 R\u22650 such that \u03c70 > \u03c7, \u03c8 0 >\n\u03c8, and \u03c70 \u2264 \u03c8 0 .\nNote that from Lemma 2, every atom in C contains all other constraints of the\nsame form x > u, which are immediately satisfiable by any \u03c70 \u2265 \u03c7.\n\n5.5\n\nFulfilling Paths and Satisfiability\n\nAn infinite path \u03c0 = A0 , A1 , * * * , (where A0 , A1 , * * * are atoms) is called a\nfulfilling path for \u03c6 if for every i \u2265 0:\n1. \u03c6 \u2208 A0 .\n2. (Ai , Ai+1 ) \u2208 R.\n3. For every p Uq \u2208 Cl(\u03c6), if p Uq \u2208 Ai , then there exists some j \u2265 i such\nthat q \u2208 Aj .\nTheorem 5 The formula \u03c6 is satisfiable if and only if there exists a fulfilling\npath for \u03c6 in A\u03c6 .\nProof. If \u03c6 is satisfiable and \u03c3 is a model for it then the corresponding\nfulfilling path can be given by \u03c0 = A0 , A1 , * * * , where Ai = {p \u2208 Cl(\u03c6) | \u03c3 i |=\np}.\nOn the other hand let \u03c0 = A0 , A1 , * * * , be a fulfilling path for \u03c6. Define a\nmodel \u03c3 = s0 , s1 , * * * , for \u03c6 such that each state si (\u2200i \u2265 0), interprets proposition p as true iff p is in Ai . Since \u03c0 is an infinite path, beyond a certain point\n18\n\n\f(say Ak ), all the atoms in \u03c0 must be repeating infinitely often. These infinitely\nrepeating atoms must be reachable from each other, and hence must be contained in a self-fulfilling SCS C. Let \u03b11 , \u03b12 , . . . , \u03b1k , sk+1 (x), sk+1 (y) be any solution that satisfies C(Ak+1 ). Using Lemma 2, we can trace the path \u03c0 backwards\ntill A0 assigning values (s0 (x) \u2264 s1 (x) . . . \u2264 sk\u22121 (x) \u2264 sk (x) \u2264 sk+1 (x), s0 (y) \u2264\ns1 (y) \u2264 . . . \u2264 sk\u22121 (y) \u2264 sk (y) \u2264 sk+1 (y)) to (x, y) in atoms A0 , A1 , . . . Ak on\nthe way, which satisfy constraints in C(A0 ), C(A1 ), . . . C(Ak ). Also using Lemmas 3,4 we can assign values (sk+1 (x) \u2264 sk+2 (x) \u2264 sk+3 (x) . . . , sk+1 (y) \u2264\nsk+2 (y) \u2264 sk+3 (y) . . .) for the future states sk+2 , sk+3 , * * * , . Clearly \u03c3 is a\ninfinite sequence of states satisfying the formula \u03c6.\nFrom this theorem we conclude that it is sufficient to look for a fulfilling\npath for \u03c6 in A\u03c6 in order to determine the satisfiability of \u03c6.\n\n5.6\n\nSatisfiability Checking\n\nThe fulfilling path for a TLTL formula \u03c6 can be constructed as follows:\nlet A\u2217 = (W \u2217 , R\u2217 ) = A\u03c6 be the initial structure resulting from the construction\ndescribed in the Section 5.3.\nwhile(A\u2217 6= \u2205 OR A\u2217 does not contain any useless maximal SCS)\nbegin\nlet C be a useless maximal SCS in A\u2217\nW\u2217 = W\u2217 \\ C\nR\u2217 = R\u2217 \u2229 (W \u2217 \u00d7 W \u2217 )\nend\nif (there is an atom A in W \u2217 such that \u03c6 \u2208 A)\nthen report success\nelse report failure.\nTheorem 6 The formula \u03c6 is satisfiable if and only if the above algorithm\nreports success.\nThe algorithm succeeds if and only if the tableau A\u03c6 contains a finite path\n\u03c0 = A0 , . . . , Ak that starts at an atom A0 , containing \u03c6, and reaches Ak at a\nterminal self-fulfilling SCS C. This path can be used to construct a fulfilling\npath for \u03c6. Hence by Theorem 5, \u03c6 is satisfiable if and only if the algorithm\nabove reports success.\n\n5.7\n\nComplexity Analysis\n\nFor the complexity analysis we would require the following result.\nLemma 7 Checking that the constraints appearing in an atom are satisfiable\nover R\u22650 can be done in time O(|Cl(\u03c6)|).\nProof. There exists a well known polynomial time procedure [Pra77] to decide\nthe satisfiability of a conjunction of linear inequalities of the form \u03be \u2264 \u03b7 + c,\nwhere \u03be, \u03b7 are real-valued variables and c is an integer constant, by reducing the\nproblem to the problem of deciding the nonexistence of a cycle with negative\nweight in a weighted directed graph such that inequality \u03be \u2264 \u03b7 + c induces two\nnodes corresponding to variables \u03be, \u03b7 and an edge (\u03be, \u03b7) labeled with \u2212c.\n19\n\n\fNonetheless, owing to special nature of the constraints considered here, we\ncan show that a linear time procedure exists to check the satisfiability of the\nconstraints appearing in an atom. Let us partition the the set of constraints\nappearing in atom A as follows:\nC(A) = Cxy \u222a C=c \u222a C=v \u222a C>c \u222a C>v \u222a C<c \u222a C<v , where\nCxy consists of constraints of the form (x v y),\nC=c consists of constraints of the form (x = c),\nC=v consists of constraints of the form (x = t + c0 ),\nC>c consists of constraints of the form (x > c),\nC>v consists of constraints of the form (x > t + c0 ),\nC<c consists of constraints of the form (x < c), and\nC<v consists of constraints of the form (x < t + c0 ).\nNote v\u2208 {<, =}, and c, c0 \u2208 N are integer constants, and t \u2208 T is a timing\nvariable.\nIf |C=c | > 1, then C=c itself is unsatisfiable and so is C(A). Otherwise if\n(x = c) \u2208 C=c then check whether constraints in C>c \u222a C<c are satisfiable on\nassigning c to x. If not, then C(A) is also not satisfiable. Otherwise, \u2200t1 \u2208 T\nsuch that (x = t1 + c1 ) \u2208 C=v , we can assign valuation c \u2212 c1 for t1 ; \u2200t2 \u2208 T\nsuch that (x < t2 + c2 ) \u2208 C<v , we can assign valuation (c \u2212 c2 ) + z, (z > 0 :\n(c \u2212 c2 ) + z > 0) for t2 ; and \u2200t3 \u2208 T such that (x > t3 + c3 ) \u2208 C>v , we can assign\n(c \u2212 c3 ) \u2212 z, (z > 0 : (c \u2212 c2 ) \u2212 z > 0) to t3 . Also assign c to y if (x = y) \u2208 Cxy ,\nelse assign c + 1.\nIn the other case, when C=c = \u2205, calculate l = max(C>c ) if C>c 6= \u2205, else\nl = \u2212\u221e and m = min(C<c ) if C<c 6= \u2205, else m = \u221e. We define max(C>c ) =\nmax{c \u2208 R\u22650 | x > c \u2208 C>c }, and min(C<c ) = min{c \u2208 R\u22650 | x < c \u2208 C<c }.\nNext we check if l < m. If not, these constraints cannot be satisfied simultaneously. Otherwise we can choose any value of x, l < x < m, as a solution.\nSatisfying valuations to all timing variables can be assigned accordingly.\nTo estimate the time complexity, notice that partitioning of C(A) can be\ndone in linear time with respect to the size of the constraint set since in order\nto place a constraint in its correct partition it only requires to check the form\nof inequality and type of variable (constant or variable). All other steps of\nchecking satisfiability and assigning valuations to timing variables in T can also\nbe carried out in time linear on the size of the constraint set, where size of the\nconstraint set is bounded by |Cl(\u03c6)|\nTheorem 8 Satisfiability problem for (unquantified) TLTL is PSPACE Complete.\nProof. Let |A\u03c6 | denote the size of the structure A\u03c6 , which is bounded by the\nnumber of possible subsets of Cl(\u03c6), that is, |A\u03c6 | \u2264 2O(|Cl(\u03c6|)) . The number of\nconstraints appearing in any atom are also bounded by |Cl(\u03c6)| \u2264 7|\u03c6|, therefore\n|A\u03c6 | \u2264 2O(|\u03c6|) . By Lemma 7, consistency checking of these constraints can be\nperformed in time O(|Cl(\u03c6)|). This results in an overall time-bound 2O(|\u03c6|) |\u03c6| =\n2O(|\u03c6|+log|\u03c6|) = 2O(|\u03c6|) .\nUsing a similar argument presented in [SC85], we can conclude that there\nexists a nondeterministic algorithm M , which (generates A\u03c6 'on-the-fly' and)\naccepts \u03c6 iff it is satisfiable.\n20\n\n\fM uses space of the order of |Cl(\u03c6)|. Using Savitch Theorem [Sav70], it\ncan be concluded that there exists a polynomial space bounded (O(|Cl(\u03c6)|2 ))\ndeterministic algorithm which can decide satisfiability of a TLTL formulae.\nIt is also shown in [SC85] that satisfiability of LTL with U and is PSPACEhard. Since LTL is properly embedded in TLTL, it renders satisfiability of\n(unquantified) TLTL PSPACE-complete.\nAs a consequence, we also have,\nTheorem 9 Validity problem for (quantified) TLTL is PSPACE Complete.\n\n6\n\nModel Checking for TLTL\n\nThe model checking problem of deciding whether a TLTL formula \u03c8 is satisfied\nby all the computations of a given timeout program P with clock, timeout, and\nstatic timing variables, is conceptually much harder than deciding the validity\nof TLTL formulas. This difficultly arises due to the fact that clock, timeout, and\nstatic timing variables range over the set of non negative reals, and therefore\ntimeout systems are inherently infinite state systems. This render automated\nverification of these systems difficult as most of the model checking techniques\nproceed by exhaustive enumeration of the state space.\nTherefore we consider a restriction of TLTL over N (i.e., clock, timeout, and\nstatic timing variables assume positive integer valuations). Also we restrict our\nattention to only those timeout systems where increments in the values of the\ntimeout variables and thus, the clock increments are allowed only over a finite\nrange of values, while taking transitions.\n\n6.1\n\nTimeout Programs\n\nThe representation of a finite state timeout program that we consider, is given\nby a timeout Kripke structure (TKS) K = hS, S 0 , Ei over the clock x, the set\nof static timing variables T , a finite set T O of timeout variables \u03c41 , \u03c42 , . . . , \u03c4n\nused to record the values of timeouts such that T O \u2229 T = \u2205, and a variable y\nwhich equals min T O = min{\u03c4i : \u03c4i \u2208 T O}, where\n\u2022 S is a finite set of locations. Each location s \u2208 S gives a boolean interpretation to each of the propositions and an integer interpretation to static\ntiming variables appearing in \u03c8 (i.e., the set T\u03c8 ) in the interval [0, M ],\n\u2022 S 0 \u2286 S is the set of initial locations defining the values for static timing\nvariables for the runs starting from these locations,\n\u2022 E = (E + \u222a E 0 ) \u2286 (S \u00d7 N \u00d7 (N \u222a {?}) \u00d7 S) - denotes the set of edges\nconnecting locations in S. E is partitioned into two disjoint sets E + and\nE 0 . If (s, l, m, s0 ) \u2208 E + then l = m = 0. For simplicity we omit l and m\nfor E + edges and represent them as (s, s0 ). For E 0 edges either l and m\nassume non zero positive integral values, which define the finite range of\nvalues for incrementing timeouts or, specifies open ended range of values\nlarger than l for incrementing timeouts when m is ?.\nThe operational meaning to E + and E 0 is given as follows.\n\n21\n\n\f\u2022 E + is the set of delay transitions, whereby clock x advances to min T O,\nthat is, if (s, 0, 0, s0 ) \u2208 E + , then on taking this transition, the value of the\nclock x is incremented to min T O.\n\u2022 E 0 represents the set of the discrete transitions. For (s, l, m, s0 ) \u2208 E + on\na discrete transition at least one of the timeouts attaining the minimum\nvalue is incremented by some arbitrary value \u03b4 in [l, m] (if m \u2208 N), or\n\u03b4 \u2265 l (if m is ?).\nThe semantics of a TKS K is defined as follows: We define a timeout computation of K to be an infinite sequence of timeout states\n\u03c3 : hs0 , x0 , y0 , T O0 i, hs1 , x1 , y1 , T O1 i, * * * ,\nwhere x0 , x1 , * * * , denote the clock values, y0 , y1 , * * * , denote the values for the\nvariable y, and T O0 , T O1 , * * * denote sets of values for the timeouts in T O for\ni = 0, 1, . . . such that T Oi [j] would denote the value of \u03c4j in T Oi . All (static)\ntiming variables in T assume the same valuation in every state. Thus we have,\n\u2022 s0 \u2208 S0 and either x0 = y0 = min T O0 = 0 or 0 = x0 < y0 = min T O0 .\n\u2022 For every i = 0, 1, . . .\n- \u2200tj \u2208 T : si (tj ) = s0 (tj )\n- yi = min T Oi .\n\u2022 For every i = 0, 1, . . .\n- either (si , 0, 0, si+1 ) \u2208 E + , s.t. xi < min T Oi \u2227 xi+1 = min T Oi . Also\nT Oi+1 = T Oi , that is, during delay transitions timeouts do not\nchange.\n- or (si , l, m, si+1 ) \u2208 E 0 and \u2203\u03c4j \u2208 T O s.t. T Oi [j] = min T Oi , and\nT Oi+1 [j] = T Oi [j] + \u03b4 where \u03b4 \u2208 [l, m] if m \u2208 N, otherwise \u03b4 \u2265 l if\nm is ?. Also xi+1 = xi = min T Oi and \u2200\u03c4k \u2208 T O \\ {\u03c4j }.T Oi+1 [k] =\nT Oi [k].\n\u2022 There are infinitely many i0 s such that xi+1 = min T Oi , which means\nclock and timeouts always advance.\n\n6.2\n\nA Tableau Construction for the Product of the program K and the formula \u03c6\n\nWe construct a tableau K = A\u03c6\u00d7K as the cross product of the tableau for a\n(unquantified) satisfiable TLTL formula \u03c6 and a TKS K. The elements of K\nare\n\u2022 NK is the set of the nodes consisting of pairs hA, si with A \u2208 A\u03c6 (tableau\nfor \u03c6) and s \u2208 K.\n+\n+\n0\n\u2022 EK = EK\n\u222a EK\nis the transition relation where EK\ncaptures the elapse of\n0\ntime and EK represents the discrete transition. Let u ::= t + c | c, which\nis defined in Section 2.1.\n+\n- (hA, si, hA0 , s0 i) \u2208 EK\niff (A, A0 ) \u2208 R, (s, 0, 0, s0 ) \u2208 E + and\n\n22\n\n\fx < u \u2208 C(A) \u21d2 x = u \u2208 C(A0 ) or x > u \u2208 C(A0 ),\nx = u \u2208 C(A) \u21d2 x > u \u2208 C(A0 ), and\nx < y \u2208 C(A) \u21d2 x = y \u2208 C(A0 )\n0\n- (hA, si, hA0 , s0 i) \u2208 EK\niff (A, A0 ) \u2208 R and (s, l, m, s0 ) \u2208 E 0 and\n\nx v u \u2208 C(A) \u21d4 x v u \u2208 C(A0 )\nx = y \u2208 C(A) \u21d2 (x < y) \u2208 C(A0 )\n\n4\n\n\u2022 N0 is the set of initial nodes consisting of all pairs hA, si such that \u03c6 \u2208 A\nand s \u2208 S0 .\n\n6.3\n\nModel Checking Procedure\n\nWe check if all runs of a program K satisfy a TLTL-formula \u03c8 = \u2200t1 . . . tk .\u03c6 as\nfollows:\nStep1 Construct the initial tableau A\u00ac\u03c6 for the negated formula \u00ac\u03c6 as described in Section 5.\nStep2 Construct the tableau product A\u00ac\u03c6\u00d7K as described in the Section 6.2.\nStep3 Check if A\u00ac\u03c6\u00d7K contains a self-fulfilling path for \u00ac\u03c6.\nLemma 10 The TKS K satisfies \u00ac\u03c6 if and only if A\u00ac\u03c6\u00d7K contains a selffulfilling path.\nTheorem 11 The TKS K validates the TLTL specification \u03c8 if and only if it\ndoes not satisfy \u00ac\u03c6.\n\n6.4\n\nComplexity of Model Checking\n\nThe size of the product tableau A\u00ac\u03c6\u00d7K is bounded by O(|K|\u00d7|A\u00ac\u03c6 |) or O(|K|\u00d7\n27|\u03c6| ), which is linear in the size of the TKS and exponential in the size of the\nTLTL specification \u03c6. Since deciding the presence of a self fulfilling path can\nalways be done in the worst case in time linear on the size of the product graph,\nwe conclude that the problem if a TLTL-formula \u03c8 = \u2200t1 . . . tk .\u03c6 holds in a\nTKS K can be decided in deterministic time linear in the size of the K and\nexponential in the length of \u03c6.\nFollowing the argument presented for satisfiability checking in Theorem 8,\nthere exists a non deterministic algorithm which checks if A\u00ac\u03c6\u00d7K contains a\nself-fulfilling path for \u00ac\u03c6 using O(|\u03c6|) space. This renders the model checking\nalso in PSPACE. To check the hardness part, we need to reduce the validity\nproblem for TLTL to model checking, which requires defining a TKS K of constant size such that formula \u03c6 holds iff it is valid in K. Towards that, we\nfurther assume that the range of static timing variables are restricted to the interval [0, M ] \u2286 N, where the value of M can be approximated by the maximum\npath delay in the Timeout Kripke structure defined below. The Path delay for a\nspecific (acyclic) path starting from some initial location and ending at some designated location is the sum of the maximal possible timeout increments or clock\ndelays (replacing open ended timeout increments with arbitrary values) over\n4 All\n\nthe timeouts with minimum value are incremented on taking the transition (s, s0 ).\n\n23\n\n\fthe transitions across the path. Well-known shortest path algorithms [CLRS01,\n580-642], viz., Floyd-Warshall algorithm, Dijkstra's algorithm, can be easily be\nadapted for calculating such maximal path delay over a given TKS. Now, choose\nK = h2P\u222a[0,M ] , 2P\u222a[0,M ] , 2P\u222a[0,M ] \u00d7 {0} \u00d7 {?} \u00d7 2P\u222a[0,M ] i to be the complete\ngraph over all subsets of P \u222a [0, M ].\n\n7\n\nUndecidability of Dense TLTL\n\nWe relax the time-progress condition and consider an interpretation of TLTL\nformulas over a dense time domain. We prove the resulting logic to be highly\nundecidable by reducing a \u03a311 -hard problem to its satisfiability problem.\n\n7.1\n\n2-counter Machines\n\nA nondeterministic 2-counter machine M consists of two counters C1 and C2 assuming non negative integer values, and a finite sequence of labeled instructions\n(e.g., labeled by numbers 1, 2, . . .) Each instruction may either increment or\ndecrement one of the counters, or jump, conditionally upon one of the counters\nbeing zero. When the machine M executes a non-jump instruction, it proceeds\nnon-deterministically to one of two specified instructions. For example, using\nprogramming pseudo-code notation, j th instruction may be either of the following, where i \u2208 {1, 2}:\nj\n\n:\n\nCi := Ci + 1; goto l1 or l2 ,\n\n(11)\n\nj\n\n:\n\nCi := Ci \u2212 1; goto l1 or l2 ,\n\n(12)\n\nj\n\n:\n\nif Ci = 0 goto l1 ; else goto l2 ,\n\n(13)\n\nwhere l1 and l2 are instruction labels. The configurations of such a M having\nn \u2265 0 instructions are represented by triples hi, c, di, where 0 \u2264 i < n is the\ninstruction label, and c \u2265 0, d \u2265 0 are the current values of the counters C1 , and\nthe counter C2 respectively. The relation between consecutive configurations can\nbe defined in an obvious way. A computation of M is a \u03c9 sequence of related\nconfigurations, beginning with the initial configuration, which is usually taken\nas h0, 0, 0i. Importantly, 2 counter machines are Turing complete [HMU06]. For\nmore details on counter machines see [HMU06, Chap. 8], [Jon97, Chap. 7-8].\nThe computation of a counter machine is called recurring if it contains infinitely many configurations with the value of the instruction counters being 0.\nIt was shown in [AH94] that the problem of deciding if a given nondeterministic\n2-counter machine has a recurring computation is \u03a311 -hard.\n\n7.2\n\nDense TLTL\n\nLet us relax the time-progress condition (m2 ) and extend the expressive power\nof TLTL by providing a dense semantics to it, i.e., we assume that between\nany two given time points there is another time point. We assume our time\ndomain as non-negative rationals Q\u22650 with dense linear order induced by usual\n'<' relation, which is irreflexive, comparability-permissible and transitive.\nThe technique we use to prove the undecidability of dense TLTL follows\nclosely the one described in [AH94, Section 4.4] to prove similar result for TPTL.\n\n24\n\n\fWe need a successor function S on the underlying time domain Q\u22650 . This\nfunction, when applied to an element in Q\u22650 will return an unique element\ngreater than the original element. S satisfies the following axioms: i) q <\nS(q) for all q \u2208 Q\u22650 and, ii) q < q 0 \u21d2 S(q) < S(q 0 ) for all q, q 0 \u2208 Q\u22650 .\nNote that owing to the denseness of Q\u22650 , arbitrary many time points could be\nsqueezed into a finite interval with the application of successor. For notational\nconvenience, S(q) will be represented as q + in the following discussion.\nWe encode a computation of M by using propositions p0 , p1 , . . . , pn , r1 and\nr2 , precisely one of which is true in any state. The configuration hi, c, di of M\nc\n\nd\n\nz }| { z }| {\nis represented by the finite sequence pi , r1 , . . . , r1 , r2 , . . . , r2 of states.\nThe initial configuration h0, 0, 0i can be encoded using a proposition p0 . The\nrecurrence condition can be encoded as (23p0 ). It is possible to have the k-th\nconfiguration of a computation of M correspond to the finite sequence of states\nthat is mapped to the interval [t, t+ ). We force the time to increase by a strictly\npositive amount between each successive states using 2(x = t \u21d2 (x > t)).\nNow we can copy groups of r-states by establishing a one-to-one correspondence\nof rj (j = 1, 2)-states at time t and time t+ . In the following we assume that\nt0 , t1 , t2 , . . . , stand for static timing variables.\nLet us consider the instruction (11) j : C2 := C2 + 1; goto l1 or l2 , which increments the counter C2 and proceeds nondeterministically to either instruction\nl1 or l2 . We can encode this computation by the following TLTL-formula:\n2(\u03c6 \u21d2 (\u03c81 \u2227 \u03c82 \u2227 \u03c83 (r1 ) \u2227 \u03c83 (r2 ) \u2227 \u03c84r2 )),\nwhere\n\u03c6:\n\u03c81 :\n\u03c82 :\n\u03c83 (rj ) :\n\u03c84r2 :\n\nx = t \u2227 pj\n3(x = t+ \u2227 (pl1 \u2228 pl2 ))\n2(x = t1 \u2227 (x = t2 \u2227 x < t+ ) \u21d2 3(x = t+\n1 \u2227\n2((x = t3 \u2227 x < t+ \u2227 rj ) \u21d2 3(x = t+\n\u2227\nr\n))\nj\n3\n2((x = t4 \u2227 (x = t+ )) \u21d2 3(x = t+\nr2 \u2227\n4 \u2227\n\n(x = t+\n2 )))\n(x = t++ )))\n\nThe formula \u03c6 specifies that the current state at time t corresponds to instruction j. The first conjunct \u03c81 ensures the proper progression to one of the two\nspecified instructions, l1 or l2 at time t+ . The second conjunct \u03c82 establishes a\ncorrespondence between states in successive intervals [t, t+ ) and [t+ , t++ ) representing configurations while the formula \u03c83 (rj ) copies rj -states in the corresponding states from first interval to the next. The last conjunct \u03c84r2 adds a\nr2 -state at the end of next configuration, as required by the increment operation. In case of counter C1 getting incremented, we will have \u03c84r1 instead of \u03c84r2\nspecifying an addition of a r1 state at the beginning of the r-state sequence in\nthe next configuration:\n\u03c84r1 : 2((x = t\u2227 (x = t4 \u2227((r1 \u2228r2 )\u2228(pl1 \u2228pl2 )))) \u21d2 3(x > t+ \u2227x < t+\n4 \u2227r1 \u2227\n\n(x = t+\n4 )))\n\nNext, for the instruction (12) j : C2 := C2 \u2212 1; goto l1 or l2 , which specifies\na decrement operation on C2 , we copy all r1 states as specified by \u03c83 (r1 ) above.\nHowever we copy the r2 states excluding the last copy in the sequence. This is\nachieved by first modifying \u03c83 for r2 as follows:\n\u03c830 (r2 ) : 2((x = t3 \u2227 x < t+ \u2227 r2 \u2227 \u00ac\n25\n\n(x = t+ )) \u21d2 3(x = t+\n3 \u2227 r2 ))\n\n\fand then rewriting \u03c84r2 as\n\u03c84r02 : 2((x = t4 \u2227 x < t+ \u2227 r2 \u2227\n\n(x = t+ )) \u21d2 (x = t+\n4 \u2227\n\n(x = t++ )))\n\nIn case of decrement on C1 , we copy all the r2 states as specified by \u03c83 (r2 ),\nhowever copy the r1 states only after excluding the first copy in the sequence.\nThis is achieved by modifying \u03c83 for r1 as follows:\n\u03c830 (r1 ) : 2(\u03c83yes \u2227 \u03c83no ), where\n\u03c83yes :\n(x = t3 \u2227 x < t+ \u2227 r1 ) \u21d2 3(x = t+\n3 \u2227 r1 )\nno\n\u03c83 :\n\u00ac(x = t \u2227 (x = t3 \u2227 r1 ) \u21d2 3(x = t+\n3 \u2227 r1 ))\nFinally, we encode the if-else instruction (13) j : if C1 = 0 goto l1 ; else goto l2 ;\nas following:\n2(\u03c6 \u21d2 (\u03c810 \u2227 \u03c820 \u2227 \u03c830 (r1 ) \u2227 \u03c830 (r2 )))\nwhere\n((x\n3(x = t+ \u2227 pl1 ))\nW = t \u2227 (r2 \u2228 (pl1 \u2228 pl2 ))) \u21d2\n+\n((x = t \u2227 (r1 )) \u21d2 3(x = t \u2227 pl2 ))\n\u03c820 :\n2(x = t1 \u2227 ((x = t2 \u2227 x < t+ ) \u21d2 3(x = t+\n(x = t+\n1 \u2227\n2 ))))\n+\n\u03c830 (rj ) : 2((x = t3 \u2227 x < t+ \u2227 rj ) \u21d2 3(x = t3 \u2227 rj ))\n\n\u03c810 :\n\nIn case of j : if C2 = 0 goto l1 ; else goto l2 , we modify \u03c810 as follows:\n_\n\u03c8100 : ((x = t\u2227\u00ac3(r2 )) \u21d2 3(x = t+ \u2227pl1 )) ((x = t\u22273(r2 )) \u21d2 3(x = t+ \u2227pl2 ))\nThus for this 2-counter machine, M we can construct a formula \u03c6M such that\n\u03c6M is satisfiable iff M has a recurring computation. Hence the satisfiability of\nTLTL is \u03a311 -hard.\nWe observe that the satisfiability of a TLTL formula \u03c8 can be always expressed as a \u03a311 -sentence implying the existence of a model for \u03c8. Since Q\u22650 is\ncountable, \u03c8 will also have a countable model. Thus any state sequence \u03c3 for \u03c8\ncan be encoded by finitely many infinite sets of natural numbers in first-order\narithmetic; say, one for each proposition p in \u03c8, characterizing the states in\nwhich p holds. It is easy to see \u03c8, as a first-order predicate holds in \u03c3. We\nconclude that the satisfiability of TLTL formulas is in \u03a311 .\nTheorem 12 The satisfiability problem for dense TLTL formulas is \u03a311 -complete.\n\n8\n\nDiscussion\n\nWhile existing real-time logics e.g., TPTL [AH94] can specify clock based dense\ntime properties, TLTL is more suitable for expressing properties of timeout\nbased real-time models for the given semantic interpretation using timeout dynamics where granularity of time is defined in terms of timeout updates. As\ndiscussed in Section 6, the infinite state space models of real-time systems can\nbe model checked over discrete time TLTL using the proposed abstractions on\nthe Kripke structure.\nThough we only consider minimum of the timeout values using a dummy\nvariable y, dynamic constraints involving individual timeouts (e.g., constraints\nof the form x \u2264 \u03c4j + c, where \u03c4j \u2208 T O, c \u2208 N) can be easily included in the\n26\n\n\fvocabulary of the logic because the existing tableaux procedure presented in\nSection 5.3 can be seamlessly extended using the fact that in any state s it is\nthe case, \u2200\u03c4j \u2208 T O.s(\u03c4j ) \u2265 s(y). Similarly extending the logic with constraints\ninvolving congruences similar to TPTL and arithmetic expressions involving\nmore than one timing variables similar to XCTL would enhance the expressive\npower of the logic. Digitizability [HMP92] is yet another important property for\napplying discrete time verification techniques on dense time logics and models.\nQuite often, not all the formulas in dense time logics are digitizable, thus not\namenable to discrete time verification. It remains to be seen which fragment of\nTLTL is digitizable. We conclude by trying to compare TLTL with Monadic\nSecond Order Logic of Order (MSO). It will be a routine exercise to show that\nTLTL can be embedded in MSO, following the work [AH93]. However as a\nfuture work, it would be interesting to characterize the fragment of MSO, for\nwhich TLTL will be expressively complete.\nAcknowledgment Both the authors did this work when they were with HTS\nResearch, Bangalore, India.\n\nReferences\n[AD94]\n\nR. Alur and D.L. Dill. A Theory of Timed Automata. Theoretical\ncomputer science, 126(2):183\u2013235, 1994.\n\n[AFH96]\n\nR. Alur, T. Feder, and T.A. Henzinger. The Benefits of Relaxing\nPunctuality. Journal of the ACM (JACM), 43(1):116\u2013146, 1996.\n\n[AH92]\n\nR. Alur and T.A. Henzinger. Logics and Models of Real-time: A\nSurvey. In Proceedings of the Real-Time: Theory in Practice, REX\nWorkshop, volume 600 of LNCS, pages 74\u2013106. Springer, 1992.\n\n[AH93]\n\nR. Alur and T.A. Henzinger. Real-time Logics: Complexity and\nExpressiveness. Information and Computation, 104(1):35\u201377, 1993.\n\n[AH94]\n\nR. Alur and T.A. Henzinger. A Really Temporal Logic. Journal\nof the ACM, 41(1):181\u2013203, 1994.\n\n[BCM05]\n\nP. Bouyer, F. Chevalier, and N. Markey. On the Expressiveness of\nTPTL and MTL. In Proceedings of the 25th international conference on foundations of software technology and theoretical computer science, volume 3821 of LNCS, pages 432\u2013443. SpringerVerlag, 2005.\n\n[BD98]\n\nD. Bosnacki and D. Dams. Integrating Real Time into Spin: A\nPrototype Implementation. In Proceedings of the Formal Description Techniques and Protocol Specification, Testing and Verification (FORTE/PSTV), pages 423\u2013439. Kluwer, BV, 1998.\n\n[BDL04]\n\nG. Behrmann, A. David, and K.G. Larsen. A Tutorial on UPPAAL.\nIn 4th International School on Formal Methods for the Design of\nComputer, Communication, and Software Systems (SFM-RT'04),\nvolume 3185 of LNCS, pages 200\u2013236. Springer-Verlag, New York,\n2004.\n27\n\n\f[Buc60]\n\nJ.R. Buchi. On a Decision Method in Restricted Second Order\nArithmetic. In Proceedings of International Congress on Logic,\nMethodology and Philosophy of Science, pages 1\u201312. Stanford University Press, 1960.\n\n[CLRS01]\n\nT.H. Cormen, C.E. Leiserson, R.L. Rivest, and C. Stein. Introduction to Algorithms. The MIT press, 2001.\n\n[dMOR+ 04] L. de Moura, S. Owre, H. Rue, J. Rushby, R. Alur, and D. Peled.\nSAL 2. In Proceedings of International Conference on ComputerAided Verification (CAV'04), volume 3114 of LNCS, pages 496\u2013\n500. Springer-Verlag, 2004.\n[DS04]\n\nB. Dutertre and M. Sorea. Modeling and Verification of a FaultTolerant Real-time Startup Protocol using Calendar Automata. In\nProceedings of FORMATS/FTRTFT, volume 3253 of LNCS, pages\n199\u2013214. Springer, 2004.\n\n[HLP90]\n\nD. Harel, O. Lichetenstein, and A. Pnueli. Explicit Clock Temporal Logic. In Proceedings of the Fifth Annual IEEE Symposium\non Logic in Computer Science, pages 402\u2013413. IEEE Computer\nSociety, 1990.\n\n[HMP92]\n\nT.A. Henzinger, Z. Manna, and A. Pnueli. What Good Are Digital\nClocks? In Proceedings of the 19th International Colloquium on\nAutomata, Languages and Programming, pages 545\u2013558. SpringerVerlag, 1992.\n\n[HMU06]\n\nJ.E. Hopcroft, R. Motwani, and J.D. Ullman. Introduction to\nAutomata Theory, Languages, and Computation. Addison-wesley,\n2006.\n\n[Jon97]\n\nN.D. Jones. Computability and Complexity: From a Programming\nPerspective. The MIT Press, 1997.\n\n[Koy90]\n\nR. Koymans. Specifying Real-Time Properties with Metric Temporal Logic. Real-Time Systems, 2(4):255\u2013299, 1990.\n\n[LP85]\n\nO. Lichtenstein and A. Pnueli. Checking that Finite State Concurrent Programs Satisfy their Linear Specification. In Proceedings\nof the 12th ACM SIGACT-SIGPLAN Symposium on Principles\nof Programming Languages, pages 97\u2013107. ACM New York, NY,\nUSA, 1985.\n\n[OD08]\n\nErnst-Rudiger Olderog and Henning Dierks. Real-Time Systems:\nFormal Specification and Automatic Verification. Cambridge University Press, 2008.\n\n[Ost89]\n\nJ.S. Ostroff. Temporal Logic for Real-time Systems. Wiley Advanced Software Development Series, 1989.\n\n[PH88]\n\nA. Pnueli and E. Harel. Applications of Temporal Logic to the\nSpecification of Real-time Systems. In Formal Techniques in RealTime and Fault-Tolerant Systems, volume 331 of LNCS, pages 84\u2013\n98. Springer, 1988.\n28\n\n\f[Pnu77]\n\nA. Pnueli. The Temporal Logic of Programs. In Proceedings of\nthe 18th Annual Symposium on Foundations of Computer Science,\npages 46\u201357, 1977.\n\n[Pra77]\n\nV.R. Pratt. Two Easy Theories whose Combination is Hard. Technical report, Massachusetts Institute of Technology, Cambridge,\n1977.\n\n[Sav70]\n\nW. J. Savitch. Relationships between Nondeterministic and Deterministic Tape Complexities. Journal of Computer and System\nSciences, 4(2):177\u2013192, 1970.\n\n[SC85]\n\nAP Sistla and EM Clarke. The Complexity of Propositional Linear\nTemporal Logics. Journal of the ACM (JACM), 32(3):733\u2013749,\n1985.\n\n[SMR07]\n\nI. Saha, J. Misra, and S. Roy. Timeout and Calendar Based Finite\nState Modeling and Verification of Real-Time Systems. In Proceedings of 5th International Symposium on Automated Technology for\nVerification and Analysis (ATVA'07), volume 4762 of LNCS, pages\n284\u2013299. Springer, 2007.\n\n[SP02]\n\nW. Steiner and M. Paulitsch. The Transition from Asynchronous\nto Synchronous System Operation: An Approach for Distributed\nFault- Tolerant System. In Proceedings of the 22nd International\nConference on Distributed Computing Systems (ICDCS'02), volume 22, pages 329\u2013336. IEEE Computer Society, 2002.\n\n[TC96]\n\nS. Tripakis and C. Courcoubetis. Extending Promela and Spin\nfor Real Time. In Proceedings of the Second International Workshop on Tools and Algorithms for the Construction and Analysis\nof Systems, (TACAS'96), volume 1055 of LNCS, pages 329\u2013348.\nSpringer Verlag, 1996.\n\n29\n\n\f"}