{"id": "http://arxiv.org/abs/quant-ph/0306118v3", "guidislink": true, "updated": "2004-01-10T15:38:40Z", "updated_parsed": [2004, 1, 10, 15, 38, 40, 5, 10, 0], "published": "2003-06-17T18:53:13Z", "published_parsed": [2003, 6, 17, 18, 53, 13, 1, 168, 0], "title": "Unconditionally Secure Multipartite Quantum Key Distribution", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0306156%2Cquant-ph%2F0306163%2Cquant-ph%2F0306155%2Cquant-ph%2F0306130%2Cquant-ph%2F0306172%2Cquant-ph%2F0306133%2Cquant-ph%2F0306090%2Cquant-ph%2F0306196%2Cquant-ph%2F0306072%2Cquant-ph%2F0306177%2Cquant-ph%2F0306074%2Cquant-ph%2F0306063%2Cquant-ph%2F0306007%2Cquant-ph%2F0306006%2Cquant-ph%2F0306191%2Cquant-ph%2F0306043%2Cquant-ph%2F0306038%2Cquant-ph%2F0306065%2Cquant-ph%2F0306194%2Cquant-ph%2F0306184%2Cquant-ph%2F0306049%2Cquant-ph%2F0306116%2Cquant-ph%2F0306073%2Cquant-ph%2F0306126%2Cquant-ph%2F0306036%2Cquant-ph%2F0306055%2Cquant-ph%2F0306200%2Cquant-ph%2F0306026%2Cquant-ph%2F0306129%2Cquant-ph%2F0306058%2Cquant-ph%2F0306197%2Cquant-ph%2F0306201%2Cquant-ph%2F0306095%2Cquant-ph%2F0306035%2Cquant-ph%2F0306119%2Cquant-ph%2F0306084%2Cquant-ph%2F0306064%2Cquant-ph%2F0306016%2Cquant-ph%2F0306041%2Cquant-ph%2F0306157%2Cquant-ph%2F0306076%2Cquant-ph%2F0306203%2Cquant-ph%2F0306187%2Cquant-ph%2F0306011%2Cquant-ph%2F0306151%2Cquant-ph%2F0306070%2Cquant-ph%2F0306143%2Cquant-ph%2F0306045%2Cquant-ph%2F0306091%2Cquant-ph%2F0306023%2Cquant-ph%2F0306028%2Cquant-ph%2F0306169%2Cquant-ph%2F0306176%2Cquant-ph%2F0306160%2Cquant-ph%2F0306034%2Cquant-ph%2F0306121%2Cquant-ph%2F0306083%2Cquant-ph%2F0306205%2Cquant-ph%2F0306042%2Cquant-ph%2F0306146%2Cquant-ph%2F0306069%2Cquant-ph%2F0306017%2Cquant-ph%2F0306193%2Cquant-ph%2F0306101%2Cquant-ph%2F0306152%2Cquant-ph%2F0306108%2Cquant-ph%2F0306122%2Cquant-ph%2F0306195%2Cquant-ph%2F0306094%2Cquant-ph%2F0306144%2Cquant-ph%2F0306204%2Cquant-ph%2F0306052%2Cquant-ph%2F0306125%2Cquant-ph%2F0306079%2Cquant-ph%2F0306185%2Cquant-ph%2F0306141%2Cquant-ph%2F0306202%2Cquant-ph%2F0306078%2Cquant-ph%2F0306134%2Cquant-ph%2F0306048%2Cquant-ph%2F0306096%2Cquant-ph%2F0306097%2Cquant-ph%2F0306164%2Cquant-ph%2F0306111%2Cquant-ph%2F0306112%2Cquant-ph%2F0306105%2Cquant-ph%2F0306075%2Cquant-ph%2F0306154%2Cquant-ph%2F0306178%2Cquant-ph%2F0306181%2Cquant-ph%2F0306114%2Cquant-ph%2F0306018%2Cquant-ph%2F0306093%2Cquant-ph%2F0306190%2Cquant-ph%2F0306081%2Cquant-ph%2F0306066%2Cquant-ph%2F0306128%2Cquant-ph%2F0306071%2Cquant-ph%2F0306019%2Cquant-ph%2F0306118%2Cquant-ph%2F0306008&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Unconditionally Secure Multipartite Quantum Key Distribution"}, "summary": "We consider the problem of secure key distribution among $n$ trustful agents:\nthe goal is to distribute an identical random bit-string among the $n$ agents\nover a noisy channel such that eavesdroppers learn little about it. We study\nthe general situation where the only resources required are secure bipartite\nkey distribution and authenticated classical communication. Accordingly,\nmultipartite quantum key distribution can be proven unconditionally secure by\nreducing the problem to the biparitite case and invoking the proof of security\nof bipartite quantum key distribution.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0306156%2Cquant-ph%2F0306163%2Cquant-ph%2F0306155%2Cquant-ph%2F0306130%2Cquant-ph%2F0306172%2Cquant-ph%2F0306133%2Cquant-ph%2F0306090%2Cquant-ph%2F0306196%2Cquant-ph%2F0306072%2Cquant-ph%2F0306177%2Cquant-ph%2F0306074%2Cquant-ph%2F0306063%2Cquant-ph%2F0306007%2Cquant-ph%2F0306006%2Cquant-ph%2F0306191%2Cquant-ph%2F0306043%2Cquant-ph%2F0306038%2Cquant-ph%2F0306065%2Cquant-ph%2F0306194%2Cquant-ph%2F0306184%2Cquant-ph%2F0306049%2Cquant-ph%2F0306116%2Cquant-ph%2F0306073%2Cquant-ph%2F0306126%2Cquant-ph%2F0306036%2Cquant-ph%2F0306055%2Cquant-ph%2F0306200%2Cquant-ph%2F0306026%2Cquant-ph%2F0306129%2Cquant-ph%2F0306058%2Cquant-ph%2F0306197%2Cquant-ph%2F0306201%2Cquant-ph%2F0306095%2Cquant-ph%2F0306035%2Cquant-ph%2F0306119%2Cquant-ph%2F0306084%2Cquant-ph%2F0306064%2Cquant-ph%2F0306016%2Cquant-ph%2F0306041%2Cquant-ph%2F0306157%2Cquant-ph%2F0306076%2Cquant-ph%2F0306203%2Cquant-ph%2F0306187%2Cquant-ph%2F0306011%2Cquant-ph%2F0306151%2Cquant-ph%2F0306070%2Cquant-ph%2F0306143%2Cquant-ph%2F0306045%2Cquant-ph%2F0306091%2Cquant-ph%2F0306023%2Cquant-ph%2F0306028%2Cquant-ph%2F0306169%2Cquant-ph%2F0306176%2Cquant-ph%2F0306160%2Cquant-ph%2F0306034%2Cquant-ph%2F0306121%2Cquant-ph%2F0306083%2Cquant-ph%2F0306205%2Cquant-ph%2F0306042%2Cquant-ph%2F0306146%2Cquant-ph%2F0306069%2Cquant-ph%2F0306017%2Cquant-ph%2F0306193%2Cquant-ph%2F0306101%2Cquant-ph%2F0306152%2Cquant-ph%2F0306108%2Cquant-ph%2F0306122%2Cquant-ph%2F0306195%2Cquant-ph%2F0306094%2Cquant-ph%2F0306144%2Cquant-ph%2F0306204%2Cquant-ph%2F0306052%2Cquant-ph%2F0306125%2Cquant-ph%2F0306079%2Cquant-ph%2F0306185%2Cquant-ph%2F0306141%2Cquant-ph%2F0306202%2Cquant-ph%2F0306078%2Cquant-ph%2F0306134%2Cquant-ph%2F0306048%2Cquant-ph%2F0306096%2Cquant-ph%2F0306097%2Cquant-ph%2F0306164%2Cquant-ph%2F0306111%2Cquant-ph%2F0306112%2Cquant-ph%2F0306105%2Cquant-ph%2F0306075%2Cquant-ph%2F0306154%2Cquant-ph%2F0306178%2Cquant-ph%2F0306181%2Cquant-ph%2F0306114%2Cquant-ph%2F0306018%2Cquant-ph%2F0306093%2Cquant-ph%2F0306190%2Cquant-ph%2F0306081%2Cquant-ph%2F0306066%2Cquant-ph%2F0306128%2Cquant-ph%2F0306071%2Cquant-ph%2F0306019%2Cquant-ph%2F0306118%2Cquant-ph%2F0306008&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We consider the problem of secure key distribution among $n$ trustful agents:\nthe goal is to distribute an identical random bit-string among the $n$ agents\nover a noisy channel such that eavesdroppers learn little about it. We study\nthe general situation where the only resources required are secure bipartite\nkey distribution and authenticated classical communication. Accordingly,\nmultipartite quantum key distribution can be proven unconditionally secure by\nreducing the problem to the biparitite case and invoking the proof of security\nof bipartite quantum key distribution."}, "authors": ["Sudhir Kumar Singh", "R. Srikanth"], "author_detail": {"name": "R. Srikanth"}, "author": "R. Srikanth", "arxiv_comment": "5 pages, REVTeX, no figures; replaced with revised version; results\n  unchanged", "links": [{"href": "http://arxiv.org/abs/quant-ph/0306118v3", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/quant-ph/0306118v3", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/quant-ph/0306118v3", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/quant-ph/0306118v3", "journal_reference": null, "doi": null, "fulltext": "Unconditionally Secure Multipartite Quantum Key Distribution\nSudhir Kumar Singh\u2217\nDept. of Mathematics, IIT Kharagpur, Kharagpur- 721302, India.\n\nR. Srikanth\u2020\n\narXiv:quant-ph/0306118v3 10 Jan 2004\n\nRaman Research Institute, Bangalore- 560080, Karnataka, India.\nWe consider the problem of secure key distribution among n trustful agents: the goal is to\ndistribute an identical random bit-string among the n agents over a noisy channel such that eavesdroppers learn little about it. We study the general situation where the only resources required are\nsecure bipartite key distribution and authenticated classical communication. Accordingly, multipartite quantum key distribution can be proven unconditionally secure by reducing the problem to the\nbiparitite case and invoking the proof of security of bipartite quantum key distribution.\nPACS numbers: 03.67.Dd\n\nI.\n\nINTRODUCTION\n\nWith the growing use of the internet and other forms of electronic communication, the question of secure communication becomes one of considerable importance. Modern cryptographic techniques, based on the availability\nof ever increasing computational power, and the invention of public key cryptography, provide practical solutions\nfor information security in various situations. But invariably these techniques are only computationally\u2013 and not\nunconditionally\u2013 secure, that is, they depend on the (unproven) hardness of certain mathematical problems. As a\nresult, it cannot be guaranteed that future advances in computational power will not nullify their cryptographic protection. Nevertheless, there does exist a form of encryption with unconditional security: the use of one-time key pads.\nThese are strings of random numbers added by the information sender to encode the message, to be subtracted by the\nreceiver to decode. Provided that the key material is truely random and used only once, this system is unbreakable\nin the sense described by Shannon in the 1940s [1]. It is critically important that the pad is only used once, i.e., an\nencryption key can never be used twice. This restriction translates into the practical one of key distribution (KD).\nThis need to securely distribute the key between the users makes it impractical in many applications. Where it is used\nin real life (eg., in confidential communications between governments), the one-time key pads are actually delivered\nin person by some trusted third party [2], an arrangement prohibitively expensive for common usage and moreover not\ntruely secure. Fortunately, recent advances in quantum information theory have shown that unconditionally secure\nkey distribution is possible in principle.\nThat quantum information can, on account of quantum uncertainty and the no-cloning principle [3], be used to\ndistribute cryptographic keys was realized two decades ago [4, 5]. More rigorous and comprehensive proofs of this\ntask, generally called quantum key distribution (QKD), taking into consideration source, device and channel noise as\nwell as an arbitrarily powerful eavesdropper, have been studied by various authors [6, 7, 8, 9, 10]. Recently, the issues\nof efficiency [11], security in the presence of an uncharacterized source [12] and high bit-error rate tolerance [13] of\nQKD have been considered. In particular, Lo and Chau [8] showed that, given fault-tolerant quantum computers,\nquantum key distribution over an arbitrarily long distance of a realistically noisy channel can be made unconditionally\nsecure. This is a heartening development, since QKD is, among quantum information applications, relatively easy to\nimplement, and some large scale implementations have already been achieved [14, 15]. The above mentioned works\nconsider QKD between two parties (ie., 2-QKD). It is of interest to consider its extension to more than two parties\n(ie., n-QKD).\nThe problem of n-QKD is to determine how n parties, who are able to communicate quantally, may share an identical\nand unconditionally secure, secret key among themselves in the presence of eavesdroppers. (A different generalization\nof 2-QKD gives multipartite quantum secret-sharing [16], which we do not consider here). In this work, we propose\na protocol for this purpose and prove its unconditional security. We note that a simple extrapolation of 2-QKD to\nn-QKD would suggest that the agents should begin by sharing an n-partite entangled state. However, this proposition\n\n\u2217 Electronic\n\u2020 Electronic\n\naddress: sudhirks@maths.iitkgp.ernet.in\naddress: srik@rri.res.in\n\n\f2\nsuffers from two drawbacks: from a practical viewpoint, preparing n-partite entanglement is no easy task; from a\ntheoretical viewpoint, proving the security of secure extraction of n separated copies of a bit-string may not be simple,\neven given the existing proof of security of the bipartite case. Our main result is that it is sufficient if some pairs of\nagents share bipartite entanglement along any spanning tree connecting the n agents, who are taken to be vertices on\na graph. In this way, n-QKD is reduced to a 2-QKD problem. Existing 2-QKD protocols [6, 7, 8, 9, 10, 11, 12, 13]\ncan be invoked to prove the unconditional security of sharing nearly perfect Einstein-Podolsky-Rosen (EPR) pairs\nbetween two parties. They prescribe procedures for reliably sharing EPR pairs, and thence sharing randomness, by\nvirtue of fault-tolerant quantum computers, quantum error correction and suitable random sampling. In the interests\nof brevity, we will not elaborate these protocols here, and only point them out as subroutines for the general n-QKD\ntask. Our protocol is fairly simple in the sense that the proof of its security is built on top of the already proven\nsecurity of the bipartite case. However, it is important to know the necessary and sufficient conditions on the network\ntopology for our proposed protocol to work.\nII.\n\nCLASSICAL REDUCTION OF n-KD TO 2-KD\n\nAs in 2-KD, the goal of n-KD is to show that n trustful parties can securely share random, secret classical bits,\neven in the presence of noise and eavesdropping. It is assumed that the n agents can share authenticated classical\ncommunication. It is convenient to treat the problem graph theoretically [17]. The n agents Ai (1 \u2264 i \u2264 n) are\nconsidered as the vertices (or nodes) of an undirected graph. An instance of a secure bi-partite channel being shared\nbetween two parties is considered as an undirected edge between the two corresponding vertices. A graph so formed\nis called a security graph. It is obvious that if the security graph has a star topology (a hub vertex with all edges\nradiating from it to the other vertices), a simple n-KD protocol can be established. The agent at the hub vertex (say,\ncalled, Lucy) generates a random bit string and transmits it to every other agent along the edges to each of them.\nThis will create a secure, identical random bit string with each agent.\nIn real life situations, because of practical and geographical constraints, the n agents may not form a security graph\nwith star topology. We describe a simple protocol that allows for more general secure bi-partite connectivity between\nthe agents. In particular, from among the secure bipartite channels suppose a spanning tree (a graph connecting all\nvertices without forming a loop) can be constructed. This construction can be formalized in order to determine an\noptimal spanning tree. Some useful definitions are given below.\nWeighted security graph: Given n parties treated as nodes on a graph, we extend the definition of a security graph\nto the weighted security graph. A weight is associated with every edge and is defined to be some suitable measure of\nthe cost of communicating by means of the channel corresponding to the edge.\nMinimum spanning security tree: Consider the weighted security graph G = (V, E). A spanning tree selected from\nG, given by G1 = (V, E1 ), E1 \u2286 E is called the minimum spanning security tree if it minimizes the total weight\nof the graph. It need not be unique and can be obtained using Kruskal's or Prim's algorithm [18]. The minimum\nspanning security tree minimizes the resources needed in the protocol as well as the size of the sector eavesdroppers\ncan potentially control.\nTerminal agent: An agent that corresponds to a vertex of degree one (ie., with exactly one edge linked to it). On\nthe other hand, an agent that corresponds to a vertex of degree greater than one is called a non-terminal agent.\nWe now present a classical subroutine that allows n \u2212 1 pair-wise shared random bits to be turned into a single\nrandom bit shared between the n parties.\n1. 2-KD: Along the n \u2212 1 edges of a minimum spanning security tree, n \u2212 1 random bits are securely shared by\nmeans of some secure 2-KD protocol.\n2. Each non-terminal agent Ai announces his unformly randomized record: this is the list of edges emanating from\nthe vertex along with the corresponding random bit values, to all of which a fixed random bit x(i) is added.\n3. This information is sufficient to allow every player, in conjunction with her/his own random bit record, to\nreconstruct the random bits of all parties. The protocol leader (say, Lucy) decides randomly on the terminal\nagent whose random bit will serve as the secret bit shared among the n agents.\nThis subroutine consumes n \u2212 1 pair-wise shared random numbers to give a one-bit secret key shared amongst the\nn-parties. To generate an m-bit string shared among the n agents, the subroutine is repeated m times.\nGiven that the initial bipartite sharing of randomness is secure, we will show that the above protocol subroutine\nallows some randomness to be shared between the n agents without revealing anything to an eavesdropper. It involves\neach non-terminal agent announcing his uniformly randomized record. Suppose one such, Ai , has the random record\n0,1,1 on the three edges linked to his vertex. He may announce 0,1,1 (for x(i) = 0) or 1,0,0 (for x(i) = 1). All\n\n\f3\nthe three agents linked to him can determine which the correct string is by referring to their shared secret bit.\nIt is a straightforward exercise to see that each of other agents linked to these three can determine the right bit\nstring. Therefore, each agent can determine the random bits of all others. Eavesdroppers, on the other hand, lacking\nknowledge of any of the n \u2212 1 shared random bits, can only work out the relative outcomes of all parties. The result\nis exactly two possible configurations for each secret bit, which are complements of each other. The eavesdropper\n\"Eve\" is thus maximally uncertain about which the correct configuration is. Hence, Lucy's choice of a party to fix\nthe secret bit reveals little to Eve. Insofar as the n-parties are able to communicate authenticated classical messages,\nthe subroutine protocol is as secure as the underlying procedure for 2-KD.\nIt is obvious that the above protocol works for any spanning security tree. Clearly, a sufficient condition for turning\nshared bipartite randomness into randomness shared between n parties is that the weighted security graph should\ncontain at least one spanning tree. On the other hand, if the security graph is disconnected, one easily checks that it\nis impossible to arrive at a definite random bit securely shared between both the disconnected pieces. Therefore, the\nexistence of at least one spanning tree in the weighted security graph is both a necessary and sufficient condition for\nthe required task.\nThe amount of securely shared randomness may be quantified by the length of shared random bit string multiplied\nby the number of sharing agents. In the above protocol, the n \u2212 1 instances of pair-wise shared randomness is\nconsumed to produce exactly one instance of a random bit shared between the n parties. We can then define the\n'random efficiency' of the above protocol by \u03b7 = (n \u00d7 1)/((n \u2212 1) \u00d7 2), which tends to (1/2) as n \u2192 \u221e. Unconditional\nsecurity of the above subroutine can in principle only be guaranteed in a protocol which includes in step 1 a quantum\nsub-routine that implements 2-QKD. In the following Section, we will present one such, based on the Shor-Preskill\nprotocols [10], as an example.\nIII.\n\nQUANTUM PROTOCOL\n\nAs in 2-QKD, the goal of the proposed n-QKD protocol is to show that n trustful parties can securely distil random,\nshared, secret classical bits, whose security is to be proven inspite of source, device and channel noise and of Eve,\nan eavesdropper assumed to be as powerful as possible, and in particular, having control over all communication\nchannels. From the result of the preceding Section, it follows that a quantum protocol is needed only in step 1 above.\nIt will involve establishing 2-QKD along a minimum spanning tree in order to securely share pair-wise randomness\nalong spanning tree's edges and thence proceed to n-QKD. We assume as given the security of establishing pair-wise\nrandomness along a spanning tree by means of a quantum communication network, based on a secure 2-QKD protocol\n[6, 7, 8, 9, 10, 11, 12, 13]. In principle, these protocols guarantee security under various circumstances.\nIn an n-QKD scheme, the insecurity of even one of the players can undermine all. Hence additional classical\nprocessing like key reconciliation and privacy amplification [19] of the final key may be needed at the n-partite level.\nIn the full n-QKD protocol that we present below, following Ref. [10] we exploit the connection of error correction\ncodes [20] with key reconciliation and privacy amplification. These procedures have been extensively studied by\nclassical cryptographers [14], and other possibilities exist.\nIn particular, we adopt a quantum protocol wherein pair-wise randomness is created by means of sharing EPR pairs\n(this follows the pattern set by the Ekert [5], Lo-Chau [8] and Modified Lo-Chau [10] protocols, but entanglement is\nnot necessary, as seen in the original BB84 protocol). The basic graph theoretic definitions introduced above apply\nalso for the quantum case, except that now the security channels correspond to shared EPR pairs. In place of a secure\nbipartite channel, an instance of EPR pair shared between two parties is considered as an undirected edge between\nthe two corresponding vertices. A graph so formed is called an EPR graph [17]. The analog of the weighted security\ngraph is the weighted EPR graph, and that of the minimum spanning security tree is the minimum spanning EPR tree.\nLet us enumerate the n parties as A1 , A2 , * * * , An . Suppose that only Ai1 , Ai2 , * * * , Ais (i1 , i2 , * * * , is \u2208 {1, 2, * * * , n})\nare capable of producing EPR pairs and S \u2261 {Ai1 , * * * , Ais } is the set of all such vertices, with S 6= \u2205. We construct\na weighted undirected graph G = (V, E) as one whose every edge must contain a vertex drawn from the set S, as\nfollows: V \u2261 {Ai ; i = 1, 2, * * * , n} and E \u2261 {(Ai , Aj ) \u2200 Ai \u2208 S and \u2200 Aj \u2208 V ; i 6= j}. And the weight of edge\n(Ai , Aj ) is defined to be wi,j \u221d number of quantum repeaters [21] (more generally: entanglement distilling resources\n[22]) required to be put between Ai and Aj . Usually, the larger the distance between two agents, the larger is the\nweight. The minimum spanning EPR tree minimizes the number of quantum repeators needed, and, in general, the\nresources needed in the protocol (EPR pairs, etc.) subject to the constraint of available EPR sources. Apart from\nimproving efficiency in terms of costs incurred, this optimization is also important from the security perspective in\nthat it minimizes the size of the sector that Eve can potentially control.\nLet C be a classical t-error correcting [m, k]-code [20]. We now present a protocol that consumes n \u2212 1 pair-wise\nsecurely shared sets of EPR pairs to create random bits shared between the n parties with asymptotic efficiency\n\u03b7 = (1/2)k/m, where k/m is the rate of the code. The classical subroutine described in the previous Section is\n\n\f4\nadapted to include key reconciliation and privacy amplification at the n-partite level, that uses the group theoretic\nproperties of C.\n1. EPR protocol: Along the n \u2212 1 edges of the minimum spanning EPR tree, EPR pairs are shared (using eg., the\nLo-Chau [8] or Modified Lo-Chau protocols [10]). Let the final, minimum number of EPR pairs distilled along\nany edge of the minimum spanning EPR tree be 2m. A projective measurement in the computational basis is\nperformed by all the parties on their respective qubits to obtain secure pair-wise shared randomness along the\ntree edges (making due adjustments according to whether the entangled spins are correlated or anti-correlated).\n2. Classical subroutine of Section II: All non-terminal vertices announce their unformly randomized outcome record.\nThis information in principle allows every party, in conjunction with her/his outcome, to reconstruct the outcomes of all other parties, save for some errors of mismatch.\n3. For each set of n \u2212 1 shared EPR pairs, protocol leader Lucy decides randomly on the terminal party whose\noutcome will serve as the secret bit.\n4. Lucy decides randomly a set of m bits to be used as check bits, and announces their positions.\n5. All parties announce the value of their check bits. If too few of these values agree, they abort the protocol.\n6. Lucy broadcasts ci \u2295 v, where v is the string consisting of the remaining code (non-check) bits, and ci is a\nrandom codeword in C.\n7. Each member j from amongst the remaining n \u2212 1 parties subtracts ci \u2295 v from his respective code bits, v \u2295 \u01ebj ,\nand corrects the result, ci \u2295 \u01ebj , to a codeword in C. Here \u01ebj is a possibly non-vanishing error-vector.\n8. The parties use i as the key.\nA rigorous proof of the security of the n-QKD scheme requires: (a) the explicit construction of a procedure such\nthat whenever Eve's strategy has a non-negligible probability of passing the verification test by the n parties, her\ninformation on the final key will be exponentially small. (b) the shared, secret randomness is robust against source,\ndevice and channel noise. By construction, our scheme combines a 2-QKD scheme to generate pair-wise shared\nrandomness and a classical scheme to turn this into multipartite-shared randomness. The security of the latter (in its\nessential form) was proven in Section II. Therefore the security of the protocol with respect to (a) and (b) reduces\nto that of the 2-QKD in step 1. For various situations, 2-QKD can be secured, as proven in Refs [6, 7, 8, 9, 10].\nFor example, Lo and Chau [8] and Shor and Preskill [10] have proved that EPR pairs can be prepared to be nearly\nperfect, even in the presence of Eve and channel noise. Their proofs essentially relies on the idea that sampling the\ncoherence of the qubits allows one to place an upper bound on the effects due to noise and information leakage to\nEve. Yet, subject to the availability of high quality quantum repeaters and fault-tolerant quantum computation, in\nprinciple 2-QKD can be made unconditionally secure [8].\nIn regard to the key reconciliation part: in step (3), each non-terminal vertex party announces his uniformly\nrandomized outcome record. Here this consumes m instances of n \u2212 1 pair-wise shared random bits into k\nrandom bits shared between the n agents while revealing little to Eve. The random efficiency is given by\n\u03b7 = (k \u00d7 n \u00d7 1)/(m \u00d7 (n \u2212 1) \u00d7 2), which tends to (1/2)k/m as n \u2192 \u221e. The check bits, whose positions and values\nare announced in steps (4) and (5), are eventually discarded. Steps (7) and (8) involve purely local, classical operations\n[23]. If security of step (1) against Eve is guaranteed, the string v, and thereby the string ci \u2295 v announced by Lucy\nin step (6), are completely random, as far as Eve can say. So, she (Eve) gains nothing therefrom. Hence her mutual\ninformation with any of the n \u2212 1 (sets of) random bits does not increase beyond what she has at the end of the EPR\nprotocol [24].\nFinally, step (5) permits with high probability to determine whether the key can be reconciled amongst the n\nplayers. The check bits that the parties measure behave like a classical random sample of bits [10]. We can then\nuse the measured error rates in a classical probability estimate. For any two parties, the probability of obtaining\nmore than (\u03b4 + \u01eb)n errors on the code bits and fewer than \u03b4n errors on the check bits is asymptotically less than\nexp[\u22120.25\u01eb2n/(\u03b4 \u2212 \u03b4 2 )]. Noting that the errors on the n check vectors are independent, it follows that probability that\nthe check vectors are all scattered within a ball of radius \u03b4n but one or more code vectors fall outside a scatter ball of\nradius (\u03b4 + \u01eb)n is exponentially small, and can be made arbitrarily small by choosing sufficiently small \u03b4. The decision\ncriterion adopted in step (5) is calculated so that the Hamming weight of the error vectors \u01ebj estimated in the above\nfashion will be less than t with high probability. Hence all parties correct their results to the same codeword ci in\nstep (8) with high probability. This completes the proof of unconditionally security of n-QKD.\n\n\f5\nAcknowledgments\n\nWe thank Prof. Anil Kumar, Prof. J. Pasupathy and Ritesh Kumar Singh for discussions. SKS thanks Prof. Anil\nKumar for enabling his visit to IISc during which this work was done. RS's work was partially supported by DRDO\nproject 510 01PS-00356.\n\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n[8]\n[9]\n[10]\n[11]\n[12]\n[13]\n[14]\n[15]\n[16]\n[17]\n[18]\n[19]\n[20]\n[21]\n[22]\n[23]\n[24]\n\nC. E. Shannon, A mathematical theory of cryptography, Technical Report 45-110-92, Bell Laboratories, 1945.\nS. Singh, The Code Book (Anchor 2000).\nW. K. Wooters and W. H. Zurek, Nature 299, 802 (1982).\nC. H. Bennett and G. Brassard, in Proceedings of IEEE International Conference on Computers, Systems, and Signal\nProcessing at Bangalore (IEEE, New York, 1984), p. 175.\nA. K. Ekert, Phys. Rev. Lett. 67, 661 (1991).\nD. Mayers, quant-ph/9802025; preliminary version in Advances in Cryptology\u2013Proceedings of Crypto '96 (Springer-Verlag,\nNew York, 1996) p. 715;\nE. Biham, M. Boyer, P. O. Boykin, T. Mor and V. Roychowdhury, in Proceedings of the Thirty-Second Annual ACM\nSymposium on Theory of Computing (ACM Press, New York 2000), p. 715.\nH.-K. Lo and H. F. Chau, Science 253, 2050 (1999).\nH. Inamori, L. Rallan, V. Vedral, quant-ph/0103058.\nP. W. Shor and J. Preskill, Phys. Rev. Lett. 85, 441 (2000).\nW.-Y. Hwang, X.-B. Wang, K. Matsumoto, J. Kim, H.-W. Lee, Phys. Rev. A 67, 012302 (2003).\nM. Koashi and J. Preskill, Phys. Rev. Lett. 90, 057902 (2003).\nX.-B. Wang, eprint quant-ph/0308057 (to appear in Phys. Rev. Lett.).\nN. Gisin, G. Ribordy, W. Tittel and H. Zbinden Rev. Mod. Phys. 74, 145 (2002).\nJ.W. Pan, S. Gasparoni, R. Ursin, G. Weihs and A. Zeilinger Nature 423, 417-422 (2003).\nV. Scarani and N. Gisin, Phys. Rev. Lett. 87 117901 (2001).\nS.K. Singh, S. Kumar and S.P. Pal, eprint quant-ph/0306049\nT. H. Cormen, C. E. Leiserson and R. L. Rivest, Introduction to Algorithms, MIT Press(1990).\nI. Csisar and J. K\u00f6rner, IEEE Trans. Inf. Theory 23, 339 (1976).\nF. J. MacWilliams and N. J. A. Sloane, The Theory of Error-correcting Codes (North-Holland 1977).\nH.-J. Briegel, W. D\u00fcr, J. I. Cirac, and P. Zoller, Phys. Rev. Lett. 81, 5932; W. D\u00fcr, H.-J. Briegel, J. I. Cirac, and P.\nZoller, Phys. Rev. A 59, 169-181 (1999).\nL.-M. Duan, M. Lukin, I. Cirac, P. Zoller, Nature 414, 413-418 (2001).\nUnless the privacy of local operations is guaranteed, the matter of security is quite hopeless.\nIn particular, no quantum key distribution scheme can succeed if Eve has the power to impersonate agent Ai while\ncommunicating to Aj and to impersonate Aj while communicating to Ai . To address this problem, Ai and Aj will need to\nauthenticate their communications (cf. Ref. [8] for details).\n\n\f"}