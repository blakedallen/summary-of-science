{"id": "http://arxiv.org/abs/cs/0607039v1", "guidislink": true, "updated": "2006-07-09T14:27:43Z", "updated_parsed": [2006, 7, 9, 14, 27, 43, 6, 190, 0], "published": "2006-07-09T14:27:43Z", "published_parsed": [2006, 7, 9, 14, 27, 43, 6, 190, 0], "title": "Set-Theoretic Preliminaries for Computer Scientists", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Set-Theoretic Preliminaries for Computer Scientists"}, "summary": "The basics of set theory are usually copied, directly or indirectly, by\ncomputer scientists from introductions to mathematical texts. Often\nmathematicians are content with special cases when the general case is of no\nmathematical interest. But sometimes what is of no mathematical interest is of\ngreat practical interest in computer science. For example, non-binary relations\nin mathematics tend to have numerical indexes and tend to be unsorted. In the\ntheory and practice of relational databases both these simplifications are\nunwarranted. In response to this situation we present here an alternative to\nthe ``set-theoretic preliminaries'' usually found in computer science texts.\nThis paper separates binary relations from the kind of relations that are\nneeded in relational databases. Its treatment of functions supports both\ncomputer science in general and the kind of relations needed in databases. As a\nsample application this paper shows how the mathematical theory of relations\nnaturally leads to the relational data model and how the operations on\nrelations are by themselves already a powerful vehicle for queries.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0607104%2Ccs%2F0607075%2Ccs%2F0607069%2Ccs%2F0607061%2Ccs%2F0607105%2Ccs%2F0607130%2Ccs%2F0607062%2Ccs%2F0607024%2Ccs%2F0607019%2Ccs%2F0607102%2Ccs%2F0607132%2Ccs%2F0607074%2Ccs%2F0607017%2Ccs%2F0607060%2Ccs%2F0607111%2Ccs%2F0607147%2Ccs%2F0607068%2Ccs%2F0607099%2Ccs%2F0607116%2Ccs%2F0607034%2Ccs%2F0607137%2Ccs%2F0607046%2Ccs%2F0607013%2Ccs%2F0607093%2Ccs%2F0607008%2Ccs%2F0607117%2Ccs%2F0607134%2Ccs%2F0607003%2Ccs%2F0607109%2Ccs%2F0607107%2Ccs%2F0607095%2Ccs%2F0607016%2Ccs%2F0607090%2Ccs%2F0607058%2Ccs%2F0607092%2Ccs%2F0607030%2Ccs%2F0607138%2Ccs%2F0607112%2Ccs%2F0607122%2Ccs%2F0607006%2Ccs%2F0607110%2Ccs%2F0607123%2Ccs%2F0607040%2Ccs%2F0607140%2Ccs%2F0607146%2Ccs%2F0607080%2Ccs%2F0607084%2Ccs%2F0607126%2Ccs%2F0607114%2Ccs%2F0607079%2Ccs%2F0607001%2Ccs%2F0607052%2Ccs%2F0607142%2Ccs%2F0607086%2Ccs%2F0607038%2Ccs%2F0607007%2Ccs%2F0607053%2Ccs%2F0607119%2Ccs%2F0607012%2Ccs%2F0607010%2Ccs%2F0607081%2Ccs%2F0607120%2Ccs%2F0607098%2Ccs%2F0607106%2Ccs%2F0607022%2Ccs%2F0607094%2Ccs%2F0607056%2Ccs%2F0607031%2Ccs%2F0607083%2Ccs%2F0607064%2Ccs%2F0607089%2Ccs%2F0607103%2Ccs%2F0607028%2Ccs%2F0607039%2Ccs%2F0607070%2Ccs%2F0607121%2Ccs%2F0607025%2Ccs%2F0607065%2Ccs%2F0607127%2Ccs%2F0607125%2Ccs%2F0607131%2Ccs%2F0607087%2Ccs%2F0607071%2Ccs%2F0607091%2Ccs%2F0607035%2Ccs%2F0607048%2Ccs%2F0607118%2Ccs%2F0607011%2Ccs%2F0607066%2Ccs%2F0607026%2Ccs%2F0607055%2Ccs%2F0607133%2Ccs%2F0607108%2Ccs%2F0607054%2Ccs%2F0607051%2Ccs%2F0607063%2Ccs%2F0607078%2Ccs%2F0607073%2Ccs%2F0607004%2Ccs%2F0607101%2Ccs%2F0607135&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The basics of set theory are usually copied, directly or indirectly, by\ncomputer scientists from introductions to mathematical texts. Often\nmathematicians are content with special cases when the general case is of no\nmathematical interest. But sometimes what is of no mathematical interest is of\ngreat practical interest in computer science. For example, non-binary relations\nin mathematics tend to have numerical indexes and tend to be unsorted. In the\ntheory and practice of relational databases both these simplifications are\nunwarranted. In response to this situation we present here an alternative to\nthe ``set-theoretic preliminaries'' usually found in computer science texts.\nThis paper separates binary relations from the kind of relations that are\nneeded in relational databases. Its treatment of functions supports both\ncomputer science in general and the kind of relations needed in databases. As a\nsample application this paper shows how the mathematical theory of relations\nnaturally leads to the relational data model and how the operations on\nrelations are by themselves already a powerful vehicle for queries."}, "authors": ["M. H. van Emden"], "author_detail": {"name": "M. H. van Emden"}, "author": "M. H. van Emden", "arxiv_comment": "36 pages, 5 figures", "links": [{"href": "http://arxiv.org/abs/cs/0607039v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0607039v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.DB", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0607039v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0607039v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:cs/0607039v1 [cs.DM] 9 Jul 2006\n\nSet-Theoretic Preliminaries for Computer\nScientists\nM.H. van Emden\nResearch Report DCS-304-IR\nDepartment of Computer Science, University of Victoria\n\nAbstract\nThe basics of set theory are usually copied, directly or indirectly,\nby computer scientists from introductions to mathematical texts. Often\nmathematicians are content with special cases when the general case is\nof no mathematical interest. But sometimes what is of no mathematical\ninterest is of great practical interest in computer science. For example,\nnon-binary relations in mathematics tend to have numerical indexes and\ntend to be unsorted. In the theory and practice of relational databases\nboth these simplifications are unwarranted. In response to this situation\nwe present here an alternative to the \"set-theoretic preliminaries\" usually\nfound in computer science texts. This paper separates binary relations\nfrom the kind of relations that are needed in relational databases. Its\ntreatment of functions supports both computer science in general and the\nkind of relations needed in databases. As a sample application this paper\nshows how the mathematical theory of relations naturally leads to the relational data model and how the operations on relations are by themselves\nalready a powerful vehicle for queries.\n\n1\n\nIntroduction\n\nMathematics is more useful than computer scientists tend to think. I am not\ntalking about specialized areas of computer science with strongly developed\nmathematical theories, like graph theory in computer networks or posets and\nlattices for programming language semantics. These are solid extensions of the\ntraditional notion of Applied Mathematics.\nNo, I'm talking about the mundane mathematics that falls into the cracks\nbetween these well-developed areas: basic facts about sets, functions, and relations. I refer to the material that gets relegated to the desultory miscellanies\nadded to texts under the name of \"set-theoretic preliminaries\". The reason for\nthe perfunctory way in which these are compiled is that computer scientists are\nambivalent about basic set theory: they don't care for that stuff, yet dare not\nomit it.\n\n1\n\n\fMy own lack of understanding in this area resulted in difficulties with the\nrelational model. Accordingly, I include it as a case study of how basic set theory\ncould have clarified these difficulties, which are also found in the literature.\nThe ambivalence concerning the set-theoretic preliminaries is understandable. Is a proper treatment not going to lead to an unacceptably large mass\nof definitions and theorems? After all, set theory is nothing if it is not done\nrigorously. In other parts of mathematics you can start right away with what\ninterests you and you refer to something else for the foundation. No such help\nis available when you deal with the foundation itself.\nThis paper is intended to improve this situation. My model is Halmos's\nNa\u0131\u0308ve Set Theory [4], which shows that one can be precise enough and yet\neasily digestible without losing anything essential. Halmos's book was aimed at\nnormal mathematicians; that is, those who have no interest in set theory, yet\ncannot do without it. It is therefore ideal for computer scientists, who are in\nthe same position. Though set theory is no different for mathematicians than it\nis for computer scientists, it does make sense to rewrite the first part of [4] into\na sort of Halmos for computer scientists. This is what I am trying to do here.\nHalmos had to maintain a delicate balance between conflicting requirements.\nOn the one hand he wanted to avoid an arid listing of the facts and definitions\nthat normal mathematicians need. Such a bare listing would not do justice to\nthe intrinsic interest of the subject. On the other hand, he did not want to get\nsucked into the depth, and richness, of the subject. I have tried to follow his\nexample. On the one hand, I give more than a minimal listing of facts. For\nexample, I even start with a history of set theory. To maintain the balance, I\nkept it to less than five hundred words. In the sequel I have tried to continue\nthis balance.\nThese considerations have resulted in a paper that is difficult to classify.\nIt is part review, part tutorial. As a result of approaching certain subjects\nimportant for computer scientists, like relations, in the way that mathematicians\nhad learned to do by the middle of the 20th century, certain new and useful\nresults come out, so that this paper also contains recent research. But most of\nall, the purpose is methodological: to show that, before breaking new ground,\nwe should go back to the basic abstract mathematics that became the consensus\nof mathematicians in the 1930s and was codified by Bourbaki in the Fascicule\nde R\u00e9sultats [1] of their Th\u00e9orie des Ensembles [2].\n\n2\n\nSets\n\nThe development of the calculus in the 18th century was a spectacular practical\nsuccess. At the same time, philosophers poked fun at the mathematicians for\nthe peculiar logic used in reasoning about infinitesimals (sometimes they were\ntreated as zero; sometimes not). In the 19th century, starting with Cauchy,\nanalysis developed as the theory underlying the calculus. The goal was to do\naway with infinitesimals and explain the processes of analysis in terms of limits,\n\n2\n\n\frationals, and, ultimately, integers as the bedrock foundation1 .\nIn the late 19th century Cantor was led to create set theory in response to\nfurther problems in analysis. This theory promised to be an even deeper layer\nof bedrock in terms of which even the integers, including hierarchies of infinities,\ncould be explained2 .\nFor some decades set theory was an esoteric and controversial theory, plagued\nby paradoxes. The axiomatic treatment of Zermelo and Fraenkel made set\ntheory into respectable mathematics. A sure sign of its newly achieved status\nwas that Bourbaki started their great multivolume treatise on analysis with a\nsummary of set theory [2] to serve as foundation of the entire edifice.\nWhen set theory is not just viewed as one of the branches of mathematics,\nbut as the foundation of all mathematics, it is tempting to conclude that the\nproper, systematic way to teach any kind of mathematics is to start with set\ntheory. Combine this idea with the curious notion that children are in school not\njust to learn to reckon, but to do \"Math\", and you get a movement like \"New\nMath\" according to which children are taught sets before they get to counting.\nBy the time the disastrous results of this approach were recognized, set\ntheory was out of favour. Even pure mathematicians were no longer impressed\nby the edifice erected by Bourbaki. Set theory was relegated to the status of\none of the many branches of mathematics; one distinguished by the utter lack\nof applications. Mathematicians interested in foundations of mathematics and\ntheoretically minded computer scientists use categories rather than set theory.\nA characteristic quote from this part of the world is: \"Set theory is the biggest\nmistake in mathematics since Roman numerals.\"\nFor the kind of things that these people do, category theory may well be\nsuperior. What I hope to show here is that a bit of basic old-fashioned set\ntheory goes a long way in improving what the rest of us do.\n\n2.1\n\nSet membership and set inclusion\n\nWhat is a set?\nI shall remain evasive on this point. In geometry, there are definitions of\nthings like triangles and parallelograms, but not of points and lines. The latter\nare undefined primitive objects in terms of which other geometrical figures are\ndefined. All we are allowed to assume about points and lines is what the axioms\nsay about the relations between them (like there being one and only one line on\nwhich two given points lie).\nIn the same way it is not appropriate to ask \"What is a set?\". All we know\nabout sets is that they enter into a certain relation with another set or with an\nelement and that these relations have certain properties. Some of these I review\nhere without attempting completeness.\n1 Leopold Kronecker (1823-1891) is widely quoted as having uttered: \"Die ganze Zahl schuf\nder liebe Gott, alles Uebrige ist Menschenwerk.\" (God made the integers, all else is the work\nof man).\n2 Professor Kronecker did not take kindly to these new developments and intervened to\nthwart Cantor's career advancement.\n\n3\n\n\fIf S is a set, then x \u2208 S means that x is an element (or member ) of S. The\nsymbol \u2208 stands for the membership relation. If S and T are sets, then S \u2282 T\nmeans that every element of S (if any) is an element of T (if any). We say that\nS is a subset of T and that T is a superset of S. Thus for every set S, we have\nS \u2282 S. Many authors use \"\u2286\" to indicate the subset-superset relation.\nIf we have both S \u2282 T and T \u2282 S, then S and T have the same elements\nand we write S = T . An important property of sets is that if S and T have\nthe same elements, then S is the same set as T . That is, a set is completely\ndetermined by the elements it contains. A set is not one of those wholes that\nare more than the sum of their parts.\nTo specify a set we only need to tell what elements it has. We can do this in\ntwo ways: element by element or by giving a rule for membership. The notation\nfor the first way is to list the elements between braces, as in\nS = {\u2660, p, \u2020, 5, \u00b6},\nwhich says that the elements of S are \u2660, p, \u2020, 5, and \u00b6, and that there are no\nother elements. As a set is determined by its elements, the order in the listing\nis immaterial.\nThe other specification method is by a rule that determines the elements of\na set; for example\n{x | x \u2208 N and x is not divisible by 2}\nfor the set of odd numbers, where N is the set of natural numbers. In this style\n{\u2660, p, \u2020, 5, \u00b6} can be specified as\n{x | x = \u2660 or x = p or x = \u2020 or x = 5 or x = \u00b6}.\nThe set with no elements is called the empty set or the null set, which we\nwrite as {} or as \u2205. The empty set is a subset of every set3 .\nSet operations\n\nIf S and T are sets, then\nS\u222aT\nS\u2229T\nS\\T\n\ndef\n\n=\n\ndef\n\n=\n\ndef\n\n=\n\n{x | x \u2208 S or x \u2208 T }\n{x | x \u2208 S and x \u2208 T }\n{x | x \u2208 S and x 6\u2208 T }\n\nare also sets. S \u222a T is known as the union of S and T , S \u2229 T as the intersection,\nand S \\ T as the set difference. The expression x 6\u2208 T occurring in the definition\nof S \\ T means that x is not a member of T .\nOne can characterize S \u222a T and S \u2229 T , respectively, as the least common\nsuperset and greatest common subset of S and T .\n3 It\n\nis even a subset of the empty set.\n\n4\n\n\fSets of sets Elements of a set can themselves be sets. For every set S we\ndefine the powerset P(S) of S as the set of all subsets of S. For example,\nP({a, b, c}) =\nP({}) =\nP({\u00b6}) =\n\n{{}, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}\n\n{{}}\n{{}, {\u00b6}}\n\nLet S be a nonempty set of sets. Then \u222aS is defined as {x | \u2203S \u2032 \u2208 S . x \u2208 S \u2032 }\nand \u2229S as {x | \u2200S \u2032 \u2208 S . x \u2208 S \u2032 }.\nLet S be a set of sets and let S0 and S1 be non-empty subsets of S. Then\nS0 \u2282 S1 implies \u222aS0 \u2282 \u222aS1 . It also implies that \u2229S1 \u2282 \u2229S0 .\nThe na\u0131\u0308ve point of view What makes sets interesting is that their elements\ncan be sets. Then of course one also has sets that contain sets that contain\nsets, and so on. It is easy to get carried away and consider things like {x | x 6\u2208\nx}. To assume that such a thing is a set leads to contradiction. As a result,\nmathematicians have learned to be careful. This care takes the form of axioms\nthat explicitly state what things are allowed to be sets. Nothing is a set unless\nthese axioms say it is. This is axiomatic set theory.\nIn this paper I do not try to justify the existence of the sets that we want\nto talk about. That is the \"na\u0131\u0308ve point of view\". According to axiomatic set\ntheory, no things exist except sets. It is na\u0131\u0308ve to assume that a set such as\n{\u2660, p, \u2020, 5, \u00b6} exists. Axiomatic set theory requires one to justify the existence\nas sets of \u2660, p, \u2020, 5, and \u00b6.\nIt is the hallmark of na\u0131\u0308vet\u00e9 to emphasize, as I often will do, that the elements\nof a set are sets: in axiomatic set theory, every nonempty set answers this\ndescription.\nAs an example of familiar objects being reconstructed as sets, let us consider\nnumbers. One of the things set theory is expected to do is to explain and to\njustify the various types of numbers. When starting with sets only, we cannot\nsay that {\u2660, p, \u2020, 5, \u00b6} has five elements, or even that this set has more elements\nthan {\u2660, p, 5, \u00b6}. \"Five\" and \"more\" needs to be explained in terms of sets. We\ncannot even say that (or whether) a set has a finite number of elements without\na set-theoretic explanation of finiteness.\nWhile remaining na\u0131\u0308ve, we should still get some idea of how axiomatic set\ntheory could justify the existence of the kind of sets that we work with. Consider the natural numbers 0, 1, 2, . . . Strictly speaking such numbers are either\n\"ordinal\" or \"cardinal\". Ordinal numbers refer to locations in a linear order;\ncardinal numbers refer to sizes of sets. The construction of ordinal numbers in\nterms of sets is simplest, so we'll just consider that. As the natural numbers\nare all finite anyway, the distinction between cardinal and ordinal numbers need\nnot concern us.\nThe axioms guarantee for every set S the existence of its unique successor\nset S + , which is S \u222a {S}. This at least permits us to say that S + has one more\nelement than S, even if we don't know how to count the elements of S.\n\n5\n\n\fAs the axioms also allow the existence of the empty set \u2205, we have also the\nsets \u2205+ , \u2205++ , and so on, all the way up to infinity (and beyond). These are\nconsidered to be the ordinal numbers 0, 1, 2, and so on, respectively. Before\nset theory it was already shown how one could get from the set N of natural\nnumbers successively the set I of integers, the set Q of rationals (that's simple),\nand, from the rationals, the set R of reals (not so simple).\nIf S + = S \u222a {S}, then S \u2282 S + . As a result, \u2205 \u2282 \u2205+ \u2282 \u2205++ \u2282 * * * In fact,\none can see that \u2205 = {}, \u2205+ = {\u2205}, \u2205++ = {\u2205, \u2205+ }, . . . : Every ordinal number\nis the set of its predecessors. So we could just consider the natural numbers\nas finite ordinals and consider the natural number 0 to be \u2205 and every positive\nnatural number n to be {0, . . . , n \u2212 1}. Instead of \"for all i = 0, . . . , n \u2212 1\"\nwe could be rid of the ambiguous \". . .\" and write \"for all i \u2208 n\". Though this\nconsequence of a natural number n being a set is not widely used, it is concise\nand unambiguous.\n\n2.2\n\nPartitions\n\nLet P be a set of non-empty subsets of a set S. Then we have \u222aP \u2282 S. If we\nalso have \u222aP = S, then P is a cover for S. The elements of P are called the\ncells of the cover. If a cover P for S is such that the sets of P are mutually\ndisjoint, then P is a partition of S.\nA partition P \u2032 of S is said to be finer than P if, for every cell C \u2032 of P \u2032 , there\nis a cell C of P such that C \u2032 \u2282 C. This makes every partition finer than itself,\nwhich is fine (in mathematics). It makes {{x} | x \u2208 S} the finest partition of\nS, and {{S}} the coarsest.\n\n2.3\n\nPairs\n\nThe order in which we list the elements of a {a, b} is an artifact of the notation.\nThe equality of {a, b} and {b, a} can perhaps be seen most clearly by writing\nboth as {x | x = a \u2228 x = b}.\nHow does one use sets not only to bundle a and b together but also to place\nthem in a certain order? The usual way to do this is based on the observation\nthat, though {a, b} and {b, a} are the same set, {{a}, {a, b}} and {{b}, {a, b}}\ndo not have the same elements, so are not the same set. We call {{a}, {a, b}} a\npair, and write ha, bi. The left element of ha, bi is a; its right element is b.\nIn a similar way one can define triples ha, b, ci as hha, bi, ci or ha, hb, cii\nquadruples ha, b, c, di, and so on.\n\n3\n\nBinary relations\n\nA relation among sets associates some of the elements in each of the sets with\neach other. In this section, I present only binary relations: relations between\ntwo sets or between a set and itself. Relations between any number of sets are\ntreated later, independently of binary relations.\n\n6\n\n\fEverything so far in this paper is standard. However, from now on authors\ndiffer on some of the terminology and definitions, though the underlying concepts are universally accepted. Hence the occasional Definition from this point\nonward.\nDefinition 1 (binary relation, source, target, extent, \u2194) A binary relation is a triple of the form hS, T, Ei, where S and T are sets and E is a set of\npairs. If E is nonempty, then hx, yi \u2208 E implies x \u2208 S and y \u2208 T . S is the\nsource, T is the target, and E is the extent of hS, T, Ei. The set of all binary\nrelations with source S and target T is denoted by the expression S \u2194 T .\nDefinition 2 (binary Cartesian product) The binary Cartesian product of\nsets S and T is defined to be {hx, yi | x \u2208 S \u2227 y \u2208 T }. It is written as S \u00d7 T .\nDefinition 3 (empty binary relation, universal binary relation) The empty\nbinary relation in S \u2194 T is the one of which the extent is the empty set of pairs.\nThe binary relation in S \u2194 T that has S \u00d7 T as extent is the universal binary\nrelation, denoted U (S, T ).\n\n3.1\n\nSet-like operations and comparisons\n\nAmong the binary relations in S \u2194 T certain operations are defined that mirror\nset operations:\nhS, T, E0 i \u222a hS, T, E1 i\nhS, T, E0 i \u2229 hS, T, E1 i\nhS, T, E0 i \\ hS, T, E1 i\n\ndef\n\n=\n\ndef\n\n=\n\ndef\n\n=\n\nhS, T, E0 \u222a E1 i\nhS, T, E0 \u2229 E1 i\nhS, T, E0 \\ E1 i\n\nComparison of sets carries over in a similar way to binary relations:\nhS, T, E0 i \u2282 hS, T, E1 i iff\n\n3.2\n\nE0 \u2282 E1\n\nProperties of binary relations\n\nConsider a binary relation hS, T, Ei. It has any subset of the following properties:\n\u2022 total: for every x \u2208 S there exists y \u2208 T such that hx, yi \u2208 E.\n\u2022 single-valued: for all x \u2208 S, y0 \u2208 T , and y1 \u2208 T , hx, y0 i \u2208 E and\nhx, y1 i \u2208 E imply y0 = y1 .\n\u2022 surjective: for every y \u2208 T there exists x \u2208 S such that hx, yi \u2208 E.\n\u2022 injective: for all y \u2208 T , x0 \u2208 S, and x1 \u2208 S, hx0 , yi \u2208 E and hx1 , yi \u2208 E\nimply x0 = x1 .\n7\n\n\fDefinition 4 A partial function is defined to be a single-valued binary relation.\nA functional binary relation is a partial function that is total.\nWe reserve \"function\" for the similar concept that will be defined later independently of binary relations. Some authors, however, prefer to regard a\nfunction as the special case of a binary relation that is single-valued and total.\n\n3.3\n\nOther operations on binary relations\n\nIn addition to the set-like operations defined in section 3.1, the following are\ndefined for binary relations.\nThe inverse of the binary relation hS, T, Ei is given by\nhS, T, Ei\u22121 = hT, S, {hy, xi | hx, yi \u2208 E}i.\nFor every binary relation r we have that (r\u22121 )\u22121 = r.\nIt is apparent from this definition that every binary relation has an inverse:\nno properties are needed. For example, every partial function f has an inverse\nf \u22121 , when regarded as binary relation. But f \u22121 is not necessarily a partial\nfunction: for that to be true, f needs to be injective.\nDefinition 5 (composition) The composition \";\" of two binary relations is\ndefined when the target of the first is the source of the second. In that case it is\ndefined by\ndef\n\nhS, T, Ei; hT, U, F i = hS, U, {hx, zi | \u2203y \u2208 T.hx, yi \u2208 E \u2227 hy, zi \u2208 F }i\nIf r0 ; r1 is defined, then so is r1\u22121 ; r0\u22121 , and it equals (r0 ; r1 )\u22121 .\n\n3.4\n\nEndo-relations\n\nA binary relation where source and target are the same set may well be called\nan endo-relation. Some of the most commonly used binary relations are of this\nkind.\ndef\nFor every set S we define the identity on S as idS = hS, S, {hx, xi | x \u2208 S}i.\nThe identity relations allow, in combination with composition, succinct characterizations of various properties that a relation r in S \u2194 T may have:\nsingle-valued iff\nsurjective iff\ninjective iff\ntotal iff\n\n8\n\nr\u22121 ; r \u2282 idT\nr\u22121 ; r \u2283 idT\n\nr; r\u22121 \u2282 idS\nr; r\u22121 \u2283 idS\n\n\fEquivalence relations Let us consider the endo-relation r = hS, S, Ei.\nIf idS \u2282 r,\nIf r = r\u22121 ,\nIf r; r \u2282 r,\n\nthen r is said to be reflexive.\nthen r is said to be symmetric.\nthen r is said to be transitive.\n\nAn endo-relation that has these three properties is called an equivalence.\nConsider {{y | hx, yi \u2208 E} | x \u2208 S}. If r is reflexive, then this is a cover for\nS. If r is an equivalence, then it is a partition.\nSome order relations If we drop from equivalence the symmetry requirement, then we are left with a weak type of order called a pre-order. Even the\ninclusion relation among the subsets of a set is stronger: in addition to reflexivity and transitivity, it has the property of also being antisymmetric, which can\nbe defined as r \u2229 r\u22121 \u2282 idS . An antisymmetric pre-order is a partial order.\nPartial orders are called thus because not every pair of elements has to be\nin the relation. A partial order r such that r \u222a r\u22121 = U (S, S), the universal\nrelation on S, is said to be order-total. The qualification \"order-\" serves to avoid\nconfusion with the property of being total that was defined earlier. A partial\norder that is also order-total is called a total order, or a linear order.\n\n4\n\nFunctions\n\nThe following definition is independent of the definition of the functional binary\nrelation in Definition 4.\nDefinition 6 (function, source, target, map, \u2192) A function consists of a\nset S, its source, a set T , its target, and a map, which associates to every\nelement of S a unique element of T . We write S \u2192 T for the set of all functions\nwith S as source and T as target.\nS is often called the \"domain\" of the function. However, I prefer to reserve\n\"domain\" for the different meanings that are entrenched in subspecializations\nof computer science such as programming language semantics, constraint processing, and databases. The arrow notation suggests \"source\" as the needed\nalternative for \"domain\"; \"target\" is its natural counterpart.\nThe set S \u2192 T is said to be the type of f \u2208 S \u2192 T . One often sees\n\"f : S \u2192 T \" when f \u2208 S \u2192 T is meant.\nS and T are typically nonempty, but need not be. S and T may or may not\nbe the same set.\nIf the map of f associates the element y in T with the element x in S, then\nwe call y the value of the function at the argument x. We may also say that\nf maps x to y. We write y as f (x) to emphasize that y is determined the\nargument x.\nExample 1 Given f \u2208 S \u2192 T , we can define the binary relation hS, T, {hx, f (x)i |\nx \u2208 S}i. It is a functional binary relation.\n9\n\n\fGiven a functional binary relation hS, T, Ei, we can define a function in\nS \u2192 T whose map associates x with the unique y such that hx, yi \u2208 E, for every\nx \u2208 S.\nThe arrow notation S \u2192 T makes it easy to remember which set is the source\nand which is the target. S \u2192 T is sometimes written as T S . This notation\nmakes it easier to confuse source and target. Here is a way to remember which\nis which. Let us define, for some sets at least, |S| as the number of elements of\nS. Then it can be seen that |S \u2192 T | = |T ||S| .\nThis formula is remarkably resistant to perverse special cases of which we\nnow consider a few. Consider {x} \u2192 T , where the source is a one-element set.\nAs any such function has to associate one element of T with x, T cannot be\nempty. It is easy to count the functions of this type: there are as many such\nfunctions as there are elements in T . The set \u2205 \u2192 T is reckoned to have one\nfunction in it: there is only one way of associating an element of the target with\neach element of the source if there are no elements in the source.\n\n4.1\n\nMultiple arguments\n\nFunctions have one argument. But source and target can themselves have structure and this can be arranged in such a way as to suggest multiple arguments.\nConsider f \u2208 S0 \u2192 (S1 \u2192 T ). With f of this type, x0 \u2208 S0 implies that\nf (x0 ) \u2208 S1 \u2192 T and x1 \u2208 S1 implies that f (x0 ), if given argument x1 , yields as\nvalue (f (x0 ))(x1 ) \u2208 T .\nInstead of (f (x0 ))(x1 ) we will write f (x0 , x1 ). Similarly, we will regard\nf (x0 , . . . , xn\u22121 ) as shorthand for the value of a function in\nS0 \u2192 (S1 \u2192 * * * \u2192 (Sn\u22121 \u2192 T ) * * *)\nat arguments x0 \u2208 S0 , . . . , xn\u22121 \u2208 Sn\u22121 . This construction is called \"Currying\"\nafter the logician Haskell B. Curry.\nExample 2 Consider g(x) = y with g \u2208 U \u2192 V . Here y is determined by\ntwo things: g and x. Hence there is a function, say \u03b1, that has value y for\narguments g and x. This function is in (U \u2192 V ) \u2192 (U \u2192 V ). Compare this\nwith two-argument Currying as in f \u2208 S0 \u2192 (S1 \u2192 T ) and let S0 correspond\nto (U \u2192 V ) and S1 to U . Then we see that \u03b1 is a two argument function with\ng \u2208 U \u2192 V as first argument and x \u2208 U as second argument. In functional\nprogramming, this is the function called apply.\n\n4.2\n\nExpressions\n\nDefinition 6 specifies a map as being part of a function. It does not specify how\nthis map associates source elements with target elements. One of the ways in\nwhich this can be done is by an expression E typically containing x if the value\nof E is defined for every value of a \u2208 S substituted for x and if the values of E\nare in T . We can then find y as the result of evaluating E.\n10\n\n\fThe expression can be a program or it can be an arithmetic or symbolic\nexpression. To indicate that the map associates a with E[x/a], one writes\nx 7\u2192 E.\nE by itself does not specify a function, as such a specification requires the\nsource and the target. E may not even be sufficient as specification of the map.\nFor example, when E is x2 + y, then x 7\u2192 E and y 7\u2192 E are the maps of different\nfunctions. If there is an expression that specifies the map of a function, then\nthere are typically other ones as well. For example, if x \u2208 R, then one may\nprefer (x + 1)2 to x2 + 2x + 1. A reason could be that one prefers to avoid\nmultiple occurrences of a variable.\nThe notation x 7\u2192 E is similar \u03bbx.E, as in lambda calculus. The arrow\nnotation has the advantage of requiring one symbol less than \u03bbx.E. Moreover,\nwhen there are two arguments, as we have here with x and E, infix is the most\nconvenient notation (compare \"2 + 2\" with \"+2.2\").\n\u221a\n\u221a\n\u221a\nExample 3 f \u2208 N \u2192 N with map n 7\u2192 ((1 + 5)n \u2212 (1 \u2212 5)n )/(2n 5) is\nthe function that gives the n-th Fibonacci number.\n\n4.3\n\nProperties of functions\n\nNote the asymmetry in the definition of a function f \u2208 S \u2192 T : with every\nx \u2208 S the map of the function associates a unique y \u2208 T .\nThe function f \u2208 S \u2192 T may associate more than one x \u2208 S with the same\ny \u2208 T . If, on the other hand, f (x1 ) = f (x2 ) implies that x1 = x2 , then this is a\nproperty that not all functions have. A function that has this property is said\nto be injective.\nIt is not necessarily the case that every y \u2208 T is equal to f (x) for some\nx \u2208 S. If f has this additional property, then it is said to be surjective.\nTo be able to count elements in a set we have to define a suitable notion of\nnumber. It would be nice and tidy if this notion of number of elements in a set\nwere based on sets. As we have not done this, we cannot officially count the\nelements in a set. But with injectivity and surjectivity we can at least compare\nsizes of sets: if f \u2208 S \u2192 T is surjective, then there have to be at least as many\nelements in S as there are in T ; if f \u2208 S \u2192 T is injective, then there have to\nbe at least as many elements in T as there are in S. If f is both injective and\nsurjective (such a function is said to be bijective), then S and T have the same\nnumber of elements, however \"number\" is defined.\nIf f \u2208 S \u2192 T is a bijection, then there exists a function g in T \u2192 S that\nassociates with every y \u2208 T the unique x \u2208 S such that f (x) = y. This g is\nuniquely determined by f , is written f \u22121 , and is called the inverse of f . It is a\nbijection; hence has an inverse (f \u22121 )\u22121 , which is equal to f .\nIf there exists a bijection in n \u2192 S, for some natural number n, then we\ncan define S to have n elements. In that case, S is said to be finite, otherwise\ninfinite. S is countably infinite if there exists a bijection in N \u2192 S. If two sets\nare infinite, then it is not necessarily the case that there is a bijection between\n\n11\n\n\fthem. For example, there is no bijection in Q \u2192 R, where Q and R are the\nsets of rational and real numbers, respectively.\nDefinition 7 (identity, restriction, insertion) The function in S \u2192 S with\nmap x 7\u2192 x is idS , the identity function on S. (I count on the context to prevent\nconfusion with the identity that is a binary relation. )\nLet f be a function in S \u2192 T and let S \u2032 be a set. The restriction of f to S \u2032\nis written f \u2193 S \u2032 and is defined4 as the function in S \u2229 S \u2032 \u2192 T that has the\nmapping that associates f (x) \u2208 T with every x (if any) in S \u2229 S \u2032 .\nIf S \u2032 \u2282 S, then idS \u2193 S \u2032 is called the insertion function determined by the subset\nS \u2032 of S.\nAnother function solely determined by subsets is the characteristic function for\nS \u2032 , which is in S \u2192 2 and maps x in S to 1 if x \u2208 S \u2032 and maps x to 0 otherwise.\n\n4.4\n\nFunction sum\n\nDefinition 8 (function sum) Functions f0 \u2208 S0 \u2192 T0 and f1 \u2208 S1 \u2192 T1 are\nsummable iff for all x \u2208 S0 \u2229 S1 , if any, we have f0 (x) = f1 (x). If this is the\ncase, then f0 + f1 , the sum of f0 and f1 , is the function in (S0 \u222a S1 ) \u2192 (T0 \u222a T1 )\nwith map x 7\u2192 f0 (x) if x \u2208 S0 and x 7\u2192 f1 (x) if x \u2208 S1 .\nExample 4 Let f0 \u2208 {a, b} \u2192 {0, 1} such that a 7\u2192 0 and b 7\u2192 1. Let f1 \u2208\n{b, c} \u2192 {0, 1} such that b 7\u2192 1 and c 7\u2192 0. Then f0 and f1 are summable and\n(f0 + f1 ) \u2208 {a, b, c} \u2192 {0, 1} such that a 7\u2192 0, b 7\u2192 1, and c 7\u2192 0.\nRemarks about summability: Given f0 \u2208 S0 \u2192 T0 and f1 \u2208 S1 \u2192 T1 . f0 \u2193 S1\nand f0 are summable, as are f0 \u2193 S1 and f0 \u2193 (S0 \\ S1 ) and f0 = f0 + (f0 \u2193\nS1 ) = (f0 \u2193 S1 ) + (f0 \u2193 (S0 \\ S1 ).\nIf f0 and f1 are summable, then\n\u2022 f0 + f1 = f0 + f1 \u2193 (S1 \\ S0 ) = f1 + f0 \u2193 (S0 \\ S1 )\n\u2022 if, moreover, S0 \u2229 S1 is nonempty, then T0 \u2229 T1 is.\n\n4.5\n\nFunction composition\n\nDefinition 9 (composition) Let f \u2208 S \u2192 T and g \u2208 T \u2192 U . The composition g \u25e6 f of f and g is the function in S \u2192 U that has as map x 7\u2192 g(f (x)).\nSee Figure 1. We sometimes write g \u25e6 f without explicitly saying that it is\ndefined; that is, that the target of f is the source of g.\nExample 5 For all f \u2208 S \u2192 T we have f \u25e6 idS = f = idT \u25e6 f . Let S \u2032 be a\nsubset of S and let i be the insertion function in S \u2032 \u2192 S. Then f \u2193 S \u2032 = f \u25e6 i.\nSee Figure 1.\n4 Some\n\nauthors restrict the notion of restriction to the case where S \u2032 \u2282 S.\n\n12\n\n\fS\n\nS\n\nT\n\nf\n\nT\n\nf\n\nU\n\ng\n\nh\n\nS\nS\n\ngf\n\nT\n\nf\n\nhgf\n\nT\n\nf\nhg\n\ng\n\nf'\n\ni\nS'\n\nV\n\nh\n\nU\n\nFigure 1: Top left: f \u2208 S \u2192 T . Top right: h = g \u25e6 f . Bottom left: S \u2032 \u2282 S\nand i \u2208 S \u2032 \u2192 S is the insertion function of S \u2032 as a subset. The diagram\nshows f \u2032 = f \u2193 S \u2032 = f \u25e6 i. Bottom right: gf = g \u25e6 f , hg = h \u25e6 g, and\nhgf = h \u25e6 (g \u25e6 f ) = (h \u25e6 g) \u25e6 f .\nThe order of f and g in g \u25e6 f is derived from the expression g(f (x)) in the\ndefinition of composition. In many situations this order seems unnatural. If\nthe f and g were functional binary relations, then their composition would be\nwritten as f ; g.\nFunction composition is associative: if, in addition to Definition 9, we have\nh \u2208 U \u2192 V , then (h \u25e6 g) \u25e6 f and h \u25e6 (g \u25e6 f ) are the same function in S \u2192 V .\nSee Figure 1.\nA useful property of composition is that if g \u25e6 f is injective, then f is. For\nsuppose that f is not injective. Then there exist x1 and x2 in S such that\nx1 6= x2 and f (x1 ) = f (x2 ). Then we also have that g(f (x1 )) = g(f (x2 )), so\nthat g \u25e6 f would not be injective.\nThe dual counterpart of this property is that if g \u25e6 f is surjective, then g is.\nFor suppose that g is not surjective. Then there is a z in U such that there is\nno y in T with g(y) = z. Then there is also no x in S with g(f (x)) = z.\nLeft and right inverse Let S and T be nonempty sets, let f \u2208 S \u2192 T , and\nlet g \u2208 T \u2192 S. If idS = g \u25e6 f , then we say that f is a right inverse of g and\nthat g is a left inverse of f . In this case, f is injective and g is surjective.\nTo see why, note that idS is injective and surjective. Hence, by the property\nof composition just introduced, idS = g \u25e6 f implies that f is injective and that\ng is surjective.\nIf, in that case, f is not surjective, then there exists a y in T such that there\n\n13\n\n\ff\n\nf\n\nS\n\nS\n\nT\nk\n\na\n\nl\nc\n\nT\n\na\n\nk\n\nc\n\nm\n\nb\n\nm\n\ng\n\ng\n\nFigure 2: On the left: g \u25e6 f = idS . For this, f needs to be injective, but need\nnot be surjective. As it is not, g is not uniquely determined: g(l) could be a\nand we would still have g \u25e6 f = idS . On the right: f \u25e6 g = idT . For this, g\nneeds to be injective, but need not be surjective. As it is not, f is not uniquely\ndetermined: f (b) could be m and we would still have f \u25e6 g = idT .\ndoes not exist an x in S such that f (x) = y. For such a y, the value of g does\nnot affect g \u25e6 f . Hence, f and idS = g \u25e6 f do not in general uniquely determine\ng.\nBut idS = g \u25e6 f and f surjective do determine g. In that case f is a bijection,\nso that the inverse f \u22121 exists. The unique g = f \u22121 is a bijection as well, so\nthat g is also injective.\nConversely, injectivity of f \u2208 S \u2192 T implies the existence of a left inverse\ng \u2208 T \u2192 S such that g \u25e6 f = idS , which is then surjective.\n\n4.6\n\nSet extensions of functions\n\nWhenever we have a function type S \u2192 T , it is natural to consider the type\nP(S) \u2192 P(T ). Let f be in S \u2192 T . We call a set extension of f any function\ng \u2208 P(S) \u2192 P(T ) such that for all subsets S \u2032 of S we have that {f (s) | s \u2208\nS \u2032 } \u2282 g(S \u2032 ).\nThis definition suggests a partial order among the set extensions of a given\nf \u2208 S \u2192 T . We define g0 \u0016 g1 for set extensions g0 and g1 of f iff g0 (S \u2032 ) \u2282\ng1 (S \u2032 ) for all subsets S \u2032 of S. The relation \u0016 is a partial order. In this partial\norder there is a least element. Its map is S \u2032 7\u2192 {f (x) | x \u2208 S \u2032 } for all subsets S \u2032\nof S. There is a greatest element in the partial order. Its map is S \u2032 7\u2192 T for all\nsubsets S \u2032 of S.\nThe least set extension of f \u2208 S \u2192 T , the one that has as map S \u2032 7\u2192 {f (s) |\n14\n\n\fs \u2208 S \u2032 }, is called the canonical set extension of f . Conversely, the function h in\nP(T ) \u2192 P(S) such that for all subsets T \u2032 of T\nh(T \u2032 ) = {x \u2208 S | f (x) \u2208 T \u2032 }\nis the inverse set extension of f . Note that the inverse set extension is defined\nfor any function, whether it is a bijection or not.\nUsually, the canonical set extension of f is just written as f , and the inverse\nset extension as f \u22121 , so that we write f (S \u2032 ) = {f (x) | x \u2208 S \u2032 } and f \u22121 (T \u2032 ) =\n{x \u2208 S | f (x) \u2208 T \u2032 }. Conventional notation relies on context to disambiguate\nf \u22121 , because it may mean the inverse of a bijection f or it may mean the inverse\nset extension of an f that is not necessarily a bijection.\nAn important property that distinguishes some set extensions is their monotonicity: S1 \u2282 S2 implies f (S1 ) \u2282 f (S2 ). Monotonicity gives us f (S1 \u2229 S2 ) \u2282\nf (S1 ) and f (S1 \u2229 S2 ) \u2282 f (S2 ), so that f (S1 ) and f (S2 ) are both supersets of\nf (S1 \u2229 S2 ). As f (S1 ) \u2229 f (S2 ) is the least common superset of f (S1 ) and f (S2 ),\nwe have\nf (S1 \u2229 S2 ) \u2282 f (S1 ) \u2229 f (S2 ).\nBut the reverse inclusion does not in general hold. For example, suppose that\nf (x1 ) = f (x2 ) = y and x1 6= x2 and let us take S1 = {x1 } and S2 = {x2 }. Then\ny \u2208 f ({x1 }) \u2229 f ({x2 }), whereas y is not contained in f ({x1 } \u2229 {x2 }) = f (\u2205) = \u2205.\nInjectivity of f is a necessary and sufficient condition for equality.\nOn the other hand, we do have\nf (S1 ) \u222a f (S2 ) = f (S1 \u222a S2 )\n\n(1)\n\nThat the left hand side is contained in the right hand side follows from monotonicity and union being the least common superset. For the reverse inclusion suppose that y \u2208 f (S1 \u222a S2 ). Then there is an x \u2208 S1 \u222a S2 such that\nf (x) \u2208 f (S1 \u222aS2 ). If the x is in S1 , then f (x) is in f (S1 ); hence in f (S1 )\u222af (S2 ).\nOtherwise, the x is in S2 , hence f (x) is in f (S2 ); hence in f (S1 ) \u222a f (S2 ). Either\nway, y \u2208 f (S1 ) \u222a f (S2 ). This shows that the right hand side of (1) is included\nin the left hand side.\nFor any f in S \u2192 T we have\nS\u2032\nT\u2032\n\n\u2282 f \u22121 (f (S \u2032 ))\n\u2283 f (f \u22121 (T \u2032 ))\n\nwith S \u2032 and T \u2032 arbitrary subsets of S and T . In the first case we have equality\niff f is injective; in the second case we have equality iff f is surjective.\n\n4.7\n\nEnriched sets\n\nS and T are the same set if and only if every element of S belongs to T and\nvice versa. Thus sets lack some properties, such as order, that are sometimes\ndesirable in a collection. Moreover, set membership is all or nothing, not a\n15\n\n\fmatter of degree. Many authors consider the set-theoretic concept of a set\ninadequate. This leads to various proposals for enrichment of the set concept.\nThe method of set theory is to use functions to specify additional properties,\nnot to enrich the concept of set itself.\n\"Ordered sets\" Suppose we wish to specify an order \u0016 among the elements\nof a finite set S. We can do this by defining a bijection f \u2208 n \u2192 S, where\nn \u2208 N . For every x1 \u2208 S and x2 \u2208 S there exist i1 \u2208 n and i2 \u2208 n such that\nf (i1 ) = x1 and f (i2 ) = x1 . Then we can define x1 \u0016 x2 according to whether\ni1 \u2264 i2 .\nIn set theory, S in combination with such an f takes the place of an \"ordered\nset\".\n\"Multisets\" Sometimes one considers a collection where it is not enough to\nsay whether or not an element belongs, but one wants to say how many times\nit belongs. Such a collection is then called a multiset or bag.\nIn set theory such a requirement poses no difficulty. It is a special case of the\ncommon situation that one wants to associate an attribute with each element of\na set. Suppose we have a set S of objects and a set T of attributes. A function\nf \u2208 S \u2192 T then specifies for each x \u2208 S which of the attributes f (x) \u2208 T it\nhas. If T = N , then the attribute f (x) can be regarded as the multiplicity of x.\nIn set theory, S in combination with such an f takes the place of a \"multiset\".\n\"Fuzzy sets\" Sometimes one considers a collection where it is not enough to\nsay whether or not an element belongs, but one wants to say how strongly it\nbelongs.\nIn set theory, one would regard the required strength of belonging as an\nattribute. The interval [0, 1] of real numbers can be selected as the set of attributes. A set S in combination with f \u2208 S \u2192 [0, 1] can then be regarded as a\n\"fuzzy set\".\n\n5\n\nTuples\n\nOften a function in S \u2192 T models a process of which the input and output\nconsist of elements of S and T , respectively. A function f \u2208 S \u2192 T may\nbe used in a different way: as a method for indexing elements of T using the\nelements of S as index.\nWhen f is used in this way, then it is called a family or a tuple with S as\nindex set, of which the components are restricted to belong to T .\nIn such a situation one sometimes writes fs rather than f (s) for the unique\nelement of T indexed by s \u2208 S. Arrays in programming languages are examples\nof such families. Then S = n and one would write f [i] rather than f (i) where\ni \u2208 n.\n\n16\n\n\fIf the index set is numerical, as in S = n, for some n \u2208 N , or S = N , then\na tuple in S \u2192 T is called a sequence. If S = N , then the sequence is said to\nbe infinite. If S = n, then we call n the length of the sequence.\nIf we think of T as an alphabet, then the functions in n \u2192 T are the strings\nover T of length n. Suppose we have strings \u03b1 \u2208 m \u2192 T and \u03b2 \u2208 n \u2192 T . Then\n\u03b3 \u2208 (m + n) \u2192 T is the concatenation of \u03b1 and \u03b2 if the map of \u03b3 is given by\ni 7\u2192 \u03b1(i) if 0 \u2264 i < m and i 7\u2192 \u03b2(i \u2212 m) if m \u2264 i < m + n.\n\n5.1\n\nNotation\n\nParentheses in mathematics are overloaded with meanings. There is the prime\npurpose of indicating tree structure in expressions. An unrelated meaning is to\nindicate function application, as in f (x), although these two meanings seem to\ncombine in f (x + y). And then we see that a sequence x in n \u2192 T is often\nwritten as (x0 , . . . , xn\u22121 ). Let us at least get rid of this last variant by writing\nx \u2208 n \u2192 T as hx0 , . . . , xn\u22121 i5 .\nTuples need not be indexed by integers. For example, points in the Euclidean\nplane are reals indexed by the X and Y coordinates. Describing points this way\ncorresponds to regarding a point p as a tuple in {X, Y } \u2192 R. For example, a\npoint p could be such that pX = 2 and pY = 3.\nIn a context where the points are thought of as being characterized by the\ncoordinates X and Y one often sees p = h2, 3i. Apparently, a quick switch\nhas been made from {X, Y } to {0, 1} as index set. We need a notation that\nunambiguously describes tuples with small nonnumerical index sets.\nConsider tuples in S \u2192 T representing addresses. Here the index set S could\nbe\n{number, street, city, state, zip}.\nSuch tuples can be written as lines in a table with columns labeled by the\nelements of the index set. The ordering of the columns is immaterial.\nIn this way addresses a, b, c, d, and e would be described as shown in\nFigure 3.\na\nb, c\nd\ne\n\nnumber\n19200\n2200\n2201\n36\n2201\n\nstreet\n120th Ave\nMission College Boulevard\nC Street NW\nCooper Square\nC Street NW\n\ncity\nBothell\nSanta Clara\nWashington\nNew York\nWashington\n\nstate\nWA\nCA\nDC\nNY\nDC\n\nzip\n98011\n95052\n20520\n10003\n20520\n\nFigure 3: A sample of named and unnamed tuples.\nIn Figure 3, the area to the left of the double vertical line is not a column:\nit only serves to write the names, if any, of the tuples. The third tuple has\n5 A potential pitfall of this notation for tuples is that ha, bi can now mean either a pair or\na tuple p with 2 as index set such that p0 = a and p1 = b.\n\n17\n\n\fno name; it is still a tuple. There is a tuple that has two names: b and c.\nAnother tuple occurs twice in the table, once with its name shown; the other\ntime without the name.\nWithout a table we would have to specify laboriously anumber = 19200,\nastreet = 120th Ave, . . ., bnumber = 2200, bstreet = Mission College Boulevard,\n. . ., and so on. Such notation is unavoidable if tables are not available. For example in XML6 the tuple a would be an \"element\" endowed with \"attributes\":\n<a number = \"19200\"\nstate = \"WA\"\n>\n\nstreet = \"120th Ave\"\nzip = \"98011\"\n\ncity = \"Bothell\"\n\nIf no tuple has a name, then one might as well omit the double vertical line,\nand describe the four tuples by means of the table:\nnumber\n19200\n2200\n36\n2201\n\nstreet\n120th Ave\nMission College Boulevard\nCooper Square\nC Street NW\n\ncity\nBothell\nSanta Clara\nNew York\nWashington\n\nstate\nWA\nCA\nNY\nDC\n\nzip\n98011\n95052\n10003\n20520\n\nIn the same way, the point p in {X, Y } \u2192 R such that pX = 2 and pY = 3\nshould be described by\np\n\nX\n2\n\nY\n,\n3\n\ninstead of p = h2, 3i, which would incorrectly imply 2 as index set. We could,\nof course, code the X-coordinate as 0 and the Y -coordinate as 1, so that it\nwould be correct to write p as h2, 3i. The point is that we don't have to code\nfamiliar symbols such as X and Y for coordinates as something else for the sake\nof set-theoretic modeling.\n\n5.2\n\nTyped tuples\n\nConsider a tuple with {number, street, city, state, zip} as index set, representing\nan address. We would like to ensure that the elements indexed by number\nand zip belong to N and that the others belong to the set A\u2217 of alphabetic\ncharacter strings. This is an example of typing a tuple. This involves in general\nassociating a set with each index. That is, to type a tuple with index I, we use\na tuple of sets with index I.\nExample 6 Addresses could be typed by the tuple of sets\nnumber\nN\n\nstreet\nA\u2217\n\ncity\nA\u2217\n\nstate\nA\u2217\n\nzip\nN\n\n6 The Extensible Markup Language, a standard promulgated by the World Wide Web\nConsortium.\n\n18\n\n\fDefinition 10 (typing of tuples) Let I be a set of indexes, T a set of disjoint\nsets, \u03c4 a tuple in I \u2192 T , and t a tuple in I \u2192 \u222aT . We say that t is typed by\n\u03c4 iff we have t(i) \u2208 \u03c4 (i) for all i \u2208 I.\nBecause the sets in T are disjoint, there is a function \u03c3 \u2208 \u222aT \u2192 T that maps\neach element x of \u222aT to the set that is an element of T to which x belongs.\nThe condition of t being typed by \u03c4 can be expressed by means of function\ncomposition; see Figure 4.\n\n\u03c3\n\nT\n\n\u03c4\n\n!T\n\nt\n\nI\nFigure 4: The tuple t \u2208 I \u2192 \u222aT is typed by \u03c4 \u2208 I \u2192 T iff \u03c4 = \u03c3 \u25e6 t.\n\n5.3\n\nCartesian products\n\nDefinition 11 (Cartesian products) Let I be a set of indexes, T a set of\ndisjoint sets, and \u03c4 a tuple in I \u2192 T . The Cartesian product on \u03c4 , denoted\ncart(\u03c4 ), is the set of all tuples that have \u03c4 as type.\nInstead of \" t is typed by \u03c4 \", we can now say \" t \u2208 cart(\u03c4 )\".\nExample 7 Let \u03c4 be in {number, street, city, state, zip} \u2192 {N , A\u2217 }, More specifically, let \u03c4 be equal to the tuple\nnumber\nN\n\nstreet\nA\u2217\n\ncity\nA\u2217\n\nstate\nA\u2217\n\nzip\n.\nN\n\ncart(\u03c4 ) is the set of all tuples of type \u03c4 . In this example it means that\nany natural number, however small or large, can occur as the element indexed\nby number or zip, and that any sequence of characters, in any combination, of\nany length, can occur as element indexed by street, city, or state. The set of\nactually existing addresses is a relatively small subset of cart(\u03c4 ).\nExample 8 Let the index set {X, Y } contain the labels that distinguish the X\nand Y coordinates of the points in the Euclidean plane. Let \u03c4 be the tuple of\nsets in {X, Y } \u2192 {R}. Now cart(\u03c4 ) is the Euclidean plane.\nOften the index set of \u03c4 is n for some positive natural number n. For this\ncase a special notation exists for cart(\u03c4 ). Let \u03c4 be in n \u2192 T , where T is a set\nof sets. The special nature of the index set allows us to write \u03c4 as h\u03c40 , . . . , \u03c4n\u22121 i.\nIn the same spirit, cart(\u03c4 ) may be written as \u03c40 \u00d7 * * * \u00d7 \u03c4n\u22121 . When T consists\n19\n\n\fof a single set, say, T = {S}, then \u03c4 \u2208 n \u2192 {S}, and \u03c40 \u00d7 * * * \u00d7 \u03c4n\u22121 may be\nwritten as S\n* * \u00d7 S}, abbreviated as S n .\n| \u00d7 *{z\nn times\n\nExample 9 S \u00d7 T = cart(\u03c4 ) where \u03c4 \u2208 2 \u2192 {S, T } with \u03c4 (0) = S and\n\u03c4 (1) = T . I trust that the context prevents confusion with the binary Cartesian\nproduct S \u00d7 T defined as {hx, yi | x \u2208 S \u2227 y \u2208 T } (see Definition 2).\nExample 10 A pack of playing cards can be modeled as a Cartesian product.\nLet suit = {\u2663, \u2666, \u2665, \u2660} and let value = {2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A}. Let\n\u03c4 = hsuit, valuei. Then the 52 elements of cart(\u03c4 ), which include e.g. h\u2665, Qi,\nand h\u2660, 5i, can be interpreted as playing cards. As the index set of \u03c4 is 2, we\ncan write cart(\u03c4 ) as suit \u00d7 value.\nExample 11 Let the index set I = n for some natural number n and let T =\n{R}. Then I \u2192 T consists of one typing tuple, say \u03c4 . cart(\u03c4 ) consists of the\npoints in Euclidean n-space and we write Rn instead of cart(\u03c4 ).\n\n5.4\n\nFunctions and Cartesian products\n\nWe have considered functions f in S \u2192 T . These have one argument x in S\nthat gets mapped into f (x) \u2208 T . S or T , or both, may be a Cartesian product.\nSuppose S = cart(\u03c4 ), with \u03c4 \u2208 I \u2192 U . The argument of f is a tuple\nthat is not necessarily indexed by numbers. However, if I = n, then we have\nf \u2208 U0 \u00d7* * *\u00d7Un\u22121 \u2192 T and f -values look like f (hu0 , . . . , un\u22121 i), usually written\nas f (u0 , . . . , un\u22121 ), where u0 \u2208 U0 , . . . , un\u22121 \u2208 Un\u22121 . This is an alternative to\nCurrying for modeling multi-argument functions.\nIt can also happen that the target set T of a function f in S \u2192 T is a\nCartesian product. In such a case it may be more natural to think of f as a\ntuple f \u2032 of functions. Suppose that f is in S \u2192 cart(\u03c4 ) with \u03c4 \u2208 I \u2192 U , where\nU is a set of sets. Thus, for each x \u2208 S, we have that f (x) is a tuple with index\nset I. For each i \u2208 I, (f (x))i is an element of this tuple.\nOne can also think of such an f as a tuple f \u2032 of functions with index set\nI. For each i \u2208 I, we define the element fi\u2032 of the tuple f \u2032 as the function in\nS \u2192 \u03c4i with map x 7\u2192 (f (x))i .\nFor every function f that has a Cartesian product as target, there is a tuple\nf \u2032 of functions uniquely determined as shown above. Conversely, for every tuple\nof functions that have the same source, the above shows the uniquely determined\nfunction with this source that has tuples as values.\n\n5.5\n\nProjections\n\nConsider a sequence s = ha, b, c, d, ei in 5 \u2192 A, where A is a set of alphabetical\ncharacters. Which, if any, of the following is a \"subsequence\" of s: hb, c, di,\nha, c, ei, he, c, ai, or ha, a, ci? Authors' opinions differ.\nWe saw that the definition of function leads in a natural way to the notion\nof restriction. Sequences, being tuples, being functions, therefore also have\nrestrictions. In set theory, subtuples are modeled as restrictions:\n20\n\n\fDefinition 12 (subtuple) If S \u2032 \u2282 S, then f \u2193 S \u2032 is the subtuple on S \u2032 of the\ntuple f in S \u2192 T .\n\nA\n\nT\n\n<a,c,e>\n\ns\n\n\u03c4!i\n\nt\n\n\u03c4\n\n5\n\ns\u2193{0,2,4}\n\ni\n\n3\nI\n\n<0,2,4>\n\n!T\n\n\u03c3\n\ni\n\nt!i\n\nJ\n\n{0,2,4}\n\nFigure 5: Left: See Example 12. Right: See Definition 14. The fact that t is\ntyped by \u03c4 is expressed by the fact that \u03c4 = \u03c3 \u25e6 t. It follows that \u03c4 \u25e6 i = \u03c3 \u25e6 t \u25e6 i.\nExample 12 Let s = ha, b, c, d, ei. We could restrict the index set of s, which\nis 5, to S \u2032 = {0, 2, 4} and get as a subtuple of s the restriction s \u2193 S \u2032 , which\n0 2 4\n, and which is not ha, c, ei. In fact, we have that ha, c, ei = (s \u2193\nis\na c e\nS \u2032 ) \u25e6 h0, 2, 4i, if the target of h0, 2, 4i is {0, 2, 4}. See Figure 5.\nThough tuples are functions, we saw that they come with their own terminology. We saw that it is \"index set\" instead of \"source\" and \"subtuple\" instead\nof restriction. In fact, there is additional specialized terminology for tuples.\nDefinition 13 (projection) Let t be a tuple with index set I and let J be a\nsubset of I. The projection \u03c0J (t) of t on J is the subtuple t \u2193 J of t.\n0 2 4\n.\na c e\nWhen the projection is on a singleton set of indexes, the result is a singleton\n3\ntuple. Rather than writing \u03c0{3} (ha, b, c, d, ei) =\n, we may write the singleton\nd\n3\nset of indexes as the index by itself: \u03c03 (ha, b, c, d, ei) =\n.\nd\nIf a tuple t has type \u03c4 , then the subtuples of t are typed in an obvious way.\nThis observation suggests the definition below.\nThus we have \u03c0{0,2,4} (ha, b, c, d, ei) =\n\nDefinition 14 (subtype) Let T be a set of disjoint sets, I an index set, J a\nsubset of I, and \u03c4 a type in I \u2192 T . We define \u03c4 \u2193 J to be the subtype of \u03c4\ndetermined by J.\nLet now t \u2208 I \u2192 \u222aT be a tuple typed by \u03c4 . It is easy to see that the subtuple\nt \u2193 J of t is typed by the subtype \u03c4 \u2193 J of \u03c4 . Observe that, if i \u2208 J \u2192 I is the\ninsertion function, then t \u2193 J = t \u25e6 i. In Figure 5 we see that \u03c4 \u2193 J = \u03c3 \u25e6 (t \u2193 J).\n21\n\n\fThis shows that if we want to say that t \u2193 J is typed by \u03c4 \u2193 J, then we can say\nit with arrows.\nA projection that is defined for an individual tuple is also defined, as canonical set extension, on a set of tuples that have the same type. Consider for\nexample a Cartesian product. It is a set of tuples of the same type. Therefore\n\u03c0J (cart(\u03c4 )) is defined by canonical set extension to be equal to {\u03c0J (t) | t \u2208\ncart(\u03c4 )}. These are all the tuples of type \u03c0J (\u03c4 ), so by definition equal to\ncart(\u03c0J (\u03c4 )). Thus we see that a projection of a Cartesian product is itself a\nCartesian product.\n\n6\n\nRelations\n\nIn Section 3 we defined binary relations. In this section we define a kind of relation that can hold between any number of arguments. We call these \"relation\".\nWhenever we refer to a binary relation, we should always qualify it as such. The\ngenerality of relations implies that some of them hold between two arguments.\nBut these are still relations and not binary relations. The situation is similar to\nthe trees in Knuth's Art of Programming [7]. He defines binary trees and trees\nin such a way that binary trees are not a special case of trees.\nRelations are specified by means of sets consisting of the tuples containing\nthe objects that are in the relation. It is not enough for the sizes of these tuples\nto be the same. Just as the source and the target are parts of the specification\nof a function, a relation is most useful as a concept when its tuples have the\nsame type. Therefore this type is part of the specification of a relation.\nDefinition 15 (relation) A relation is a pair h\u03c4, Ei where \u03c4 , the signature,\nor the type, of the relation, is a tuple of type I \u2192 T , where T is a set of sets,\nand E, the extent of the relation, is a subset of cart(\u03c4 ).\nExample 13 h\u03c4, Ei where \u03c4 has the empty set as index set. cart(\u03c4 ) has one\nelement, the empty tuple. There are two possibilities for E: the empty set and\nthe singleton set containing the empty tuple.\nThe following example emphasizes the distinction between a relation and a\nbinary relation.\nExample 14 A relation h\u03c4, Ei with \u03c4 \u2208 2 \u2192 T can be represented without loss\nof information by the binary relation h\u03c4 (0), \u03c4 (1), {ht0 , t1 i | t \u2208 E}i. Conversely,\nlet hS, T, Ei be a binary relation and let \u03c4 \u2208 2 \u2192 {S, T } be such that \u03c40 = S\nand \u03c41 = T . This binary relation is represented without loss of information as\nthe relation h\u03c4, F i where F = {t \u2208 cart(\u03c4 ) | ht0 , t1 i \u2208 E}.\nThe following example shows that set theory is of potential interest to\ndatabases.\nExample 15 Let \u03c4 be as in Example 7. The actually existing addresses are\nbut a relatively small subset E of cart(\u03c4 ). The relation h\u03c4, Ei is a relational\nformat for the information represented by this set of addresses.\n22\n\n\fExample 16 The Euclidean plane is a set of tuples that have index set {X, Y }\nand where both elements are reals. That is, the Euclidean plane is cart(\u03c4 ),\nwhere \u03c4 .\nA figure in the Euclidean plane is a subset of the Euclidean plane. So every\nfigure in the Euclidean plane is a relation of type {X, Y } \u2192 {R}. For example,\nthe relation\nh\u03c4, {p \u2208 cart(\u03c4 ) | p2X + p2Y = 1}i\nis the unit circle with the origin as centre.\n\n6.1\n\nSet-like operations\n\nAmong relations of the same type certain relational operations are defined that\nmirror set operations:\nh\u03c4, E1 i \u222a h\u03c4, E2 i\n\n6.2\n\ndef\n\n=\n\nh\u03c4, E1 i \u2229 h\u03c4, E2 i\n\ndef\n\nh\u03c4, E1 i \\ h\u03c4, E2 i\n\n=\n\n=\n\ndef\n\nh\u03c4, E1 \u222a E2 i\nh\u03c4, E1 \u2229 E2 i\nh\u03c4, E1 \\ E2 i\n\nRelations with named tuples\n\nThe extent of a relation h\u03c4, Ei is the set of tuples E. These tuples are not named\nor ordered. Naming of the tuples can be achieved by a set S of names and a\nfunction f in S \u2192 E. If we want to name all tuples, f needs to be surjective.\nIt is also be possible to name the tuples of a relation by means of a subset\nI \u2032 of I (where I is the index set of \u03c4 ), if t \u2193 I \u2032 uniquely identifies t. That is,\nif t0 \u2193 I \u2032 = t1 \u2193 I \u2032 implies, for all t0 , t1 \u2208 E, that t0 = t1 . Sometimes such an\nI \u2032 is a singleton set {i}. A common example is where E consists of tuples t\ndescribing employees and ti is the social insurance number.\n\n6.3\n\nProjections and cylinders\n\nRecall that projections are defined (Definition 13) as restrictions of tuples.\nCanonical set extensions of projections are therefore defined on sets of tuples.\nAs extents of relations are sets of tuples, projections are also defined, as canonical set extensions, on extents of relations.\nDefinition 16 (projection) Let \u03c4 be in I \u2192 T , where T is a set of disjoint\nsets and I is an index set. The projection on J of the relation h\u03c4, Ei is written\n\u03c0J (h\u03c4, Ei) and is defined to be the relation h\u03c4 \u2193 J, {t \u2193 J | t \u2208 E}i.\nExample 17 If we have a relation r = h\u03c4, Ei where \u03c4 is\nnumber\nN\n\nstreet\nA\u2217\n\ncity\nA\u2217\n\n23\n\nstate\nA\u2217\n\nzip\nN\n\n\fand E is the set of tuples that represent addresses of subscribers, then \u03c0{city,state} (r)\nis a relational format for the cities where there is at least one subscriber.\nExample 18 Let r be the relation h\u03c4, Ei where \u03c4 = 3 \u2192 {{a, b}} and E =\n{ha, a, ai, ha, a, bi, hb, a, bi}.\nAn example of a projection is\n\u03c02 (r) = h2 \u2192 {{a, b}}, {ha, ai, hb, ai}i\nWe cannot represent the extent of, e.g., \u03c0{0,2} (r) with angle brackets because the\nangle brackets presuppose an index set in the form of n. Instead we say,\n\u03c0{0,2} (r) = h{0, 2} \u2192 {{a, b}}, Ei\n0\na\nwhere E =\na\nb\n\n2\na\n.\nb\nb\n\nProjections are more often used as canonical set extensions on sets of tuples than on individual tuples. As projections are typically not injective, they\ntypically do not have an inverse. But every function does have an inverse set\nextension. The inverse set extensions of projections are especially useful.\nLet I be an index set with a subset J. If S is a set of tuples with index set\nJ, then we can ask: What tuples t with index set I are such that \u03c0J (t) \u2208 S?\nThis is the definition of inverse set extension: it is defined for all functions,\nprojections or not. So\n\u03c0J\u22121 (S) = {t | \u03c0J (t) \u2208 S}.\n\u22121\n\u22121\nExample 19 In Example 18, \u03c0{0,1}\napplied to the extent of \u03c0{0,1} (r) and \u03c0{0,2}\napplied to the extent of \u03c0{0,2} (r) are, respectively,\n\n{ha, a, ai, ha, a, bi, hb, a, ai, hb, a, bi}\n\n{ha, a, ai, ha, b, ai, ha, a, bi, ha, b, bi, hb, a, bi, hb, b, bi}\nGiven a relation r, one can also wonder about relations that have r as projection. There is a largest such, which is the \"cylinder\" on r. This gives the\nidea; to get the signatures right, see the following definition.\nDefinition 17 (cylinder) For i \u2208 {0, 1}, let \u03c4i be in Ii \u2192 Ti , such that \u03c40 and\n\u03c41 are summable; Ti is a set of sets. Let h\u03c40 , E0 i be a relation. The cylinder in\nI0 \u222a I1 on h\u03c40 , E0 i is written as \u03c0I\u22121\n(h\u03c40 , E0 i) and is defined to be relation\n0 \u222aI1\nh\u03c40 + \u03c41 , {t \u2208 cart(\u03c40 + \u03c41 ) | t \u2193 I0 \u2208 E0 }i.\nThe notation \u03c0 \u22121 suggests some kind of inverse of projection. The suggestion\nis inspired by facts such as \u03c0I0 (\u03c0I\u22121\n(h\u03c40 , E0 i)) = h\u03c40 , E0 i.\n0 \u222aI1\n24\n\n\fExample 20 Consider cart(\u03c4 ), with \u03c4 in {X, Y, Z} \u2192 {R}, and think of it as\nthe three-dimensional Euclidean space. Let the relation r be h\u03c4, {t \u2208 cart(\u03c4 ) |\nt2X + t2Y + t2Z \u2264 1}i, which is the unit sphere with centre in the origin. The\nprojections\n\u03c0{X,Y } (r)\n\u03c0{Z,Y } (r)\n\u03c0{Z,X} (r)\n\n= h\u03c4 \u2193 {X, Y }, {t \u2208 \u03c0{X,Y } cart(\u03c4 ) | t2X + t2Y \u2264 1}i\n\n= h\u03c4 \u2193 {Z, Y }, {t \u2208 \u03c0{Z,Y } cart(\u03c4 ) | t2Z + t2Y \u2264 1}i\n\n= h\u03c4 \u2193 {Z, X}, {t \u2208 \u03c0{Z,X} cart(\u03c4 ) | t2Z + t2X \u2264 1}i\n\ncan be thought of as the two-dimensional projections of the sphere.\nThe one-dimensional projections\n\u03c0X (r)\n\u03c0Y (r)\n\u03c0Z (r)\n\n= h\u03c4 \u2193 {X}, {t \u2208 \u03c0X cart(\u03c4 ) | t2X \u2264 1}i\n= h\u03c4 \u2193 {Y }, {t \u2208 \u03c0Y cart(\u03c4 ) | t2Y \u2264 1}i\n\n= h\u03c4 \u2193 {Z}, {t \u2208 \u03c0Z cart(\u03c4 ) | t2Z \u2264 1}i\n\ncan be thought of as the one-dimensional projections of the sphere.\n\u22121\nThe cylinder \u03c0X\n(\u03c0X (r)) looks like an infinite slab bounded by two planes\nparallel to the Y, Z-plane through the points with Y and Z coordinates 0 and\nwith X coordinates \u22121 and +1. This slab is just wide enough to contain the\nsphere.\n\u22121\n\u22121\n\u03c0X\n(\u03c0X (r)) \u2229 \u03c0Y\u22121 (\u03c0Y (r)) \u2229 \u03c0Z\n(\u03c0Z (r))\nis the intersection of three such slabs perpendicular to each other, so it is the\nsmallest cube with edges parallel to the coordinate axes that contains the sphere.\nIt is a Cartesian product.\n\u22121\nThe cylinder \u03c0{X,Y\n} (\u03c0{X,Y } (r)) looks like, well, a cylinder. Its axis is parallel to the Z axis. The unit disk in the X, Y -plane with its centre at the origin\nis a cross-section.\n\u22121\n\u22121\n\u22121\n\u03c0{X,Y\n} (\u03c0{X,Y } (r)) \u2229 \u03c0{Z,X} (\u03c0{Z,X} (r)) \u2229 \u03c0{Z,Y } (\u03c0{Z,Y } (r))\n\nis the intersection of three such cylinders. It is a body bounded by curved planes\nthat properly contains the sphere r and is properly contained in the box.\nDefinition 18 (join) For i \u2208 {0, 1} let there be relations h\u03c4i , Ei i, with \u03c4i \u2208\nIi \u2192 Ti and Ti a set of disjoint sets. If \u03c40 and \u03c41 are summable, then the\njoin of h\u03c40 , E0 i and h\u03c41 , E1 i is written as h\u03c40 , E0 i \u2736 h\u03c41 , E1 i and defined to be\n\u03c0I\u22121\n(h\u03c40 , E0 i) \u2229 \u03c0I\u22121\n(h\u03c41 , E1 i).\n0 \u222aI1\n0 \u222aI1\nThe intersection in this definition is defined because of the assumed summability of \u03c40 and \u03c41 . The signature of h\u03c40 , E0 i \u2736 h\u03c41 , E1 i is \u03c40 + \u03c41 .\n\n7\n\nApplication to relational databases\n\nCodd [3] proposed to represent the information in \"large banks of formatted data\" as a collection of relations. This proposal has been so successful\n25\n\n\fthat databases are ubiquitous and that most of these conform to Codd's relational model for data. The success of the relational model is due to the fact\nthat its mathematical nature has made more manageable the complexity that\nwould have prevented the earlier models to support the enormous growth that\ndatabases have experienced.\nI have selected relational databases as example of an application in computer\nscience where elementary set theory is useful. This is because the notion of\nrelation is far from clear in the early database literature. As examples I have\nselected Codd's original paper [3] and Ullman's widely quoted textbook [11].\n\n7.1\n\nThe relational model according to Codd\n\nIn Codd [3] we find the following definition, the original one, in section 1.3 \"A\nRelational View of Data\":\nThe term relation is used here in its accepted mathematical sense.\nGiven sets S1 , . . . , Sn (not necessarily distinct), R is a relation on\nthese n sets if it is a set of n-tuples each of which has its first element\nfrom S1 , its second element from S2 , and so on. We shall refer to Sj\nas the jth domain of R.\nNote that Sj , not j, is the domain. Thus Si and Sj may be the same set,\neven though i 6= j. The above quote continues with:\nFor expository reasons, we shall frequently make use of an array\nrepresentation of relations, but it must be remembered that this\nparticular representation is not an essential part of the relational\nview being expounded. An array which represents an n-ary relation\nR has the following properties:\n1. Each row represents an n-tuple of R.\n2. The ordering of rows is immaterial.\n3. All rows are distinct.\n4. The ordering of columns is significant - it corresponds to\nthe ordering S1 , . . . , Sn of the domains on which R is defined\n(see, however, remarks below on domain-ordered and domainunordered relations).\n5. The significance of each column is partially conveyed by labeling it with the name of the corresponding domain.\nCodd gives as example of such an array the one shown in Figure 6. He\nobserves that this example does not illustrate why the order of the columns\nmatters. For that he introduces the one in Figure 7.\nHe explains Figure 7 as follows.\n\n26\n\n\fsupply\n\n(supplier\n1\n...\n\npart\n2\n...\n\nproject\n5\n...\n\nquantity)\n17\n...\n\nFigure 6: Codd's first example: domains all different.\n\ncomponent\n\n(part\n1\n...\n\npart\n5\n...\n\nquantity)\n9\n...\n\nFigure 7: Codd's second example: domains not all different.\n\n. . . two columns may have identical headings (indicating identical\ndomains) but possess distinct meanings with respect to the relation.\nWe can take it that in Figure 7 we have n = 3, S1 = S2 = part, and\nS3 = quantity. As S1 , . . . , Sn need not all be different, columns can only\nidentified by {1, . . . , n}.\nCodd goes on to point out that in practice n can be as large as thirty and\nthat users of such a relation find it difficult to refer to each column by the\ncorrect choice among the integers 1, . . . , 30. According to Codd, the solution is\nas follows.\nAccordingly, we propose that users deal, not with relations, which\nare domain-ordered, but with relationships, which are domain-unordered.\nOne problem is the term \"domain-ordered\". The term suggests that the\nrelation is ordered by the domains S1 , . . . , Sn . But, as Codd warns us, these\nsets are necessarily distinct. If there are fewer than n domains, then they cannot\norder the relation.\nAnother problem with this passage is the introduction of \"relationships\" as\ndistinct from \"relations\". Codd notes in his description of the relational view\nof data that \"the term relation is used in its accepted mathematical sense\". He\nwould have had a hard time to find an accepted mathematical sense for the\ndistinction between \"relation\" and \"relationship\".\nCodd started out with the bold idea that the data that need to be managed in practice can be organized as relations \"in their accepted mathematical\nsense\". Within one page he was forced to retract from this promising start\nto get bogged down in the murky area of \"domain-ordered relations\" versus\n\"domain-unordered relationships\".\nThe cause of the difficulty is that Codd seemed to regard it as somehow\nunmathematical for the index set I to be anything that differs from {1, . . . , n}.\nIn this paper, the exposition leading up to Definition 15 is intended to ensure\nthat one is not even tempted to entertain such a misconception.\n27\n\n\f7.2\n\nThe relational model according to Ullman\n\nThe reader may have thought that the difficulties in Codd [3] would soon be\nstraightened out as this original proposal became mainstream computer science,\nand, as such, the subject of widely quoted textbooks. Let us look at one of these,\nthe one by J.D. Ullman [11].\n[11] introduces \"The Set-Theoretic Notion of a Relation\" (page 43), a notion\nthere also called \"the set-of-lists\" notion of a relation. This is distinguished from\n\"An Alternative Formulation of Relations\", one that is called \"relation in the\nset-of-mappings sense\".\nThe set-list-lists notion of a relation is any subset of the Cartesian product\nD1 \u00d7 * * * \u00d7 Dk , where D1 , . . . , Dk are domains. While Codd was careful to\nsay that the domains need not be distinct, [11] says that there are k domains.\nBut this is probably not intended. [11] uses attributes A1 , . . . , Ak to name the\ncolumns of a tabular representation of a relation. [11] does not say whether\nthese are distinct, but that is probably intended.\nIn the set-of-lists type of relation, columns are named by the indexes 1, . . . , k.\nApparently, the attributes A1 , . . . , Ak are redundant comments on the columns.\nStarting on page 44, in the \"Alternative Formulation\" section, [11] makes\nthe observation that the attributes can be used to index the domains instead\nof the indexes {1, . . . , k} in the set-of-lists type of relation. When the indexes\nare attributes, one has a \"relation in the set-of-mappings sense\". This kind of\nrelation is illustrated with examples rather than defined.\n[11] observes that in the practice of database use, relations are sets of mappings. This make one wonder why the other kind, with its redundant numerical\nindexes, was introduced. The answer comes on page 53, in the section on relational algebra.\nRecall that a relation is a set of k-tuples for some k, called the arity\nof the relation. In general, we give names (attributes) to the components of tuples, although some of the operations mentioned below,\nsuch as union, difference, product, and intersection, do not depend\non the names of the components. These operations do depend on\nthere being a fixed, agreed-upon order for the attributes; i.e. they\nare operations on the list style of tuples rather than the mapping\n(from the attribute names to values) style.\nAs we saw earlier, these operations do not depend on the index set of the\ntype \u03c4 of a relation h\u03c4, Ei having \"a fixed, agreed-upon order\" for its elements.\nDefinition 15 obviates the need for Codd's distinction between \"domainordered\" and \"domain-unordered\" relations and for Ullman's distinction between \"sets-of-lists type relations\" and \"relations in the sets-of-mappings sense\".\nCodd's idea of a relational format for data was a promising one, but the special\ncase of relations as subsets of D1 \u00d7 * * * \u00d7 Dn is too special. It is perhaps not too\nlate to revisit Codd's idea with relations according to Definition 15.\n\n28\n\n\f7.3\n\nA reconstruction of the relational model according to\nset theory and logic\n\nLet us now see what the relational model for data would look like to someone\nwho knows some set theory and who was only told the general idea of [3] without\nthe details as worked out by Codd. We first look how data are stored, then how\nthey are queried. Finally, in this section, we introduce a relational operation\nthat facilitates querying.\n7.3.1\n\nRelations are repository for data\n\nWe have to start with what is implicit in the very idea of a database, relational\nor not. The information to be stored in a database concerns various aspects of\nthings like employees in an organization, parts of an airplane, books in library,\nand so on. The general pattern seems to be that a database describes a collection\nof objects.\nThere is no limit to the information one can collect about an object as it\nexists in reality. Hence one performs an act of abstraction by deciding on a\nset of attributes that apply to the object and one determines what is the value\nof each attribute for this particular object. A consequence of this abstraction\nis that it cannot distinguish between objects for which the attributes have the\nsame value. The set of attributes has to be comprehensive enough that this does\nnot matter for the purpose of the database. That is, within the microcosm of\nthe database, one assumes that Leibniz's principle of Identity of Indiscernibles\nholds.\nThe foregoing is summarized in the first of the following points. The remaining points constitute a reconstruction of the main ideas of a relational database\nas suggested by the first point.\n1. A database is a description of a world populated by objects. For each\nobject, the database lists the values of the applicable attributes.\n2. The database presupposes a set of attributes, and for each attribute, a\nset of allowable values for this attribute. Such sets of admissible values\nare called domains. Let A be the set of attributes and let T be a set of\ndisjoint domains. As each attribute has a uniquely determined domain,\nthis information is expressed by a function, say \u03c4 , that is of type A \u2192 T .\n3. Not all attributes apply to every object. Hence, two objects may be similar\nin the sense that the same set of attributes applies to both. Let us say\nthat objects that are similar in this sense belong to the same class. Hence\na class is characterized by the subset of A that contains the attributes of\nthe objects in the class.\n4. The description of each object is an association of a value with each attribute that is applicable to the object. That is, the object is represented\nby a tuple that is typed by \u03c4 \u2193 I, where I is the set of attributes of the\nclass to which the object belongs.\n29\n\n\fsuppliers =\nsid\nsname\n321\nlee\npoe\n322\n323\nray\n\nparts =\npid\npname\n213\nhose\ntube\n214\n215\nshim\n\ncity\ntulsa\ntaos\ntulsa\nprojects =\nrid\npid\n132\n215\n214\n133\n134\n213\n\nsid\n322\n321\n322\n\npqty\n13\n6\n18\n\nrqty\n2\n11\n18\n\nFigure 8: The relations for Example 21.\n5. The objects of a class are described by tuples of the same type. As tuples\nof the same type are a relation, the class is a relation of that type. As\nobjects need not belong to the same class, a database consists in general\nof multiple relations h\u03c4 \u2193 I0 , E0 i, . . . , h\u03c4 \u2193 In\u22121 , En\u22121 i, where I0 , . . . , In\u22121\nare the attribute sets of the classes.\n6. The life cycle of a database includes a design phase followed by a usage\nphase. In the design phase A, T , and \u03c4 \u2208 A \u2192 T is determined, as well as\nthe subsets I0 , . . . , In\u22121 of A. This is the database scheme. In the usage\nphase the extents E0 , . . . , En\u22121 are added and modified. With the extents\nadded, we have a database instance.\nNote that the set of attributes of one class might be included in another.\nThis suggests a hierarchy of classes. Note also that nothing is said about the\nnature of the values that the attributes might take. Values might be restricted\nto simple values like numbers or strings. Or they could be tuples of one of the\nrelations.\nIt would seem that whether to include these possibilities in a relational\ndatabase would be a matter of trading off flexibility in modeling against simplicity and efficiency in implementation. Not so: these possibilities amount\nto an object-relational database, the desirability of which is subject to heated\ncontroversy.\n7.3.2\n\nQueries, relational algebras, query languages\n\nAccording the relational model, relations are not only used as format for the\ndata stored in a database, but also as format for queries; that is, for selections\nof data to be retrieved from the database. Thus the results of queries are\nrelations. These relations depend on those that are stored in the database and\nmust therefore be the result of operations on them. Let us see how we can use\nthe operations introduced so far.\n\n30\n\n\fSELECT PNAME, CITY\nFROM SUPPLIERS, PARTS, PROJECTS\nWHERE PARTS.PID = PROJECTS.PID AND SUPPLIERS.SID = PARTS.SID\nAND RQTY <= PQTY\nFigure 9: An SQL query to the relations in Figure 8.\nExample 21 (Shim in Taos) Consider the relations shown in the tables in\nFigure 8. Each table consists of a line of headings followed by the line entries\nof the tables. The line entries represent the tuples of the relations. Each table\nhas three such lines.\nThe following abbreviations are used. In the suppliers table, sid for supplier ID, sname for supplier name, and city for supplier city. In the parts\ntable, pid for part ID, pname for part name, and pqty for part quantity on\nhand. In the projects table, rid for project ID and rqty for part quantity\nrequired.\nWe want to know the part names and cities in which there is a supplier with\na sufficient quantity on hand for at least one of the projects.\nThe relation specified by the SQL query in Figure 9 can be specified with\nrelations according to Definitions 15, and with projection and join according to\nDefinitions 16 and 18, respectively.\nLet the tables in Figure 8 be the relations suppliers = h\u03c40 , E0 i, parts =\nh\u03c41 , E1 i, and projects = h\u03c42 , E2 i. In addition, there is a relation in the query\nfor which there is no table, namely the less-than-or-equal relation. Mathematically, there is no reason to treat it differently from the relations stored in tables.\nHence, we also include it as leq = h\u03c43 , E3 i.\nThe index sets of \u03c40 , \u03c41 , \u03c42 are the sets of the column headings of the\ntables for suppliers, parts, and projects, respectively: for \u03c40 the index\nset is { sid, sname, city}, for \u03c41 it is { pid, pname, sid, pqty}, for \u03c42 it is\n{ rid, pid, rqty}. For \u03c43 it is { rqty, pqty}.\nThe extents E0 , E1 , and E2 are as described in Figure 8. Moreover, E3 =\n{t \u2208 cart(\u03c43 ) | t rqty \u2264 t pqty }.\nConsider now the relation\n\u03c0{ pname, city} = suppliers \u2736 parts \u2736 projects \u2736 leq.\n\n(2)\n\nFor the relations to be joinable, the signatures \u03c40 , \u03c41 , \u03c42 , and \u03c43 have to be\nsummable. That is, for any elements common to their source sets, they have\nto have the same value. For example, the source sets of \u03c40 and \u03c41 have sid\nin common. They both map sid to its domain, which is the set of supplier\nIDs. Therefore \u03c40 and \u03c41 are summable; hence cities \u2736 parts is defined\n(Definition 18). Similarly with the other joins in the expression (2), which has\nas value the relation described by the SQL query in Figure 8.\nIn the query in Example 21 every relation occurs at most once. In the\nfollowing example we consider a query where this is not the case.\n31\n\n\fparent\nmary\npc =\njohn\nmary\n\nchild\njohn\nalan\njoan\n\nFigure 10: Relation for Example 22.\nExample 22 (Mary, Alan) In Figure 10 we show a table specifying a relation\nconsisting of tuples of two elements where one is a parent of the other. It is\nrequired to identify pairs of persons who are in the grandparent relation.\nWhat distinguishes this query from the one in Example 21 is that the relations do not occur in the join as given, but are derived from the given relation.\nOn the basis of the derived relations we create one in which the pairs are in the\ngrandparent relation. In one of the SQL dialects this would be:\nSELECT PC0.PARENT, PC1.CHILD\nFROM\nPC AS PC0, PC AS PC1\nWHERE PC0.CHILD = PC1.PARENT\nIn this query, the derived tables are obtained via the linguistic device of renaming pc to pc0 and pc1 .\n7.3.3\n\nAn additional relational operation\n\nDo we have to introduce a special-purpose language to handle a simple query\nsuch as this one? In the following we show how an additional relational operation, \"filtering\", is sufficient to handle, in combination with projection and\njoin, not only this query, but more generally, to write relations expressions that\nmimic the queries of a powerful query language such as Datalog [8].\nThe filtering operation acts on a relation and a tuple and results in a relation.\nLet the relation be h\u03c4, Ei with \u03c4 \u2208 I \u2192 T and T a set of disjoint sets. Let the\ntuple be p \u2208 I \u2192 V , where V is a set of objects that we think of as placeholders.\nIn similar situations such placeholders are often called \"variables\", which is fine,\nas long as we remember that they are elements of a set, and that there is nothing\nlinguistic about them.\nFor each such tuple p we can ask: is there a t \u2208 E such that t = s \u25e6 p for\nsome s \u2208 V \u2192 \u222aT ? In that case we include s in the extent E \u2032 of a relation\nh\u03c6, E \u2032 i. See Figure 11.\nDefinition 19 (filtering) Let \u03c4 be in I \u2192 T , where T is a set of disjoint sets\nand I is an index set. Let p \u2208 I \u2192 V be a tuple. Let \u03c6 \u2208 V \u2192 T be such that\n\u03c4 = \u03c6 \u25e6 p. The filtering by p of the relation h\u03c4, Ei is written h\u03c4, Ei : p and is\ndefined to be the relation h\u03c6, {s \u2208 p(I) \u2192 \u222aT | \u2203t \u2208 E. t = s \u25e6 p}i.\nThe condition \u03c4 = \u03c6\u25e6 p ensures that the variables in V are typed compatibly\nwith \u03c4 .\n32\n\n\fV\n\ns\n\u03c6\n\np\n\nq\n\n\u03c3\n\nT\n\n\u03c4\n\n!T\n\nt\n\nI\nFigure 11: Sets and functions involved in filtering.\nExample 23 Let I = 3, T = {R}, V = {x, y, z}, \u03c4 \u2208 I \u2192 T , and E =\n{hu, v, wi \u2208 R3 | u \u00d7 v = w}. Let p = hx, x, zi. What is h\u03c4, Ei : p?\nIn this example we use the filtering operation to obtain the squaring relation\nas a special case of the multiplication relation. As T is a singleton set, there is\nonly one possibility for \u03c4 , and this is hR, R, Ri. The same holds for \u03c6. In this\nway, h\u03c4, Ei is the multiplication relation over the reals.\nDefinition 19 now implies that the extent of h\u03c4, Ei : p, the result of applying\nfiltering with p to h\u03c4, Ei, is {s \u2208 {x, z} \u2192 R | s2x = sz }. This can be explained\nas follows. We need to find all s \u2208 {x, z} \u2192 R such that there exists a t \u2208 E\nwith t = s \u25e6 p. Now, t = s \u25e6 p implies that t0 = (s \u25e6 p)0 = sp0 = sx . Similarly,\nt1 = (s \u25e6 p)1 = sp1 = sx .\nThat is, t = s \u25e6 p has a solution s iff t0 = t1 . Indeed, p = hx, x, zi can be\nregarded as a pattern that a t \u2208 E may or may not conform to. By filtering the\nmultiplication relation's h\u03c4, Ei tuples through pattern p, h\u03c4, Ei : p becomes, in\nits way, the squaring relation.\nLet us now return to Example 22 to see how filtering can be used here.\nSuppose we have a set V = {x, y, z} and an index set I = {parent, child}.\nLet p and q both be in I \u2192 V , with p such that pparent = x, pchild = y,\nand with q such that qparent = y, qchild = z.\nThe relation\n\u03c0{x,y} (pc : p \u2736 pc : q)\nis the equivalent of the relation resulting from the SQL query.\nIn this example, we have followed database usage in making the index set I =\n{parent, child} non-numerical. If we set I = 2, then we have the convenient\nnotation hx, yi for p and hy, zi for q. The query then becomes\n\u03c0{x,z} (pc : hx, yi \u2736 pc : hy, zi).\n\n(3)\n\nWith the relational operations defined so far (the set-like operations, projection, cylindrification, join, and filtering) we can define a wide variety of queries.\n33\n\n\fWe do this by writing expressions in the informal language of set theory. This\ndoes not mean that a \"query language\" exists. Of course, to make such expressions readable for a machine, they have to be formalized. Only then a\n\"language\" exists, and then only in a technical sense. Thus a \"query language\"\nshould only arise as part of the user manual of a software package. It has no\nplace in expositions of the relational data model.\nSimilarly, as soon as we have relations and operations on them, an algebra\nexists. But this is only so in a technical and not in any substantial sense. Here\nis an example of what I mean by the existence of an algebra in a substantial\nsense. For example, we could observe that the set of integers is closed under\naddition, that addition has an inverse, and that zero is the neutral element\nunder addition. That we then have an algebra in a substantial sense is borne\nout by the fact that this algebra is a group and that examples of groups exist\nthat don't look like the integers at all, yet have certain interesting properties in\ncommon that are expressed in the usual group axioms and theorems.\nIt happens to be the case that the set-like operations together with cylindrification and certain special relations like the diagonals constitute an algebra\nworth the name, the cylindric set algebra. The operations were identified by\nTarski. He only talked about an algebra when a significant theorem and interesting properties had been identified, and then only in abstracts less than a\nhalf page long [9, 10]. Only much later, when significant algebraic results were\nobtained, were cylindric algebras made the subject of a longer publication [5].\nIn the database world things work differently: already in the first few years,\nCodd proposed two query languages for the relational data model. One, the\nrelational calculus, was to be of a nonprocedural nature, so as to make it easy for\nusers to relate the query to their intuitive perception of the real-world situation\ndescribed by the database. The other query language, the relational algebra,\nis distinguished by operations on relations as algebraic objects. This language\nwas intended to facilitate query optimization. However, for some decades the\nquery language used most widely in practice is SQL, which has neither of these\ncharacteristics.\nI have avoided introducing a relational algebra or a query language. Instead\nI have limited myself to introducing operations on relations: the set-like operations, projection, cylindrification, join, and filtering. The closest I come to\na query language are the expressions in the informal language customary and\nuniversal to all mathematical discussions.\nIn spite of these limitations, it is striking how close a query such as the one in\nEquation (3) comes to its equivalent in Datalog [8], one of the query languages\nproposed in the literature. In Datalog, this query would be\nanswer(x, z) \u2190 pc(x, y), pc(y, z).\n\n(4)\n\nOne of the advantages of Datalog over the relational calculus of Codd is that\nDatalog is a subset of the first-order predicate calculus, a relational calculus that\nantedates computers by half a century. The predicate calculus fully embodies\nCodd's ideal of a declarative relational language. The reason Codd could not\n34\n\n\fadopt it, is that a relational algebra counterpart was not known at the time.\nRecent research [5, 6, 12] has remedied this deficiency.\n\n8\n\nConclusion\n\nWhen I advocate basic set theory for computer science, I don't mean finding the\nright formula to copy. Neither this paper, nor any of the books may have the\nright formula. For example, neither Bourbaki [1] nor Halmos [4] give exactly\nthe notion of relation required for databases. The difference is mathematically\ntrivial, but crucial for the relational data model. Neither [1], nor [4], nor this\npaper can anticipate such trivial but crucial variations.\nFor the mathematicians consulted by Codd, the distinction between n =\n{0, . . . , n \u2212 1} and more general index sets in a relation was trivial, so they\nused the most familiar, which is n. But the failure to allow for general index\nsets has continued to trouble the relational data model for years. For Codd it\nwas dangerous to know more than the general idea that a relation is a set of\ntuples, that a tuple is a function, and that arguments for a function don't have\nto be numbers. And for us it is dangerous to copy the formulas from Codd. We\nshould remember his idea, and take it from there, as best we can.\nHence the advice given by Halmos [4] \"Read this, and forget it.\" Or as\nGoethe said: \"Was du ererbt von deinen V\u00e4tern hast, erwirb es um es zu besitzen.\"7\nIn other words, don't copy the formulas.\n\n9\n\nAcknowledgements\n\nMany thanks to Hajnal Andr\u00e9ka, Philip Kelly, Michael Levy, Belaid Moa, Istv\u00e1n\nNemeti, Alex Thomo, and Bill Wadge for helpful discussions and suggestions.\n\nReferences\n[1] N. Bourbaki. Th\u00e9orie des Ensembles (Fascicule de R\u00e9sultats). Hermann et\nCie, 1939.\n[2] Nicolas Bourbaki. El\u00e9ments de Math\u00e9matiques; Fascicule 17, Livre 1:\nTh\u00e9orie des Ensembles. Hermann et Cie, 1954.\n[3] E.F. Codd. A relational model of data for large shared data banks. Comm.\nACM, pages 377 \u2013 387, 1970.\n[4] Paul R. Halmos. Naive Set Theory. D. Van Nostrand, 1960.\n7 What\n\nyou have inherited from your fathers, create it, so that it may be yours.\n\n35\n\n\f[5] Leon Henkin, J. Donald Monk, and Alfred Tarski. Cylindric Algebras, Parts\nI, II. Studies in Logic and the Foundations of Mathematics. North-Holland,\n1985.\n[6] T. Imielinski and W. Lipski. The relational model of data and cylindric\nalgebras. Journal of Computer and System Sciences, 28:80\u2013102, 1984.\n[7] Donald Knuth. The Art of Programming, volume I. Addison-Wesley, 1968.\n[8] D. Maier and D.S. Warren. Computing with Logic: Logic Programming\nwith Prolog. Benjamin/Cummings, 1988.\n[9] A. Tarski. A representation theorem for cylindric algebras. Bull. Amer.\nMath. Soc., 58:65 \u2013 66, 1952.\n[10] A. Tarski and F.B. Thompson. Some general properties of cylindric algebras. Bull. Amer. Math. Soc., 58:65 \u2013 65, 1952.\n[11] Jeffrey D. Ullman. Principles of Database and Knowledge-Base Systems.\nComputer Science Press, 1988.\n[12] M.H. van Emden. Compositional semantics for the procedural interpretation of logic. In S. Etalle and M. Truszczy\u0144ski, editors, Proc. Intern. Conf.\non Logic Programming, number LNCS 4079, pages 315 \u2013 329. Springer\nVerlag, 2006.\n\n36\n\n\f"}