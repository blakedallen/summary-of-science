{"id": "http://arxiv.org/abs/0905.0456v1", "guidislink": true, "updated": "2009-05-04T18:58:07Z", "updated_parsed": [2009, 5, 4, 18, 58, 7, 0, 124, 0], "published": "2009-05-04T18:58:07Z", "published_parsed": [2009, 5, 4, 18, 58, 7, 0, 124, 0], "title": "Non deterministic classical logic: the $\u03bb\u03bc^{++}$-calculus", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0905.4000%2C0905.3732%2C0905.4928%2C0905.3749%2C0905.0812%2C0905.1867%2C0905.0456%2C0905.1507%2C0905.4065%2C0905.0694%2C0905.0411%2C0905.4204%2C0905.0129%2C0905.2527%2C0905.3378%2C0905.1033%2C0905.4765%2C0905.2147%2C0905.2048%2C0905.0354%2C0905.4824%2C0905.0417%2C0905.2333%2C0905.3292%2C0905.2521%2C0905.0253%2C0905.1933%2C0905.2684%2C0905.4505%2C0905.1941%2C0905.2736%2C0905.4449%2C0905.3342%2C0905.3297%2C0905.4243%2C0905.0997%2C0905.2977%2C0905.0012%2C0905.4946%2C0905.2415%2C0905.1044%2C0905.2192%2C0905.2200%2C0905.1079%2C0905.0749%2C0905.1185%2C0905.4529%2C0905.0781%2C0905.2971%2C0905.3789%2C0905.4228%2C0905.4549%2C0905.0720%2C0905.3363%2C0905.0595%2C0905.4221%2C0905.1239%2C0905.4344%2C0905.4741%2C0905.4774%2C0905.2261%2C0905.0412%2C0905.1998%2C0905.0268%2C0905.4273%2C0905.0387%2C0905.1699%2C0905.3754%2C0905.2187%2C0905.1202%2C0905.2737%2C0905.4109%2C0905.3232%2C0905.1017%2C0905.0649%2C0905.1543%2C0905.4192%2C0905.2226%2C0905.1588%2C0905.1051%2C0905.1237%2C0905.1936%2C0905.2597%2C0905.1040%2C0905.2201%2C0905.0768%2C0905.0993%2C0905.2371%2C0905.1779%2C0905.0934%2C0905.1628%2C0905.3346%2C0905.1939%2C0905.4707%2C0905.4031%2C0905.2602%2C0905.1203%2C0905.4042%2C0905.2690%2C0905.3103%2C0905.2603&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Non deterministic classical logic: the $\u03bb\u03bc^{++}$-calculus"}, "summary": "In this paper, we present an extension of $\\lambda\\mu$-calculus called\n$\\lambda\\mu^{++}$-calculus which has the following properties: subject\nreduction, strong normalization, unicity of the representation of data and thus\nconfluence only on data types. This calculus allows also to program the\nparallel-or.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0905.4000%2C0905.3732%2C0905.4928%2C0905.3749%2C0905.0812%2C0905.1867%2C0905.0456%2C0905.1507%2C0905.4065%2C0905.0694%2C0905.0411%2C0905.4204%2C0905.0129%2C0905.2527%2C0905.3378%2C0905.1033%2C0905.4765%2C0905.2147%2C0905.2048%2C0905.0354%2C0905.4824%2C0905.0417%2C0905.2333%2C0905.3292%2C0905.2521%2C0905.0253%2C0905.1933%2C0905.2684%2C0905.4505%2C0905.1941%2C0905.2736%2C0905.4449%2C0905.3342%2C0905.3297%2C0905.4243%2C0905.0997%2C0905.2977%2C0905.0012%2C0905.4946%2C0905.2415%2C0905.1044%2C0905.2192%2C0905.2200%2C0905.1079%2C0905.0749%2C0905.1185%2C0905.4529%2C0905.0781%2C0905.2971%2C0905.3789%2C0905.4228%2C0905.4549%2C0905.0720%2C0905.3363%2C0905.0595%2C0905.4221%2C0905.1239%2C0905.4344%2C0905.4741%2C0905.4774%2C0905.2261%2C0905.0412%2C0905.1998%2C0905.0268%2C0905.4273%2C0905.0387%2C0905.1699%2C0905.3754%2C0905.2187%2C0905.1202%2C0905.2737%2C0905.4109%2C0905.3232%2C0905.1017%2C0905.0649%2C0905.1543%2C0905.4192%2C0905.2226%2C0905.1588%2C0905.1051%2C0905.1237%2C0905.1936%2C0905.2597%2C0905.1040%2C0905.2201%2C0905.0768%2C0905.0993%2C0905.2371%2C0905.1779%2C0905.0934%2C0905.1628%2C0905.3346%2C0905.1939%2C0905.4707%2C0905.4031%2C0905.2602%2C0905.1203%2C0905.4042%2C0905.2690%2C0905.3103%2C0905.2603&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "In this paper, we present an extension of $\\lambda\\mu$-calculus called\n$\\lambda\\mu^{++}$-calculus which has the following properties: subject\nreduction, strong normalization, unicity of the representation of data and thus\nconfluence only on data types. This calculus allows also to program the\nparallel-or."}, "authors": ["Karim Nour"], "author_detail": {"name": "Karim Nour"}, "author": "Karim Nour", "links": [{"href": "http://arxiv.org/abs/0905.0456v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0905.0456v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "math.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "math.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0905.0456v1", "affiliation": "LAMA", "arxiv_url": "http://arxiv.org/abs/0905.0456v1", "arxiv_comment": null, "journal_reference": "Mathematical Logic Quarterly 48 (2002) 357 - 366", "doi": null, "fulltext": "arXiv:0905.0456v1 [math.LO] 4 May 2009\n\nNon deterministic classical logic:\nthe \u03bb\u03bc++ -calculus\nKarim NOUR\nLAMA - Equipe de Logique,\nUniversit\u00e9 de Savoie\n73376 Le Bourget du Lac\ne-mail nour@univ-savoie.fr\nAbstract\nIn this paper, we present an extension of \u03bb\u03bc-calculus called \u03bb\u03bc++ calculus which has the following properties: subject reduction, strong\nnormalization, unicity of the representation of data and thus confluence\nonly on data types. This calculus allows also to program the parallel-or.\n\n1\n\nIntroduction\n\nThere are now many type systems which are based on classical logic ; among\nthe best known are the system LC of J.-Y. Girard [2], the \u03bb\u03bc-calulus of M.\nParigot [6], the \u03bbc -calculus of J.-L. Krivine [3] and the \u03bbSym -calculus of F. Barbanera and S. Berardi [1]. We consider here the \u03bb\u03bc-calculus because it has very\ngood properties: confluence, subject reduction and strong normalization. On\nthe other hand, we lose in this system the unicity of the representation of data.\nIndeed, there are normal closed terms, different from Church integers, typable\nby integer type (they are called classical integers). The solutions which were\nproposed to solve this problem consisted in giving algorithms to find the value of\nclassical integers ([5],[7]). Moreover the presentation of typed \u03bb\u03bc-calculus is not\nvery natural. For example, we do not find a closed \u03bb\u03bc-term of type \u00ac\u00acA \u2192 A.\nIn this paper, we present an extension of \u03bb\u03bc-calculus called \u03bb\u03bc++ -calculus which\ncodes exactly the second order classical natural deduction. The system we propose contains a non deterministic simplification rule which allows a program to\nbe reduced to one of its subroutines. This rule can be seen as a complicated\ngarbage collector. This calculus which we obtain has the following properties: subject reduction, strong normalization, unicity of the representation of\ndata and thus confluence only on data types. This calculus allows also to program the parallel-or.\nAcknowledgement. We wish to thank C. Raffalli for helpful discussions. We\ndo not forget the numerous corrections and suggestions by N. Bernard.\n\n1\n\n\f2\n2.1\n\n\u03bb\u03bc-calculus\nPure \u03bb\u03bc-calculus\n\n\u03bb\u03bc-calculus has two distinct alphabets of variables: the set of \u03bb-variables x, y, z, ...,\nand the set of \u03bc-variables \u03b1, \u03b2, \u03b3,.... Terms (also called \u03bb\u03bc-terms) are defined\nby the following grammar:\nt := x | \u03bbx t | (t t) | \u03bc\u03b1 [\u03b2]t\nThe reduction relation of \u03bb\u03bc-calculus is induced by fives different notions of\nreduction :\nThe computation rules\n(\u03bbx u v)\n(\u03bc\u03b1 u v)\n\n\u2192 u[x := v]\n(c\u03bb )\n\u2217\n\u2192 \u03bc\u03b1 u[\u03b1 := v]\n(c\u03bc )\n\nwhere u[\u03b1 :=\u2217 v] is obtained from u by replacing inductively each subterm of\nthe form [\u03b1]w by [\u03b1](w v)\nThe simplification rules\n[\u03b1]\u03bc\u03b2 u \u2192 u[\u03b2 := \u03b1]\n\u03bc\u03b1 [\u03b1]u \u2192 u (\u2217)\n\n(s1 )\n(s2 )\n\n\u03bc\u03b1 u \u2192 \u03bbx \u03bc\u03b1 u[\u03b1 :=\u2217 x]\n\n(\u2217\u2217)\n\n(s3 )\n\n(*) if \u03b1 has no free occurence in u\n(**) if u contains a subterm of the form [\u03b1]\u03bby w\nFor any \u03bb\u03bc-terms t, t\u2032 , we shall write:\n\u2013 t \u2192n\u03bc t\u2032 if t\u2032 is obtained from t by applying n times these rules.\n\u2013 t \u2192\u03bc t\u2032 if there is n \u2208 IN such that t \u2192n\u03bc t\u2032 .\nWe have the following result ([6],[9]):\nTheorem 2.1 In \u03bb\u03bc-calculus, the reduction \u2192\u03bc is confluent.\n\n2.2\n\nTyped \u03bb\u03bc-calculus\n\nProofs are written in a second order natural deduction system with several conclusions, presented with sequents. The connectives we use are \u22a5, \u2192 and \u2200. We\ndenote by A1 , A2 , ..., An \u2192 A the formula A1 \u2192 (A2 \u2192 (...(An \u2192 A)...)). We\ndo not suppose that the language has a special constant for equality. Instead,\nwe define the formula a = b (where a, b are terms) to be \u2200X (X(a) \u2192 X(b))\n2\n\n\fwhere X is a unary predicate variable. Let E be a set of equations. We denote\nby a \u2248E b the equivalence binary relation such that : if a = b is an equation of\nE, then a[x1 := t1 , ..., xn := tn ] \u2248E b[x1 := t1 , ..., xn := tn ].\nLet t be a \u03bb\u03bc-term, A a type, \u0393 = x1 : A1 , ..., xn : An , \u2206 = \u03b11 : B1 , ..., \u03b1m : Bm\nare two contexts and E a set of equations. The notion \"t is of type A in \u0393 and\n\u2206 with respect to E\" (denoted by \u0393 \u22a2 t : A, \u25b3) is defined by the following rules:\n(1) \u0393 \u22a2 xi : Ai , \u25b3 (1 \u2264 i \u2264 n)\n(2) If \u0393, x : A \u22a2 t : B, \u25b3, then \u0393 \u22a2 \u03bbx t : A \u2192 B, \u25b3\n(3) If \u03931 \u22a2 u : A \u2192 B, \u25b31 , and \u03932 \u22a2 v : A, \u25b32 , then \u03931 , \u03932 \u22a2 (u v) : B, \u25b31 , \u25b32\n(4) If \u0393 \u22a2 t : A, \u25b3, and x not free in \u0393 and \u25b3, then \u0393 \u22a2 t : \u2200x A, \u25b3\n(5) If \u0393 \u22a2 t : \u2200x A, \u25b3, then, for every term a, \u0393 \u22a2 t : A[x := a], \u25b3\n(6) If \u0393 \u22a2 t : A, \u25b3, and X is not free in \u0393 and \u25b3, then \u0393 \u22a2 t : \u2200X A, \u25b3\n(7) If \u0393 \u22a2 t : \u2200X A, \u25b3, then, for every formula G, \u0393 \u22a2 t : A[X := G], \u25b3\n(8) If \u0393 \u22a2 t : A[x := a], \u25b3, and a \u2248E b, then \u0393 \u22a2 t : A[x := b], \u25b3\n(9) If \u0393 \u22a2 t : A, \u03b2 : B, \u25b3, then :\n\u2013 \u0393 \u22a2 \u03bc\u03b2 [\u03b1]t : B, \u03b1 : A, \u25b3 if \u03b1 6= \u03b2\n\u2013 \u0393 \u22a2 \u03bc\u03b1 [\u03b1]t : B, \u25b3 if \u03b1 = \u03b2\nThe typed \u03bb\u03bc-calculus has the following properties ([6],[8]):\nTheorem 2.2\n1) Subject reduction: Type is preserved during reduction.\n2) Strong normalization: Typable \u03bb\u03bc-terms are strongly normalizable.\n\n2.3\n\nRepresentation of data types\n\nEach data type generated by free algebras can be defined by a second order formula. The type of boolean is the formula Bool[x] = \u2200X {X(1), X(0) \u2192 X(x)}\nwhere 0 and 1 are constants. The type of integers is the formula Ent[x] =\n\u2200X {X(0), \u2200y (X(y) \u2192 X(sy)) \u2192 X(x)} where 0 is a constant symbol for zero,\nand s is a unary function symbol for successor.\nIn the rest of this paper, we suppose that every set of equations E satisfies the\nfollowing properties: 0 6\u2248E 1 and if n 6= m, then sn (0) 6\u2248E sm (0)\nWe denote by id = \u03bbx x, 1 = \u03bbx\u03bby x, 0 = \u03bbx\u03bby y and, for every n \u2208 IN,\nn = \u03bbx\u03bby (y n x) (where (y 0 x) = x and (y k+1 x) = (y (y k x))). It is easy to see\nthat:\nLemma 2.1\n1) \u22a2 1 : Bool[1] and \u22a2 0 : Bool[0].\n2) For every n \u2208 IN, \u22a2 n : Ent[sn (0)].\n\n3\n\n\fThe converse of (1) lemma 2.1 is true.\nLemma 2.2 If b \u2208 {0, 1} and \u22a2 t : Bool[b], then t \u2192\u03bc b.\nBut the converse of (2) lemma 2.1 is not true. Indeed, if we take the closed\nnormal term \u03b8 = \u03bbx\u03bbf \u03bc\u03b1 [\u03b1](f \u03bc\u03b2 [\u03b1](f x)), we have \u22a2 \u03b8 : Ent[s(0)].\n\n3\n3.1\n\n\u03bb\u03bc++ -calculus\nPure \u03bb\u03bc++ -calculus\n\nThe set of \u03bb\u03bc++ -terms is given by the following grammar:\nt := x | \u03b1 | \u03bbx t | \u03bc\u03b1 t | (t t)\nwhere x ranges over a set V\u03bb of \u03bb-variables and \u03b1 ranges over a set V\u03bc of \u03bcvariables disjoint from V\u03bb .\nThe reduction relation of \u03bb\u03bc++ -calculus is induced by eight notions of reduction:\nThe computation rules\n(\u03bbx u v) \u21c0 u[x := v]\n(C\u03bb )\n(\u03bc\u03b1 u v) \u21c0 \u03bc\u03b2u [\u03b1 := \u03bby (\u03b2 (y v))]\n\n(C\u03bc )\n\nThe local simplification rules\n((\u03b1 u) v) \u21c0 (\u03b1 u)\n(S1 )\n\u03bc\u03b1\u03bc\u03b2 u \u21c0 \u03bc\u03b1 u[\u03b2 := id]\n(\u03b1 (\u03b2 u)) \u21c0 (\u03b2 u)\n(S3 )\n(\u03b2 \u03bc\u03b1 u) \u21c0 u[\u03b1 := \u03bby (\u03b2 y)]\n\n(S2 )\n(S4 )\n\nThe global simplification rules\n\u03bc\u03b1 u \u21c0 \u03bbz \u03bc\u03b2 u[\u03b1 := \u03bby (\u03b2 (y z))]\n\u03bc\u03b1 u[y := (\u03b1 v)] \u21c0 v (\u2217\u2217)\n(S6 )\n\n(\u2217)\n\n(S5 )\n\n(*) if u contains a subterm of the form (\u03b1 \u03bbx v)\n(**) if y is free in u and \u03b1 is not free in v\nFor any \u03bb\u03bc++ -terms t, t\u2032 , we shall write\n\u2013 t \u21c0n\u03bc++ t\u2032 if t\u2032 is obtained from t by applying n times these rules.\n\u2013 t \u21c0\u03bc++ t\u2032 if there is n \u2208 IN such that t \u21c0n\u03bc++ t\u2032 .\nLet us claim first that \u03bb\u03bc++ -calculus is not confluent. Indeed, if we take\nu = \u03bbx \u03bc\u03b1 ((x (\u03b1 0)) (\u03b1 1)), we have (using rule S6 ) u \u21c0\u03bc++ \u03bbx 0 and\n4\n\n\fu \u21c0\u03bc++ \u03bbx 1. The non confluence of \u03bb\u03bc++ -calculus does not come only from\nrule S6 . Indeed, if we take v = \u03bc\u03b1 ((\u03b1 \u03bc\u03b2 \u03b2)0), we have v \u21c0\u03bc++ \u03bc\u03b1\u03bby (\u03b1 y)\nand v \u21c0\u03bc++ 0.\nThe rules which are really new compared to \u03bb\u03bc-calculus are S1 and S6 . The\nrule S1 means that the \u03bc-variables are applied to more than one term. We will\nsee that typing will ensure this condition. The rule S6 means that if \u03bc\u03b1 t has\na subterm (\u03b1 v) where v does not contain free variables which are bounded in\n\u03bc\u03b1 t, then we can return v as result. This results in the possibility of making\na parallel computation. It is clear that this rule is very difficult to implement.\nBut for the examples and the properties we will present, the condition \"not\nactive binders between \u03bc\u03b1 and \u03b1\" will be enough. Let us explain how we can\nimplement the weak version of this rule. We suppose that the syntax of the\nterms has two \u03bb-abstractions: \u03bb and \u03bb\u2032 and two \u03bc-abstractions: \u03bc and \u03bc\u2032 . We\nwrite \u03bb\u2032 x u and \u03bc\u2032 \u03b1 u only if the variables x and \u03b1 do not appear in u. We\nsuppose also that for each \u03bc-variable \u03b1 we have a special symbol \u03be\u03b1 . We can\nthus simulate the weak version of rule S6 by the following non deterministic\nrules:\n\u03bc\u03b1 u \u21c0\n\n(\u03be\u03b1 u)\n\n\u2032\n\n(\u03be\u03b1 \u03bb x u) \u21c0\n(\u03be\u03b1 \u03bc\u2032 \u03b2 u) \u21c0\n\n(\u03be\u03b1 u)\n(\u03be\u03b1 u)\n\n((\u03be\u03b1 (\u03b1 v)) \u21c0\n((\u03be\u03b1 (u v)) \u21c0\n\nv\n(\u03be\u03b1 u)\n\n(\u2217)\n\n((\u03be\u03b1 (u v)) \u21c0\n\n(\u03be\u03b1 v)\n\n(\u2217)\n\n(*) u 6= \u03b1\nA result of a computation is a term which does not contain symbols \u03be\u03b1 .\nWe will see that with the exception of rule S6 the \u03bb\u03bc++ -calculus is not different\nfrom \u03bb\u03bc-calculus. We will establish codings which make it possible to translate\neach one in to the other.\n\n3.2\n\nRelation between \u03bb\u03bc- calculus and \u03bb\u03bc++ - calculus\n\nWe add to \u03bb\u03bc-calculus the equivalent version of rule S6 :\n\u03bc\u03b1 [\u03b2]u[y := [\u03b1]v] \u2192\u2032 v\nif y is free in u and \u03b1 is not free in v.\nWe denote by \u03bb\u03bc+ -calculus this new calculus.\nFor any \u03bb\u03bc-terms t, t\u2032 , we shall write :\n\u2013 t \u2192n\u03bc+ t\u2032 if t\u2032 is obtained from t by applying n times these rules.\n5\n\n\f\u2013 t \u2192\u03bc+ t\u2032 if there is n \u2208 IN such that t \u2192n\u03bc+ t\u2032 .\nFor each \u03bb\u03bc-term t we define a \u03bb\u03bc++ -term t\u2217 in the following way:\nx\u2217\n{\u03bbx t}\u2217\n{(u v)}\u2217\n{\u03bc\u03b1 [\u03b2]t}\u2217\n\n= x\n= \u03bbx t\u2217\n= (u\u2217 v \u2217 )\n= \u03bc\u03b1 (\u03b2 t\u2217 )\n\nWe have the following result:\nTheorem 3.1 Let u, v be \u03bb\u03bc-terms. If u \u2192n\u03bc+ v, then there is m \u2265 n such that\n\u2217\nu\u2217 \u21c0m\n\u03bc++ v .\nProof Easy.\n\n\u2737\n\nThe converse of this coding is much more difficult to establish because it is\nnecessary to include the reductions of administrative redexes. We first modify\nslightly the syntax of the \u03bb\u03bc++ -calculus. We suppose that we have a particular\n\u03bc-constant \u03b4 (i.e. \u03bc\u03b4 u is not a term) and two other \u03bb-abstractions: \u03bb1 and \u03bb2 .\nThe only terms build with these abstractions are: \u03bb1 xu where u contains only\none occurence of x and \u03bb2 xx. For the rule C\u03bc , \u03bb, \u03bb1 and \u03bb2 behave in the same\nway. We write rules C\u03bc , S2 , S4 and S5 in the following way:\n(\u03bc\u03b1 u v)\n\n\u21c0 \u03bc\u03b2 u[\u03b1 := \u03bb1 y (\u03b2 (y v))]\n\n\u03bc\u03b1\u03bc\u03b2 u \u21c0 \u03bc\u03b1 u[\u03b2 := \u03bb2 x x]\n(\u03b2 \u03bc\u03b1 u) \u21c0 u[\u03b1 := \u03bb1 y (\u03b2 y)]\n\u03bc\u03b1 u\n\n(C\u03bc )\n\n(S2 )\n(S4 )\n\n\u21c0 \u03bbz\u03bc\u03b2 u[\u03b1 := \u03bb1 y (\u03b2 (y z))]\n\n(S5 )\n\nIt is clear that the new \u03bb\u03bc++ -calculus is stable by reductions.\nFor each \u03bb\u03bc++ -term t we define a \u03bb\u03bc-term t\u25e6 in the following way :\nx\u25e6\n\n=\n\nx\n\n\u03b1\u25e6\n{\u03bbx t}\u25e6\n\n=\n=\n\n\u03bbx\u03bc\u03b3 [\u03b1]x\n\u03bbx t\u25e6\n\n{\u03bb1 x t}\u25e6\n{\u03bb2 x x}\u25e6\n\n=\n=\n\n\u03bbx t\u25e6\n\u03bbx\u03bc\u03b3 [\u03b4]x\n\n{\u03bc\u03b1 t}\u25e6\n{(\u03bb1 x u v)}\u25e6\n\n=\n=\n\n\u03bc\u03b1 [\u03b4]t\u25e6\nu\u25e6 [x := v \u25e6 ]\n\n{(\u03bb2 x x v)}\u25e6\n{(u v)}\u25e6\n\n=\n=\n\n\u03bc\u03b3 [\u03b4]v \u25e6\n(u\u25e6 v \u25e6 )\n6\n\n(\u2217)\n\n(\u2217\u2217)\n(\u2217 \u2217 \u2217)\n\n\f(*) \u03b3 6= \u03b1\n(**) \u03b3 is not free in v \u25e6\n(***) u 6= \u03bbi x w i \u2208 {1, 2}\nWe have the following result:\nTheorem 3.2 Let u, v be \u03bb\u03bc++ -terms. If u \u21c0n\u03bc++ v, then there is m \u2265 n and\n\u25e6\na \u03bb\u03bc-term w such that u\u25e6 \u2192m\n\u03bc+ w and v \u2192\u03bc+ w.\nProof We use the confluence of \u03bb\u03bc-calculus and the following lemma:\nLemma 3.1 Let u, v be \u03bb\u03bc++ -terms.\n1) {u[x := v]}\u25e6 \u2192\u03bc+ u\u25e6 [x := v \u25e6 ].\n2) {u[\u03b1 := \u03bb1 y (\u03b2 (y v))]}\u25e6 \u2192\u03bc+ u\u25e6 [\u03b1 :=\u2217 v \u25e6 ].\n\n\u2737\n\nWe deduce the following corollary:\nCorollary 3.1 Let u be a \u03bb\u03bc++ -term. If u\u25e6 is strongly normalizable then u is\nalso strongly normalizable.\n\n3.3\n\nTyped \u03bb\u03bc++ -calculus\n\nTypes are formulas of second order predicate logic constructed from \u22a5, \u2192 and\n\u2200. For every formula A, we denote by \u00acA the formula A \u2192\u22a5 and by \u2203x A the\nformula \u00ac\u2200x \u00acA. Proofs are written in the ordinary classical natural deduction\nsystem.\nLet t be a \u03bb\u03bc++ -term, A a type, \u0393 = x1 : A1 , ..., xn : An , \u03b11 : \u00acB1 , ..., \u03b1m : \u00acBm\na context, and E a set of equations. We define the notion \"t is of type A in \u0393\nwith respect to E\" (denoted by \u0393 \u22a2\u2032 t : A) by means of the following rules\n(1)\n(2)\n(3)\n(4)\n(5)\n(6)\n(7)\n(8)\n(9)\n\n\u0393 \u22a2\u2032 xi : Ai (1 \u2264 i \u2264 n) and \u0393 \u22a2\u2032 \u03b1j : \u00acBj (1 \u2264 j \u2264 m).\nIf \u0393, x : A \u22a2\u2032 u : B, then \u0393 \u22a2\u2032 \u03bbx u : A \u2192 B.\nIf \u03931 \u22a2\u2032 u : A \u2192 B, and \u03932 \u22a2\u2032 v : A, then \u03931 , \u03932 \u22a2\u2032 (u v) : B.\nIf \u0393 \u22a2\u2032 u : A, and x is not free in \u0393, then \u0393 \u22a2\u2032 u : \u2200x A.\nIf \u0393 \u22a2\u2032 u : \u2200x A, then, for every term a, \u0393 \u22a2\u2032 u : A[x := a].\nIf \u0393 \u22a2\u2032 u : A, and X is not free in \u0393, then \u0393 \u22a2\u2032 u : \u2200X A.\nIf \u0393 \u22a2\u2032 u : \u2200X A, then, for every formulas G, \u0393 \u22a2\u2032 u : A[X := G].\nIf \u0393 \u22a2\u2032 u : A[x := a], and a \u2248E b, then \u0393 \u22a2\u2032 u : A[x := b].\nIf \u0393, \u03b1 : \u00acB \u22a2\u2032 u :\u22a5, then \u0393 \u22a2\u2032 \u03bc\u03b1 u : B.\n\nConsequently, we can give more explanations for rule S6 . It means that \"in\na proof of a formula we cannot have a subproof of the same formula\". The\nterms \u03bc\u03b1 u[y := (\u03b1 v)] and v has the same type, then the rule S6 authorizes\n\n7\n\n\fa program to be reduced to one of its subroutines which has the same behaviour.\nIf \u25b3 = \u03b11 : B1 , ..., \u03b1m : Bm , then we denode by \u00ac\u25b3 = \u03b11 : \u00acB1 , ..., \u03b1m : \u00acBm .\nIf \u0393 = x1 : A1 , ..., xn : An , \u03b11 : \u00acB1 , ..., \u03b1m : \u00acBm , then we denote by\n\u0393\u03bb = x1 : A1 , ..., xn : An and \u0393\u03bc = \u03b11 : B1 , ..., \u03b1m : Bm .\nWe have the following results:\nTheorem 3.3\n1) If \u0393 \u22a2 t : A, \u25b3, then \u0393, \u00ac\u25b3 \u22a2\u2032 t\u2217 : A.\n2) If \u0393 \u22a2\u2032 t : A, then \u0393\u03bb \u22a2 t\u25e6 : A, \u0393\u03bc , \u03b4 :\u22a5\nProof By induction on typing.\n\n4\n\n\u2737\n\nTheoretical properties of \u03bb\u03bc++ -calculus\n\nTheorem 4.1 (Subject reduction)\nIf \u0393 \u22a2\u2032 u : A and u \u21c0 v, then \u0393 \u22a2\u2032 v : A.\nProof It suffices to verify that the reduction rules are well typed.\n\n\u2737\n\nTheorem 4.2 (Strong normalization)\nIf \u0393 \u22a2\u2032 u : A, then u is strongly normalizable.\nProof According to the theorem 3.3 and the corollary 3.1, it is enough to show\nthat the \u03bb\u03bc+ -calculus is strongly normalizable. It is a direct consequence of the\ntheorem 2.2 and the following lemma:\nLemma 4.1 Let u, v, w be \u03bb\u03bc-terms. If u \u2192\u2032 v \u2192n\u03bc w then there is m \u2265 n and\n\u2032\n\u2032\n\u2737\na \u03bb\u03bc-term v \u2032 such that u \u2192m\n\u03bc v \u2192 w.\nLet t be a \u03bb\u03bc++ -term and Vt a set of normal \u03bb\u03bc++ -terms. We write t \u2192\u03bc++ Vt\niff:\n\u2013 for all u \u2208 Vt , t \u21c0\u03bc++ u.\n\u2013 If t \u21c0\u03bc++ u and u is normal, then u \u2208 Vt .\nIntuitively Vt is the set of values of t.\nTheorem 4.3 (Unicity of representation of integers)\nIf n \u2208 IN and \u22a2\u2032 t : Ent[sn (0)], then t \u2192\u03bc++ {n}.\nProof Let t be a closed normal term such that \u22a2\u2032 t : Ent[sn (0)]. Since we cannot\nuse rules S4 and S5 , we prove that t = \u03bbx\u03bbf u and x : X(0), f : \u2200y (X(y) \u2192\nX(s(y))) \u22a2\u2032 u : X(sn (0)). The term u does not contain \u03bc-variables. Indeed, if\nnot, we consider a subterm (\u03b1 v) of u such that v does not contain \u03bc-variables.\nIt is easy to see that v is of the form (f m x), thus u is not normal (we can apply\nrule S6 ). Therefore u = (f n x) and t = n.\n\u2737\n8\n\n\f5\n5.1\n\nSome programs in \u03bb\u03bc++ -calculus\nClassical programs\n\nLet I = \u03bbx\u03bc\u03b1 x, C = \u03bbx\u03bc\u03b1 (x \u03b1) and P = \u03bbx\u03bc\u03b1 (\u03b1 (x \u03b1)). It is easy to check\nthat:\nTheorem 5.1\n1) \u22a2\u2032 I : \u2200X {\u22a5\u2192 X}, and, for every t, t1 , ..., tn , (I t t1 ...tn ) \u21c0\u03bc++ \u03bc\u03b1 t.\n2) \u22a2\u2032 C : \u2200X {\u00ac\u00acX \u2192 X}, and, for every t, t1 , ..., tn , (C t t1 ...tn ) \u21c0\u03bc++\n\u03bc\u03b1 (t \u03bby (\u03b1 (y t1 ...tn ))).\n3) \u22a2\u2032 P : \u2200X {(\u00acX \u2192 X) \u2192 X}, and, for every t, t1 , ..., tn , (P t t1 ...tn ) \u21c0\u03bc++\n\u03bc\u03b1 (\u03b1 (t \u03bby (\u03b1 (y t1 ...tn ))) t1 ...tn ).\nLet us note that the \u03bb\u03bc++ -term I simulates the exit instruction of C programming language and the \u03bb\u03bc++ -term P simulates the Call/cc instruction of the\nScheme functional language (see [4]).\n\n5.2\n\nProducers of integers\n\nFor every n1 , ..., nm \u2208 IN, we define the following finite sequence (Uk )1\u2264k\u2264m :\nUk = (\u03b1 (x \u03bbd\u03bby (y nk ) id (I Uk\u22121 ))) (2 \u2264 k \u2264 m)\nand U1 = (\u03b1 (x \u03bbd\u03bby (y n1 ) id \u03b1)).\nLet Pn1 ,...,nm = \u03bbx\u03bc\u03b1 Um . We have:\nTheorem 5.2 \u22a2\u2032 Pn1 ,...,nm : \u2200x {Ent[x] \u2192 \u2203y Ent[y]}, and (Pn1 ,...,nm 0) \u2192\u03bc++\n{\u03bby (y ni ) ; 1 \u2264 i \u2264 m}.\nProof For the typing, it suffices to prove that x : Ent[x], \u03b1 : \u00ac\u2203y Ent[y] \u22a2\u2032\n\u03bbd\u03bby (y nk ) : \u00ac\u2203y Ent[y] \u2192 \u2203y Ent[y] (1 \u2264 k \u2264 m) and thus x : Ent[x], \u03b1 :\n\u00ac\u2203y Ent[y] \u22a2\u2032 Uk :\u22a5 (1 \u2264 k \u2264 m).\nWe define the following finite sequence (Vk )1\u2264k\u2264m :\nVk = (\u03b1 (\u03bbd\u03bby (y nk ) (I Vk\u22121 ))) (2 \u2264 k \u2264 m) and V1 = (\u03b1 \u03bby (y n1 )).\n\u2737\nWe have (Pn1 ,...,nm 0) \u21c0\u03bc++ \u03bbx\u03bc\u03b1 Vm \u21c0\u03bc++ \u03bby (y ni ) (1 \u2264 i \u2264 m).\nLet PIN = (Y F ) where\nF = \u03bbx\u03bby\u03bc\u03b1 (\u03b1 (y \u03bbd (x (s y)) id (I (\u03b1 (y \u03bbd\u03bbz (z y) id \u03b1))))), Y is the Turing\nfixed point and s a \u03bb\u03bc++ -term for successor on Church integers. It is easy to\ncheck that:\nTheorem 5.3 (PIN 0) \u2192\u03bc++ {\u03bby (y m) ; m \u2208 IN}.\nWe can check that \u22a2\u2032 F : \u2200x {Ent[x] \u2192 \u2203y Ent[y]} \u2192 \u2200x {Ent[x] \u2192 \u2203y Ent[y]}.\nTherefore, if we add to the typed system the following rule:\nIf \u0393 \u22a2\u2032 F : A \u2192 A, then \u0393 \u22a2\u2032 (Y F ) : A\n9\n\n\fwe obtain \u22a2\u2032 PIN : \u2200x {Ent[x] \u2192 \u2203y Ent[y]}.\nIt is clear that, with this rule, we lose the strong normalization property. But\nwe possibly can put restrictions on this rule to have weak normalization.\nWe can deduce the following corollary:\nCorollary 5.1 Let R \u2286 IN be a recursively enumerable set. There is a closed\nnormal \u03bb\u03bc++ -term PR such that (PR 0) \u2192\u03bc++ {m ; m \u2208 R}.\n\n5.3\n\nParallel-or\n\nLet T B = {b ; b \u2192\u03bc++ {0} or b \u2192\u03bc++ {1}} the set of true booleans.\nA closed normal \u03bb\u03bc++ -term b is said to be a false boolean iff :\nb 6\u21c0\u03bc++ \u03bbx u\nor\nb \u21c0\u03bc++ \u03bbx u where u 6\u21c0\u03bc++ \u03bby v and u 6\u21c0\u03bc++ (x v1 ...vn )\nor\nb \u21c0\u03bc++ \u03bbx\u03bby u where u 6\u21c0\u03bc++ \u03bby v, u 6\u21c0\u03bc++ (x w1 ...wn ) and u 6\u21c0\u03bc++ (y w1 ...wn ).\nWe denote F B the set of false booleans. Intuitively a false boolean is thus a\nterm which can give the first informations on a true boolean before looping.\nLet B = T B \u222a F B the set of booleans.\nWe said that a closed normal \u03bb\u03bc++ -term T is a parallel-or iff for all b1 , b2 \u2208 B:\n(T b1 b2 ) \u2192\u03bc++ {0, 1} ;\n(T b1 b2 ) \u21c0\u03bc++ 1 iff b1 \u2192\u03bc++ 1 or b2 \u2192\u03bc++ 1 ;\n(T b1 b2 ) \u21c0\u03bc++ 0 iff b1 \u2192\u03bc++ 0 and b2 \u2192\u03bc++ 0.\nLet or be a binary function defined by the following set of equations :\nor(1, x) = 1\nor(0, x) = x\nor(x, 1) = 1\nor(x, 0) = x\nW\nb (y 1\nb 0)\nb (I (\u03b1 (y 1\nb (x b\nb \u03b1))))) where 1\nb = \u03bbp 1 and\nLet\n= \u03bbx\u03bby\u03bc\u03b1 (\u03b1 (x 1\n1 0)\nb\n0 = \u03bbp 0.\nW\nW\nTheorem 5.4 \u22a2\u2032\n: \u2200x\u2200y {Bool[x], Bool[y] \u2192 Bool[or(x, y)]} and\nis a\nparallel-or.\nProof Let B[x] = \u00acBool[x] \u2192 Bool[x].\nb 0)\nb : B[x].\nx : Bool[x] \u22a2\u2032 x : B[1], B[0] \u2192 B[x], then x : Bool[x] \u22a2\u2032 (x 1\nb 0)\nb : B[y].\nIn the same way we prove that y : Bool[y] \u22a2\u2032 (y 1\ny : Bool[y] \u22a2\u2032 y : B[1], B[x] \u2192 B[or(x, y)], then\nb (x 1\nb 0))\nb : Bool[or(x, y)], therefore\nx : Bool[x], y : Bool[y] \u22a2\u2032 (y 1\n10\n\n\fb (x b\nb \u03b1))) :\u22a5 and\n\u03b1 : \u00acBool[or(x, y)], x : Bool[x], y : Bool[y] \u22a2\u2032 (\u03b1 (y 1\n1 0)\n\u2032\nb (x b\nb \u03b1)))) :\n\u03b1 : \u00acBool[or(x, y)], x : Bool[x], y : Bool[y] \u22a2 (I (\u03b1 (y 1\n1 0)\n\u00acBool[or(x, y)].\nx : Bool[x] \u22a2\u2032 x : B[1], B[y] \u2192 B[or(x, y)], then\nb (y 1\nb 0))\nb : B[or(x, y)], therefore\nx : Bool[x], y : Bool[y] \u22a2\u2032 (x 1\nb (y 1\nbb\nb (x 1\nbb\n\u03b1 : \u00acBool[or(x, y)], x : Bool[x], y : Bool[y] \u22a2\u2032 (x 1\n0) (I (\u03b1 (y 1\n0) \u03b1))) :\nBool[or(x, y)]. W\nAnd finally : \u22a2\u2032 : \u2200x\u2200y {Bool[x], Bool[y] \u2192 Bool[or(x, y)]}.\nWe will make three examples of reductions. Let b1 , b2 , b3 \u2208 B such that b1 \u2192\u03bc++\n{0}, b2 \u2192\u03bc++ {1} and b3 \u21c0\u03bc++ \u03bbx\u03bby u where\nW u 6\u21c0\u03bc++W\u03bby v, u 6\u21c0\u03bc++ (x\nW w1 ...wn )\nand u 6\u21c0\u03bc++ (y w1 ...wn ). We will reduce ( b1 b3 ), ( b2 b3 ), and ( b3 b2 ).\nb and R2 = (b3 1\nb (bi b\nb \u03b1))) do not terminate,\n1 0)\nThe reductions of R1 = (b3 b\n1 0)\nand \u03b1 is free\nW in each R such\nW that R2 \u21c0\u03bc++ R. Therefore, the only way to be\ncompute ( b1 b3 ) and ( b2 b3 ) are the following:\nW\n( b1 b3 )\nb R1\u2032 (I (\u03b1 R2\u2032 ))))\n\u21c0\u03bc++ \u03bc\u03b1 (\u03b1 (0 1\n\u21c0\u03bc++ ...\n\u21c0\u03bc++ \u03bc\u03b1 (\u03b1 (R1\u2032\u2032 (I (\u03b1 R2\u2032\u2032 ))))\n\u21c0\u03bc++ ...\nThen the computation does not terminate.\nW\n( b2\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\nb3 )\nb R1\u2032 (I (\u03b1 R2\u2032 ))))\n\u03bc\u03b1 (\u03b1 (1 1\n...\nb (I (\u03b1 R2\u2032\u2032 )))\n\u03bc\u03b1 (\u03b1 1\n...\n\u03bc\u03b1 (\u03b1 1) \u21c0\u03bc++ 1.\n\nb (b2 1\nb 0))\nb and R4 = (b3 1\nb 0)\nb do not terminate.\nThe reductions of R3 = (b3 1\nW\nTherefore, the only way to compute ( b3 b2 ) is the following:\nW\n( b3\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\u21c0\u03bc++\n\nb2 )\n\u03bc\u03b1 (\u03b1 (R1\u2032 (I (\u03b1 ((1 b\n1 R4\u2032 ) \u03b1)))))\n...\nb \u03b1)))))\n\u03bc\u03b1 (\u03b1 (R1\u2032\u2032 (I (\u03b1 (1\n...\n\u03bc\u03b1 (\u03b1 (R1\u2032\u2032\u2032 (I (\u03b1 1))))\n...\n1.\n\n11\n\n\u2737\n\n\fReferences\n[1] F. Barbanera and S. Berardi A symmetric lambda-calculus for classical\nprogram extraction. In M. Hagiya and J.C. Mitchell, editors, Proceedings\nof theoretical aspects of computer software, volume 789 of LNCS, pp. 495515. Springer Verlag, 1994.\n[2] J.-Y. Girard A new constructive logic: classical logic. Mathematical Structures in Computer Science, num 1, pp. 255-296, 1991.\n[3] J.-L. Krivine Classical logic, storage operators and 2nd order lambdacalculus. Annals of Pure and Applied Logic, num 68, pp. 53-78, 1994.\n[4] J.-L. Krivine About classical logic and imperative programming. Ann. of\nMath. and Artif. Intell., num 16, pp. 405-414, 1996.\n[5] K. Nour La valeur d'un entier classique en \u03bb\u03bc-calcul. Archive for Mathematical Logic 36, pp. 461-473, 1997.\n[6] M. Parigot \u03bb\u03bc-calculus : an algorithm interpretation of classical natural\ndeduction. Lecture Notes in Artificial Intelligence, Springer Verlag, num\n624, pp. 190-201, 1992.\n[7] M. Parigot Classical proofs as programs. Lectures Notes in Computer Science, Springer Verlag, num 713, 263-276, 1992.\n[8] M. Parigot Strong normalization for second order classical natural deduction. Proceedings of the eighth annual IEEE symposium on logic in computer science, pp. 39-46, 1993.\n[9] W. Py Confluence en \u03bb\u03bc-calcul. Th\u00e8se de doctorat, Universit\u00e9 de Savoie,\n1998.\n\n12\n\n\f"}