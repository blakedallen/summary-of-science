{"id": "http://arxiv.org/abs/1005.0053v1", "guidislink": true, "updated": "2010-05-01T08:08:34Z", "updated_parsed": [2010, 5, 1, 8, 8, 34, 5, 121, 0], "published": "2010-05-01T08:08:34Z", "published_parsed": [2010, 5, 1, 8, 8, 34, 5, 121, 0], "title": "Global Linear Complexity Analysis of Filter Keystream Generators", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1005.0068%2C1005.4216%2C1005.5000%2C1005.1151%2C1005.0053%2C1005.3079%2C1005.0542%2C1005.3954%2C1005.4696%2C1005.3952%2C1005.4799%2C1005.3346%2C1005.3089%2C1005.5634%2C1005.1979%2C1005.2620%2C1005.3693%2C1005.4377%2C1005.4072%2C1005.2375%2C1005.1814%2C1005.1371%2C1005.0292%2C1005.4929%2C1005.2494%2C1005.0039%2C1005.3462%2C1005.2834%2C1005.4039%2C1005.4889%2C1005.0976%2C1005.0159%2C1005.0056%2C1005.3725%2C1005.1061%2C1005.1971%2C1005.1870%2C1005.3179%2C1005.1234%2C1005.4357%2C1005.5084%2C1005.4015%2C1005.1661%2C1005.2096%2C1005.4116%2C1005.4143%2C1005.3297%2C1005.5060%2C1005.5584%2C1005.4701%2C1005.4572%2C1005.0145%2C1005.0315%2C1005.2630%2C1005.5255%2C1005.0739%2C1005.2093%2C1005.1262%2C1005.3017%2C1005.5644%2C1005.3528%2C1005.4737%2C1005.3286%2C1005.4967%2C1005.4373%2C1005.0658%2C1005.5078%2C1005.5317%2C1005.5684%2C1005.3059%2C1005.4436%2C1005.2637%2C1005.5036%2C1005.0437%2C1005.2463%2C1005.5640%2C1005.0207%2C1005.1638%2C1005.4340%2C1005.3643%2C1005.1401%2C1005.2394%2C1005.0695%2C1005.4834%2C1005.5666%2C1005.0508%2C1005.1020%2C1005.0833%2C1005.2954%2C1005.2715%2C1005.1092%2C1005.4318%2C1005.0173%2C1005.2597%2C1005.3239%2C1005.3451%2C1005.1006%2C1005.5700%2C1005.0699%2C1005.5249%2C1005.5312&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Global Linear Complexity Analysis of Filter Keystream Generators"}, "summary": "An efficient algorithm for computing lower bounds on the global linear\ncomplexity of nonlinearly filtered PN-sequences is presented. The technique\nhere developed is based exclusively on the realization of bit wise logic\noperations, which makes it appropriate for both software simulation and\nhardware implementation. The present algorithm can be applied to any arbitrary\nnonlinear function with a unique term of maximum order. Thus, the extent of its\napplication for different types of filter generators is quite broad.\nFurthermore, emphasis is on the large lower bounds obtained that confirm the\nexponential growth of the global linear complexity for the class of nonlinearly\nfiltered sequences.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1005.0068%2C1005.4216%2C1005.5000%2C1005.1151%2C1005.0053%2C1005.3079%2C1005.0542%2C1005.3954%2C1005.4696%2C1005.3952%2C1005.4799%2C1005.3346%2C1005.3089%2C1005.5634%2C1005.1979%2C1005.2620%2C1005.3693%2C1005.4377%2C1005.4072%2C1005.2375%2C1005.1814%2C1005.1371%2C1005.0292%2C1005.4929%2C1005.2494%2C1005.0039%2C1005.3462%2C1005.2834%2C1005.4039%2C1005.4889%2C1005.0976%2C1005.0159%2C1005.0056%2C1005.3725%2C1005.1061%2C1005.1971%2C1005.1870%2C1005.3179%2C1005.1234%2C1005.4357%2C1005.5084%2C1005.4015%2C1005.1661%2C1005.2096%2C1005.4116%2C1005.4143%2C1005.3297%2C1005.5060%2C1005.5584%2C1005.4701%2C1005.4572%2C1005.0145%2C1005.0315%2C1005.2630%2C1005.5255%2C1005.0739%2C1005.2093%2C1005.1262%2C1005.3017%2C1005.5644%2C1005.3528%2C1005.4737%2C1005.3286%2C1005.4967%2C1005.4373%2C1005.0658%2C1005.5078%2C1005.5317%2C1005.5684%2C1005.3059%2C1005.4436%2C1005.2637%2C1005.5036%2C1005.0437%2C1005.2463%2C1005.5640%2C1005.0207%2C1005.1638%2C1005.4340%2C1005.3643%2C1005.1401%2C1005.2394%2C1005.0695%2C1005.4834%2C1005.5666%2C1005.0508%2C1005.1020%2C1005.0833%2C1005.2954%2C1005.2715%2C1005.1092%2C1005.4318%2C1005.0173%2C1005.2597%2C1005.3239%2C1005.3451%2C1005.1006%2C1005.5700%2C1005.0699%2C1005.5249%2C1005.5312&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "An efficient algorithm for computing lower bounds on the global linear\ncomplexity of nonlinearly filtered PN-sequences is presented. The technique\nhere developed is based exclusively on the realization of bit wise logic\noperations, which makes it appropriate for both software simulation and\nhardware implementation. The present algorithm can be applied to any arbitrary\nnonlinear function with a unique term of maximum order. Thus, the extent of its\napplication for different types of filter generators is quite broad.\nFurthermore, emphasis is on the large lower bounds obtained that confirm the\nexponential growth of the global linear complexity for the class of nonlinearly\nfiltered sequences."}, "authors": ["A. F\u00faster-Sabater", "P. Caballero-Gil"], "author_detail": {"name": "P. Caballero-Gil"}, "author": "P. Caballero-Gil", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1049/ip-cdt:19970764", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1005.0053v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1005.0053v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1005.0053v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1005.0053v1", "arxiv_comment": null, "journal_reference": "IEE Proceedings Computers and Digital Techniques, January 1997,\n  Volume 144, Issue 1, p.33-38", "doi": "10.1049/ip-cdt:19970764", "fulltext": "arXiv:1005.0053v1 [cs.CR] 1 May 2010\n\nGlobal Linear Complexity Analysis of Filter\nKeystream Generators\nA. F\u00faster-Sabater(1) and P. Caballero-Gil(2)\n(1)Consejo Superior de Investigaciones Cient\u0131\u0301ficas, Madrid, Spain\n(2)Universidad de La Laguna, Facultad de Matem\u00e1ticas,\nDepartamento de Estad\u0131\u0301stica, IO y Computaci\u00f3n, La Laguna, Spain\n\nAbstract\nAn efficient algorithm for computing lower bounds on the global linear\ncomplexity of nonlinearly filtered PN-sequences is presented. The technique here developed is based exclusively on the realization of bit wise\nlogic operations, which makes it appropriate for both software simulation\nand hardware implementation. The present algorithm can be applied to\nany arbitrary nonlinear function with a unique term of maximum order.\nThus, the extent of its application for different types of filter generators is\nquite broad. Furthermore, emphasis is on the large lower bounds obtained\nthat confirm the exponential growth of the global linear complexity for\nthe class of nonlinearly filtered sequences.\n\n1\n\nIntroduction\n\nMany procedures in modern communication systems require binary sequences\nwhich appear to be random but, in fact, have been generated in a deterministic\nway. They are the so-called pseudorandom sequences. In cryptographic applications the sequence obtained in such a way is referred to as the keystream.\nTo provide secure encryption the keystream must verify several properties of\ncryptographic nature such as: long periods, balanced statistics, mth-order correlation immunity, distance to linear functions, avalanche criterion... (for a\nmore detailed survey see [9]). In addition a keystream generator has to be unpredictable: that is, given a portion of the output sequence, a cryptoanalyst\nshould be unable to predict other bits forward or backward. A widely accepted\nmeasure of the unpredictability of a sequence is the linear complexity defined\nas the shortest linear recursion over GF(2) satisfied by such a sequence.\n0 This work was supported by R&D Spanish Program TIC95-0080.\nIEE Proceedings Computers and Digital Techniques, January 1997, Vol. 144, Is. 1, p.33-38.\nDOI: 10.1049/ip-cdt:19970764\n\n1\n\n\fOne of the most commonly used keystream generators is obtained by applying a nonlinear function to the stages of a maximal-length Linear Feedback\nShift Register (LFSR). This type of generator is called 'filter generator'. The\nlinear complexity of the resulting keystream can be computed in two different\nways:\n1.- Analysing the digits of the output sequence by means of the BerlekampMassey LFSR synthesis algorithm [6].\n2.- Studying the nonlinear function applied to the LFSR's stages.\nLocal linear complexity and global linear complexity are obtained in each\ncase respectively. The global linear complexity of the filter generators depends\nexclusively on the particular form of the filter and the LFSR's minimal polynomial. Generally speaking, there is no systematic method to predict the resulting global linear complexity. This is the reason why in the open literature\nstatements like 'it is extremely difficult to lowerbound (or guarantee) the linear\ncomplexity of the sequences produced by nonlinearly filtering the state of an\nLFSR' [8, pp. 57] can be found. Nevertheless, some authors have faced this\nproblem and several references can be quoted. Apart from the works of Groth\n[2] and Key [3], Kumar and Scholtz [5] derived a general lower bound for the\nclass of bent sequences, although the LFSR's length is restricted to be a multiple\nof 4. Rueppel [8] established his root presence test for the product of distinct\nphases of a PN-sequence, which is based on the computation of determinants\nin a finite field. One of the most recent works on this subject, [7], has focussed\non the use of the Discrete Fourier Transform Technique to analyse the global\nlinear complexity. Most of the above mentioned works impose rather restrictive conditions on the LFSR's length, the order of the nonlinear function or the\nparticular form of the applied function.\nBased on the works [8] and [1], a new algorithm (the so-called LB-algorithm)\nis proposed for the computation of lower bounds on the global linear complexity.\nThis algorithm can be applied to any arbitrary nonlinear filter with a unique\nterm of maximum order. In fact, no restrictions are imposed on the LFSR's\nstages, the particular form of the filter or the LFSR's minimal polynomial. On\nthe other hand, the most important feature of the LB-algorithm is that it is\nbased exclusively on the realization of bit wise logic operations (OR, AND and\nXOR), which makes it rather adequate to either software simulation or hardware\nimplementation.\nAs the algorithm INPUTS are L (LFSR's length) and k (order of the function), then the lower bound obtained is valid for any kth-order function with a\nunique term of maximum order and for any LFSR of length L.\n\n2\n\n\f2\n\nReview of the Root Presence Test and new\nDefinitions\n\nSome fundamental concepts and notation which are used in this work can be\nintroduced as follows.\nS is the output sequence of an LFSR whose minimal polynomial ms (x) \u2208\nGF (2)[x] is primitive. L is the length of the LFSR. \u03b1 \u2208 GF (2L ) is one root\nof ms (x). fk denotes the unique maximum order term of a nonlinear kth-order\nfunction f applied to the LFSR's stages, fk = sn+t0 sn+t1 * * * sn+tk\u22121 where the\nsymbols tj (j=0,1,...,k-1) are integers verifying 0 \u2264 t0 < t1 < *** < tk\u22121 < 2L \u22121.\nIn this work only the contribution of fk to the global linear complexity of the\nresulting sequence will be studied.\nThe root presence test for the product of k distinct phases of a PN-sequence\ncan be stated as follows, [8]:\n\u03b1E \u2208 GF (2L ) is a root of the minimal polynomial of the generated sequence\nif and only if\ne0\n\nAE =\n\n\u03b1t0 2\ne1\n\u03b1t0 2\n.\nt0 2ek\u22121\n\u03b1\n\ne0\n\n\u03b1t1 2\ne1\n\u03b1t1 2\n.\nt1 2ek\u22121\n\u03b1\n\n.\n.\n.\n.\n\n.\n.\n.\n.\n\ne0\n\n. \u03b1tk\u22121 2\ne1\n. \u03b1tk\u22121 2\n.\n.\ntk\u22121 2ek\u22121\n. \u03b1\n\n6= 0\n\nHere \u03b1tj \u2208 GF (2L ) (j=0,1,..,k-1) correspond respectively to the k phases\n(sn+tj ) of the PN-sequence. E, the representative element of the cyclotomic\ncoset E, is a positive integer of the form E = 2e0 + 2e1 + * * * + 2ek\u22121 with\nthe ei (i=0,1,..., k-1) all different running in the interval [0, L). Under these\nconditions, \u03b1E and its conjugate roots contribute to the global linear complexity\nof the nonlinearly filtered sequence. The value of this contribution is equal to\nthe number of elements in such a cyclotomic coset.\nThe cyclotomic coset E is said to be degenerate if the corresponding determinant AE equals zero. Otherwise the cyclotomic coset E will be nondegenerate.\nNotice that every cyclotomic coset E can be easily associated with the radix2 form of the integer E. This fact quite naturally suggests the introduction of\nbinary strings of length L and Hamming weight k. Indeed, the cyclotomic coset\nE can be equivalently characterized by:\n(i) the integer E of the form E = 2e0 + 2e1 + * * * + 2ek\u22121 .\n(ii) an L-bit string whose 1's are placed at the positions {ei }i=0,1,...,k\u22121 .\n(iii) the determinant AE as defined before.\n(iv) the homogeneous linear system (2.1) associated with AE ,\n\uf8f1\ne0\ne0\ne0\nd0 \u03b1t0 2 + d1 \u03b1t1 2 + * * * + dk\u22121 \u03b1tk\u22121 2\n\uf8f4\n\uf8f4 0=\ne1\ne1\ne1\n\uf8f4\n\uf8f2 0=\nd0 \u03b1t0 2 + d1 \u03b1t1 2 + * * * + dk\u22121 \u03b1tk\u22121 2\n(1)\n..\n\uf8f4\n.\n\uf8f4\n\uf8f4\nek\u22121\nek\u22121\nek\u22121\n\uf8f3\n0 = d0 \u03b1t0 2\n+ d1 \u03b1t1 2\n+ * * * + dk\u22121 \u03b1tk\u22121 2\n3\n\n\fwhere dj \u2208 GF (2L ) \u2200j.\nIn the sequel these four characterizations will be used indistinctly. Regarding\nthe use of the binary strings, some additional notation is necessary.\nLet E = 2e0 + 2e1 + * * * + 2ek\u22121 and F = 2f0 + 2f1 + * * * + 2fl\u22121 be two\nL-bit strings of weight k and l respectively with k<l. E \u2282 F means that\n{ei }i=0,1,...,k\u22121 \u2282 {fi }i=0,1,...,l\u22121 . That is, all the 1's in E are also in F.\nFor a set of L-bit strings {En } = {E1 , E2 , ..., EN }, OR[{En }] denotes the\nL-bit string resulting from a bit wise OR among the L-bit strings of the set.\nObviously, we have that \u2200n \u2208 {1, 2, ..., N }, En \u2282 OR[{En }].\nFinally, we quote the following definitions and results related to the global\nlinear complexity of a function with a unique term of maximum order, [1].\nA cyclotomic coset is called a fixed-distance coset if it has an element Ed of\nthe form Ed = 2e0 + 2e1 + * * * + 2ek\u22121 , with ei \u2261 d * i (mod L) \u2200i \u2208 {0, 1, ..., k \u2212 1}\nand d being a positive integer less than L such that (d,L)=1. Its name is\ndue to the fixed distance d among the positions of the 1's in the L-bit string\nrepresentation of Ed .\nThe 1 placed at the position ej will be called the jth-1 of the L-bit string\nassociated with the coset Ed .\nTheorem 1\nf is a kth-order function if and only if all the fixed-distance cosets are nondegenerate.\nCorollary 1\nThe global linear complexity \u039b of the sequence produced by f is lower(\u03a6(L) being the Euler function).\nbounded by \u039b \u2265 NL * L, where NL = \u03a6(L)\n2\nHere NL represents the number of fixed-distance cosets and L the number of\nelements in such cosets.\nCorollary 2\nIf L is prime, then the global \u0001linear complexity \u039b of the sequence generated\nby f is lowerbounded by \u039b \u2265 L2 Remark that these results, which constitute\nthe starting point of the present work, are independent of the LFSR, the order\nof f and the particular form of f .\n\n3\n\nTheoretical Results\n\nConsidering a general function f defined as before, the present work is concerned\nwith the next simple idea:\nNot many degenerate cosets can exist simultaneously.\nA proof of this statement can be outlined in three different steps. First, the\nN cosets of a specific set are supposed to be simultaneously degenerate. Then,\nit is proved that only m of these cosets (with m < N) can be simultaneously degenerate. Consequently, (N-m) cosets contribute to the global linear complexity\nof the resulting sequence.\n\n4\n\n\fThis procedure can be expressed in a more formal way as follows. First of\nall, a new class of cosets is introduced.\nGiven a fixed-distance coset Ed = 2e0 +2e1 +***+2ek\u22121 and j \u2208 {0, 1, ..., k\u22121},\nwe will call jth-quasi fixed-distance coset (for short jth-quasi f-d coset) to any\ncyclotomic coset whose representative element Fdj is of the form Fdj = 2f0 +\n2f1 + * * * + 2fk\u22121 such that {ei }i=0,1,...,k\u22121 \u2282 {fi }i=0,1,...,k\u22121 i 6= j. That is,\na jth-quasi f-d coset Fdj is any cyclotomic coset whose L-bit string associated\ncontains all the 1's of the L-bit string associated with Ed except for the jth-1.\nj\nj\nj\n{Fd,n\n} = {Fd,1\n, ..., Fd,N\n} is used to denote a set of jth-quasi f-d cosets.\nLemma 1\nLet Fdj be any jth-quasi f-d coset, then AF j has at least a minor of order\nd\n(k-1) (without the jth-row and an arbitrary ith-column) that does not equal\nzero:\ne0\n\n\u03b1t0 2\n.\nej\u22121\n\u03b1t0 2\nej+1\n\u03b1t0 2\n.\nt0 2ek\u22121\n\u03b1\n\ne0\n\n. \u03b1ti\u22121 2\n.\n.\nej\u22121\n. \u03b1ti\u22121 2\nej+1\n. \u03b1ti\u22121 2\n.\n.\nti\u22121 2ek\u22121\n. \u03b1\n\ne0\n\n\u03b1ti+1 2\n.\nej\u22121\n\u03b1ti+1 2\nej+1\n\u03b1ti+1 2\n.\nti+1 2ek\u22121\n\u03b1\n\ne0\n\n. \u03b1tk\u22121 2\n.\n.\nej\u22121\n. \u03b1tk\u22121 2\nej+1\n. \u03b1tk\u22121 2\n.\n.\ntk\u22121 2ek\u22121\n. \u03b1\n\n6= 0.\n\n(2)\n\nProof The determinants AF j and AEd differ exclusively in the jth-row.\nd\nExpanding both determinants along the jth-row, we can write AF j and AEd in\nd\nterms of the k minors of order (k-1) of the form (3.1). The fact that AEd 6= 0\n(see Theorem 1) completes the proof.\nThe following theorem is the theoretical basis of the LB-algorithm.\nTheorem 2\nLet Ed be any fixed-distance coset and j \u2208 {0, 1, ..., k \u2212 1}. If for some\nj\nset of jth-quasi f-d cosets {Fd,n\n} there exists at least a fixed-distance coset Ed\u2032\nj\nj\n} cannot be simultaneously\nsuch that Ed\u2032 \u2282 OR[{Fd,n }], then the cosets of {Fd,n\ndegenerate.\nj\nProof We proceed by contradiction. We assume that the cosets of {Fd,n\n}\nare simultaneously degenerate. This simultaneous degeneration is equivalent to\nthe existence of a set of homogeneous linear systems (associated with each determinant AF j ) with nontrivial solutions. All these systems have (k-1) equations\nd,n\nin common. Furthermore, due to Lemma 1, the solutions of each system are at\nthe same time the joint solutions to all the systems, therefore the compatibility of the general system composed of all the different equations can be easily\ndeduced. Finally, according to the starting hypothesis, the k equations associated with the determinant Ad\u2032 are among the equations of the general system.\nThis means that a compatible system has a non-compatible subsystem, which\nobviously is a contradiction.\n\n5\n\n\fThe LB-algorithm that is presented in the next section realizes the previous\nresults by means of the handling of L-bit strings.\n\n4\n\nThe LB-Algorithm\n\nIn this section, the LB-algorithm which computes a lower bound on the global\nlinear complexity is presented in detail. The LB-algorithm is based on the\nprevious theorems and corollaries. For every set of N quasi f-d cosets, the\nalgorithm determines:\n(a) the maximum number m of cosets which can be simultaneously degenerate.\n(b) the contribution to the global linear complexity of the (N-m) remaining\ncosets which are nondegenerate.\nThe LB-algorithm converts the linear system (2.1) into an L-bit string according to the following simple rule: the presence of the ith-equation 0 =\nei\nei\nei\nd0 \u03b1t0 2 + d1 \u03b1t1 2 + * * * + dk\u22121 \u03b1tk\u22121 2 in the system implies a 1 in the Lbit string at the position indicated by ei . Note that, due to the particular form\nof the linear system, squaring the equations of the system (2.1) is equivalent to\na left cyclic rotation in the L-bit string associated (Fig. 1). This fact will be\nused widely throughout the algorithm.\n\n4.1\n\nBit Wise Logic Operations\n\nThe LB-algorithm realizes basically three bit wise logic operations AND, OR\nand exclusive-OR (denoted by XOR). An interpretation of each operation is\npresented in the following.\nGiven two homogeneous linear systems and their corresponding binary strings,\nthe AND operation between both strings gives rise to a new homogeneous linear\nsystem whose equations are common to both systems (Fig. 2 a)). In the algorithm the logic operation AND will be used to check the presence of a particular\nsubsystem inside a general system.\nThe XOR operation of two L-bit strings associated with both linear systems\nof the form (2.1) gives rise to a new system whose equations belong exclusively\nto one of the previous linear systems (Fig. 2 b)). In the following algorithm the\nlogic operation XOR is used to check if a particular coset has been previously\nstudied.\nFinally, the OR operation among several L-bit strings gives rise to a macrosystem which includes all the equations corresponding to the systems (Fig. 2 c)).\nThroughout the algorithm this logic operation is used as a fundamental tool to\ncheck the basic idea of this work: the simultaneous degeneration of the quasi\nf-d cosets.\nIt is clear that the LB-algorithm is based exclusively on the handling of L-bit\nstrings instead of solving linear systems or computing determinants in a finite\n\n6\n\n\ffield.\n\n4.2\n\nNotation\n\nThe following notation is used throughout the LB-algorithm.\nFDC(i) (i=1,2,...,NL ) denotes the L-bit string corresponding to the ith-fixeddistance coset Edi .\n\u2206 is a lower bound on the global linear complexity.\nMASK(i,j) (j=1,2,...,k-1) denotes the L-bit string obtained from FDC(i) by\nreplacing the jth-1 by a 0. Remark that MASK(i,0) is a shifted version of\nMASK(i,k-1).\nC(i,j) denotes a set of L-bit strings associated with the jth-quasi f-d cosets\n{Fdji ,n }. Any L-bit string in C(i,j) previously considered must be eliminated. In\norder to detect them we operate every L-bit string in C(i,j) as follows:\n1. by means of AND operations with every FDC(i) (i=1,2,...,NL ) to discover\nthe fixed distance cosets\n2. by means of XOR operations with every previous MASK. Those cosets\nthat produce a resulting string with a unique 1 must be eliminated from C(i,j)\nas they have been already analysed in previous sets {Fdji ,n }.\nm is a decreasing counter whose first value (denoted by M) is the number of\nL-bit strings in C(i,j) \u0001after eliminations.\na(n) (n=1,2,..., M\nm ) denotes each possible M-bit string of weight m.\nVOR denotes the string resulting from an OR operation among those m\ncosets of C(i,j) indicated by the positions of the 1's in a(n).\nVL is a binary variable whose value depends on the AND operation between\nVOR and each FDC(i).\n\n4.3\n\nAlgorithm\n\nThe LB-algorithm INPUTS are L (LFSR's length) and k (order of the function)\nwith 2< k< L-2, and its OUTPUT is the lower bound of the global linear\ncomplexity \u2206.\nFig. 3 shows the LB-algorithm whose Steps 1 and 2 can be described as\nfollows.\nStep 1\nCompute the NL values of d.\nGenerate the FDC(i) (i=1,2,...,NL ).\nInitialize the lower bound \u2206 = L * NL .\nStep 2\nGenerate MASK(i,j) (i=1,2,...,NL ; j=1,2,...,k-1).\nInitialize the counter m=L-k.\nGenerate the set C(i,j).\n\n7\n\n\fRealize the AND between every FDC(l) (l=1,2,...,NL ) and every coset of\nC(i,j). If any result equals FDC(l), then the corresponding coset in C(i,j) is\neliminated and m=m-1.\nRealize the XOR between every MASK(o,p) (o=1,2,...,i-1, p=1,2,...,k-1; o=i,\np=1,2,...,j-1) and every coset of C(i,j). If any result has a unique 1, then the\ncorresponding coset in C(i,j) is eliminated and m=m-1.\n\n4.4\n\nExample\n\nFig. 4 shows the results obtained from the LB-algorithm for L=11 and k=6.\nSince the LB-algorithm is independent of the specific function and minimal\npolynomial of the LFSR, the lower bound obtained is valid for any arbitrary\nnonlinear function with a unique term of maximum order 6 and for any maximallength LFSR of length 11.\nIf we had used the root presence test to obtain the same result, we would have\nhad to compute (for each function of order 6 and each maximal-length LFSR\nof length 11) at least 22 determinants of order 6 in GF (211 ). This would have\nimplied more than a million arithmetic operations in a finite field, [4]. According\nto the present algorithm, the numerical result obtained is independent of the\nfunction and the maximal-length LFSR.\n\n4.5\n\nDiscussion\n\nThe main facts concerning the performance of the algorithm are summarized in\nthis section.\nThe LB-algorithm is divided into two stages. The first stage includes the\ngeneration and 'debugger' of the cosets to be analysed. The second stage is\nconcerned with the simultaneous degenerations of the different sets of cosets. In\nthe second stage a 'sweep' of some sets of cosets is carried out, which permits\ntheir use later on the algorithm.\nRegarding the required memory, note that only the L-bit strings MASK(i,j)\n(but not the cosets C(i,j)) have to be stored. This means keeping one out of\n(L-k) cosets analysed.\nIn order to handle the cosets of C(i,j), the more suitable structure of information is a list. This structure seems also adequate to select, through the\ncodification a(n), the cosets involved in each OR operation. On the other hand,\nin order to generate the successive strings a(n), backtracking can be used.\nIt can also be determined that the LB-algorithm has a maximum computational complexity of order O(2L\u2212k ), where L denotes the length of the LFSR and\nk is the order of the function. In order to estimate this value, it has been assumed\nthe 'worst possible\ncase',\na number of logic operations given by\n\u0001\n\u0001 which involves\n\u0001\nM\nM\nM\nL\u2212k\nNL (k \u2212 1)[ M\n+\n+\n*\n*\n*\n+\n]\n=\nN\n.\nL (k \u2212 1)(2 \u2212 M ) \u2264 NL (k \u2212 1)2\nM\nM\u22121\n2\nHowever, from the experimental results it can be deduced that the running\ntime of the LB-algorithm depends on the real number of bit wise operations\n8\n\n\famong the different L-bit strings, which is much less. As an illustrative example we can say \u0001that for\u0001 L=53\u0001 and k=27\nthe\noperations is only\n\u0001\n\u0001 number of logic\n25\n25\n25\n25\n26\nN53 (27 \u2212 1)[ 25\n+\n+\n+\n+\n]\n\u2264\nN\n*\n26\n*\n2\n.\n53\n25\n24\n23\n22\n21\nFurthermore the following three considerations must be taken into account.\nFirst, for each pair of values (L,k), the LB-algorithm has to be used only once.\nSecond, it will be used only with relatively small inputs. And third, a high\nbound obtained for specific values of L and k will encourage the designer of\nrunning-key generators to use nonlinear filter with a unique term of maximum\norder k applied to any maximal-length LFSR of length L.\nThe LB-algorithm has been implemented on a DEC work-station and several\nexperiments over values of L primes have been carried out to evaluate it. The\neffect of this choice is twofold. On the one hand, it simplifies the computation\nof the NL values of d in Step 1, and on the other hand, the more fixed-distance\ncosets there are the higher bounds the algorithm computes.\nThe following table shows some experimental results.\nL\nk\nBound\n\n11\n17\n23\n29\n37\n43\n47\n53\n6\n9\n12\n15\n19\n22\n24\n27\n242 3128 8349 22330 47952 75852 99405 143206\nTable 1: Lower bounds on the global linear complexity\n\nAccording to the values shown, the LB-algorithm is believed to be quite\nefficient to lowerbound the global linear complexity of the filtered sequences.\nThe growth of the bound observed can be approximated by the curve of Fig 5,\nwhich has been obtained through regression analysis for the linear model. This\napproximation let us estimate a bound above 500000 for L=89.\nIn conclusion, the main result deduced from the LB-algorithm is reliability\nfor the nonlinear filter. Thanks to it a designer of nonlinear filter generators\ncould carry out the following steps:\n1.- Find values of L and k that produce a high lower bound,\n2.- Choose any nonlinear function of a smaller order than k,\n3.- Add it to any kth-order product and\n4.- Apply the resulting nonlinear function to any maximal-length LFSR of\nlength L.\nIn this way the designer would obtain a sequence with a guaranteed large\nglobal linear complexity.\n\n5\n\nConclusions\n\nOur research has highlighted the problem of the global linear complexity of\nthe nonlinear filter generators. In addition, a new algorithm, the so-called LBalgorithm, to lowerbound the global linear complexity has been presented.\nThis proposal differs from existing schemes in different aspects. Firstly,\nunlike the well-known Berlekamp-Massey's algorithm [6], we do not consider\n9\n\n\fthe digits of the output sequence but the characteristics of the nonlinear filter.\nSecondly, the proposed algorithm indeed does not require any condition on\nthe LFSR's stages involved, as do [5] and [7]. Therefore the obtained bounds\nare valid for any nonlinear function with a unique term of maximum order.\nFinally, this work is based on the handling of L-bit strings instead of computing\ndeterminants in a finite field (Rueppel's method, [8]), which seems to be much\nmore adequate for software simulation and/or hardware implementation.\nLarge lower bounds for the global linear complexity have been obtained\nfrom the LB-algorithm without imposing any restriction on the function or\nthe polynomial. This fact ensures the reliability of the nonlinear state-filter\ngenerators for cryptographic application.\nThis investigation has left as open problem the study of the remaining cosets\nthat the LB-algorithm does not analyse.\n\nReferences\n[1] A. F\u00faster-Sabater and P. Caballero-Gil, 'On the Linear Complexity of Nonlinearly Filtered PN-Sequences', Advances in Cryptology-ASIACRYPT'94,\nLecture Notes in Computer Science Vol. 917, Springer-Verlag, 1995.\n[2] E.J. Groth, 'Generation of Binary Sequences with Controllable Complexity',\nIEEE Trans. Inform. Theory, Vol. IT-17, May 1971.\n[3] E.L. Key, \"An Analysis of the Structure and Complexity of Nonlinear Binary\nSequence Generators\", IEEE Trans. Inform. Theory, Vol. IT-22, pp. 732-736,\nNov. 1976.\n[4] D.E. Knuth, \"The Art of Computer Programming, Vol. 2: Seminumerical\nAlgorithms\", Addison-Wesley, 1981.\n[5] P.V. Kumar and R.A. Scholtz, \"Bounds on the Linear Span of Bent Sequences\", IEEE Transactions on Information Theory, Vol. IT-29, pp. 854862, Nov. 1983.\n[6] J.L. Massey, \"Shift-Register Synthesis and BCH Decoding\", IEEE Transactions on Information Theory, Vol. IT-15, pp. 122-127, Jan. 1969.\n[7] J.L. Massey and S. Serconek, \"A Fourier Transform Approach to the Linear\nComplexity of Nonlinearly Filtered Sequences\", Advances in CryptologyCRYPTO'94, Lecture Notes in Computer Science Vol. 839, pp. 332-340,\nSpringer-Verlag, 1994.\n[8] R.A. Rueppel, \"Analysis and Design of Stream Ciphers\", Springer-Verlag,\nNew York, 1986.\n\n10\n\n\f[9] G.J. Simmons (ed.), 'Contemporary Cryptology: The Science of Information\nIntegrity', IEEE Press, 1991.\n\n11\n\n\f"}