{"id": "http://arxiv.org/abs/1110.4746v5", "guidislink": true, "updated": "2014-04-22T08:30:16Z", "updated_parsed": [2014, 4, 22, 8, 30, 16, 1, 112, 0], "published": "2011-10-21T10:28:15Z", "published_parsed": [2011, 10, 21, 10, 28, 15, 4, 294, 0], "title": "QoS Aware and Survivable Network Design for Planned Wireless Sensor\n  Networks", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1110.2073%2C1110.0557%2C1110.3518%2C1110.5842%2C1110.1349%2C1110.5884%2C1110.4933%2C1110.2231%2C1110.3762%2C1110.3843%2C1110.2490%2C1110.0626%2C1110.1461%2C1110.1539%2C1110.0332%2C1110.1969%2C1110.0489%2C1110.4907%2C1110.5590%2C1110.5270%2C1110.4816%2C1110.5989%2C1110.5380%2C1110.3177%2C1110.5530%2C1110.4763%2C1110.6589%2C1110.5223%2C1110.5985%2C1110.5936%2C1110.0827%2C1110.3150%2C1110.0978%2C1110.6230%2C1110.6920%2C1110.0307%2C1110.2493%2C1110.3622%2C1110.6681%2C1110.5538%2C1110.3773%2C1110.1976%2C1110.5726%2C1110.6912%2C1110.2275%2C1110.1071%2C1110.2541%2C1110.5642%2C1110.1807%2C1110.6168%2C1110.5567%2C1110.0944%2C1110.1598%2C1110.1649%2C1110.2506%2C1110.2689%2C1110.4548%2C1110.2436%2C1110.3332%2C1110.1034%2C1110.1888%2C1110.3748%2C1110.2042%2C1110.3904%2C1110.5580%2C1110.2690%2C1110.6852%2C1110.3778%2C1110.4960%2C1110.1084%2C1110.6061%2C1110.5714%2C1110.5631%2C1110.4589%2C1110.4859%2C1110.6654%2C1110.4746%2C1110.5755%2C1110.3021%2C1110.1583%2C1110.4385%2C1110.0505%2C1110.4103%2C1110.6105%2C1110.4604%2C1110.3266%2C1110.1493%2C1110.6113%2C1110.1551%2C1110.1600%2C1110.4199%2C1110.4632%2C1110.3037%2C1110.5169%2C1110.2176%2C1110.0863%2C1110.5317%2C1110.2663%2C1110.3465%2C1110.5762%2C1110.4096&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "QoS Aware and Survivable Network Design for Planned Wireless Sensor\n  Networks"}, "summary": "We study the problem of wireless sensor network design by deploying a minimum\nnumber of additional relay nodes (to minimize network cost) at a subset of\ngiven potential relay locations, in order to convey the data from already\nexisting sensor nodes (hereafter called source nodes) to a Base Station, while\nmeeting a certain specified hop count bound (the hop count bound is chosen to\nensure a pre-determined probability of the data being delivered to the BS\nwithin a given maximum delay). We study two variations of the problem.\n  First we sudy the problem of guaranteed QoS connected network design, where\nthe objective is to have at least one path from each source to the BS with the\nspecified hop count bound. We show that the problem is NP-Hard. For a problem\nin which the number of existing sensor nodes and potential relay locations is\nn, we propose an O(n) approximation algorithm of polynomial time complexity.\nResults show that the algorithm performs efficiently (in over 90% of the tested\nscenarios, it gave solutions that were either optimal or were worse than\noptimal by just one relay) in various randomly generated network scenarios.\n  Next, we study the problem of survivable network design with guaranteed QoS,\ni.e, the requirement is to have at least k > 1 node disjoint hop constrained\npaths from each source to the BS. We show that the problem is NP-Hard. We also\nshow that the problem of finding a feasible solution to this optimization\nproblem is NP-Complete. We propose two polynomial time heuristics for this\nproblem, and compare their performance on various randomly generated network\nscenarios.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1110.2073%2C1110.0557%2C1110.3518%2C1110.5842%2C1110.1349%2C1110.5884%2C1110.4933%2C1110.2231%2C1110.3762%2C1110.3843%2C1110.2490%2C1110.0626%2C1110.1461%2C1110.1539%2C1110.0332%2C1110.1969%2C1110.0489%2C1110.4907%2C1110.5590%2C1110.5270%2C1110.4816%2C1110.5989%2C1110.5380%2C1110.3177%2C1110.5530%2C1110.4763%2C1110.6589%2C1110.5223%2C1110.5985%2C1110.5936%2C1110.0827%2C1110.3150%2C1110.0978%2C1110.6230%2C1110.6920%2C1110.0307%2C1110.2493%2C1110.3622%2C1110.6681%2C1110.5538%2C1110.3773%2C1110.1976%2C1110.5726%2C1110.6912%2C1110.2275%2C1110.1071%2C1110.2541%2C1110.5642%2C1110.1807%2C1110.6168%2C1110.5567%2C1110.0944%2C1110.1598%2C1110.1649%2C1110.2506%2C1110.2689%2C1110.4548%2C1110.2436%2C1110.3332%2C1110.1034%2C1110.1888%2C1110.3748%2C1110.2042%2C1110.3904%2C1110.5580%2C1110.2690%2C1110.6852%2C1110.3778%2C1110.4960%2C1110.1084%2C1110.6061%2C1110.5714%2C1110.5631%2C1110.4589%2C1110.4859%2C1110.6654%2C1110.4746%2C1110.5755%2C1110.3021%2C1110.1583%2C1110.4385%2C1110.0505%2C1110.4103%2C1110.6105%2C1110.4604%2C1110.3266%2C1110.1493%2C1110.6113%2C1110.1551%2C1110.1600%2C1110.4199%2C1110.4632%2C1110.3037%2C1110.5169%2C1110.2176%2C1110.0863%2C1110.5317%2C1110.2663%2C1110.3465%2C1110.5762%2C1110.4096&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We study the problem of wireless sensor network design by deploying a minimum\nnumber of additional relay nodes (to minimize network cost) at a subset of\ngiven potential relay locations, in order to convey the data from already\nexisting sensor nodes (hereafter called source nodes) to a Base Station, while\nmeeting a certain specified hop count bound (the hop count bound is chosen to\nensure a pre-determined probability of the data being delivered to the BS\nwithin a given maximum delay). We study two variations of the problem.\n  First we sudy the problem of guaranteed QoS connected network design, where\nthe objective is to have at least one path from each source to the BS with the\nspecified hop count bound. We show that the problem is NP-Hard. For a problem\nin which the number of existing sensor nodes and potential relay locations is\nn, we propose an O(n) approximation algorithm of polynomial time complexity.\nResults show that the algorithm performs efficiently (in over 90% of the tested\nscenarios, it gave solutions that were either optimal or were worse than\noptimal by just one relay) in various randomly generated network scenarios.\n  Next, we study the problem of survivable network design with guaranteed QoS,\ni.e, the requirement is to have at least k > 1 node disjoint hop constrained\npaths from each source to the BS. We show that the problem is NP-Hard. We also\nshow that the problem of finding a feasible solution to this optimization\nproblem is NP-Complete. We propose two polynomial time heuristics for this\nproblem, and compare their performance on various randomly generated network\nscenarios."}, "authors": ["Abhijit Bhattacharya", "Anurag Kumar"], "author_detail": {"name": "Anurag Kumar"}, "author": "Anurag Kumar", "links": [{"href": "http://arxiv.org/abs/1110.4746v5", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1110.4746v5", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.NI", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.NI", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1110.4746v5", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1110.4746v5", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "1\n\nQoS Aware and Survivable Network Design for\nPlanned Wireless Sensor Networks\nAbhijit Bhattacharya and Anurag Kumar\nDept. of Electrical Communication Engineering\nIndian Institute of Science, Bangalore, 560012, India\nemail: abhijit@ece.iisc.ernet.in, anurag@ece.iisc.ernet.in\n\narXiv:1110.4746v5 [cs.NI] 22 Apr 2014\n\nAbstract\nWe study the problem of wireless sensor network design by deploying a minimum number of additional relay\nnodes at a subset of given potential relay locations, in order to convey the data from existing sensor nodes (hereafter\ncalled source nodes) to a Base Station(BS), while meeting a quality of service (QoS) objective specified as a hop\ncount bound. The hop count bound suffices to ensure a certain probability of the data being delivered to the BS within\na given maximum delay under the so-called \"lone packet\" traffic model. We study two variations of the problem.\nFirst, we study the problem of guaranteed QoS, connected network design, where the objective is to have at\nleast one path from each source to the BS with the specified hop count bound. We observe that the problem is\nNP-Hard. For a problem in which the number of existing sensor nodes and potential relay locations is n, we propose\nan O(n) approximation algorithm of polynomial time complexity. Results show that the algorithm performs efficiently\nin various randomly generated network scenarios; in over 90% of the tested scenarios, it gave solutions that were\neither optimal or were worse than optimal by just one relay. Under a certain stochastic setting, we then obtain an\nupper bound on the average case approximation ratio of a class of algorithms (including the proposed algorithm) for\nthis problem as a function of the number of source nodes, and the hop count bound. Experimental results show that\nthe actual performance of the proposed algorithm is much better than the analytical upper bound. In carrying out this\nstudy of the algorithm, for small problems the optimal solutions are obtained by an exhaustive search, whereas for\nlarge problems we obtain a lower bound to the optimal value via an ILP formulation (involving so called \"node cut\"\nbased inequalities) whose LP relaxation has a polynomial number of constraints (unlike usual path based formulation\nwhich has exponential number of constraints).\nNext, we study the problem of survivable network design with guaranteed QoS, i.e., the requirement is to have\nat least k > 1 node disjoint, hop constrained paths from each source to the BS. We observe that the problem is NPHard, and that the problem of finding a feasible solution to this optimization problem is NP-Complete. We propose a\npolynomial time heuristic for this problem. Finally, we study its performance on several randomly generated network\nscenarios, and provide an extensive analysis of these results. Similar in spirit to the one connectivity problem, we\nobtain, under a certain stochastic setting, an upper bound on the average case approximation ratio of a class of\nalgorithms (including the proposed algorithm) for the hop constrained, survivable network design problem.\n\nI. Introduction\nLarge industrial establishments such as refineries, power plants, and electric power distribution stations, typically\nhave a large number of sensors distributed over distances of 100s of meters from the control center. Individual wires\ncarry the sensor readings to the control center. Recently there has been increasing interest in replacing these wireline\nnetworks with wireless packet networks ([1], [2]). A similar problem arises in an intrusion detection application\nusing a fence of passive infrared (PIR) sensors [3], where the event sensed by several sensors has to be conveyed\nto a Base Station (BS) quickly and reliably.\nThe communication range of the sensing nodes is typically a few tens of meters (depending on the RF propagation\ncharacteristics of the deployment region). Therefore, usually multi-hop communication is needed to transmit the\nsensed data to the BS. The problem then is to design a multi-hop wireless mesh network with minimum deployment\ncost, i.e., minimum number of additional relays, so as to communicate from each sensing (source) node to a central\nnode, which we will call the BS (we shall use the terms BS and sink interchangebly), while meeting certain\nperformance objectives such as a delay bound, and packet delivery probability.\nThe relay placement problem can be broadly classified into two classes of problems. One is the unconstrained\nrelay placement problem, where the relay locations can be anywhere in the 2-dimensional region. In most practical\napplications, however, due to the presence of obstacles to radio propagation (e.g., a firewall, a large machine, or a\nbuilding), or due to taboo regions (e.g., a pond or a ditch), we cannot place relay nodes anywhere in the region, but\nonly at certain designated locations. This leads to the problem of constrained relay placement in which the relays\nare constrained to be placed at certain potential relay locations (see Figure 1 for a depiction of the problem). In\n\n\f2\nPotential Links\n\nSensor Nodes\n(also serve as relays)\n\nUndesirable Link\n\nSink\n\nPossible Relay Node Locations\n\nFig. 1. The constrained relay placement problem; circles indicate sources, and the hexagons indicate potential relay locations. The edges denote\nthe useful links between the nodes.\nHop Count = 5, Packet error rate of 0.05 and Packet length of 90 bytes\n\n1\n\nCDF of longest path delay\n\n0.9\n0.8\n0.7\n0.6\n0.5\n0.4\n0.3\n0.2\n0.1\n0\n0\n\n5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80\nDelay in ms\n\nFig. 2. CDF of end-to-end delay along a 5-hop path in a beaconless IEEE 802.15.4 network, assuming packet error rate of 0.05, and packet\nlength of 90 bytes. The end-to-end delay does not include the fixed processing delay at each node.\n\neither of these problems, relays would have to be placed so that as few of them as possible are used while meeting\nperformance objectives such as an upper bound on packet delivery delay, or a lower bound on packet delivery\nprobability, or topological objectives such as the number of redundant paths.\nAs depicted in Figure 1, the source locations and the potential relay locations are specified. Only certain links are\npermitted; this could be because some links could be too long, leading to high bit error rate and hence large packet\ndelay, or due to an obstacle, e.g., a firewall, or a building. The problem is to obtain a subnetwork that connects the\nsource nodes to the base station with the requirement that\n1) A minimum number of relay nodes is used.\n2) There are at least k node disjoint paths from each source node to the BS.\n3) The maximum delay on any path is bounded by a given value dmax , and the packet delivery probability (the\nprobability of delivering a packet within the delay bound) on any path is \u2265 pdel .\nTo the best of our knowledge, this problem of QoS constrained, cost optimal network design has not yet been\nsolved; we shall discuss the relevant literature in more detail in Section IV-D. In this paper, we address this problem\nfor the case in which (a) the nodes use the CSMA/CA Medium Access Control (as standardized in IEEE 802.15.4\n[4]), and (b) the traffic from the source nodes is such that at any point of time only one measurement packet flows\nfrom a source in the network to the base station. We call this the \"lone packet traffic model\", which is realistic\nfor many applications where the time between successive measurements being taken is sufficiently long so that\nthe measurements can be staggered so as not to occupy the medium at the same time. For example, see Figure 2,\nwhich depicts the cumulative distribution function (CDF) of end-to-end delay along a 5-hop path in a beaconless\nIEEE 802.15.4 network. The CDF has been obtained as a convolution of per hop delay distributions which are\nobtained using the backoff parameters given in the standard [4].\nAlso, from Figure 2, we see that the end-to-end delay is \u2264 69 msec (without considering the node processing\ndelay) with probability 0.99. The per hop processing delay was measured to be 15.48 msec [5, p. 31, Section\n2.2.5]. Thus, the total end-to-end delay over the 5-hop path turns out to be \u2264 146.4 msec with probability 0.99.\nThis suggests that, even if such a network is designed based on the lone packet model, it will support a positive\naggregate packet arrival rate, while meeting a target delivery delay objective with a high probability. Indeed, our\n\n\f3\n\nanalytical modeling of such networks (see [6]) has shown that the arrival rate of a packet every few seconds (e.g., 5\nto 10 seconds) from each source can be sustained. Such slow measurement rates are typical of so-called condition\nmonitoring/industrial telemetry applications [7], [8].\nMoreover, note that for a design (network) to satisfy the QoS objectives for a given positive arrival rate (continuous\ntraffic), it is necessary that the network satisfies the QoS objectives under zero/light traffic load, i.e., the \"lone packet\"\nmodel (for a more formal proof of this fact, see Section II). As we shall see in subsequent sections, even under\nthis simplified model of light traffic load, the problem of QoS constrained network design is computationally hard,\nand it does not seem to have been addressed before (we provide a literature survey in Section IV-D). We cannot\nhope to solve the general problem of QoS aware network design for continuous traffic unless we have a reasonably\ngood solution to the more basic problem of \"lone packet\" based network design, as well as a good analytical tool\nto model accurately, the stochastic interaction between the nodes in the network under traffic in which multiple\nlinks contend for the medium using CSMA/CA. A fast and accurate approximate performance analysis of multihop\nbeaconless CSMA networks has been developed in [6]. In our current paper, we address the basic problem of QoS\naware network design under \"lone packet\" model, as a step towards our future work of exploiting an analysis, such\nas the one in [6], to augment the \"lone packet\" based design to one that meets the QoS for traffic in which several\npackets can occupy the network at the same time. Design of multihop beaconless CSMA networks under given\npositive packet arrival rates from the sources, by combining the \"lone packet\" based design with the analytical tool\ndeveloped in [6], is a topic of our current research.\nNote that even if the traffic is infrequent, the end user may still like to constrain the delay between when a\nmeasurement packet is generated and when the packet is received. Moreover, the links in a wireless sensor network\nare typically low power, lossy links, where packet loss probabilities of 1% to 5% can be expected even on good\nlinks. Thus, the designs need to be constrained even for a lone packet model to achieve a satisfactory packet\ndelivery probability. In applications, the measurements are currently conveyed to the BS via a wireline network.\nWhile replacing the wireline network (which is expensive to install and maintain) with a wireless mesh network,\nwe aim to constrain the end-to-end performance achieved by the wireless network by imposing a hop count bound\nof hmax between each source and the BS. One possible approach of deriving such a hop count bound is presented\nin Section III.\nGiven a graph with feasible links between the potential locations and the source nodes, and a hop constraint,\nhmax , the problem we address is to eliminate as many relays as possible from this graph so as to leave a graph with\nat least k paths, each of at most hmax hops, between each source and the BS. We consider the case k = 1 first, and\nthen the case k > 1. We provide a survey of related literature after a formal statement of the problem in Section IV.\nThe rest of the paper is organized as follows: in Section IV, we describe the problem formulations for one\nconnected, and k-connected hop constrained network design, show that the problems are NP-Hard, and present a\nbrief survey of closely related literature. In Section V, we propose a polynomial time algorithm (SPTiRP) for one\nconnected network design, and provide a complete analysis of the algorithm. In particular, we provide a worst case\napproximation guarantee of the algorithm for arbitrary potential relay locations and source locations. We also derive\na sufficient condition on the number and distribution of potential relay locations to ensure feasibility of the problem\nwith high probability. Under such a stochastic setting, we provide an upper bound on the average case performance\nof the proposed algorithm. In Section VI, we propose a node-cut based ILP formulation for the one-connected hop\nconstrained network design problem, whose LP relaxation has a polynomial number of constraints (unlike usual\npath based formulation which has exponential number of constraints). The LP relaxation can be useful in obtaining a\nlower bound on the optimal solution for problems of prohibitively large size, where an exhaustive enumeration of all\npossible solutions is impractical. In Section VII, we provide extensive numerical results for the SPTiRP algorithm\napplied to a set of random scenarios. Section VIII provides packet level simulation results (using Qualnet, and\nassuming IEEE 802.15.4 CSMA/CA Medium Access Control) for the designs obtained using our algorithm to\nquantify the performance limits of the designs under \"positive\" traffic arrival rates. In Section IX, we study the\ncomplexity involved in obtaining a feasible solution for the hop-constrained k-connectivity problem. In Section X,\nwe propose a polynomial time algorithm (E-SPTiRP) for solving the k-connectivity problem, and provide analysis\nfor the time complexity and approximation guarantee of the algorithm. In particular, for a subclass of problems\nwith arbitrary potential locations and source locations, we provide a worst case approximation guarantee of the\nproposed algorithm. Similar in spirit to the one-connectivity problem, we then derive a sufficient condition on the\nnumber and distribution of potential locations to ensure feasibility of the hop constrained k-connectivity problem\nwith high probability. Under such a stochastic setting, we obtain an upper bound on the average case performance\nof the E-SPTiRP algorithm. In Section XI, we provide detailed numerical results for the algorithm applied to a set\n\n\f4\n\nof random network scenarios. Finally, we conclude the paper in Section XII.\nII. Comparison of Lone-Packet Model and Positive-Flow Model\nIn developing algorithms for QoS constrained network design, it is fairly intuitive to assume that the performance\nof the network under the lone-packet model, i.e., where packets enter and leave the system one at a time, would\nbe better than that under a positive-flow model, where there is a positive arrival rate at each source node, and\npackets can co-exist in the network, leading to contention. It is well known, however, that in CSMA/CA networks,\nin general, the performance is not monotone with the arrival rates (see, e.g., [9]); hence, the preceding statement\nabout the lone-packet traffic model needs to made with care. We provide here a simple proof based on a sample\npath argument. In doing so, we also make the notions of lone-packet and positive-flow models more formal.\nA. Lone Packet vs. Positive Arrival Rate: A Sample Path Argument\nConsider an arbitrary tree network with a single sink, where each source q, 1 \u2264 q \u2264 m, has a route, cq =\n{q, vq1 , . . . , vq(hq \u22121) , 0}, with hop count hq to the sink (the sink node is denoted by 0). Let perr be the packet error rate\non any link in the network. Note that even if we consider a different packet error rate for every link, the following\nargument will carry through with little modification. But to convey the basic concept, we are dealing with a simpler\nversion here. Further, we assume that the nodes use the CSMA/CA MAC, as standardised by IEEE 802.15.4[4] (in\nfact, the argument holds for any MAC, with appropriate changes in the construction developed in the proof).\nWe consider two different stochastic processes, namely, a lone packet process (corresponding to the lone packet\ntraffic model), and a positive flow process (corresponding to a positive traffic arrival rate vector \u03bb \u2208 Rm ). Let \u03a91\nand \u03a92 denote the sample spaces associated with the lone packet process, and the positive flow process respectively.\nWe define, for all \u03c9 \u2208 \u03a91 ,\n(\n1 if the kth packet on route cq in the lone-packet model is delivered\n(q)\nD0,k (\u03c9) =\n0 if the kth packet on route cq in the lone-packet model is not delivered\nSimilarly, define, for all \u03c9 \u2208 \u03a92 ,\n(\n1 if the kth packet on route cq in the positive-flow model is delivered\n(q)\nD+,k (\u03c9) =\n0 if the kth packet on route cq in the positive-flow model is not delivered\nThen, we can define the following quantities:\nq\n\npdel (0) = lim\n\nk\u2192\u221e\n\nK\n1 X (q)\nD\nK k=1 0,k\n\nwhich is the long term fraction of packets delivered on route cq , 1 \u2264 q \u2264 m, under lone-packet model.\nAnd,\nK\n1 X (q)\nD+,k\npqdel (\u03bb) = lim\nk\u2192\u221e K\nk=1\n\n(1)\n\n(2)\n\nwhich is the long term fraction of packets delivered on route cq , 1 \u2264 q \u2264 m, for a positive arrival rate vector\n\u03bb \u2208 Rm .\nProposition 1.\npqdel (0) \u2265 pqdel (\u03bb)\n\n\u2200\u03bb > 0, \u2200q \u2208 {1, . . . , m}\n\n(3)\n\nProof: We shall prove via a sample path argument. We aim to couple the two processes, namely, the lone\npacket process, and the positive flow process onto a common probability space as follows.\nLet n be the maximum number of attempts of a packet by a transmitter before the packet is discarded (n is a\nparameter of the underlying CSMA protocol). For each route j, 1 \u2264 j \u2264 m, let {e(kj) , k \u2265 1} be a realisation of n \u00d7 h j\nBernoulli random sequences, each with success probability 1 \u2212 perr ; as usual, a 1 in these sequences denotes that the\ncorresponding packet attempt is a success. Using this sequence of i.i.d coin tosses, we can couple the two different\nstochastic processes, namely, the lone-packet process, and the positive flow process (corresponding to \u03bb > 0) onto\na common sample space as follows.\nFor each process, consider the kth packet arriving on route c j ; for this packet, use the element (which is a\nmatrix) e(kj) of the above coin tossing sequence to decide whether the packet encounters a link error, or not, on\n\n\f5\n\nany transmission attempt on any hop. Once the packet is delivered successfully, or discarded, we discard the rest\n( j)\nof the matrix ek , and use the next element in the sequence for the next packet arriving on c j . For example, if\n( j)\nek (t, h) = 1, the tth transmission attempt (if it occurs) on the hth link of the kth packet on route c j is successful, and\n( j)\nif ek (t, h) = 0, the attempt encounters a link error. If the packet is delivered, or discarded before the tth attempt,\nor the hth hop, then e(kj) (t, h) is abandoned without use.\nThus, the link errors seen by the kth packet, k \u2265 1, on route c j , 1 \u2264 j \u2264 m, are the same in both the processes.\nWe define the two processes (the one with lone-packet traffic and the one with positive arrival rates) on the same\nsample space \u03a9 with sample points \u03c9 constructed as follows:\n(m)\n\u03c9 = {({a(1)\nk , k \u2265 1}, . . . , {ak , k \u2265 1}),\n(N)\n({b(1)\nk , k \u2265 1}, . . . , {bk , k \u2265 1}),\n\n(m)\n({e(1)\nk , k \u2265 1}, . . . , {ek , k \u2265 1}), {rl , l \u2265 1}}\n\nwhere,\nth\na(i)\nk \u2208 R+ : k interarrival time at source i\n( j)\nB\nbk \u2208 R+ : vector of backoff durations of the kth packet arriving at the jth node, 1 \u2264 j \u2264 N; B is the\nmaximum number of CCA failures before a packet is discarded at a node\ne(kj) \u2208 {0, 1}n\u00d7h j : link error indication matrix for kth packet arriving on route c j\nrl \u2208 {c1 , . . . , cm }: The source node (and hence the route) of the lth packet arriving in the network. Note that\nthis is for the lone-packet model only. The interarrival time sequence determines the sequence of routes\ntaken for the positive traffic model.\nNote that given such an instance \u03c9 \u2208 \u03a9, we can construct the sample paths of both the lone-packet process\nand the positive-flow process. To construct the sample path of the lone-packet process, we need the components\n(N)\n(1)\n(m)\n({b(1)\nk , k \u2265 1}, . . . , {bk , k \u2265 1}), ({ek , k \u2265 1}, . . . , {ek , k \u2265 1}), and {rl , l \u2265 1} of \u03c9. In the lone-packet process, the\nth\ndeparture of the l packet triggers the arrival of the (l + 1)th packet, which takes the route rl+1 .\n(m)\nTo construct the sample path of the positive-flow process, we need to use the components ({a(1)\nk , k \u2265 1}, . . . , {ak , k \u2265\n(1)\n(N)\n(1)\n(m)\n1}), ({bk , k \u2265 1}, . . . , {bk , k \u2265 1}), and ({ek , k \u2265 1}, . . . , {ek , k \u2265 1}) of \u03c9. In this process, packets enter the system\n( j)\nat a source j, 1 \u2264 j \u2264 m, according to the sequence of interarrival times {ak , k \u2265 1}.\nWe consider the probability space (\u03a9, F , P), where F is an appropriate \u03c3-algebra, and the probability measure\nP satisfies the additional property\n\uf8fc\n\uf8f1\nK\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n1 X\n\uf8fd\n\uf8f2\n= 1 \u2200q \u2208 {1, . . . , m}\n\u03c9\n:\nlim\n1\n=\n\u03a8\n>\n0\nP\uf8f4\n\uf8f4\n{r\n=c\n}\nq\nl\nq\n\uf8f4\n\uf8f4\n\uf8fe\n\uf8f3\nK\u2192\u221e K\nl=1\n\nwhich ensures that even in the lone-packet model, an infinite number of packets arrive to each source, so that\neach route is traversed infinitely often, with probability 1.\n(q)\nNote that the random variables D(q)\n0,k and D+,k are defined on this common probability space in exactly the same\nway as they were defined earlier for the respective probability spaces of the two processes.\n(q)\nObserve that D(q)\n0,k (\u03c9) = 0 if and only if the link error indication matrix ek has an all zero column (since in\nthe lone-packet system, packets can be lost only due to link errors, and all the n transmission attempts over a link\n(q)\non the packet's route must fail before the packet is discarded). Since the same link error indication matrix, ek ,\nth\nth\nis used for the k packet on route cq in the positive-flow process, it follows that if the k packet on route cq in\nthe lone-packet model is discarded, the kth packet on route cq in the positive-flow model will also be discarded.\nMoreover, there will be additional discards in the positive-flow model due to CCA failures, and collisions, which\nare absent in the lone-packet model. It follows, therefore, that for all K, \u03c9 \u2208 \u03a9,\nK\nX\nk=1\n\n(q)\n\nD+,k (\u03c9) \u2264\n\nK\nX\n\n(q)\n\nD0,k (\u03c9)\n\nk=1\n\nHence,\n\uf8f1\n\uf8fc\nK\nK\n\uf8f4\n\uf8f4\n\uf8f4\n1 X (q)\n1 X (q) \uf8f4\n\uf8f2\n\uf8fd\nP\uf8f4\nlim\nD+,k \u2264 lim\nD0,k \uf8f4\n=1\n\uf8f4\n\uf8f4\n\uf8f3k\u2192\u221e K\n\uf8fe\nk\u2192\u221e K\nk=1\nk=1\n\n\f6\n\nRecall that by definition,\npqdel (0) = lim\n\nk\u2192\u221e\n\npqdel (\u03bb) = lim\n\nk\u2192\u221e\n\nK\n1 X (q)\nD a.s.\nK k=1 0,k\n\nK\n1 X (q)\nD a.s.\nK k=1 +,k\n\nThus, we have shown that pqdel (0) \u2265 pqdel (\u03bb), for any \u03bb > 0.\nMoreover, note that\n\uf8fc\n\uf8f1\nK\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n1 X (q)\n\uf8f2\nn hq \uf8fd\nD\n=\n(1\n\u2212\np\n)\n= 1, by strong law of large numbers\nlim\nP\uf8f4\n\uf8f4\nerr\n0,k\n\uf8f4\n\uf8f4\n\uf8fe\n\uf8f3k\u2192\u221e K\nk=1\nq\n\nHence, pdel (\u03bb) \u2264 (1 \u2212 pnerr )hq .\n\nIII. Design constraints to ensure end-to-end performance objectives\nA. Assumptions\nIn several industrial telemetry applications, the rate at which measurements are obtained from the sensors is\nlow, for example, as little as one reading per hour from each sensor. We also assume that the alarm traffic is so\ninfrequent that it does not interfere with any regular data transmission. Then, if the data transmission from the\nsensors is staggered over the hour, it can be assumed that each measurement packet flows over the network with no\ninterference from any other packet flow. Our work in this paper is concerned with this \"lone packet\" traffic model.\nWe also assume that IEEE 802.15.4 standard [4, p. 30-179, p. 640-643] is used for PHY and MAC layers.\nWe can obtain the bit error rate, \u01eb, on a link as a function (which depends on the modulation scheme) of received\nSignal to Noise Ratio (SNR), by using a formula given in the standard. Then, for a Physical layer (PHY) packet\ndata unit length of L bytes, the packet error rate (PER) on a link can be obtained as 1 \u2212 (1 \u2212 \u01eb)L . Given the PER q\non a link as a function of received SNR, we can obtain an expression for Dq (*), the c.d.f. of packet delay on the\nlink (given that the packet is not dropped), using the backoff behavior and parameters of IEEE 802.15.4 CSMA/CA\nMAC. We can also obtain the packet drop probability as a function of the link PER, and we denote this function\nby \u03b4(*).\nWe also permit slow fading of links; so the link PER can vary slowly over time, thus leading to the concept of\n\"link outage\". We say, a link is in outage if the PER of the link exceeds a target maximum link PER, designated\nby qmax (obtained as a function of the target SNR, \u03b3min ). Let us denote by pout , the maximum probability of a link\nbeing in outage.\nBefore proceeding further, we summarize for our convenience, the notations used in the development of the\nmodel.\nUser\nL\nk\ndmax\npdel\n\nrequirements:\nThe longest distance from a source to the base-station (in meters)\nThe required number of node disjoint paths between each source and the base-station\nThe maximum acceptable end-to-end delay of a packet sent by a source (packet length is assumed to be\nfixed and given)\nPacket delivery probability: the probability that a packet is not dropped and meets the delay bound\n(assuming that at least one path is available from each source to the base station).\n\nParameters obtained from the standard:\nDq (*) The cumulative distribution function of packet delay on a link with PER q, given that the packet is not\ndropped; D(h)\nq (*) denotes the h-fold convolution of Dq (*). Under the lone packet model, Dq (*) is obtained by\na simple analysis of the backoff and attempt process at a node, as defined in the IEEE 802.15.4 standard\nfor beaconless mesh networks.\nb(*) The mapping from SNR to link BER for the modulation scheme\n\u03b4(*) The mapping from PER to packet drop probability over a link. Note that even when there is no contention,\npackets could be lost due to random channel errors on links (i.e., non-zero link PER). A failed packet\ntransmission is reattempted at most three times before being dropped.\n\n\f7\n\nDesign\nPxmt\n\u03b3min\nqmax\n\nparameters:\nThe transmit power over a link (assumed here to be the same for all nodes)\nThe target SNR on a link\nThe target maximum PER on a link\n\nParameters obtained by making field measurements:\nrmax The maximum allowed length of a link on the field to meet the target SNR, and outage probability\nrequirements\npout The maximum probability of a link SNR falling below \u03b3min due to temporal variations. A link is \"bad\" if\nits outage probability is worse than pout , and \"good\", otherwise\nTo be derived:\nhmax The hop count bound on each path, required to meet the packet delivery objectives\nRemark: In practice, the value k can be chosen so that a network monitoring and repair process ensures that a\npath is available from each source to the BS at all times. The choice of k is not in the scope of our formulation,\nand would depend on how quickly the network monitoring process can detect node failures, and how rapidly the\nnetwork can be repaired. We, thus, assume that, whenever a packet needs to be delivered from a source to the BS,\nthere is a path available, and, by appropriate choice of the path parameters (the length of each link, and the number\nof hops), we ensure the delivery probability, pdel .\nB. Design Constraints from Packet Delivery Objectives\nConsider, in the final design, a path between a source i and the base-station, which is Li meters away. Suppose\nthat this path has hi hops, and the length of the jth hop on this path is ri, j , 1 \u2264 j \u2264 hi . Then we can write\nLi \u2264\n\nhi\nX\nj=1\n\nri, j \u2264 hi rmax\n\n(4)\n\nwhere the first inequality derives from the triangle inequality, and the second inequality is obvious. Since L is the\nfarthest that any source is from the base station, we can conclude that the number of hops on any path from a\nL\nsource to a sink is bounded below by rmax\n.\nFollowing a conservative approach, we take the PER on every link to be qmax (we are taking the worst case PER\non each link, and are not accounting for a lower PER on a shorter link) .\nSuppose that we have obtained a network in which there are k node independent paths from each source to the\nbase-station, and all the links on these paths are good (\"good\" in the sense explained earlier in the definition of\npout ). Consider a packet arriving at Source i, for which, by design, there are k paths, with hop counts hl , 1 \u2264 l \u2264 k,\nand suppose that at least one of these paths is available (i.e., all the nodes along that path are functioning). The\navailability of such a path will be determined by a separate route management algorithm, which is out of the scope\nof this paper. We select one of these good paths to route the packet. The path selection algorithm would incorporate\na load and energy balancing strategy. If the chosen path has h hops in it, then the probability that none of the edges\nalong the chosen path is in outage is given by\n(1 \u2212 pout )hl\nIncreasing hl makes this probability smaller. With this in mind, let us seek an hmax , by the following conservative\napproach. First, we lower bound the probability of the chosen path not being in outage by\n(1 \u2212 pout )hmax\nNow we can ensure that the packet delivery constraint is met by requiring\nmax )\n(1 \u2212 pout )hmax (1 \u2212 \u03b4(qmax ))hmax Dq(hmax\n(dmax ) \u2265 pdel\n\n(5)\n\nwhere the additional terms lower bound the probability that the packet is not dropped along the chosen path\nmax )\n((1 \u2212 \u03b4(qmax ))hmax ) and that the end-to-end delay is less than or equal to dmax (Dq(hmax\n(dmax )). Recall that we take the\nPER on each \"good\" link to be qmax . The left hand expression in (5) is decreasing as hmax increases; let hmax be the\nlargest value so that the inequality is met. Thus, we can meet the end-to-end performance objectives by imposing\na hop count constraint hmax from each source to the BS.\n\n\f8\n\nAlso, combining (4) and the hmax just obtained, we get, for every source i\nrmax \u2265\n\nL\nhmax\n\n(6)\n\nHence, under a given physical setting, we can convert the problem of network design with end-to-end delay\nbound, and guaranteed packet delivery probability to a problem of network design with end-to-end hop constraint\non each path.\nIV. The Network Design Problems\nA. The Network Design Setting\nGiven a set of source nodes or required vertices Q (including the BS) and a set of potential relay locations R\n(also called Steiner vertices), we consider a graph G = (V, E) on V = Q \u222a R with E consisting of all feasible edges.\nWe assume that CSMA/CA as defined in IEEE 802.15.4 [4] is used for multiple access.\nNote that there are several ways in which we can obtain the graph G above (i.e., the set of feasible edges E),\nkeeping in mind the end-to-end QoS objective. For example, we can impose a bound on the packet error rate (PER)\nof each link, or alternately, we can constrain the maximum allowed link length (which, in turn, affects the link\nPER). As shown in Section III, having characterized the link quality of each feasible link in the graph G, the QoS\nobjectives (dmax and pdel ) can be met by imposing a hop count bound of hmax between each source node and the\nsink.\nWe would like to point out that the graph design algorithms presented in this paper are in no way tied to the\nlink modeling approach mentioned above for obtaining the graph G, and the hop constraint hmax . The algorithms\ncan be applied as long as a graph on Q \u222a R, and a hop constraint is given, irrespective of how the graph and the\nhop constraint were obtained. The link modeling approach is just a convenient, and not necessarily unique, way of\nconverting the QoS objective into a graph design objective.\nB. Problem Formulation\n1) One Connected Network Design Problem: Given the graph G = (V, E) on V = Q \u222a R with E consisting of all\nfeasible edges (as explained in Section IV-A), and a hop constraint hmax , the problem is to extract from this graph,\na spanning tree on Q, rooted at the BS, using a minimum number of relays such that the hop count from each\nsource to the BS is \u2264 hmax . We call this the Rooted Steiner Tree-Minimum Relays-Hop Constraint (RST-MR-HC)\nproblem.\n2) k-Connected Network Design Problem: The requirement is to have at least k node disjoint and hop constrained\npaths from each source to the sink. Then, we can formulate our relay placement problem as follows:\nGiven the graph G = (V, E) on V = Q \u222a R with E consisting of all feasible edges, the problem is to extract from\nthis graph, a subgraph spanning Q, rooted at the BS, using a minimum number of relays such that each source has\nat least k node disjoint paths to the sink, and the hop count from each source to the BS on each path is \u2264 hmax . We\ncall this the Rooted Steiner Network-k Connectivity-Minimum Relays-Hop Constraint (RSNk-MR-HC) problem.\nC. Complexity of the Problems\nProposition 2. 1) The RST-MR-HC problem is NP-Hard.\n2) The RSNk-MR-HC problem is NP-Hard.\nProof:\n1) The subset of RST-MR-HC problems where the hop count bound is trivially satisfied is precisely the class of\nRST-MR [10] problems (consider, for example, all RST-MR-HC problems where |Q| + |R| = n, n being some\npositive integer, and the hop count bound is hmax = n \u2212 1. Clearly, the hop count bound is trivially satisfied\nin these problems). Thus, the RST-MR problem is a subclass of the RST-MR-HC problem. But, the RST-MR\nproblem is NP-Hard (see [10]). Hence, the RST-MR-HC problem, being a superclass of the RST-MR problem,\nis also NP-Hard [11, p. 63, Section 3.2.1].\n2) We have just proved that the problem is NP-Hard even for k =1, since that is just the RST-MR-HC problem.\nTherefore the general problem is also NP-Hard, using the \"restriction\" argument [11, p. 63, Section 3.2.1].\n\n\f9\n\nD. Related Literature\nWe see that the problem we have chosen to address belongs, broadly, to the class of Steiner Tree Problems (STP)\non graphs ([12], [13]).\nThe classical STP is stated as: given an undirected graph G = (V, E), with a non-negative weight associated with\neach edge, and a set of required vertices Q \u2286 V, find a minimum total edge cost subgraph of G that spans Q, and\nmay include vertices from the set S := V \u2212 Q, called the Steiner vertices.\nThe classical STP dates back to Gauss and it has been proven to be NP-Hard. Lin and Xue [14] proposed the\nSteiner Tree Problem with Minimum Number of Steiner Points and Bounded Edge Length (STP-MSPBEL). The\nSTP-MSPBEL was stated as: given a set of n terminal points Q in 2-dimensional Euclidean plane, find a tree\nspanning Q, and some additional Steiner points such that each edge has length no more than R, and the number\nof Steiner points is minimized. This bound on edge length only constrains link quality, but not end to end QoS.\nThe problem was shown to be NP-complete and a polynomial time 5-approximation algorithm was presented. This\nproblem was the first well-studied problem on optimal relay placement (relay locations unconstrained). However,\nno average case performance guarantee was provided for the proposed algorithm.\nCheng et al. [15] studied the same problem as Lin and Xue, and proposed a 3-approximation algorithm and a\n2.5-approximation algorithm.\nLloyd and Xue [16] studied a generalization of STP-MSPBEL problem where each sensor node has range r and\neach relay node has range R \u2265 r. They provided a 7-approximation polynomial time algorithm. They also studied\nthe problem of minimum number of relay placement such that there exists a path consisting solely of relay nodes\nbetween each pair of sensors. For this problem, they provided a (5 + \u01eb)-approximation algorithm. The problems\nstudied by Lloyd and Xue, as well as Cheng et al. fall in the category of unconstrained relay placement problem.\nNeither work provide any average case performance guarantee of their proposed algorithms.\nVoss [17] studied the Steiner Tree Problem with Hop Constraints (STPH). This problem is stated as: given a\ndirected connected graph G = (V, E), with non-negative weight associated with each edge, consider a subset of V,\nnamely, Q = {0, 1, 2, . . . , n} with 0 being the root vertex, and a positive integer H. The problem is to find a minimum\ntotal edge cost subgraph T of G such that there exists a path in T from 0 to each vertex in Q\\{0} not exceeding\nH arcs (possibly including vertices from S := V \u2212 Q). We can call this problem the Rooted Steiner Tree-Minimum\nWeight-Hop Constraint problem (RST-MW-HC). This problem was shown to be NP-Hard, and a Minimal Spanning\nTree based heuristic algorithm was proposed to obtain a good quality feasible solution, followed by an improvement\nprocedure using a variation of Local Search method called the Tabu search heuristic. No performance guarantee\nor complexity analysis of the heuristic was provided. Also, the tabu search heuristic may not be polynomial time.\nNote that an instance of the RST-MR-HC problem can be converted to an instance of the RST-MW-HC problem\nin polynomial time as follows: replace each relay with a directed edge of weight 1, and replace each edge associated\nwith the relay with two directed edges (each of weight 0), one incident into the tail of the edge substituting the\nrelay, and one going out of the tip of the edge substituting the relay. Then, minimizing the number of relays in the\noriginal problem is equivalent to minimizing the total weight in the converted problem. Then, one could use Voss's\nalgorithm on this instance of RST-MW-HC problem to solve the original problem. But, as we mentioned earlier,\nVoss's algorithm does not provide any performance guarantee, and because of the tabu search heuristic (which may\nnot be polynomial time), it may take long to converge to a solution.\nCosta et al. [18] studied the Steiner Tree Problem with revenue, budget, and hop constraints. Given a graph\nG = (V, E), with a cost associated with each edge, and a non-negative revenue associated with each vertex, the\nproblem is to determine a revenue maximizing tree subject to a total edge cost constraint, and a hop constraint\nbetween the root vertex and every other vertex in the tree. They propose a greedy algorithm for initial solution\nfollowed by destroy-and-repair or tabu search to improve the initial solution. They have evaluated the performance\nof the proposed algorithms only through numerical experiments; no theoretical guarantee has been provided.\nIt is possible to cast our problem into the form of the one addressed by Costa et al. [18] as follows: assign a\nnegative revenue, say \u22121, to each relay node (Steiner vertex), and a large positive revenue, say |R| + 1, where |R|\nis the number of potential relay locations, to each source vertex. This cost assignment would ensure that a revenue\nmaximizing tree has all the source vertices in it, since the gain in revenue by adding a source outweighs the loss\nin revenue due to the additional relays, if any, required to connect the source to the BS. Also, the negative revenue\non relays ensures that the revenue maximizing tree contains in it, as few relays as possible. Now, choose the hop\nconstraint to be the same as that in the original RST-MR-HC problem. Also, assign a cost of zero to each edge, and\nchoose a trivial total edge cost constraint (any positive real number). With these assignments/choices, the problem\nof minimizing total relay count while obtaining a hop constrained tree network (RST-MR-HC) is the same as the\n\n\f10\n\nproblem of obtaining a revenue-maximizing Steiner tree subject to a hop constraint and a total edge cost constraint.\nThis formulation, however, requires the node weights to be negative, whereas the algorithm proposed by Costa et al.\nrequires the nonnegativity of the node weights 1 . Moreover, even if one could find a way to map the RST-MR-HC\nproblem to the revenue-budget-hop constrained STP, the tabu search based heuristic proposed by Costa et al. to\nimprove the initial solution to the revenue-budget-hop constraint problem is not guaranteed to be polynomial time\nin general, and may take a long time to converge.\nKim et al. [19] studied the Delay and Delay Variation Constrained multicastng Steiner Tree Problem. The problem\nis similar to the one studied by Voss, with a delay constraint instead of the hop constraint, and a constraint on delay\nvariation between two sources. With the delay variation constraint relaxed, Kim's problem becomes the Rooted\nSteiner Tree-Minimum Weight-Delay Constraint problem. They proposed a polynomial time heuristic algorithm to\nobtain feasible solutions, but they also did not provide any performance guarantee for their algorithm.\nBredin et al. [20] studied the problem of optimal relay placement (unconstrained) for k\u2212connectivity. They\nproposed an O(1) approximation algorithm for the problem with any fixed k \u2265 1. However, they did not provide\nany average case analysis for their algorithm.\nMisra et al. [10] studied the constrained relay placement problem for connectivity and survivability. They provided\nO(1) approximation algorithms for both the problems. We can call their first problem the Rooted Steiner TreeMinimum Relays problem, and their second problem, the Rooted Steiner Tree-Minimum Relays-Survivability problem.\nAlthough their formulation takes into account an edge length bound, namely edge length\u2264 rc , which can model the\nlink quality, the formulation does not involve a path constraint such as the hop count along the path; hence, there\nis no constraint on the end-to-end QoS.\nYang et al. [21] studied a variation of the problem in [10], namely the two-tiered constrained relay placement\nproblem for connectivity and survivability, where each source has to be covered by one (two) relay nodes, and\nthe relay nodes form a one (two)-connected network with the BS. They provided O(ln n) approximation algorithms\nfor arbitrary settings, and O(1) approximation for some special cases. Their formulation also does not involve any\nconstraint on the end-to-end QoS.\nThe numerical experiments in both [10] and [21] actually evaluate the empirical average case performance of\ntheir proposed algorithms on random test scenarios, which they compare against the theoretically derived worst\ncase performance bounds. Neither work, however, attempt a formal analysis of the average case performance of\nthe proposed algorithms.\nTABLE I\nA Comparison with Closely Related Literature; the \"starred\" problems are the ones we address in this paper; an entry '\u00d7' in a column means\nthat the corresponding algorithm does not provide the attribute given in the top of that column, whereas a 'X' means that it does provide the\nattribute.\n\nProblem\n\nRST-MR [10]\nRST-MW-HC [17]\nRST-MW-DC [19]\nRST-MR-HC\u2217\nRSNk-MR-HC\u2217\n\nEnd-to-End\nPerformance\nObjective\n\nComplexity\n\n\u00d7\nX\nX\nX\nX\n\nNP-Hard\nNP-Hard\nNP-Hard\nNP-Hard\nNP-Hard\n\nWorst Case Approximation\nGuarantee of\nProposed\nAlgorithm\n6.2\n\u00d7\n\u00d7\npolynomial factor\npolynomial factor\n\nAverage Case Approximation\nGuarantee of\nProposed\nAlgorithm\n\u00d7\n\u00d7\n\u00d7\npolynomial factor\npolynomial factor\n\nIn Table I, we present a brief comparison of the problem under study in this paper with some of the closely\nrelated problems studied in the literature.\nV. RST-MR-HC: A Heuristic and its Analysis\nA. Shortest Path Tree (SPT) based Iterative Relay Pruning Algorithm (SPTiRP)\n1) The Zero Relay Case: Find the SPT on Q alone, rooted at the sink. If the hop count \u2264 hmax for each path,\nwe are done; no relays are required in an optimal solution. Else, go to the next step.\n1 The greedy algorithm that they proposed starts with the root node, and proceeds by adding a path connecting a non-selected profitable vertex\nto the existing solution at each step; when the budget constraint can be trivially satisfied, this amounts to simply finding a hop constrained path\nfrom a profitable vertex to the root. This is not enough to ensure revenue maximization if the revenues associated with some of the nodes is\nnegative, since the path selected from the profitable vertex to the root may contain vetices with negative revenue, thus reducing the profit along\nthe way; thus, additional constraints must be imposed for selection of paths from the profitable vertices to the root node to ensure minimal\nusage of the negative-revenue vertices.\n\n\f11\n\n2) Find the Shortest Path Tree T on G, rooted at the sink.\n3) Checking Feasibility: If for any path in the SPT, the path weight exceeds hmax , declare the problem infeasible.\n(Clearly, if the shortest path from a node to the sink does not meet the hop count bound, no other path from\nthe node to the sink will meet the hop count bound). Else, go to the next step.\nPruning the SPT:\n4) Discard all nodes in R\\T . Note that this step may lead to suboptimality as some nodes in R\\T could be part\nof an optimal solution.\n5) Now, for the remaining relay nodes in R, define the weight of a relay node as the number of paths in the\nSPT that use the node.\n6) Arrange the paths in SPT in increasing order of hop count.\n7) Among the paths in the SPT that use relay nodes, choose one that has the least number of hops This path\nhas the maximum \"slack\" in the hop constraint. Arrange the relay nodes on this path in increasing order of\ntheir weights as defined in (5).\n8) Remove the least weight relay node and consider the restriction of G to the remaining nodes in T . Find an\nSPT on this graph. If in this SPT, path cost exceeds hmax for any path, then discard this SPT, replace the\nremoved relay node, and repeat this step with the next least weight relay node. If all the relays in the least\ncost path have been tried without success, move on to the next least cost path, and repeat steps 7 and 8 for\nthe relays in this path that have not yet been tried.\n9) If in the above step, the SPT obtained satisfies the delay constraint for all the paths, then delete the removed\nrelay node permanently from R and repeat Steps 4 through 9.\n10) Stop when no more relay pruning is possible without violating the hop constraint on one or more of the paths.\nDiscussion:\nStep 1 of the above algorithm ensures that if the optimal design does not use any relay node, then the same\nholds true for our algorithm. That way we can make sure that the algorithm does not do infinitely worse in the\nRelay\nis finite.\nsense that Relayalgo\nopt\nThe idea behind Steps 7, 8 and 9 is that choosing to remove a relay from the path with the most slack in cost\n(i.e., hop constraint), we stand a better chance of still meeting the delay requirement with the remaining relays.\nAlso, removing a relay of less weight would mean affecting the cost of a small number of paths. So by pruning\nrelays in the manner as described in Steps 7, 8 and 9, we aim for a better exploration of the search space.\nB. Analysis of SPTiRP\n1) Complexity: The complexity of determining the shortest path tree on N nodes is O(N log N) [22]. Let us\ndenote this function by gS PT (.). In Iteration 1 of the algorithm, the complexity is gS PT (|Q|) and in iteration 2, it\nis gS PT (|Q| + |R|). In subsequent iterations, we remove 1 relay node at a time and find the SPT on the resultant\ncomplete graph; if no improvement is found, we replace that node and continue. Thus, for the kth iteration, the\nworst case complexity will be (|R| \u2212 k + 3)gS PT (|Q| + |R| \u2212 k + 2), where in the worst case, k = 3, 4, . . . , |R| + 1. Let\ng sptirp (.) denote the overall complexity. Thus, the overall complexity will be\ng sptirp (|Q| + |R|) = gS PT (|Q| + |R|)+\n|R|\nX\n(gS PT (|Q| + |R| \u2212 j))(|R| \u2212 j + 1)\nj=1\n\n\u2264 (1 + |R|2 )(gS PT (|Q| + |R|))\nwhich is polynomial time.\n2) Worst Case Approximation Factor:\nTheorem 1. The worst case approximation guarantee for the SPTiRP algorithm is min{m(hmax \u2212 1), (|R| \u2212 1)}, where\nm is the number of sources, hmax is the hop constraint, and |R| is the number of potential relay locations.\nProof: The worst case occurs when the SPT obtained before we enter Step (4) does not contain any relay\nnode(s) that correspond to some optimal design. If no relays are used in any optimal design, then the algorithm\nwill yield an optimal design (Step (1)). If an optimal solution uses a positive number of relays but not all of them,\nthen SPTiRP cannot stop by using all the relays. For suppose, SPTiRP stops and uses all the relays. Since there is\n\n\f12\n\nBS\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n11\n00\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n1\n0\n00\n11\nS1\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n1\n0\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n00000000000000\n11111111111111\n00\n11\n0000000000000\n1111111111111\n0000000000\n1111111111\n000000\n111111\n0000000000000\n1111111111111\n00 1111111111111\n11\n00000000000000\n11111111111111\n0000000000000\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\nR3\nRn\n00\n11\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\nR2\n0000000000000\n1111111111111\n00 1111111111111\n11\n00000000000000\n11111111111111\n0000000000000\n0000000000000\n1111111111111\n0000000000000\n1111111111111\nR1\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00 111\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00 111\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00 111\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n111\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n1111111111111\n00 111\n11\n00000\n11111\n0000000000000\n1111111111111\n00000\n11111\n000\n00000000000000\n11111111111111\n0000000000000\n1111111111111\n0000000000000\n00\n11\n00000\n11111\n11\n00\n1\n0\n1\n0\n1\n0\n0000000000000\n1111111111111\n000 1111111111111\n111\n\nS2\n\nFig. 3.\n\nS3\n\nSn\n\nA Sequence of Problems where the Worst Case Approximation Guarantee is Strict\nS1\nSn\n\nBS\n\nRn\n\nSn\u22121\n\nFig. 4.\n\nS2\n\nR1\n\nRn\u22121\n\nR2\n\nR3\n\nS3\n\nA Sequence of Problems where SPTiRP gives Optimal Solution\n\na feasible tree containing a strict subset of the relays, the pruning steps in SPTiRP will succeed in pruning at least\none relay. Hence, the worst possibility is that the optimal design uses just 1 relay node, whereas the SPT obtained\nin Step (2) consists of all the remaining (|R| \u2212 1) relays, and moreover, pruning any of these (|R| \u2212 1) relays will\ncause one or more paths in the resulting SPT to violate the hop constraint. Thus, in the worst case, the algorithm\nmay lead to a design with (|R| \u2212 1) relays instead of the optimal design with one relay. Also note that for a problem\nwith m sources, and a hop constraint hmax , no feasible solution can use more than m(hmax \u2212 1) relays. Hence, we\nhave a polynomial factor worst case approximation guarantee of min{m(hmax \u2212 1), (|R| \u2212 1)}.\n3) Sharp Examples (for Worst Case Approximation and for Optimality): Let us now present a sequence of\nproblems of increasing complexity for which the approximation guarantee is strict, i.e., for these problems, the\nalgorithm ends up using |R| \u2212 1 relays, while the optimum design uses one relay. Such examples are worthwhile\nto explore as they help to show that the approximation factor obtained above cannot be improved. Consider the\nsituation shown in Figure 3. The green hexagons denote the relay node locations and the black circles represent the\nsource node locations. Only the edges shown (coloured or black) are permitted. Consider the RST-MR-HC problem\non this graph with hmax = 3. Clearly the optimal solution will use only one relay, R1, to reach from each source\nto the BS within the specified hop count bound. The black dotted links correspond to the optimal solution. The\nred link will belong to both the optimal solution and the outcome of our algorithm as it is a direct link between\nsource S 1 and the BS. Our SPT based algorithm will calculate the shortest paths and thus end up using relays\nR2, R3, . . . , Rn, leaving out R1. The black solid links correspond to the solution given by our algorithm. Clearly, in\nsuch problems, we end up using |R| \u2212 1 relays instead of just one.\nAnother sequence of problems of increasing complexity for which the algorithm gives the optimal design can\nbe constructed as shown in Figure 4. Such examples help to show that the proposed algorithm does provide an\noptimal solution in some scenarios.\nAs before, the green hexagons represent relay locations and the black dots represent source nodes. Suppose\nhmax = 2. Then clearly, the optimal solution is as shown in the figure. The algorithm, after calculating the SPT, will\nend up with the same solution.\n\n\f13\n\n4) Average Case Approximation Factor of SPTiRP: We shall derive below, an upper bound on the average case\napproximation factor of SPTiRP in a certain stochastic setting, defined by a probability distribution on the potential\nrelay locations and the source locations. The derivation, in fact, applies to any algorithm that starts with an SPT,\nand proceeds by pruning relays from the SPT in some manner. The probability distributions (and hence the setting)\nare chosen so as to ensure the existence of a feasible solution with high probability.\nWe consider a square area A(\u2282 R2+ ) of side a. The BS is located at (0,0). We deploy n potential locations\nrandomly over A, yielding the potential locations vector x \u2208 An . Then we place m sources over A, yielding source\nlocation vector y \u2208 Am . Let \u03c9 = (x, y), i.e., \u03c9 denotes the joint potential locations vector and source locations\nvector. We assume a model where a link of length \u2264 r metres has the desired PER so that hmax is the hop constraint.\nWe then consider the geometric graph, Gr (\u03c9), over these n + m points; i.e., in Gr (\u03c9) there is an undirected edge\nbetween a pair of nodes in (\u03c9) if the Euclidean distance between these nodes is \u2264 r. If in this graph the shortest\npath from each source to the BS (at (0, 0)) has a hop count \u2264 hmax , then \u03c9 is feasible. Define\nH j (\u03c9): Hop distance (i.e., the number of hops in the shortest path) of source j from the BS in Gr (\u03c9),\n1 \u2264 j \u2264 m. (\u221e if source j is disconnected from BS in Gr (\u03c9))\nX = {(x, y) : \u2200y j , 1 \u2264 j \u2264 m, H j \u2264 hmax }: Set of all feasible instances\nWe would like X to be a high probability event. For this we need to limit the locations of the sources to be no\nmore than (1 \u2212 \u01eb)rhmax from the BS; Theorem 2, later, will help characterize the relationship between \u01eb, the number\nof potential locations, and the probability of X.\nFor a given \u01eb \u2208 (0, 1), let A\u01eb (\u2282 A) denote the quarter circle of radius (1 \u2212 \u01eb)hmax r centred at the BS, where hmax\nis the hop constraint, and r is the maximum allowed communication range.\nFormally, we deploy n potential locations independently and identically distributed (i.i.d) uniformly randomly\nover the area A; then deploy m sources i.i.d uniformly randomly over the area A\u01eb . The probability space of this\n(n)\n(n)\nrandom experiment is denoted by (\u03a9(n)\nm,\u01eb , Bm,\u01eb , Pm,\u01eb ), where,\n2(n+m)\nn\nm\n\u03a9(n)\n): Sample space; the set of all possible deployments\nm,\u01eb = (A \u00d7 A\u01eb )(\u2282 R+\n(n)\nBm,\u01eb : The Borel \u03c3-algebra in \u03a9(n)\nm,\u01eb\n(n)\nP(n)\nm,\u01eb : Probability measure induced on Bm,\u01eb by the uniform i.i.d deployment of nodes\nConsider the random geometric graph Gr (\u03c9) induced by considering all links of length \u2264 r on an instance\n\u03c9 \u2208 \u03a9(n)\nm,\u01eb . We introduce the following notation:\nNS PT iRP (\u03c9): number of relays in the outcome of the SPTiRP algorithm on Gr (\u03c9) (\u221e if \u03c9 \u2208 Xc )\nROpt (\u03c9): number of relays in an optimal solution to the RST-MR-HC problem on Gr (\u03c9) (\u221e if \u03c9 \u2208 Xc )\nThe average case approximation ratio of the SPTiRP algorithm over feasible instances is defined as\n\u25b3\n\nAverage case approximation ratio, \u03b1 =\n\nE[NS PT iRP |X]\nE[ROpt |X]\n\n(7)\n\nRemark: This would be a useful quantity if the user of the algorithm wishes to apply the algorithm to several\ninstances of the problem, yielding the required number of relays N1 , N2 , * * * , Nk , as against the optimal number of\n2 +***+Nk\nrelays R1 , R2 , * * * , Rk , and is interested in the ratio NR11+N\n+R2 +***+Rk .\nIn the derivation to follow, we will need X to be a high probability event, i.e., with probability greater than 1 \u2212 \u03b4\nfor a given \u03b4 > 0. The following result ensures that this holds for the construction provided earlier, provided the\nnumber of potential locations is large enough.\nTheorem 2. For any given \u01eb, \u03b4 \u2208 (0, 1), hmax > 0 and r > 0, there exists n0 (\u01eb, \u03b4, hmax , r) \u2208 N such that, for any\n(n)\n(n)\n(n)\nn \u2265 n0 , Pm,\u01eb\n(X) \u2265 1 \u2212 \u03b4 in the random experiment (\u03a9(n)\nm,\u01eb , Bm,\u01eb , Pm,\u01eb ).\nProof: The proof follows along the lines of the proof of Theorem 3 in [23]. We make the construction as\nshown in Figure 5. From the BS bl , we draw a circle of radius hmax r centered at bl , this is the maximum distance\nreachable in hmax hops, by triangle inequality, since each hop can be of maximum length r. We then construct\nblades as shown in Figure 5. We start with one blade. It will cover some portion of the circumference of the circle\nof radius hmax r; see Figure 5. Construct the next blade so that it covers the adjacent portion of the circumference\nthat has not been covered by the previous blade. We go on constructing these blades until the entire portion of the\ncircle lying inside the area A is covered (see Figure 5). Let us define,\n\u2022 J(r) : Number of blades required to cover the part of the circle within A.\nl\nth\n\u2022 B j : j blade drawn from the point bl as shown in Figure 5, 1 \u2264 j \u2264 J(r).\n\n\f14\n\nA\n\nr\n\nh\n\nblade Bjl\n\n...\n\nJ(r ) blades\n\n...\n\nbl\nh strips in each blade\n\nFig. 5.\n\nConstruction using the blades cutting the circumference of the circle of radius hr (adapted from Nath et al. [23]).\npr\nr\n\nqr\nu(r) =\n\nq\n\n(1 \u2212 p2 )r\n\nbl\n\nBlade Blj\n\n***\n1\n\n2\n\nh\u22121\n\nh\n\n(p \u2212 q)hr\n\nall nodes that fall here will have hop distance \u2264 h from bl\n\nFig. 6.\n\nThe construction with h hops (adapted from Nath et al. [23]).\n\nOn each of these blades, we construct hmax strips2 , shown shaded in Figure 6, u(r) being the width of the blade\nand t(r) the width of the strip. We define the following events.\nAli, j = {\u03c9: \u2203 at least one node out of the n potential loacations in the ith strip of Blj }\nhmax \u22121 l\nAi, j }: Event that there exists at least one node out of the n potential locations\nX\u01eb,\u03b4 = {\u03c9 : \u03c9 \u2208 \u2229 J(r)\nj=1 \u2229i=1\nin each of the first (hmax \u2212 1) strips (see Figure 6) for all the blades Blj\nNote that for an instance \u03c9 \u2208 X\u01eb,\u03b4 , all nodes (and in particular, all sources) at a distance < (p \u2212 q)hr from bl ,\n1 \u2264 h \u2264 hmax , are reachable in at most h hops. Since 1 > p > q > 0, we can choose p \u2212 q to be equal to 1 \u2212 \u01eb, for\nthe given \u01eb > 0. It follows that\nX\u01eb,\u03b4 \u2286 X\n(8)\n(n)\nand hence, P(n)\nm,\u01eb (X) \u2265 Pm,\u01eb (X\u01eb,\u03b4 ).\n(n)\nThus, to ensure Pm,\u01eb (X) \u2265 1 \u2212 \u03b4, it is sufficient to ensure that P(n)\nm,\u01eb (X\u01eb,\u03b4 ) \u2265 1 \u2212 \u03b4, which we aim to do next.\nTo find the value of J(r), we need to define the following.\na(r): Length of the arc of radius hmax r that lies within a blade, drawn taking bl as center, as shown in\nFigure 7.\n\u03b1(r) : Angle subtended by a(r)lat blm, see Figure 7.\np\n\u03c0\nNow from Figure 5, we have, J(r) = 2\u03b1(r)\n. We also have from Figure 7, hmax r\u03b1(r) = a(r) \u2265 u(r) = 1 \u2212 p2 r.\n'\n&\n\u221a 2\n1\u2212p\n\u03c0hmax\n.\nHence, \u03b1(r) \u2265 hmax . So, J(r) \u2264 \u221a\n2\n2\n\n1\u2212p\n\n(n)\nTo simplify notations, we shall henceforth write P(*) to indicate Pm,\u01eb\n(*).\n\n2A\n\nconstruction with improved convergence rate based on lens-shaped areas rather than rectangular strips is presented in Appendix B of [23].\n\n\f15\n\n\u03b1(r)\n\na (r)\n\nbl\n\nu(r )\nhr\n\nFig. 7.\n\nConstruction to find J(r) (adapted from Nath et al. [23]).\n\nNow we compute,\nP(X\u01eb,\u03b4 )\n=\n\n\u0011\n\u0010\nhmax \u22121 l c\nAi, j\n1 \u2212 P \u222a J(r)\nj=1 \u222ai=1\n\n\u2265\n\n1\u2212\n\n\u2265\n\u2265\n=\n\nJ(r) hmax\nX\u22121 \u0010 c \u0011\nX\nP Ali, j\nj=1\n\ni=1\n\n\uf8ee\n\uf8f9\n!n\n\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\nu(r)t(r)\n\uf8fa\uf8fa\uf8fa (hmax \u2212 1) 1 \u2212\n1 \u2212 \uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\nA\n\uf8f9\n\uf8ee\nnu(r)t(r)\n\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\uf8fa\n1 \u2212 \uf8ef\uf8ef\uf8ef\uf8ef p\n(h \u2212 1)e\u2212 A\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\uf8fa\uf8fa max\n\uf8f9\n\uf8ee\n\u221a\n\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\nq 1\u2212p2 r2\n\uf8fa\uf8fa\uf8fa (hmax \u2212 1)e\u2212n A\n1 \u2212 \uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\n\n(9)\n\nThe first inequality comes from the union bound, the second inequality, from the upper bound on J(r). The third\ninequality uses the result 1 \u2212 x \u2264 e\u2212x .\nThus, in order to achieve P(X\u01eb,\u03b4 ) \u2265 1 \u2212 \u03b4 (and hence, P(X) \u2265 1 \u2212 \u03b4), it is sufficient that\n\uf8ee\n\uf8f9\n\u221a\n\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa \u2212n q 1\u2212p2 r2\nA\n\uf8fa\uf8fa\uf8fa e\n\u22651\u2212\u03b4\n1 \u2212 \uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\n\n\uf8f1\uf8ee\n\uf8f9 \uf8fc\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\uf8ef\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\uf8fa 1 \uf8f4\n\uf8fd\u25b3\n\u21d2n\u2265 p\nln \uf8f4\n= n0 (\u01eb, \u03b4, hmax , r)\n(10)\n\uf8ef\uf8ef\uf8ef p\n\uf8fa\uf8fa\uf8fa \uf8f4\n\uf8f4\n\uf8f3\n\uf8fe\n\uf8ef 2 1 \u2212 p2 \uf8fa \u03b4 \uf8f4\nq 1 \u2212 p2 r 2\np\nwhere, p and q can be obtained in terms of \u01eb by maximizing q 1 \u2212 p2 (so as to somewhat tighten the bound in\nEquation (10)) under the constraint p \u2212 q = 1 \u2212 \u01eb.\nNote that a tighter bound can be obtained by using the \"eyeball\" construction presented in Appendix B of [23]\ninstead of the rectangular strip construction presented here.\nA\n\nRemark: For fixed hmax and r, n0 (\u01eb, \u03b4) increases with decreasing \u01eb and \u03b4.\nThe experiment: In the light of Theorem 2, we employ the following node deployment strategy to ensure, w.h.p,\nfeasibility of the RST-MR-HC problem in the area A. Choose arbitrary small values of \u01eb, \u03b4 \u2208 (0, 1). Given the\nhop count bound hmax and the maximum communication range r, obtain n0 (\u01eb, \u03b4, hmax , r) as defined in Theorem 2.\nDeploy n \u2265 n0 potential locations i.i.d uniformly randomly over the area of interest, A. m sources are deployed\ni.i.d uniformly randomly within a radius (1 \u2212 \u01eb)hmax r from the BS, i.e., over the area A\u01eb . By virtue of Theorem 2,\nthis ensures that any source deployed within a distance (1 \u2212 \u01eb)hmax r is no more than hmax hops away from the BS\nw.h.p, thus ensuring feasibility of the RST-MR-HC problem w.h.p. We check whether the deployment is feasible\nby computing the SPT on the induced random geometric graph with hop count as cost. In this stochastic setting,\nwe derive an upper bound on the average case approximation ratio, \u03b1, of the SPTiRP algorithm as follows.\n\n\f16\n\nLemma 1.\nE[NS PT iRP |X] \u2264 m[hmax \u2212\n\u2212\n\nhmax\nX\u22121\nj=2\n\nj2\nh2max\n\n1\n(1 \u2212 \u01eb)2 h2max\n]\u2212m\n\n+ m\u03b4(hmax \u2212 1)\n\n(11)\n\nProof: We define the following:\nNS PT (\u03c9): number of relays in the SPT on Gr (\u03c9) for the m sources with BS as the root (\u221e if Gr (\u03c9) is\ndisconnected)\nS j (\u03c9): set of sources whose Euclidean Distance (D s ) from the BS satisfy (1 \u2212 \u01eb)( j \u2212 1)r < D s \u2264 (1 \u2212 \u01eb) jr,\nfor j = 3, . . . , hmax , and r < D s \u2264 (1 \u2212 \u01eb)2r for j = 2, 0 < D s \u2264 r for j = 1\nM j (\u03c9): Number of sources in the set S j (\u03c9), i.e., |S j (\u03c9)|\nH j (\u03c9): maximum number of hops in the shortest path from a source in S j (\u03c9) to the BS\nP max\nNote that hj=1\nM j (\u03c9) = m.\nRecall that NS PT iRP (\u03c9) denotes the number of relays in the solution provided by the SPTiRP algorithm on a\nfeasible instance. Since the algorithm starts by finding an SPT, and then pruning relays from that SPT, we have\nNS PT iRP (\u03c9) \u2264 NS PT (\u03c9)\nHence, we can upper bound the expected number of relays in the SPTiRP solution on a feasible instance as\nE[NS PT iRP |X] \u2264 E[NS PT |X]\n\n(12)\n\nNow, observe that\nNS PT \u2264\n\nhmax\nX\nj=1\n\nMjH j \u2212 m\n\n(13)\n\nAlso note that, given X\u01eb,\u03b4 (i.e., given a deployment in X\u01eb,\u03b4 ), H j \u2264 j, \u2200 j = 1, . . . , hmax .\nTherefore, taking expectation on both sides of (13), we have\n\nE[NS PT |X\u01eb,\u03b4 ] \u2264 E[\n\nhmax\nX\nj=1\n\nM j H j |X\u01eb,\u03b4 ] \u2212 m\n\n\u2264\n\nhmax\nX\n\njE[M j |X\u01eb,\u03b4 ] \u2212 m\n\n=\n\nhmax\nX\n\njE[M j ] \u2212 m\n\nj=1\n\nj=1\n\n= m[hmax \u2212\n\u2212\n\nhmax\nX\u22121\nj=2\n\nj2\nh2max\n\nsince M j \u22a5 X\u01eb,\u03b4\n\n1\n(1 \u2212 \u01eb)2 h2max\n] \u2212 m,\n\nafter simplification\n\n(14)\n\nHowever, a deployment in X\u01eb,\u03b4 is sufficient, but not necessary for feasibility of the RST-MR-HC problem. When\na deployment is not in X\u01eb,\u03b4 , but still there exists a feasible solution satisfying the hop constraint, the number of\n\n\f17\n\nnodes in the SPT can be trivially upper bounded as m(hmax \u2212 1). Hence,\nE[NS PT |X] = E[NS PT |X\u01eb,\u03b4 , X]P[X\u01eb,\u03b4 |X]\n+ E[NS PT |Xc\u01eb,\u03b4 , X]P[Xc\u01eb,\u03b4 |X]\n\n\u2264 E[NS PT |X\u01eb,\u03b4 ] + E[NS PT |Xc\u01eb,\u03b4 , X]\u03b4\n1\n\u2264 m[hmax \u2212\n(1 \u2212 \u01eb)2 h2max\nhmax\n\u22121\nX j2\n\u2212\n]\u2212m\nh2max\nj=2\n\n+ m\u03b4(hmax \u2212 1)\n\n(15)\n\nThe lemma follows by combining equations (12) and (15).\nLemma 2.\n\uf8ee\n\uf8ef\uf8ef\nE[ROpt |X] \u2265 \uf8ef\uf8ef\uf8ef\uf8f01 \u2212\n\nhmax \u2212 1\n(1 \u2212 \u01eb)hmax\n\nwhere, ni = min(i, hmax \u2212 i).\n\n\uf8eb\n!2m \uf8f9\nhmax\nX\u22121 \uf8ec\uf8ec\uf8ec\n\uf8fa\uf8fa\uf8fa\n\uf8ec\uf8ec\uf8ec1 \u2212\n\uf8fa\uf8fa\uf8fb (1 \u2212 \u03b4)\n\uf8ec\uf8ed\ni=1\n\n\uf8f6m\u22121\n\uf8f7\uf8f7\uf8f7\n\uf8f7\uf8f7\uf8f7\n\uf8f7\n(1 \u2212 \u01eb)2 h2max \uf8f8\nn2i\n3\n\n(16)\n\nProof:\nWe can write\nE[ROpt |X] \u2265 E[ROpt 1X\u01eb,\u03b4 |X]\n\n= P[X\u01eb,\u03b4 |X] \u00d7 E[ROpt |X\u01eb,\u03b4 , X]\n\u2265 P[X\u01eb,\u03b4 , X] E[ROpt |X\u01eb,\u03b4 , X]\n= P[X\u01eb,\u03b4 ] E[ROpt |X\u01eb,\u03b4 ],\n\u2265 (1 \u2212 \u03b4) E[ROpt |X\u01eb,\u03b4 ]\n\nsince X\u01eb,\u03b4 implies feasibility\n\n(17)\n\nRemark: The first inequality above is tight since X\u01eb,\u03b4 is a high probability event (for the chosen deployment\nstrategy). The second inequality is tight since P(X) \u2265 P(X\u01eb,\u03b4 , X) \u2265 1 \u2212 \u03b4, and hence P(X) is close to 1. The third\ninequality is tight when the number of potential relay locations is just enough to meet the requirement P(X\u01eb,\u03b4 ) \u2265 1\u2212\u03b4,\ni.e., P(X\u01eb,\u03b4 ) \u2245 1 \u2212 \u03b4.\nWe define\nD s (\u03c9): The maximum Euclidean distance from the BS, of a source location in \u03c9\nThen, for the conditional expectation term on the right hand side of Eqn. (17), we can write\nE[ROpt |X\u01eb,\u03b4 ] = E[ROpt 1{D s \u2264(hmax \u22121)r} |X\u01eb,\u03b4 ]\n\n+ E[ROpt 1{Ds >(hmax \u22121)r} |X\u01eb,\u03b4 ]\n\n\u2265 E[ROpt 1{D s >(hmax \u22121)r} |X\u01eb,\u03b4 ]\n\n= P[D s > (hmax \u2212 1)r|X\u01eb,\u03b4 ]\u00d7\n\nE[ROpt |Ds > (hmax \u2212 1)r, X\u01eb,\u03b4 ]\n= P[D s > (hmax \u2212 1)r]\u00d7\n\nE[ROpt |Ds > (hmax \u2212 1)r, X\u01eb,\u03b4 ]\n\n(18)\n\nwhere the last equality follows since the event X\u01eb,\u03b4 depends only on the positions of the relays, while the event\n{\u03c9 : D s (\u03c9) > (hmax \u2212 1)r} depends only on the sources, thus being independent of each other.\nRemark: The inequality above may not be loose since the probability that there exists at least one source in the\nring with inner and outer radii ((hmax \u2212 1)r, (1 \u2212 \u01eb)hmax r) is significantly large compared to that in the inner rings\n(the last ring having the maximum area among all the rings), and this probability increases with increasing number\nof sources.\n\n\f18\n\nr\n\ns(\u03c9)\n\n(s)\nL1\n\n2r\n(s)\n\nL2\n\nr\n\n3r\nr\n(s)\nL3\n\nBS\nr\n(1 \u2212 \u01eb)hr\nhr\n(s)\nth\nth\nFig. 8. Illustration of the lenses L(s)\nj , 1 \u2264 j \u2264 hmax \u2212 1, used in the proof of Lemma 2; L j contains in it, the j lens, and hence the j\nintermediate node in a feasible path from source s(\u03c9) to the BS. The solid triangles indicate the intermediate nodes in a feasible path from\nsource s(\u03c9) to the BS.\n\nNote that D s > (hmax \u2212 1)r on an instance in X\u01eb,\u03b4 implies that there exists at least one source in the ring with\ninner and outer radii ((hmax \u2212 1)r, (1 \u2212 \u01eb)hmax r), and, being feasible, it must be hmax hops away from the BS. For\nease of writing, let us define\nXhmax = {\u03c9 : D s (\u03c9) > (hmax \u2212 1)r} \u2229 X\u01eb,\u03b4\nConsider an instance \u03c9 \u2208 Xhmax . In this \u03c9, let us denote by s(\u03c9), the source which is farthest from the BS among\nall the sources in the outermost ring (centred at the BS), with inner and outer radii ((hmax \u2212 1)r, (1 \u2212 \u01eb)hmax r).\nObserve that, ROpt (\u03c9) is lower bounded by the number of relays in the path from the source s(\u03c9) to the BS in\nany optimal solution in \u03c9.\nFor an instance \u03c9 \u2208 Xhmax , we have the following properties:\n1) for each node in a feasible path from the source s(\u03c9) to the BS,\na) The next hop node must lie in the lens shaped intersection of the communication circle of radius r of\nthat node, and the next ring. These lenses are disjoint, and there are (hmax \u2212 1) of them. This property is\nillustrated in Figure 8, where we have, hmax = 4, and we have indicated a feasible path from the source\ns(\u03c9) (which is in the outermost ring) to the BS; each link in the path is indicated by a solid straight\nline, and each intermediate node is indicated by a triangle. Also shown by narrow solid arc is the lens\nshaped intersection of the communication circle of radius r of each node, and the next ring. Note that\nfor each node, the next hop node always lies in this lens shaped intersection. Moreover, these lenses are\ndisjoint.\nb) The next hop node is a relay if there does not exist a source node (out of at most (m \u2212 1) remaining\nsource nodes) within the next \"lens\".\n2) Further, it follows from the triangle inequality that the maximum possible Euclidean distance from s(\u03c9), of\nthe jth node (counting from the source side, excluding the source) in a feasible path from s(\u03c9) to the BS,\nis jr, irrespective of the position of the intermediate nodes. Hence, we denote by L(s)\nj (\u03c9), the lens shaped\nintersection of the circle of radius jr centred at s(\u03c9), and the circle of radius (hmax \u2212 j)r centred at the BS.\nClearly, L(s)\nj (\u03c9) encompasses in it, all possible lenses (depending on the positions of the intermediate nodes)\n\n\f19\n\nthat might contain the jth node in a feasible path of s(\u03c9). Also note that the lenses L(s)\nj , 1 \u2264 j \u2264 hmax \u2212 1, are\ndisjoint. For example, see Figure 8, where hmax = 4, and we have indicated by thick dashed arcs, the lenses\n(s)\nth\nL(s)\nj , 1 \u2264 j \u2264 3, for the source s(\u03c9). As can be seen from the figure, L j , 1 \u2264 j \u2264 3, contains in it, the j\nth\nlens, and hence the j intermediate node in the feasible path from source s(\u03c9) to the BS. Also, we see from\nFigure 8 that the lenses L(s)\nj , 1 \u2264 j \u2264 3 are disjoint.\n\nNow, for any \u03c9 \u2208 {\u03c9 : D s (\u03c9) > (hmax \u2212 1)r}, we define, \u2200i, 1 \u2264 i \u2264 hmax \u2212 1,\n(\n1, if , \u2203 no source in L(s)\ni (\u03c9)\nYi (\u03c9) =\n0, otherwise\n\nSet Yi (\u03c9) = \u221e if \u03c9 \u2208 {\u03c9 : D s (\u03c9) > (hmax \u2212 1)r}c . Yi (\u03c9) is uniquely determined by \u03c9, and does not depend on any\nparticular optimal solution.\nThus, it follows from the definition of Yi (\u03c9) and the properties 1 and 2 above that, in an optimal solution, the\nP max \u22121\nnumber of relays in the path from the source s(\u03c9) to the BS is at least hi=1\nYi (\u03c9) (since whenever Yi (\u03c9) = 1, 1 \u2264\nth\ni \u2264 hmax \u2212 1, the i hop node in the path from source s(\u03c9) to the BS must be a relay). Hence,\nROpt (\u03c9) \u2265\n\nhmax\nX\u22121\ni=1\n\nYi (\u03c9) \u2200\u03c9 \u2208 Xhmax\n\nLet us further define\n(\nnumber of sources in the outermost ring,\no\nM (\u03c9) =\n0,\n\n(19)\n\nif \u03c9 \u2208 {\u03c9 : D s (\u03c9) > (hmax \u2212 1)r}\notherwise\n\nThus, we have\n\uf8eeh \u22121\n\uf8f9\nX\n\uf8ef\uf8ef\uf8ef max\n\uf8fa\uf8fa\uf8fa\nE[ROpt |Xhmax ] \u2265 E \uf8ef\uf8ef\uf8ef\uf8f0\nYi |Xhmax \uf8fa\uf8fa\uf8fa\uf8fb\ni=1\n\nm\nX\n\nP[M =\n\n=\n\nm\nX\n\nP[M o =\n\n=\n\nm\nX\n\nP[M o =\n\nm\nX\n\nP[M o =\n\n=\n\no\n\nj=1\n\nj=1\n\nj=1\n\n\u2265\n\n\uf8eeh \u22121\n\uf8f9\nX\n\uf8ef\uf8ef\uf8ef max\n\uf8fa\uf8fa\uf8fa\no\n\uf8ef\nj|Xhmax ] E \uf8ef\uf8ef\uf8f0\nYi |M = j, Xhmax \uf8fa\uf8fa\uf8fa\uf8fb\ni=1\n\uf8ebh \u22121\n\uf8f6\nX \u0002\n\uf8ec\uf8ec\uf8ec max\n\uf8f7\uf8f7\uf8f7\n\u0003\nj|Xhmax ] \uf8ec\uf8ec\uf8ec\uf8ed\nE Yi |M o = j, Xhmax \uf8f7\uf8f7\uf8f7\uf8f8\ni=1\n\uf8ebh \u22121\n\uf8f6\nX\n\uf8ec\uf8ec\uf8ec max\n\uf8f7\uf8f7\uf8f7\no\nj|Xhmax ] \uf8ec\uf8ec\uf8ed\uf8ec\nP[Yi = 1|M = j, Xhmax ]\uf8f7\uf8f7\uf8f7\uf8f8\ni=1\n\uf8ebh \u22121 \uf8f6\nmax\n\uf8ec\uf8ec\uf8ec X \uf8f7\uf8f7\uf8f7\nqi \uf8f7\uf8f7\uf8f7\uf8f8 , qi \u2254 P[Yi = 1|M o = 1, Xhmax ]\nj|Xhmax ] \uf8ec\uf8ec\uf8ec\uf8ed\n\n= P[M o \u2265 1|Xhmax ]\n=\n\nhmax\nX\u22121\ni=1\n\n(20)\n\ni=1\n\nj=1\n\nqi ,\n\nhmax\nX\u22121\n\nqi\n\ni=1\n\nsince P[M o \u2265 1|Xhmax ] = 1\n\n(21)\n\nwhere, the inequality 20 follows by taking (m \u2212 1) sources (which is the maximum possible number, given that\nthere exists at least one source in the outermost ring) to be free to enter the lenses L(s)\ni , 1 \u2264 i \u2264 hmax \u2212 1.\nTo obtain a lower bound on qi , we proceed as follows.\nqi = P[Yi = 1|M o = 1, Xhmax ]\n\n= P[Yi = 1|M o = 1, D s > (hmax \u2212 1)r] X\u01eb,\u03b4 indept. of source node locations\n\n(22)\n\nWhen there exists a single source in the outermost ring, Yi = 1 if there does not exist a source node (out of at\n\n\f20\n\nmr\n\u03b8\n\n\u03c6\n\nBS\n\nS\nnr\n\nD\n\nFig. 9.\n\nThe lens shaped intersection between two circles\n\nmost (m \u2212 1) remaining source nodes) within the lens L(s)\ni .\n\n\u03c0 2 2\nClaim: The area of lens L(s)\ni is upper bounded by 3 ni r , where ni = min(i, hmax \u2212 i).\nProof:\nConsider the situation shown in Figure 9. We are interested in the area of the shaded lens shaped region of\nintersection between two circles of radii mr and nr respectively, m, n \u2208 N, r \u2208 R+ . Assume without loss of generality,\nm \u2265 n. Also, assume that the distance D between the centres of the circles satisfies (m + n)r > D \u2265 max(mr, nr), so\nthat the circles have a non-zero area of intersection, and neither centre is within the other circle. Let the angles \u03b8\nand \u03c6 be as shown in the figure. Let A s denote the area of the shaded region. Then clearly,\n\nA s \u2264 n2 r 2 \u03c6\n\n(23)\n\n+\n\nLet D = ar, where a \u2208 R . Note that (m + n) > a \u2265 m (since, (m + n)r > D \u2265 max(mr, nr) = mr).\nNow,\nD2 + m2 r 2 \u2212 n 2 r 2\n2Dmr\na 2 + m2 \u2212 n 2\n=\n2am\nm2 \u2212 n 2\na\n+\n=\n2m\n2am\n\ncos \u03b8 =\n\nand,\nD2 + n 2 r 2 \u2212 m2 r 2\n2Dnr\na 2 + n 2 \u2212 m2\n=\n2an\na\nn 2 \u2212 m2\n=\n+\n2n\n2an\n\ncos \u03c6 =\n\nThus,\n!\"\n#\nm2 \u2212 n 2\n1 1 a\n\u2212\n+\nm n 2\n2a\n\u2264 0 since m \u2265 n\n\ncos \u03b8 \u2212 cos \u03c6 =\n\n(24)\n\n\u03c0\n2)\n\nObserve that \u03b8, \u03c6 \u2208 (0, (since n \u2264 m \u2264 a < m + n).\nHence, it follows from Eqn. (24) that\n\u03b8\u2265\u03c6\nAlso note that\n\n(25)\n\n\f21\n\n1\na\n\u2265\ncos \u03b8 \u2265\n2m 2\n\u03c0\n\u21d2\u03b8\u2264\n3\nFinally, combining 23, 25, and 26, we have\n\nsince a \u2265 m\n(26)\n\n\u03c0\nA s \u2264 n2 r 2 \u03c6 \u2264 n2 r 2 \u03b8 \u2264 n2 r 2\n3\n\u03c0\n2 2\n= [min(m, n)] r , since m \u2265 n\n3\n\n(27)\n\nHence the claim follows, since the lens L(s)\ni is the region of intersection of a circle of radius ir centred at the\nsource s, and a circle of radius (hmax \u2212 i)r centred at the BS.\nHence, from Equation (22),\n\nFinally,\n\n\uf8eb\n\uf8f6m\u22121\nn2i\n\uf8ec\uf8ec\uf8ec\n\uf8f7\uf8f7\uf8f7\n3\n\uf8f7\uf8f7\uf8f7\nqi = P[Yi = 1|M o = 1, D s > (hmax \u2212 1)r] \u2265 \uf8ec\uf8ec\uf8ec\uf8ec\uf8ed1 \u2212\n,\n(1 \u2212 \u01eb)2 (hmax )2 \uf8f7\uf8f8\n\nni = min(i, hmax \u2212 i)\n\n(28)\n\nE[ROpt |X] \u2265 (1 \u2212 \u03b4)P[Ds > (hmax \u2212 1)r]E[ROpt |Xhmax ], from (18)\nhmax\nX\u22121\n\u2265 (1 \u2212 \u03b4)P[Ds > (hmax \u2212 1)r]\nqi , from (21)\ni=1\n\n\uf8ee\n\uf8ef\uf8ef\n\u2265 \uf8ef\uf8ef\uf8ef\uf8f01 \u2212\n\n\uf8f6m\u22121\n\uf8eb\n!2m \uf8f9\nn2i\nhmax\n\uf8f7\uf8f7\uf8f7\nX\u22121 \uf8ec\uf8ec\uf8ec\n\uf8fa\uf8fa\uf8fa\nhmax \u2212 1\n3\n\uf8f7\uf8f7\uf8f7\n\uf8ec\uf8ec\uf8ec1 \u2212\n\uf8fa\uf8fa\uf8fb (1 \u2212 \u03b4)\n,\n\uf8ec\n2 h2 \uf8f7\n\uf8f8\n\uf8ed\n(1 \u2212 \u01eb)hmax\n(1\n\u2212\n\u01eb)\nmax\ni=1\n\nfrom (28)\n\n(29)\n\nwhere, ni = min(i, hmax \u2212 i).\nIt follows from Lemma 1 and Lemma 2 that:\n\nTheorem 3. The average case approximation ratio of the SPTiRP algorithm over all feasible instances in the\nstochastic setting described earlier is upper bounded as\n\u03b1 \u2264\n\nN\nROpt\n\n(30)\n\nwhere, N is given by the R.H.S of (11), and ROpt is given by the R.H.S of (16).\nVI. Node Cut based ILP Formulation for RST-MR-HC Problem\nWe shall formulate the RST-MR-HC problem as an ILP, using certain node cut inequalities (the approach is\nsimilar to the one presented in [24]). Such a formulation will be useful when the number of potential locations\nis prohibitively large so that a complete enumeration of all possible solutions to obtain the optimal solution (for\ncomparison against the solution provided by the SPTiRP algorithm) is impractical; in such cases, we can solve the\nLP relaxation of the ILP to obtain a lower bound on the optimal solution for comparison with the SPTiRP outcome.\nWe start with a couple of definitions.\nDefinition 1. Given a source and a sink in a graph, a node cut for that source-sink pair is defined as a set of\nnodes whose deletion disconnects the source from the sink [24].\nDefinition 2. A minimal node cut for a source-sink pair is a node cut which does not contain any other node cut\nas its subset [24].\nConsider the graph G = (Q \u222a R, E) (notations same as earlier). We define, \u2200k \u2208 Q\\{0}, \u2200 j \u2208 V\\{k, 0},\n(\n1 if node j is selected to connect source k to the sink\ny j,k =\n0 otherwise\n\n\f22\n\nLet Pk , k \u2208 Q\\{0}, denote the set of paths from source k to the sink in the graph G. A path pk \u2208 Pk from source\nk to sink is said to be selected if y j,k = 1 \u2200 j \u2208 pk . A source k is said to be connected to the sink if at least one\nof the paths in Pk is selected.\nTheorem 4. The following condition is both necessary and sufficient for connectivity of all the sources to the sink:\nX\ny j,k \u2265 1 \u2200\u03b3 \u2208 \u0393k ; \u2200k \u2208 Q\\{0}\n(31)\nj\u2208\u03b3\n\nk\n\nwhere, \u0393 is the set of minimal node cuts for a source node k.\nProof: We shall only prove the sufficiency. The proof of necessity is as given in [24], where they have stated\nthat the above inequality is a valid inequality for the relay node placement problem.\nWe shall prove by contradiction. Suppose, for an assignment of the variables y j,k , \u2200k \u2208 Q\\{0}, \u2200 j \u2208 V\\{k, 0}, the\ninequality (31) holds, but at least one source, say source i, is not connected to the sink.\nTherefore, for the given assignment of the variables y j,i , \u2200 j \u2208 V\\{i, 0}, no path in the set Pi got selected. Therefore,\nfor each path pi \u2208 Pi , there exists at least one node j \u2208 pi such that y j,i = 0. Thus, the set of all such nodes from all\nthe paths in Pi form a node cut for the source i and sink. This node cut will contain a minimal node cut for source\nP\ni\ni\ni and the sink, say, \u03b3violated\nfor which j\u2208\u03b3violated\ny j,i = 0. Thus, inequality (31) is violated for the minimal node cut\ni\n\u03b3violated\n, which is a contradiction of our earlier proposition. Hence, if inequality (31) holds for an assignment of the\nvariables y j,k , \u2200k \u2208 Q\\{0}, \u2200 j \u2208 V\\{k, 0}, then all the sources must be connected to the sink for that assignment of\nvariables.\nWe now formulate the ILP as follows:\nmin\n\nX\n\nyj\n\n(32)\n\nj\u2208R\n\nSubject to:\n\nX\nj\u2208\u03b3\n\nX\n\nj\u2208V\\{k,0}\n\ny j,k \u2265 1\ny j \u2265 y j,k\n\n\u2200\u03b3 \u2208 \u0393k ; \u2200k \u2208 Q\\{0}\n\u2200 j \u2208 R; \u2200k \u2208 Q\\{0}\n\n(33)\n(34)\n\ny j,k \u2264 hmax \u2212 1 \u2200k \u2208 Q\\{0}\n\n(35)\n\ny j,k \u2208 {0, 1} \u2200k \u2208 Q\\{0}; \u2200 j \u2208 V\\{k, 0}\ny j \u2208 {0, 1} \u2200 j \u2208 R\n\n(36)\n(37)\n\nConstraint (33) in the above formulation ensures connectivity from each source to the sink; constraint (34) simply\nsays that a relay node gets selected if it is selected for the path of at least one source; constraint (35) ensures that\na selected path from a source to the sink has no more than hmax hops; constraints (36) and (37) are the integer\nconstraints on the node selection variables. The objective function (32) simply minimizes the total number of relay\nnodes selected.\nWe shall now show that the optimum value of the objective function for the ILP is indeed the same as the\noptimum solution (i.e., the minimum number of relays) to the original RST-MR-HC problem.\nTo do that, we introduce the following notations:\nF = {y = {{y j,k } j\u2208V\\{k,0},k\u2208Q\\{0} , {y j } j\u2208R } : y satisfies constraints (33)-(37)}: set of all feasible solutions to the\nILP\n\u2032\nPk = {pk : pk consists of \u2264 hmax hops from source k to sink} \u2286 Pk : set of all hop count feasible paths\nfrom source k to sink\n\u2032\n|Q|\u22121\n: pk \u2208 Pk }: all possible combinations of hop count feasible paths from the sources to\nU0 = {g , {pk }k=1\nthe sink\nDefine a set F0 in a one-to-one correspondence to the set U0 as follows:\n|Q|\u22121\nFor each g = {pk }k=1\n\u2208 U0 , define x(g) = {{x j,k } j\u2208V\\{k,0},k\u2208Q\\{0} , {x j } j\u2208R } \u2208 F0 such that\n(\n1 if j \u2208 pk\nx j,k =\n0 otherwise\n\n\f23\n\nxj =\n\n(\n\n1 if x j,k = 1 for some k \u2208 Q\\{0}\n0 otherwise\n\nLemma 3. F0 \u2286 F\nProof: Verify that any x \u2208 F0 satisfies constraints (33)-(37).\nP\nP\nCorollary 1. miny\u2208F j\u2208R y j \u2264 min x\u2208F0 j\u2208R x j\n\nObserve that in Corollary 1, the L.H.S is the optimum objective function value of the ILP, whereas the R.H.S is\nthe optimum solution (i.e., the minimum number of relays) for the RST-MR-HC problem. Thus, we have proved that\nthe optimum solution to the ILP is a lower bound to the optimum solution to RST-MR-HC problem.\nLemma 4. For each y \u2208 F , \u2203 x \u2208 F0 such that\n1) x j,k \u2264 y j,k \u2200 j, \u2200k, and hence\nP\nP\n2)\nj\u2208R x j \u2264\nj\u2208R y j\n\n|Q|\u22121\n\u2208 U0 . In doing this,\nProof: Given y \u2208 F , we can construct paths pk \u2208 Pk , k \u2208 Q\\{0} such that g = {pk }k=1\n|Q|\u22121\nwe require constraints (33) and (35) in the definition of F . Now obtain x \u2208 F0 for this g = {pk }k=1\n\u2208 U0 . Observe\nthat x j,k \u2264 y j,k \u2200 j, \u2200k.\nAlso, since the variables are binary, this implies that maxk\u2208Q\\{0} x j,k \u2264 maxk\u2208Q\\{0} y j,k \u2200 j \u2208 R, i.e., x j \u2264 y j \u2200 j \u2208 R.\nFor otherwise, suppose maxk\u2208Q\\{0} x j,k > maxk\u2208Q\\{0} y j,k for some j \u2208 R. Then that would imply, maxk\u2208Q\\{0} x j,k = 1\nand maxk\u2208Q\\{0} y j,k = 0, i.e., for that j \u2208 R, \u2203 k \u2208 Q\\{0} such that x j,k = 1 and y j,k = 0. But this contradicts the fact\nthat x j,k \u2264 y j,k \u2200 j, \u2200k. Hence the conclusion.\nP\nP\nTherefore, it follows that j\u2208R x j \u2264 j\u2208R y j\n\u2032\n\nCorollary 2.\n\nmin\ny\u2208F\n\nX\nj\u2208R\n\ny j \u2265 min\nx\u2208F0\n\nX\n\nxj\n\nj\u2208R\n\nP\nP\nP\n\u2032\n\u2032\nProof: Suppose y = arg miny\u2208F j\u2208R y j . Then, by the above lemma, \u2203x \u2208 F0 such that j\u2208R x j \u2264 j\u2208R yopt, j .\nopt\nP\nP\n\u2032\nBut clearly, min x\u2208F0 j\u2208R x j \u2264 j\u2208R x j . Hence the proof.\n\nTheorem 5.\n\nmin\ny\u2208F\n\nX\nj\u2208R\n\ny j = min\nx\u2208F0\n\nX\n\nxj\n\nj\u2208R\n\nProof: The proof follows by combining Corollaries 1 and 2.\nTheorem 5 states that the optimum value of the objective function for the ILP is indeed the same as the optimum\nsolution (i.e., the minimum number of relays) to the original RST-MR-HC problem.\nTo solve the LP relaxation of this ILP to obtain a lower bound on the optimal solution, we use the algorithm\npresented in [24] (with the Master problem being the ILP represented by Equations (32)-(37)), which uses as a\nsub-program (to find the node cut constraints iteratively), an algorithm presented by Garg et al. [25] in the context\nof node weighted multiway cuts.\nVII. SPTiRP: Numerical Results\nWe performed four sets of experiments to test the SPTiRP algorithm. In all these experiments, the relays and\nthe sources are placed randomly. The first two sets of experiments were performed with a large number of relays,\nin a setting that conforms to the conditions mentioned in Theorem 2, and hence a feasible solution is guaranteed\nwith a high probability. However, due to the large number of relays only a lower bound to the optimal value can\nbe obtained. The third set of experiments were performed with a small number of relays, so that feasibility cannot\nbe assured, but the optimal value can be obtained in every feasible instance. Finally, the fourth set of experiments\nwere performed with a different random graph model (compared to the first three), namely, the Erdos-Renyi random\ngraph model to test the performance of our algorithm on non-geometric input graphs.\nIn experiment sets 1 and 2, we need a large number of potential relay locations to ensure the high probability\nof feasibility. As we had mentioned in Section VI, for such large problem instances, an exhaustive enumeration of\nall possible solutions to obtain the optimal solution is impractical. Hence, for these problem instances, we solved\nthe LP relaxations of the corresponding ILPs to obtain lower bounds on the optimum relay count.\n\n\f24\n\nIn experiment sets 3 and 4, however, the number of potential relay locations, and hence, the problem size was\nmoderate; so we obtained the exact optimum relay count for each instance by an exhaustive enumeration technique,\nstarting with the solution provided by the SPTiRP algorithm. The details are provided below.\nA. Experiment Set 1\nWe generated 100 random networks as follows: we chose rmax = 60 meters, and hmax = 4 for this set of\nexperiments. We also chose \u01eb = \u03b4 = 0.1 (see Theorem 2). For the chosen parameter values and for an area of\n216m \u00d7 216m, the required number of potential relay locations was found to be n(\u01eb, \u03b4, hmax, rmax ) \u2265 1908. Hence,\n1908 potential relay locations were selected uniformly randomly over a 216m \u00d7 216m area. This ensures that\nany point within a distance (1 \u2212 \u01eb)hmax rmax from the BS is at most hmax hops away from the BS with a high\nprobability (\u2265 (1 \u2212 \u03b4) = 0.9). 10 source nodes were deployed uniformly randomly over the quarter circle of radius\n(1 \u2212 \u01eb)hmax rmax = 216m; hence we have a feasible solution with a high probability (\u2265 0.9).\nThe SPTiRP algorithm was run on the 100 scenarios thus generated; none of the 100 scenarios tested turned out\nto be infeasible. For each scenario, a lower bound on the optimum relay count was obtained by solving the LP\nrelaxation of the corresponding ILP formulation as described in Section VI.\nThe results are summarized in Table II.\nTABLE II\nTest Set 1: Performance of the SPTiRP algorithm Compared to Lower Bound on Optimal Solution\nPotential\nRelay\ncount\n1908\n\nScenarios\n\n100\n\nOptimal Design\nmatched with\nlower bound\n23\n\nOff by one\nfrom\nlower bound\n21\n\nMax off\nfrom\nlower bound\n10\n\nObservations\n1) In 44% of the tested scenarios, the algorithm ends up giving optimal or near-optimal (exceeding optimum\njust by one relay) solutions. However, note that the comparison was only against a lower bound on the\noptimal solution, which can potentially be loose depending on the problem scenario, and we suspect the\nactual performance of the algorithm to be much better (indeed, as we shall see in Experiment Set 3 by\ncomparing against the actual optimal solution, the algorithm performed close to optimal in most of the tested\nscenarios).\n2) In the remaining cases, where it is off by more than one relay, the maximum difference from the lower bound\nwas found to be 10 relays.\n3) We computed the empirical worst case approximation factor from the experiments as follows: for each scenario,\nwe computed the approximation factor given by the SPTiRP algorithm w.r.t the lower bound obtained from\nRelayAlgo\n. The maximum of these over all the tested scenarios\nthe LP relaxation as approximation factor = Relaylowerbound\n(in the current set of experiments) was taken to be the (empirical) worst case approximation factor.\n4) We also computed the theoretical bound on the average approximation ratio for the given setting and parameter\nvalues using Equation 30, and compared it against the empirical average case approximation ratio obtained\nfrom the experiments as\nEmpirical average case approx. ratio =\n\nAverage relaycount of SPTiRP over 100 scenarios\n(38)\nAverage lower bound from LP relaxation over 100 scenarios\n\nThe results are summarized in Table III.\nTABLE III\nTest Set 1: Approximation ratio for the SPTiRP algorithm\nPotential\nRelay\ncount\n1908\n\nScenarios\n\n100\n\nWorst case\napproximation ratio\nTheoretical\nExperimental\n30\n5\n\nAverage case\napproximation ratio\nTheoretical bound (Eqn. (30))\nExperimental(Eqn. (38))\n14\n1.66\n\nIn Table IV, we have compared the execution time of the SPTiRP algorithm against the time required to compute\na lower bound on the optimal solution by solving the LP relaxation. Both the algorithms were run in MATLAB\n7.11 on the Sankhya cluster of the ECE Department, IISc, using a single compute node (linux based) with 16\n\n\f25\n\nGB main memory, and a single processor with 4 cores, i.e., 4 CPUs. As can be seen from the table, while the\nSPTiRP algorithm computes a very good (often optimal) solution in at most a few seconds, computing even the\nlower bound on the optimal solution (i.e., solving the LP relaxation instead of the actual ILP) can be actually quite\ntime consuming, running into several hours (upto about 12 hours in the worst case).\nTABLE IV\nTest Set 1: Computation time of the SPTiRP algorithm compared to Optimal solution (lower bound) computation\nPotential\nRelay\nCount\n1908\n\nScenarios\n\nMean execution time\nof SPTiRP\nin sec\n6.6621\n\n100\n\nMean Execution time\nof obtaining\na lower bound on optimal solution\nin sec\n7002\n\nMax execution time\nof SPTiRP\nin sec\n18.4438\n\nMax execution time\nof obtaining\na lower bound on optimal solution\nin sec\n41716\n\nB. Experiment Set 2\nThe setting for this set of experiments is very similar to that in Experiment Set 1, except that now the sources\nwere also deployed over the same square area as the potential relay locations, instead of a quarter circle.\nWe generated 100 random networks as follows: we chose rmax = 60 meters, and hmax = 4 for this set of\nexperiments. We also chose \u01eb = \u03b4 = 0.1. For the chosen parameter values and for an area of 150m \u00d7 150m, the\nrequired number of potential relay locations was found to be n(\u01eb, \u03b4, hmax , rmax ) \u2265 920. Hence, 920 potential relay\nlocations were selected uniformly randomly over a 150m \u00d7 150m area. This ensures that any point within a distance\n(1 \u2212 \u01eb)hmax rmax from the BS is at most hmax hops away from the BS with a high probability (\u2265 (1 \u2212 \u03b4) = 0.9). 10\nsource nodes were deployed uniformly randomly over the 150m \u00d7 150m area. Note that all the sources are within\na radius (1 \u2212 \u01eb)hmax rmax = 216 meters from the BS, since the diagonal of the deployment area is less than 216\nmeters; hence we have a feasible solution with a high probability (\u2265 0.9).\nThe SPTiRP algorithm was run on the 100 scenarios thus generated; none of the 100 scenarios tested turned out\nto be infeasible. For each scenario, a lower bound on the optimum relay count was obtained by solving the LP\nrelaxation of the corresponding ILP formulation as described in Section VI.\nThe results are summarized in Table V.\nTABLE V\nTest Set 2: Efficiency of the SPTiRP algorithm in obtaining the optimal design\nPotential\nRelay\ncount\n920\n\nScenarios\n\n100\n\nOptimal Design\nw.r.t\nlower bound\n82\n\nOff by one\nfrom\nlower bound\n15\n\nMax off\nfrom\nlower bound\n2\n\nObservations\n1) In over 97% of the tested scenarios, the algorithm ends up giving optimal or near-optimal (exceeding optimum\njust by one relay) solutions.\n2) In the remaining cases, where it is off by more than one relay, the maximum difference was found to be 2\nrelays.\n3) We computed the empirical worst case approximation ratio in the same manner as was done in Experiment\nSet 1.\n4) We also computed the theoretical bound on the average approximation ratio for the given setting and parameter\nvalues using Equation 30, and compared it against the empirical average case approximation ratio obtained\nfrom the experiments as was done in Experiment Set 1.\nThe results are summarized in Table VI.\nTABLE VI\nTest Set 2: Approximation ratio for the SPTiRP algorithm\nPotential\nRelay\ncount\n920\n\nScenarios\n\n100\n\nWorst case\napproximation ratio\nTheoretical\nExperimental\n30\n2\n\nAverage case\napproximation ratio\nTheoretical bound (Eqn. (30))\nExperimental (Eqn. (38))\n14\n1.13\n\n\f26\n\nIn Table VII, we have compared the execution time of the SPTiRP algorithm against the time required to compute\na lower bound on the optimal solution by solving the LP relaxation. Both the algorithms were run in MATLAB\n7.11 on the Sankhya cluster of the ECE Department, IISc, using a single compute node (linux based) with 16 GB\nmain memory, and a single processor with 4 cores, i.e., 4 CPUs. As can be seen from the table, while the SPTiRP\nalgorithm computes a very good (often optimal) solution in at most a few seconds, computing even the lower bound\non the optimal solution (i.e., solving the LP relaxation instead of the actual ILP) was quite time consuming, running\nwell beyond an hour.\nTABLE VII\nTest Set 2: Computation time of the SPTiRP algorithm compared to Optimal solution (lower bound) computation\nPotential\nRelay\nCount\n920\n\nScenarios\n\n100\n\nMean execution time\nof SPTiRP\nin sec\n2.4222\n\nMean execution time\nof obtaining\na lower bound on optimal solution\nin sec\n2489.2\n\nMax execution time\nof SPTiRP\nin sec\n5.5684\n\nMax execution time\nof obtaining\na lower bound on optimal solution\nin sec\n5902.4\n\nC. Experiment Set 3\nIn this set of experiments we deployed a smaller number of relays randomly. Due to the small number of relays,\nthe probabilistic analysis of feasibility is not useful. We generated 1000 random networks as follows: A 150m\u00d7150m\narea is partitioned into square cells of side 10m. Consider the lattice created by the corner points of the cells. 10\nsource nodes are placed at random over these lattice points. Then the potential relay locations are obtained by\nselecting n points uniformly randomly over the 150m \u00d7 150m; n was varied from 100 to 140 in steps of 10, and\nfor each value of n, we generated 200 random network scenarios (thus yielding 1000 test cases). We chose rmax =\n60 meters, and hmax = 6 for the experiments.\nGiven the outcome of the SPTiRP algorithm, an optimal solution can be obtained as follows: Suppose the SPTiRP\nuses n relays. Then perform an exhaustive search over all possible combinations of (n \u2212 1) and fewer relays to\ncheck if the performance constraints can still be met.\nIn none of the 1000 scenarios tested, the hop constraint turned out to be infeasible.The results are summarized\nin Table VIII.\nTABLE VIII\nTest Set 3: Efficiency of the SPTiRP algorithm in obtaining the optimal design\nPotential\nRelay\ncount\n100\n110\n120\n130\n140\nTotal\n\nScenarios\n\nOptimal Design\n\nOff by one\n\n200\n200\n200\n200\n200\n1000\n\n154\n154\n158\n155\n161\n782\n\n42\n40\n39\n36\n38\n195\n\nMax off\nfrom\noptimal\n3\n2\n2\n2\n2\n3\n\nThe efficiency of the algorithm can be easily visualized from the pie chart in Figure 10.\nObservations\n1) As in the case of test set 1, even for test set 2, in over 97% of the tested scenarios, the algorithm ends up\ngiving optimal or near-optimal (exceeding optimum just by one relay) solutions.\n2) In the remaining cases, where it is off by more than one relay, the maximum difference was found to be 3\nrelays.\nIn Table X, we have compared the execution time of the SPTiRP algorithm against the time required to compute\nan optimal solution, given the outcome of the SPTiRP algorithm. Both the SPTiRP algorithm, and the postprocessing\non its outcome were run in MATLAB 7.0.1 on a Windows Vista (basic) based PC (Dell Inspiron 1525) having Intel\nCore 2 Duo T5800 CPU with processor speed of 2 GHz, and 3 GB RAM. Again, while the SPTiRP algorithm\ncomputed a very good (often optimal) solution in at most a second or two (averaging less than a second), computing\nthe optimal solution even after being provided with a very good upper bound on the required number of relays by\nSPTiRP, turned out to be quite time consuming, running into several minutes.\n\n\f27\n\n2.3%\n\n19.5%\n\n78.2%\n\nFig. 10. Efficiency of the Algorithm as suggested by Test Results; Red: SPTiRP gives optimal solution; Yellow: SPTiRP is off from optimum\nby one relay; Green: SPTiRP off from optimum by 2 or more relays\nTABLE IX\nTest Set 3: Computation time of the SPTiRP algorithm compared to Optimal solution computation\nPotential\nRelay\n\nScenarios\n\nCount\n100\n110\n120\n130\n140\nOverall\n\n200\n200\n200\n200\n200\n1000\n\nMean execution time\nof SPTiRP\nin sec\n0.58812\n0.70544\n0.81154\n0.99343\n1.1438\n0.84847\n\nMean execution time\nof directly obtaining\nan optimal solution\nin sec\n661.485\n240.85\n423.89\n951.495\n140.7\n483.684\n\nMax execution time\nof SPTiRP\nin sec\n1.638\n2.081\n1.591\n2.606\n2.808\n2.808\n\nMax execution time\nof directly obtaining\nan optimal solution\nin sec\n1828.7\n722.29\n944.74\n2674.9\n355.46\n2674.9\n\nAlso, we note from Table X that, as the node density increases, the computation time of the SPTiRP algorithm\nalso increases.\nD. Experiment Set 4\nThis set of experiments were performed using the Erdos-Renyi random graph model to generate the input graphs.\nWe generated 500 random networks as follows: A 150m \u00d7 150m area is partitioned into square cells of side 10m.\nConsider the lattice created by the corner points of the cells. 10 source nodes are placed at random over these\nlattice points. Then the potential relay locations are obtained by selecting n points uniformly randomly over the\n150m \u00d7 150m; n was varied from 100 to 140 in steps of 10, and for each value of n, we generated 100 random\nnetwork scenarios (thus yielding 500 test cases). For each instance, the edges in the input graph were selected iid\nwith probability 0.5, i.e., for each possible (unordered) node pair (i, j), the edge (i, j) was chosen to be a feasible\nedge with probability 0.5. We chose hmax = 6 for the experiments. Note that apart from the method used for creating\nthe feasible edges, the setting is similar to that in Experiment Set 3.\nGiven the outcome of the SPTiRP algorithm, an optimal solution can be obtained in the same manner as in\nExperiment Set 3.\nIn none of the 500 scenarios tested, the hop constraint turned out to be infeasible. Our observations are summarized\nbelow.\nObservations:\n1) In each of the 500 test cases, the SPTiRP algorithm returned an optimal solution.\n2) In 491 cases, no relay was required. In the remaining cases, only one relay was required.\nIn Table X, we have presented the execution time of the SPTiRP algorithm. Note that since the outcome of the\nalgorithm in all the test cases were zero or one relay, computing the optimum solution given the outcome of the\nalgorithm was trivial. The SPTiRP algorithm was run in MATLAB R2011b on a Windows Vista (basic) based PC\n(Dell Inspiron 1525) having Intel Core 2 Duo T5800 CPU with processor speed of 2 GHz, and 3 GB RAM.\n\n\f28\n\nTABLE X\nTest Set 4: Computation time of the SPTiRP algorithm\nPotential\nRelay\nCount\n100\n110\n120\n130\n140\nOverall\n\nScenarios\n\n100\n100\n100\n100\n100\n500\n\nMean execution time\nof SPTiRP\nin sec\n0.1199\n0.1144\n0.1279\n0.1204\n0.1408\n0.1247\n\nMax execution time\nof SPTiRP\nin sec\n0.4412\n0.4403\n0.3767\n0.2681\n0.3675\n0.4412\n\nVIII. SPTiRP: Simulation Results\nTo test the QoS under positive traffic arrival rates, of the network topologies obtained using SPTiRP algorithm,\nwe performed extensive simulations using Qualnet v4.5 [26]. For these simulations, we assumed the PHY and MAC\nlayers to be as specified in the IEEE 802.15.4 standard[4].\nWe generated 20 network topologies as follows: in each case, 10 source nodes, and 120 potential relay locations\nwere randomly selected in a 150m \u00d7 150m area in exactly the same way as described in Section VII-C. As before,\nthe BS was assumed to be at the corner (0, 0). We chose the maximum communication range, rmax = 30 meters,\nwhich, for a transmit power of 0 dBm, and a PHY layer packet size of 131 bytes, corresponds to a PER of \u2264 1%,\nassuming the path loss model given in the standard [4], [27], a fade margin of 20 dB, and receiver sensitivity of\n\u221298.8 dBm. The hop constraint was chosen as hmax = 9, which, for a PER of 1%, corresponds to an end-to-end\ndelivery probability of 91.35% (under the lone packet model), and an end-to-end mean delay of 56.16 msec, also\nunder the lone packet model, assuming the CSMA/CA backoff parameters given in the standard, and a PHY layer\npacket size of 131 bytes (see [5] for details of how this mean end-to-end delay can be computed). Having chosen\nrmax , we had a graph on the sources, and the potential relay locations. We used the SPTiRP algorithm on this\nnetwork graph with the above mentioned hop constraint, to obtain a tree topology connecting the sources to the\nBS using a small number of relays, and satisfying the hop constraint.\nQualnet simulation was performed on each of the 20 network topologies thus generated, for six different traffic\narrival rates, namely, \u03bb =0.1, 0.2, 0.3, 0.4, 0.5, and 2 packets/sec from each source. The arrival process was\nassumed to be Poisson. The simulation procedure is described below:\n1) We used the following interference model in Qualnet: any two nodes that are within Carrier Sense (CS) range\nof each other can hear each other's transmission. If two nodes are within the CS range of a receiver node,\nthen their transmissions interfere with each other at the receiver node. The CS range, rcs , was set equal to\nrmax for the simulations (see above).\n2) We used the collision model in Qualnet to account for packet losses due to interference. If two or more packet\ntransmissions interfere with one another at a receiver node, then all of those packets are lost.\n3) For each topology, and each arrival rate, the simulation was repeated for 25 iterations, with each iteration\nbeing run for 1500 seconds of simulated time..\n4) For each topology, and each arrival rate, we recorded the end-to-end delivery probability (we shall use the\nshorthand pdel for this from now on, with slight abuse of notation) from each source to the sink, averaged\nover the 25 iterations, and the mean end-to-end packet delay from each source to the sink, also averaged over\n25 iterations.\nThe results are summarized in Table XI. To keep the table concise, we have adopted the following strategy:\nfor each arrival rate and each topology, we have computed pdel averaged over the 10 sources, and reported\nonly the minimum average pdel for each rate, the minimum being taken over the 20 scenarios. This constitutes\ncolumn 3 of Table XI. A similar strategy has been adopted for reporting the end-to-end delay (column 6 of\nthe table). We have also reported the minimum pdel and the maximum delay encountered over all sources and\nall the 20 scenarios for each rate (columns 2 and 5 respectively), and the maximum pdel and the minimum\ndelay encountered over all sources and scenarios for each rate (columns 4 and 7 respectively).\nObservations:\n1) From Table XI, we observe that the mean end-to-end delay never exceeded the lone-packet target end-to-end\ndelay of 56.16 msec.\n\n\f29\n\nTABLE XI\nSummary of Qualnet simulation results for 20 network topologies\nArrival\nrate\nin pkts/sec\n0.1\n0.2\n0.3\n0.4\n0.5\n2.0\n\nMinimum\npdel\n\nMinimum\naverage pdel\n\nMaximum\npdel\n\n0.874\n0.860\n0.846\n0.826\n0.802\n0.557\n\n0.905\n0.893\n0.879\n0.865\n0.848\n0.667\n\n0.982\n0.980\n0.981\n0.980\n0.978\n0.967\n\nMaximum\ndelay\nin sec\n0.0509\n0.0510\n0.0511\n0.0513\n0.0514\n0.0535\n\nMaximum\naverage delay\nin sec\n0.0401\n0.0401\n0.0402\n0.0403\n0.0404\n0.0417\n\nMinimum\ndelay\nin sec\n0.0113\n0.0113\n0.0113\n0.0114\n0.0114\n0.0117\n\n2) For low arrival rates, the minimum pdel violated the lone-packet target pdel only by a small margin. For each\nrate, we quantify this margin of violation as follows:\nPercentage violation in pdel =\n\nLone-packet target pdel \u2212 Minimum pdel under current arrival rate\n\u00d7 100\nLone-packet target pdel\n\nThese results are summarized in Table XII.\nTABLE XII\nProximity of positive traffic QoS to lone-packet target QoS\nArrival\nrate\nin pkts/sec\n0.1\n0.2\n0.3\n0.4\n0.5\n2.0\n\nMaximum percent violation in pdel\nw.r.t lone-packet target\n(over the 20 scenarios tested)\n4.3721\n5.8784\n7.3715\n9.5948\n12.1749\n39.0019\n\n3) From Table XII, we note that the tested network topologies, although designed for the lone-packet model,\ncan handle light positive traffic arrival rate (upto 0.4 packets/sec) from each source, without exceeding the\nlone-packet QoS by more than 10%.\nIX. RSNk-MR-HC: Complexity of Obtaining a Feasible Solution\nWe have already seen that the RSNk-MR-HC problem is NP-Hard. In this Section, we shall show that even the\nproblem of obtaining a feasible solution (as opposed to an optimal solution) to the RSNk-MR-HC problem is NPComplete. Hence, we cannot hope for a polynomial time approximation algorithm for the general RSNk-MR-HC\nproblem, and have to resort to developing good heuristics instead.\nLemma 5. Given a graph G = (V, E), specified vertices s and t, positive integers k \u2265 2, and H \u2264 |V|. The problem\nto determine if G contains k or more mutually vertex disjoint paths from s to t, none involving more than H edges\nis NP-Complete for all fixed H \u2265 5.\nProof: See [Itai, Perl, and Shiloach, 1977]. The proof there is via transformation from 3 Satisfiability.\nCorollary 3. Given an edge weighted graph G = (V, E), with V = Q \u222a R, the problem of finding a subgraph with\nk \u2265 2 vertex disjoint paths from each source node to sink such that each path has hop count \u2264 hmax (RSNk-HC) is\nNP-Complete.\nProof: From Lemma 5, it follows that this problem is NP-Complete for any hmax \u2265 5. Hence, the general\nproblem is NP-Complete.\nCorollary 4. Unless P = NP, there does not exist any polynomial time complexity algorithm for providing a feasible\nsolution to the RSNk-MR-HC problem.\nCorollary 5. Unless P = NP, no polynomial time complexity algorithm can provide finite approximation guarantee\nfor the general RSNk-MR-HC problem.\n\n\f30\n\nProof: Suppose, in a certain instance of the RSNk-MR-HC problem, the source nodes alone are sufficient\nto meet the design requirements, i.e., there exist node disjoint hop constrained paths from each source to the\nsink, involving only other source nodes, and no additional relay nodes. But, from Corollary 3, it follows that no\npolynomial time algorithm is guaranteed to predict the existence of such a solution even when there exists one.\nTherefore (unlike the SPTiRP algorithm which uses zero relays whenever the optimal solution uses zero relays),\nin this case, one might end up using a non zero number of relay nodes despite the fact that the optimal solution\nuses zero relays. Hence, for the general RSNk-MR-HC problem, a polynomial time algorithm cannot provide finite\napproximation guarantee.\nX. E-SPTiRP: A Polynomial Time Heuristic for RSNk-MR-HC\nWe propose Extended SPTiRP, a polynomial time heuristic for the RSNk-MR-HC problem, which builds on the\nSPTiRP algorithm for one connectivity, described in Section V. Before we discuss the algorithm, we describe below\ntwo limitations that are common to any polynomial time algorithm for the RSNk-MR-HC problem.\nRecall from the proof of Corollary 5 that no polynomial time algorithm for the RSNk-MR-HC problem is\nguaranteed to predict the existence of a solution involving only the source nodes whenever such a solution exists.\nAlso, from Corollary 4, it follows that unless P = NP, no polynomial time algorithm for the RSNk-MR-HC\nproblem is guaranteed to find a feasible solution whenever there exists one. Therefore, if a polynomial time heuristic\nfor the RSNk-MR-HC problem fails to find a feasible solution, we shall say that the problem is possibly infeasible.\nHowever, note that it is possible to determine, in polynomial time, if the corresponding RST-MR-HC problem\n(i.e., the problem of obtaining a one-connected, hop constrained subgraph) is feasible (simply by computing the\nshortest path tree, and checking if the paths from the sources to the sink therein meet the hop count bound). Hence,\nif we cannot find even one path with desired hop count bound from some of the sources to the sink, then the problem\nis actually infeasible.\nA. Algorithm E-SPTiRP\nSince the algorithm consists of many steps, we organize the presentation of the algorithm as follows: we shall\nfirst present the key steps of the algorithm in Section X-A1. Then, each key step will be explained in more detail\nalong with pseudo code in the subsequent subsections.\n1) Main Idea/Key Steps in the Algorithm: Given G = (V, E), where V = Q \u222a R, connectivity requirement k, and\nhop constraint hmax\n1) Phase 1: Checking for k-connectivity on Q alone\nCheck for k connectivity with hop constraint on Q alone\n\u2022 If the answer to this step is positive, done\n\u2022 Else go to the next step\nSee Section X-A2, Steps 1-6 of the pseudo code for details of this phase.\n2) Phase 2: Obtaining node-disjoint paths, with a small relay count, from each source to the sink We come\nto this phase if Phase 1 fails to find a network on Q alone satisfying the design objectives. Our objective\nin this phase is to obtain k node disjoint, hop constrained paths from each source to the sink, using as few\nadditional relays as possible. To that end, we proceed as follows.\na) Obtaining a one-connected, hop constrained network: Run the SPTiRP algorithm on the entire graph\nof sources and potential relay locations, to obtain a one connected hop constrained network with a small\nnumber of relays. If this step completes successfully, we get a hop constrained path from each source\nto the sink.\n\u2022 If the SPTiRP algorithm returns failure, we can declare the problem to be infeasible, and stop, as we\ncould not even obtain a one connected network satisfying the hop constraint.\nSee Section X-A3, Steps 1-2 of the pseudo code for more details.\nb) Obtaining alternate node disjoint, hop constrained routes: Next, for each source, we aim to obtain\nan alternate node disjoint hop count feasible path to the sink.\n\u2022 If we fail to find an alternate hop count feasible node disjoint route for some of the sources, we\ndeclare the problem to be possibly infeasible, and stop.\nDetails of this step are provided in Section X-A3, Steps 3-11 of the pseudo code.\n\n\f31\n\nc) Relay pruning: If we can find an alternate hop count feasible node disjoint route from a source to the\nsink, we start with that feasible solution, and aim to prune relays, while retaining hop count feasibility,\nin order to obtain a better solution in terms of relay count.\n\u2022 we pursue a relay pruning strategy wherein, we aim to prioritize the reuse of relays used by the\nsolution so far, and minimize the use of relays that are unused as yet. See Section X-A3, Steps 12-16\nof the pseudo code for detailed procedure.\nd) This procedure is repeated until all the sources have k node disjoint hop constrained paths to the sink,\nor the problem has been declared (possibly) infeasible.\nNext, we explain each of the above steps in more details.\n2) Phase 1: Checking for k-connectivity on Q alone: In this phase, we shall check if the design objectives (k\nconnectivity with hop constraint) can be met using only the source nodes, and no additional relays. In other words,\nwe aim at finding k node disjoint hop constrained paths from each source to the sink, using only other source\nnodes.\nInput: G Q = (Q, E Q ), hmax , k\ncomment: E Q is the set of all edges of length \u2264 rmax\non Q\nOutput: T (the desired network)\nflags: boolean Fin f (if Fin f = 1, no feasible solution\nfound)\nInitialize: T = \u2205, Fin f = 0\nOuter loop: for each source S i , 1 \u2264 i \u2264 |Q| \u2212 1\n(comment: the following steps will be repeated for\neach source)\nStep 1: Q = {S i , 0}; R = Q\\Q\nRemark: For each source, we treat all the other sources as relays (the set R), and try to obtain k node disjoint hop\nconstrained paths from the source to the sink, using the nodes in R.\nStep 2: l = 1 (l is the loop variable for the inner loop,\ndescribed next)\nInner loop: while l \u2264 k (comment: the following\nsteps (Steps 3 to 6) will be repeated until we have k\nnode disjoint paths from source i to sink)\nStep 3: pathmax (S i , 0) \u2190 S PT iRP(Q \u222a R, E Q )\nRemark: Treating the remaining sources as relays, we run the SPTiRP algorithm to obtain the lth node disjoint\npath (pathmax (S i , 0)) from source i to sink; the reason for using the SPTiRP algorithm is to use as few nodes as\npossible from the set R, so that there are enough nodes left to construct the (l + 1)th node disjoint path in the next\niteration of the inner loop.\nStep 4: if hopcount(pathmax(S i , 0)) > hmax\n{Fin f \u2190 1;\nexit Phase 1}\nelse go to next Step\nRemark: Note that if the hop constraint cannot be met in the first iteration (of the inner loop) itself (i.e., for l = 1),\nit implies that that the shortest path from source i to sink using only the other source nodes does not satisfy the hop\nconstraint. Then, we can conclude for sure that the design objectives cannot be met using only the source nodes,\nand we can proceed to Phase 2 of the algorithm.\nHowever, if the hop constraint is met in the first iteration, and cannot be satisfied in some subsequent iteration\n(i.e., for some l > 1), we cannot conclude for sure that Q alone was not sufficient to meet the design requirements\n(recall Corollary 3, and our discussion at the beginning of Section X). All we can say at this point is that Phase 1\nof our algorithm failed to find a feasible solution on Q alone, and therefore, we shall proceed to the next phase of\nthe algorithm, assuming that the problem on Q alone is possibly infeasible.\n\n\f32\n\nStep 5: T \u2190 T \u222a pathmax (S i , 0)\ncomment: We augment the network with the current\nfeasible path.\nStep 6: Rused \u2190 R \u2229 pathmax (S i , 0)\nR \u2190 R\\Rused\nl\u2190l+1\ncomment: We identify the nodes in R used in the\ncurrent path from source i to sink, and remove them\nfrom R before proceeding to the next iteration of the\ninner loop.\nRemark: The above step is necessary since in each iteration, we need to identify node disjoint paths from the\nsource to the sink.\nAt the end of Phase 1, we either have a network T , consisting only of the source nodes, and meeting the design\nrequirements (in which case, we are done), or we find that the problem on Q alone is possibly infeasible (Fin f = 1),\nin which case, we proceed to Phase 2 of the algorithm.\n3) Phase 2: Obtaining node-disjoint paths from each source to the sink with a small relay count: We come\nto this phase if phase 1 fails to find a network on Q alone satisfying the design objectives. Our objective in this\nphase is to obtain k node disjoint hop constrained paths from each source to the sink, using as few additional relays\nas possible. To that end, we proceed as explained in Section X-A1.\nWe present below, the detailed pseudo code for this phase, along with necessary remarks, and explanations.\nInput: G = (V, E), hmax , k\ncomment: V = Q \u222a R, and E is the set of all edges\nof length \u2264 rmax on Q \u222a R.\nOutput: T (the desired network)\nflag: boolean Fin f (if Fin f = 1, problem is (possibly)\ninfeasible)\nInitialize: T = \u2205, Fin f = 0\nStep 1: (T, Fin f ) \u2190 S PT iRP(G)\nRemark: We run the SPTiRP algorithm on G to obtain a one connected hop constrained network with as few relays\nas possible.\nStep 2: if Fin f = 1\nexit Phase 2\nelse go to the next step\nRemark: If the SPTiRP algorithm fails to meet the hop constraint for some of the sources, we declare the problem\nto be infeasible, and stop. Otherwise, we proceed to find alternate node disjoint hop constrained paths from each\nof the sources to the sink, as below.\nStep 3: Q \u2190 sort(Q) in decreasing order of Euclidean\ndistance from the sink\nRemark: We arrange the sources in decreasing order of their Euclidean distances from the sink; we shall start the\nalternate route determination procedure with the farthest source and proceed in that order. The logic behind this\napproach is as follows:\n\u2022 Farther sources are likely to consume more relays.\n\u2022 So meet their need first.\n\u2022 As we consider sources closer to the sink, coax these sources to share the already used relays.\n\n\f33\n\nStep 4: n = 2 (comment: n is the loop variable for\nthe outer loop to be defined next; n keeps track of the\nnumber of node disjoint paths discovered, including\ncurrent iteration)\nOuter loop: while n \u2264 k (comment: the following\nsteps will be repeated until all the sources have k\nnode disjoint hop constrained paths to the sink)\nStep 5: L(r) \u2190 R \u2229 T\nR \u2190 R\\L(r)\nRemark: In the nth iteration of the outer loop, we shall try to obtain the nth node disjoint, hop constrained path\nfrom each source to the sink, using as few relays as possible.\nWe define a Locked set L(r) as the set of relays used so far in the course of the network design algorithm (and\nhence, are part of the final desired network). For example, at the start of the n(th) iteration (n = 2, . . . , k), L(r) consists\nof the relays used in the first (n \u2212 1) node disjoint paths from each of the sources to the sink.\nWe also define a free relay set, R, as the set of relays not used so far in the network design.\nTherefore, in our attempt to minimize the number of additional relays used, we shall try to reuse relays from\nthe Locked set L(r) whenever possible, and try to minimize the use of relays from the free relay set. With this in\nmind,we proceed to obtain the alternate node disjoint paths from each source to the sink as below.\nStep 6:\nInner loop: for each source S i \u2208 Q, 1 \u2264 i \u2264 |Q| \u2212 1\n(comment: The following steps will be repeated for\neach source, starting with the source farthest from the\nsink)\nStep 7: Viused \u2190 V \u2229 {\u222an\u22121\nl=1 pathmax (S i , 0)}\nRemark: We designate by pathmax (S i , 0), the lth node disjoint hop constrained path from source S i to sink (1 \u2264 l \u2264 k).\nIn Step 7, we identify the set of nodes (designated by Viused ) used by the first n \u2212 1 node disjoint paths from source\nS i to sink. Since we want to find another node disjoint path from source S i to sink in the current (nth ) iteration (of\nthe outer loop), we need to remove the set of vertices, Viused , except S i and 0, from consideration for the nth path\nbefore proceeding further in the current iteration. We do that in the next step.\nNote that at the end of Steps 7 to 11, we shall either have a feasible solution for the nth node disjoint path from\nsource S i to sink, or we shall end up with possible infeasibility.\nStep 8: Vi(r) \u2190 {V\\Viused } \u222a {S i , 0}\nRemark: Vi(r) is the set of vertices not used in the first n \u2212 1 paths from source S i to the sink, and therefore,\neligible to be part of the nth node disjoint path from source S i to sink.\nStep 9: Gni \u2190 restriction of G to Vi(r)\nRemark: In order to obtain the nth node disjoint path from source S i to sink, we restrict the graph G to the\neligible node set Vi(r) .\nStep 10: pathnsh (S i , 0) \u2190 S PT (Gni )\n\nStep 11: if hopcount(pathnsh(S i , 0)) > hmax\n{Fin f \u2190 1;\nexit Phase 2}\nelse go to the next Step\n\nRemark:\n1) If pathnsh (S i , 0), the shortest path from source S i to sink in Gni , does not meet the hop constraint, we declare\nthe problem to be possibly infeasible, and stop, as we have failed to obtain a feasible solution for the nth\n\n\f34\n\nnode disjoint path (1 < n \u2264 k) from source S i to sink. If hop constraint is satisfied by pathnsh (S i , 0), we have\na feasible solution for the nth node disjoint path from source S i to sink, and we proceed to the next step to\nprune relays from this feasible solution in order to achieve a better solution in terms of relay count.\n(r)\n(r)\nStep 12: L(r)\ni \u2190 L \u2229 Vi\n(r)\n(r)\nQi \u2190 Q \u2229 V i\nth\nRemark: We designate by L(r)\ni , the members of the locked relay set that are eligible to be part of the n node\n(r)\ndisjoint path from source S i to sink. Similarly, Qi denotes the set of source nodes that are part of the eligible\n(r)\n(r)\nnode set Vi(r) . Note that, apart from the sets L(r)\ni and Qi , the only other component of the eligible node set Vi is\n(r)\n(r)\n(r)\nthe free relay set, R, i.e., Vi = Li \u222a Qi \u222a R.\nNow, in our attempt to minimize the number of relays used, we shall try to prune one at a time, the free relays (i.e.,\nrelays in R) that are part of the initial feasible path, pathnsh (S i , 0), and try to obtain an alternate hop constrained\npath, reusing the relays in the eligible locked set L(r)\ni as much as possible. We explain this procedure in the next\nsteps.\n\nStep 13: Ri \u2190 R \u2229 pathnsh (S i , 0)\nRemark: We identify as Ri , the set of free relays that are part of the initial feasible solution, pathnsh (S i , 0), for the\nnth node disjoint path from source S i to sink. To reduce the relay count, we shall try to prune the relays in Ri one\nat a time, while maintaining the hop constraint.\n(r)\nStep 14: Vi \u2032(r) \u2190 Q(r)\ni \u222a Li \u222a Ri\n(r)\nn\nGi \u2032 \u2190 restriction of Gi to Vi \u2032(r) (comment: After\npruning a relay from the initial feasible path, we shall\nsearch for a hop constrained path over this graph, and\nnot over Gni ).\n\nRemark: After pruning a \"free\" relay from the feasible path, pathnsh (S i , 0), we shall search for a better path (in\nterms of relay count) using only the remaining free relays in pathnsh (S i , 0), and the locked relays and sources in\nVin , irrespective of whether they are part of pathnsh (S i , 0). In other words, we shall restrict our search space for the\nhop constrained path to the graph Gi \u2032(r) , thereby disallowing the use of free relays that are not part of pathnsh (S i , 0),\nwhile still allowing the use of (eligible) locked relays and sources even if they are not part of the initial feasible\npath. The idea behind this selection of search space is as follows:\nsh\n\u2022 Restricting the search space to only the free relays in pathn (S i , 0) ensures reduction in relay count, if we can\nfind a hop constrained path after relay pruning.\n(r)\n(r)\n\u2022 Since the relays in Li , and the sources Qi are already part of the final desired network, their inclusion in\nthe current search space does not contradict our objective of reducing relay count, but helps by improving the\nchance of finding a hop constrained path after pruning a free relay.\n\u2022 This selection of search space, thus, enforces the reuse of relays in Locked set, while trying to avoid the use\nof free relays, thereby improving the relay count.\nStep 15: for each node j \u2208 Ri (comment: the\nfollowing sub steps will be repeated until no more\nrelay pruning from the set Ri is possible without\nviolating the hop constraint)\nStep 15a: T empPath(S i , 0) \u2190 S PT (Gi \u2032(r) \\ j)\nRemark: With slight abuse of notation, we designate by Gi \u2032(r) \\ j, the restriction of the graph Gi \u2032(r) to the node\nset Vi \u2032(r) \\ j. After pruning a relay j, we obtain the shortest path (T empPath(S i, 0)) from source S i to sink, using\nthe remaining vertices in Vi \u2032(r) .\n\n\f35\n\nStep 15b: if hopcount(T empPath(S i, 0)) > hmax\ncontinue; (comment: Go back to Step 15, and\ntry pruning the next relay in Ri )\nelse go to next Step\nRemark: If the shortest path from S i to sink in Gi \u2032(r) after pruning relay j does not satisfy the hop constraint, we\nreplace back the relay j, and try pruning the next relay in Ri .\nStep 15c: pathn (S i , 0) \u2190 T empPath(S i , 0)\nVi \u2032(r) \u2190 Vi \u2032(r) \\ j\nRi \u2190 Ri \\ j\nGi \u2032(r) \u2190 restriction of Gni to Vi \u2032(r)\nRemark: If relay j can be pruned successfully without violating the hop constraint, we update the nth node disjoint\npath, pathn (S i , 0), and the sets Vi \u2032(r) (the set of vertices to be part of the search space for a feasible path) and Ri\n(the set of free relays to be pruned) as above before proceeding to the next iteration of the loop (i.e., before pruning\nthe next relay in Ri ).\nNote that since relay j has been pruned, the updated candidate path will have at least one relay less than the\nrelay set used by the initial feasible path, pathnsh (S i , 0).\nStep 16: T \u2190 T \u222a pathn S i , 0\nL(r) \u2190 L(r) \u222a {R \u2229 pathn S i , 0}\nR \u2190 R\\L(r)\nEnd of Inner loop\nRemark: After obtaining the nth node disjoint, hop constrained path from a source S i to the sink using as few\nrelays as possible, we augment the network T with the path from source S i to sink, namely, pathn (S i , 0). Also,\nbefore proceeding to the next source (i.e., the next iteration of the inner loop), we update the Locked relay set with\nthe new relays used in pathn (S i , 0); the free relay set R is also updated accordingly.\nStep 17: n \u2190 n + 1\nEnd of Outer loop\nRemark: When we have obtained a node disjoint, hop constrained path from all the sources to the sink in the\ncurrent iteration (of the outer loop), we proceed to the next iteration of the outer loop.\nEnd of pseudo code for E-SPTiRP\nRemarks:\nTwo ideas play a key role in improving the performance of the E-SPTiRP algorithm, namely,\n\u2022 prioritizing the reuse of relays already used by the solution thus far (see Section X-A3, Step 5 of the pseudo\ncode).\n\u2022 ordering the sources in order of their distances from the sink, and searching for alternate path starting with\nthe farthest source (see Section X-A3, Step 3 of the pseudo code).\nTo demonstrate that these two ideas do improve performance, we devised another empty algorithm which mimics\nmost of the steps of the E-SPTiRP algorithm, except that, while finding alternate node disjoint routes for the sources,\n\u2022 We did not put any emphasis on the reuse of relays\n\u2013 that are already part of the one connected network that is obtained in Step 1 of Phase 2\n\u2013 relays that have been used to construct alternate routes for the previous sources\n\u2022 We did not impose any ordering on the sources according to their distances from the BS.\nThe details of the dummy algorithm are presented in Section X-B. As we shall see in Section XI, the performance\nof this dummy algorithm was significantly worse compared to that of E-SPTiRP in terms of relay count.\nB. Dummy Algorithm\n1) Phase 1: Checking for k-connectivity on Q alone:\n\u2022 We aim at finding k node disjoint, hop constrained paths from each source to the sink, using only other source\nnodes.\n\n\f36\n\nThe procedure, and the conclusions are the same as in E-SPTiRP.\nIf hop constraint is met for all sources, we are done. No relays required for k-connectivity. Else, proceed to\nthe next phase.\n2) Phase 2: Obtaining node-disjoint paths from each source to the sink with a small relay count: We come\nto this phase if Phase 1 fails to find a network on Q alone satisfying the design objectives. Our objective in this\nphase is to obtain k node disjoint hop constrained paths from each source to the sink, using as few additional relays\nas possible.\n\u2022\n\n\u2022\n\nInput: G = (V, E), hmax , k\ncomment: V = Q \u222a R, and E is the set of all edges\nof length \u2264 rmax on Q \u222a R.\nOutput: T (the desired network)\nflag: boolean Fin f (if Fin f = 1, problem is (possibly)\ninfeasible)\nInitialize: T = \u2205, Fin f = 0\nStep 1: (T, Fin f ) \u2190 S PT iRP(G)\nRemark: We run the SPTiRP algorithm on G to obtain a one connected hop constrained network with as few relays\nas possible.\nStep 2: if Fin f = 1\nexit Phase 2\nelse go to next step\nRemark: If the SPTiRP algorithm fails to meet the hop constraint for some of the sources, we declare the problem\nto be infeasible, and stop.\nStep 3: n = 2 (comment: n is the loop variable for\nthe outer loop described next)\nOuter loop: while n \u2264 k (comment: the following\nsteps (Steps 4 to 12) will be repeated until all the\nsources have k node disjoint hop constrained paths to\nthe sink)\nInner loop: for each source S i \u2208 Q, 1 \u2264 i \u2264 |Q| \u2212 1\n(comment: Steps 4 to 11 will be repeated for each\nsource)\nStep 4: Viused \u2190 V \u2229 {\u222an\u22121\nl=1 pathmax (S i , 0)}\nRemark: We designate by pathmax (S i , 0), the lth node disjoint hop constrained path from source S i to sink (1 \u2264 l \u2264 k).\nIn Step 4, we identify the set of nodes (designated by Viused ) used by the first n \u2212 1 node disjoint paths from source\nS i to sink. Since we want to find another node disjoint path from source S i to sink in the current (nth ) iteration (of\nthe outer loop), we need to remove the set of vertices, Viused , except S i and 0, from consideration for the nth path\nbefore proceeding further in the current iteration. We do that in the next step.\nStep 5: Vi(r) \u2190 {V\\Viused } \u222a {S i , 0}\nRemark: Vi(r) is the set of vertices not used in the first n \u2212 1 paths from source S i to the sink, and therefore, eligible\nto be part of the nth node disjoint path from source S i to sink.\nStep 6: Gni \u2190 restriction of G to Vi(r)\nRemark: In order to obtain the nth node disjoint path from source S i to sink, we restrict the graph G to the eligible\nnode set Vi(r) .\n\n\f37\n\nStep 7: pathnsh (S i , 0) \u2190 S PT (Gni )\n\nStep 8: if hopcount(pathnsh(S i , 0)) > hmax\n{Fin f \u2190 1;\nexit Phase 2}\nelse go to next Step\n\nRemark:\n1) We obtain the shortest path (designated by pathnsh (S i , 0))from source S i to sink in Gni ; if this path meets the\nhop constraint, we have a feasible solution for the nth node disjoint path from source S i to sink, and we can\nproceed to the next step to prune relays from the feasible solution in order to achieve a better solution in\nterms of relay count. If, however, the path obtained in Step 7 does not meet the hop constraint, we declare\nthe problem to be possibly infeasible, and stop, as we have failed to obtain a feasible solution for the nth\nnode disjoint path (1 < n \u2264 k) from source S i to sink.\n2) Successful completion of Steps 7 and 8 thus guarantee the existence of a hop count feasible, node disjoint\npath from source S i to sink. Now, since our objective is to meet the design requirements using as few relays as\npossible, in the next step, we shall try to obtain a better path (in terms of relay count) from source S i to sink,\nby pruning relays from the feasible path obtained earlier. The dummy algorithm will differ from E-SPTiRP\nalgorithm in this relay pruning procedure.\n3) Note that we can simply run the SPTiRP algorithm on the graph Gni to obtain the nth node disjoint hop\nconstrained path from source S i to sink, update the network T with that path, and move on to the next source\n(next iteration of the inner loop). But since the SPTiRP algorithm is designed to 'optimize' the total number\nof relays used by all the source nodes in Gni , the path so obtained from source S i to sink may not be the best\nin terms of relay count for source S i . Hence, we shall explore other methods of reducing relay count in the\npath from source S i to sink, as indicated in Step 9.\nn\nStep 9: path(1)\nn (S i , 0) \u2190 S PT iRP(G i ) (comment:\nCandidate path 1)\n\npath(2)\n\u2190\nRoutineA(Gni, pathnsh (S i , 0), R)\nn (S i , 0)\n(comment: Candidate path 2)\nRemark: We obtain two candidate routes for the nth node disjoint hop constrained path from source S i to sink\nin Gni . The first candidate path is obtained simply by running the SPTiRP algorithm on the graph Gni . The second\ncandidate route is obtained by pruning relays from the feasible path, pathnsh (S i , 0), obtained in Steps 7 and 8 earlier.\nThe routine for this relay pruning procedure, namely RoutineA, is described next. Once we have the candidate\nroutes, we shall choose the best among them in terms of relay count.\nPseudo code for RoutineA\nInput: Gni , pathnsh (S i , 0), R\nOutput: path(2)\nn (S i , 0) (comment: the second candidate path)\nsh\nInitialize: path(2)\nn (S i , 0) \u2190 pathn (S i , 0)\n\nStep a: QiA \u2190 Vi(r) \u2229 Q\nRiA \u2190 R \u2229 pathnsh (S i , 0)\nViA \u2190 QiA \u222a RiA\n\nGiA \u2190 restriction of Gni to ViA (comment: This\nis the graph over which we shall search for a hop\nconstrained path after pruning a relay)\nRemark: RiA is the set of relays used in the feasible path, pathnsh (S i , 0), from source S i to sink. We shall try to\nprune the relays in the set RiA one by one to achieve a better path in terms of relay count.\nQiA is the set of sources (may or may not be used in the initial feasible path, pathnsh (S i , 0)) belonging to the\neligible vertex set, Vin , defined earlier in Step 5 of Dummy Algorithm, phase 2. We designate by ViA , the vertex set\n\n\f38\n\nconsisting of the sources in QiA , and the relays in RiA .\nWe shall allow our search space to be the vertex set ViA (i.e., the graph GiA ), i.e., we shall allow all the eligible\nsource nodes in Vin , irrespective of whether they were used or not in the initial feasible path, and allow only the\nrelays used in the initial feasible path, pathnsh (S i , 0).\n\u2022 Since we are allowing only the relays used in the initial feasible path, this method will still ensure a reduction\nin relay count, if a hop constrained path is found after pruning a relay.\nsh\n\u2022 In the worst case, the routine may end up with pathn (S i , 0) as outcome.\nStep b: Loop: for each node j \u2208 RiA (comment:\nthe following steps will be repeated until no more\nrelay pruning is possible without violating the hop\nconstraint)\nStep c: T empPath(S i , 0) \u2190 S PT (GiA \\ j)\nRemark: With slight abuse of notation, we designate by GiA \\ j, the restriction of the graph GiA to the node set ViA \\ j.\nAfter pruning a relay j, we obtain the shortest path (T empPath(S i, 0)) from source S i to sink, using the remaining\nvertices in ViA .\nStep d: if hopcount(T empPath(S i, 0)) > hmax\ncontinue; (comment: Go back to step 2 and\ntry pruning the next relay in RiA )\nelse go to next Step\nRemark: If the shortest path from S i to sink in GiA after pruning relay j does not satisfy the hop constraint, we\nreplace back the relay j, and try pruning the next relay in RiA .\nStep e: path(2)\nn (S i , 0) \u2190 T empPath(S i , 0)\nRiA \u2190 R \u2229 path(2)\nn (S i , 0)\nViA \u2190 QiA \u2229 RiA\nGiA \u2190 restriction of Gni to ViA\nRemark: If relay j can be pruned successfully without violating the hop constraint, we update the candidate path,\nA\nA\npath(2)\nn (S i , 0), and the sets Vi and Ri (the set of relays used in the candidate path) as above before proceeding to\nthe next iteration of the loop (i.e., before pruning the next relay).\nNote that since relay j has been pruned, the updated relay set RiA (and hence the updated candidate path) will\nhave at least one relay less than the relay set used by the initial feasible path, pathnsh (S i , 0).\nend of Pseudo code for RoutineA\nStep 10 (of Dummy Algorithm, phase 2):\npathn (S i , 0) \u2190 arg min{relaycount(path(1)\nn (S i , 0)),\nrelaycount(path(2)\nn (S i , 0))}\nRemark: Once we have the candidate routes for the nth node disjoint hop constrained path from source S i to sink,\nwe choose the best among them in terms of relay count.\nStep 11: T \u2190 T \u222a pathn (S i , 0)\nInner loop end\nRemark: Update the network T with the nth node disjoint, hop constrained path from source S i to sink.\nStep 12: n \u2190 n + 1\nOuter loop end\nend of Pseudo code for Dummy Algorithm\n3) Time complexity of the Dummy algorithm: Phase 1 of Dummy algorithm involves repeating the SPTiRP\nalgorithm on the set Q alone at most k times for each of the sources. Hence, the time complexity of this phase is\nupper bounded by k(|Q| \u2212 1)g sptirp (|Q|).\n\n\f39\n\nPhase 2 starts by running the SPTiRP algorithm on the entire graph. The time complexity involved therein is\ng sptirp (|Q| + |R|). Now the alternate route finding procedure involves finding SPT on Gi (see the algorithm for\ndefinition of Gi ), followed by two different methods of finding candidate routes.\nNow, the time complexity of finding SPT on Gi is \u2264 g spt (|Q| + |R|), and this step is repeated at most k \u2212 1 times\nfor each source.\nRoutineA (for computing the second candidate path) involves pruning relays from a path, one at a time, and\nrunning SPT on the remaining searchspace (i.e., the relays on the path, and all the eligible source nodes. See\nDummy algorithm for detailed explanation) to check hop constraint feasibility. The time complexity of RoutineA\nis, therefore, upper bounded by |R|g spt (|Q| + |R| \u2212 1) \u2264 |R|g spt (|Q| + |R|). This method is repeated at most k \u2212 1 times\nfor each source.\nComputation of the first candidate path involves running the SPTiRP algorithm on Gi , and its worst case\ncomplexity is upper bounded by g sptirp (|Q| + |R|). This method is also repeated at most k \u2212 1 times for each\nsource.\nHence, the time complexity of Dummy algorithm is upper bounded by k(|Q| \u2212 1)g sptirp (|Q|) + g sptirp (|Q| + |R|) +\n(|Q| \u2212 1)(k \u2212 1){g spt (|Q| + |R|) + |R|g spt (|Q| + |R|) + g sptirp (|Q| + |R|)}.\nRecall that g sptirp (*) and g spt (*) are both polynomial time, and hence the above expression is polynomial time in\n|Q|, |R|, and k.\nC. Analysis of E-SPTiRP\n1) Time complexity: We show below that the time complexity of the algorithm is upper bounded by polynomials\nin |Q|, |R|, and k. Hence the algorithm is polynomial time.\nLemma 6. The time complexity of the E-SPTiRP algorithm is upper bounded by k(|Q| \u2212 1)g sptirp (|Q|) + g sptirp (|Q| +\n|R|) + (k \u2212 1)(|Q| \u2212 1)(|R| + 1)g spt(|Q| + |R|), where g sptirp (*) is the time complexity of the SPTiRP algorithm, and g spt (*)\nis the time complexity of finding the shortest path tree.\nProof:\nThe first and second terms in the above expression can be derived by similar arguments as given for Dummy\nalgorithm above.\nNow, the alternate route finding procedure starts by finding an SPT on a graph Gi , a restriction of the graph G.\nThe complexity of this is upper bounded by g spt (|Q| + |R|). This is repeated for each source at most k \u2212 1 times.\nThe next step in alternate route finding consists of pruning from a path (path2 (i, 0)), relays chosen from a certain\nselected set (Ri ), one at a time, and finding the SPT on the resulting restricted graph (see E-SPTiRP for detailed\nexplanation) to check if hop constraint is satisfied by the resulting path. The worst case complexity of this step is\nupper bounded by |R|g spt (|Q| + |R|). This step is also repeated at most k \u2212 1 times for each source.\nHence, the worst case complexity of E-SPTiRP is upper bounded by k(|Q| \u2212 1)g sptirp (|Q|) + g sptirp (|Q| + |R|) + (k \u2212\n1)(|Q| \u2212 1)(|R| + 1)g spt (|Q| + |R|).\nFrom Lemma 6, it follows that E-SPTiRP algorithm is polynomial time.\n2) Worst case approximation guarantee: As already stated in Corollary 5 (Section IX), no polynomial time\nalgorithm can provide finite approximation guarantee for the general class of RSNk-MR-HC problems. However,\nfor a subclass of RSNk-MR-HC problems where the optimal solution for one connectivity with hop constraint\n(RST-MR-HC) uses at least one relay, we can derive a polynomial factor worst case approximation guarantee for\npolynomial time complexity algorithms. This is the content of Lemma 7, Corollary 6, and Theorem 6.\nLemma 7. For any fixed k \u2208 {1, 2, . . .}, if the optimal solution for the RSNk-MR-HC problem on the graph G = (V, E),\nuses n > 0 relays, then the optimal solution for the RSN(k + 1)-MR-HC problem on the same graph with the same\nhop constraint as the RSNk-MR-HC problem, uses at least n + 1 relays.\nProof: Consider a problem instance where the optimal solution for the RSNk-MR-HC problem uses n > 0\nrelays.\nSuppose we claim that the optimal solution for the RSN(k+1)-MR-HC problem on that problem instance also uses\nn relays (it evidently cannot use fewer than n relays as that would contradict the hypothesis that the RSNk-MR-HC\nproblem uses at least n relays).\nTherefore, for that problem instance, there exists a relay set Ropt = {R1 , R2 , . . . , Rn } such that each source has\nk + 1 node disjoint paths to the sink involving some of those relays.\n\n\f40\n\nNote that Ropt is an optimal solution for the RSNk-MR-HC problem on this problem instance. This is because,\nfrom each source to the sink we can take any k of the k + 1 paths provided by this solution to RSN(k + 1)-MR-HC;\nthis will be an optimal solution to RSNk-MR-HC. In this optimal solution to RSNk-MR-HC, let S i be the set of\nsources that use the relay Ri , 1 \u2264 i \u2264 n. Note that if this set is empty for some i, 1 \u2264 i \u2264 n, then there is nothing left\nto prove, since we could obtain an optimal solution to the RSNk-MR-HC problem using only the relays in Ropt \\Ri\n(which, in turn, contradicts the assumption that the optimal solution to the RSNk-MR-HC problem uses n relays).\nWe, therefore, assume that S i is nonempty for all i, 1 \u2264 i \u2264 n, and derive a contradiction.\nBy our claim, Ropt is also the optimal solution for the RSN(k + 1)-MR-HC problem. Since the (k + 1) paths from\neach source to the sink in this solution must be node disjoint, therefore, each source in the set S i uses the relay Ri\nin only one of its (k + 1) paths to the sink. It follows, therefore, that each source in S i has k hop constrained, node\ndisjoint paths to the sink using only the relays in Ropt \\Ri . This, in turn, implies that the set Ropt \\Ri is sufficient\nto obtain k node-disjoint, hop constrained paths from each of the sources to the sink, i.e., Ropt \\Ri is, in fact, an\noptimal solution for the RSNk-MR-HC problem. This contradicts our earlier assumption that the optimal solution\nfor RSNk-MR-HC problem uses n relays.\nTherefore, our claim that the optimal solution for the RSN(k + 1)-MR-HC problem uses n relays is wrong. Hence,\nthe optimal solution for RSN(k + 1)-MR-HC problem must use at least n + 1 relays.\nCorollary 6. If the optimal solution for the RST-MR-HC problem on the graph G = (V, E), uses m > 0 relays,\nthen the optimal solution for the RSNk-MR-HC problem on the same graph with the same hop constraint as the\nRST-MR-HC problem, uses at least m + k \u2212 1 relays.\nProof: If the optimal solution for the RST-MR-HC problem on the graph G = (V, E), uses m > 0 relays, then\nby Lemma 7, the optimal solution for the RSN2-MR-HC problem must use at least m + 1 relays. Therefore, using\nLemma 7 once more, the optimal solution for the RSN3-MR-HC problem must use at least m + 2 relays. Thus, by\nrepeated use of Lemma 7, the optimal solution for the RSNk-MR-HC problem must use at least m + k \u2212 1 relays.\nTheorem 6. For the set of problem instances where the optimal solution for the RST-MR-HC problem uses at\nleast one relay, the worst case approximation guarantee given by any polynomial time complexity algorithm for\nthe RSNk-MR-HC problem, whenever the algorithm terminates with a feasible solution, is min{m(hmax \u2212 1), |R|/k},\nwhere m is the number of sources, and hmax is the hop count bound.\nProof: Since the optimal solution for the RST-MR-HC problem uses at least one relay, the worst case scenario is\nthat the optimal relay count for RST-MR-HC problem is just 1, and hence, from Corollary 6, the optimal solution for\nRSNk-MR-HC problem uses at least k relays, whereas a polynomial time algorithm for the same problem may end\nup using all the |R| relays, or at most mk(hmax \u2212 1) relays, whichever is the smaller, whenever the algorithm obtained\na feasible solution for the problem. Hence, the worst case approximation guarantee is min{m(hmax \u2212 1), |R|/k}.\n3) Average Case Approximation Guarantee: We provide a bound on the average case approximation ratio for\nthe RSNk-MR-HC problem for a stochastic setting very similar to that in Section V-B4. We consider a square\narea A(\u2282 R2+ ) of side a. The BS is located at (0,0). We deploy n potential locations independently and identically\ndistributed (i.i.d) uniformly randomly over the area A; then deploy m sources i.i.d uniformly randomly over the\narea A\u01eb (recall that for a given \u01eb \u2208 (0, 1), A\u01eb (\u2282 A) denotes the quarter circle of radius (1 \u2212 \u01eb)hmax r centred at the\nBS, where hmax is the hop constraint, and r is the maximum allowed communication range). The probability space\n(n)\n(n)\n(n)\n(n)\n(n)\nof this random experiment is (\u03a9m,\u01eb\n, Bm,\u01eb\n, Pm,\u01eb\n) where, \u03a9m,\u01eb\n, B(n)\nm,\u01eb , Pm,\u01eb are as defined earlier.\nr\nWe consider the random geometric graph G (\u03c9) induced by considering all links of length \u2264 r on an instance\n\u03c9 \u2208 \u03a9(n)\nm,\u01eb . We introduce the following notations, in addition to the notations introduced earlier in Section V-B4:\nXk = {\u03c9 : \u2203 at least k node disjoint paths with hop count \u2264 hmax from each source to the BS in G(\u03c9)}:\nset of all feasible instances for the RSNk-MR-HC problem. Note that Xk \u2282 X.\nXalgo \u2282 Xk : set of all feasible instances where E-SPTiRP algorithm obtains a feasible solution\nNE\u2212S PT iRP (\u03c9): Number of relays in the outcome of the E-SPTiRP algorithm on Gr (\u03c9) (\u221e if \u03c9 \u2208 Xcalgo )\nROpt,k (\u03c9): Number of relays in the optimal solution to the RSNk-MR-HC problem on Gr (\u03c9) (\u221e if \u03c9 \u2208 Xck )\nRecall from Corollary 4 that no polynomial time algorithm (and in particular, the E-SPTiRP algorithm) is\nguaranteed to obtain a feasible solution to the RSNk-MR-HC problem whenever such a solution exists. Also recall\nfrom Corollary 5 in Section IX that when an optimal solution to the RST-MR-HC problem on an instance uses\nzero relays, we cannot obtain any finite approximation guarantee for the RSNk-MR-HC problem on that instance.\nTherefore, we consider the set of feasible instances of the RSNk-MR-HC problem where the E-SPTiRP algorithm\n\n\f41\n\nreturns a feasible solution, and the optimal solution to the corresponding RST-MR-HC problem uses non-zero\nnumber of relays, i.e., ROpt > 0.\nThe average case approximation ratio of the E-SPTiRP algorithm over all such feasible instances is defined as\n\u25b3\n\nAverage case approximation ratio, \u03b1k =\n\nE[NE\u2212S PT iRP |Xalgo , ROpt > 0]\nE[ROpt,k |Xalgo , ROpt > 0]\n\n(39)\n\nIn the derivation to follow, we will need Xk to be a high probability event, i.e., with probability greater than 1 \u2212 \u03b4\nfor a given \u03b4 > 0. The following result, similar to Theorem 2, ensures that this holds for the construction provided\nearlier, provided the number of potential locations is large enough.\nTheorem 7. For any given \u01eb, \u03b4 \u2208 (0, 1), k > 1, hmax > 0 and r > 0, there exists n0 (\u01eb, \u03b4, k, hmax, r) \u2208 N such that, for\n(n)\n(n)\n(n)\nany n \u2265 n0 , Pm,\u01eb\n(Xk ) \u2265 1 \u2212 \u03b4 in the random experiment (\u03a9(n)\nm,\u01eb , Bm,\u01eb , Pm,\u01eb ).\nProof: The proof is very similar to the proof of Theorem 2.\nWe make the same construction as shown in Figure 5, and define the following events.\nCi,l j = {\u03c9: \u2203 at least k nodes out of the n potential loacations in the ith strip of Blj}\nhmax \u22121 l\nCi, j }: Event that there exists at least k nodes out of the n potential locations\nX\u01eb,\u03b4,k = {\u03c9 : \u03c9 \u2208 \u2229 J(r)\nj=1 \u2229i=1\nin each of the first hmax \u2212 1 strips (see Figure 6) for all the blades Blj\nNote that for an instance \u03c9 \u2208 X\u01eb,\u03b4,k , all nodes (and in particular, all sources) at a distance < (p \u2212 q)hr from bl ,\n1 \u2264 h \u2264 hmax , are reachable via at least k node disjoint paths, each with at most h hops. Since 1 > p > q > 0, we\ncan choose p \u2212 q to be equal to 1 \u2212 \u01eb, for the given \u01eb > 0. It follows that\nX\u01eb,\u03b4,k \u2286 Xk\n\n(40)\n\n(n)\n(n)\n(X\u01eb,\u03b4,k ).\nand hence, Pm,\u01eb\n(Xk ) \u2265 Pm,\u01eb\n(n)\n(n)\nThus, to ensure Pm,\u01eb (Xk ) \u2265 1 \u2212 \u03b4, it is sufficient &to ensure\n' that Pm,\u01eb (X\u01eb,\u03b4,k ) \u2265 1 \u2212 \u03b4, which we aim to do next.\n\u03c0hmax\n.\nAs done earlier, we upper bound J(r) as J(r) \u2264 \u221a\n2\n2\n\n1\u2212p\n\nTo simplify notations, we write P(*) to indicate P(n)\nm,\u01eb (*).\nNow we compute,\n\u0011\n\u0010\nhmax \u22121 l c\nC\nP(X\u01eb,\u03b4,k ) =\n1 \u2212 P \u222a J(r)\n\u222a\ni,\nj\nj=1 i=1\n\u2265\n\u2265\n\u2265\n=\n\u2192 1 as n \u2192 \u221e\n\n1\u2212\n\nJ(r) hmax\nX\u22121 \u0010 c \u0011\nX\nP Ci,l j\nj=1\n\ni=1\n\n\uf8f9\n\uf8ee\nk\u22121\nX\n\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\n\uf8fa\uf8fa\uf8fa (hmax \u2212 1)\n1 \u2212 \uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\ni=0\n\uf8ee\n\uf8f9\nk\u22121\nX\n\uf8ef\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\n\uf8fa (h \u2212 1)\n1 \u2212 \uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\uf8fa\uf8fa max\ni=0\n\uf8f9\n\uf8ee\nk\u22121\nX\n\uf8ef\uf8ef \u03c0hmax \uf8fa\uf8fa\uf8fa\n\uf8fa (h \u2212 1)\n1 \u2212 \uf8ef\uf8ef\uf8ef\uf8ef p\n\uf8ef\uf8ef 2 1 \u2212 p2 \uf8fa\uf8fa\uf8fa\uf8fa max\ni=0\n\n!n\u2212i\n!i\n!\nu(r)t(r)\nu(r)t(r)\nn\n1\u2212\nA\nA\ni\n!i\n!\nn \u2212 (n\u2212i)u(r)t(r) u(r)t(r)\nA\ne\nA\ni\n\uf8eb\n\uf8f6i\np\n!\n\u221a\nn \u2212(n\u2212i) q 1\u2212p2 r2 \uf8ec\uf8ec\uf8ec\uf8ec q 1 \u2212 p2 r2 \uf8f7\uf8f7\uf8f7\uf8f7\nA\ne\n\uf8ec\uf8ed\n\uf8f7\uf8f8\nA\ni\n\n(41)\n\nThe first inequality comes from the union bound, the second inequality, from the upper bound on J(r). The third\ninequality uses the result 1 \u2212 x \u2264 e\u2212x .\nHence the theorem follows.\np\nNote that p and q can be obtained as earlier in terms of \u01eb by maximizing q 1 \u2212 p2 under the constraint\np \u2212 q = 1 \u2212 \u01eb.\nRemark: For fixed hmax and r, n0 (\u01eb, \u03b4, k) increases with decreasing \u01eb and \u03b4, and increasing k.\nThe experiment: In the light of Theorem 7, we employ the following node deployment strategy to ensure, w.h.p,\nfeasibility of the RSNk-MR-HC problem in the area A. Choose arbitrary small values of \u01eb, \u03b4 \u2208 (0, 1). Given the\nhop count bound hmax and the maximum communication range r, obtain n0 (\u01eb, \u03b4, k, hmax , r) as defined in Theorem 7.\nDeploy n \u2265 n0 potential locations i.i.d uniformly randomly over the area of interest, A. m sources are deployed\n\n\f42\n\ni.i.d uniformly randomly within a radius (1 \u2212 \u01eb)hmax r from the BS, i.e., over the area A\u01eb . By virtue of Theorem 7,\nthis ensures that any source deployed within a distance (1 \u2212 \u01eb)hmax r has at least k node disjoint paths to the BS,\nthat are no more than hmax hops w.h.p, thus ensuring feasibility of the RSNk-MR-HC problem w.h.p. We run the\nE-SPTiRP algorithm on the induced random geometric graph with hop count as cost to check if the algorithm\nreturns a feasible solution. We also run the SPTiRP algorithm on the same graph to check if the optimal solution\nto the RST-MR-HC problem on that instance uses non-zero number of relays. In this stochastic setting, we derive\nan upper bound on the average case approximation ratio, \u03b1k , of the E-SPTiRP algorithm as follows.\nLemma 8. E[NES PT iRP |Xalgo , ROpt > 0] \u2264 mk(hmax \u2212 1)\nProof: Observe that for any feasible solution given by the E-SPTiRP algorithm, the number of relay nodes\non each of the k paths for a source cannot exceed hmax \u2212 1 (since each path has at most hmax hops). The lemma\nfollows immediately.\nLemma 9. E[ROpt,k |Xalgo , ROpt > 0] \u2265 ROpt + k \u2212 1\nwhere, ROpt denotes the R.H.S of Equation 16.\nProof: Given Xalgo and ROpt > 0, it follows from Corollary 6 that\nROpt,k (\u03c9) \u2265 ROpt (\u03c9) + k \u2212 1 \u2200\u03c9 \u2208 Xalgo \u2229 {\u03c9 : ROpt (\u03c9) > 0}\nHence,\nE[ROpt,k |Xalgo , ROpt > 0] \u2265 E[ROpt |Xalgo , ROpt > 0] + k \u2212 1\n\n(42)\n\nBefore proceeding further, we take a small detour. Recall that the E-SPTiRP algorithm declares possible infeasibility if after finding a one-connected solution using the SPTiRP algorithm, the alternate path from some source to\nthe BS (a constrained shortest path using only the nodes not used in the previous paths from that source) violates\nthe hop constraint.\nNote that the event X\u01eb,\u03b4,k ensures that there exist at least k node disjoint shortest paths (all of the same minimum\nhop count) from each source to the BS, which is a sufficient condition to ensure that the E-SPTiRP algorithm can\nfind a feasible solution (since the constrained shortest path avoiding nodes used in upto (k \u2212 1) previous paths will\nstill be a shortest path, and hence will meet the hop constraint). Thus, X\u01eb,\u03b4,k \u2282 Xalgo .\nWith this in mind, let us get back to the main proof.\nE[ROpt |Xalgo , ROpt > 0] \u2265 E[ROpt |Xalgo ]\n\u2265 E[ROpt 1X\u01eb,\u03b4,k |Xalgo ]\n\n= P[X\u01eb,\u03b4,k |Xalgo ] E[ROpt |X\u01eb,\u03b4,k , Xalgo ]\n\u2265 P[X\u01eb,\u03b4,k , Xalgo ] E[ROpt |X\u01eb,\u03b4,k , Xalgo ]\n\n= P[X\u01eb,\u03b4,k ] E[ROpt |X\u01eb,\u03b4,k ]\n\u2265 (1 \u2212 \u03b4)E[ROpt |X\u01eb,\u03b4,k ]\n\nsince, X\u01eb,\u03b4,k \u2282 Xalgo\n\n(43)\n\nAlong similar lines of derivation as in Equations (18)-(29) (with X\u01eb,\u03b4,k instead of X\u01eb,\u03b4 ), we obtain the following\nbound:\n\uf8ee\n!2m \uf8f9 hmax\n\uf8ef\uf8ef\uf8ef\n\uf8fa\uf8fa\uf8fa X\u22121\nhmax \u2212 1\n\uf8ef\n\uf8fa\uf8fa\nE[ROpt |X\u01eb,\u03b4,k ] \u2265 \uf8ef\uf8f01 \u2212\nqi\n(44)\n(1 \u2212 \u01eb)hmax \uf8fb i=1\n\nwhere, qi is lower bounded as in Equation (28).\nFinally, combining Equations (42), (43), and (44), we have the desired lemma.\nCombining Lemma 8 and Lemma 9, we obtain the following upper bound on the average case approximation\nratio of E-SPTiRP algorithm.\nTheorem 8. The average case approximation ratio, \u03b1k , of E-SPTiRP algorithm is upper bounded as\n\u03b1k \u2264\n\nmk(hmax \u2212 1)\nROpt + k \u2212 1\n\n(45)\n\n\f43\n\nwhere, ROpt is given by the R.H.S of (16).\nRemark: For a 2-connectivity problem with 10 sources, and a hop constraint hmax = 4, the upper bound on the\naverage case approximation ratio of the E-SPTiRP algorithm turns out to be 22, provided the source locations, and\nthe potential relay locations are distributed according to the experiment described earlier.\nXI. Numerical Results for the k-Connectivity Algorithms\nTo evaluate the performance of the E-SPTiRP algorithm, we ran both the algorithms (E-SPTiRP as well as the\nDummy algorithm presented in the Appendix) to solve the RSNk-MR-HC problem with k = 2 on the same random\nnetwork scenarios (test set 3) that were generated to test the SPTiRP algorithm (see Section VII-C). Due to the small\nnumber of relays, the probabilistic analysis of feasibility was not useful; however, in none of the 1000 scenarios\ntested, the hop constraint turned out to be infeasible. The results are summarized in Table XIII.\nTABLE XIII\nPerformance comparison of the k connectivity algorithms for k = 2\nPotential\nrelay\ncount\n\nScenarios\n\n100\n110\n120\n130\n140\nTotal\n\n200\n200\n200\n200\n200\n1000\n\nRelay Count\nDummy\nAverage\n5.295\n4.88\n5.45\n5.15\n5.27\n5.209\n\nMax\n13\n10\n12\n11\n14\n14\n\nE-SPTiRP\nMin\n0\n0\n1\n0\n0\n0\n\nAverage\n4.13\n3.895\n4.18\n4\n3.945\n4.03\n\nMax\n9\n9\n8\n8\n9\n9\n\nMin\n0\n0\n1\n0\n0\n0\n\nE-SPTiRP\nbetter than\nDummy\n\nE-SPTiRP\nsame as\nDummy\n\nE-SPTiRP\nworse than\nDummy\n\n134\n121\n129\n135\n133\n652\n\n54\n68\n52\n54\n53\n281\n\n12\n11\n19\n11\n14\n67\n\nMean execution\ntime\nin sec\nDummy\nE-SPTiRP\n11.163\n3.0429\n13.973\n3.8558\n16.252\n4.3314\n18.97\n5.2316\n23.748\n6.3596\n16.821\n4.564\n\nFrom Table XIII, we can make the following observations:\n1) In all 5 sets of experiments (with different node densities), the average relay count required by E-SPTiRP to\nachieve 2 connectivity is less than that required by Dummy algorithm.\n2) In over 65% of the tested scenarios, E-SPTiRP performed better than Dummy algorithm in terms of relay\ncount. In another 28.1% of cases, they performed equally well.\n3) In all 5 sets of experiments, the maximum relaycount required by Dummy algorithm is more than that required\nby E-SPTiRP (although the maximums for the two algorithms may have been on different random scenarios).\n4) In terms of mean execution time, E-SPTiRP performed much better than Dummy algorithm in all 5 sets of\nexperiments. This is probably because of the fact that in the alternate path finding procedure (Steps 5-8 of\nPhase 2, Dummy algorithm, Section X-B), Dummy algorithm finds two candidate routes, and chooses the\nbest among them, whereas, E-SPTiRP (Section X-A3, Steps 3-16) determines the alternate node disjoint path\nin one attempt. Thus, the alternate route determination procedure for Dummy algorithm is possibly more time\nconsuming than that of E-SPTiRP.\n5) For both the algorithms, the average execution time increases with increasing node density.\nFor each of the five sets of experiments, we also noted the minimum (maximum) relay count required by either\nalgorithm over scenarios where the other algorithm uses a maximum (minimum) number of relays. The comparative\nstudy is summarized in Table XIV.\nTABLE XIV\nComparison of Maximum and Minimum Relaycount of the k connectivity algorithms for k = 2\nPotential\nrelay\ncount\n\nScenarios\n\nMax\nrelay count\nof\nDummy (n1 )\n\n100\n110\n120\n130\n140\n\n200\n200\n200\n200\n200\n\n13\n10\n12\n11\n14\n\nMin\nrelay count\nof\nE-SPTiRP\nwhen\nDummy\nuses n1\n8\n4\n6\n7\n7\n\nMax\nrelay count\nof\nE-SPTiRP (n2 )\n\n9\n9\n8\n8\n9\n\nMin\nrelay count\nof\nDummy\nwhen\nE-SPTiRP\nuses n2\n13\n10\n9\n9\n12\n\nMin\nrelay count\nof\nDummy (m1 )\n\n0\n0\n1\n0\n0\n\nMax\nrelay count\nof\nE-SPTiRP\nwhen\nDummy\nuses m1\n0\n0\n2\n0\n0\n\nMin\nrelay count\nof\nE-SPTiRP (m2 )\n\n0\n0\n1\n0\n0\n\nMax\nrelay count\nof\nDummy\nwhen\nE-SPTiRP\nuses m2\n0\n0\n6\n0\n0\n\n\f44\n\nFrom Table XIV, we observe that\n1) For all 5 sets of experiments, in scenarios where Dummy algorithm performs at its worst in terms of relay\ncount, the minimum relay count of E-SPTiRP is always much better than the relaycount of Dummy algorithm.\nAlso observe that the maximum relay count used by E-SPTiRP in all sets of experiments is better than that\nof Dummy algorithm.\n2) In scenarios where E-SPTiRP uses a maximum number of relays, the minimum relay count used by Dummy\nalgorithm is still higher than the relay count of E-SPTiRP.\n3) In scenarios where Dummy algorithm uses zero relays, E-SPTiRP also uses zero relays (which is expected,\nsince Phase 1 is same for both algorithms (see Dummy algorithm and E-SPTiRP in Section X)).\n4) In scenarios where Dummy algorithm uses the minimum non-zero number of relays (1 relay), the maximum\nrelay count used by E-SPTiRP was just 1 more than the relay count used by Dummy algorithm.\n5) In scenarios where E-SPTiRP uses the minimum non zero number of relays (1 relay), the maximum relay\ncount used by Dummy algorithm was as high as 6.\nThus, from our observations in Table XIV, we can conclude that the worst case performance of E-SPTiRP in\nterms of relay count is better than that of Dummy algorithm.\nTo compare the performance of the proposed algorithm against the worst case performance bound given in\nTheorem 6, we did the following:\n\u2022 For each of the five sets of experiments, we identified the scenarios where the optimal solution for the RSTMR-HC problem is non zero.\n\u2022 For each of the scenarios thus identified, we can compute the lower bound on the optimal number of relays\nrequired for 2-connectivity, using Lemma 7, as follows. If the optimal solution for the RST-MR-HC problem\nuses n relays, the optimal number of relays required for 2-connectivity is lower bounded by n + 1.\n\u2022 For each scenario, we obtained the approximation factor given by the proposed algorithm w.r.t the lower bound\nRelayAlgo\ncomputed above as approximation factor = Relaylowerbound\n.\n\u2022 For each of the five sets of experiments, we obtained the worst and the best approximation factors (as computed\nabove) achieved by both E-SPTiRP and the Dummy algorithm, and also the worst case performance bound\nobtained from Theorem 6.\nThe results are summarized in Table XV.\nTABLE XV\nPerformance Comparison of the k connectivity algorithms against theoretical performance bound for k = 2\nPotential\nrelay\ncount\n(|R|)\n100\n110\n120\n130\n140\nTotal\n\nScenarios (out of 200 in Table XIII)\nwhere RST-MR-HC has\nnon zero optimal\nsolution\n156\n146\n158\n150\n147\n757\n\nWorst Case Theoretical\nperformance\nbound\n(min{10(hmax \u2212 1), |R|/2})\n50\n50\n50\n50\n50\nNA\n\nWorst Approx.\nfactor of\nDummy\n\nBest Approx.\nfactor of\nDummy\n\nWorst Approx.\nfactor of\nE-SPTiRP\n\nBest Approx.\nfactor of\nE-SPTiRP\n\n5.5\n5\n5.5\n4.5\n5.5\n5.5\n\n1\n1\n1\n1\n1.5\n1\n\n3.5\n3.5\n3\n3.5\n3.5\n3.5\n\n1\n1\n1\n1\n1\n1\n\nFrom Table XV, we observe that\n1) For each of the five sets of experiments, the worst case approximation factor (as defined earlier, for scenarios\nwhere optimal solution of RST-MR-HC problem is non zero) achieved by both the algorithms is much better\nthan the theoretical performance bound predicted in Theorem 6.\nAlso note that these approximation factors were computed based on a lower bound on the optimal solution\nfor 2 connectivity; hence the actual performance of the algorithms is even better than this.\n2) In all five sets of experiments, E-SPTiRP outperformed Dummy algorithm significantly in terms of the worst\ncase approximation factor.\n3) The best approximation factor achieved by both the algorithms was 1, i.e., the lower bound was actually\nachieved by the algorithms in some of the test cases.\nIn the relatively small number of test scenarios where Theorem 6 does not apply (i.e., optimal solution for\nRST-MR-HC problem is zero), and hence there is no bounded factor approximation guarantee for the algorithms,\nwe obtained the maximum and minimum number of relays used by the two algorithms over those scenarios. The\nresults are presented in Table XVI.\n\n\f45\n\nTABLE XVI\nPerformance of the k connectivity algorithms for k = 2 in scenarios where there is no bounded approximation guarantee\nPotential\nrelay\ncount\n100\n110\n120\n130\n140\nTotal\n\nScenarios (out of 200 in Table XIII)\nwhere RST-MR-HC has\nzero optimal\nsolution\n44\n54\n42\n50\n53\n243\n\nTheoretical\nperformance\nbound\n\nMax relaycount\nof\nDummy\n\nMin relaycount\nof\nDummy\n\nMax relaycount\nof\nE-SPTiRP\n\nMin relaycount\nof\nE-SPTiRP\n\nNA\nNA\nNA\nNA\nNA\nNA\n\n7\n7\n7\n7\n7\n7\n\n0\n0\n0\n0\n0\n0\n\n5\n4\n5\n5\n5\n5\n\n0\n0\n0\n0\n0\n0\n\nFrom Table XVI, we see that even in scenarios where there is no bounded factor approximation guarantee for the\nalgorithms, the performance of the algorithms is reasonably good, with the maximum relay count being 7 relays\nfor Dummy algorithm, and 5 relays for E-SPTiRP. The minimum relay count for both the algorithms is zero (which\nis clearly optimal) in those scenarios.\nXII. Conclusion\nIn this paper, we have studied the problem of determining an optimal relay node placement strategy such that\ncertain performance objective(s) (in this case, hop constraint, which, under a lone-packet model, ensures data delivery\nto the BS within a certain maximum delay) is (are) met. We studied both one connected hop constrained network\ndesign, and k-connected (survivable) hop constrained network design. We showed that the problems are NP-Hard,\nand proposed polynomial time approximation algorithms for the problems. The algorithm for one connected hop\nconstrained network design problem, as can be concluded from numerical experiments presented in Section VII,\ngives solutions of reasonably good quality, using extremely reasonable computation time.\nFrom the numerical results presented in Section XI, we can conclude that the algorithm proposed for the kconnected network design problem behaves significantly better than the worst case performance bound predicted\nin Theorem 6 (in Section X) for the subclass of problems to which the Theorem 6 applies. Even for problems\nwhere the algorithm does not have any bounded approximation guarantee, we found from our experiments that the\nalgorithm behaves reasonably well in terms of relay count.\nOne might ask why the local search algorithms presented in this paper work so well in the tested random\nscenarios. The answer to this question is not immediately obvious, but, for the RST-MR-HC and RSNk-MR-HC\nproblems, the graphs we ran our tests on were all geometric graphs; hence, a formal analysis of the properties of\nthe underlying random geometric graph might provide some useful insights into the performance of these local\nsearch algorithms. We wish to address this issue in our future work.\nFurther, we are working on extending the design to traffic models more complex than the lone packet traffic\nmodel considered here. This requires the analysis of packet delays in a mesh network with more complex traffic\nflows and the nodes accessing the medium using CSMA/CA as defined in IEEE 802.15.4 [9], [6].\nAcknowledgement\nThis work was supported by the Automation Systems Technology (ASTeC) Center, a program of the Department\nof Information Technology at CDAC, Trivandrum, Kerala, India.\nReferences\n[1] Honeywell, \"www.honeywell.com/ps/wireless.\"\n[2] ISA100, \"www.isa.org/isa100.\"\n[3] R. A. Sajana, R. Subramanian, P. V. Kumar, S. Krishnan, B. Amrutur, J. Sebastian, M. Hegde, and S. Anand, \"A low-complexity algorithm\nfor intrusion detection using a PIR-based wireless sensor network,\" in International Conference Series on Intelligent Sensors, Sensor\nNetworks and Information Processing, (Sydney), 2009.\n[4] IEEE, IEEE Standards Part 15.4: Wireless Medium Access Control (MAC) and Physical Layer (PHY) Specifications for Low-Rate Wireless\nPersonal Area Networks (LR-WPANs). New York, October 2003.\n[5] A. Bhattacharya, \"Node Placement and Topology Design for Planned Wireless Sensor Networks,\" M.E thesis, Indian Institute of Science,\nJune 2010.\n[6] R. Srivastava and A. Kumar, \"Performance Analysis of Beacon-Less IEEE 802.15.4 Multi-Hop Networks,\" in 4th International Conference\non Communication Systems and Networks (COMSNETS), 2012.\n[7] Cyan, \"http://www.cyantechnology.com/apps/index.php.\"\n\n\f46\n\n[8] B. Aghaei, \"Using wireless sensor network in water, electricity and gas industry,\" in 3rd IEEE International Conference on Electronics\nComputer Technology, pp. 14\u201317, April 2011.\n[9] C. K. Singh, A. Kumar, and P. M. Ameer, \"Performance Evaluation of an IEEE 802.15.4 Sensor Network with a Star Topology,\" Wireless\nNetwork, vol. 14, pp. 543\u2013568, 2008.\n[10] S. Misra, S. D. Hong, G. Xue, and J. Tang, \"Constrained Relay Node Placement in Wireless Sensor Networks to Meet Connectivity and\nSurvivability Requirements,\" in IEEE INFOCOM, 2008.\n[11] M. R. Garey and D. S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness. Bell Telephone Laboratories,\nInc., 1979.\n[12] F. K. Hwang, D. S. Richards, and P. Winter, The Steiner Tree Problem, vol. 53 of Annals of Discrete Mathematics. Elsevier Science\nPublishers B.V, 1992.\n[13] V. V. Vazirani, Approximation Algorithms. Springer, 1st ed., 2001.\n[14] G.-H. Lin and G. Xue, \"Steiner tree problem with minimum number of Steiner points and bounded edge length,\" Information Processing\nLetters, vol. 69, pp. 53\u201357, 1999.\n[15] X. Cheng, D.-Z. Du, L. Wang, and B. Xu, \"Relay sensor placement in wireless sensor networks,\" Wireless Netw, vol. 14, pp. 347\u2013355,\n2008.\n[16] E. L. Lloyd and G. Xue, \"Relay node placement in wireless sensor networks,\" IEEE Transactions on Computers, vol. 56, January 2007.\n[17] S. Voss, \"The Steiner tree problem with hop constraints,\" Annals of Operations Research, vol. 86, pp. 321\u2013345, 1999.\n[18] A. M. Costa, J.-F. Cordeau, and G. Laporte, \"Fast heuristics for the steiner tree problem with revenues, budget and hop constraints,\"\nEuropean Journal of Operational Research, vol. 190, pp. 68\u201378, 2008.\n[19] M. Kim, Y.-C. Bang, and H. Choo, \"On multicasting Steiner trees for delay and delay variation constraints,\" 2006.\n[20] J. L. Bredin, E. D. Demaine, M. T. Hajiaghayi, and D. Rus, \"Deploying Sensor Networks with Guaranteed Capacity and Fault Tolerance,\"\nin MobiHoc'05, ACM, 2005.\n[21] D. Yang, S. Misra, X. Fang, G. Xue, and J. Zhang, \"Two-Tiered Constrained Relay Node Placement in Wireless Sensor Networks:\nComputational Complexity and Efficient Approximations,\" IEEE Transactions on Mobile Computing, 2011. accepted for publication.\n[22] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to Algorithms. The MIT Press and McGraw-Hill, 2 ed., 2001.\n[23] S. Nath, N. E. Venkatesan, A. Kumar, and P. V. Kumar, \"Theory and Algorithms for Hop-Count-Based Localization with Random Geometric\nGraph Models of Dense Sensor Networks,\" ACM Transactions on Sensor Networks, pp. 111\u2013150, 2010.\n[24] A. Nigam and Y. K. Agarwal, \"Optimal Relay Placement in Wireless Sensor Networks using Node Cut Inequalities,\" in 4th International\nConference on Communication Systems and Networks (COMSNETS), 2012.\n[25] N. Garg, V. V. Vazirani, and M. Yannakakis, \"Multiway cuts in node weighted graphs,\" Journal of Algorithms, vol. 50, pp. 49\u201361, 2004.\n[26] \"http://web.scalable-networks.com/content/qualnet.\"\n[27] IEEE, IEEE Standards Part 15.2: Coexistence of Wireless Personal Area Networks with Other Wireless Devices Operating in Unlicensed\nFrequency Bands. New York, August 2003.\n\n\f"}