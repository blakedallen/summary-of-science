{"id": "http://arxiv.org/abs/0711.0344v1", "guidislink": true, "updated": "2007-11-02T16:53:34Z", "updated_parsed": [2007, 11, 2, 16, 53, 34, 4, 306, 0], "published": "2007-11-02T16:53:34Z", "published_parsed": [2007, 11, 2, 16, 53, 34, 4, 306, 0], "title": "Automatic Coding Rule Conformance Checking Using Logic Programs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0711.2183%2C0711.1758%2C0711.0675%2C0711.3373%2C0711.3588%2C0711.2917%2C0711.2326%2C0711.3549%2C0711.4014%2C0711.4058%2C0711.1865%2C0711.1793%2C0711.3148%2C0711.1001%2C0711.0925%2C0711.0591%2C0711.4481%2C0711.0601%2C0711.0352%2C0711.4947%2C0711.0415%2C0711.0167%2C0711.0428%2C0711.1629%2C0711.3860%2C0711.1360%2C0711.1973%2C0711.3776%2C0711.3174%2C0711.2047%2C0711.2957%2C0711.4183%2C0711.2636%2C0711.3237%2C0711.1312%2C0711.2910%2C0711.3979%2C0711.2174%2C0711.2924%2C0711.3431%2C0711.3502%2C0711.0991%2C0711.3552%2C0711.3258%2C0711.1419%2C0711.0344%2C0711.2894%2C0711.2978%2C0711.0277%2C0711.1764%2C0711.3104%2C0711.3658%2C0711.3407%2C0711.1868%2C0711.0937%2C0711.1213%2C0711.3994%2C0711.3682%2C0711.2520%2C0711.2291%2C0711.2768%2C0711.1512%2C0711.4301%2C0711.0676%2C0711.4111%2C0711.3084%2C0711.2317%2C0711.4769%2C0711.2857%2C0711.0345%2C0711.1065%2C0711.0390%2C0711.0308%2C0711.3347%2C0711.1921%2C0711.4945%2C0711.0146%2C0711.3394%2C0711.4777%2C0711.1919%2C0711.3443%2C0711.4193%2C0711.4865%2C0711.4255%2C0711.2150%2C0711.4161%2C0711.1965%2C0711.1752%2C0711.4884%2C0711.4579%2C0711.2270%2C0711.4968%2C0711.2413%2C0711.0209%2C0711.2111%2C0711.4711%2C0711.3108%2C0711.1785%2C0711.4281%2C0711.4221%2C0711.0300&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Automatic Coding Rule Conformance Checking Using Logic Programs"}, "summary": "Some approaches to increasing program reliability involve a disciplined use\nof programming languages so as to minimise the hazards introduced by\nerror-prone features. This is realised by writing code that is constrained to a\nsubset of the a priori admissible programs, and that, moreover, may use only a\nsubset of the language. These subsets are determined by a collection of\nso-called coding rules.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0711.2183%2C0711.1758%2C0711.0675%2C0711.3373%2C0711.3588%2C0711.2917%2C0711.2326%2C0711.3549%2C0711.4014%2C0711.4058%2C0711.1865%2C0711.1793%2C0711.3148%2C0711.1001%2C0711.0925%2C0711.0591%2C0711.4481%2C0711.0601%2C0711.0352%2C0711.4947%2C0711.0415%2C0711.0167%2C0711.0428%2C0711.1629%2C0711.3860%2C0711.1360%2C0711.1973%2C0711.3776%2C0711.3174%2C0711.2047%2C0711.2957%2C0711.4183%2C0711.2636%2C0711.3237%2C0711.1312%2C0711.2910%2C0711.3979%2C0711.2174%2C0711.2924%2C0711.3431%2C0711.3502%2C0711.0991%2C0711.3552%2C0711.3258%2C0711.1419%2C0711.0344%2C0711.2894%2C0711.2978%2C0711.0277%2C0711.1764%2C0711.3104%2C0711.3658%2C0711.3407%2C0711.1868%2C0711.0937%2C0711.1213%2C0711.3994%2C0711.3682%2C0711.2520%2C0711.2291%2C0711.2768%2C0711.1512%2C0711.4301%2C0711.0676%2C0711.4111%2C0711.3084%2C0711.2317%2C0711.4769%2C0711.2857%2C0711.0345%2C0711.1065%2C0711.0390%2C0711.0308%2C0711.3347%2C0711.1921%2C0711.4945%2C0711.0146%2C0711.3394%2C0711.4777%2C0711.1919%2C0711.3443%2C0711.4193%2C0711.4865%2C0711.4255%2C0711.2150%2C0711.4161%2C0711.1965%2C0711.1752%2C0711.4884%2C0711.4579%2C0711.2270%2C0711.4968%2C0711.2413%2C0711.0209%2C0711.2111%2C0711.4711%2C0711.3108%2C0711.1785%2C0711.4281%2C0711.4221%2C0711.0300&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Some approaches to increasing program reliability involve a disciplined use\nof programming languages so as to minimise the hazards introduced by\nerror-prone features. This is realised by writing code that is constrained to a\nsubset of the a priori admissible programs, and that, moreover, may use only a\nsubset of the language. These subsets are determined by a collection of\nso-called coding rules."}, "authors": ["Guillem Marpons-Ucero", "Julio Mari\u00f1o", "\u00c1ngel Herranz", "Lars-\u00c5ke Fredlund", "Manuel Carro", "Juan Jos\u00e9 Moreno-Navarro"], "author_detail": {"name": "Juan Jos\u00e9 Moreno-Navarro"}, "author": "Juan Jos\u00e9 Moreno-Navarro", "arxiv_comment": "Paper presented at the 17th Workshop on Logic-based Methods in\n  Programming Environments (WLPE2007)", "links": [{"href": "http://arxiv.org/abs/0711.0344v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0711.0344v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.2.6; D.1.6", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0711.0344v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0711.0344v1", "journal_reference": null, "doi": null, "fulltext": "Automatic Coding Rule Conformance Checking\nUsing Logic Programs \u22c6\n\narXiv:0711.0344v1 [cs.PL] 2 Nov 2007\n\nGuillem Marpons1 , Julio Mari\u00f1o1 , \u00c1ngel Herranz1 , Lars-\u00c5ke Fredlund1 ,\nManuel Carro1, and Juan Jos\u00e9 Moreno-Navarro1,2\n1\n2\nUniversidad Polit\u00e9cnica de Madrid\nIMDEA Software\n{gmarpons,jmarino,aherranz,lfredlund,mcarro,jjmoreno}@fi.upm.es\n\nSome approaches to increasing program reliability involve a disciplined use of programming languages so as to minimise the hazards introduced by error-prone features. This\nis realised by writing code that is constrained to a subset of the a priori admissible\nprograms, and that, moreover, may use only a subset of the language. These subsets\nare determined by a collection of so-called coding rules. Standard coding rule sets exist\nthat target different languages (e.g. MISRA-C for the C language or HICPP for C++)\nand application domains. Some organisations do set up their own coding rule sets.\nA major drawback of actual coding rule sets is that they are written in natural\nlanguage, which bears ambiguity and undermines any effort to enforce them automatically. This work aims at defining a framework to formalise coding rules and check for\nconformity with them, using logic programming. It is part of the Global GCC project\n(http://www.ggcc.info/), an ITEA funded EU programme intended to enrich the\nGNU Compiler Collection with advanced project-wide analysis capacities.\nThe overwhelming diversity of rules (they range from being trivially enforceable to\nexpressing non-computable properties) has obliged us to focus first on a particular class\nthat we have termed structural rules: those which deal with static entities in the code\n(classes, member functions, etc.) and their properties and relationships (inheritance,\noverriding, etc.) We have identified a significant number of rules of this kind that can be\nstatically checked, being at the same time more interesting than those purely syntactic.\nRules are formalised using first order logic: relationships between program entities\nare encoded as facts (thus giving an abstract description of the program) and a formula\nis generated for every coding rule. When these, together, are inconsistent, the program\nviolates the coding rule. We automate this process by generating a program-dependent\nset of Prolog facts and program-independent predicates which describe rule violations.\nFor example, a violation of rule 3.3.15 of HICPP, which reads \"ensure base classes\ncommon to more than one derived class are virtual \", is codified as:\nv i o l a t e _ h i c p p _ 3 _ 3 _ 1 5(A ,B ,C , D ) : - class ( A ) , class ( B ) , class ( C ) , class ( D ) ,\nB \\= C , d i r e c t _ b a s e _ o f(A , B ) , d i r e c t _ b a s e _ o f(A , C ) ,\nbase_of (B , D ) , base_of (C , D ) , \\+ v i r t u a l _ b a s e _ o f(A , C ).\n\nSuccessful queries to this predicate pinpoint infringements of the rule and the answer substitutions identify a source of the violation.\nAs rule-writers may not be proficient in Prolog, we provide a user-friendly domainspecific language (DSL) that also increases expressiveness by, e.g., allowing quantification over some specific domains or providing facilities for defining closures. At the DSL\ncore there is a set of predefined predicates describing (structural) program properties,\nsuch as those used in the above rule, that are gathered during the compilation process.\n\u22c6\n\nWork partially supported by Spanish Ministry of Industry PROFIT grants FIT340005-2007-7 and FIT-350400-2006-44, Comunidad Aut\u00f3noma de Madrid grant S0505/TIC/0407 (PROMESAS), Ministry of Education and Science grant TIN200509207-C03-01 (MERIT/COMVERS) and EU IST FET grant IST-15905 (MOBIUS).\n\n\f"}