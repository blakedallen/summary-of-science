{"id": "http://arxiv.org/abs/0901.2399v3", "guidislink": true, "updated": "2009-02-19T18:43:11Z", "updated_parsed": [2009, 2, 19, 18, 43, 11, 3, 50, 0], "published": "2009-01-16T05:41:36Z", "published_parsed": [2009, 1, 16, 5, 41, 36, 4, 16, 0], "title": "The Safe Lambda Calculus", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0901.1391%2C0901.0727%2C0901.4589%2C0901.0331%2C0901.0436%2C0901.4187%2C0901.4593%2C0901.4945%2C0901.3968%2C0901.2419%2C0901.3147%2C0901.2742%2C0901.1752%2C0901.0198%2C0901.3542%2C0901.2950%2C0901.4488%2C0901.4490%2C0901.4542%2C0901.1810%2C0901.1743%2C0901.1603%2C0901.1103%2C0901.3085%2C0901.0745%2C0901.0169%2C0901.0865%2C0901.4033%2C0901.1596%2C0901.0690%2C0901.3439%2C0901.4860%2C0901.3883%2C0901.0907%2C0901.0500%2C0901.1530%2C0901.2399%2C0901.0236%2C0901.0521%2C0901.3264%2C0901.0747%2C0901.2852%2C0901.2729%2C0901.3853%2C0901.3930%2C0901.3090%2C0901.3805%2C0901.2134%2C0901.2727%2C0901.0337%2C0901.2897%2C0901.1496%2C0901.3598%2C0901.0054%2C0901.0687%2C0901.1855%2C0901.0142%2C0901.4586%2C0901.2714%2C0901.0016%2C0901.1585%2C0901.0428%2C0901.1065%2C0901.2285%2C0901.1819%2C0901.4957%2C0901.0882%2C0901.3156%2C0901.4845%2C0901.4653%2C0901.4808%2C0901.2869%2C0901.1077%2C0901.4203%2C0901.4426%2C0901.2298%2C0901.2220%2C0901.1183%2C0901.4411%2C0901.4483%2C0901.0101%2C0901.1292%2C0901.3788%2C0901.2411%2C0901.0669%2C0901.0568%2C0901.3375%2C0901.1371%2C0901.3486%2C0901.3485%2C0901.3897%2C0901.2453%2C0901.3260%2C0901.1863%2C0901.2763%2C0901.4315%2C0901.2046%2C0901.1128%2C0901.4966%2C0901.4385%2C0901.4622&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The Safe Lambda Calculus"}, "summary": "Safety is a syntactic condition of higher-order grammars that constrains\noccurrences of variables in the production rules according to their\ntype-theoretic order. In this paper, we introduce the safe lambda calculus,\nwhich is obtained by transposing (and generalizing) the safety condition to the\nsetting of the simply-typed lambda calculus. In contrast to the original\ndefinition of safety, our calculus does not constrain types (to be\nhomogeneous). We show that in the safe lambda calculus, there is no need to\nrename bound variables when performing substitution, as variable capture is\nguaranteed not to happen. We also propose an adequate notion of beta-reduction\nthat preserves safety. In the same vein as Schwichtenberg's 1976\ncharacterization of the simply-typed lambda calculus, we show that the numeric\nfunctions representable in the safe lambda calculus are exactly the\nmultivariate polynomials; thus conditional is not definable. We also give a\ncharacterization of representable word functions. We then study the complexity\nof deciding beta-eta equality of two safe simply-typed terms and show that this\nproblem is PSPACE-hard. Finally we give a game-semantic analysis of safety: We\nshow that safe terms are denoted by `P-incrementally justified strategies'.\nConsequently pointers in the game semantics of safe lambda-terms are only\nnecessary from order 4 onwards.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0901.1391%2C0901.0727%2C0901.4589%2C0901.0331%2C0901.0436%2C0901.4187%2C0901.4593%2C0901.4945%2C0901.3968%2C0901.2419%2C0901.3147%2C0901.2742%2C0901.1752%2C0901.0198%2C0901.3542%2C0901.2950%2C0901.4488%2C0901.4490%2C0901.4542%2C0901.1810%2C0901.1743%2C0901.1603%2C0901.1103%2C0901.3085%2C0901.0745%2C0901.0169%2C0901.0865%2C0901.4033%2C0901.1596%2C0901.0690%2C0901.3439%2C0901.4860%2C0901.3883%2C0901.0907%2C0901.0500%2C0901.1530%2C0901.2399%2C0901.0236%2C0901.0521%2C0901.3264%2C0901.0747%2C0901.2852%2C0901.2729%2C0901.3853%2C0901.3930%2C0901.3090%2C0901.3805%2C0901.2134%2C0901.2727%2C0901.0337%2C0901.2897%2C0901.1496%2C0901.3598%2C0901.0054%2C0901.0687%2C0901.1855%2C0901.0142%2C0901.4586%2C0901.2714%2C0901.0016%2C0901.1585%2C0901.0428%2C0901.1065%2C0901.2285%2C0901.1819%2C0901.4957%2C0901.0882%2C0901.3156%2C0901.4845%2C0901.4653%2C0901.4808%2C0901.2869%2C0901.1077%2C0901.4203%2C0901.4426%2C0901.2298%2C0901.2220%2C0901.1183%2C0901.4411%2C0901.4483%2C0901.0101%2C0901.1292%2C0901.3788%2C0901.2411%2C0901.0669%2C0901.0568%2C0901.3375%2C0901.1371%2C0901.3486%2C0901.3485%2C0901.3897%2C0901.2453%2C0901.3260%2C0901.1863%2C0901.2763%2C0901.4315%2C0901.2046%2C0901.1128%2C0901.4966%2C0901.4385%2C0901.4622&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Safety is a syntactic condition of higher-order grammars that constrains\noccurrences of variables in the production rules according to their\ntype-theoretic order. In this paper, we introduce the safe lambda calculus,\nwhich is obtained by transposing (and generalizing) the safety condition to the\nsetting of the simply-typed lambda calculus. In contrast to the original\ndefinition of safety, our calculus does not constrain types (to be\nhomogeneous). We show that in the safe lambda calculus, there is no need to\nrename bound variables when performing substitution, as variable capture is\nguaranteed not to happen. We also propose an adequate notion of beta-reduction\nthat preserves safety. In the same vein as Schwichtenberg's 1976\ncharacterization of the simply-typed lambda calculus, we show that the numeric\nfunctions representable in the safe lambda calculus are exactly the\nmultivariate polynomials; thus conditional is not definable. We also give a\ncharacterization of representable word functions. We then study the complexity\nof deciding beta-eta equality of two safe simply-typed terms and show that this\nproblem is PSPACE-hard. Finally we give a game-semantic analysis of safety: We\nshow that safe terms are denoted by `P-incrementally justified strategies'.\nConsequently pointers in the game semantics of safe lambda-terms are only\nnecessary from order 4 onwards."}, "authors": ["William Blum", "C. -H. Luke Ong"], "author_detail": {"name": "C. -H. Luke Ong"}, "author": "C. -H. Luke Ong", "links": [{"title": "doi", "href": "http://dx.doi.org/10.2168/LMCS-5(1:3)2009", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/0901.2399v3", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0901.2399v3", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.GT", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.3.2; F.4.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0901.2399v3", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0901.2399v3", "arxiv_comment": null, "journal_reference": "Logical Methods in Computer Science, Volume 5, Issue 1 (February\n  19, 2009) lmcs:1145", "doi": "10.2168/LMCS-5(1:3)2009", "fulltext": "Logical Methods in Computer Science\nVol. 5 (1:3) 2009, pp. 1\u201338\nwww.lmcs-online.org\n\nSubmitted\nPublished\n\nApr. 22, 2008\nFeb. 19, 2009\n\nTHE SAFE LAMBDA CALCULUS\nWILLIAM BLUM AND C.-H. LUKE ONG\nOxford University Computing Laboratory \u2013 School of Informatics, University of Edinburgh, UK\ne-mail address: william.blum@comlab.ox.ac.uk\nOxford University Computing Laboratory, Oxford, UK\ne-mail address: luke.ong@comlab.ox.ac.uk\nAbstract. Safety is a syntactic condition of higher-order grammars that constrains occurrences of variables in the production rules according to their type-theoretic order. In\nthis paper, we introduce the safe lambda calculus, which is obtained by transposing (and\ngeneralizing) the safety condition to the setting of the simply-typed lambda calculus. In\ncontrast to the original definition of safety, our calculus does not constrain types (to be\nhomogeneous). We show that in the safe lambda calculus, there is no need to rename\nbound variables when performing substitution, as variable capture is guaranteed not to\nhappen. We also propose an adequate notion of \u03b2-reduction that preserves safety. In the\nsame vein as Schwichtenberg's 1976 characterization of the simply-typed lambda calculus,\nwe show that the numeric functions representable in the safe lambda calculus are exactly\nthe multivariate polynomials; thus conditional is not definable. We also give a characterization of representable word functions. We then study the complexity of deciding beta-eta\nequality of two safe simply-typed terms and show that this problem is PSPACE-hard. Finally we give a game-semantic analysis of safety: We show that safe terms are denoted by\nP-incrementally justified strategies. Consequently pointers in the game semantics of safe\n\u03bb-terms are only necessary from order 4 onwards.\n\nIntroduction\nBackground. The safety condition was introduced by Knapik, Niwi\u0144ski and Urzyczyn\nat FoSSaCS 2002 [19] in a seminal study of the algorithmics of infinite trees generated\nby higher-order grammars. The idea, however, goes back some twenty years to Damm\n[10] who introduced an essentially equivalent1 syntactic restriction (for generators of word\nlanguages) in the form of derived types. A higher-order grammar (that is assumed to be\nhomogeneously typed) is said to be safe if it obeys certain syntactic conditions that constrain\nthe occurrences of variables in the production (or rewrite) rules according to their typetheoretic order. Though the formal definition of safety is somewhat intricate, the condition\n1998 ACM Subject Classification: F.3.2, F.4.1.\nKey words and phrases: lambda calculus, higher-order recursion scheme, safety restriction, game\nsemantics.\nSome of the results presented here were first published in TLCA proceedings [8].\n1\nSee de Miranda's thesis [12] for a proof.\n\nl\n\nLOGICAL METHODS\nIN COMPUTER SCIENCE\n\nc\nDOI:10.2168/LMCS-5 (1:3) 2009\n\nCC\n\nW. Blum and C.-H. L. Ong\nCreative Commons\n\n\f2\n\nW. BLUM AND C.-H. L. ONG\n\nitself is manifestly important. As we survey in the following, higher-order safe grammars\ncapture fundamental structures in computation and offer clear algorithmic advantages:\n\u2022 Word languages. Damm and Goerdt [11] have shown that the word languages generated\nby order-n safe grammars form an infinite hierarchy as n varies over the natural numbers.\nThe hierarchy gives an attractive classification of the semi-decidable languages: Levels 0,\n1 and 2 of the hierarchy are respectively the regular, context-free, and indexed languages\n(in the sense of Aho [5]), although little is known about higher orders.\nRemarkably, for generating word languages, order-n safe grammars are equivalent to\norder-n pushdown automata [11], which are in turn equivalent to order-n indexed grammars [24, 25].\n\u2022 Trees. Knapik et al. have shown that the Monadic Second Order (MSO) theories of trees\ngenerated by safe (deterministic) grammars of every finite order are decidable2.\nThey have also generalized the equi-expressivity result due to Damm and Goerdt [11]\nto an equivalence result with respect to generating trees: A ranked tree is generated by an\norder-n safe grammar if and only if it is generated by an order-n pushdown automaton.\n\u2022 Graphs. Caucal [9] has shown that the MSO theories of graphs generated3 by safe grammars of every finite order are decidable. Recently Hague et al. have shown that the MSO\ntheories of graphs generated by order-n unsafe grammars are undecidable, but deciding\ntheir modal mu-calculus theories is n-EXPTIME complete [17].\nOverview. In this paper, we examine the safety condition in the setting of the lambda\ncalculus. Our first task is to transpose it to the lambda calculus and express it as an\nappropriate sub-system of the simply-typed theory. A first version of the safe lambda\ncalculus has appeared in an unpublished technical report [4]. Here we propose a more\ngeneral and cleaner version where terms are no longer required to be homogeneously typed\n(see Section 1 for a definition). The formation rules of the calculus are designed to maintain\na simple invariant: Variables that occur free in a safe \u03bb-term have orders no smaller than\nthat of the term itself. We can now explain the sense in which the safe lambda calculus is safe\nby establishing its salient property: No variable capture can ever occur when substituting\na safe term into another. In other words, in the safe lambda calculus, it is safe to use\ncapture-permitting substitution when performing \u03b2-reduction.\nThere is no need for new names when computing \u03b2-reductions of safe \u03bb-terms, because\none can safely \"reuse\" variable names in the input term. Safe lambda calculus is thus\ncheaper to compute in this na\u0131\u0308ve sense. Intuitively one would expect the safety constraint\nto lower the expressivity of the simply-typed lambda calculus. Our next contribution is to\ngive a precise measure of the expressivity deficit of the safe lambda calculus. An old result\nof Schwichtenberg [34] says that the numeric functions representable in the simply-typed\nlambda calculus are exactly the multivariate polynomials extended with the conditional\nfunction. In the same vein, we show that the numeric functions representable in the safe\nlambda calculus are exactly the multivariate polynomials.\n2It has recently been shown [30] that trees generated by unsafe deterministic grammars (of every finite\n\norder) also have decidable MSO theories. More precisely, the MSO theory of trees generated by order-n\nrecursion schemes is n-EXPTIME complete.\n3These are precisely the configuration graphs of higher-order pushdown systems.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n3\n\nOur last contribution is to give a game-semantic account of the safe lambda calculus.\nUsing a correspondence result relating the game semantics of a \u03bb-term M to a set of traversals [30] over a certain abstract syntax tree of the \u03b7-long form of M (called computation\ntree), we show that safe terms are denoted by P-incrementally justified strategies. In such\na strategy, pointers emanating from the P-moves of a play are uniquely reconstructible\nfrom the underlying sequence of moves and the pointers associated to the O-moves therein:\nSpecifically, a P-question always points to the last pending O-question (in the P-view) of a\ngreater order. Consequently pointers in the game semantics of safe \u03bb-terms are only necessary from order 4 onwards. Finally we prove that a \u03b2-normal \u03bb-term is safe if and only if\nits strategy denotation is (innocent and) P-incrementally justified.\n1. The safe lambda calculus\nHigher-order safe grammars. We first present the safety restriction as it was originally\ndefined [19]. We consider simple types generated by the grammar A ::= o | A \u2192 A. By\nconvention, \u2192 associates to the right. Thus every type can be written as A1 \u2192 * * * \u2192 An \u2192\no, which we shall abbreviate to (A1 , * * * , An , o) (in case n = 0, we identify (o) with o). We\nwill also use the notation An \u2192 B for every types A, B and positive natural number n > 0\ndefined by induction as: A1 \u2192 B = A \u2192 B and An+1 \u2192 B = A \u2192 (An \u2192 B). The order\nof a type is given by ord o = 0 and ord(A \u2192 B) = max(ord A + 1, ord B). We assume an\ninfinite set of typed variables. The order of a typed term or symbol is defined to be the\norder of its type. The set of applicative terms over a set of typed symbols is defined as its\nclosure under the application operation (i.e., if M : A \u2192 B and N : A are in the closure\nthen so does M N : B).\nA (higher-order) grammar is a tuple h\u03a3, N , R, Si, where \u03a3 is a ranked alphabet (in\nthe sense that each symbol f \u2208 \u03a3 is assumed to have type or \u2192 o where r is the arity of\nf ) of terminals; N is a finite set of typed non-terminals; S is a distinguished ground-type\nsymbol of N , called the start symbol; R is a finite set of production (or rewrite) rules, one\nfor each non-terminal F : (A1 , . . . , An , o) \u2208 N , of the form F z1 . . . zm \u2192 e where each zi\n(called parameter ) is a variable of type Ai and e is an applicative term of type o generated\nfrom the typed symbols in \u03a3 \u222a N \u222a {z1 , . . . , zm }. We say that the grammar is order-n just\nin case the order of the highest-order non-terminal is n.\nWe call higher-order recursion scheme a higher-order grammar that is deterministic\n(i.e., for each non-terminal F \u2208 N there is exactly one production rule with F on the left\nhand side). Higher-order recursion schemes are used as generators of infinite trees. The\ntree generated by a recursion scheme G is a possibly infinite applicative term, but\nviewed as a \u03a3-labelled tree; it is constructed from the terminals in \u03a3, and is obtained by\nunfolding the rewrite rules of G ad infinitum, replacing formal by actual parameters each\ntime, starting from the start symbol S. See e.g. [19] for a formal definition.\nExample 1.1. Let G be the following order-2 recursion scheme:\nS \u2192 Ha\nH z o \u2192 F (g z)\nF \u03c6(o,o) \u2192 \u03c6 (\u03c6 (F h))\nwhere the arities of the terminals g, h, a are 2, 1, 0 respectively. The tree\ngenerated by G is defined by the infinite term g a (g a (h (h (h * * * )))).\n\ng\ng\n\na\na\n\nh\nh.\n..\n\n\f4\n\nW. BLUM AND C.-H. L. ONG\n\nA type (A1 , * * * , An , o) is said to be homogeneous if ord A1 \u2265 ord A2 \u2265 * * * \u2265 ord An ,\nand each A1 , . . . , An is homogeneous [19]. We reproduce the following Knapik et al.'s\ndefinition [19].\nDefinition 1.2 (Safe grammar). (All types are assumed to be homogeneous.) A term of\norder k > 0 is unsafe if it contains an occurrence of a parameter of order strictly less than k,\notherwise the term is safe. An occurrence of an unsafe term t as a subexpression of a term\nt\u2032 is safe if it is in the context * * * (ts) * * * , otherwise the occurrence is unsafe. A grammar\nis safe if no unsafe term has an unsafe occurrence at a right-hand side of any production.\nExample 1.3. (i) Take H : ((o, o), o) and f : (o, o, o); the following rewrite rules are unsafe\n(In each case we underline the unsafe subterm that occurs unsafely):\nG(o,o) x\nF ((o,o),o,o,o) z x y\n\n\u2192\n\u2192\n\nH (f x)\nf (F (F z y) y (z x)) x\n\n(ii) The order-2 grammar defined in Example 1.1 is unsafe.\nSafety adapted to the lambda calculus. We assume a set \u039e of higher-order constants.\nWe use sequents of the form \u0393 \u22a2\u039e\n$ M : A to represent term-in-context where \u0393 is the\ncontext and A is the type of M . For convenience, we shall omit the superscript from \u22a2\u039e\ns\nwhenever the set of constants \u039e is clear from the context. The subscript in \u22a2\u039e\n$ specifies\nwhich type system is used to form the judgement: We use the subscript 'st' to refer to the\ntraditional system of rules of the Church-style simply-typed lambda calculus augmented\nwith constants from \u039e. We will introduce a new subscripts for each type system that we\ndefine. For simplicity we write (A1 , * * * , An , B) to mean A1 \u2192 * * * \u2192 An \u2192 B, where B is\nnot necessarily ground.\nDefinition 1.4. (i) The safe lambda calculus is a sub-system of the simply-typed lambda\ncalculus. It is defined as the set of judgements of the form \u0393 \u22a2s M : A that are derivable\nfrom the following Church-style system of rules:\n\u0393 \u22a2s M : A\n(const)\nf \u2208\u039e\n(wk)\n\u0393\u2282\u2206\n(var)\nx : A \u22a2s x : A\n\u22a2s f : A\n\u2206 \u22a2s M : A\n\u0393 \u22a2asa M : A \u2192 B \u0393 \u22a2s N : A\n\u0393 \u22a2asa M N : B\n\u0393 \u22a2asa M : A \u2192 B \u0393 \u22a2s N : A\n(app)\n\u0393 \u22a2s M N : B\n\n(appas )\n\n(abs)\n\n\u0393, x1 : A1 , . . . , xn : An \u22a2asa M : B\nAn\n1\n\u0393 \u22a2s \u03bbxA\n1 . . . xn .M : (A1 , . . . , An , B)\n\n(\u03b4)\n\n\u0393 \u22a2s M : A\n\u0393 \u22a2asa M : A\n\nord B \u2264 ord \u0393\n\nord(A1 , . . . , An , B) \u2264 ord \u0393\n\nwhere ord \u0393 denotes the set {ord y : y \u2208 \u0393} and \"c \u2264 S\" means that c is a lower-bound of\nthe set S. The subscripts in \u22a2s and \u22a2asa stand for \"safe\" and \"almost safe application\".\n(ii) The sub-system that is defined by the same rules in (i), such that all types that\noccur in them are homogeneous, is called the homogeneous safe lambda calculus.\n(iii) We say that a term M is safe if the judgement \u0393 \u22a2s M : T is derivable in the safe\nlambda calculus for some context \u0393 and type T .\n\n\fTHE SAFE LAMBDA CALCULUS\n\n5\n\nThe safe lambda calculus deviates from the standard definition of the simply-typed\nlambda calculus in a number of ways. First the rule (abs) can abstract several variables\nat once. (Of course this feature alone does not alter expressivity.) Crucially, the side\nconditions in the application rule and abstraction rule require the variables in the typing\ncontext to have orders no smaller than that of the term being formed. We do not impose\nany constraint on types. In particular, type-homogeneity, which was an assumption of the\noriginal definition of safe grammars [19], is not required here. Another difference is that we\nallow \u039e-constants to have arbitrary higher-order types.\nExample 1.5 (Kierstead terms). Consider the terms M1 = \u03bbf ((o,o),o) .f (\u03bbxo .f (\u03bby o .y)) and\nM2 = \u03bbf ((o,o),o) .f (\u03bbxo .f (\u03bby o .x)). The term M2 is not safe because in the subterm f (\u03bby o .x),\nthe free variable x has order 0 which is smaller than ord(\u03bby o .x) = 1. On the other hand,\nM1 is safe.\nIt is easy to see that valid typing judgements of the safe lambda calculus satisfy the\nfollowing simple invariant:\nLemma 1.6. If \u0393 \u22a2s M : A then every variable in \u0393 occurring free in M has order at least\nord M .\nDefinition 1.7. A term is an almost safe applications if it is safe or if it is of the form\nN1 . . . Nm for some m \u2265 1 where N1 is not an application and for every 1 \u2264 i \u2264 m, Ni is\nsafe.\nA term is almost safe if either it is an almost safe application, or if it is of the form\nA1\nn\n\u03bbx1 . . . xA\nn .M for n \u2265 1 and some almost safe application M .\nAn almost safe application is not necessarily safe but it can be used to form a safe term\nby applying sufficiently many safe terms to it. An almost safe term can be turned into\na safe term by either applying sufficiently many safe terms (if it is an application), or by\nabstracting sufficiently many variables (if it is an abstraction).\nWe have the following immediate lemma:\nLemma 1.8. A term M is\n(i) an almost safe application iff there is a derivation of \u0393 \u22a2asa M : T for some \u0393, T ;\nAn\n1\n(ii) almost safe iff \u0393 \u22a2asa M : T or if M \u2261 \u03bbxA\n1 . . . xn .N and \u0393 \u22a2asa N : T for some\n\u0393, T .\nIn particular, terms constructed with the rule (appas ) are almost safe applications.\nWhen restricted to the homogeneously-typed sub-system, the safe lambda calculus captures the original notion of safety due to Knapik et al. in the context of higher-order grammars:\nProposition 1.9. Let G = h\u03a3, N , R, Si be a grammar and let e be an applicative term\nAm }. A rule F z . . . z \u2192 e in R is safe\ngenerated from the symbols in N \u222a \u03a3 \u222a { z1A1 , * * * , zm\n1\nm\ne : o is a\n(in the original sense of Knapik et al.) if and only if z1 : A1 , * * * , zm : Am \u22a2\u03a3\u222aN\ns\nvalid typing judgement of the homogeneous safe lambda calculus.\nProof. We show by induction that\n\n\f6\n\nW. BLUM AND C.-H. L. ONG\n\n(i) z1 , . . . , zm \u22a2asa t : A is a valid judgement of the homogeneous safe lambda calculus\ncontaining no abstraction if and only if in the Knapik sense, all the occurrences of unsafe\nsubterms of t are safe occurrences.\n(ii) z1 , . . . , zm \u22a2s t : A is a valid judgement of the homogeneous safe lambda calculus\ncontaining no abstraction if and only if in the Knapik sense, all the occurrences of unsafe\nsubterms of t are safe occurrences, and all parameters occurring in t have order greater than\nord t.\nThe constant and variable rule are trivial. Application case: By definition, a term t0 . . . tn\nis Knapik-safe iff for all 0 \u2264 i \u2264 n, all the occurrences of unsafe subterms of ti are safe\noccurrences (in the Knapik sense), and for all 1 \u2264 j \u2264 n, the operands occurring in tj\nhave order greater than ord tj . The (appas ) rule and the induction hypothesis permit us to\nconclude.\nNow since e is an applicative term of ground type, the previous result gives: z1 , . . . , zm \u22a2s\ne : o is a valid judgement of the homogeneous safe lambda calculus iff all the occurrences\nof unsafe subterms of e are safe occurrences, which by definition of Knapik-safety is in turn\nequivalent to saying that the rule F z1 . . . zm \u2192 e is safe.\nIn what sense is the safe lambda calculus safe? It is an elementary fact that when performing \u03b2-reduction in the lambda calculus, one must use capture-avoiding substitution,\nwhich is standardly implemented by renaming bound variables afresh upon each substitution. In the safe lambda calculus, however, variable capture can never happen (as the\nfollowing lemma shows). Substitution can therefore be implemented simply by capturepermitting replacement, without any need for variable renaming. In the following, we write\nM {N/x} to denote the capture-permitting substitution4 of N for x in M .\nLemma 1.10 (No variable capture). There is no variable capture when performing capturepermitting substitution of N for x in M provided that \u0393, x : B \u22a2s M : A and \u0393 \u22a2s N : B are\nvalid judgements of the safe lambda calculus.\nProof. We proceed by structural induction on M . The variable, constant and application\ncases are trivial. For the abstraction case, suppose M \u2261 \u03bby.R where y = y1 . . . yp . If x \u2208 y\nthen M {N/x} = M and there is no variable capture.\nOtherwise, x 6\u2208 y. By Lemma 1.8 R is of the form M1 . . . Mm for some m \u2265 1\nwhere M1 is not an application and for every 1 \u2264 i \u2264 m, Mi is safe. Thus we have\nM {N/x} \u2261 \u03bby.M1 {N/x} . . . Mm {N/x}. Let i \u2208 {1..m}. By the induction hypothesis there\nis no variable capture in Mi {N/x}. Thus variable capture can only happen if the following two conditions are met: (i) x occurs freely in Mi , (ii) some variable yi for 1 \u2264 i \u2264 p\noccurs freely in N . By Lemma 1.6, (ii) implies ord yi \u2265 ord N = ord x and since x 6\u2208 y,\ncondition (i) implies that x occurs freely in the safe term \u03bby.R thus by Lemma 1.6 we have\nord x \u2265 ord \u03bby.R \u2265 1 + ord yi > ord yi which gives a contradiction.\nRemark 1.11. A version of the No-variable-capture Lemma also holds in safe grammars, as\nis implicit in (for example Lemma 3.2 of) the original paper [19].\nExample 1.12. In order to contract the \u03b2-redex in the term\nf : (o, o, o), x : o \u22a2st (\u03bb\u03c6(o,o) xo .\u03c6 x)(f x) : (o, o)\n4This substitution is done by textually replacing all free occurrences of x in M by N without performing\nvariable renaming. In particular for the abstraction case we have (\u03bby1 . . . yn .M ){N/x} = \u03bby1 . . . yn .M {N/x}\nwhen x 6\u2208 {y1 . . . yn }.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n7\n\none should rename the bound variable x to a fresh name to prevent the capture of the free\noccurrence of x in the underlined term during substitution. Consequently, by the previous\nlemma, the term is not safe (because ord x = 0 < 1 = ord f x).\nNote that \u03bb-terms that 'satisfy' the No-variable-capture Lemma are not necessarily\nsafe. For instance the \u03b2-redex in \u03bby o z o .(\u03bbxo .y)z can be contracted using capture-permitting\nsubstitution, even though the term is not safe.\nRelated work: In her thesis [12], de Miranda proposed a different notion of safe lambda\ncalculus. This notion corresponds to (a less general version of) our notion of homogeneous\nsafe lambda calculus. It can be showed that for pure applicative terms (i.e., with no lambdaabstraction) the two systems coincide. In particular a version of Proposition 1.9 also holds\nin de Miranda's setting [12]. In the presence of lambda abstraction, however, our system is\nless restrictive. For instance the term \u03bbf (o,o,o) xo .f x : (o, o) is typable in the homogeneous\nsafe lambda calculus but not in the safe lambda calculus \u00e0 la de Miranda. One can show\nthat de Miranda's system is in fact equivalent to the homogeneous long-safe lambda calculus\n(i.e., the restriction of the system of Def. 1.21 to homogeneous types).\nSafe beta reduction. From now on we will use the standard notation M [N/x] to denote\nthe substitution of N for x in M . It is understood that, provided that M and N are safe,\nthis substitution is capture-permitting.\nLemma 1.13 (Substitution preserves safety). Let \u0393 \u22a2s N : B. Then\n(i) \u0393, x : B \u22a2s M : A implies \u0393 \u22a2s M [N/x] : A;\n(ii) \u0393, x : B \u22a2asa M : A implies \u0393 \u22a2asa M [N/x] : A.\nThis is proved by an easy induction on the structure of the safe term M .\nIt is desirable to have an appropriate notion of reduction for our calculus. However the\nstandard \u03b2-reduction rule is not adequate. Indeed, safety is not preserved by \u03b2-reduction as\nthe following example shows. Suppose that w, z : o and f : (o, o, o) \u2208 \u03a3 then the safe term\n(\u03bbxo y o .f xy)zw \u03b2-reduces to (\u03bby o .f zy)w, which is unsafe since the underlined first-order\nsubterm contains a free occurrence of the ground-type variable z. However if we perform\none more reduction we obtain the safe term f zw. This suggests simultaneous contraction\nof \"consecutive\" \u03b2-redexes. In order to define this notion of reduction we first introduce\nthe corresponding notion of redex.\nIn the simply-typed lambda calculus a redex is a term of the form (\u03bbx.M )N . In the\nsafe lambda calculus, a redex is a succession of several standard redexes:\nDefinition 1.14. A safe redex is an almost safe application of the form\nAn\n1\n(\u03bbxA\n1 . . . xn .M )N1 . . . Nl\n\nfor l, n \u2265 1 such that M is an almost safe application. (Consequently each Ni is safe as well\nAn\n1\nas \u03bbxA\n1 . . . xn .M , and M is either safe or is an application of safe terms.)\nFor instance, in the case n < l, a safe redex has a derivation tree of the following form:\n\n\f8\n\nW. BLUM AND C.-H. L. ONG\n\n\u0393\u2032 , x\n\n...\n: A \u22a2s M : (An+1 , . . . , Al , B)\n\nAn\n1\n\u0393\u2032 \u22a2s \u03bbxA\n1 . . . xn .M : (A1 , . . . , Al , B)\nAn\n1\n\u0393 \u22a2s \u03bbxA\n1 . . . xn .M : (A1 , . . . , Al , B)\nAn\n1\n\u0393 \u22a2asa \u03bbxA\n1 . . . xn .M : (A1 , . . . , Al , B)\n\n(abs)\n(wk)\n(\u03b4)\n\n...\n\u0393 \u22a2s N1 : A1\n\nAn\n1\n\u0393 \u22a2asa (\u03bbxA\n1 . . . xn .M )N1 : (A2 , . . . Al , B)\n..\n.\n(appas )\nA1\nA\nn\n\u0393 \u22a2asa (\u03bbx1 . . . xn .M )N1 . . . Nl\u22121 : (Al , B)\n\n(appas )\n...\n\u0393 \u22a2s Nl : Al\n\nAn\n1\n\u0393 \u22a2s (\u03bbxA\n1 . . . xn .M )N1 . . . Nl : B\n\n(app)\n\nA safe redex is by definition an almost term, but it is not necessarily a safe term. For\ninstance the term (\u03bbxo y o .x)z is a safe redex but it is only an almost safe term. The reason\nwhy we call such redexes \"safe\" is because when they occur within a safe term, it is possible\nto contract them without braking the safety of the whole term. Before showing this result,\nwe first need to define how to contract safe redexes:\nDefinition 1.15 (Redex contraction). We use the abbreviations x = x1 . . . xn , N =\nN1 . . . Nl . The relation \u03b2s (when viewed as a function) is defined on the set of safe redexes as follows:\n\u0003\n\u0002\nAl+1\nAn\nAn\n1\n\u03b2s = { (\u03bbxA\n1 . . . xn .M )N1 . . . Nl 7\u2192 \u03bbxl+1 . . . xn .M N /x1 . . . xl | n > l}\nAn\n1\n\u222a { (\u03bbxA\n1 . . . xn .M )N1 . . . Nl 7\u2192 M [N1 . . . Nn /x] Nn+1 . . . Nl | n \u2264 l} .\n\nwhere M [R1 . . . Rk /z1 . . . zk ] denotes the simultaneous substitution in M of R1 ,. . . ,Rk for\nz1 , . . . , zk .\nLemma 1.16 (\u03b2s -reduction preserves safety). Suppose that M1 \u03b2s M2 . Then\n(i) M2 is almost safe;\n(ii) If M1 is safe then so is M2 .\nProof. Let M1 \u03b2s M2 for some safe redex M1 and term M2 of type A. By definition, M1 is\nBn\n1\nof the form (\u03bbxB\n1 . . . xn .M )N1 . . . Nl for some safe terms N1 , . . . , Nl and almost safe term\nBn\n1\nM of type C such that (\u03bbxB\n1 . . . xn .M ) is safe.\n\u2212 Suppose\u0002 n > l then\u0003 A = (Bl+1 , . . . , Bn , C). (i) By the Substitution Lemma 1.13, the\nterm M N /x1 . . . xl is an almost safe application: we have \u0393, xl+1 : Bl+1 , . . . xn : Bn \u22a2asa\n\u0003\n\u0002\nM N /x1 . . . xl : C. (Indeed, if M is safe then we apply the Substitution Lemma once;\notherwise it is of the form R1 . . . Rq where Ri is a safe term and we apply the lemma on\n\u0002\n\u0003\nBl+1\nn\n. . . xB\neach Ri .) Thus by definition, \u03bbxl+1\nn .M N /x1 . . . xl \u2261 M2 is almost safe.\n(ii) Suppose that M1 is safe. W.l.o.g. we can assume that the last rule used to\nform M1 is (app) (and not the weakening rule (wk)), thus the variables of the typing\ncontext \u0393 are precisely the free variables of M1 , and Lemma 1.6 gives us ord A \u2264\nord \u0393. This allows us to use the rule (abs) to form the safe term-in-context \u0393 \u22a2s\n\u0003\n\u0002\nBl+1\nn\n. . . xB\n\u03bbxl+1\nn .M N /x1 . . . xl \u2261 M2 : A.\n\u2212 Suppose n \u2264 l. (i) Again by the Substitution Lemma we have that M [N1 . . . Nn /x] is an\nalmost safe application: \u0393 \u22a2asa M [N1 . . . Nn /x] : C. If n = l then the proof is finished;\notherwise (n < l) we further apply the rule (appas ) l \u2212 n times which gives us the almost\nsafe application \u0393 \u22a2asa M2 : A.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n9\n\n(ii) Suppose that M1 is safe. If n = l then M2 \u2261 M [N1 . . . Nn /x] is safe by the\nSubstitution Lemma; If n < l then we obtain the judgement \u0393 \u22a2s M2 : A by applying\nthe rule (appas ) l \u2212 n \u2212 1 times on \u0393 \u22a2s M [N1 . . . Nn /x] : C followed by one application\nof (app).\nWe can now define a notion of reduction for safe terms.\nDefinition 1.17. The safe \u03b2-reduction, written \u2192\u03b2s , is the compatible closure of the\nrelation \u03b2s with respect to the formation rules of the safe lambda calculus (i.e., it is the\nsmallest relation such that if M1 \u03b2s M2 and C[M ] is a safe term for some context C[\u2212]\nformed with the rules of the simply-typed lambda calculus then C[M1 ] \u2192\u03b2s C[M2 ]).\nLemma 1.18 (\u03b2s -reduction preserves safety). If \u0393 \u22a2s M1 : A and M1 \u2192\u03b2s M2 then\n\u0393 \u22a2s M2 : A.\nProof. Follows from Lemma 1.16 by an easy induction.\nLemma 1.19. The safe reduction relation \u2192\u03b2s :\n(i) is a subset of the transitive closure of \u2192\u03b2 (\u2192\u03b2s \u2282\u0589\u03b2 );\n(ii) is strongly normalizing;\n(iii) has the unique normal form property;\n(iv) has the Church-Rosser property.\nProof. (i) Immediate from the definition: Safe \u03b2-reduction is just a multi-step \u03b2-reduction.\n(ii) This is because \u2192\u03b2s \u2282\u0589\u03b2 and, \u2192\u03b2 is strongly normalizing in the simply-typed \u03bbcalculus. (iii) It is easy to see that if a safe term has a beta-redex if and only if it has\na safe beta-redex (because a beta-redex can always be \"widen\" into consecutive beta-redex\nof the shape of those in Def. 1.15). Therefore the set of \u03b2s -normal forms is equal to the\nset of \u03b2s -normal forms. The uniqueness of \u03b2-normal form then implies the uniqueness of\n\u03b2s -normal form. (iv) is a consequence of (i) and (ii).\nEta-long expansion. The \u03b7-long normal form (or simply \u03b7-long form) of a term is obtained\nby hereditarily \u03b7-expanding the body of every lambda abstraction as well as every subterm\noccurring in an operand position (i.e., occurring as the second argument of some occurrence\nof the binary application operator). Formally the \u03b7-long form, written \u2308M \u2309, of a (typeannotated) term M of type (A1 , . . . , An , o) with n \u2265 0 is defined by cases according to the\nsyntactic shape of M :\n\u2308\u03bbx\u03c4 .N \u2309 \u2261 \u03bbx\u03c4 .\u2308N \u2309\n\u2308xN1 . . . Nm \u2309 \u2261 \u03bb\u03c6A .x\u2308N1 \u2309 . . . \u2308Nm \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309\n\u2308(\u03bbx\u03c4 .N )N1 . . . Np \u2309 \u2261 \u03bb\u03c6A .(\u03bbx\u03c4 .\u2308N \u2309)\u2308N1 \u2309 . . . \u2308Np \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309\nwhere m \u2265 0, p \u2265 1, x is either a variable or constant, \u03c6 = \u03c61 . . . \u03c6n and each \u03c6i : Ai is\nAn\n1\na fresh variable. The binder notation '\u03bb\u03c6A ' stands for '\u03bb\u03c6A\n1 . . . \u03c6n ' if n \u2265 1, and for '\u03bb'\n(called the dummy lambda) in the case n = 0. The base case of this inductive definition lies\nin the second clause for m = n = 0: \u2308x\u2309 \u2261 \u03bb.x.\nRemark 1.20. This transformation does not introduce new redexes therefore the \u03b7-long\nnormal form of a \u03b2-normal term is also \u03b2-normal.\nLet us introduce a new typing system:\n\n\f10\n\nW. BLUM AND C.-H. L. ONG\n\nDefinition 1.21. We define the set of long-safe terms by induction over the following\nsystem of rules:\n\u0393 \u22a2l M : A\n(constl )\nf \u2208\u039e\n(wkl )\n\u0393\u2282\u2206\n(varl )\nx : A \u22a2l x : A\n\u22a2l f : A\n\u2206 \u22a2l M : A\n(appl )\n\n\u0393 \u22a2l M : (A1 , . . . , An , B) \u0393 \u22a2l N1 : A1 . . .\n\u0393 \u22a2l M N1 . . . Nn : B\n\n(absl )\n\n\u0393, x1 : A1 , . . . , xn : An \u22a2l M : B\nAn\n1\n\u0393 \u22a2l \u03bbxA\n1 . . . xn .M : (A1 , . . . , An , B)\n\n\u0393 \u22a2l Nn : An\n\nord B \u2264 ord \u0393\n\nord(A1 , . . . , An , B) \u2264 ord \u0393\n\nThe subscript in \u22a2l stands for \"long-safe\". This terminology is deliberately suggestive\nof a forthcoming lemma. Note that long-safe terms are not necessarily in \u03b7-long normal\nform.\nObserve that the system of rules from Def. 1.21 is a sub-system of the typing system of\nDef. 1.4 where the application rule is restricted the same way as the abstraction rule (i.e.,\nit can perform multiple applications at once provided that all the variables in the context\nof the resulting term have order greater than the order of the term itself). Thus we clearly\nhave:\nLemma 1.22. If a term is long-safe then it is safe.\nIn general, long-safety is not preserved by \u03b7-expansion. For instance we have \u22a2l \u03bby o z o .y :\n(o, o, o) but performing one eta-expansion produces the term \u03bbxo .(\u03bby o z o .y)x : (o, o, o) which\nis not long-safe. On the other hand, \u03b7-reduction (of one variable) preserves long-safety:\nLemma 1.23 (\u03b7-reduction of one variable preserves long-safety). \u0393 \u22a2l \u03bb\u03c6\u03c4 .M \u03c6 : A with \u03c6\nnot occurring free in s implies \u0393 \u22a2l M : A.\nProof. Suppose \u0393 \u22a2l \u03bb\u03c6\u03c4 .M \u03c6 : A. If M is an abstraction then by construction of M is\nnecessarily safe. If M \u2261 N0 . . . Np with p \u2265 1 then again, since \u03bb\u03c6\u03c4 .N0 . . . Np \u03c6 is safe,\neach of the Ni is safe for 0 \u2264 i \u2264 p and for every variable z occurring free in \u03bb\u03c6.M \u03c6,\nord z \u2265 ord(\u03bb\u03c6\u03c4 .M \u03c6) = ord M . Since \u03c6 does not occur free in M , the terms M and\n\u03bb\u03c6\u03c4 .M \u03c6 have the same set of free variables, thus we can use the application rule to form\n\u0393\u2032 \u22a2l N0 . . . Np : A where \u0393\u2032 consists of the typing-assignments for the free variables of M .\nThe weakening rules permits us to conclude \u0393 \u22a2l M : A.\nLemma 1.24 (\u03b7-long expansion preserves long-safety). \u0393 \u22a2l M : A then \u0393 \u22a2l \u2308M \u2309 : A.\nProof. First we observe that for every variable or constant x : A we have x : A \u22a2l \u2308x\u2309 : A.\nWe show this by induction on ord x. It is verified for every ground type variable x since\nx = \u2308x\u2309. Step case: x : A with A = (A1 , . . . , An , o) and n > 0. Let \u03c6i : Ai be fresh variables\nfor 1 \u2264 i \u2264 n. Since ord Ai < ord x the induction hypothesis gives \u03c6i : Ai \u22a2l \u2308\u03c6i \u2309 : Ai .\nUsing (wkl ) we obtain x : A, \u03c6 : A \u22a2l \u2308\u03c6i \u2309 : Ai . The application rule gives x : A, \u03c6 : A \u22a2l\nx\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309 : o and the abstraction rule gives x : A \u22a2l \u03bb\u03c6.x\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309 = \u2308x\u2309 : A.\nWe now prove the lemma by induction on M . The base case is covered by the previous\nobservation. Step case:\n\u2022 M \u2261 xN1 . . . Nm with x : (B1 , . . . , Bm , A), A = (A1 , . . . , An , o) for some m \u2265 0, n > 0\nand Ni : Bi for 1 \u2264 i \u2264 m. Let \u03c6i : Ai be fresh variables for 1 \u2264 i \u2264 n. By the\nprevious observation we have \u03c6i : Ai \u22a2l \u2308\u03c6i \u2309 : Ai , the weakening rule then gives us\n\n\fTHE SAFE LAMBDA CALCULUS\n\n11\n\n\u0393, \u03c6 : A \u22a2l \u2308\u03c6i \u2309 : Ai . Since the judgement \u0393 \u22a2l xN1 . . . Nm : A is formed using the\n(appl ) rule, each Nj must be long-safe for 1 \u2264 j \u2264 m, thus by the induction hypothesis\nwe have \u0393 \u22a2l \u2308Nj \u2309 : Bj and by weakening we get \u0393, \u03c6 : A \u22a2l \u2308Nj \u2309 : Bj . The (appl )\nrule then gives \u0393, \u03c6 : A \u22a2l x\u2308N1 \u2309 . . . \u2308Nm \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309 : o. Finally the (absl ) rule gives\n\u0393 \u22a2l \u03bb\u03c6.x\u2308N1 \u2309 . . . \u2308Nm \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309 \u2261 \u2308M \u2309 : A, the side-condition of (absl ) being verified\nsince ord \u2308s\u2309 = ord s.\n\u2022 M \u2261 N0 . . . Nm where N0 is an abstraction and m \u2265 1. The eta-long normal form is\n\u2308M \u2309 \u2261 \u03bb\u03c6.\u2308N0 \u2309 . . . \u2308Nm \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6n \u2309 for some fresh variables \u03c61 , . . . , \u03c6n . Again, using\nthe induction hypothesis we can easily derive \u0393 \u22a2l \u2308M \u2309 : A.\n\u2022 M \u2261 \u03bb\u03b7 B .N where N of type C and is not an abstraction. The induction hypothesis\ngives \u0393, \u03b7 : B \u22a2l \u2308N \u2309 : C and using (absl ) we get \u0393 \u22a2l \u03bb\u03b7.\u2308N \u2309 \u2261 \u2308M \u2309 : A.\nRemark 1.25.\n(i) The converse of this lemma does not hold: performing \u03b7-reduction over a large abstraction does not in general preserve long-safety. (This does not contradict Lemma\n1.23 which states that safety is preserved when performing \u03b7-reduction on an abstraction of a single variable.) A counter-example is \u03bbf (o,o,o) g((o,o,o),o) .g(\u03bbxo .f x), which is\nnot long-safe but whose eta-normal form \u03bbf (o,o,o) g((o,o,o),o) .g(\u03bbxo y o .f xy) is long-safe.\nThere are also closed terms in eta-normal form that are not long-safe but have an\n\u03b7-long normal form that is long-safe! Take for instance the closed \u03b2\u03b7-normal term\n\u03bbf (o,(o,o),o,o) g((o,o),o,o,o),o) .g(\u03bby (o,o) xo .f xy).\n(ii) After performing \u03b7-long expansion of a term, all the occurrences of the application rule\nare made long-safe. Thus if a term remains not long-safe after \u03b7-long expansion, this\nmeans that some variable occurrence is not bound by the first following application of\nthe (abs) rule in the typing tree.\nLemma 1.26. A simply-typed term is safe if and only if its \u03b7-long normal form is long-safe.\nProof. Let \u0393 \u22a2st M : T . We want to show that we have \u0393 \u22a2s M : T if and only if\n\u0393 \u22a2l \u2308M \u2309 : T . The 'Only if' part can be proved by a trivial induction on the structure of \u0393 \u22a2s M : T . For the 'if' part we proceed by induction on the structure of the\nsimply-typed term M : The variable and constant cases are trivial. Suppose that M is an\napplication of the form xN1 . . . Nm : A for m \u2265 1. Its \u03b7-long normal form is of the form\nx\u2308N1 \u2309 . . . \u2308Nm \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6m \u2309 : o for some fresh variables \u03c61 , . . . \u03c6m . By assumption this\nterm is long-safe therefore we have ord A \u2264 ord \u0393 and for 1 \u2264 i \u2264 m, \u2308Ni \u2309 is also long-safe.\nBy the induction hypothesis this implies that the Ni s are all safe. We can then form the\njudgement \u0393 \u22a2s xN1 . . . Nm : A using the rules (var) and (\u03b4) followed by m \u2212 1 applications\nof the rule (appas ) and one application of (app) (this is allowed since we have ord A \u2264 ord \u0393).\nThe case M \u2261 (\u03bbx.N )N1 . . . Nm for m \u2265 1 is treated identically.\nSuppose that M \u2261 \u03bbxB .N : A. By assumption, its \u03b7-long n.f. \u03bbxB \u03c6C .\u2308N \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6m \u2309 :\nA (for some fresh variables \u03c6 = \u03c61 . . . \u03c6m and types C = C1 . . . Cm ) is long-safe. Thus\nwe have ord A \u2264 ord \u0393. Furthermore the long-safe subterm \u2308N \u2309\u2308\u03c61 \u2309 . . . \u2308\u03c6m \u2309 is precisely the eta-long normal form of N \u03c61 . . . \u03c6m : o therefore by the induction hypothesis\nwe have that N \u03c61 . . . \u03c6m : o is safe. Since the \u03c6i 's are all safe (by rule (var)), we can\n\"peel-off\" m applications (performed using the rules (appas ) or (app)) from the sequent\n\u0393, x : B, \u03c6 : C \u22a2s N \u03c61 . . . \u03c6m : o which gives us the sequent \u0393, x : B, \u03c6 : C \u22a2asa N : A. Since\nthe variables \u03c6 are fresh for N , we can further peel-off applications of the weakening rule\nto obtain the judgement \u0393, x : B \u22a2s N : A.\n\n\f12\n\nW. BLUM AND C.-H. L. ONG\n\nFinally since we have ord A \u2264 ord \u0393, we can use the rule (abs) to form the sequent\n\u0393 \u22a2s \u03bbxB .N : A.\nProposition 1.27. A term is safe if and only if its \u03b7-long normal form is safe.\nProof.\n(If):\n\n\u0393 \u22a2s \u2308M \u2309 : T =\u21d2 \u0393 \u22a2l \u2308M \u2309 : T\n=\u21d2 \u0393 \u22a2s M : T\n\n(Only if):\n\n\u0393 \u22a2s M : T =\u21d2 \u0393 \u22a2l \u2308M \u2309 : T\n\nBy Lemma 1.26 (only if),\nBy Lemma 1.26 (if).\nBy Lemma 1.26 (only if),\n\n=\u21d2 \u0393 \u22a2s \u2308M \u2309 : T\n\nBy Lemma 1.22.\n\nThe type inhabitation problem. It is well known that the simply-typed lambda calculus corresponds to intuitionistic implicative logic via the Curry-Howard isomorphism.\nThe theorems of the logic correspond to inhabited types, and every inhabitant of a type\nrepresents a proof of the corresponding formula. Similarly, we can consider the fragment\nof intuitionistic implicative logic that corresponds to the safe lambda calculus under the\nCurry-Howard isomorphism; we call it the safe fragment of intuitionistic implicative logic.\nWe would like to compare the reasoning power of these two logics, in other words, to\ndetermine which types are inhabited in the lambda calculus but not in the safe lambda\ncalculus.5\nIf types are generated from a single atom o, then there is a positive answer: Every\ntype generated from one atom that is inhabited in the lambda calculus is also inhabited in\nthe safe lambda calculus. Indeed, one can transform any unsafe inhabitant M into a safe\none of the same type as follows: Compute the eta-long beta normal form of M . Let x be\nan occurrence of a ground-type variable in a subterm of the form \u03bbx.C[x] where \u03bbx is the\nbinder of x and for some context C[\u2212] different from the identity (defined as C[R] \u2261 R\nfor all R). We replace the subterm \u03bbx.C[x] by \u03bbx.x in M . This transformation is sound\nbecause both C[x] and x are of the same ground type. We repeat this procedure until\nthe term stabilizes. This procedure clearly terminates since the size of the term decreases\nstrictly after each step. The final term obtained is safe and of the same type as M .\nThis argument cannot be generalized to types generated from multiple atoms. In\nfact there are order-3 types with only 2 atoms that are inhabited in the simply-typed\nlambda calculus but not in the safe lambda calculus. Take for instance the order-3 type\n(((b, a), b), ((a, b), a), a) for some distinct atoms a and b. It is only inhabited by the following\nfamily of terms which are all unsafe:\n\u03bbf ((b,a),b) g((a,b),a) .g(\u03bbxa1 .f (\u03bby1b .x1 ))\n\u03bbf ((b,a),b) g((a,b),a) .g(\u03bbxa1 .f (\u03bby1b .g(\u03bbxa2 .y1 )))\n\u03bbf ((b,a),b) g((a,b),a) .g(\u03bbxa1 .f (\u03bby1b .g(\u03bbxa2 .f (\u03bby2b .xi )))\n\nwhere i = 1, 2\n\n\u03bbf ((b,a),b) g((a,b),a) .g(\u03bbxa1 .f (\u03bby1b .g(\u03bbxa2 .f (\u03bby2b .g(\u03bbxa3 .yi )))\n...\n5This problem was raised to our attention by Ugo dal Lago.\n\nwhere i = 1, 2\n\n\fTHE SAFE LAMBDA CALCULUS\n\n13\n\nAnother example is the type of function composition. For any atom a and natural\nnumber n \u2208 N, we define the types na as follows: 0a = a and (n + 1)a = na \u2192 a. Take\nthree distinct atoms a, b and c. For any i, j, k \u2208 N, we write \u03c3(i, j, k) to denote the type\n\u03c3(i, j, k) \u2261 (ia \u2192 jb ) \u2192 (jb \u2192 kc ) \u2192 ia \u2192 kc .\nFor all i, j, k, this type is inhabited in the lambda calculus by the \"function composition\nterm\":\n\u03bbxyz.y(x z) .\nThis term is safe if and only if i \u2265 j (for the subterm x z is safe iff i = ord(ia ) = ord z \u2265\nord(x z) = ord(jb ) = j). In the case i < j, the type \u03c3(i, j, k) may still be safely inhabited.\nFor instance \u03c3(1, 3, 4) is inhabited by the safe term\n\u03bbx1a \u21923b y 3b \u21924c z 1c .y(x(\u03bbua .u)) .\nThe order-4 type \u03c3(0, 2, 0), however, is only inhabited by the unsafe term \u03bbxyz.y(xz).\nStatman showed [35] that the problem of deciding whether a type defined over an\ninfinite number of ground atoms is inhabited (or equivalently of deciding validity of an\nintuitionistic implicative formula) is PSPACE-complete. The previous observations suggest\nthat the validity problem for the safe fragment of implicative logic may not be PSPACEhard.\n2. Expressivity\n2.1. Numeric functions representable in the safe lambda calculus. Natural numbers can be encoded in the simply-typed lambda calculus using the Church Numerals: each\nn \u2208 N is encoded as the term n = \u03bbs(o,o) z o .sn z of type I = ((o, o), o, o) where o is a ground\ntype. We say that a p-ary function f : Np \u2192 N, for p \u2265 0, is represented by a term\nF : (I, . . . , I, I) (with p + 1 occurrences of I) if for all mi \u2208 N, 0 \u2264 i \u2264 p we have:\nF m1 . . . mp =\u03b2 f (m1 , . . . , mp ) .\nSchwichtenberg [34] showed the following:\nTheorem 2.1 (Schwichtenberg, 1976). The numeric functions representable by simplytyped lambda-terms of type I \u2192 . . . \u2192 I using the Church Numeral encoding are exactly the\nmultivariate polynomials extended with the conditional function.\nIf we restrict ourselves to safe terms, the representable functions are exactly the multivariate polynomials:\nTheorem 2.2. The functions representable by safe lambda-expressions of type I \u2192 . . . \u2192 I\nare exactly the multivariate polynomials.\nProof. Natural numbers are encoded as the Church Numerals: n = \u03bbsz.sn z for each\nn \u2208 N. Addition: For n, m \u2208 N, n + m = \u03bb\u03b1(o,o) xo .(n\u03b1)(m\u03b1x). Multiplication: n.m =\n\u03bb\u03b1(o,o) .n(m\u03b1). These terms are all safe, furthermore function composition can be safely encoded: take a function g : Nn \u2192 N represented by safe term G of type I n \u2192 I and functions\nf1 , . . . , fn : Np \u2192 N represented by safe terms F1 , . . . Fn respectively then the composed\nfunction (x1 , * * * , xp ) 7\u2192 g(f1 (x1 , . . . , xp ), . . . , fn (x1 , . . . , xp )) is represented by the safe term\n\u03bbc1 . . . cp .G(F1 c1 . . . cp ) . . . (Fn c1 . . . cp ). Hence any multivariate polynomial P (n1 , . . . , nk )\ncan be computed by composing the addition and multiplication terms as appropriate.\n\n\f14\n\nW. BLUM AND C.-H. L. ONG\n\nFor the converse, let U be a safe lambda-term of type I \u2192 I \u2192 I. The generalization\nto terms of type I n \u2192 I for every n \u2208 N is immediate (they correspond to polynomials with\nn variables). By Lemma 1.27, safety is preserved by \u03b7-long normal expansion therefore we\ncan assume that U is in \u03b7-long normal form.\nLet N\u03a3\u03c4 denote the set of safe \u03b7-long \u03b2-normal terms of type \u03c4 with free variables in\n\u03a3, and A\u03c4\u03a3 for the set of \u03b2-normal terms of type \u03c4 with free variables in \u03a3 and of the\nform \u03c6s1 . . . sm for some variable \u03c6 : (A1 , . . . , Am , o) where m \u2265 0 and for all 1 \u2264 i \u2264 m,\nsi \u2208 N\u03a3Ai . Observe that the set Ao\u03a3 contains only safe terms but the sets A\u03c4\u03a3 in general may\ncontain unsafe terms. Let \u03a3 denote the alphabet {x, y : I, z : o, \u03b1 : o \u2192 o}. By an easy\nreasoning (See the term grammar construction of Zaionc [37]), we can derive the following\nequations inducing a grammar over the set of terminals \u03a3 \u222a {\u03bbxy\u03b1z., \u03bbz.} that generates\n(I,I,I)\n:\nprecisely the terms of N\u2205\n(I,I,I)\n\nN\u2205\n\n\u2192\n\n\u03bbxy\u03b1z.Ao\u03a3\n(o,o)\n\nAo\u03a3\n\nAo\u03a3 \u2192\n\nz | A\u03a3\n\n(o,o)\n\n\u2192\n\n\u03b1 | AI\u03a3 N\u03a3\n\n(o,o)\n\n\u2192\n\n\u03bbz.Ao\u03a3\n\nAI\u03a3 \u2192\n\nx|y .\n\nA\u03a3\nN\u03a3\n\n(o,o)\n\nThe key rule is the fourth one: had we not imposed the safety constraint the right-hand side\n(o,o)\nwould instead be of the form \u03bbwo .A\u03a3\u222a{w:o} . Here the safety constraint imposes to abstract\nall the ground type variables occurring freely, thus only one free variable of ground type\ncan appear in the term and we can choose it to be named z up to \u03b1-conversion.\nWe extend the notion of representability to terms of type o, (o, o) and I with free\nvariables in \u03a3 as follows: A function f : N2 \u2192 N is represented by (i) \u03a3 \u22a2st F : o if and\nonly if for all m, n \u2208 N, F [m, n/x, y] =\u03b2 \u03b1f (m,n) z; (ii) \u03a3 \u22a2st G : (o, o) iff G[m, n/x, y] =\u03b2\n\u03bbz.\u03b1f (m,n) z; (iii) \u03a3 \u22a2st H : I iff H[m, n/x, y] =\u03b2 \u03bb\u03b1z.\u03b1f (m,n) z.\nWe now show by induction on the grammar rules that any term generated by the\ngrammar represents some polynomial: Base case: The term x and y represent the projection\nfunctions (m, n) 7\u2192 m and (m, n) 7\u2192 n respectively. The term \u03b1 and z represent the constant\nfunctions (m, n) 7\u2192 1 and (m, n) 7\u2192 0 respectively. Step case: The first and fourth rule are\ntrivial: for F \u2208 Ao\u03a3 , the terms \u03bbz.F and \u03bbxy\u03b1z.F represent the same function as F . We\nnow consider the second and third rule. We observe that for m, p, p\u2032 \u2265 0 we have\n(i) m (\u03bbz.\u03b1p z) =\u03b2 \u03bbz.\u03b1m*p z;\n\n\u2032\n\n\u2032\n\n(ii) (\u03bbz.\u03b1p z)(\u03b1p z) =\u03b2 \u03b1p+p z .\n\n(o,o)\n\nSuppose that F \u2208 AI\u03a3 and G \u2208 N\u03a3 represent the functions f and g respectively then\n(o,o)\nby (i), F G represents the function f \u00d7 g. If F \u2208 A\u03a3 and G \u2208 N\u03a3o represent the functions\nf and g then by (ii), F G represents the function f + g.\nHence U represents\nsome polynomial: for all m, n \u2208 N we have U m n =\u03b2 \u03bb\u03b1z.\u03b1p(m,n) z\nP\nwhere p(m, n) = 0\u2264k\u2264d mik njk for some ik , jk \u2265 0, d \u2265 0.\nCorollary 2.3. The conditional operator C : I \u2192 I \u2192 I \u2192 I satisfying:\n\u001a\ny, if t \u2192\u03b2 0 ;\nC t y z \u2192\u03b2\nz, if t \u2192\u03b2 n + 1 .\n\nis not definable in the simply-typed safe lambda calculus.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n15\n\nExample 2.4. The term \u03bbF GH\u03b1x.F (\u03bby.G\u03b1x)(H\u03b1x) used by Schwichtenberg [34] to define\nthe conditional operator is unsafe since the underlined subterm, which is of order 1, occurs\nat an operand position and contains an occurrence of x of order 0.\nRemark 2.5.\n(i) This corollary tells us that the conditional function is not definable when numbers are\nrepresented by the Church Numerals. It may still be possible, however, to represent\nthe conditional function using a different encoding for natural numbers. One way to\ncompensate for the loss of expressivity caused by the safety constraint is to introduce\ncountably many domains of representation for natural numbers. Such a technique is\nused to represent the predecessor function in the simply-typed lambda calculus [14].\n(ii) The boolean conditional can be represented in the safe lambda calculus as follows:\nWe encode booleans by terms of type B = (o, o, o). The two truth values are then\nrepresented by \u03bbxo y o .x and \u03bbxo y o .y and the conditional operator is given by the term\n\u03bbF B GB H B xo y o .F (G x y)(H x y).\n(iii) It is also possible to define a conditional operator behaving like the conditional operator\nC in the second-order lambda calculus [14]: natural numbers are represented by terms\nn \u2261 \u039bt.\u03bbst\u2192t z t .sn (z) of type J \u2261 \u2206t.(t \u2192 t) \u2192 (t \u2192 t) and the conditional is encoded\nby the term \u03bbF J GJ H J .F J (\u03bbuJ .G) H. Whether this term is safe or not cannot be\nanswered just yet as we do not have a notion of safety for second-order typed terms.\n2.2. Word functions definable in the safe lambda calculus. Schwichtenberg's result\non numeric functions definable in the lambda calculus was extended to richer structures:\nZaionc studied the problem for word functions, then functions over trees and eventually the\ngeneral case of functions over free algebras [20, 39, 38, 37, 40]. In this section we consider\nthe case of word functions expressible in the safe lambda calculus.\nWord functions. We consider a binary alphabet \u03a3 = {a, b}. The result of this section\nnaturally extends to all finite alphabets. We consider the set \u03a3\u2217 of all words over \u03a3. The\nempty words is denoted \u01eb. We write |w| to denote the length of the word w \u2208 \u03a3\u2217 . For any\nk \u2208 N we write k to denote the word a . . . a with k occurrences of a, so that |k| = k. For\nany n \u2265 1 and k \u2265 0, we write c(n, k) for the n-ary function (\u03a3\u2217 )n \u2192 \u03a3\u2217 that maps all\ninputs to the word k. We consider various word functions. Let x, y, z be words over \u03a3:\n\u2022 Concatenation app : (\u03a3\u2217 )2 \u2192 \u03a3\u2217 . The word app(x, y) is the concatenation of x and y.\n\u2022 Substitution sub : (\u03a3\u2217 )3 \u2192 \u03a3\u2217 . The word sub(x, y, z) is obtained from x by substituting\nthe word y for all occurrences of a and z for all occurrences of b. Formally:\nsub(\u01eb, y, z) = \u01eb ,\nsub(ax, y, z) = app(y, sub(x, y, z)) ,\nsub(bx, y, z) = app(z, sub(x, y, z)) .\n\u2022 Prefix-cut cuta : \u03a3\u2217 \u2192 \u03a3\u2217 . The word cuta x is the maximal prefix of x containing only\nthe letter 'a'. Formally:\ncuta (\u01eb) = \u01eb ,\ncuta (ax) = app(a, cuta (x)) ,\ncuta (bx) = \u01eb .\n\n\f16\n\nW. BLUM AND C.-H. L. ONG\n\n\u2022 Projections \u03c0k : (\u03a3\u2217 )n \u2192 \u03a3\u2217 for n \u2265 1, 1 \u2264 k \u2264 n defined as \u03c0k (x1 , . . . , xk , . . . , xn ) = xk .\n\u2022 Constant functions cstw : \u03a3\u2217 \u2192 \u03a3\u2217 for w \u2208 \u03a3\u2217 , mapping constantly onto the word w.\nAdditional operations can be obtained by combining the above functions [39]:\n\u2022 Prefix-cut cutb : \u03a3\u2217 \u2192 \u03a3\u2217 is defined by cutb (x) = sub(cuta (sub(x, b, a)), b, a).\n\u2022 Non-emptiness check sq : \u03a3\u2217 \u2192 \u03a3\u2217 (returns 0 if the word is \u01eb and 1 otherwise) is defined\nby sq(x) = cuta (app(sub(x, b, b), a).\n\u2022 Emptiness check sq : \u03a3\u2217 \u2192 \u03a3\u2217 is defined by sq(x) = sq(sq(x)).\n\u2022 Occurrence check occl : \u03a3\u2217 \u2192 \u03a3\u2217 of the letter l \u2208 \u03a3 (returns 1 if the word contains an\noccurrence of l and 0 otherwise) is defined by occl (x) = sq(sub(x, l, \u01eb)).\nRepresentability. We consider equality of terms modulo \u03b1, \u03b2 and \u03b7 conversion, and we write\nM =\u03b2\u03b7 N to denote this equality. For every simple type \u03c4 , we write Cl(\u03c4 ) for the set of\nclosed terms of type \u03c4 (modulo \u03b1, \u03b2 and \u03b7 conversion).\nTake the type B = (o \u2192 o) \u2192 (o \u2192 o) \u2192 o \u2192 o, called the binary word type [37].\nThere is a 1-1 correspondence between words over \u03a3 and closed terms of type B. Think\nof the first two parameters as concatenators for 'a' and 'b' respectively, and the third\nparameter as the constructor for the empty word. Thus the empty word \u01eb is represented by\n\u03bbuo\u2192o v o\u2192o xo .x; if w \u2208 \u03a3\u2217 is represented by a term W \u2208 Cl(B) then a * w is represented by\n\u03bbuo\u2192o v o\u2192o xo .u(W uvx) and b * w is represented by \u03bbuo\u2192o v o\u2192o xo .v(W uvx). For any word\nw \u2208 \u03a3\u2217 we write w to denote the term representation obtained that way. We say that the\nword function h : (\u03a3\u2217 )n \u2192 \u03a3\u2217 is represented by a closed term H \u2208 Cl(Bn \u2192 B) just if for\nall x1 , . . . , xn \u2208 B\u2217 , Hx1 . . . xn =\u03b2\u03b7 hx1 . . . xn .\nExample 2.6. The word functions app, sub, cuta , cutb , sq, sq, occa , occb defined above are\nrespectively represented by the following lambda-terms:\nAPP \u2261 \u03bbcduvx.cuv(duvx),\nCUTa \u2261 \u03bbcuvx.cu(\u03bby.x)x,\nSQ \u2261 \u03bbcuvx.c(\u03bby.ux)(\u03bby.ux)x,\nOCCa \u2261 \u03bbcuvx.c(\u03bby.ux)(\u03bby.y)x,\n\nSUB \u2261 \u03bbxdeuvx.c(\u03bby.duvy)(\u03bby.euvy)x,\nCUTb \u2261 \u03bbcuvx.c(\u03bby.x)vx,\nSQ \u2261 \u03bbcuvx.c(\u03bby.x)(\u03bby.x)(ux),\nOCCb \u2261 \u03bbcuvx.c(\u03bby.y)(\u03bby.ux)x.\n\nZaionc [37] showed that the \u03bb-definable word functions are generated by a finite base\nin the following sense:\nTheorem 2.7 (Zaionc [37]). The set of \u03bb-definable word functions is the minimal set containing: (i) the constant functions; (ii) the projections; (iii) concatenation app; (iv) substitution sub; (v) prefix-cut cuta ; and closed by composition.\nThe terms representing these basic operations are given in Example 2.6. We observe\nthat among them, only APP and SUB are safe; the other terms are all unsafe because they\ncontain terms of the form N (\u03bby.x) where x and y are of the same order. It turns out that\nAPP and SUB constitute a base of terms generating all the functions definable in the safe\nlambda calculus as the following theorem states:\nTheorem 2.8. Let \u03bbsafe def denote the minimal set containing the following word functions\nand closed by composition:\n(i) the projections;\n(ii) the constant functions;\n\n\fTHE SAFE LAMBDA CALCULUS\n\n17\n\n(iii) concatenation app;\n(iv) substitution sub.\nThe set of word functions definable in the safe lambda calculus is precisely \u03bbsafe def.\nThe proof follows the same steps as Zaionc's proof. The first direction is immediate:\nProjections are represented by safe terms of the form \u03bbx1 . . . xn .xi for some i \u2208 {1..n}, and\nconstant functions by \u03bbx1 . . . xn .w for some w \u2208 \u03a3\u2217 . The terms APP and SUB are safe\nand represent concatenation and substitution. For closure by composition: take a function\ng : (\u03a3\u2217 )n \u2192 \u03a3\u2217 represented by safe term G \u2208 Cl(Bn \u2192 B) and functions f1 , . . . , fn :\n(\u03a3\u2217 )p \u2192 \u03a3\u2217 represented by safe terms F1 , . . . Fn respectively then the function\n(x1 , * * * , xp ) 7\u2192 g(f1 (x1 , . . . , xp ), . . . , fn (x1 , . . . , xp ))\nis represented by the term \u03bbc1 . . . cp .G(F1 c1 . . . cp ) . . . (Fn c1 . . . cp ) which is also safe.\nTo show the other direction we need to introduce some more definitions. We will write\nOp(n, k) to denote the set of open terms M typable as follows:\nc1 : B, . . . cn : B, u : (o, o), v : (o, o), xk\u22121 : o, . . . , x0 : o \u22a2st M : o .\nThus we have the following equality (modulo \u03b1, \u03b2 and \u03b7 conversions) for n, k \u2265 1:\nB (o,o) (o,o) o\nv\nxk\u22121 . . . xo0 .M | M \u2208 Op(n, k)}\nCl(\u03c4 (n, k)) = {\u03bbcB\n1 . . . cn u\n\nwriting \u03c4 (n, k) as a shorthand for the type Bn \u2192 (o, o)2 \u2192 ok \u2192 o. We generalize the\nnotion of representability to terms of type \u03c4 (n, k) as follows:\nDefinition 2.9 (Function pair representation). A closed term T \u2208 Cl(\u03c4 (n, k)) represents\nthe pair of functions (f, p) where f : (\u03a3\u2217 )n \u2192 \u03a3\u2217 and p : (\u03a3\u2217 )n \u2192 {0, . . . , k \u2212 1} if for\nall w1 , . . . , wn \u2208 \u03a3\u2217 and for every i \u2208 {0 . . . , k \u2212 1} we have:\nT w1 . . . wn =\u03b2\u03b7 \u03bbuvxk\u22121 . . . x0 .f (w1 , . . . , wn )uvx|p(w1 ,...,wn )| .\nBy extension we will say that an open term M from Op(n, k) represents the pair (f, p) just\nif M [w1 . . . wn /c1 . . . cn ] =\u03b2\u03b7 f (w1 , . . . , wn )uvx|p(w1 ,...,wn )| .\nWe will call safe pair any pair of functions of the form (w, c(n, i)) where 0 \u2264 i \u2264 k \u2212 1\nand w is an n-ary function from \u03bbsafe def.\nTheorem 2.10 (Characterization of the representable pairs). The function pairs representable in the safe lambda calculus are precisely the safe pairs.\nProof. (Soundness). Take a pair (w, c(n, i)) where 0 \u2264 i \u2264 k \u2212 1 and w is an n-ary function\nfrom \u03bbsafe def. As observed earlier, all the functions from \u03bbsafe def are representable in the safe\nlambda calculus: Let w be the representative of w. The pair (w, c(n, i)) is then represented\nby the term \u03bbc1 . . . cn uvxk\u22121 . . . x0 .wc1 . . . cn uvxi .\n(Completeness) It suffices to consider safe \u03b2-\u03b7-long normal terms from Op(n, k) only.\nThe result then follows immediately for every safe term in Cl(\u03c4 (n, k)). The subset of\nOp(n, k) consisting of \u03b2-\u03b7-long normal terms is generated by the following grammar [37]:\n(\u03b1ki ) Rk \u2192 xi\n(\u03b2 k )\n\n| uRk\n\n(\u03b3 k )\n\n| vRk\n\n\f18\n\nW. BLUM AND C.-H. L. ONG\n\nQk (Rk+1 )\n\n}|\n{\nz\n| cj (\u03bbz k .Rk+1 [z k , x0 , . . . , xk\u22121 /x0 , x1 , . . . , xk ])\n\n(\u03b4jk )\n\n(\u03bbz k .Rk+1 [z k , x0 , . . . , xk\u22121 /x0 , x1 , . . . , xk ])\nRk\n\nfor k \u2265 1, 0 \u2264 i < k, 0 \u2264 j \u2264 n. The notation M [. . . / . . .] denotes the usual simultaneous\nsubstitution. The non-terminals are Rk for k \u2265 1 and the set of terminals is {z k , \u03bbz k | k \u2265\n1} \u222a {xi |i \u2265 0} \u222a {c1 , . . . , cn , u, v}.\nThe name of each rule is indicated in parenthesis. We identify a rule name with the\nright-hand side of the rule, thus \u03b1ki belongs to Op(n, k), \u03b2 k and \u03b3 k are functions from\nOp(n, k) to Op(n, k), and \u03b4jk is a function from Op(n, k + 1) \u00d7 Op(n, k + 1) \u00d7 Op(n, k) to\nOp(n, k).\nWe now want to characterize the subset consisting of all safe terms generated by this\ngrammar. The term \u03b1ki is always safe; \u03b2 k (M ) and \u03b3 k (M ) are safe if and only if M is; and\n\u03b4jk (F, G, H) is safe if and only if Qk (F ), Qk (G) and H are safe. The free variables of Qk (F )\nbelong to {c1 , . . . cn , u, v, x0 , . . . xk } thus they have order greater than ord z except the xi s\nwhich have the same order as z. Hence since the xi s are not abstracted together with z we\nhave that Qk (F ) is safe if and only if F is safe and the variables x0 . . . xk do not appear free\nin F [z k , x0 , . . . , xk\u22121 /x0 , x1 , . . . , xk ], or equivalently if the variables x1 . . . xk do not appear\nfree in F . Similarly, Qk (G) is safe if and only if G is safe and the variables x1 . . . xk do not\nappear free in G.\nWe therefore need to identify the subclass of terms generated by the non-terminal Rk\nwhich are safe and which do not have any free occurrence of variables in {x1 . . . xk\u22121 }. By\nimposing this requirement to the rules of the previous grammar we obtain the following\nspecialized grammar characterizing the desired subclass:\n(\u03b1k0 ) R\nk\n\nk\n\n\u2192 x0\n\n(\u03b2 )\n\n| uR\n\n(\u03b3 k )\n\n| vR\n\nk\n\n(\u03b4 j )\n\nk\n\nk\n\n| cj (\u03bbz k .R\n\nk+1\n\n[z k /x0 ]) (\u03bbz k .R\n\nk+1\n\nk\n\n[z k /x0 ]) R .\n\nFor every term M , Qk (M ) is safe if and only if M can be generated from the non-terminal\nk\nR . Thus the subset of Cl(\u03c4 (n, k)) consisting of safe beta-normal terms is given by the\ngrammar:\nek\n(e\n\u03c0 k ) Se \u2192 \u03bbc1 . . . cn uvxk\u22121 . . . x0 .R\ne k \u2192 xi\n(e\n\u03b1ki ) R\nek\n(\u03b2ek )\n| uR\nek\n(e\n\u03b3k)\n| vR\n(\u03b4ejk )\n\nek .\n| cj (\u03bbz k .Rk+1 [z k /x0 ]) (\u03bbz k .Rk+1 [z k /x0 ]) R\n\nTo conclude the proof it thus suffices to show that every term generated by this grammar\ne represents a safe pair.\n(starting with the non-terminal S)\n\n\fTHE SAFE LAMBDA CALCULUS\n\n19\n\nk\n\nWe proceed by induction and show that the non-terminal R generates terms representek generate terms representing\ning pairs of the form (w, c(n, 0)) while non-terminals Se and R\npairs of the form (w, c(n, i)) for 0 \u2264 i < k and w \u2208\u03bbsafedef.\neki represents\nBase case: The term \u03b1k0 represents the safe pair (c(n, 0), c(n, 0)) while \u03b1\nthe safe pair (c(n, 0), c(n, i)). Step case: Suppose T \u2208 Op(n, k) represents a pair (w, p).\nk\nThen \u03b2 (T ) and \u03b2ek (T ) represent the pair (app(a, w), p); \u03b3 k (T ) and \u03b3\nek (T ) represent the\nk\npair (app(b, w), p); and \u03c0 (T ) \u2208 Cl(\u03c4 (n, k)) represents the pair (w, p). Now suppose that E,\nF and G represent the pairs (we , c(n, 0)), (wf , c(n, 0)) and (wg , c(n, i)) respectively. Then\nwe have:\n\u03b4ek (E, F, G)[w1 . . . wn /c1 . . . cn ]\nj\n\n= wj (\u03bbz k .E[z k /x0 ])[w1 . . . wn /c1 . . . cn ]\n\n(\u03bbz k .F [z k /x0 ])[w1 . . . wn /c1 . . . cn ]\nG[w1 . . . wn /c1 . . . cn ]\n=\u03b2\u03b7 wj (\u03bbz k .E[w1 . . . wn /c1 . . . cn ][z k /x0 ])\n(\u03bbz k .F [w1 . . . wn /c1 . . . cn ][z k /x0 ])\n(wg (w1 . . . wn ) u v xi )\n=\u03b2\u03b7 wj (\u03bbz k .(we (w1 . . . wn ) u v x0 )[z k /x0 ])\n(\u03bbz k .(wf (w1 . . . wn ) u v x0 )[z k /x0 ])\n\nG represents (h, c(n, i))\nE represents (f, c(n, 0))\nF represents (g, c(n, 0))\n\n(wg (w1 . . . wn ) u v xi )\n=\u03b2\u03b7 wj (\u03bbz k .we (w1 . . . wn ) u v z k )\n(\u03bbz k .wf (w1 . . . wn ) u v z k )\n(wg (w1 . . . wn ) u v xi )\n=\u03b7 wj (we (w1 . . . wn ) u v) (wf (w1 . . . wn ) u v) (wg (w1 . . . wn ) u v xi )\n=\u03b2\u03b7 w u v xi\nwhere the word function w is defined as\nw : w1 , . . . , wn 7\u2192 app(sub(wj , we (w1 , . . . , wn ), wf (w1 , . . . , wn )), wg (x1 , . . . , wn )) .\nHence \u03b4ejk (E, F, G) represents the pair (w, c(n, i)).\nThe same argument shows that if E, F and G all represent safe pairs then so does\nk\n\u03b4 j (E, F, G).\nTheorem 2.8 is obtained by instantiating Theorem 2.10 with terms of types \u03c4 (n, 1) =\nI n \u2192 I: every closed safe term of this type represents some n-ary function from \u03bbsafe def.\n2.3. Representability of functions over other structures.\nThere is an isomorphism between binary trees and closed terms of type \u03c4 = (o \u2192\no \u2192 o) \u2192 o \u2192 o. Thus a closed term of type \u03c4 \u2192 \u03c4 \u2192 . . . \u2192 \u03c4 represents an n-ary\nfunction over trees. Zaionc gave a characterization of the set of tree functions representable\nin the simply-typed lambda calculus [38]: It is precisely the minimal set containing constant\nfunctions, projections and closed under composition and limited primitive recursion. Zaionc\n\n\f20\n\nW. BLUM AND C.-H. L. ONG\n\nshowed that the same characterization holds for the general case of functions expressed over\n(different) free algebras [39, 40] (they are again given by the minimal set containing constant\nfunctions, projections and closed under composition and limited primitive recursion). This\nresult subsumes Schwichtenberg's result on definable numeric functions as well as Zaionc's\nown results on definable word and tree functions.\nWe have seen that constant functions, projections and composition can be encoded by\nsafe terms. Limited primitive recursion, however, cannot be encoded in the safe lambda\ncalculus (It can be used to define the conditional operator and the cuta word function). We\nexpect an appropriate restriction to limited recursion to characterize the functions over free\nalgebras representable in the safe lambda calculus.\n3. Complexity of the safe lambda calculus\nThis section is concerned with the complexity of the beta-eta equivalence problem for\nthe safe lambda calculus: Given two safe lambda-terms, are they equivalent up to \u03b2\u03b7conversion?\n3.1. Statman's result. Let exph (m) denote the tower-of-exponential function defined by\ninduction as exp0 (m) = m and exph+1 (m) = 2exph (m) . A program is elementary recursive\nif its run-time can be bounded by expK (n) for some constant K where n is the length of\nthe input.\nWe recall the definition of finite type theory. We define D0 = {true, false} and Dk+1 =\nP(Dk ) (i.e., the powerset of Dk ). For k \u2265 0, we write xk , y k and z k to denote variables\nranging over Dk . Prime formulae are x0 , true \u2208 y 1 , false \u2208 y 1 , and xk \u2208 y k+1 . Formulae\nare built up from prime formulae using the logical connectives \u2227,\u2228,\u2192,\u00ac and the quantifiers\n\u2200 and \u2203. Meyer showed that deciding the validity of such formulae requires nonelementary\ntime [26].\nA famous result by Statman states that deciding the \u03b2\u03b7-equality of two first-order\ntypable lambda-terms is not elementary recursive [36]. The proof proceeds by encoding\nthe Henkin quantifier elimination of type theory in the simply-typed lambda calculus and\nby appealing to Meyer's result [26]. Simpler proofs have subsequently been given: one by\nMairson [23] and another by Loader [22]. Both proceed by encoding the Henkin quantifier\nelimination procedure in the lambda calculus, as in the original proof, but their use of list\niteration to implement quantifier elimination makes them much easier to understand.\nIt turns out that all these encodings rely on unsafe terms: Statman's encoding uses\nthe conditional function sg which is not definable in the safe lambda calculus [8]; Mairson's\nencoding uses unsafe terms to encode both quantifier elimination and set membership, and\nLoader's encoding uses unsafe terms to build list iterators. We are thus led to conjecture\nthat finite type theory (see definition in Sec. 3.2) is intrinsically unsafe in the sense that\nevery encoding of it in the lambda calculus is necessarily unsafe. Of course this conjecture\ndoes not rule out the possibility that another non-elementary problem is encodable in the\nsafe lambda calculus.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n21\n\n3.2. Mairson's encoding. We refer the reader to Mairson's original paper [23] for a detailed account of his encoding. We show here why Mairson's encoding does not work in\nthe safe lambda calculus. We then introduce a variation that eliminates some of the unsafety. Although the resulting encoding does not suffice to interpret type theory in the\nsafe lambda calculus, it enables another interesting encoding: that of the True Quantifier\nBoolean Formula (TQBF) problem. This implies that deciding beta-eta equality of safe\nterms is PSPACE-hard.\n3.2.1. Sources of unsafety. In Mairson's encoding, boolean values are encoded by terms of\ntype B = \u03c3 \u2192 \u03c3 \u2192 \u03c3 for some type \u03c3, and variables of order k \u2265 0 are encoded by terms\nof type \u2206k defined as \u22060 \u2261 B and \u2206k+1 \u2261 (\u2206k \u2192 \u03c4 \u2192 \u03c4 ) \u2192 \u03c4 \u2192 \u03c4 for any type \u03c4 . Using\nthis encoding, unsafety manifests itself in three different places:\n(i) Set membership: The prime formula \"xk \u2208 y k+1 \" is encoded by a term-in-context of\nthe form\nx : \u2206k , y : \u2206k+1 \u22a2st y(\u03bbz \u2206k .M (x, z)) F : \u2206k \u2192 \u2206k+1 \u2192 \u22060\n\n(3.1)\n\nfor some term F and term M (x, z) containing free occurrences of x and z. This is\nunsafe because the free occurrence of x in M (x, z) is not abstracted together with z.\n(ii) Quantifier elimination is implemented using a list iterator Dk+1 of type \u2206k+2 which\nacts like the foldr function (from functional programming) over the list of all elements\nof Dk . Thus nested quantifiers in the formula are encoded by nested list iterations.\nThis can be source of unsafety, for instance the formula \"\u2200x0 .\u2203y 0 .x0 \u2228 y 0 \" is encoded\nas\n\u22a2st D0 (\u03bbx\u22060 .AN D(D0 (\u03bby \u22060 .OR(x \u2228 y))F )) T : B\nfor some terms AN D, OR, F and T and where the type \u03c4 is instantiated as B. This\nterm is unsafe due to the underlined occurrence which is unsafely bound.\nMore generally, nested binding will be encoded safely if and only if every variable x\nin the formula is bound by the first quantifier \u2203z or \u2200z satisfying ord z \u2265 ord x in the\npath to the root of the formula AST. So for example if set-membership were safely\nencodable then the interpretation of \"\u2200xk .\u2203y k+1 .xk \u2208 y k+1 \" would be unsafe whereas\nthat of \"\u2200y k+1 .\u2203xk .xk \u2208 y k+1 \" would be safe.\n(iii) Elements of the type hierarchy. The base set D0 of booleans is represented by a safe\nterm D0 of type \u22060 . Higher-order sets Dk for k \u2265 1 are represented by unsafe terms\nDk : they are constructed from D0 using a powerset construction that is unsafe.\nThe second source of unsafety can be easily overcome, the idea is as follows. We\nintroduce multiple domains of representation for a given formula. An element of Dk is\nthereby represented by countably many terms of type \u2206nk where n \u2208 N indicates the level\nof the domain of representation. The type \u2206nk is defined in such a way that its order\nstrictly increases as n grows. Furthermore, there exists a term that can lower the domain\nof representation of a given term. Thus each formula variable can have a different domain\nof representation, and since there are infinitely many such domains, it is always possible to\nfind an assignment of representation domains to variables such that the resulting encoding\nterm is safe.\nThere is no obvious way to eliminate unsafety in the two other cases however. For\ninstance in the case of set-membership, Mairson's encoding (3.1) could be made safe by\n\n\f22\n\nW. BLUM AND C.-H. L. ONG\n\nappealing to a term that changes the domain of representation of an encoded higher-order\nvalue of the type-hierarchy. Unfortunately, such transformation is intrinsically unsafe!\nIn the following paragraphs we present in detail a variation over Mairson's encoding in\nwhich quantifier elimination is safely encoded.\n3.2.2. Encoding basic boolean operations. Let o be a base type and define the family of\ntypes \u03c30 \u2261 o, \u03c3n+1 \u2261 \u03c3n \u2192 \u03c3n satisfying ord \u03c3n = n. Booleans are encoded over domains\nBn \u2261 \u03c3n \u2192 o \u2192 o \u2192 o for n \u2265 0, each type Bn being of order n+1. We write in+1 to denote\nthe term \u03bbx\u03c3n .x of type \u03c3n+1 for n \u2265 0. The truth values true and false are represented\nby the following terms parameterized by n \u2208 N:\nT n \u2261 \u03bbu\u03c3n xo y o .x : Bn\nF n \u2261 \u03bbu\u03c3n xo y o .y : Bn .\nClearly these terms are safe. Moreover the following relations hold for all n, n\u2032 \u2265 0:\n\u03bbu\u03c3n\u2032 .T n+1 in+1 \u2192\u03b2 T n\n\n\u2032\n\u2032\n\n\u03bbu\u03c3n\u2032 .F n+1 in+1 \u2192\u03b2 F n .\nIt is then possible to change the domain of representation of a Boolean value from a higherlevel to another arbitrary level using the conversion term:\n\u2032\n\n\u2192n\nCn+17\n\u2261 \u03bbmBn+1 u\u03c3n\u2032 .m in+1 : Bn+1 \u2192 Bn\u2032\n0\n\nso that if a term M of type Bn , for n \u2265 1, is beta-eta convertible to T n (resp. F n ) then\n\u2032\n\u2032\n\u2032\nCn70 \u2192n M of type Bn\u2032 is beta-eta convertible to T n (resp. F n ).\n\u2192 n\u2032\nObserve that although Cn+17\nis safe for all n, n\u2032 \u2265 0, if we apply a variable to it then\n0\nthe resulting term-in-context\n\u2032\n\n\u2192n\nx : Bn+1 \u22a2st Cn+17\nx : Bn\n0\n\nis safe if and only if ord Bn+1 \u2265 ord Bn\u2032 , that is to say if and only if the transformation\ndecreases the domain of representation of x.\nBoolean functions are encoded by the following closed safe terms parameterized by n:\nAN D n \u2261 \u03bbpBn q Bn u\u03c3n xo y o .p u (q u x y) y : Bn \u2192 Bn \u2192 Bn\nORn \u2261 \u03bbpBn q Bn u\u03c3n xo y o .p u x (q u x y) : Bn \u2192 Bn \u2192 Bn\nN OT n \u2261 \u03bbpBn u\u03c3n xo \u03bby o .p u y x : Bn \u2192 Bn \u2192 Bn .\n3.2.3. Coding elements of the type hierarchy. For every n \u2208 N we define the hierarchy of\ntype \u2206nk as follows: \u2206n0 \u2261 Bn and \u2206nk+1 \u2261 \u2206nk \u2217 where for a given type \u03b1, \u03b1\u2217 = (\u03b1 \u2192 \u03c4 \u2192\n\u03c4 ) \u2192 \u03c4 \u2192 \u03c4 for any type \u03c4 . We encode an occurrence xk of a formula variable by a term\nvariable xk of type \u2206nk for some level of domain representation n \u2208 N. Following Mairson's\nencoding, each set Dk is represented by a list Dnk consisting of all its elements:\nDn0 \u2261 \u03bbcBn \u2192\u03c4 \u2192\u03c4 e\u03c4 .c T n (c F n e) : \u2206n1\nDnk+1 \u2261 powerset\u2206nk Dnk : \u2206nk+2\nwhere\n\u2217\u2217 \u2192\u03b1\u2217\u2217 )\u2192\u03b1\u2217\u2217 \u2192\u03b1\u2217\u2217\n\npowerset\u03b1 \u2261 \u03bbA\u2217 (\u03b1\u2192\u03b1\n\n.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n\u2217 \u2192\u03c4 \u2192\u03c4\n\nA\u2217 double\u03b1 (\u03bbc\u03b1\n\n23\n\nb\u03c4 .c (\u03bbc\u2032\u03b1\u2192\u03c4 \u2192\u03c4 b\u2032\u03c4 .b\u2032 ) b)\n\n: ((\u03b1 \u2192 \u03b1\u2217\u2217 \u2192 \u03b1\u2217\u2217 ) \u2192 \u03b1\u2217\u2217 \u2192 \u03b1\u2217\u2217 ) \u2192 \u03b1\u2217\u2217\n\u2217 \u2192\u03c4 \u2192\u03c4 )\u2192\u03c4 \u2192\u03c4\n\ndouble\u03b1 \u2261 \u03bbx\u03b1 l(\u03b1\n\n\u2217 \u2192\u03c4 \u2192\u03c4\n\nc\u03b1\n\nb\u03c4 .\n\n\u2217\n\nl(\u03bbe\u03b1 .c (\u03bbc\u2032\u03b1\u2192\u03c4 \u2192\u03c4 b\u2032\u03c4 .c\u2032 x (e c\u2032 b\u2032 )))(l c b)\n: \u03b1 \u2192 \u03b1\u2217\u2217 \u2192 \u03b1\u2217\u2217 .\n(In the definition of Dnk+1 , to see why it is possible to apply powerset\u2206nk and Dnk one needs\nto understand that the term Dnk is of type \u2206nk+1 polymorphic in \u03c4 . The application can\nthus be typed by taking \u03c4 \u2261 \u2206nk+2 in the term Dnk .)\nObserve that the term double is unsafe because the underlined variable occurrence x is\nnot bound together with c\u2032 . Consequently for all n \u2265 0, Dn0 is safe and Dnk is unsafe for all\nk > 0.\n3.2.4. Quantifier elimination. Terms of type \u2206nk+1 are now used as iterators over lists of\nelements of type \u2206nk and we set \u03c4 \u2261 Bn in the type \u2206nk+1 in order to iterate a level-n\nBoolean function. Since ord \u2206nk \u2265 ord Bn for all n, all the instantiations of the terms\nDnk will be safe (although the terms Dnk themselves are not safe for k > 1). Following\n[23], quantifier\nelimination interprets\nthe formula \u2200xk .\u03a6(xk ) as the iterated conjunction\n\u0011\n\u0010\nn\nC0n7\u21920 Dnk (\u03bbx\u2206k .AN D n (\u03a6\u0302 x)) T n where \u03a6\u0302 is the interpretation of \u03a6 and n is the representation level chosen\nvariable xk . Similarly\nwe interpret \u2203xk .\u03a6(xk ) by the iterated\n\u0011\n\u0010 for the\nn\ndisjunction C0n7\u21920 Dnk (\u03bbx\u2206k .AN D n (\u03a6\u0302 x)) T n .\n\n3.2.5. Encoding the formula. Given a formula of type theory, it is possible to encode it in\nthe lambda calculus by inductively applying the above encodings of boolean operations and\nquantifiers on the formula; each variable occurrence in the formula being assigned some\ndomain of representation.\nWe now show that there exists an assignment of representation domains for each variable\nk\noccurrence such that the resulting term is safe. Let xpp . . . xk11 for p \u2265 1 be the list of\nvariables appearing in the formula, given in order of appearance of their binder in the\nk\nformula (i.e., xpp is bound by the leftmost binder). We fix the domain of representation of\neach variable as follows. The right-most variable xk11 is encoded in the domain \u22060k1 ; and if\nfor 1 \u2264 i < p the domain of representation of xki i is \u2206lkl then the domain of representation\nk\n\n\u2032\n\n\u2032\n\ni+1\nof xi+1\nis defined as \u2206lki+1 where l\u2032 is the smallest natural number such that ord \u2206lki+1 is\nstrictly greater than ord \u2206lki .\nThis way, since variables that are bound first have higher order, variables that are\nbound in nested list-iterations-corresponding to nested quantifiers in the formula-are\nguaranteed to be safely bound.\n\nExample 3.1. The formula \u2200x0 .\u2203y 0 .x0 \u2228y 0 , which is encoded by an unsafe term in Mairson's\nencoding, is represented in our encoding by the safe term\n\u0010\n\u0011\n1\n0\n\u22a2s C170\u21920 D10 (\u03bbx\u22060 .AN D 0 (D00 (\u03bby \u22060 .OR0 (OR0 (C170\u21920 x) y)) F 0 )) T 1 : B0 .\n\n\f24\n\nW. BLUM AND C.-H. L. ONG\n\n3.2.6. Set-membership. To complete the interpretation of prime formulae, we need to show\nhow to encode set membership. Unfortunately, the introduction of multiple domains of representation does not permit us to completely eliminate the unsafety of Mairson's encoding\nof set membership.\nIndeed, adapting Mairson's encoding of set membership requires the ability to perform\nconversion of domains of representation for higher-order sets (not only for Boolean values).\n\u2192 n\u2032\nThe conversion term Cn+17\ncan be generalized to higher-order sets as follows:\n0\nn\n\n\u2032\n\n\u2032\n\nn\n\nn\n\n\u2032\n\n\u2192n\nCn7k+1\n\u2261 \u03bbm\u2206k+1 u\u2206k \u2192\u03c4 \u2192\u03c4 v \u03c4 .m(\u03bbz \u2206k w\u03c4 .u(Cn7k \u2192n z)w)v : \u2206nk+1 \u2192 \u2206nk+1\n\nwhere k \u2265 0. Unfortunately this term is safe if and only if n = n\u2032 (The largest underlined\nsubterm is safe just when n \u2265 n\u2032 and the other underline subterm is safe just when n\u2032 \u2265 n).\nHence at higher-orders, all the non-trivial conversion terms are unsafe.\n\u2192n\u2032 , k \u2265 0, n 6= n\u2032 were safely representable then the encoding would\nIf the terms Cn7k+1\ngo as follows: We set \u03c4 \u2261 B0 in the types \u2206nk+1 for all n, k \u2265 0 in order to iterate a level-0\nBoolean function. Firstly, the formulae \"true \u2208 y 1 \" and \"false \u2208 y 1 \" can be encoded\nby the safe terms y 1 (\u03bbx0 .OR0 x0 )F 0 and y 1 (\u03bbx0 .OR0 (N OT 0 x0 ))F 0 respectively. For the\ngeneral case \"xk \u2208 y k+1 \" we proceed as in Mairson's proof [23]: we introduce lambda-terms\nencoding set equality, set membership and subset tests, and we further parameterize these\nencodings by a natural number n.\nn+1\n\nn+1\nmemberk+1\n\u2261 \u03bbx\u2206k\n\nn+1\n\nn\n\nn+17\u2192n\ny \u2206k+1 .(Ck+1\ny) (\u03bbz \u2206k .OR0 (eqkn (Ckn+17\u2192n x) z)) F 0\n\n\u2192 \u2206n+1\n: \u2206n+1\nk+1 \u2192 B0\nk\nn\n\nn\n\nn\n\nn\nx y)) T 0\nsubsetnk+1 \u2261 \u03bbx\u2206k+1 y \u2206k+1 .x (\u03bbx\u2206k .AN D 0 (memberk+1\n\n: \u2206nk+1 \u2192 \u2206nk+1 \u2192 B0\neq0n \u2261 \u03bbxBn .\u03bby Bn .C0n7\u21920 (ORn (AN D n x y)(AN D n (N OT n x)(N OT n y)))\n: Bn \u2192 Bn \u2192 B0\nn\n\nn\n\nn\n\nn\n\nn\neqk+1\n\u2261 \u03bbx\u2206k+1 y \u2206k+1 .(\u03bbop\u2206k+1 \u2192\u2206k+1\u2192B0 .AN D 0 (op x y)(op y x)) subsetnk+1\n\n: \u2206nk+1 \u2192 \u2206nk+1 \u2192 B0 .\nn\nand subsetnk+1 are safely bounds. Moreover, the\nThe variables in the definition of eqk+1\nn+1\nis now safely bound-which was not the case in Mairson's\noccurrence of x in memberk+1\noriginal encoding-thanks to the fact that the representation domain of z is lower than that\nof x. The formula xk \u2208 y k+1 can then be encoded as\n\u2032\n\n\u2032\n\nu\n7\u2192u\nx : \u2206nk , y : \u2206nk+1 \u22a2st memberk+1\n(Ckn7\u2192u x) (Cnk+1\ny) : B0\n\nfor some n, n\u2032 \u2265 2 and u = min(n, n\u2032 ) + 1.\nUnfortunately this encoding is not completely safe because, as mentioned before, the\nconversion term Ckn7\u2192u is unsafe for k \u2265 1, n 6= u. We conjecture that the set-membership\nfunction is intrinsically unsafe.\n3.3. PSPACE-hardness. We observe that instances of the True Quantified Boolean Formulae satisfaction problem (TQBF) are special instances of the decision problem for finite\ntype theory. These instances correspond to formulae in which set membership is not allowed\n\n\fTHE SAFE LAMBDA CALCULUS\n\n25\n\nand variables are all taken from the base domain D0 . As we have shown in the previous section, such restricted formulae can be safely encoded in the safe lambda calculus. Therefore\nsince TQBF is PSPACE-complete we have:\nTheorem 3.2. Deciding \u03b2\u03b7-equality of two safe lambda-terms is PSPACE-hard.\nExample 3.3. Using the encoding where \u03c4 is set to B0 in the types \u2206nk for all k, n \u2265 0,\nthe formula \u2200x\u2203y\u2203z(x \u2228 y \u2228 z) \u2227 (\u00acx \u2228 \u00acy \u2228 \u00acz) is represented by the safe term:\n\u22a2s D20 (\u03bbxB2 .AN D 0\n(D10 (\u03bby B1 .OR0\n(D00 (\u03bbz B0 .OR0\n(AN D 0 (OR0 (OR0 (C270\u21920 x) (C170\u21920 y))z)\n(OR0 (OR0 (N EG0 (C270\u21920 x))(N EG0 (C170\u21920 y)))(N EG0 z)))\n)F 0 )\n)F 0 )\n)T 0\n: B0 .\nRemark 3.4. The Boolean satisfaction problem (SAT) is just a particular instance of TQBF\nwhere formulae are restricted to use only existential quantifiers, thus the safe lambda calculus is also NP-hard. Asperti gave an interpretation of SAT in the simply-typed lambda\ncalculus but his encoding relies on unsafe terms [6].\nRemark 3.5. (i) Because the safety condition restricts expressivity in a non-trivial way,\none can reasonably expect the beta-eta equivalence problem to have a lower complexity\nin the safe case than in the normal case; this intuition is strengthened by our failed\nattempt to encode type theory in the safe lambda calculus. No upper bounds is known\nat present. On the other hand our PSPACE-hardness result is probably a coarse lower\nbound; it would be interesting to know whether we also have EXPTIME-hardness.\n(ii) Statman showed [36] that when restricted to some finite set of types, the beta-eta\nequivalence problem is PSPACE-hard. Such result is unlikely to hold in the safe\nlambda calculus. This is suggested by the fact that we had to use the entire type\nhierarchy to encode TQBF in the safe lambda calculus. In fact we expect the beta-eta\nequivalence problem for safe terms to have a complexity lower than PSPACE when\nrestricted to any finite set of types.\n(iii) The normalization problem (\"Given a (safe) term M , what is its \u03b2-normal form?\")\nis non-elementary. Indeed, let \u03c4\u22122 \u2261 o and for n \u2265 \u22121, \u03c4n \u2261 \u03c4n\u22121 \u2192 \u03c4n\u22121 . For\nn\nk, n \u2208 N, let k denote the kth Church Numeral \u03bbs\u03c4n\u22121 z \u03c4n\u22122 .s(* * * (s(s z) * * * ) (with k\nn\u22121 n\u22122\n0\n2\n* * * 2 of type \u03c40\napplications of s) of type \u03c4n . Then for n \u2265 1, the safe term 2\n0\nhas size O(n) and its normal form expn (1) has size O(expn (1)).\nThus in the simply-typed lambda calculus, beta-eta equivalence is essentially as\nhard as normalization. We do not know if this is the case in the safe lambda calculus.\n(iv) A related problem is that of beta-reduction: \"Given a \u03b2-normal term M1 and a term\nM2 , does M2 \u03b2-reduce to M1 ?\". It is known to be PSPACE-complete when restricted\nto order-3 terms [33], but no complexity result is known for higher orders. The safe case\ncan potentially give rise to interesting complexity characterizations at higher-orders.\n\n\f26\n\nW. BLUM AND C.-H. L. ONG\n\n4. A game-semantic account of safety\nOur aim is to characterize safety by game semantics. We shall assume that the reader\nis familiar with the basics of game semantics; for an introduction, we recommend Abramsky\nand McCusker's tutorial [3]. Recall that a justified sequence over an arena is an alternating\nsequence of O-moves and P-moves such that every move m, except the opening move, has a\npointer to some earlier occurrence of the move m0 such that m0 enables m in the arena. A\nplay is just a justified sequence that satisfies Visibility and Well-Bracketing. A basic result\nin game semantics is that \u03bb-terms are denoted by innocent strategies, which are strategies\nthat depend only on the P-view of a play. The main result (Theorem 4.11) of this section is\nthat if a \u03bb-term is safe, then its game semantics (is an innocent strategy that) is, what we\ncall, P-incrementally justified. In such a strategy, pointers emanating from the P-moves of a\nplay are uniquely reconstructible from the underlying sequence of moves and pointers from\nthe O-moves therein: Specifically a P-question always points to the last pending O-question\n(in the P-view) of a greater order.\nThe proof of Theorem 4.11 depends on a Correspondence Theorem (see the Appendix)\nthat relates the strategy denotation of a \u03bb-term M to the set of traversals over a souped-up\nabstract syntax tree of the \u03b7-long form of M . In the language of game semantics, traversals\nare just (concrete representations of) the uncovering (in the sense of Hyland and Ong [18])\nof plays in the strategy denotation.\nThe useful transference technique between plays and traversals was originally introduced\nby the second author [30] for studying the decidability of monadic second-order theories\nof infinite structures generated by higher-order grammars (in which the \u03a3-constants or\nterminal symbols are at most order 1, and uninterpreted). In the Appendix, we present an\nextension of this framework to the general case of the simply-typed lambda calculus with\nfree variables of any order. A new traversal rule is introduced to handle nodes labelled\nwith free variables. Also new nodes are added to the computation tree to account for the\nanswer moves of the game semantics, thus enabling the framework to model languages with\ninterpreted constants such as PCF (by adding traversal rules to handle constant nodes).\nIncrementally-bound computation tree. In the context of higher-order grammars, the\ncomputation tree is defined as the unravelling of the finite graph representing the long\ntransform of the grammar [30]. Similarly we define the computation tree of a \u03bb-term as an\nabstract syntax tree of its \u03b7-long normal form. We write lht1 , . . . , tn i with n \u2265 0 to denote\nthe ordered tree with a root labelled l with n child-subtrees t1 , . . . , tn . In the following we\nconsider arbitrary simply-typed terms.\nDefinition 4.1. The computation tree \u03c4 (M ) of a simply-typed term \u0393 \u22a2st M : T with\nvariable names in a countable set V is a tree with labels in\n{@} \u222a V \u222a {\u03bbx1 . . . xn | x1 , . . . , xn \u2208 V, n \u2208 N}\ndefined from its \u03b7-long form as follows. Suppose x = x1 . . . xn for n \u2265 0 then\nfor m \u2265 0, z \u2208 V: \u03c4 (\u03bbxA .zs1 . . . sm : o) = \u03bbxhzh\u03c4 (s1 ), . . . , \u03c4 (sm )ii\nfor m \u2265 1: \u03c4 (\u03bbxA .(\u03bby \u03c4 .t)s1 . . . sm : o) = \u03bbxh@h\u03c4 (\u03bby \u03c4 .t), \u03c4 (s1 ), . . . , \u03c4 (sm )ii .\nExample 4.2. Take \u22a2st \u03bbf o\u2192o .(\u03bbuo\u2192o .u)f : (o \u2192 o) \u2192 o \u2192 o.\n\n\fTHE SAFE LAMBDA CALCULUS\n\nIts \u03b7-long normal form is:\n\n27\n\nIts computation tree is:\n\u03bbf z\n\n\u22a2st \u03bbf o\u2192o z o .\n(\u03bbuo\u2192o v o .u(\u03bb.v))\n(\u03bby o .f y)\n(\u03bb.z)\n: (o \u2192 o) \u2192 o \u2192 o\n\n@\n\u03bbuv\n\n\u03bby\n\n\u03bb\n\nu\n\nf\n\nz\n\n\u03bb\n\n\u03bb\n\nv\n\ny\n\nExample 4.3. Take \u22a2st \u03bbuo v ((o\u2192o)\u2192o) .(\u03bbxo .v(\u03bbz o .x))u : o \u2192 ((o \u2192 o) \u2192 o) \u2192 o.\nIts \u03b7-long normal form is:\n\nIts computation tree is:\n\u03bbuv\n@\n\n\u22a2st\n\n\u03bbuo v ((o\u2192o)\u2192o) .\n\n(\u03bbxo .v(\u03bbz o .x))u\n: o \u2192 ((o \u2192 o) \u2192 o) \u2192 o\n\n\u03bbx\n\n\u03bb\n\nv\n\nu\n\n\u03bbz\nx\nEven-level nodes are \u03bb-nodes (the root is on level 0). A single \u03bb-node can represent several consecutive variable abstractions or it can just be a dummy lambda if the corresponding\nsubterm is of ground type. Odd-level nodes are variable or application nodes.\nThe order of a node n, written ord n, is defined as follows: @-nodes have order 0. The\norder of a variable-node is the type-order of the variable labelling it. The order of the root\nnode is the type-order of (A1 , . . . , Ap , T ) where A1 , . . . , Ap are the types of the variables in\nthe context \u0393. Finally, the order of a lambda node different from the root is the type-order\nof the term represented by the sub-tree rooted at that node.\nWe say that a variable node n labelled x is bound by a node m, and m is called the\nbinder of n, if m is the closest node in the path from n to the root such that m is labelled\n\u03bb\u03be with x \u2208 \u03be.\nWe introduce a class of computation trees in which the binder node is uniquely determined by the nodes' orders:\nDefinition 4.4. A computation tree is incrementally-bound if for all variable node x,\neither x is bound by the first \u03bb-node in the path to the root with order > ord x, or x is a\nfree variable and all the \u03bb-nodes in the path to the root except the root have order \u2264 ord x.\nProposition 4.5 (Safety and incremental-binding).\n(i) If M is safe then \u03c4 (M ) is incrementally-bound.\n(ii) Conversely, if M is a closed simply-typed term and \u03c4 (M ) is incrementally-bound then\nM is safe.\nProof. (i) Suppose that M is safe. By Lemma 1.27 the \u03b7-long form of M is safe therefore\n\u03c4 (M ) is the tree representation of a safe term.\n\n\f28\n\nW. BLUM AND C.-H. L. ONG\n\nIn the safe lambda calculus, the variables in the context with the lowest order must be\nall abstracted at once when using the abstraction rule. Since the computation tree merges\nconsecutive abstractions into a single node, any variable x occurring free in the subtree\nrooted at a node \u03bb\u03be different from the root must have order greater or equal to ord \u03bb\u03be.\nConversely, if a lambda node \u03bb\u03be binds a variable node x then ord \u03bb\u03be = 1 + maxz\u2208\u03be ord z >\nord x.\nLet x be a bound variable node. Its binder occurs in the path from x to the root,\ntherefore, according to the previous observation, x must be bound by the first \u03bb-node\noccurring in this path with order > ord x. Let x be a free variable node then x is not\nbound by any of the \u03bb-nodes occurring in the path to the root. Once again, by the previous\nobservation, all these \u03bb-nodes except the root have order smaller than ord x. Hence \u03c4 is\nincrementally-bound.\n(ii) Let M be a closed term such that \u03c4 (M ) is incrementally-bound. W.l.o.g. we can\nassume that M is in \u03b7-long form. We prove that M is safe by induction on its structure.\nThe base case M \u2261 \u03bb\u03be.x for some variable x is trivial. Step case: If M \u2261 \u03bb\u03be.N1 . . . Np . Let\ni range over 1..p. We have Ni \u2261 \u03bb\u03b7i .Ni\u2032 for some non-abstraction term Ni\u2032 . By the induction\nhypothesis, \u03bb\u03be.Ni = \u03bb\u03be\u03b7i .Ni\u2032 is a safe closed term, and consequently Ni\u2032 is necessarily safe.\nLet z be a free variable of Ni\u2032 not bound by \u03bb\u03b7i in Ni . Since \u03c4 (M ) is incrementally-bound\nwe have ord z \u2265 ord \u03bb\u03b71 = ord Ni , thus we can abstract the variables \u03b71 using (abs) which\nshows that Ni is safe. Finally we conclude \u22a2s M = \u03bb\u03be.N1 . . . Np : T using the rules (app)\nand (abs).\nThe assumption that M is closed is necessary. For instance for x, y : o, the computation\ntrees \u03c4 (\u03bbxy.x) and \u03c4 (\u03bby.x) are both incrementally-bound but \u03bbxy.x is safe and \u03bby.x is not.\nP-incrementally justified strategy. We now consider the game-semantic model of the\nsimply-typed lambda calculus. The strategy denotation of a term-in-context \u0393 \u22a2st M : T is\nwritten [[\u0393 \u22a2st M : T ]]. We define the order of a move m, written ord m, to be the length of\nthe path from m to its furthest leaf in the arena minus 1. (There are several ways to define\nthe order of a move; the definition chosen here is sound in the current setting where each\nquestion move in the arena enables at least one answer move.)\nDefinition 4.6. A strategy \u03c3 is said to be P-incrementally justified if for every play\ns q \u2208 \u03c3 where q is a P-question, q points to the last unanswered O-question in psq with\norder strictly greater than ord q.\nNote that although the pointer is determined by the P-view, the choice of the move\nitself can be based on the whole history of the play. Thus P-incremental justification does\nnot imply innocence.\nThe definition suggests an algorithm that, given a play of a P-incrementally justified\ndenotation, uniquely recovers the pointers from the underlying sequence of moves and from\nthe pointers associated to the O-moves therein. Hence:\nLemma 4.7. In P-incrementally justified strategies, pointers emanating from P-moves are\nsuperfluous.\nExample 4.8. Copycat strategies, such as the identity strategy idA on game A or the\nevaluation map evA,B of type (A \u21d2 B) \u00d7 A \u2192 B, are all P-incrementally justified.6\n6In such strategies, a P-move m is justified as follows: Either m points to the preceding move in the\n\nP-view or the preceding move is of smaller order and m is justified by the second last O-move in the P-view.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n29\n\nThe Correspondence Theorem 6.10 gives us the following equivalence:\nProposition 4.9. Let \u0393 \u22a2st M : T be a \u03b2-normal term. The computation tree \u03c4 (M ) is\nincrementally-bound if and only if [[\u0393 \u22a2st M : T ]] is P-incrementally justified.\nExample 4.10. Consider the \u03b2-normal term \u0393 \u22a2st f (\u03bby.x) : o where y : o and \u0393 =\nf : ((o, o), o), x : o. The figure on the right represents its computation tree with the\nnode orders given as superscripts. The node x is not incrementally-bound therefore\n\u03c4 (f (\u03bby.x)) is not incrementally-bound and by Proposition 4.9, [[\u0393 \u22a2st f (\u03bby.x) : o]]\nis not incrementally-justified (although [[\u0393 \u22a2st f : ((o, o), o)]] and [[\u0393 \u22a2st \u03bby.x : (o, o)]]\nare).\n\n\u03bb3\nf2\n\u03bby 1\nx0\n\nPropositions 4.5 and 4.9 allow us to show the following:\nTheorem 4.11 (Safety and P-incremental justification).\n(i) If \u0393 \u22a2s M : T then [[\u0393 \u22a2s M : T ]] is P-incrementally justified.\n(ii) If \u22a2st M : T is a closed simply-typed term and [[\u22a2st M : T ]] is P-incrementally justified\nthen the \u03b2-normal form of M is safe.\nProof. (i) Let M be a safe simply-typed term. By Lemma 1.18, its \u03b2-normal form M \u2032 is\nalso safe. By Proposition 4.5(i), \u03c4 (M \u2032 ) is incrementally-bound and by Proposition 4.9, [[M \u2032 ]]\nis incrementally-justified. Finally the soundness of the game model gives [[M ]] = [[M \u2032 ]]. (ii)\nis a consequence of Lemma 1.18, Proposition 4.9 and 4.5(ii) and soundness of the game\nmodel.\nPutting Theorem 4.11(i) and Lemma 4.7 together gives:\nProposition 4.12. In the game semantics of safe \u03bb-terms, pointers emanating from Pmoves are unnecessary: they are uniquely recoverable from the underlying sequences of moves\nand from O-moves' pointers.\nExample 4.13. If justification pointers are omitted then the denotations of the two Kierstead terms from Example 1.5 are not distinguishable. In the safe lambda calculus this\nambiguity disappears since M1 is safe whereas M2 is not.\nIn fact, as the last example highlights, pointers are superfluous at order 3 for safe\nterms whether from P-moves or O-moves. This is because for question moves in the\nfirst two levels of an arena (initial moves being at level 0), the associated pointers are\nuniquely recoverable thanks to the visibility condition. At the third level, the question\nmoves are all P-moves therefore their associated pointers are uniquely recoverable by Pincremental justification. This is not true anymore at order 4: Take the safe term-in-context\n\u03c8 : (((o4 , o3 ), o2 ), o1 ) \u22a2s \u03c8(\u03bb\u03c6(o,o) .\u03c6a) : o0 for some constant a : o. Its strategy denotation\ncontains plays whose underlying sequence of moves is q0 q1 q2 q3 q2 q3 q4 . Since q4 is an Omove, it is not constrained by P-incremental justification and thus it can point to any of\nthe two occurrences of q3 .7\n7More generally, a P-incrementally justified strategy can contain plays that are not \"O-incrementally\n\njustified\" since it must take into account any possible strategy incarnating its context, including those that\nare not P-incrementally justified. For instance in the given example, there is one version of the play that is\nnot O-incrementally justified (the one where q4 points to the first occurrence of q3 ). This play is involved in\nthe strategy composition [[\u22a2st M2 : (((o, o), o), o)]]; [[\u03c8 : (((o, o), o), o) \u22a2st \u03c8(\u03bb\u03c6.\u03c6a) : o]] where M2 denotes the\nunsafe Kierstead term.\n\n\f30\n\nW. BLUM AND C.-H. L. ONG\n\nTowards a fully abstract game model. The standard game models which have been\nshown to be fully abstract for PCF [2, 18] are of course also fully abstract for the restricted\nlanguage safe PCF. One may ask, however, whether there exists a fully abstract model with\nrespect to safe context only. Such model may be obtained by considering P-incrementally\njustified strategies-which have been shown to compose [7]. Its is reasonable to think that\nO-moves also needs to be constrained by the symmetrical O-incremental justification, which\ncorresponds to the requirement that contexts are safe. This line of work is still in progress.\nSafe PCF and safe Idealised Algol. PCF is the simply-typed lambda calculus augmented with basic arithmetic operators, if-then-else branching and a family of recursion\ncombinator YA : ((A, A), A) for every type A. We define safe PCF to be PCF where the\napplication and abstraction rules are constrained in the same way as the safe lambda calculus. This language inherits the good properties of the safe lambda calculus: No variable\ncapture occurs when performing substitution and safety is preserved by the reduction rules\nof the small-step semantics of PCF.\nCorrespondence. The computation tree of a PCF term is defined as the least upper-bound of\nthe chain of computation trees of its syntactic approximants [3]. It is obtained by infinitely\nexpanding the Y combinator, for instance \u03c4 (Y (\u03bbf x.f x)) is the tree representation of the\n\u03b7-long form of the infinite term (\u03bbf x.f x)((\u03bbf x.f x)((\u03bbf x.f x)(. . .\nIt is straightforward to define the traversal rules modeling the arithmetic constants of\nPCF. Just as in the safe lambda calculus we had to remove @-nodes in order to reveal the\ngame-semantic correspondence, in safe PCF it is necessary to filter out the constant nodes\nfrom the traversals. The Correspondence Theorem for PCF says that the revealed game\nsemantics is isomorphic to the set of traversals disposed of these superfluous nodes. This\ncan easily be shown for term approximants. It is then lifted to full PCF using the continuity\nof the function T rv( )\u21be\u229b from the set of computation trees (ordered by the approximation\nordering) to the set of sets of justified sequences of nodes (ordered by subset inclusion).\nFinally computation trees of safe PCF terms are incrementally-bound thus we have\nTheorem 4.14. Safe PCF terms have P-incrementally justified denotations.\nSimilarly, we can define safe IA to be safe PCF augmented with the imperative features\nof Idealized Algol (IA for short) [32]. Adapting the game-semantic correspondence and\nsafety characterization to IA seems feasible although the presence of the base type var,\nwhose game arena comN \u00d7 exp has infinitely many initial moves, causes a mismatch between\nthe simple tree representation of the term and its game arena. It may be possible to\novercome this problem by replacing the notion of computation tree by a \"computation\ndirected acyclic graph\".\nThe possibility of representing plays without some or all of their pointers under the\nsafety assumption suggests potential applications in algorithmic game semantics. Ghica\nand McCusker [15] were the first to observe that pointers are unnecessary for representing\nplays in the game semantics of the second-order finitary fragment of Idealized Algol (IA2\nfor short). Consequently observational equivalence for this fragment can be reduced to the\nproblem of equivalence of regular expressions. At order 3, although pointers are necessary,\ndeciding observational equivalence of IA3 is EXPTIME-complete [29, 28]. Restricting the\nproblem to the safe fragment of IA3 may lead to a lower complexity.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n31\n\n5. Further work and open problems\nThe safe lambda calculus is still not well understood. Many basic questions remain.\nWhat is a (categorical) model of the safe lambda calculus? Does the calculus have interesting models? What kind of reasoning principles does the safe lambda calculus support,\nvia the Curry-Howard Isomorphism? Does the safe lambda calculus characterize a complexity class, in the same way that the simply-typed lambda calculus characterizes the\npolytime-computable numeric functions [21]? Is the addition of unsafe contexts to safe ones\nconservative with respect to observational (or contextual) equivalence?\nWith a view to algorithmic game semantics and its applications, it would be interesting to identify sublanguages of Idealised Algol whose game semantics enjoy the property\nthat pointers in a play are uniquely recoverable from the underlying sequence of moves.\nWe name this class PUR. IA2 is the paradigmatic example of a PUR-language. Another\nexample is Serially Re-entrant Idealized Algol [1], a version of IA where multiple uses of\narguments are allowed only if they do not \"overlap in time\". We believe that a PUR language can be obtained by imposing the safety condition on IA3 . Murawski [27] has shown\nthat observational equivalence for IA4 is undecidable; is observational equivalence for safe\nIA4 decidable?\nAcknowledgment. We thank Ugo dal Lago for the insightful discussions we had during his\nvisit at the Oxford University Computing Laboratory in March 2008, and the anonymous\nreferees for helpful comments.\nReferences\n[1] S. Abramsky. Semantics via game theory. In Marktoberdorf International Summer School, 2001. Lecture\nslides.\n[2] S. Abramsky, P. Malacaria, and R. Jagadeesan. Full abstraction for PCF. In Theoretical Aspects of\nComputer Software, pages 1\u201315, 1994.\n[3] S. Abramsky and G. McCusker. Game semantics. In H. Schwichtenberg and U. Berger, editors, Logic\nand Computation: Proceedings of the 1997 Marktoberdorf Summer School, pages 1\u201356. Springer-Verlag,\n1998. Lecture notes.\n[4] K. Aehlig, J. G. de Miranda, and C.-H. L. Ong. Safety is not a restriction at level 2 for string languages.\nTechnical report, University of Oxford, 2004.\n[5] A. V. Aho. Indexed grammars \u2013 an extension of context-free grammars. J. ACM, 15(4):647\u2013671, 1968.\n[6] A. Asperti. P = NP, up to sharing.\n[7] W. Blum. The Safe Lambda Calculus. PhD thesis, University of Oxford, forthcoming.\n[8] W. Blum and C.-H. L. Ong. The safe lambda calculus. In S. R. D. Rocca, editor, TLCA, volume 4583\nof Lecture Notes in Computer Science, pages 39\u201353. Springer, 2007.\n[9] D. Caucal. On infinite terms having a decidable monadic theory. Lecture Notes in Computer Science,\n2420:165\u2013176, 2002.\n[10] W. Damm. The IO- and OI-hierarchy. TCS, 20:95\u2013207, 1982.\n[11] W. Damm and A. Goerdt. An automata-theoretical characterization of the OI-hierarchy. Information\nand Control, 71(1-2):1\u201332, 1986.\n[12] J. G. de Miranda. Structures generated by higher-order grammars and the safety constraint. D.Phil\nthesis, University of Oxford, 2006.\n[13] A. Dimovski, D. R. Ghica, and R. Lazic. Data-abstraction refinement: A game semantic approach. In\nC. Hankin and I. Siveroni, editors, SAS, volume 3672 of Lecture Notes in Computer Science, pages\n102\u2013117. Springer, 2005.\n[14] S. Fortune, D. Leivant, and M. O'Donnell. The expressiveness of simple and second-order type structures. J. ACM, 30(1):151\u2013185, 1983.\n\n\f32\n\nW. BLUM AND C.-H. L. ONG\n\n[15] D. R. Ghica and G. McCusker. Reasoning about idealized algol using regular languages. In Proceedings\nof 27th International Colloquium on Automata, Languages and Programming ICALP 2000, volume 1853\nof LNCS, pages 103\u2013116. Springer-Verlag, 2000.\n[16] W. Greenland. Game Semantics for Region Analysis. PhD thesis, University of Oxford, 2004.\n[17] M. Hague, A. S. Murawski, C.-H. L. Ong, and O. Serre. Collapsible pushdown automata and recursive\nschemes. LICS, pages 452\u2013461, 2008.\n[18] J. M. E. Hyland and C.-H. L. Ong. On full abstraction for PCF: I, II, and III. Information and Computation, 163(2):285\u2013408, December 2000.\n[19] T. Knapik, D. Niwi\u0144ski, and P. Urzyczyn. Higher-order pushdown trees are easy. In FOSSACS'02, pages\n205\u2013222. Springer, 2002. LNCS Vol. 2303.\n[20] D. Leivant. Functions over free algebras definable in the simply typed lambda calculus. Theor. Comput.\nSci., 121(1&2):309\u2013322, 1993.\n[21] D. Leivant and J.-Y. Marion. Lambda calculus characterizations of poly-time. In M. Bezem and J. F.\nGroote, editors, TLCA, volume 664 of Lecture Notes in Computer Science, pages 274\u2013288. Springer,\n1993.\n[22] R. Loader. Notes on simply typed lambda calculus, February 1998.\n[23] H. G. Mairson. A Simple Proof of a Theorem of Statman. TCS, 103(2):387\u2013394, 1992.\n[24] A. N. Maslov. The hierarchy of indexed languages of an arbitrary level. Soviet Math. Dokl., 15:1170\u2013\n1174, 1974.\n[25] A. N. Maslov. Multilevel stack automata. Problems of Information Transmission, 12:38\u201343, 1976.\n[26] A. R. Meyer. The inherent computational complexity of theories of ordered sets. In Proc. Int'l. Cong.\nof Mathematicians, volume 2, pages 477\u2013482, August 1974.\n[27] A. S. Murawski. On program equivalence in languages with ground-type references. In Logic in Computer\nScience, 2003. Proceedings. 18th Annual IEEE Symposium on, pages 108\u2013117, 22-25 June 2003.\n[28] A. S. Murawski and I. Walukiewicz. Third-order idealized algol with iteration is decidable. In V. Sassone,\neditor, FoSSaCS, volume 3441 of Lecture Notes in Computer Science, pages 202\u2013218. Springer, 2005.\n[29] C.-H. L. Ong. An approach to deciding observational equivalence of algol-like languages. Ann. Pure\nAppl. Logic, 130(1-3):125\u2013171, 2004.\n[30] C.-H. L. Ong. On model-checking trees generated by higher-order recursion schemes. In Proceedings of\nIEEE Symposium on Logic in Computer Science., pages 81\u201390. Computer Society Press, 2006. Extended\nabstract.\n[31] C.-H. L. Ong. On model-checking trees generated by higher-order recursion schemes (technical report).\nPreprint, 42 pp, 2006.\n[32] J. C. Reynolds. The essence of algol. In J. W. de Bakker and J. C. van Vliet, editors, Algorithmic\nLanguages, pages 345\u2013372. IFIP, North-Holland, Amsterdam, 1981.\n[33] A. Schubert. The complexity of beta-reduction in low orders. Proceedings TLCA 2001, pages 400\u2013414,\n2001.\n[34] H. Schwichtenberg. Definierbare funktionen im lambda-kalkul mit typen. Archiv Logik Grundlagenforsch, 17:113\u2013114, 1976.\n[35] R. Statman. Intuitionistic propositional logic is polynomial-space complete. Theoretical Computer Science, 9(1):67\u201372, July 1979.\n[36] R. Statman. The typed lambda-calculus is not elementary recursive. Theoretical Computer Science,\n9(1):73\u201381, July 1979.\n[37] M. Zaionc. Word operation definable in the typed lambda-calculus. Theor. Comput. Sci., 52:1\u201314, 1987.\n[38] M. Zaionc. On the lambda-definable tree operations. In C. Bergman, R. D. Maddux, and D. Pigozzi,\neditors, Algebraic Logic and Universal Algebra in Computer Science, volume 425 of Lecture Notes in\nComputer Science, pages 279\u2013292. Springer, 1988.\n[39] M. Zaionc. Lambda-definability on free algebras. Ann. Pure Appl. Logic, 51(3):279\u2013300, 1991.\n[40] M. Zaionc. Lambda representation of operations between different term algebras. Lecture Notes in\nComputer Science, pages 91\u2013105, 1995.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n33\n\n6. Appendix \u2013 Computation tree, traversals and correspondence\nThe second author introduced the notion of computation tree and traversals over a\ncomputation tree for the purpose of studying trees generated by higher-order recursion\nscheme [30]. Here we extend these concepts to the simply-typed lambda calculus. Our\nsetting allows the presence of free variables of any order and the term studied is not required\nto be of ground type. (This contrasts with [30]'s setting where the term is of ground type\nand contains only uninterpreted constant.) Note that we automatically account for the\npresence of uninterpreted constants since they can just be regarded as free variables. We\nwill then state the Correspondence Theorem (Theorem 6.10) that was used in Sec. 4.\nIn the following we fix a simply-typed term-in-context \u0393 \u22a2st M : T (not necessarily\nsafe) and we consider its computation tree \u03c4 (M ) as defined in Def. 4.1.\n6.1. Notations. We first fix some notations. We write \u229b to denote the root of the computation tree \u03c4 (M ). The set of nodes of this computation tree is denoted by IN . The sets\nIN@ , IN\u03bb and INvar are respectively the subset of @-nodes, \u03bb-nodes and variable nodes.\nThe type of a variable-labelled node is the type of the variable that labels it; the type of\nthe root is (A1 , . . . , Ap , T ) where x1 : A1 , . . . , xp : Ap are the variables in the context \u0393; and\nthe type of a node n \u2208 (IN\u03bb \u222a IN@ ) \\ {\u229b} is the type of the subterm of \u2308M \u2309 corresponding\nto the subtree of \u03c4 (M ) rooted at n.\n6.2. Pointers and justified sequences of nodes. We define the enabling relation on\nthe set of nodes of the computation tree as follows: m enables n, written m \u22a2 n, if and only\nif n is bound by m (and we sometimes write m \u22a2i n to indicate that n is the ith variable\nbound by m); or m is the root \u229b and n is a free variable; or n is a \u03bb-node and m is its\nparent node.\nWe say that a node n0 of the computation tree is hereditarily enabled by np \u2208 IN if\nthere are nodes n1 , . . . , np\u22121 \u2208 IN such that ni+1 enables ni for all i \u2208 0..p \u2212 1.\nFor any set of nodes S, H \u2286 N we write S H\u22a2 for {n \u2208 S |\u2203m \u2208 H s.t. m \u22a2\u2217 n} \u2013 the\nsubset of S consisting of nodes hereditarily enabled by some node in H. We will abbreviate\nS {m}\u22a2 into S m\u22a2 .\n\u229b\u22a2 (i.e., variables that are herediWe call input-variables nodes the elements of INvar\n\u229b\u22a2 = IN \\ (IN IN@ \u22a2 \u222a IN IN\u03a3 \u22a2 ).\ntarily enabled by the root of \u03c4 (M )). Thus we have INvar\nvar\nvar\nA justified sequence of nodes is a sequence of nodes with pointers such that each\noccurrence of a variable or \u03bb-node n different from the root has a pointer to some preceding\noccurrence m satisfying m \u22a2 n. In particular, occurrences\nof @-nodes do not have pointer.\ni\nWe represent the pointer in the sequence as follows m . . . n. where the label indicates that\neither n is labelled with the ith variable abstracted by the \u03bb-node m or that n is the ith\nchild of m. Children nodes are numbered from 1 onward except for @-nodes where it starts\nfrom 0. Abstracted variables are numbered from 1 onward. The ith child of n is denoted by\nn.i.\nWe say that a node n0 of a justified sequence is hereditarily justified by np if there\nare occurrences n1 , . . . , np\u22121 in the sequence such that ni points to ni+1 for all i \u2208 0..p \u2212 1.\nFor any occurrence n in a justified sequence s, we write s \u21be n to denote the subsequence of\ns consisting of occurrences that are hereditarily justified by n.\n\n\f34\n\nW. BLUM AND C.-H. L. ONG\n\nThe notion of P-view ptq of a justified sequence of nodes t is defined the same way as\nthe P-view of a justified sequences of moves in Game Semantics:8\np\u01ebq = \u01eb\nfor n \u2208\n/ IN\u03bb , ps * nq = psq * n\n\nps * m * . . . * \u03bb\u03beq = psq * m * \u03bb\u03be\nps * \u229bq = \u229b\n\nThe O-view of s, written xsy, is defined dually. We will borrow the game-semantic\nterminology: A justified sequences of nodes satisfies alternation if for any two consecutive\nnodes one is a \u03bb-node and the other is not, and P-visibility if every variable node points\nto a node occurring in the P-view a that point.\n6.3. Computation tree with value-leaves. We now add another ingredient to the computation tree that was not originally used in the context of higher-order grammars [30]. We\nwrite D to denote the set of values of the base type o. We add value-leaves to \u03c4 (M ) as\nfollows: For each value v \u2208 D and for each node of the computation tree we attach a new\nchild leaf vn to n. We write N for the set of nodes (i.e., inner nodes and leaf nodes) of the\nresulting tree. The set of leaf nodes is denoted L, we thus have N = IN \u222a L. For $ ranging\nin {@, \u03bb, var}, we write N$ to denote the set consisting of nodes from IN$ together with\nleaf nodes with parent node in IN$ ; formally N$ = IN$ \u222a {vn | n \u2208 IN$ , v \u2208 D}.\nThe basic notions can be adapted to this new version of computation tree: A value-leaf\nhas order 0. The enabling relation \u22a2 is extended so that every leaf is enabledv by its parent\nnode. A link going from a value-leaf vn to a node n is labelled by v (e.g., n . . . vn ). For the\ndefinition of P-view and visibility, value-leaves are treated as \u03bb-nodes if they are at an odd\nlevel in the computation tree, and as variable nodes if they are at an even level.\nWe say that an occurrence of an inner node n \u2208 IN is answered by an occurrence\nvn if vn in the sequence that points to n, otherwise we say that n is unanswered. The\nlast unanswered node is called the pending node. A justified sequence of nodes is wellbracketed if each value-leaf occurring in it is justified by the pending node at that point.\nIf t is a traversal then we write ?(t) to denote the subsequence of t consisting only of\nunanswered nodes.\n6.4. Traversals of the computation tree. A traversal is a justified sequence of nodes of\nthe computation tree where each node indicates a step that is taken during the evaluation\nof the term.\nDefinition 6.1 (Traversals for simply-typed \u03bb-terms). The set T rv(M ) of traversals over\n\u03c4 (M ) is defined by induction over the rules of Table 1. A traversal that cannot be extended\nby any rule is said to be maximal.\n8 The equalities in the definition determine pointers implicitly. For instance in the second clause, if in\nthe left-hand side, n points to some node in s that is also present in psq then in the right-hand side, n points\nto that occurrence of the node in psq.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n35\n\nInitialization rules\n(Empty) \u01eb \u2208 T rv(M ).\n(Root) The sequence constituted of a single occurrence of \u03c4 (M )'s root is a traversal.\nStructural rules\n(Lam) If t * \u03bb\u03be is a traversal then so is t * \u03bb\u03be * n where n denotes \u03bb\u03be's child and:\n\u2013 If n \u2208 IN@ \u222a IN\u03a3 then it has no justifier;\n\u2013 if n \u2208 INvar \\ INfv then it points to the only occurrencea of its binder in pt * \u03bb\u03beq;\n\u2013 if n \u2208 INfv then it points to the only occurrence of the root \u229b in pt * \u03bb\u03beq.\n0\n\n(App) If t * @ is a traversal then so is t * @ * n.\nInput-variable rules\n\u229b\u22a2 \u222a L\u229b\u22a2 and x is an occurrence of a variable\n(InputVar) If t is a traversal where t\u03c9 \u2208 INvar\n\u03bb\nnode in xty then so is t * n for every child \u03bb-node n of x, n pointing to x.\nv\n\n\u229b\u22a2 then so is t * x * t * v\n(InputValue) If t1 *x*t2 is a traversal with pending node x \u2208 INvar\n1\n2\nx\nfor all v \u2208 D.\nCopy-cat rules\ni\ni\n\ni\n\n@\u22a2 then so is t * n * \u03bbx . . . x * \u03bb\u03b7 .\n(Var) If t * n * \u03bbx . . . xi is a traversal where xi \u2208 INvar\ni\ni\nv\nv\n\nv\n\n(Value) If t * m * n . . . v n is a traversal where n \u2208 IN then so is t * m * n . . . v n * v m .\nTable 1: Traversal rules for the simply-typed \u03bb-calculus.\naProp. 6.3 shows that P-views are paths in the tree thus n's enabler occurs exactly once in the P-view.\n\nA traversal always starts by visiting the root. Then it mainly\nfollows the structure of the tree. The (Var) rule permits us to\njump across the computation tree. The idea is that after visiting a variable node x, a jump is allowed to the node corresponding to the subterm that would be substituted for x if all\nthe \u03b2-redexes occurring in the term were reduced. The sequence\n1\n1\n\ni\ni\n\n\u03bb\u03b7. 1\n..\n\n\u03bby\ny\n\u03bb\u03b7\n.. i\n.\n\n0\n\n\u03bb\n@\n\n1\n\n\u03bbx\nxi\n\n\u03bb\u03b7. n\n..\n\n\u03bb * @ * \u03bby . . . y * \u03bbx . . . xi * \u03bb\u03b7i . . . is an example of traversal of the computation tree shown\non the right.\nExample 6.2. The following justified sequence is a traversal of the computation tree of\nexample 4.2:\n\nt = \u03bbf z * @ * \u03bbuv * u * \u03bby * f * \u03bb * y * \u03bb * v * \u03bb * z .\nProposition 6.3. (Counterpart of the Path-traversal correspondence for higher-order grammars [31, proposition 6].) Let t be a traversal. Then:\n(i) t is a well-defined and well-bracketed justified sequence;\n(ii) t is a well-defined justified sequence satisfying alternation, P-visibility and O-visibility;\n(iii) If t's last node is not a value-leaf, then ptq is the path in the computation tree going\nfrom the root to t's last node.\n\n\f36\n\nW. BLUM AND C.-H. L. ONG\n\nThe reduction of a traversal t is the subsequence of t obtained by keeping only occurrences of nodes that are hereditarily enabled by the root \u229b. This has the effect of\neliminating the \"internal nodes\" of the computation. If t is a non-empty traversal then\nthe root \u229b occurs exactly once in t thus the reduction of t is equal to t \u21be r where r is the\nfirst occurrence in t (the only occurrence of the root). We write T rv(M )\u21be\u229b for the set or\nreductions of traversals of M .\nExample 6.4. The reduction of the traversal given in example 6.2 is:\nt \u21be \u03bbf z = \u03bbf z * f * \u03bb * z .\nApplication nodes are used to connect the operator and the operand of an application\nin the computation tree but since they do not play any role in the computation of the term,\nwe can remove them from the traversals. We write t \u2212 @ for the sequence of nodes-withpointers obtained by removing from t all @-nodes and value-leaves of @-nodes, and where\nevery pointer to an @-node is replaced by a pointer to its immediate predecessor in t. We\nwrite T rv(M )\u2212@ for the set {t \u2212 @ | t \u2208 T rv(M )}.\nExample 6.5. Let t be the traversal given in example 6.2, we have:\n\nt \u2212 @ = \u03bbf z * \u03bbuv * u * \u03bby f * \u03bb * y * \u03bb * v * \u03bb * z .\nRemark 6.6. Clearly if M is \u03b2-normal then \u03c4 (M ) does not contain any @-node therefore all\nnodes are hereditarily enabled by the root and we have T rv(M )\u2212@ = T rv(M ) = T rv(M )\u21be\u229b.\nLemma 6.7. Suppose that M is a \u03b2-normal simply-typed term. Let t be a non-empty\ntraversal of M and r denote the only occurrence of \u03c4 (M )'s root in t. If t's last occurrence\nis not a leaf then\nptq \u21be r = p?(t) \u21be rq .\nIn the lambda calculus without interpreted constants this lemma follows immediately\nfrom the fact that T rv(M ) = T rv(M )\u21be\u229b. It remains valid in the presence of interpreted\nconstants provided that the traversal rules implementing the constants are well-behaved 9.\n6.5. Computation trees and arenas. We consider the well-bracketed game model of the\nsimply-typed lambda calculus. We choose to represent strategies using \"prefix-closed set of\nplays\".10 We fix a term \u0393 \u22a2st M : T and write [[\u0393 \u22a2st M : T ]] for its strategy denotation.\nThe answer moves of a question q are written vq where v ranges in D.\nProposition 6.8. There exists a function \u03c6M , constructible from M , that maps nodes from\nN \\ (N@ \u222a N\u03a3 ) to moves of the arenas underlying the strategy denotations of M 's subterms\nsuch that:\n9A traversal rule is well-behaved if it can be stated under the form \"t = t * n * t \u2208 T rv(M ) \u2227 ?(t) =\n1\n2\n\n?(t1 ) * n \u2227 n \u2208 IN\u03a3 \u222a INvar \u2227 P (t) \u2227 m \u2208 S(t) =\u21d2 t1 * n * t2 * m \u2208 T rv(M )\" for some expression P expressing\na condition on t and function S mapping traversals of the form of t to a subset of the children of n.\n10\nIn the literature, a strategy is commonly defined as a set of plays closed by taking a prefix of even\nlength. However for the purpose of showing the correspondence with traversals, the \"prefix-closed\"-based\ndefinition is more adequate.\n\n\fTHE SAFE LAMBDA CALCULUS\n\n37\n\n\u2022 \u03c6 maps \u03bb-nodes to O-questions, variable nodes to P-questions, value-leaves of \u03bb-nodes to\nP-answers and value-leaves of variable nodes to O-answers.\n\u2022 \u03c6 maps nodes of a given order to moves of the same order.\nIf t = t0 t1 . . . is a justified sequence of nodes in N\u03bb \u222a Nvar then \u03c6(t) is defined to be the\nsequence of moves \u03c6(t0 ) \u03c6(t1 ) . . . equipped with the pointers of t.\nExample 6.9. Take \u03bbx.(\u03bbg.gx)(\u03bby.y) with x, y : o and g : (o, o). The diagram below\nrepresents the computation tree (middle), the arenas [[(o, o), o]] (left), [[o, o]] (right), [[o \u2192 o]]\n\u03bby,q\n\u03bbg,q\n(rightmost) and \u03c6 = \u03c8 \u222a \u03c8\u03bbg.gx\u03bbg \u222a \u03c8\u03bby.y\u03bby (dashed-lines).\n\u03bbx\nq\u03bbg\nqg\n\n\u03bbg,q\n\u03c8\u03bbg.gx\u03bbg\n\nqg1\n\n\u03c8\n\n@\n\u03bbg\n\n\u03bby\n\ng\n\ny\n\n\u03bby,q\n\u03c8\u03bby.y\u03bby\n\nq\u03bbx\nq\u03bby\n\nqx\n\nqy\n\n\u03bb\nx\n\n6.6. The Correspondence Theorem. In game semantics, strategy composition is performed using a CSP-like \"composition + hiding\". If some of the internal moves are not\nhidden then we obtain alternative denotations called revealed semantics [16] or interaction semantics [13]. We obtain different notions of revealed semantics depending on the\nchoice of internal moves that we hide. For instance the fully revealed denotation of\n\u0393 \u22a2st M : T , written hh\u0393 \u22a2st M : T ii, is obtained by uncovering all the internal moves from\n[[\u0393 \u22a2st M : T ]] that are generated during composition.11 The inverse operation consists in\nfiltering out the internal moves.\nThe syntactically-revealed denotation, written hh\u0393 \u22a2st M : T iis , differs from the\nfully-revealed one in that only certain internal moves are preserved during composition:\nWhen computing the denotation of an application joint by an @-node in the computation\ntree, all the internal moves are preserved. When computing the denotation of hhyi N1 . . . Np ii\nfor some variable yi , however, we only preserve the internal moves of N1 , . . . , Np while omitting the internal moves produced by the copy-cat projection strategy denoting yi .\nThe Correspondence Theorem states that in the simply-typed lambda calculus, the set\nT rv(M ) of traversals of the computation tree is isomorphic to the syntactically-revealed\ndenotation, and the set of traversal reductions is isomorphic to the standard strategy denotation:\nTheorem 6.10 (The Correspondence Theorem). We have the following two isomorphisms:\n\u223c\n=\n\n(i) \u03c6M\n\n: T rv(M )\u2212@ \u2212\u2192 hh\u0393 \u22a2st M : T iis\n\n(ii) \u03c6M\n\n: T rv(M )\u21be\u229b \u2212\u2192 [[\u0393 \u22a2st M : T ]] .\n\n\u223c\n=\n\n11An algorithm that uniquely recovers hidden moves from [[\u0393 \u22a2 M : T ]] was given by Hyland and Ong\nst\n\n[18, Part II].\n\n\f38\n\nW. BLUM AND C.-H. L. ONG\n\nExample 6.11. Take the term M \u2261 \u03bbf (o,o) z o .(\u03bbg(o,o) x.f x)(\u03bby o .y)(f z) of type ((o, o), o, o).\nThe figure below represents the computation tree (left tree), the arena [[((o, o), o, o)]] (right\ntree) and the function \u03c8M (dashed line). (Answer moves are not shown for clarity.) Take\nthe traversal t given hereunder, we have:\n\u03c8M\n\n\u03bbf z\n@\n\nt = \u03bbf z * @ * \u03bbgx * f [1] * \u03bb[2] * x * \u03bb[3] * f [4] * \u03bb[5] * z\n\n\u03bbgx \u03bby \u03bb[3]\nf [1]\n\ny\n\nq0\n\nf [4]\n\n\u03bb[2]\n\n\u03bb[5]\n\nx\n\nz\n\nq1 q3\nq2\n\nt \u21be r = \u03bbf z * f [1] * \u03bb[2] * f [4] * \u03bb[5] * z\n\u03c6M (t \u21be r) = q 0 * q 1 * q 2 * q 1 * q 2 * q 3 \u2208 [[M ]] .\n\nThis work is licensed under the Creative Commons Attribution-NoDerivs License. To view\na copy of this license, visit http:// reative ommons.org/li enses/by-nd/2.0/ or send a\nletter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.\n\n\f"}