{"id": "http://arxiv.org/abs/cs/0401025v1", "guidislink": true, "updated": "2004-01-27T03:42:03Z", "updated_parsed": [2004, 1, 27, 3, 42, 3, 1, 27, 0], "published": "2004-01-27T03:42:03Z", "published_parsed": [2004, 1, 27, 3, 42, 3, 1, 27, 0], "title": "Running C++ models undet the Swarm environment", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0201011%2Ccs%2F0201018%2Ccs%2F0201009%2Ccs%2F0201005%2Ccs%2F0201014%2Ccs%2F0201003%2Ccs%2F0201017%2Ccs%2F0201027%2Ccs%2F0201004%2Ccs%2F0201012%2Ccs%2F0201006%2Ccs%2F0201022%2Ccs%2F0201029%2Ccs%2F0201002%2Ccs%2F0201024%2Ccs%2F0201026%2Ccs%2F0201007%2Ccs%2F0201008%2Ccs%2F0201013%2Ccs%2F0201019%2Ccs%2F0201021%2Ccs%2F0201001%2Ccs%2F0201023%2Ccs%2F0201016%2Ccs%2F0201025%2Ccs%2F0201010%2Ccs%2F0201028%2Ccs%2F0201015%2Ccs%2F0201020%2Ccs%2F0401006%2Ccs%2F0401015%2Ccs%2F0401002%2Ccs%2F0401030%2Ccs%2F0401028%2Ccs%2F0401012%2Ccs%2F0401001%2Ccs%2F0401009%2Ccs%2F0401025%2Ccs%2F0401005%2Ccs%2F0401021%2Ccs%2F0401019%2Ccs%2F0401026%2Ccs%2F0401011%2Ccs%2F0401008%2Ccs%2F0401029%2Ccs%2F0401018%2Ccs%2F0401010%2Ccs%2F0401003%2Ccs%2F0401007%2Ccs%2F0401022%2Ccs%2F0401027%2Ccs%2F0401023%2Ccs%2F0401004%2Ccs%2F0401013%2Ccs%2F0401020%2Ccs%2F0401016%2Ccs%2F0401017%2Ccs%2F0401024%2Ccs%2F0511083%2Ccs%2F0511096%2Ccs%2F0511087%2Ccs%2F0511009%2Ccs%2F0511095%2Ccs%2F0511029%2Ccs%2F0511006%2Ccs%2F0511036%2Ccs%2F0511070%2Ccs%2F0511094%2Ccs%2F0511034%2Ccs%2F0511061%2Ccs%2F0511068%2Ccs%2F0511050%2Ccs%2F0511046%2Ccs%2F0511023%2Ccs%2F0511001%2Ccs%2F0511028%2Ccs%2F0511107%2Ccs%2F0511098%2Ccs%2F0511057%2Ccs%2F0511075%2Ccs%2F0511071%2Ccs%2F0511033%2Ccs%2F0511104%2Ccs%2F0511101%2Ccs%2F0511092%2Ccs%2F0511005%2Ccs%2F0511017%2Ccs%2F0511010%2Ccs%2F0511047%2Ccs%2F0511044%2Ccs%2F0511069%2Ccs%2F0511043%2Ccs%2F0511038%2Ccs%2F0511021%2Ccs%2F0511081%2Ccs%2F0511054%2Ccs%2F0511079%2Ccs%2F0511004%2Ccs%2F0511108%2Ccs%2F0511072%2Ccs%2F0511084&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Running C++ models undet the Swarm environment"}, "summary": "Objective-C is still the language of choice if users want to run their\nsimulation efficiently under the Swarm environment since the Swarm environment\nitself was written in Objective-C. The language is a fast, object-oriented and\neasy to learn. However, the language is less well known than, less expressive\nthan, and lacks support for many important features of C++ (eg. OpenMP for high\nperformance computing application). In this paper, we present a methodology and\nsoftware tools that we have developed for auto generating an Objective-C object\ntemplate (and all the necessary interfacing functions) from a given C++ model,\nutilising the Classdesc's object description technology, so that the C++ model\ncan both be run and accessed under the Objective-C and C++ environments. We\nalso present a methodology for modifying an existing Swarm application to make\npart of the model (eg. the heatbug's step method) run under the C++\nenvironment.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0201011%2Ccs%2F0201018%2Ccs%2F0201009%2Ccs%2F0201005%2Ccs%2F0201014%2Ccs%2F0201003%2Ccs%2F0201017%2Ccs%2F0201027%2Ccs%2F0201004%2Ccs%2F0201012%2Ccs%2F0201006%2Ccs%2F0201022%2Ccs%2F0201029%2Ccs%2F0201002%2Ccs%2F0201024%2Ccs%2F0201026%2Ccs%2F0201007%2Ccs%2F0201008%2Ccs%2F0201013%2Ccs%2F0201019%2Ccs%2F0201021%2Ccs%2F0201001%2Ccs%2F0201023%2Ccs%2F0201016%2Ccs%2F0201025%2Ccs%2F0201010%2Ccs%2F0201028%2Ccs%2F0201015%2Ccs%2F0201020%2Ccs%2F0401006%2Ccs%2F0401015%2Ccs%2F0401002%2Ccs%2F0401030%2Ccs%2F0401028%2Ccs%2F0401012%2Ccs%2F0401001%2Ccs%2F0401009%2Ccs%2F0401025%2Ccs%2F0401005%2Ccs%2F0401021%2Ccs%2F0401019%2Ccs%2F0401026%2Ccs%2F0401011%2Ccs%2F0401008%2Ccs%2F0401029%2Ccs%2F0401018%2Ccs%2F0401010%2Ccs%2F0401003%2Ccs%2F0401007%2Ccs%2F0401022%2Ccs%2F0401027%2Ccs%2F0401023%2Ccs%2F0401004%2Ccs%2F0401013%2Ccs%2F0401020%2Ccs%2F0401016%2Ccs%2F0401017%2Ccs%2F0401024%2Ccs%2F0511083%2Ccs%2F0511096%2Ccs%2F0511087%2Ccs%2F0511009%2Ccs%2F0511095%2Ccs%2F0511029%2Ccs%2F0511006%2Ccs%2F0511036%2Ccs%2F0511070%2Ccs%2F0511094%2Ccs%2F0511034%2Ccs%2F0511061%2Ccs%2F0511068%2Ccs%2F0511050%2Ccs%2F0511046%2Ccs%2F0511023%2Ccs%2F0511001%2Ccs%2F0511028%2Ccs%2F0511107%2Ccs%2F0511098%2Ccs%2F0511057%2Ccs%2F0511075%2Ccs%2F0511071%2Ccs%2F0511033%2Ccs%2F0511104%2Ccs%2F0511101%2Ccs%2F0511092%2Ccs%2F0511005%2Ccs%2F0511017%2Ccs%2F0511010%2Ccs%2F0511047%2Ccs%2F0511044%2Ccs%2F0511069%2Ccs%2F0511043%2Ccs%2F0511038%2Ccs%2F0511021%2Ccs%2F0511081%2Ccs%2F0511054%2Ccs%2F0511079%2Ccs%2F0511004%2Ccs%2F0511108%2Ccs%2F0511072%2Ccs%2F0511084&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Objective-C is still the language of choice if users want to run their\nsimulation efficiently under the Swarm environment since the Swarm environment\nitself was written in Objective-C. The language is a fast, object-oriented and\neasy to learn. However, the language is less well known than, less expressive\nthan, and lacks support for many important features of C++ (eg. OpenMP for high\nperformance computing application). In this paper, we present a methodology and\nsoftware tools that we have developed for auto generating an Objective-C object\ntemplate (and all the necessary interfacing functions) from a given C++ model,\nutilising the Classdesc's object description technology, so that the C++ model\ncan both be run and accessed under the Objective-C and C++ environments. We\nalso present a methodology for modifying an existing Swarm application to make\npart of the model (eg. the heatbug's step method) run under the C++\nenvironment."}, "authors": ["Richard Leow", "Russell K. Standish"], "author_detail": {"name": "Russell K. Standish"}, "author": "Russell K. Standish", "links": [{"href": "http://arxiv.org/abs/cs/0401025v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0401025v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.MA", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.MA", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.1.5;D.2.3;I.2.11", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0401025v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0401025v1", "arxiv_comment": null, "journal_reference": "Proceedings SwarmFest 2003", "doi": null, "fulltext": "Running C++ model under Swarm Environment\nRichard Leow 2 and Russell K. Standish 1 2\n1\n\nSchool of Mathematics\nHigh Performance Computing Support Unit,\nUniversity of New South Wales,\nSydney, NSW 2052, Australia.\nrichardl@hpc.unsw.edu.au\nR.Standish@unsw.edu.au\nhttp://www.hpc.unsw.edu.au\n2\n\nAbstract\nObjective-C [1,2,3,4,5] is still the language of choice if users want to run their simulation efficiently\nunder the Swarm [1] environment since the Swarm environment itself was written in Objective-C.\nThe language is a fast, object-oriented and easy to learn. However, the language is less well known\nthan, less expressive than, and lacks support for many important features of C++ (eg. OpenMP for\nhigh performance computing application).\nIn this paper, we present a methodology and software tools that we have developed for auto\ngenerating an Objective-C object template (and all the necessary interfacing functions) from a given\nC++ model, utilising the Classdesc's object description technology [6,7], so that the C++ model can\nboth be run and accessed under the Objective-C and C++ environments. We also present a\nmethodology for modifying an existing Swarm application to make part of the model (eg. the\nheatbug's step method) run under the C++ environment.\n\n1.0\n\nIntroduction\n\nSwarm [1] is one of the better-known agent based modelling systems. Swarm consists of a\nsimulation engine built in Objective-C that takes a set of objects called a Swarm, and a schedule of\nactions to perform on them. Swarm defines interfaces that the objects need to adhere to (called\nprotocols in Objective-C) in order for the simulation engine to interface to the Swarms. Finally, it\nprovides a suite of visualisation tools or instruments that can be attached to running swarms to\nobserve their behaviours. Swarm programs are hierarchical and the codes are object-oriented. First\nbeta version of Swarm was released in 1995 and was written in Objective-C. In 1999, a Java layer\nwas introduced (release 2.0 onwards). A COM interface was proposed [10] which would allow\nobjects written in arbitrary OO languages to be interfaced to swarm, but partially implemented\nbefore funding ran out.\nThe Objective-C syntax is a superset of ANSI Standard-C syntax, and its compiler works for both C\nand Objective-C source code. C++ was primarily designed as a \"better C\", incorporated objectoriented support as well as many other improvements over C. C++ is the preferred development\nlanguage by many because the language is fast, widely deployed, well known, provides rich\nexpressive features and supports generic programming and in-lining. Additionally, the language has\nan OpenMP support built-in and it can easily integrate with C/FORTRAN. Due to its market\npresence, vendors have provided highly optimising versions of C++ compilers for their various\nplatforms. Therefore, it is highly desirable to be able to use the C++ (let users code their models in\nC++) and Objective-C (able to utilise various Swarm's tools) languages in combination to take\nadvantage of what is best in both environments.\nIn this paper, we present a methodology and software tools that we have developed (utilising the\nClassdesc class descriptor technology) that enables users to auto generate an equivalent Objective-C\n\n\fobject template and all the necessary interfacing functions from a given C++ model. These will\nenable users to run and access their C++ models under both the C++ and Objective-C environments.\nWe also present a methodology for modifying an existing Swarm application (eg. Heatbugs) to\nmake part of it run under the C++ environment. The key concept is to use a modified Classdesc [6]\nto parse the user C++ model and to generate a relevant class description file. We then use this file to\nconstruct an Objective-C translator to auto-generate an equivalent Objective-C object template and\nall the necessary interface functions. Our C++AEObjective-C interfaces are very efficient as a lot of\nwork is done at compile time by the Classdesc and our approach is much more simpler as compared\nto Daniels COM approach [10] as we only target the C++ and Objective-C environments.\n\n2.0\n\nC++ model AE Objective-C design strategies\n\n2.1\n\nObjective-C basics\n\nFigure 1 Objective-C object structure\nIn Objective-C, objects are identified by a distinct data type id which is a pointer to the object.\nEvery object carries an isa instance variable which points to the object's class \u2013 what kind of object\nit is. The objc_class structure stores the object's type description. Most objects are derived from the\nroot class object called Object - it makes objects behave as Objective-C objects and enable them to\ncooperate with the run-time system. A message is sent to an object to get it to perform useful work\n(to apply a method). In Objective-C, message expressions are enclosed in square brackets (see\nFigure 2). The receiver is an object, and the message tells it what to do. In source code, the message\nis simply the name of a method and any arguments that are passed to it.\nIn Objective-C, messages are not bound to method implementations until run-time. The message\nfunction does everything necessary for dynamic binding. It first finds the procedure from the given\nmessage of particular receiver, then calls its procedure, passing it the receiving object and the\narguments, and finally, returns a value.\n\nFigure 2 Typical Objective-C message\n2.2\n\nFile conventions used\n\nFor an object to be used in both the C++ and the Objective-C environment:\n\u2022 The .h file extension is reserved for the C++ header file and .mh file extension is used for the\nObjective-C header file.\n\u2022 The .o file extension is reserved for the compiled C++ object file and the .mo file is used for the\ncompiled Objective-C object file.\n\u2022 The .cd file is the Classdesc output Class Description file from the given object .h file. This file\nis used for the compilation of Objective-C translator (see Section 2.6).\n\n\fFile name & extension\n\nPurpose\n\nRemarks\n\nmyobj.h\nmyobj.cc\nmyobj.mh\nmyobj.m\nmyobjExportCpp.cc\nmyobj.mo\nmyobj.o\nmyobj.cd\n\nC++ header file\nC++ object implementation file\nObjC object header\nObjC object implementation\nC++ interface function for ObjC\nCompiled ObjC object\nCompiled C++ object\nClassdesc description file\n\nUser model\nUser model\nInterface file 1\nInterface file 2\nInterface file 3\nObjC object file\nC++ object file\nClassdesc output\n\nFigure 3 File conventions used\n2.3\n\nObjects creation in the C++ and Objective-C environments\n\nFigure 4 shows an example of a C++ model and Figure 5 shows the equivalent Objective-C object\ntemplate. Since Objective-C and C++ programs are both run in the same memory space, only one\ncopy of the object is created and shared between both environments.\nIn our implementation, shared Objective-C/C++ objects are instantiated in the Objective-C\nenvironment (since all the objects in Objective-C environment must be inherited from the\nObjective-C base class for them to behave as Objective-C objects) and are accessed in the C++\nenvironment using the objects' C++ class templates (the Objective-C objects' pointers are passed to\nthe C++ environment for typecasting).\n#include <stdarg.h>\n#include \"ObjCsupport.h\"\n#include \"vector\"\nclass myCounter: public objc_obj {\npublic:\nchar\nsName[20];\nint\niaX[2][4];\n. . .\n\n};\n\n// ObjC supports\n// need to be derived from ObjC class\n\npublic:\nint\nsum3_x1(int x1, double x2, double x3); // std parameter passing\ndouble sumN_x1(double x1, objc_t& buf);\n// using va_list\nint prtVec(vector<int> v); // c++ only method \u2013 no ObjC translation\nint cpp_prtVec();\n// C++ only method due to \"cpp_\" sub-string\n\nFigure 4 An example of a user C++ model (myCounter.h)\n#import <objc/Object.h>\n@interface myCounter : Object\n{ @public\nchar sName[20];\nint iaX[2][4];\n. . .\n}\n- init;\n- (double) sum3_x1: (double) x1 x2: (double) x2 x3: (double) x3;\n- (double) sumN_x1: (double) x1, ...;\n@end\n\nFigure 5\n\nAn equivalent Objective-C object template (myCounter.mh)\n\n\f2.4\n\nParameter passing between C++ and Objective-C methods\n\nTwo methods of parameter passing are supported: the standard method and parameter passing using\nthe Standard-C stdarg mechanism [9]. The second method supports an arbitrary number of\narguments to be passed to C++ method. Figure 6 shows the two supported parameter-passing\nmethods and examples. Figure 7 shows the implementation details of the required interfacing\nfunctions to support these two types of parameter passing.\nTo aid users in extracting arbitrary number of arguments from the va_list structure (through the use\nof Standard-C va_start, va_arg and va_end macros), a supporting C++ class called objc_t and its\ncorresponding \">>\" overloaded output stream operator have been implemented and stored in the in\nthe supporting file ObjCsupport.h. An example of the usage is shown in Figure 6 in the user C++\nimplementation of the sumN_x1 member method (in this case, to sum a list of three real numbers).\nStandard parameter passing method:\nC++ method :\ndouble sum2_x1(double x1, double x2);\nObjective-C:\n- (double) sum3_x1: (double) x1 x2: (double) x2;\nParameter passing using va_list:\nC++ method :\ndouble sumN_x1(double x1, objc_t& buf);\nObjective-C:\n- (double) sumN_x1: (double) x1, ...;\nExample of Objective-C calls in user main program (main.m):\ndouble dx = [myObj sumN_x1: 1.1, 2.2, 3.3];\nExample of user method implementation in C++ (myCounter.cc):\ndouble sumN_x1(double x1, objc_t& buf)\n{ double x2, x3 ; buf >> x2 >> x3, return x1 + x2 + x3; }\n\nFigure 6\n\nSupported parameter passing methods and examples.\n\nObjective-C interface functions generated (stored in .m file) :\ndouble cpp_myCounter_sum2_x1(myCounter * obj, double x1 , double x2);\n- (double) sum2_x1: (double) x1 x2: (double) x2\n{ return cpp_myCounter_sum2_x1(self, x1, x2); }\ndouble cpp_myCounter_sumN_x1(myCounter * obj, double x1, va_list * ap);\n- (double) sumN_x1: (double) x1, ...\n{ double rtnvalue; va_list ap; va_start(ap, x1);\nrtnvalue = cpp_myCounter_sumN_x1(self, x1, &ap);\nva_end(ap);\nreturn rtnvalue; }\nC++ interface functions generated (stored in ExportCpp.cc file):\nextern \"C\"\ndouble cpp_myCounter_sum2_x1(myCounter * obj, double x1 , double x2)\n{ return obj->sum2_x1(x1, x2); }\nextern \"C\"\ndouble cpp_myCounter_sumN_x1(myCounter * obj, double x1, va_list * ap)\n{ objc_t buffer; buffer.ap = ap; return obj->sumN_x1(x1, buffer); }\n\nFigure 7 Supporting interfacing functions needed.\nFigure 8 shows the algorithm used to translate a C++ function prototype to its Objective-C\nequivalent. The translation of the C++ function argument string to Objective-C equivalent is\ndefined in the writeobjc action in the Classdesc's Objective-C base action definition file\nwriteobjc_base.h.\n\n\fGiven C++ function prototype :\nCpp-return-type\nfunction-name\nOutput Objective-C equivalent:\nObjC-return-type function-name\n\nCpp-argument-list\nObjC-argument-list\n\nconstruct ObjC-return-type + function name\nIF C++-only function\nno-function-translation\nELSE IF (#arg==2 & arg2-type==objc_t&)\nconstruct va_list-type-ObjC-argument-list\nELSE\nFOR arg1 to argn\nconstruct standard ObjC-type-argument-list\n\nFigure 8\n\nC++ AE Objective-C function prototype translation algorithm\n\nTo support the use of C++ only member-methods in the user model, following member functions\nwill not be translated to its Objective-C equivalent: argument-list contains any C++ objects (such as\nvector) or function-name that contains \"cpp_\" sub-string.\n2.5\n\nClassdesc modification to parse a user supplied C++ model\n\nClassdesc [6] is a technology that introduces knowledge of an object's structure into the run-time.\nClassdesc is also part of the Ecolab simulation system [7] for studying the evolution of complexity\n[8]. Both projects are open source projects, and are available for download from the UNSW HPC\nwebsite (http://parallel.hpc.unsw.edu.au). We modified Classdesc to include a \u2013objc switch to\nenable it to output class description definitions that are only relevant to the Objective-C translator.\nAn example of the modified Classdesc output is shown in Figure 9.\n#include \"writeobjc_base.h\"\ninline void writeobjc(writeobjc_t* targ, eco_string desc,class myCounter& arg)\n{\nwriteobjc(targ,desc+\"\",(objc_obj&)arg);\nwriteobjc(targ,desc+\".sName\",is_array(),arg.sName[0],\"[20]\");\n...\nwriteobjc(targ,desc+\".sum2_x1\",arg,&myCounter::sum2_x1, \"double\", \"double x1, double x2\");\nwriteobjc(targ,desc+\".sumN_x1\",arg,&myCounter::sumN_x1, \"double\", \"double x1 , objc_t & buf\");\n}\n\nFigure 9. An example of Classdesc output\nThe output from the Classdesc is stored in the .cd file, which consists mostly of writeobjc\nstatements (or actions). These overloaded writeobjc statements will recursive descend the class\ndefinition performing the \"translation\" operation on each primitive data type making-up the class.\nThe definitions of writeobjc actions on all primitive data type, including member function type, are\ndefined in the writeobjc_base.h file (Classdesc base action definition file).\n2.6\n\nThe construction of an Objective-C translator\n\nGiven the output of a Classdesc class definition file (.cd file), the purpose of a translator is to autogenerate an equivalent Objective-C object template and all the necessary Objective-C to C++\ninterfacing functions. To construct a translator, we need following files: the output file from the\nClassdesc (eg. myCounter.cd file), translator main program file (Figure 10), a user C++ model (eg.\nmyCounter.h and myCounter.cc files), and the Classdesc base-action definition file\n(writeobjc_base.h).\nDuring the compilation of an Objective-C translator, the class name (or the user model name) is\npassed to the translator by means of the compiler switch (for example, -DCNAME=myCounter) to\n\n\fenable the translator to include appropriate .h and .cd files. When the compilation completed, a\ntranslator called write_objc is created. When this translator is executed, it will create an equivalent\nObjective-C object template and all the necessary interfacing functions.\n#define WRITE_OBJC(classname) \\\nwriteobjc_headers(&targ, (eco_string) STRING(classname)); \\\nwriteobjc(&targ, (eco_string) STRING(classname), arg);\\\nwriteobjc_tail(&targ)\n#include \"writeobjc_base.h\"\n#include FILE_NAME(CNAME,.h)\n#include FILE_NAME(CNAME,.cd)\nint main()\n{ writeobjc_t targ;\nCNAME arg;\nWRITE_OBJC(CNAME);\nreturn 0;\n}\n\nFigure 10 Translator main program (write_objc.cc)\nDuring the execution of the translator, it creates an instance of the user model (or object) and\nrecursively calls the writeobjc action on all its member variables and functions for Objective-C\ntranslation. When the translator finishes its execution, three interface files are created: the\nObjective-C object definition file (eg. myCounter.mh), the Objective-C object implementation file\n(eg. myCounter.m) and the Objective-C calls to C++ methods interface file\n(myCounterExportCpp.cc file). Since writeobjc is recursive, it is only necessary to perform this\nprocess once, on a top level C++ class.\n\n3.0\n\nFour steps for C++ model AE Objective-C application generation\n\nGiven a C++ model, we need to go through the four steps of transformation (as shown in Figure 11)\nin order to generate a final application that will run under both the C++ and Objective-C\nenvironments. Figure 12 shows the details of the steps involved for final user application\ngeneration. Since this can be managed automatically via the make process, this complexity is not\nvisible to the programmer.\nStep\nStep\nStep\nStep\n\n1:\n2:\n3:\n4:\n\nParse C++ model using Classdesc\nCreate a translator\nAuto-generate interface files\nGenerate final application\n\nFigure 11 Four step for C++ AE Objective-C application generation\n\n\fFigure 12 C++ AE Objective-C application generation flow diagram\n3.1\n\nModification to the Swarm run-time environment\n\nThe Swarm run-time environment (see Figure 13) needs to be changed (stored in\n~/$(SWARMHOME)/etc/swarm/ sub-directory) to support both the C++ and Objective-C\nenvironments.\nSpecify a C++ compiler to use in ~/$(SWARMHOME)/etc/swarm/Makefile.common file\nCPP=/usr/local/gcc2/bin/g++\nAdd .m.mo and .cc.o rules in ~/$(SWARMHOME)/etc/swarm/Makefile.rule file:\n.SUFFIXES: .o .m .mo .mh .cd .cc .xm\n.m.mo: $(OBJC) -c -o $@ $(OBJCFLAGS) $(CPPFLAGS) $(DLLCPPFLAGS) $(EXTRACPPFLAGS)\n$(SWARMINCLUDES) $<\n.cc.o: $(CPP) -g -c $(OPTFLAGS) $<\nSpecify the use of C++ for linking in Makefile.appl\n$(APPEXE): $(OBJECTS)\n$(SHELL) $(bindir)/libtool-swarm --mode link $(CPP) $(CFLAGS) $(LDFLAGS) -\n\nFigure 13 Swarm environment modification\n3.2\n\nC++ AE Objective-C execution results: myCounter example\n\nFigure 14 shows the Makefile of the myCounter example and Figure 15 shows the execution trace\nof this Makefile and the execution results of the myCounter example.\n.h.cd: classdesc -objc writeobjc < $< > $@\n.h.mh: $(CPP) -g -c myCounter.cc\n$(CPP) -g -DCNAME=myCounter -o write_objc $(CPPOBJ) $(OBJC_TRANSLATOR)\nwrite_objc\n.m.mo: $(CC) -c -o $@ -Wno-import $(CFLAGS) $<\n.m.o: $(CC) -c -Wno-import $(CFLAGS) $<\n.cc.o: $(CPP) -g -c $(OPTFLAGS) $<\nLIBS = -L/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95/ \\\n-L/usr/local/lib/libstdc++.so -lgcc -lobjc\nOBJC_cd=myCounter.cd\n\n\fOBJC_mh=myCounter.mh\nCPPOBJ=myCounter.o\nINTERFACE_OBJ= myCounterExportCpp.o\nOBJC_TRANSLATOR=write_objc.cc\nOBJCOBJ=main.o myCounter.mo\nOBJ=$(OBJCOBJ) $(CPPOBJ) $(INTERFACE_OBJ)\nappl: $(OBJC_cd) $(OBJC_mh) $(OBJ)\n$(CPP) $(CFLAGS) -o main $(OBJ) $(LIBS)\nmain.o: main.m\nmyCounter.cd: myCounter.h\nmyCounter.mo: myCounter.mh myCounter.m\nmyCounter.o: myCounter.h myCounter.cc\nmyCounterExportCpp.o: myCounter.h myCounterExportCpp.cc\nmyCounter.mh: myCounter.h myCounter.cc\nclean:\nrm -f *.o *.mo *.*~ *~ main *.cd *,D\nrm myCounterExportCpp.cc write_objc myCounter.mh myCounter.m\n...\n\nFigure 14 Makefile for myCounter example\n$ make clean\n$ make\n\u00c5 Step 1\nclassdesc -objc writeobjc < myCounter.h > myCounter.cd\n/usr/local/gcc2/bin/g++ -g -c myCounter.cc\n\u00c5 Step 2\n/usr/local/gcc2/bin/g++ -g -DCNAME=myCounter -o write_objc myCounter.o\nwrite_objc.cc\nwrite_objc\nC++ to ObjC parsing ...\n\u00c5 Step 3\nStarts parsing C++ class to ObjC ...\nTranslating array: \"sName[20]\" - Translating simple data type: \"sName\" of-type\n\"char\"\n. . .\nTranslating function: double sumN_x1(double x1 , objc_t & buf )\n. . .\nEnd translation.\ngcc\ngcc\ng++\ng++\n\n-c -Wno-import -g main.m\n\u00c5 Step 4\n-c -o myCounter.mo -Wno-import -g myCounter.m\n-g -c myCounterExportCpp.cc\n-g -o main main.o myCounter.mo myCounter.o myCounterExportCpp.o\n-L/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95/\n-L/usr/local/lib/libstdc++.so -lgcc -lobjc\n\n$ main\n\u00c5 myCounter example\nC++ -> ObjC interface testing:\nMyCounter C++ Object: byte=<68> ObjName=<c1> dVal=<5.5> iInc=<3>\niaX[2][4]=<10 11 12 13 20 21 22 23 >\nMyCounter C++ Object: byte=<68> ObjName=<c1> dVal=<8.5> iInc=<3>\niaX[2][4]=<10 11 12 13 20 21 22 23 >\nParameter passing using va_list:\nSum = 16.500000\nNormal ObjC parameter passing:\nSum = 16.500000\nEnd testing.\n$\n\nFigure 15 myCounter sample execution trace\n\n\f4.0\n\nObjective-C AE C++ approach: Heatbugs example\n\nThe goal is to make the agent-part of the Heatbugs (the Heatbug's step method) run under C++ and\nleaving the rest to run under the Swarm environment. Currently, Classdesc will not parse the\nObjective-C code; therefore, we need to manually create an equivalent C++ class template for the\nHeatbug object (see Figure 16).\nHeatbug Objective-C definition\n@interface Heatbug: SwarmObject\n{ @public\n\nHeatbug C++ class template\nclass Heatbug\n{ public: public objc_obj\nunsigned\nzbits; // fr Swarmobj\ndouble\nunhappiness;\ndouble\nunhappiness;\nint\nx, y;\nint\nx, y;\nHeatValue idealTemperature;\nHeatValue idealTemperature;\nHeatValue outputHeat;\nHeatValue outputHeat;\nfloat\nrandomMoveProbability;\nfloat\nrandomMoveProbability;\nid\nworld;\nid <Grid2d> world;\nint\nworldXSize, worldYSize;\nint\nworldXSize, worldYSize;\nid\nheat;\nHeatSpace *heat;\nColor\nbugColor;\nColor\nbugColor;\n\n}\n- step;\n. . .\n@end\n\npublic:\nvoid step();\n};\n\nFigure 16 Heatbug objective-C definition and its equivalent C++ template\nOur approach is to use the techniques that we have developed in previous section for the\nmodification. Firstly, we need to create a C++ Heatbug class template and its implementation file\n(Heatbug.h and Heatbug.cc). The C++ Heatbug class will contain one member method called step\n(which contain most of modified Objective-C Heatbug step source code). Also noted that the\nObjective-C Heatbug object definition uses four user define types: HeatValue, Color,\nHeatExtremeType, and maxHeat. Therefore, we also need to type-define them in our C++ class\ntemplate (Figure 17). The other needed classes are id and objc_obj, which have already been\ndefined in the ObjCsupport.h file. The additional member variable that we needed to include in the\nHeatbug C++ class template is zbits. This zbits member variable is used by the Swarm environment\nfor memory zone allocation (the Objective-C Heatbug object inherited it from the SwarmObject\nobject and the SwarmObject inherited it form the Object_s object).\ntypedef\ntypedef\ntypedef\nextern\n\nint\nunsigned char\nenum {cold,hot}\nconst HeatValue\n\nHeatValue;\nColor;\nHeatExtremeType;\nmaxHeat;\n\nFigure 17 Heatbug related user define type for C++\nNext, the C++ Heatbug class needs to export the C++ step method for the Objective-C step method\nto call. The exported C++ step method is stored in HeatbugExportCpp.cc interface file as shown in\nFigure 18.\nSince the Objective-C Heatbug step method uses additional Swarm objects (a total of 11 member\nmethods from four different Swarm objects as shown in Figure 19). We also need to export these\nObjective-C methods to C++ environment (these Objective-C exported functions are stored in\nHeatbugExportObjC.m interfacing file). An example of a C++ calls to the Swarm's member method\nis shown in Figure 20 (in this case, a C++ objc_getHeat interface function calls to the getHeat\nmember-method of Swarm's HeatSpace object).\n\n\fObjective-C step method (Heatbug.m) :\nvoid cpp_Heatbug_step(Heatbug * obj);\n- step\n{ cpp_Heatbug_step(self); return self; }\nC++ export function (HeatbugExportCpp.cc) :\nextern \"C\" void cpp_Heatbug_step(Heatbug * obj)\n{ obj->step(); }\n\nFigure 18 Heatbug Objective-C step method modification and interfacing function.\nSwarm Object\nCalls C++ calls Swarm methods (7 methods)\n------------------ ----- ---------------------------------------SwarmObject\nHeatbug object derived from this object\nRaster\nGUI part of Heatbug - not modified\nPixmap\nGUI part of Heatbug - not modified\nUniformIntegerDist\nUniformDoubleDist\nGrid2d\nDiffuse2d\n\n3\n1\n1\n2\n1\n1\n2\n\n[uniformIntRand getIntWithMin: withMax:]\n[uniformDblRand getIntWithMin: withMax:]\n[world getObjectAtX: Y:]\n[world putObject: atX: Y:]\n[heat getValueAtX: Y:]\n[heat findExtremeType: X: Y:]\n[heat addHeat: X: Y:]\n\nFigure 19 Heatbug step method uses four swarm objects that needed to be translated to C++.\nOriginal Objective-C call:\nint heatHere = [heat getValueAtX: x Y: y]\nC++ modification:\nint heatHere = objc_getHeat(heat,x,y);\nExample of Objective-C export function (HeatbugExportObjC.m):\nextern int objc_getHeat(void * heatobj, int px, int py)\n{ return [(HeatSpace *) heatobj getValueAtX: px Y: py]; }\n\nFigure 20 C++ calls to Swarm-objec member method interfacing.\nFinally, we need to modify the Heatbugs Makefile (Figure 21) to make it compiles both the C++\nand Objective-C source codes. Figure 22 shows the execution trace of this Makefile and the\nexecution results of the modified Heatbugs sample.\n...\nCPPOBJ= Heatbug.o\nOBJCOBJ=Heatbug.mo HeatSpace.o main.o \\\nHeatbugModelSwarm.o HeatbugObserverSwarm.o \\\nHeatbugBatchSwarm.o HeatbugExportObjc.o\nOBJECTS=$(OBJCOBJ) $(CPPOBJ)\n...\nmain.o: main.m Heatbug.mh HeatSpace.h \\\nHeatbugObserverSwarm.h HeatbugBatchSwarm.h\nHeatbug.mo: Heatbug.m Heatbug.mh\nHeatbug.o: Heatbug.cc Heatbug.h\n...\nHeatbugExportObjc.o: HeatbugExportObjc.m\n\nFigure 21 Heatbug Makefile modification.\n$ make\n\u00c5 Heatbugs Makfile execution trace\n-c -o Heatbug.mo -g -O2 -Wall ....\ngcc -c -g -O2 -Wall -Wno-import ....\n...\ng++ -g -c Heatbug.cc\n\n\f~swarm-2.1.1/bin/libtool-swarm --mode link ....\ng++ -g -O2 -o heatbugs Heatbug.mo ....\n...\ncreating heatbugs\n$\n$ heatbugs\n\u00c5 run both in C++ and Objective-C/Swarm environments\nT=1 Hb1 at (60,65) feels cold moves to (60,66)\nT=1 Hb2 at (39,40) feels cold moves to (40,40)\nT=1 Hb3 at (30,7) feels cold moves to (30,6)\n...\n$\n\nFigure 22 Modified Heatbugs run in both C++ and Objective-C environments.\n\n5.0\n\nSummary\n\nIn this paper, we have demonstrated the use of Classdesc class description technology to parse a\nuser written C++ model and output a class description definitions (save in a .cd file). We then use\nthis .cd file to construct an Objective-C translator. When this translator is executed, it will autogenerate an equivalent Objective-C template and all the necessary interface functions so that the\nuser C++ model can both be run under the C++ and Objective-C/Swarm environments. In addition,\nwe also developped a methodology of modifying an existing Swarm application to make part of it\nrun under the C++ environment. This will provide the users the capability of coding their models\nusing C++ language while still able to utilise all the software tools available in the Swarm\nenvironment. To facilitate the Swarm and C++ integration, we still need to create a C++ layer (C++\nSwarm-object class templates and member methods interfacing) for all the existing Swarm objects.\nClassdesc is currently an open source project, and latest version is available from the UNSW HPC1\nweb site. You can also register as a developer by emailing R.Standish@unsw.edu.au. This will\nallow you to access the code as it is being developed, and submit your own code for changes. The\nproject is managed by Peter Miller's Aegis2 code management system, which allows multiple\ndevelopers to work independently on the code.\n\nReference:\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n\n1\n2\n\nSwarm User Guide, by Swarm Development Group, by Paul Johnson and Alex Lancaster,\nPublished 10 April 2000.\nObjective-Oriented Programming and the Objective-C Language, Next Developer's Library,\nby Don Larkin and Greg Wilson, 1993-1995 Next Software, Inc.\nThe Objective-C Language, Rhapsody Developer Documentation, Chapter 2, Feb 1998, Apple\nComputer, Inc.\nGCC 3.1 Objective-C source-codes and Objective-C 4.0 Language Implementation module\nsource codes, GCC 3.1, (C) 1992-2002 Free Software Foundation, Inc.\nInside Mac OS X: The Objective-C Programming Language, May 2002, Apple Computer,\nInc.\nA system for reflection in C++, Madina, D. and Standish, R.K., in Proceedings AUUG 2001:\nAlways on and everywhere, 207. ISBN 0957753225.\nEcolab 4, Standish, R.K., in Applied Complexity: From Neural Networks to Managed\nLandscapes, Halloy, S. and Williams, T. (eds), (New Zealand Institute for Crop and Food\nResearch, Christchurch), 156-163, 2000.\n\nhttp://parallel.hpc.unsw.edu.au\nhttp://www.canb.auug.org.au/~millerp/aegis/aegis.html\n\n\f[8]\n\nDiversity Evolution, Standish, R.K., in Artificial Life VIII (2002), Standish, RK, Bedau, MA\nand Abbass, HA (eds) (Cambridge, MA: MIT Press), 131-137.\n[9] The C programming language, Brian W. Kernighan and Dennis M. Ritchie, Second Edition,\nPg 155, \u00a9 1988 by Bell laboratories, Incorporated, Prentice Hall Software.\n[10] Swarm and COM, Marcus Daniels, Integration workshop at the GIS/EM4 Conference on\nSeptember 02, 2000.\n\n\f"}