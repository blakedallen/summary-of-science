{"id": "http://arxiv.org/abs/1112.0433v1", "guidislink": true, "updated": "2011-12-02T11:47:56Z", "updated_parsed": [2011, 12, 2, 11, 47, 56, 4, 336, 0], "published": "2011-12-02T11:47:56Z", "published_parsed": [2011, 12, 2, 11, 47, 56, 4, 336, 0], "title": "Automating the Finite Element Method", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1112.2204%2C1112.1031%2C1112.4599%2C1112.1710%2C1112.3342%2C1112.2418%2C1112.5373%2C1112.0644%2C1112.0688%2C1112.5833%2C1112.3641%2C1112.1804%2C1112.0433%2C1112.1750%2C1112.2875%2C1112.1715%2C1112.4467%2C1112.3615%2C1112.4679%2C1112.5889%2C1112.5945%2C1112.2305%2C1112.0304%2C1112.1997%2C1112.1903%2C1112.2307%2C1112.1628%2C1112.5678%2C1112.2807%2C1112.1854%2C0909.1369%2C0909.0826%2C0909.4282%2C0909.3218%2C0909.2156%2C0909.2069%2C0909.2417%2C0909.2683%2C0909.3898%2C0909.2097%2C0909.1125%2C0909.2093%2C0909.2584%2C0909.0266%2C0909.0629%2C0909.0672%2C0909.2209%2C0909.3102%2C0909.0526%2C0909.4314%2C0909.5319%2C0909.2350%2C0909.2748%2C0909.0972%2C0909.0365%2C0909.0467%2C0909.4106%2C0909.3651%2C0909.3529%2C0909.0687%2C0909.2262%2C0909.4622%2C0909.2140%2C0909.1123%2C0909.1468%2C0909.5248%2C0909.5528%2C0909.2975%2C0909.4373%2C0909.4024%2C0909.1275%2C0909.5478%2C0909.0696%2C0909.3485%2C0909.2901%2C0909.1245%2C0909.0673%2C0909.5691%2C0909.4256%2C0909.0324%2C0909.3672%2C0909.4169%2C0909.4893%2C0909.4986%2C0909.4803%2C0909.1863%2C0909.0412%2C0909.5099%2C0909.4015%2C0909.0955%2C0909.3135%2C0909.2873%2C0909.4933%2C0909.2211%2C0909.1208%2C0909.5191%2C0909.0666%2C0909.1670%2C0909.1435%2C0909.4797%2C0909.5218&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Automating the Finite Element Method"}, "summary": "The finite element method can be viewed as a machine that automates the\ndiscretization of differential equations, taking as input a variational\nproblem, a finite element and a mesh, and producing as output a system of\ndiscrete equations. However, the generality of the framework provided by the\nfinite element method is seldom reflected in implementations (realizations),\nwhich are often specialized and can handle only a small set of variational\nproblems and finite elements (but are typically parametrized over the choice of\nmesh).\n  This paper reviews ongoing research in the direction of a complete automation\nof the finite element method. In particular, this work discusses algorithms for\nthe efficient and automatic computation of a system of discrete equations from\na given variational problem, finite element and mesh. It is demonstrated that\nby automatically generating and compiling efficient low-level code, it is\npossible to parametrize a finite element code over variational problem and\nfinite element in addition to the mesh.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1112.2204%2C1112.1031%2C1112.4599%2C1112.1710%2C1112.3342%2C1112.2418%2C1112.5373%2C1112.0644%2C1112.0688%2C1112.5833%2C1112.3641%2C1112.1804%2C1112.0433%2C1112.1750%2C1112.2875%2C1112.1715%2C1112.4467%2C1112.3615%2C1112.4679%2C1112.5889%2C1112.5945%2C1112.2305%2C1112.0304%2C1112.1997%2C1112.1903%2C1112.2307%2C1112.1628%2C1112.5678%2C1112.2807%2C1112.1854%2C0909.1369%2C0909.0826%2C0909.4282%2C0909.3218%2C0909.2156%2C0909.2069%2C0909.2417%2C0909.2683%2C0909.3898%2C0909.2097%2C0909.1125%2C0909.2093%2C0909.2584%2C0909.0266%2C0909.0629%2C0909.0672%2C0909.2209%2C0909.3102%2C0909.0526%2C0909.4314%2C0909.5319%2C0909.2350%2C0909.2748%2C0909.0972%2C0909.0365%2C0909.0467%2C0909.4106%2C0909.3651%2C0909.3529%2C0909.0687%2C0909.2262%2C0909.4622%2C0909.2140%2C0909.1123%2C0909.1468%2C0909.5248%2C0909.5528%2C0909.2975%2C0909.4373%2C0909.4024%2C0909.1275%2C0909.5478%2C0909.0696%2C0909.3485%2C0909.2901%2C0909.1245%2C0909.0673%2C0909.5691%2C0909.4256%2C0909.0324%2C0909.3672%2C0909.4169%2C0909.4893%2C0909.4986%2C0909.4803%2C0909.1863%2C0909.0412%2C0909.5099%2C0909.4015%2C0909.0955%2C0909.3135%2C0909.2873%2C0909.4933%2C0909.2211%2C0909.1208%2C0909.5191%2C0909.0666%2C0909.1670%2C0909.1435%2C0909.4797%2C0909.5218&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The finite element method can be viewed as a machine that automates the\ndiscretization of differential equations, taking as input a variational\nproblem, a finite element and a mesh, and producing as output a system of\ndiscrete equations. However, the generality of the framework provided by the\nfinite element method is seldom reflected in implementations (realizations),\nwhich are often specialized and can handle only a small set of variational\nproblems and finite elements (but are typically parametrized over the choice of\nmesh).\n  This paper reviews ongoing research in the direction of a complete automation\nof the finite element method. In particular, this work discusses algorithms for\nthe efficient and automatic computation of a system of discrete equations from\na given variational problem, finite element and mesh. It is demonstrated that\nby automatically generating and compiling efficient low-level code, it is\npossible to parametrize a finite element code over variational problem and\nfinite element in addition to the mesh."}, "authors": ["Anders Logg"], "author_detail": {"name": "Anders Logg"}, "author": "Anders Logg", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1007/s11831-007-9003-9", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1112.0433v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1112.0433v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "76 pages, 19 figures", "arxiv_primary_category": {"term": "math.NA", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "math.NA", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1112.0433v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1112.0433v1", "journal_reference": "Arch. Comput. Meth. Engng. 14(2), 2007, pp. 93-138", "doi": "10.1007/s11831-007-9003-9", "fulltext": "Arch. Comput. Meth. Engng.\nVol. 00, 0, 1-76 (2006)\n\nArchives of Computational\nMethods in Engineering\nState of the art reviews\n\nAutomating the Finite Element Method\n\narXiv:1112.0433v1 [math.NA] 2 Dec 2011\n\nAnders Logg\nToyota Technological Institute at Chicago\nUniversity Press Building\n1427 East 60th Street\nChicago, Illinois 60637 USA\nEmail: logg@tti-c.org\n\nSummary\nThe finite element method can be viewed as a machine that automates the discretization of differential\nequations, taking as input a variational problem, a finite element and a mesh, and producing as output\na system of discrete equations. However, the generality of the framework provided by the finite element\nmethod is seldom reflected in implementations (realizations), which are often specialized and can handle\nonly a small set of variational problems and finite elements (but are typically parametrized over the choice\nof mesh).\nThis paper reviews ongoing research in the direction of a complete automation of the finite element method.\nIn particular, this work discusses algorithms for the efficient and automatic computation of a system of\ndiscrete equations from a given variational problem, finite element and mesh. It is demonstrated that by\nautomatically generating and compiling efficient low-level code, it is possible to parametrize a finite element\ncode over variational problem and finite element in addition to the mesh.\n\n1 INTRODUCTION\nThe finite element method (Galerkin's method) has emerged as a universal method for\nthe solution of differential equations. Much of the success of the finite element method\ncan be contributed to its generality and simplicity, allowing a wide range of differential\nequations from all areas of science to be analyzed and solved within a common framework.\nAnother contributing factor to the success of the finite element method is the flexibility of\nformulation, allowing the properties of the discretization to be controlled by the choice of\nfinite element (approximating spaces).\nAt the same time, the generality and flexibility of the finite element method has for a\nlong time prevented its automation, since any computer code attempting to automate it\nmust necessarily be parametrized over the choice of variational problem and finite element,\nwhich is difficult. Consequently, much of the work must still be done by hand, which is\nboth tedious and error-prone, and results in long development times for simulation codes.\nAutomating systems for the solution of differential equations are often met with skepticism, since it is believed that the generality and flexibility of such tools cannot be combined\nwith the efficiency of competing specialized codes that only need to handle one equation\nfor a single choice of finite element. However, as will be demonstrated in this paper, by\nautomatically generating and compiling low-level code for any given equation and finite element, it is possible to develop systems that realize the generality and flexibility of the finite\nelement method, while competing with or outperforming specialized and hand-optimized\ncodes.\n\nc 2006 by CIMNE, Barcelona (Spain).\n\nISSN: 1134\u20133060\n\nReceived: March 2006\n\n\fAnders Logg\n\n2\n\n1.1 Automating the Finite Element Method\nTo automate the finite element method, we need to build a machine that takes as input a\ndiscrete variational problem posed on a pair of discrete function spaces defined by a set of\nfinite elements on a mesh, and generates as output a system of discrete equations for the\ndegrees of freedom of the solution of the variational problem. In particular, given a discrete\nvariational problem of the form: Find U \u2208 Vh such that\n\u2200v \u2208 V\u0302h ,\n\na(U ; v) = L(v)\n\n(1)\n\nwhere a : Vh \u00d7V\u0302h \u2192 R is a semilinear form which is linear in its second argument, L : V\u0302h \u2192 R\na linear form and (V\u0302h , Vh ) a given pair of discrete function spaces (the test and trial spaces),\nthe machine should automatically generate the discrete system\nF (U ) = 0,\n\n(2)\n\nwhere F : Vh \u2192 RN , N = |V\u0302h | = |Vh | and\nFi (U ) = a(U ; \u03c6\u0302i ) \u2212 L(\u03c6\u0302i ),\n\ni = 1, 2, . . . , N,\n\n(3)\n\nfor {\u03c6\u0302i }N\ni=1 a given basis for V\u0302h .\nTypically, the discrete variational problem (1) is obtained as the discrete version of a\ncorresponding continuous variational problem: Find u \u2208 V such that\n\u2200v \u2208 V\u0302 ,\n\na(u; v) = L(v)\n\n(4)\n\nwhere V\u0302h \u2282 V\u0302 and Vh \u2282 V .\nThe machine should also automatically generate the discrete representation of the linearization of the given semilinear form a, that is the matrix A \u2208 RN \u00d7N defined by\nAij (U ) = a\u2032 (U ; \u03c6\u0302i , \u03c6j ),\n\ni, j = 1, 2, . . . , N,\n\n(5)\n\nwhere a\u2032 : Vh \u00d7 V\u0302h \u00d7 Vh \u2192 R is the Fr\u00e9chet derivative of a with respect to its first argument\nN\nand {\u03c6\u0302i }N\ni=1 and {\u03c6i }i=1 are bases for V\u0302h and Vh respectively.\nIn the simplest case of a linear variational problem,\na(v, U ) = L(v)\n\n\u2200v \u2208 V\u0302h ,\n\n(6)\n\nthe machine should automatically generate the linear system\nAU = b,\n\n(7)\n\nwhere Aij = a(\u03c6\u0302i , \u03c6j ) and bi = L(\u03c6\u0302i ), and where (Ui ) \u2208 RN is the vector of degrees of\nfreedom for the discrete solution U , that is, the expansion coefficients in the given basis for\nVh ,\nN\nX\nUi \u03c6i .\n(8)\nU=\ni=1\n\nWe return to this in detail below and identify the key steps towards a complete automation of the finite element method, including algorithms and prototype implementations for\neach of the key steps.\n\n\fAutomating the Finite Element Method\n\n3\n\n1.2 The FEniCS Project and the Automation of CMM\nThe FEniCS project [60, 36] was initiated in 2003 with the explicit goal of developing free\nsoftware for the Automation of Computational Mathematical Modeling (CMM), including\na complete automation of the finite element method. As such, FEniCS serves as a prototype\nimplementation of the methods and principles put forward in this paper.\nIn [96], an agenda for the automation of CMM is outlined, including the automation\nof (i) discretization, (ii) discrete solution, (iii) error control, (iv) modeling and (v) optimization. The automation of discretization amounts to the automatic generation of the\nsystem of discrete equations (2) or (7) from a given given differential equation or variational problem. Choosing as the foundation for the automation of discretization the finite\nelement method, the first step towards the Automation of CMM is thus the automation of\nthe finite element method. We continue the discussion on the automation of CMM below\nin Section 11.\nSince the initiation of the FEniCS project in 2003, much progress has been made, especially concerning the automation of discretization. In particular, two central components\nthat automate central aspects of the finite element method have been developed. The first\nof these components is FIAT, the FInite element Automatic Tabulator [83, 82, 84], which\nautomates the generation of finite element basis functions for a large class of finite elements.\nThe second component is FFC, the FEniCS Form Compiler [98, 87, 88, 99], which automates\nthe evaluation of variational problems by automatically generating low-level code for the\nassembly of the system of discrete equations from given input in the form of a variational\nproblem and a (set of) finite element(s).\nIn addition to FIAT and FFC, the FEniCS project develops components that wrap the\nfunctionality of collections of other FEniCS components (middleware) to provide simple,\nconsistent and intuitive user interfaces for application programmers. One such example\nis DOLFIN [62, 68, 63], which provides both a C++ and a Python interface (through\nSWIG [15, 14]) to the basic functionality of FEniCS.\nWe give more details below in Section 9 on FIAT, FFC, DOLFIN and other FEniCS\ncomponents, but list here some of the key properties of the software components developed\nas part of the FEniCS project, as well as the FEniCS system as a whole:\n\u2022 automatic and efficient evaluation of variational problems through FFC [98, 87, 88,\n99], including support for arbitrary mixed formulations;\n\u2022 automatic and efficient assembly of systems of discrete equations through DOLFIN [62,\n68, 63];\n\u2022 support for general families of finite elements, including continuous and discontinuous\nLagrange finite elements of arbitrary degree on simplices through FIAT [83, 82, 84];\n\u2022 high-performance parallel linear algebra through PETSc [9, 8, 10];\n\u2022 arbitrary order multi-adaptive mcG(q)/mdG(q) and mono-adaptive cG(q)/dG(q) ODE\nsolvers [94, 95, 50, 97, 100].\n1.3 Automation and Mathematics Education\nBy automating mathematical concepts, that is, implementing corresponding concepts in\nsoftware, it is possible to raise the level of the mathematics education. An aspect of this is\nthe possibility of allowing students to experiment with mathematical concepts and thereby\nobtaining an increased understanding (or familiarity) for the concepts. An illustrative\nexample is the concept of a vector in Rn , which many students get to know very well\nthrough experimentation and exercises in Octave [37] or MATLAB [118]. If asked which is\n\n\f4\n\nAnders Logg\n\nthe true vector, the x on the blackboard or the x on the computer screen, many students\n(and the author) would point towards the computer.\nBy automating the finite element method, much like linear algebra has been automated\nbefore, new advances can be brought to the mathematics education. One example of this\nis Puffin [70, 69], which is a minimal and educational implementation of the basic functionality of FEniCS for Octave/MATLAB. Puffin has successfully been used in a number\nof courses at Chalmers in G\u00f6teborg and the Royal Institute of Technology in Stockholm,\nranging from introductory undergraduate courses to advanced undergraduate/beginning\ngraduate courses. Using Puffin, first-year undergraduate students are able to design and\nimplement solvers for coupled systems of convection\u2013diffusion\u2013reaction equations, and thus\nobtaining important understanding of mathematical modeling, differential equations, the\nfinite element method and programming, without reducing the students to button-pushers.\nUsing the computer as an integrated part of the mathematics education constitutes a\nchange of paradigm [67], which will have profound influence on future mathematics education.\n1.4 Outline\nThis paper is organized as follows. In the next section, we first present a survey of existing\nfinite element software that automate particular aspects of the finite element method. In\nSection 3, we then give an introduction to the finite element method with special emphasis\non the process of generating the system of discrete equations from a given variational\nproblem, finite element(s) and mesh. A summary of the notation can be found at the end\nof this paper.\nHaving thus set the stage for our main topic, we next identify in Sections 4\u20136 the\nkey steps towards an automation of the finite element method and present algorithms and\nsystems that accomplish (in part) the automation of each of these key steps. We also discuss\na framework for generating an optimized computation from these algorithms in Section 7. In\nSection 8, we then highlight a number of important concepts and techniques from software\nengineering that play an important role for the automation of the finite element method.\nPrototype implementations of the algorithms are then discussed in Section 9, including\nbenchmark results that demonstrate the efficiency of the algorithms and their implementations. We then, in Section 10, present a number of examples to illustrate the benefits of a\nsystem automating the finite element method. As an outlook towards further research, we\npresent in Section 11 an agenda for the development of an extended automating system for\nthe Automation of CMM, for which the automation of the finite element method plays a\ncentral role. Finally, we summarize our findings in Section 12.\n2 SURVEY OF CURRENT FINITE ELEMENT SOFTWARE\nThere exist today a number of projects that seek to create systems that (in part) automate\nthe finite element method. In this section, we survey some of these projects. A complete\nsurvey is difficult to make because of the large number of such projects. The survey is\ninstead limited to a small set of projects that have attracted the attention of the author.\nIn effect, this means that most proprietary systems have been excluded from this survey.\nIt is instructional to group the systems both by their level of automation and their\ndesign. In particular, a number of systems provide automated generation of the system\nof discrete equations from a given variational problem, which we in this paper refer to as\nthe automation of the finite element method or automatic assembly, while other systems\nonly provide the user with a basic toolkit for this purpose. Grouping the systems by their\ndesign, we shall differentiate between systems that provide their functionality in the form of\n\n\fAutomating the Finite Element Method\n\n5\n\na library in an existing language and systems that implement new domain-specific languages\nfor finite element computation. A summary for the surveyed systems is given in Table 1.\nIt is also instructional to compare the basic specification of a simple test problem such\nas Poisson's equation, \u2212\u2206u = f in some domain \u03a9 \u2282 Rd , for the surveyed systems, or more\nprecisely, the specification of the corresponding discrete variational problem a(v, U ) = L(v)\nfor all v in some suitable test space, with the bilinear form a given by\nZ\n\u2207v * \u2207U dx,\n(9)\na(v, U ) =\n\u03a9\n\nand the linear form L given by\n\nL(v) =\n\nZ\n\nv f dx.\n\n(10)\n\n\u03a9\n\nEach of the surveyed systems allow the specification of the variational problem for\nPoisson's equation with varying degree of automation. Some of the systems provide a\nhigh level of automation and allow the variational problem to be specified in a notation\nthat is very close to the mathematical notation used in (9) and (10), while others require\nmore user-intervention. In connection to the presentation of each of the surveyed systems\nbelow, we include as an illustration the specification of the variational problem for Poisson's\nequation in the notation employed by the system in question. In all cases, we include only\nthe part of the code essential to the specification of the variational problem. Since the\ndifferent systems are implemented in different languages, sometimes even providing new\ndomain-specific languages, and since there are differences in philosophies, basic concepts\nand capabilities, it is difficult to make a uniform presentation. As a result, not all the\nexamples specify exactly the same problem.\nProject\nAnalysa\ndeal.II\nDiffpack\nFEniCS\nFreeFEM\nGetDP\nSundance\n\nautomatic assembly\nyes\nno\nno\nyes\nyes\nyes\nyes\n\nlibrary / language\nlanguage\nlibrary\nlibrary\nboth\nlanguage\nlanguage\nlibrary\n\nlicense\nproprietary\nQPL1\nproprietary\nGPL, LGPL\nLGPL\nGPL\nLGPL\n\nTable 1. Summary of projects seeking to automate the finite element method.\n\n2.1 Analysa\nAnalysa [6, 7] is a domain-specific language and problem-solving environment (PSE) for\npartial differential equations. Analysa is based on the functional language Scheme and\nprovides a language for the definition of variational problems. Analysa thus falls into the\ncategory of domain-specific languages.\nAnalysa puts forward the idea that it is sometimes desirable to compute the action of\na bilinear form, rather than assembling the matrix representing the bilinear form in the\ncurrent basis. In the notation of [7], the action of a bilinear form a : V\u0302h \u00d7 Vh \u2192 R on a\ngiven discrete function U \u2208 Vh is\nw = a(V\u0302h , U ) \u2208 RN ,\n\n(11)\n\n1\nIn addition to the terms imposed by the QPL, the deal.II license imposes a form of advertising clause,\nrequiring the citation of certain publications. See [12] for details.\n\n\fAnders Logg\n\n6\n\nwhere\nwi = a(\u03c6\u0302i , U ),\n\ni = 1, 2, . . . , N.\n\n(12)\n\nOf course, we have w = AU , where A is the matrix representing the bilinear form, with\nAij = a(\u03c6\u0302i , \u03c6j ), and (Ui ) \u2208 RN is the vector of expansion coefficients for U in the basis of\nVh . It follows that\nw = a(V\u0302h , U ) = a(V\u0302h , Vh )U.\n(13)\nIf the action only needs to be evaluated a few times for different discrete functions U\nbefore updating a linearization (reassembling the matrix A), it might be more efficient to\ncompute each action directly than first assembling the matrix A and applying it to each U .\nTo specify the variational problem for Poisson's equation with Analysa, one specifies a\npair of bilinear forms a and m, where a represents the bilinear form a in (9) and m represents\nthe bilinear form\nZ\nv U dx,\n(14)\nm(v, U ) =\n\u03a9\n\ncorresponding to a mass matrix. In the language of Analysa, the linear form L in (10) is\nrepresented as the application of the bilinear form m on the test space V\u0302h and the right-hand\nside f ,\nL(\u03c6\u0302i ) = m(V\u0302h , f )i , i = 1, 2, . . . , N,\n(15)\nas shown in Table 2. Note that Analysa thus defers the coupling of the forms and the test\nand trial spaces until the computation of the system of discrete equations.\n(integral-forms\n((a v U) (dot (gradient v) (gradient U)))\n((m v U) (* v U))\n)\n(elements\n(element (lagrange-simplex 1))\n)\n(spaces\n(test-space (fe element (all mesh) r:))\n(trial-space (fe element (all mesh) r:))\n)\n(functions\n(f (interpolant test-space (...)))\n)\n(define A-matrix (a testspace trial-space))\n(define b-vector (m testspace f))\nTable 2. Specifying the variational problem for Poisson's equation with Analysa\nusing piecewise linear elements on simplices (triangles or tetrahedra).\n\n2.2 deal.II\ndeal.II [12, 13, 11] is a C++ library for finite element computation. While providing\ntools for finite elements, meshes and linear algebra, deal.II does not provide support for\n\n\fAutomating the Finite Element Method\n\n7\n\nautomatic assembly. Instead, a user needs to supply the complete code for the assembly\nof the system (7), including the explicit computation of the element stiffness matrix (see\nSection 3 below) by quadrature, and the insertion of each element stiffness matrix into the\nglobal matrix, as illustrated in Table 3. This is a common design for many finite element\nlibraries, where the ambition is not to automate the finite element method, but only to\nprovide a set of basic tools.\n...\nfor (dof_handler.begin_active(); cell! = dof_handler.end(); ++cell)\n{\n...\nfor (unsigned int i = 0; i < dofs_per_cell; ++i)\nfor (unsigned int j = 0; j < dofs_per_cell; ++j)\nfor (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\ncell_matrix(i, j) += (fe_values.shape_grad (i, q_point) *\nfe_values.shape_grad (j, q_point) *\nfe_values.JxW(q_point));\nfor (unsigned int i = 0; i < dofs_per_cell; ++i)\nfor (unsigned int q_point = 0; q_point < n_q_points; ++q_point)\ncell_rhs(i) += (fe_values.shape_value (i, q_point) *\n<value of right-hand side f> *\nfe_values.JxW(q_point));\ncell->get_dof_indices(local_dof_indices);\nfor (unsigned int i = 0; i < dofs_per_cell; ++i)\nfor (unsigned int j = 0; j < dofs_per_cell; ++j)\nsystem_matrix.add(local_dof_indices[i],\nlocal_dof_indices[j],\ncell_matrix(i, j));\nfor (unsigned int i = 0; i < dofs_per_cell; ++i)\nsystem_rhs(local_dof_indices[i]) += cell_rhs(i);\n}\n...\nTable 3. Assembling the linear system (7) for Poisson's equation with deal.II.\n\n2.3 Diffpack\nDiffpack [24, 92] is a C++ library for finite element and finite difference solution of partial\ndifferential equations. Initiated in 1991, in a time when most finite element codes were\nwritten in FORTRAN, Diffpack was one of the pioneering libraries for scientific computing\nwith C++. Although originally released as free software, Diffpack is now a proprietary\nproduct.\nMuch like deal.II, Diffpack requires the user to supply the code for the computation\nof the element stiffness matrix, but automatically handles the loop over quadrature points\nand the insertion of the element stiffness matrix into the global matrix, as illustrated in\nTable 4.\n\n\fAnders Logg\n\n8\n\nfor (int i = 1; i <= nbf; i++)\nfor (int j = 1; j <= nbf; j++)\nelmat.A(i, j) += (fe.dN(i, 1) * fe.dN(j, 1) +\nfe.dN(i, 2) * fe.dN(j, 2) +\nfe.dN(i, 3) * fe.dN(j, 3)) * detJxW;\nfor (int i = 1; i <= nbf; i++)\nelmat.b(i) += fe.N(i)*<value of right-hand side f>*detJxW;\nTable 4. Computing the element stiffness matrix and element load vector for\nPoisson's equation with Diffpack.\n\n2.4 FEniCS\nThe FEniCS project [60, 36] is structured as a system of interoperable components that\nautomate central aspects of the finite element method. One of these components is the form\ncompiler FFC [98, 87, 88, 99], which takes as input a variational problem together with a set\nof finite elements and generates low-level code for the automatic computation of the system\nof discrete equations. In this regard, the FEniCS system implements a domain-specific\nlanguage for finite element computation, since the form is entered in a special language\ninterpreted by the compiler. On the other hand, the form compiler FFC is also available\nas a Python module and can be used as a just-in-time (JIT) compiler, allowing variational\nproblems to be specified and computed with from within the Python scripting environment.\nThe FEniCS system thus falls into both categories of being a library and a domain-specific\nlanguage, depending on which interface is used.\nTo specify the variational problem for Poisson's equation with FEniCS, one must specify\na pair of basis functions v and U, the right-hand side function f, and of course the bilinear\nform a and the linear form L, as shown in Table 5.\nelement = FiniteElement(''Lagrange'', ''tetrahedron'', 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\nf = Function(element)\na = dot(grad(v), grad(U))*dx\nL = v*f*dx\nTable 5. Specifying the variational problem for Poisson's equation with FEniCS\nusing piecewise linear elements on tetrahedra.\n\nNote in Table 5 that the function spaces (finite elements) for the test and trial functions v\nand U together with all additional functions/coefficients (in this case the right-hand side f)\nare fixed at compile-time, which allows the generation of very efficient low-level code since\nthe code can be generated for the specific given variational problem and the specific given\nfinite element(s).\nJust like Analysa, FEniCS (or FFC) supports the specification of actions, but while\nAnalysa allows the specification of a general expression that can later be treated as a\nbilinear form, by applying it to a pair of function spaces, or as a linear form, by applying\nit to a function space and a given fixed function, the arity of the form must be known at\nthe time of specification in the form language of FFC. As an example, the specification of\na linear form a representing the action of the bilinear form (9) on a function U is given in\n\n\fAutomating the Finite Element Method\n\n9\n\nTable 6.\nelement = FiniteElement(''Lagrange'', ''tetrahedron'', 1)\nv = BasisFunction(element)\nU = Function(element)\na = dot(grad(v), grad(U))*dx\nTable 6. Specifying the linear form for the action of the bilinear form (9) with\nFEniCS using piecewise linear elements on tetrahedra.\n\nA more detailed account of the various components of the FEniCS project is given below\nin Section 9.\n2.5 FreeFEM\nFreeFEM [108, 59] implements a domain-specific language for finite element solution of\npartial differential equations. The language is based on C++, extended with a special\nlanguage that allows the specification of variational problems. In this respect, FreeFEM\nis a compiler, but it also provides an integrated development environment (IDE) in which\nprograms can be entered, compiled (with a special compiler) and executed. Visualization\nof solutions is also provided.\nFreeFEM comes in two flavors, the current version FreeFEM++ which only supports\n2D problems and the 3D version FreeFEM3D. Support for 3D problems will be added to\nFreeFEM++ in the future. [108].\nTo specify the variational problem for Poisson's equation with FreeFEM++, one must\nfirst define the test and trial spaces (which we here take to be the same space V), and then\nthe test and trial functions v and U, as well as the function f for the right-hand side. One\nmay then define the bilinear form a and linear form L as illustrated in Table 7.\nfespace V(mesh, P1);\nV v, U;\nfunc f = ...;\nvarform a(v, U) = int2d(mesh)(dx(v)*dx(U) + dy(v)*dy(U));\nvarform L(v) = int2d(mesh)(v*f);\nTable 7. Specifying the variational problem for Poisson's equation with\nFreeFEM++ using piecewise linear elements on triangles (as determined by the mesh).\n\n2.6 GetDP\nGetDP [35, 34] is a finite element solver which provides a special declarative language for\nthe specification of variational problems. Unlike FreeFEM, GetDP is not a compiler, nor is\nit a library, but it will be classified here under the category of domain-specific languages.\nAt start-up, GetDP parses a problem specification from a given input file and then proceeds\naccording to the specification.\nTo specify the variational problem for Poisson's equation with GetDP, one must first give\na definition of a function space, which may include constraints and definition of sub spaces.\nA variational problem may then be specified in terms of functions from the previously\ndefined function spaces, as illustrated in Table 8.\n\n\fAnders Logg\n\n10\n\nFunctionSpace {\n{ Name V; Type Form0;\nBasisFunction {\n{ ... }\n}\n}\n}\nFormulation {\n{ Name Poisson; Type FemEquation;\nQuantity {\n{ Name v; Type Local; NameOfSpace V; }\n}\nEquation {\nGalerkin { [Dof{Grad v}, {Grad v}];\n....\n}\n}\n}\n}\nTable 8. Specifying the bilinear form for Poisson's equation with GetDP.\n\n2.7 Sundance\nSundance [103, 101, 102] is a C++ library for finite element solution of partial differential\nequations (PDEs), with special emphasis on large-scale PDE-constrained optimization.\nSundance supports automatic generation of the system of discrete equations from a\ngiven variational problem and has a powerful symbolic engine, which allows variational\nproblems to be specified and differentiated symbolically natively in C++. Sundance thus\nfalls into the category of systems providing their functionality in the form of library.\nTo specify the variational problem for Poisson's equation with Sundance, one must\nspecify a test function v, an unknown function U, the right-hand side f, the differential\noperator grad and the variational problem written in the form a(v, U ) \u2212 L(v) = 0, as\nshown in Table 9.\nExpr v = new TestFunction(new Lagrange(1));\nExpr U = new UnknownFunction(new Lagrange(1));\nExpr f = new DiscreteFunction(...);\nExpr\nExpr\nExpr\nExpr\n\ndx =\ndy =\ndz =\ngrad\n\nnew Derivative(0);\nnew Derivative(1);\nnew Derivative(2);\n= List(dx, dy, dz);\n\nExpr poisson = Integral((grad*v)*(grad*U) - v*f);\nTable 9. Specifying the variational problem for Poisson's equation with Sundance using piecewise linear elements on tetrahedra (as determined by\nthe mesh).\n\n\fAutomating the Finite Element Method\n\n11\n\n3 THE FINITE ELEMENT METHOD\nIt once happened that a man thought he had written original\nverses, and was then found to have read them word for word,\nlong before, in some ancient poet.\nGottfried Wilhelm Leibniz\nNouveaux essais sur l'entendement humain (1704/1764)\nIn this section, we give an overview of the finite element method, with special focus on\nthe general algorithmic aspects that form the basis for its automation. In many ways, the\nmaterial is standard [121, 117, 26, 27, 16, 71, 20, 39, 115], but it is presented here to give\na background for the continued discussion on the automation of the finite element method\nand to summarize the notation used throughout the remainder of this paper. The purpose\nis also to make precise what we set out to automate, including assumptions and limitations.\n3.1 Galerkin's Method\nGalerkin's method (the weighted residual method) was originally formulated with global\npolynomial spaces [57] and goes back to the variational principles of Leibniz, Euler, Lagrange, Dirichlet, Hamilton, Castigliano [25], Rayleigh [112] and Ritz [113]. Galerkin's\nmethod with piecewise polynomial spaces (V\u0302h , Vh ) is known as the finite element method.\nThe finite element method was introduced by engineers for structural analysis in the 1950s\nand was independently proposed by Courant in 1943 [30]. The exploitation of the finite\nelement method among engineers and mathematicians exploded in the 1960s. In addition\nto the references listed above, we point to the following general references: [38, 44, 45, 43,\n46, 47, 49, 17].\nWe shall refer to the family of Galerkin methods (weighted residual methods) with\npiecewise (polynomial) function spaces as the finite element method, including PetrovGalerkin methods (with different test and trial spaces) and Galerkin/least-squares methods.\n3.2 Finite Element Function Spaces\nA central aspect of the finite element method is the construction of discrete function spaces\nby piecing together local function spaces on the cells {K}K\u2208T of a mesh T of a domain\n\u03a9 = \u222aK\u2208T \u2282 Rd , with each local function space defined by a finite element.\n3.2.1 The finite element\n\nWe shall use the standard Ciarlet [27, 20] definition of a finite element, which reads as\nfollows. A finite element is a triple (K, PK , NK ), where\n\u2022 K \u2282 Rd is a bounded closed subset of Rd with nonempty interior and piecewise\nsmooth boundary;\n\u2022 PK is a function space on K of dimension nK < \u221e;\n\u2032 (the bounded linear functionals on P ).\n\u2022 NK = {\u03bd1K , \u03bd2K , . . . , \u03bdnKK } is a basis for PK\nK\nnK\nWe shall further assume that we are given a nodal basis {\u03c6K\ni }i=1 for PK that for each node\nK\nK\nK\n\u03bdi \u2208 NK satisfies \u03bdi (\u03c6j ) = \u03b4ij for j = 1, 2, . . . , nK . Note that this implies that for any\nv \u2208 PK , we have\nnK\nX\nv=\n\u03bdiK (v)\u03c6K\n(16)\ni .\ni=1\n\n\fAnders Logg\n\n12\n\nIn the simplest case, the nodes are given by evaluation of function values or directional\nnK\nderivatives at a set of points {xK\ni }i=1 , that is,\n\u03bdiK (v) = v(xK\ni ),\n\ni = 1, 2, . . . , nK .\n\n(17)\n\n3.2.2 The local-to-global mapping\n\nNow, to define a global function space Vh = span{\u03c6i }N\ni=1 on \u03a9 and a set of global nodes\nN = {\u03bdi }N\nfrom\na\ngiven\nset\n{(K,\nP\n,\nN\n)}\nof\nfinite\nelements, we also need to specify\nK\nK K\u2208T\ni=1\nhow the local function spaces are pieced together. We do this by specifying for each cell\nK \u2208 T a local-to-global mapping,\n\u03b9K : [1, nK ] \u2192 N,\n\n(18)\n\nthat specifies how the local nodes NK are mapped to global nodes N , or more precisely,\n\u03bd\u03b9K (i) (v) = \u03bdiK (v|K ),\n\ni = 1, 2, . . . , nK ,\n\n(19)\n\nfor any v \u2208 Vh , that is, each local node \u03bdiK \u2208 NK corresponds to a global node \u03bd\u03b9K (i) \u2208 N\ndetermined by the local-to-global mapping \u03b9K .\n3.2.3 The global function space\n\nWe now define the global function space Vh as the set of functions on \u03a9 satisfying\nv|K \u2208 PK\n\n\u2200K \u2208 T ,\n\n(20)\n\nand furthermore satisfying the constraint that if for any pair of cells (K, K \u2032 ) \u2208 T \u00d7 T and\nlocal node numbers (i, i\u2032 ) \u2208 [1, nK ] \u00d7 [1, nK \u2032 ], we have\n\u03b9K (i) = \u03b9K \u2032 (i\u2032 ),\nthen\n\n\u2032\n\n\u03bdiK (v|K ) = \u03bdiK\u2032 (v|K \u2032 ),\n\n(21)\n(22)\n\nwhere v|K denotes the continuous extension to K of the restriction of v to the interior of\n\u2032\nK, that is, if two local nodes \u03bdiK and \u03bdiK\u2032 are mapped to the same global node, then they\nmust agree for each function v \u2208 Vh .\nNote that by this construction, the functions of Vh are undefined on cell boundaries,\nunless the constraints (22) force the (restrictions of) functions of Vh to be continuous on\ncell boundaries, in which case we may uniquely define the functions of Vh on the entire\ndomain \u03a9. However, this is usually not a problem, since we can perform all operations on\nthe restrictions of functions to the local cells.\n3.2.4 Lagrange finite elements\n\nThe basic example of finite element function spaces is given by the family of Lagrange finite\nelements on simplices in Rd . A Lagrange finite element is given by a triple (K, PK , NK ),\nwhere the K is a simplex in Rd (a line in R, a triangle in R2 , a tetrahedron in R3 ), PK is\nthe space Pq (K) of scalar polynomials of degree \u2264 q on K and each \u03bdiK \u2208 NK is given by\npoint evaluation at some point xK\ni \u2208 K, as illustrated in Figure 1 for q = 1 and q = 2 on a\nnK\ntriangulation of some domain \u03a9 \u2282 R2 . Note that by the placement of the points {xK\ni }i=1\nat the vertices and edge midpoints of each cell K, the global function space is the set of\ncontinuous piecewise polynomials of degree q = 1 and q = 2 respectively.\n\n\fAutomating the Finite Element Method\n\n13\n\nFigure 1. Distribution of the nodes on a triangulation of a domain \u03a9 \u2282 R2 for\nLagrange finite elements of degree q = 1 (left) and q = 2 (right).\n\n3.2.5 The reference finite element\n\nAs we have seen, a global discrete function space Vh may be described by a mesh T , a set\nof finite elements {(K, PK , NK )}K\u2208T and a set of local-to-global mappings {\u03b9K }K\u2208T . We\nmay simplify this description further by introducing a reference finite element (K0 , P0 , N0 ),\nwhere N0 = {\u03bd10 , \u03bd20 , . . . , \u03bdn00 }, and a set of invertible mappings {FK }K\u2208T that map the\nreference cell K0 to the cells of the mesh,\nK = FK (K0 )\n\n\u2200K \u2208 T ,\n\n(23)\n\nas illustrated in Figure 2. Note that K0 is generally not part of the mesh. Typically,\nthe mappings {FK }K\u2208T are affine, that is, each FK can be written in the form FK (X) =\nAK X + bK for some matrix AK \u2208 Rd\u00d7d and some vector bK \u2208 Rd , or isoparametric, in\nwhich case the components of FK are functions in P0 .\nFor each cell K \u2208 T , the mapping FK generates a function space on FK given by\n\u22121\n: v0 \u2208 P0 },\nPK = {v = v0 \u25e6 FK\n\n(24)\n\n\u22121\n\u22121\n(x)\n(x)) = v0 \u25e6FK\nthat is, each function v = v(x) may be written in the form v(x) = v0 (FK\nfor some v0 \u2208 P0 .\nSimilarly, we may also generate for each K \u2208 T a set of nodes NK on PK given by\n\nNK = {\u03bdiK : \u03bdiK (v) = \u03bdi0 (v \u25e6 FK ),\n\ni = 1, 2, . . . , n0 }.\n\n(25)\n\nUsing the set of mappings {FK }K\u2208T , we may thus generate from the reference finite element (K0 , P0 , N0 ) a set of finite elements {(K, PK , NK )}K\u2208T given by\nK = FK (K0 ),\n\u22121\n: v0 \u2208 P0 },\nPK = {v = v0 \u25e6 FK\n\nNK =\n\n{\u03bdiK\n\n:\n\n\u03bdiK (v)\n\n=\n\n\u03bdi0 (v\n\n\u25e6 FK ),\n\n(26)\ni = 1, 2, . . . , n0 = nK }.\n\nnK\nWith this construction, it is also simple to generate a set of nodal basis functions {\u03c6K\ni }i=1 on\nn0\n0\nK from a set of nodal basis functions {\u03a6i }i=1 on the reference element satisfying \u03bdi (\u03a6j ) =\n\u22121\n\u03b4ij . Noting that if \u03c6K\ni = \u03a6i \u25e6 FK for i = 1, 2, . . . , nK , then\n0 K\n0\n\u03bdiK (\u03c6K\nj ) = \u03bdi (\u03c6j \u25e6 FK ) = \u03bdi (\u03a6j ) = \u03b4ij ,\n\n(27)\n\n\fAnders Logg\n\n14\n\nx3\n\nK\nx2\nX3\n\n= (0, 1)\n\nx = FK (X)\nFK\nx1\n\nK0\n\nX\nX 1 = (0, 0)\n\nX 2 = (1, 0)\n\nFigure 2. The (affine) mapping FK from a reference cell K0 to some cell K \u2208 T .\n\nnK\nso {\u03c6K\ni }i=1 is a nodal basis for PK .\nNote that not all finite elements may be generated from a reference finite element using\nthis simple construction. For example, this construction fails for the family of Hermite\nfinite elements [26, 27, 20]. Other examples include H(div) and H(curl) conforming finite\nelements (preserving the divergence and the curl respectively over cell boundaries) which\nrequire a special mapping of the basis functions from the reference element.\nHowever, we shall limit our current discussion to finite elements that can be generated\nfrom a reference finite element according to (26), which includes all affine and isoparametric\nfinite elements with nodes given by point evaluation such as the family of Lagrange finite\nelements on simplices.\nWe may thus define a discrete function space by specifying a mesh T , a reference finite\nelement (K, P0 , N0 ), a set of local-to-global mappings {\u03b9K }K\u2208T and a set of mappings\n{FK }K\u2208T from the reference cell K0 , as demonstrated in Figure 3. Note that in general,\nthe mappings need not be of the same type for all cells K and not all finite elements need\nto be generated from the same reference finite element. In particular, one could employ a\ndifferent (higher-degree) isoparametric mapping for cells on a curved boundary.\n\n3.3 The Variational Problem\nWe shall assume that we are given a set of discrete function spaces defined by a corresponding set of finite elements on some triangulation T of a domain \u03a9 \u2282 Rd . In particular, we\nare given a pair of function spaces,\nV\u0302h = span{\u03c6\u0302i }N\ni=1 ,\nVh = span{\u03c6i }N\ni=1 ,\n\n(28)\n\n\fAutomating the Finite Element Method\n\n15\n\nFigure 3. Piecing together local function spaces on the cells of a mesh to form\na discrete function space on \u03a9, generated by a reference finite element\n(K0 , P0 , N0 ), a set of local-to-global mappings {\u03b9K }K\u2208T and a set of\nmappings {FK }K\u2208T .\n\nwhich we refer to as the test and trial spaces respectively.\nWe shall also assume that we are given a variational problem of the form: Find U \u2208 Vh\nsuch that\na(U ; v) = L(v) \u2200v \u2208 V\u0302h ,\n(29)\nwhere a : Vh \u00d7 V\u0302h \u2192 R is a semilinear form which is linear in its second argument2 and\nL : V\u0302h \u2192 R is a linear form (functional). Typically, the forms a and L of (29) are defined\nin terms of integrals over the domain \u03a9 or subsets of the boundary \u2202\u03a9 of \u03a9.\n3.3.1 Nonlinear variational problems\n\nThe variational problem (29) gives rise to a system of discrete equations,\nF (U ) = 0,\n\n(31)\n\nfor the vector (Ui ) \u2208 RN of degrees of freedom of the solution U =\nFi (U ) = a(U ; \u03c6\u0302i ) \u2212 L(\u03c6\u0302i ),\n\ni = 1, 2, . . . , N.\n\nPN\n\ni=1 Ui \u03c6i\n\n\u2208 Vh , where\n(32)\n\nIt may also be desirable to compute the Jacobian A = F \u2032 of the nonlinear system (31)\nfor use in a Newton's method. We note that if the semilinear form a is differentiable in U ,\n2\nWe shall use the convention that a semilinear form is linear in each of the arguments appearing after\nthe semicolon. Furthermore, if a semilinear form a with two arguments is linear in both its arguments, we\nshall use the notation\na(v, U ) = a\u2032 (U ; v, U ) = a\u2032 (U ; v) U,\n(30)\n\nwhere a\u2032 is the Fr\u00e9chet derivative of a with respect to U , that is, we write the bilinear form with the test\nfunction as its first argument.\n\n\fAnders Logg\n\n16\n\nthen the entries of the Jacobian A are given by\nAij =\n\n\u2202Fi (U )\n\u2202\n\u2202U\n=\na(U ; \u03c6\u0302i ) = a\u2032 (U ; \u03c6\u0302i )\n= a\u2032 (U ; \u03c6\u0302i )\u03c6j = a\u2032 (U ; \u03c6\u0302i , \u03c6j ).\n\u2202Uj\n\u2202Uj\n\u2202Uj\n\n(33)\n\nAs an example, consider the nonlinear Poisson's equation\n\u2212\u2207 * ((1 + u)\u2207u) = f\nu=0\n\nin \u03a9,\non \u2202\u03a9.\n\nMultiplying (34) with a test function v and integrating by parts, we obtain\nZ\nZ\nvf dx,\n\u2207v * ((1 + u)\u2207u) dx =\n\n(34)\n\n(35)\n\n\u03a9\n\n\u03a9\n\nand thus a discrete nonlinear variational problem of the form (29), where\nZ\n\u2207v * ((1 + U )\u2207U ) dx,\na(U ; v) =\nZ\u03a9\nv f dx.\nL(v) =\n\n(36)\n\n\u03a9\n\nLinearizing the semilinear form a around U , we obtain\nZ\nZ\n\u2032\n\u2207v * ((1 + U )\u2207w) dx,\n\u2207v * (w\u2207U ) dx +\na (U ; v, w) =\n\n(37)\n\n\u03a9\n\n\u03a9\n\nfor any w \u2208 Vh . In particular, the entries of the Jacobian matrix A are given by\nZ\nZ\n\u2032\n\u2207\u03c6\u0302i * ((1 + U )\u2207\u03c6j ) dx.\n\u2207\u03c6\u0302i * (\u03c6j \u2207U ) dx +\nAij = a (U ; \u03c6\u0302i , \u03c6j ) =\n\n(38)\n\n\u03a9\n\n\u03a9\n\n3.3.2 Linear variational problems\n\nIf the variational problem (29) is linear, the nonlinear system (31) is reduced to the linear\nsystem\nAU = b,\n(39)\nfor the degrees of freedom (Ui ) \u2208 RN , where\nAij = a(\u03c6\u0302i , \u03c6j ),\nbi = L(\u03c6\u0302i ).\n\n(40)\n\nNote the relation to (33) in that Aij = a(\u03c6\u0302i , \u03c6j ) = a\u2032 (U ; \u03c6\u0302i , \u03c6j ).\nIn Section 2, we saw the canonical example of a linear variational problem with Poisson's\nequation,\n\u2212\u2206u = f\nu=0\n\nin \u03a9,\non \u2202\u03a9,\n\ncorresponding to a discrete linear variational problem of the form (29), where\nZ\n\u2207v * \u2207U dx,\na(v, U ) =\n\u03a9\nZ\nv f dx.\nL(v) =\n\u03a9\n\n(41)\n\n(42)\n\n\fAutomating the Finite Element Method\n\n17\n\n3.4 Multilinear Forms\nWe find that for both nonlinear and linear problems, the system of discrete equations is\nobtained from the given variational problem by evaluating a set of multilinear forms on\nthe set of basis functions. Noting that the semilinear form a of the nonlinear variational\nproblem (29) is a linear form for any given fixed U \u2208 Vh and that the form a for a linear\nvariational problem can be expressed as a(v, U ) = a\u2032 (U ; v, U ), we thus need to be able to\nevaluate the following multilinear forms:\na(U ; *) : V\u0302h \u2192 R,\nL : V\u0302h \u2192 R,\n\n(43)\n\n\u2032\n\na (U, *, *) : V\u0302h \u00d7 Vh \u2192 R.\nWe shall therefore consider the evaluation of general multilinear forms of arity r > 0,\na : Vh1 \u00d7 Vh2 \u00d7 * * * \u00d7 Vhr \u2192 R,\n\n(44)\n\ndefined on the product space Vh1 \u00d7 Vh2 \u00d7 * * * \u00d7 Vhr of a given set {Vhj }rj=1 of discrete function\nspaces on a triangulation T of a domain \u03a9 \u2282 Rd . In the simplest case, all function spaces\nare equal but there are many important examples, such as mixed methods, where it is\nimportant to consider arguments coming from different function spaces. We shall restrict\nour attention to multilinear forms expressed as integrals over the domain \u03a9 (or subsets of\nits boundary).\n1\nr\n2\n1\nr Nr\n2 N2\nLet now {\u03c61i }N\ni=1 , {\u03c6i }i=1 , . . . , {\u03c6i }i=1 be bases of Vh , Vh , . . . , Vh respectively and let\ni = (i1 , i2 , . . . , ir ) be a multiindex of length |i| = r. The multilinear form a then defines a\nrank r tensor given by\nAi = a(\u03c61i1 , \u03c62i2 , . . . , \u03c6rir ) \u2200i \u2208 I,\n(45)\nwhere I is the index set\nI=\n\nr\nY\n\n[1, |Vhj |] = {(1, 1, . . . , 1), (1, 1, . . . , 2), . . . , (N 1 , N 2 , . . . , N r )}.\n\n(46)\n\nj=1\n\nFor any given multilinear form of arity r, the tensor A is a (typically sparse) tensor of\nrank r and dimension (|Vh1 |, |Vh2 |, . . . , |Vhr |) = (N 1 , N 2 , . . . , N r ).\nTypically, the arity of the multilinear form a is r = 2, that is, a is a bilinear form, in\nwhich case the corresponding tensor A is a matrix (the \"stiffness matrix\"), or the arity of\nthe multilinear form a is r = 1, that is, a is a linear form, in which case the corresponding\ntensor A is a vector (\"the load vector\").\nSometimes it may also be of interest to consider forms of higher arity. As an example,\nconsider the discrete trilinear form a : Vh1 \u00d7 Vh2 \u00d7 Vh3 \u2192 R associated with the weighted\nPoisson's equation \u2212\u2207 * (w\u2207u) = f . The trilinear form a is given by\nZ\nw\u2207v * \u2207U dx,\n(47)\na(v, U, w) =\n\u03a9\n\nP 3\n3\n3\nfor w = N\ni=1 wi \u03c6i \u2208 Vh a given discrete weight function. The corresponding rank three\ntensor is given by\nZ\n\u03c63i3 \u2207\u03c61i1 * \u2207\u03c62i2 dx.\n(48)\nAi =\n\u03a9\n\n\fAnders Logg\n\n18\n\nNoting that for any w =\n\nPN 3\n\n3\ni=1 wi \u03c6i , the tensor contraction A : w =\n\n\u0010P 3\nN\n\ni3 =1 Ai1 i2 i3 wi3\n\nis a matrix, we may thus obtain the solution U by solving the linear system\n(A : w)U = b,\n\n\u0011\n\ni1 i2\n\n(49)\n\nwhere bi = L(\u03c61i1 ) = \u03a9 \u03c61i1 f dx. Of course, if the solution is needed only for one single\nweight function w, it is more efficient to consider w as a fixed function and directly compute\nthe matrix A associated with the bilinear form a(*, *, w). In some cases, it may even be\ndesirable to consider the function U as being fixed and directly compute a vector A (the\naction) associated with the linear form a(*, U, w), as discussed above in Section 2.1. It is\nthus important to consider multilinear forms of general arity r.\nR\n\n3.5 Assembling the Discrete System\nThe standard algorithm [121, 71, 92] for computing the tensor A is known as assembly; the\ntensor is computed by iterating over the cells of the mesh T and adding from each cell the\nlocal contribution to the global tensor A.\nTo explain how the standard assembly algorithm applies to the computation of the\ntensor A defined in (45) from a given multilinear form a, we note that if the multilinear\nform a is expressed as an integral over the domain \u03a9, we can write the multilinear form as\na sum of element multilinear forms,\nX\na=\naK ,\n(50)\nK\u2208T\n\nand thus\nAi =\n\nX\n\naK (\u03c61i1 , \u03c62i2 , . . . , \u03c6rir ).\n\n(51)\n\nK\u2208T\n\nWe note that in the case\nof Poisson's equation, \u2212\u2206u = f , the element bilinear form aK is\nR\ngiven by aK (v, U ) = K \u2207v * \u2207U dx.\nWe now let \u03b9jK : [1, njK ] \u2192 [1, N j ] denote the local-to-global mapping introduced above\nin Section 3.2 for each discrete function space Vhj , j = 1, 2, . . . , r, and define for each K \u2208 T\nthe collective local-to-global mapping \u03b9K : IK \u2192 I by\n\u03b9K (i) = (\u03b91K (i1 ), \u03b92K (i2 ), . . . , \u03b93K (i3 )) \u2200i \u2208 IK ,\n\n(52)\n\nwhere IK is the index set\nIK =\n\nr\nY\n\nj\n[1, |PK\n|] = {(1, 1, . . . , 1), (1, 1, . . . , 2), . . . , (n1K , n2K , . . . , nrK )}.\n\n(53)\n\nj=1\nnj\n\nK\nFurthermore, for each Vhj we let {\u03c6K,j\ni }i=1 denote the restriction to an element K of the\nj\nj Nj\nsubset of the basis {\u03c6i }i=1 of Vh supported on K, and for each i \u2208 I we let Ti \u2282 T denote\nthe subset of cells on which all of the basis functions {\u03c6jij }rj=1 are supported.\nWe may now compute the tensor A by summing the contributions from each local cell K,\nX\nX\nAi =\naK (\u03c61i1 , \u03c62i2 , . . . , \u03c6rir ) =\naK (\u03c61i1 , \u03c62i2 , . . . , \u03c6rir )\n\nK\u2208T\n\n=\n\nX\n\nK\u2208Ti\n\nK\u2208Ti\n\n).\n, . . . , \u03c6K,r\n, \u03c6K,2\naK (\u03c6K,1\n(\u03b9rK )\u22121 (ir )\n(\u03b91K )\u22121 (i1 ) (\u03b92K )\u22121 (i2 )\n\n(54)\n\n\fAutomating the Finite Element Method\n\n19\n\nThis computation may be carried out efficiently by iterating once over all cells K \u2208 T and\nadding the contribution from each K to every entry Ai of A such that K \u2208 Ti , as illustrated\nin Algorithm 1. In particular, we never need to form the set Ti , which is implicit through\nthe set of local-to-global mappings {\u03b9K }K\u2208T .\nAlgorithm 1 A = Assemble(a, {Vhj }rj=1 , {\u03b9K }K\u2208T , T )\nA=0\nfor K \u2208 T\nfor i \u2208 IK\nK,2\nK,r\nA\u03b9K (i) = A\u03b9K (i) + aK (\u03c6K,1\ni1 , \u03c6i2 , . . . , \u03c6ir )\nend for\nend for\n\nThe assembly algorithm may be improved by defining the element tensor AK by\nK,1 K,2\nK,r\nAK\ni = aK (\u03c6i1 , \u03c6i2 , . . . , \u03c6ir ) \u2200i \u2208 IK .\n\n(55)\n\nFor any multilinear form of arity r, the element tensor AK is a (typically dense) tensor of\nrank r and dimension (n1K , n2K , . . . , nrK ).\nBy computing first on each cell K the element tensor AK before adding the entries to\nthe tensor A as in Algorithm 2, one may take advantage of optimized library routines for\nperforming each of the two steps. Note that Algorithm 2 is independent of the algorithm\nused to compute the element tensor.\nAlgorithm 2 A = Assemble(a, {Vhj }rj=1 , {\u03b9K }K\u2208T , T )\nA=0\nfor K \u2208 T\nCompute AK according to (55)\nAdd AK to A according to \u03b9K\nend for\n\nConsidering first the second operation of inserting (adding) the entries of AK into the\nglobal sparse tensor A, this may in principle be accomplished by iterating over all i \u2208 IK\nand adding the entry AK\ni at position \u03b9K (i) of A as illustrated in Figure 4. However, sparse\nmatrix libraries such as PETSc [9, 8, 10] often provide optimized routines for this type of\noperation, which may significantly improve the performance compared to accessing each\nentry of A individually as in Algorithm 1. Even so, the cost of adding AK to A may be\nsubstantial even with an efficient implementation of the sparse data structure for A, see\n[85].\nA similar approach can be taken to the first step of computing the element tensor, that\nis, an optimized library routine is called to compute the element tensor. Because of the\nwide variety of multilinear forms that appear in applications, a separate implementation is\nneeded for any given multilinear form. Therefore, the implementation of this code is often\nleft to the user, as illustrated above in Section 2.2 and Section 2.3, but the code in question\nmay also be automatically generated and optimized for each given multilinear form. We\nshall return to this question below in Section 5 and Section 9.\n\n\fAnders Logg\n\n20\n\n\u03b92K (1)\n\n\u03b92K (2)\n\n\u03b92K (3)\n\n1\n\n2\n\n3\n\n1\n\u03b91K (1)\n\n2\n3\n\n\u03b91K (2)\n\nAK\n32\n\u03b91K (3)\n\nFigure 4. Adding the entries of the element tensor AK to the global tensor A\nusing the local-to-global mapping \u03b9K , illustrated here for a rank two\ntensor (a matrix).\n\n3.6 Summary\nIf we thus view the finite element method as a machine that automates the discretization\nof differential equations, or more precisely, a machine that generates the system of discrete\nequations (31) from a given variational problem (29), an automation of the finite element\nmethod is straightforward up to the point of computing the element tensor for any given\nmultilinear form and the local-to-global mapping for any given discrete function space; if\nthe element tensor AK and the local-to-global mapping \u03b9K can be computed on any given\ncell K, the global tensor A may be computed by Algorithm 2.\nAssuming now that each of the discrete function spaces involved in the definition of\nthe variational problem (29) is generated on some mesh T of the domain \u03a9 from some\nreference finite element (K0 , P0 , N0 ) by a set of local-to-global mappings {\u03b9K }K\u2208T and a\nset of mappings {FK }K\u2208T from the reference cell K0 , as discussed in Section 3.2, we identify\nthe following key steps towards an automation of the finite element method:\n\u2022 the automatic and efficient tabulation of the nodal basis functions on the reference\nfinite element (K0 , P0 , N0 );\n\u2022 the automatic and efficient evaluation of the element tensor AK on each cell K \u2208 T ;\n\u2022 the automatic and efficient assembly of the global tensor A from the set of element\ntensors {AK }K\u2208T and the set of local-to-global mappings {\u03b9K }K\u2208T .\nWe discuss each of these key steps below.\n\n\fAutomating the Finite Element Method\n\n21\n\n4 AUTOMATING THE TABULATION OF BASIS FUNCTIONS\nGiven a reference finite element (K0 , P0 , N0 ), we wish to generate the unique nodal basis\n0\n{\u03a6i }ni=1\nfor P0 satisfying\n\u03bdi0 (\u03a6j ) = \u03b4ij ,\n\ni, j = 1, 2, . . . , n0 .\n\n(56)\n\nIn some simple cases, these nodal basis functions can be worked out analytically by hand or\nfound in the literature, see for example [121, 71]. As a concrete example, consider the nodal\nbasis functions in the case when P0 is the set of quadratic polynomials on the reference\ntriangle K0 with vertices at v 1 = (0, 0), v 2 = (1, 0) and v 3 = (0, 1) as in Figure 5 and nodes\nN0 = {\u03bd10 , \u03bd20 , . . . , \u03bd60 } given by point evaluation at the vertices and edge midpoints. A basis\nfor P0 is then given by\n\u03a61 (X) = (1 \u2212 X1 \u2212 X2 )(1 \u2212 2X1 \u2212 2X2 ),\n\u03a62 (X) = X1 (2X1 \u2212 1),\n\u03a63 (X) = X2 (2X2 \u2212 1),\n\u03a64 (X) = 4X1 X2 ,\n\u03a65 (X) = 4X2 (1 \u2212 X1 \u2212 X2 ),\n\u03a66 (X) = 4X1 (1 \u2212 X1 \u2212 X2 ),\n\n(57)\n\nand it is easy to verify that this is the nodal basis. However, in the general case, it may be\nvery difficult to obtain analytical expressions for the nodal basis functions. Furthermore,\ncopying the often complicated analytical expressions into a computer program is prone to\nerrors and may even result in inefficient code.\nIn recent work, Kirby [83, 82, 84] has proposed a solution to this problem; by expanding\nthe nodal basis functions for P0 as linear combinations of another (non-nodal) basis for P0\nwhich is easy to compute, one may translate operations on the nodal basis functions, such as\nevaluation and differentiation, into linear algebra operations on the expansion coefficients.\nThis new linear algebraic approach to computing and representing finite element basis\nfunctions removes the need for having explicit expressions for the nodal basis functions,\nthus simplifying or enabling the implementation of complicated finite elements.\n4.1 Tabulating Polynomial Spaces\n0\nTo generate the set of nodal basis functions {\u03a6i }ni=1\nfor P0 , we must first identify some\nn0\nother known basis {\u03a8i }i=1 for P0 , referred to in [82] as the prime basis. We return to the\nquestion of how to choose the prime basis below.\nWriting now each \u03a6i as a linear combination of the prime basis functions with \u03b1 \u2208 Rd\u00d7d\nthe matrix of coefficients, we have\n\n\u03a6i =\n\nn0\nX\n\n\u03b1ij \u03a8j ,\n\ni = 1, 2, . . . , n0 .\n\n(58)\n\nj=1\n\nThe conditions (56) thus translate into\n\u03b4ij = \u03bdi0 (\u03a6j ) =\n\nn0\nX\n\n\u03b1jk \u03bdi0 (\u03a8k ),\n\ni, j = 1, 2, . . . , n0 ,\n\n(59)\n\nk=1\n\nor\n\nV\u03b1\u22a4 = I,\n\n(60)\n\n\fAnders Logg\n\n22\n\nX3\nv4\nX2\nv3\n\nv3\n\nX2\n\nv1\nX1\nv1\n\nv2\n\nv2\n\nX1\n\nFigure 5. The reference triangle (left) with vertices at v 1 = (0, 0), v 2 = (1, 0)\nand v 3 = (0, 1), and the reference tetrahedron (right) with vertices at\nv 1 = (0, 0, 0), v 2 = (1, 0, 0), v 3 = (0, 1, 0) and v 4 = (0, 0, 1).\n\nwhere V \u2208 Rn0 \u00d7n0 is the (Vandermonde) matrix with entries Vij = \u03bdi0 (\u03a8j ) and I is the\n0\nn0 \u00d7n0 identity matrix. Thus, the nodal basis {\u03a6i }ni=1\nis easily computed by first computing\nthe matrix V by evaluating the nodes at the prime basis functions and then solving the\nlinear system (60) to obtain the matrix \u03b1 of coefficients.\nIn the simplest case, the space P0 is the set Pq (K0 ) of polynomials of degree \u2264 q on K0 .\nFor typical reference cells, including the reference triangle and the reference tetrahedron\nshown in Figure 5, orthogonal prime bases are available with simple recurrence relations\nfor the evaluation of the basis functions and their derivatives, see for example [33]. If\nP0 = Pq (K0 ), it is thus straightforward to evaluate the prime basis and thus to generate\nand solve the linear system (60) that determines the nodal basis.\n4.2 Tabulating Spaces with Constraints\nIn other cases, the space P0 may be defined as some subspace of Pq (K0 ), typically by\nconstraining certain derivatives of the functions in P0 or the functions themselves to lie\nin Pq\u2032 (K0 ) for some q \u2032 < q on some part of K0 . Examples include the the Raviart\u2013\nThomas [111], Brezzi\u2013Douglas\u2013Fortin\u2013Marini [23] and Arnold\u2013Winther [4] elements, which\nput constraints on the derivatives of the functions in P0 .\nAnother more obvious example, taken from [82], is the case when the functions in P0\nare constrained to Pq\u22121 (\u03b30 ) on some part \u03b30 of the boundary of K0 but are otherwise in\nPq (K0 ), which may be used to construct the function space on a p-refined cell K if the\nfunction space on a neighboring cell K \u2032 with common boundary \u03b30 is only Pq\u22121 (K \u2032 ). We\nmay then define the space P0 by\nP0 = {v \u2208 Pq (K0 ) : v|\u03b30 \u2208 Pq\u22121 (\u03b30 )} = {v \u2208 Pq (K0 ) : l(v) = 0},\n\n(61)\n\n\fAutomating the Finite Element Method\n\n23\n\nwhere the linear functional l is given by integration against the qth degree Legendre polynomial along the boundary \u03b30 .\nc\nIn general, one may define a set {li }ni=1\nof linear functionals (constraints) and define P0\nas the intersection of the null spaces of these linear functionals on Pq (K0 ),\nP0 = {v \u2208 Pq (K0 ) : li (v) = 0,\n\ni = 1, 2, . . . , nc }.\n\n(62)\n\n0\nTo find a prime basis {\u03a8i }ni=1\nfor P0 , we note that any function in P0 may be expressed as\n|Pq (K0 )|\na linear combination of some basis functions {\u03a8\u0304i }i=1\nfor Pq (K0 ), which we may take as\nP|Pq (K0 )|\n\u03b2i \u03a8\u0304i , then\nthe orthogonal basis discussed above. We find that if \u03a8 = i=1\n\n|Pq (K0 )|\n\n0 = li (\u03a8) =\n\nX\n\n\u03b2j li (\u03a8\u0304j ),\n\ni = 1, 2, . . . , nc ,\n\n(63)\n\nj=1\n\nor\nL\u03b2 = 0,\n\n(64)\n\nwhere L is the nc \u00d7 |Pq (K0 )| matrix with entries\nLij = li (\u03a8\u0304j ),\n\ni = 1, 2, . . . , nc ,\n\nj = 1, 2, . . . , |Pq (K0 )|.\n\n(65)\n\nA prime basis for P0 may thus be found by computing the nullspace of the matrix L, for\nexample by computing its singular value decomposition (see [58]). Having thus found the\n0\nprime basis {\u03a8i }ni=1\n, we may proceed to compute the nodal basis as before.\n5 AUTOMATING THE COMPUTATION OF THE ELEMENT TENSOR\nAs we saw in Section 3.5, given a multilinear form a defined on the product space Vh1 \u00d7\nVh2 \u00d7 . . . \u00d7 Vhr , we need to compute for each cell K \u2208 T the rank r element tensor AK given\nby\nK,1 K,2\nK,r\n(66)\nAK\ni = aK (\u03c6i1 , \u03c6i2 , . . . , \u03c6ir ) \u2200i \u2208 IK ,\nwhere aK is the local contribution to the multilinear form a from the cell K.\nWe investigate below two very different ways to compute the element tensor, first a\nmodification of the standard approach based on quadrature and then a novel approach\nbased on a special tensor contraction representation of the element tensor, yielding speedups\nof several orders of magnitude in some cases.\n5.1 Evaluation by Quadrature\nThe element tensor AK is typically evaluated by quadrature on the cell K. Many finite\nelement libraries like Diffpack [24, 92] and deal.II [12, 13, 11] provide the values of relevant\nquantities like basis functions and their derivatives at the quadrature points on K by\nmapping precomputed values of the corresponding basis functions on the reference cell\nK0 using the mapping FK : K0 \u2192 K.\nThus, to evaluate the element tensor AK for Poisson's equation by quadrature on K,\none computes\nAK\ni\n\n=\n\nZ\n\nK\n\n\u2207\u03c6K,1\ni1\n\n* \u2207\u03c6K,2\ni2 dx\n\n\u2248\n\nNq\nX\nk=1\n\nK,2 k\n\u2032\nk\nk\nwk \u2207\u03c6K,1\ni1 (x ) * \u2207\u03c6i2 (x ) det FK (x ),\n\n(67)\n\n\fAnders Logg\n\n24\n\nN\n\nq\n\u2282 K with corresponding quadrature\nfor some suitable set of quadrature points {xi }i=1\nP Nq\nNq\nweights {wi }i=1 , where we assume that the quadrature weights are scaled so that i=1\nwi =\n|K0 |. Note that the approximation (67) can be made exact for a suitable choice of quadrature points if the basis functions are polynomials.\nComparing (67) to the example codes in Table 3 and Table 4, we note the similarities\nbetween (67) and the two codes. In both cases, the gradients of the basis functions as well\n\u2032 are precomputed at the\nas the products of quadrature weight and the determinant of FK\nset of quadrature points and then combined to produce the integral (67).\nIf we assume that the two discrete spaces Vh1 and Vh2 are equal, so that the local basis\n\nn1\n\nn2\n\nK,2 K\nn0\nK\nfunctions {\u03c6K,1\ni }i=1 and {\u03c6i }i=1 are all generated from the same basis {\u03a6i }i=1 on the\nreference cell K0 , the work involved in precomputing the gradients of the basis functions at\nthe set of quadrature points amounts to computing for each quadrature point xk and each\nK\n\u2032 \u2212\u22a4 (x )\u2207 \u03a6 (X ), that is,\nbasis function \u03c6K\nX i\nk\nk\ni the matrix\u2013vector product \u2207x \u03c6i (xk ) = (FK )\nd\n\nX \u2202Xl\n\u2202\u03c6K\n\u2202\u03a6K\ni\n(xk ) =\n(xk ) i (X k ),\n\u2202xj\n\u2202xj\n\u2202Xl\n\n(68)\n\nl=1\n\nn ,N\n\nq\n0\n\u22121\nwhere xk = FK (X k ) and \u03c6K\ni = \u03a6i \u25e6FK . Note that the the gradients {\u2207X \u03a6i (Xk )}i=1,k=1 of\nthe reference element basis functions at the set of quadrature points on the reference element\nremain constant throughout the assembly process and may be pretabulated and stored.\nThus, the gradients of the basis functions on K may be computed in Nq n0 d2 multiply\u2013\nadd pairs (MAPs) and the total work to compute the element tensor AK is Nq n0 d2 +\nNq n20 (d + 2) \u223c Nq n20 d, if we ignore that we also need to compute the mapping FK , and the\n\u2032 . In Section 5.2 and Section 7 below, we will see that this\ndeterminant and inverse of FK\noperation count may be significantly reduced.\n\n5.2 Evaluation by Tensor Representation\nIt has long been known that it is sometimes possible to speed up the computation of the\nelement tensor by precomputing certain integrals on the reference element. Thus, for any\nspecific multilinear form, it may be possible to find quantities that can be precomputed in\norder to optimize the code for the evaluation of the element tensor. These ideas were first\nintroduced in a general setting in [85, 86] and later formalized and automated in [87, 88].\nA similar approach was implemented in early versions of DOLFIN [62, 68, 63], but only for\npiecewise linear elements.\nWe first consider the case when the mapping FK from the reference cell is affine, and then\ndiscuss possible extensions to non-affine mappings such as when FK is the isoparametric\nmapping. As a first example, we consider again the computation of the element tensor AK\nfor Poisson's equation. As before, we have\nAK\ni =\n\nZ\n\nK\n\nK,2\n\u2207\u03c6K,1\ni1 * \u2207\u03c6i2 dx =\n\nZ X\nd\n\u2202\u03c6K,1\n\u2202\u03c6K,2\ni\ni\n1\n\nK \u03b2=1\n\n\u2202x\u03b2\n\n2\n\n\u2202x\u03b2\n\ndx,\n\n(69)\n\nbut instead of evaluating the gradients on K and then proceeding to evaluate the integral\nby quadrature, we make a change of variables to write\nAK\ni =\n\nZ\n\nd\nd\nd X\nX\n\u2202X\u03b11 \u2202\u03a61i1 X \u2202X\u03b12 \u2202\u03a62i2\n\u2032\ndet FK\ndX,\n\u2202x\n\u2202X\n\u2202x\n\u2202X\n\u03b11\n\u03b12\n\u03b2\n\u03b2\nK0\n\u03b2=1 \u03b11 =1\n\n\u03b12 =1\n\n(70)\n\n\fAutomating the Finite Element Method\n\n25\n\nand thus, if the mapping FK is affine so that the transforms \u2202X/\u2202x and the determi\u2032 are constant, we obtain\nnant det FK\nAK\ni\n\n=\n\n\u2032\ndet FK\n\nZ\nd\nd X\nd\nd\nd\nX\nX\nX\nX\n\u2202\u03a61i1 \u2202\u03a62i2\n\u2202X\u03b11 \u2202X\u03b12\nA0i\u03b1 G\u03b1K ,\ndX =\n\u2202x\u03b2 \u2202x\u03b2 K0 \u2202X\u03b11 \u2202X\u03b12\n\n\u03b11 =1 \u03b12 =1 \u03b2=1\n\nor\n\n(71)\n\n\u03b11 =1 \u03b12 =1\n\nAK = A0 : GK ,\n\n(72)\n\nwhere\nA0i\u03b1 =\nG\u03b1K\n\n=\n\nZ\n\nK0\n\n\u2202\u03a61i1 \u2202\u03a62i2\ndX,\n\u2202X\u03b11 \u2202X\u03b12\n\n\u2032\ndet FK\n\nd\nX\n\u2202X\u03b11 \u2202X\u03b12\n.\n\u2202x\u03b2 \u2202x\u03b2\n\n(73)\n\n\u03b2=1\n\nWe refer to the tensor A0 as the reference tensor and to the tensor GK as the geometry\ntensor.\nNow, since the reference tensor is constant and does not depend on the cell K, it may\nbe precomputed before the assembly of the global tensor A. For the current example, the\nwork on each cell K thus involves first computing the rank two geometry tensor GK , which\nmay be done in d3 multiply\u2013add pairs, and then computing the rank two element tensor AK\nas the tensor contraction (72), which may be done in n20 d2 multiply\u2013add pairs. Thus, the\ntotal operation count is d3 + n20 d2 \u223c n20 d2 , which should be compared to Nq n20 d for the\nstandard quadrature-based approach. The speedup in this particular case is thus roughly\na factor Nq /d, which may be a significant speedup, in particular for higher order elements.\nAs we shall see, the tensor representation (72) generalizes to other multilinear forms as\nwell. To see this, we need to make some assumptions about the structure of the multilinear\nform (44). We shall assume that the multilinear form a is expressed as an integral over \u03a9 of\na weighted sum of products of basis functions or derivatives of basis functions. In particular,\nwe shall assume that the element tensor AK can be expressed as a sum, where each term\ntakes the following canonical form,\nm\nXZ Y\n\u03b4 (\u03b3)\ncj (\u03b3)Dxj \u03c6K,j\n(74)\nAK\n=\ni\n\u03b9j (i,\u03b3) [\u03baj (\u03b3)] dx,\n\u03b3\u2208C\n\nK j=1\n\nwhere C is some given set of multiindices, each coefficient cj maps the multiindex \u03b3 to a\nreal number, \u03b9j maps (i, \u03b3) to a basis function index, \u03baj maps \u03b3 to a component index\n(for vector or tensor valued basis functions) and \u03b4j maps \u03b3 to a derivative multiindex.\nTo distinguish component indices from indices for basis functions, we use [*] to denote a\ncomponent index and subscript to denote a basis function index. In the simplest case, the\nnumber of factors m is equal to the arity r of the multilinear form (rank of the tensor),\nbut in general, the canonical form (74) may contain factors that correspond to additional\nfunctions which are not arguments of the multilinear form. This is the case for the weighted\nPoisson's equation (47), where m = 3 and r = 2. In general, we thus have m > r.\nAs an illustration of this notation, we consider again the bilinear form for Poisson's\nequation and write it in the notation of (74). We will also consider a more involved example\nto illustrate the generality of the notation. From (69), we have\nZ X\nK,2\nK,2\nd\nd Z\nX\n\u2202\u03c6K,1\n\u2202\u03c6K,1\ni1 \u2202\u03c6i2\ni1 \u2202\u03c6i2\nAK\n=\ndx\n=\ndx,\n(75)\ni\n\u2202x\u03b3\n\u2202x\n\u2202x\n\u03b3\n\u03b3\nK \u03b3=1 \u2202x\u03b3\nK\n\u03b3=1\n\n\fAnders Logg\n\n26\n\nand thus, in the notation of (74),\nm = 2,\nC = [1, d],\nc(\u03b3) = (1, 1),\n\u03b9(i, \u03b3) = (i1 , i2 ),\n\u03ba(\u03b3) = (\u2205, \u2205),\n\u03b4(\u03b3) = (\u03b3, \u03b3),\n\n(76)\n\nwhere \u2205 denotes an empty component index (the basis functions are scalar).\nAs another example, we consider the bilinear form for a stabilization term appearing in\na least-squares stabilized cG(1)cG(1) method for the incompressible Navier\u2013Stokes equations [40, 65, 64, 66],\na(v, U ) =\n\nZ\n\n(w * \u2207v) * (w * \u2207U ) dx =\n\nZ\n\nd\nX\n\n\u03a9 \u03b3 ,\u03b3 ,\u03b3 =1\n1 2 3\n\n\u03a9\n\nw[\u03b32 ]\n\n\u2202v[\u03b31 ]\n\u2202U [\u03b31 ]\nw[\u03b33 ]\ndx,\n\u2202x\u03b32\n\u2202x\u03b33\n\n(77)\n\nwhere w \u2208 Vh3 = Vh4 is a given approximation of the velocity, typically obtained from the\nprevious iteration in an iterative method for the nonlinear Navier\u2013Stokes equations. To\nwrite the element tensor for (77) in the canonical form (74), we expand w in the nodal\n3 = P 4 and note that\nbasis for PK\nK\nAK\ni\n\n=\n\nd\nX\n\nn3K n4K Z\nX\nX\n\n\u03b31 ,\u03b32 ,\u03b33 =1 \u03b34 =1 \u03b35 =1 K\n\nK,2\n\u2202\u03c6K,1\ni1 [\u03b31 ] \u2202\u03c6i2 [\u03b31 ] K K,3\nw\u03b34 \u03c6\u03b34 [\u03b32 ]w\u03b3K5 \u03c6K,4\n\u03b35 [\u03b33 ] dx,\n\u2202x\u03b32\n\u2202x\u03b33\n\n(78)\n\nWe may then write the element tensor AK for the bilinear form (77) in the canonical\nform (74), with\nm = 4,\nC = [1, d]3 \u00d7 [1, n3K ] \u00d7 [1, n4K ],\nc(\u03b3) = (1, 1, w\u03b3K4 , w\u03b3K5 ),\n\u03b9(i, \u03b3) = (i1 , i2 , \u03b34 , \u03b35 ),\n\u03ba(\u03b3) = (\u03b31 , \u03b31 , \u03b32 , \u03b33 ),\n\u03b4(\u03b3) = (\u03b32 , \u03b33 , \u2205, \u2205),\n\n(79)\n\nwhere \u2205 denotes an empty derivative multiindex (no differentiation).\nIn [88], it is proved that any element tensor AK that can be expressed in the general\ncanonical form (74), can be represented as a tensor contraction AK = A0 : GK of a reference\ntensor A0 independent of K and a geometry tensor GK . A similar result is also presented\nin [87] but in less formal notation. As noted above, element tensors that can be expressed\nin the general canonical form correspond to multilinear forms that can be expressed as\nintegrals over \u03a9 of linear combinations of products of basis functions and their derivatives.\nThe representation theorem reads as follows.\n\n\fAutomating the Finite Element Method\n\n27\n\nTheorem 1 (Representation theorem) If FK is a given affine mapping from a referj m\nence cell K0 to a cell K and {PK\n}j=1 is a given set of discrete function spaces on K,\neach generated by a discrete function space P0j on the reference cell K0 through the affine\nj\nmapping, that is, for each \u03c6 \u2208 PK\nthere is some \u03a6 \u2208 P0j such that \u03a6 = \u03c6 \u25e6 FK , then the\nelement tensor (74) may be represented as the tensor contraction of a reference tensor A0\nand a geometry tensor GK ,\nAK = A0 : GK ,\n(80)\nthat is,\nAK\ni =\n\nX\n\nA0i\u03b1 G\u03b1K\n\n\u2200i \u2208 IK ,\n\n(81)\n\n\u03b1\u2208A\n\nwhere the reference tensor A0 is independent of K. In particular, the reference tensor A0\nis given by\nm\nXZ Y\n\u03b4\u2032 (\u03b1,\u03b2) j\n(82)\n\u03a6\u03b9j (i,\u03b1,\u03b2) [\u03baj (\u03b1, \u03b2)] dX,\nDXj\nA0i\u03b1 =\n\u03b2\u2208B\n\nK0 j=1\n\nand the geometry tensor GK is the outer product of the coefficients of any weight functions\n\u2032 ,\nwith a tensor that depends only on the Jacobian FK\nG\u03b1K\n\n=\n\nm\nY\n\ncj (\u03b1)\n\n\u2032\ndet FK\n\nm\nX Y\n\n\u03b2\u2208B\u2032\n\nj=1\n\nj \u2032 =1\n\n|\u03b4j \u2032 (\u03b1,\u03b2)|\n\nY\n\nk=1\n\n\u2202X\u03b4\u2032 \u2032\n\nj k\n\n(\u03b1,\u03b2)\n\n\u2202x\u03b4j\u2032 k (\u03b1,\u03b2)\n\n,\n\n(83)\n\nfor some appropriate index sets A, B and B \u2032 . We refer to the index set IK as the set of\nprimary indices, the index set A as the set of secondary indices, and to the index sets B\nand B \u2032 as sets of auxiliary indices.\nThe ranks of the tensors A0 and GK are determined by the properties of the multilinear\nform a, such as the number of coefficients and derivatives. Since the rank of the element\ntensor AK is equal to the arity r of the multilinear form a, the rank of the reference tensor A0\nmust be |i\u03b1| = r + |\u03b1|, where |\u03b1| is the rank of the geometry tensor. For the examples\npresented above, we have |i\u03b1| = 4 and |\u03b1| = 2 in the case of Poisson's equation and |i\u03b1| = 8\nand |\u03b1| = 6 for the Navier\u2013Stokes stabilization term.\nThe proof of Theorem 1 is constructive and gives an algorithm for computing the representation (80). A number of concrete examples with explicit formulas for the reference\nand geometry tensors are given in Tables 10\u201313. We return to these test cases below in\nSection 9.2, when we discuss the implementation of Theorem 1 in the form compiler FFC\nand present benchmark results for the test cases.\nWe remark that in general, a multilinear form will correspond to a sum of tensor contractions, rather than a single tensor contraction as in (80), that is,\nAK =\n\nX\n\nA0,k : GK,k .\n\n(84)\n\nk\n\nOne such example is the computation of the element tensor for the convection\u2013reaction\nproblem \u2212\u2206u + u = f , which may be computed as the sum of a tensor contraction of\na rank four reference tensor A0,1 with a rank two geometry tensor GK,1 and a rank two\nreference tensor A0,2 with a rank zero geometry tensor GK,2 .\n\n\fAnders Logg\n\n28\n\na(v, U )\n\n=\n\nA0i\u03b1\n\n=\n\nG\u03b1K\n\n=\n\nR\n\nR\n\n\u03a9\n\nv U dx\n\nK0\n\nrank\n\n\u03a61i1 \u03a62i2 dX\n\n\u2032\ndet FK\n\n|i\u03b1| = 2\n|\u03b1| = 0\n\nTable 10. The tensor contraction representation AK = A0 : GK of the element\ntensor AK for the bilinear form associated with a mass matrix (test\ncase 1).\n\na(v, U )\n\n=\n\nA0i\u03b1\n\n=\n\nG\u03b1K\n\n=\n\nR\n\nR\n\n\u03a9 \u2207v\n\n* \u2207U dx\n\n\u2202\u03a61i \u2202\u03a62i\n2\n1\nK0 \u2202X\u03b11 \u2202X\u03b12\n\n\u2032\ndet FK\n\nrank\ndX\n\n|i\u03b1| = 4\n\n\u2202X\u03b11 \u2202X\u03b12\n\u03b2=1 \u2202x\u03b2 \u2202x\u03b2\n\n|\u03b1| = 2\n\nPd\n\nTable 11. The tensor contraction representation AK = A0 : GK of the element\ntensor AK for the bilinear form associated with Poisson's equation (test\ncase 2).\n\na(v, U )\n\n=\n\nA0i\u03b1\n\n=\n\nG\u03b1K\n\n=\n\nR\n\n\u03a9v\n\nPd\n\n* (w * \u2207)U dx\nR\n\n\u03b2=1 K0\n\n\u03a61i1 [\u03b2]\n\n\u2032\nw\u03b1K1 det FK\n\n\u2202X\u03b13\n\u2202x\u03b12\n\n\u2202\u03a62i [\u03b2] 3\n2\n\u2202X\u03b13 \u03a6\u03b11 [\u03b12 ] dX\n\nrank\n|i\u03b1| = 5\n|\u03b1| = 3\n\nTable 12. The tensor contraction representation AK = A0 : GK of the element\ntensor AK for the bilinear form associated with a linearization of the\nnonlinear term u * \u2207u in the incompressible Navier\u2013Stokes equations\n(test case 3).\n\n\fAutomating the Finite Element Method\n\na(v, U )\n\n=\n\nA0i\u03b1\n\n=\n\nG\u03b1K\n\n=\n\n29\n\nR\n\n\u03a9\n\n\u01eb(v) : \u01eb(U ) dx\nR \u2202\u03a61i1 [\u03b2] \u2202\u03a62i2 [\u03b2]\n\u03b2=1 K0 \u2202X\u03b11 \u2202X\u03b12\n\nPd\n1\n2\n\nrank\n\n\u2032\ndet FK\n\ndX\n\n\u2202X\u03b11 \u2202X\u03b12\n\u03b2=1 \u2202x\u03b2 \u2202x\u03b2\n\nPd\n\n|i\u03b1| = 4\n|\u03b1| = 2\n\nTable 13. The tensor contraction representation AK = A0 : GK of the element\nR\nR\ntensor AK for the bilinear form \u03a9 \u01eb(v) : \u01eb(U ) dx = \u03a9 41 (\u2207v + (\u2207v)\u22a4 ) :\n(\u2207U + (\u2207U )\u22a4 ) dx associated with the strain-strain term of linear elasticity (test case 4). Note that the product expands into four terms\nwhich can be grouped in pairs of two. The representation is given only\nfor the first of these two terms.\n\n5.3 Extension to Non-Affine Mappings\nThe tensor contraction representation (80) of Theorem 1 assumes that the mapping FK\nfrom the reference cell is affine, allowing the transforms \u2202X/\u2202x and the determinant to be\npulled out of the integral. To see how to extend this result to the case when the mapping FK\nis non-affine, such as in the case of an isoparametric mapping for a higher-order element\nused to map the reference cell to a curvilinear cell on the boundary of \u03a9, we consider again\nthe computation of the element tensor AK for Poisson's equation. As in Section 5.1, we\nuse quadrature to evaluate the integral, but take advantage of the fact that the discrete\n1 and P 2 on K may be generated from a pair of reference finite elements\nfunction spaces PK\nK\nas discussed in Section 3.2. We have\nZ X\nZ\nK,2\nd\n\u2202\u03c6K,1\ni1 \u2202\u03c6i2\nK,1\nK,2\nK\ndx\n\u2207\u03c6i1 * \u2207\u03c6i2 dx =\nAi =\n\u2202x\u03b2 \u2202x\u03b2\nK\nK\n\u03b2=1\n\n=\n\nd\nX\n\nd\nX\n\nd\nX\n\n\u03b11 =1 \u03b12 =1 \u03b2=1\n\n\u2248\n\nNq\nd\nd\nX\nX\nX\n\n\u03b11 =1 \u03b12 =1 \u03b13 =1\n\nZ\n\nK0\n\nw\u03b13\n\n\u2202X\u03b11 \u2202X\u03b12 \u2202\u03a61i1 \u2202\u03a62i2\n\u2032\ndet FK\ndX\n\u2202x\u03b2 \u2202x\u03b2 \u2202X\u03b11 \u2202X\u03b12\nd\nX\n\u2202\u03a61i1\n\u2202\u03a62i2\n\u2202X\u03b11\n\u2202X\u03b12\n\u2032\n(X\u03b13 )\n(X\u03b13 ) det FK\n(X\u03b13 ).\n(X\u03b13 )\n(X\u03b13 )\n\u2202X\u03b11\n\u2202X\u03b12\n\u2202x\u03b2\n\u2202x\u03b2\n\u03b2=1\n\n(85)\n\nAs before, we thus obtain a representation of the form\nAK = A0 : GK ,\n\n(86)\n\nwhere the reference tensor A0 is now given by\nA0i\u03b1 = w\u03b13\n\n\u2202\u03a61i1\n\u2202\u03a62i2\n(X\u03b13 )\n(X\u03b13 ),\n\u2202X\u03b11\n\u2202X\u03b12\n\n(87)\n\nand the geometry tensor GK is given by\n\u2032\nG\u03b1K = det FK\n(X\u03b13 )\n\nd\nX\n\u2202X\u03b1\n\n1\n\n\u03b2=1\n\n\u2202x\u03b2\n\n(X\u03b13 )\n\n\u2202X\u03b12\n(X\u03b13 ).\n\u2202x\u03b2\n\n(88)\n\n\f30\n\nAnders Logg\n\nWe thus note that a (different) tensor contraction representation of the element tensor AK\nis possible even if the mapping FK is non-affine. One may also prove a representation\ntheorem similar to Theorem 1 for non-affine mappings.\nComparing the representation (87)\u2013(88) with the affine representation (73), we note\nthat the ranks of both A0 and GK have increased by one. As before, we may precompute\nthe reference tensor A0 but the number of multiply\u2013add pairs to compute the element\ntensor AK increase by a factor Nq from n20 d2 to Nq n20 d2 (if again we ignore the cost of\ncomputing the geometry tensor).\nWe also note that the cost has increased by a factor d compared to the cost of a\ndirect application of quadrature as described in Section 5.1. However, by expressing the\nelement tensor AK as a tensor contraction, the evaluation of the element tensor is more\nreadily optimized than if expressed as a triply nested loop over quadrature points and basis\nfunctions as in Table 3 and Table 4.\nAs demonstrated below in Section 7, it may in some cases be possible to take advantage\nof special structures such as dependencies between different entries in the tensor A0 to\nsignificantly reduce the operation count. Another more straightforward approach is to use\nan optimized library routine such as a BLAS call to compute the tensor contraction as we\nshall see below in Section 7.1.\n5.4 A Language for Multilinear Forms\nTo automate the process of evaluating the element tensor AK , we must create a system that\ntakes as input a multilinear form a and automatically computes the corresponding element\ntensor AK . We do this by defining a language for multilinear forms and automatically\ntranslating any given string in the language to the canonical form (74). From the canonical\nform, we may then compute the element tensor AK by the tensor contraction AK = A0 : GK .\nWhen designing such a language for multilinear forms, we have two things in mind.\nFirst, the multilinear forms specified in the language should be \"close\" to the corresponding\nmathematical notation (taking into consideration the obvious limitations of specifying the\nform as a string in the ASCII character set). Second, it should be straightforward to\ntranslate a multilinear form specified in the language to the canonical form (74).\nA language may be specified formally by defining a formal grammar that generates the\nlanguage. The grammar specifies a set of rewrite rules and all strings in the language can be\ngenerated by repeatedly applying the rewrite rules. Thus, one may specify a language for\nmultilinear forms by defining a suitable grammar (such as a standard EBNF grammar [75]),\nwith basis functions and multiindices as the terminal symbols. One could then use an\nautomating tool (a compiler-compiler) to create a compiler for multilinear forms.\nHowever, since a closed canonical form is available for the set of possible multilinear\nforms, we will take a more explicit approach. We fix a small set of operations, allowing only\nmultilinear forms that have a corresponding canonical form (74) to be expressed through\nthese operations, and observe how the canonical form transforms under these operations.\n5.4.1 An algebra for multilinear forms\nj m\nConsider the set of local finite element spaces {PK\n}j=1 on a cell K corresponding to a\nnj ,m\n\nK,j K\nset of global finite element spaces {Vhj }m\nj=1 . The set of local basis functions {\u03c6i }i,j=1\nspan a vector space P K and each function v in this vector space may be expressed as a\nlinear combination of the basis functions, that is, the set of functions P K may be generated\nfrom the basis functions through addition v + w and multiplication with scalars \u03b1v. Since\nv \u2212 w = v + (\u22121)w and v/\u03b1 = (1/\u03b1)v, we can also easily equip the vector space with\n\n\fAutomating the Finite Element Method\n\n31\n\nsubtraction and division by scalars. Informally, we may thus write\no\nn\nX\nPK = v : v =\nc(*) \u03c6K\n(*) .\n\n(89)\n\nWe next equip our vector space P K with multiplication between elements of the vector\nspace. We thus obtain an algebra (a vector space with multiplication) of linear combinations\nof products of basis functions. Finally, we extend our algebra P K by differentiation \u2202/\u2202xi\nwith respect to the coordinate directions on K, to obtain\n(\n)\nY \u2202 |(*)| \u03c6K\nX\n(*)\nPK = v : v =\nc(*)\n,\n(90)\n\u2202x(*)\nwhere (*) represents some multiindex.\nTo summarize, P K is the algebra of linear combinations of products of basis functions\nor derivatives of basis functions that is generated from the set of basis functions through\naddition (+), subtraction (\u2212), multiplication (*), including multiplication with scalars, division by scalars (/), and differentiation \u2202/\u2202xi . We note that the algebra is closed under\nthese operations, that is, applying any of the operators to an element v \u2208 P K or a pair of\nelements v, w \u2208 P K yields a member of P K .\nIf the basis functions are vector-valued (or tensor-valued), the algebra is instead generated from the set of scalar components of the basis functions. Furthermore, we may\nintroduce linear algebra operators, such as inner products and matrix\u2013vector products, and\ndifferential operators, such as the gradient, the divergence and rotation, by expressing these\ncompound operators in terms of the basic operators (addition, subtraction, multiplication\nand differentiation).\nWe now note that the algebra P K corresponds precisely to the canonical form (74) in\nthat the element tensor AK for any multilinear form on K that can be expressed as an\nintegral over K of an element v \u2208 P K has an immediate representation as a sum of element\ntensors of the canonical form (74). We demonstrate this below.\n5.4.2 Examples\n\nAs an example, consider the bilinear form\na(v, U ) =\n\nZ\n\nv U dx,\n\n(91)\n\n\u03a9\n\nwith corresponding element tensor canonical form\nZ\nK,2\nK\n\u03c6K,1\nAi =\ni1 \u03c6i2 dx.\n\n(92)\n\nK\n\nK,2\nIf we now let v = \u03c6K,1\ni1 \u2208 P K and U = \u03c6i2 \u2208 P K , we note that v U \u2208 P K and we may\nthus express the element tensor as an integral over K of an element in P K ,\nZ\nv U dx,\n(93)\nAK\n=\ni\nK\n\nwhich is close to the notation of (91). As another example, consider the bilinear form\nZ\n\u2207v * \u2207U + v U dx,\n(94)\na(v, U ) =\n\u03a9\n\n\fAnders Logg\n\n32\n\nwith corresponding element tensor canonical form3\nAK\ni =\n\nd Z\nX\n\u03b3=1\n\nK\n\nK,2\n\u2202\u03c6K,1\ni1 \u2202\u03c6i2\ndx +\n\u2202x\u03b3 \u2202x\u03b3\n\nZ\n\nK\n\nK,2\n\u03c6K,1\ni1 \u03c6i2 dx.\n\n(95)\n\nK,2\nAs before, we let v = \u03c6K,1\ni1 \u2208 P K and U = \u03c6i2 \u2208 P K and note that \u2207v * \u2207U + v U \u2208 P K .\nIt thus follows that the element tensor AK for the bilinear form (94) may be expressed as\nan integral over K of an element in P K ,\nZ\nK\n\u2207v * \u2207U + v U dx,\n(96)\nAi =\nK\n\nwhich is close to the notation of (94). Thus, by a suitable definition of v and U as local\nbasis functions on K, the canonical form (74) for the element tensor of a given multilinear\nform may be expressed in a notation that is close to the notation for the multilinear form\nitself.\n5.4.3 Implementation by operator-overloading\n\nIt is now straightforward to implement the algebra P K in any object-oriented language\nwith support for operator overloading, such as Python or C++. We first implement a class\nBasisFunction, representing (derivatives of) basis functions of some given finite element\nspace. Each BasisFunction is associated with a particular finite element space and different\nBasisFunctions may be associated with different finite element spaces. Products of scalars\nand (derivatives of) basis functions are represented by the class Product, which may be\nimplemented as a list of BasisFunctions. Sums of such products are represented by the\nclass Sum, which may be implemented as a list of Products. We then define an operator\nfor differentiation of basis functions and overload the operators addition, subtraction and\nmultiplication, to generate the algebra of BasisFunctions, Products and Sums, and note\nthat any combination of such operators and objects ultimately yields an object of class Sum.\nIn particular, any object of class BasisFunction or Product may be cast to an object of\nclass Sum.\nBy associating with each object one or more indices, implemented by a class Index,\nan object of class Product automatically represents a tensor expressed in the canonical\nform (74). Finally, we note that we may introduce compound operators such as grad, div,\nrot, dot etc. by expressing these operators in terms of the basic operators.\nThus, if v and U are objects of class BasisFunction, the integrand of the bilinear\nform (94) may be given as the string\ndot(grad(v), grad(U)) + v*U.\n\n(97)\n\nIn Table 5 we saw a similar example of how the bilinear form for Poisson's equation is\nspecified in the language of the FEniCS Form Compiler FFC. Further examples will be\ngiven below in Section 9.2 and Section 10.\n6 AUTOMATING THE ASSEMBLY OF THE DISCRETE SYSTEM\nIn Section 3, we reduced the task of automatically generating the discrete system F (U ) = 0\nfor a given nonlinear variational problem a(U ; v) = L(v) to the automatic assembly of the\n3\n\nTo be precise, the element tensor is the sum of two element tensors, each written in the canonical\nform (74) with a suitable definition of multiindices \u03b9, \u03ba and \u03b4.\n\n\fAutomating the Finite Element Method\n\n33\n\ntensor A that represents a given multilinear form a in a given finite element basis. By\nAlgorithm 2, this process may be automated by automating first the computation of the\nelement tensor AK , which we discussed in the previous section, and then automating the\naddition of the element tensor AK into the global tensor A, which is the topic of the current\nsection.\n6.1 Implementing the Local-to-Global Mapping\nWith {\u03b9jK }rj=1 the local-to-global mappings for a set of discrete function spaces, {Vhj }rj=1 ,\nwe evaluate for each j the local-to-global mapping \u03b9jK on the set of local node numbers\n{1, 2, . . . , njK }, thus obtaining for each j a tuple\n\u03b9jK ([1, njK ]) = (\u03b9jK (1), \u03b9jK (2), . . . , \u03b9jK (njK )).\n\n(98)\n\nThe entries of the element tensor AK may then be added to the global tensor A by an\noptimized low-level library call4 that takes as input the two tensors A and AK and the set\nof tuples (arrays) that determine how each dimension of AK should be distributed onto the\nglobal tensor A. Compare Figure 4 with the two tuples given by (\u03b91K (1), \u03b91K (2), \u03b91K (3)) and\n(\u03b92K (1), \u03b92K (2), \u03b92K (3)) respectively.\nNow, to compute the set of tuples {\u03b9jK ([1, njK ])}rj=1 , we may consider implementing for\neach j a function that takes as input the current cell K and returns the corresponding tuple\n\u03b9jK ([1, nK ]). Since the local-to-global mapping may look very different for different function\nspaces, in particular for different degree Lagrange elements, a different implementation is\nneeded for each different function space. Another option is to implement a general purpose\nfunction that handles a range of function spaces, but this quickly becomes inefficient. From\nthe example implementations given in Table 14 and Table 15 for continuous linear and\nquadratic Lagrange finite elements on tetrahedra, it is further clear that if the local-to-global\nmappings are implemented individually for each different function space, the mappings can\nbe implemented very efficiently, with minimal need for arithmetic or branching.\nvoid nodemap(int nodes[], const Cell& cell, const Mesh& mesh)\n{\nnodes[0] = cell.vertexID(0);\nnodes[1] = cell.vertexID(1);\nnodes[2] = cell.vertexID(2);\nnodes[3] = cell.vertexID(3);\n}\n\nTable 14. A C++ implementation of the mapping from local to global node numbers for continuous linear Lagrange finite elements on tetrahedra. One\nnode is associated with each vertex of a local cell and the local node\nnumber for each of the four nodes is mapped to the global number of\nthe associated vertex.\n\n4\n\nIf PETSc [9, 8, 10] is used as the linear algebra backend, such a library call is available with the call\nVecSetValues() for a rank one tensor (a vector) and MatSetValues() for a rank two tensor (a matrix).\n\n\fAnders Logg\n\n34\n\nvoid nodemap(int nodes[], const Cell& cell, const Mesh& mesh)\n{\nnodes[0] = cell.vertexID(0);\nnodes[1] = cell.vertexID(1);\nnodes[2] = cell.vertexID(2);\nnodes[3] = cell.vertexID(3);\nint offset = mesh.numVertices();\nnodes[4] = offset + cell.edgeID(0);\nnodes[5] = offset + cell.edgeID(1);\nnodes[6] = offset + cell.edgeID(2);\nnodes[7] = offset + cell.edgeID(3);\nnodes[8] = offset + cell.edgeID(4);\nnodes[9] = offset + cell.edgeID(5);\n}\n\nTable 15. A C++ implementation of the mapping from local to global node numbers for continuous quadratic Lagrange finite elements on tetrahedra.\nOne node is associated with each vertex and also each edge of a local\ncell. As for linear Lagrange elements, local vertex nodes are mapped to\nthe global number of the associated vertex, and the remaining six edge\nnodes are given global numbers by adding to the global edge number\nan offset given by the total number of vertices in the mesh.\n\n6.2 Generating the Local-to-Global Mapping\nWe thus seek a way to automatically generate the code for the local-to-global mapping\nfrom a simple description of the distribution of nodes on the mesh. As before, we restrict\nour attention to elements with nodes given by point evaluation. In that case, each node\ncan be associated with a geometric entity, such as a vertex, an edge, a face or a cell.\nMore generally, we may order the geometric entities by their topological dimension to\nmake the description independent of dimension-specific notation (compare [80]); for a twodimensional triangular mesh, we may refer to a (topologically two-dimensional) triangle as\na cell, whereas for a three-dimensional tetrahedral mesh, we would refer to a (topologically\ntwo-dimensional) triangle as a face. We may thus for each topological dimension list the\nnodes associated with the geometric entities within that dimension. More specifically, we\nmay list for each topological dimension and each geometric entity within that dimension a\ntuple of nodes associated with that geometric entity. This approach is used by the FInite\nelement Automatic Tabulator FIAT [83, 82, 84].\nAs an example, consider the local-to-global mapping for the linear tetrahedral element\nof Table 14. Each cell has four nodes, one associated with each vertex. We may then\ndescribe the nodes by specifying for each geometric entity of dimension zero (the vertices)\na tuple containing one local node number, as demonstrated in Table 16. Note that we may\nspecify the nodes for a discontinuous Lagrange finite element on a tetrahedron similarly by\nassociating all for nodes with topological dimension three, that is, with the cell itself, so\nthat no nodes are shared between neighboring cells.\nAs a further illustration, we may describe the nodes for the quadratic tetrahedral element of Table 15 by associating the first four nodes with topological dimension zero (vertices) and the remaining six nodes with topological dimension one (edges), as demonstrated\n\n\fAutomating the Finite Element Method\n\n35\n\nin Table 17.\nFinally, we present in Table 18 the specification of the nodes for fifth-degree Lagrange\nfinite elements on tetrahedra. Since there are now multiple nodes associated with some\nentities, the ordering of nodes becomes important. In particular, two neighboring tetrahedra\nsharing a common edge (face) must agree on the global node numbering of edge (face)\nnodes. This can be accomplished by checking the orientation of geometric entities with\nrespect to some given convention.5 For each edge, there are two possible orientations and\nfor each face of a tetrahedron, there are six possible orientations. In Table 19, we present\nthe local-to-global mapping for continuous fifth-degree Lagrange finite elements, generated\nautomatically from the description of Table 18 by the FEniCS Form Compiler FFC [98, 87,\n88, 99].\nd=0\n\n(1) \u2013 (2) \u2013 (3) \u2013 (4)\n\nTable 16. Specifying the nodes for continuous linear Lagrange finite elements on\ntetrahedra.\n\nd=0\nd=1\n\n(1) \u2013 (2) \u2013 (3) \u2013 (4)\n(5) \u2013 (6) \u2013 (7) \u2013 (8) \u2013 (9) \u2013 (10)\n\nTable 17. Specifying the nodes for continuous quadratic Lagrange finite elements\non tetrahedra.\n\nWe may thus think of the local-to-global mapping as a function that takes as input the\ncurrent cell K (cell) together with the mesh T (mesh) and generates a tuple (nodes) that\nmaps the local node numbers on K to global node numbers. For finite elements with nodes\ngiven by point evaluation, we may similarly generate a function that interpolates any given\nfunction to the current cell K by evaluating it at the nodes.\nd=0\nd=1\nd=2\nd=3\n\n(1) \u2013 (2) \u2013 (3) \u2013 (4)\n(5, 6, 7, 8) \u2013 (9, 10, 11, 12) \u2013 (13, 14, 15, 16) \u2013\n(17, 18, 19, 20) \u2013 (21, 22, 23, 24) \u2013 (25, 26, 27, 28)\n(29, 30, 31, 32, 33, 34) \u2013 (35, 36, 37, 38, 39, 40) \u2013\n(41, 42, 43, 44, 45, 46) \u2013 (47, 48, 49, 50, 51, 52)\n(53, 54, 55, 56)\n\nTable 18. Specifying the nodes for continuous fifth-degree Lagrange finite elements on tetrahedra.\n\n7 OPTIMIZATIONS\nAs we saw in Section 5, the (affine) tensor contraction representation of the element tensor\nfor Poisson's equation may significantly reduce the operation count in the computation of\nthe element tensor. This is true for a wide range of multilinear forms, in particular test\ncases 1\u20134 presented in Tables 10\u201313.\n5\n\nFor an example of such a convention, see [63] or [99].\n\n\fAnders Logg\n\n36\n\nvoid nodemap(int nodes[], const Cell& cell, const Mesh& mesh)\n{\nstatic unsigned int edge_reordering[2][4] = {{0, 1, 2, 3}, {3, 2, 1, 0}};\nstatic unsigned int face_reordering[6][6] = {{0, 1, 2, 3, 4, 5},\n{0, 3, 5, 1, 4, 2},\n{5, 3, 0, 4, 1, 2},\n{2, 1, 0, 4, 3, 5},\n{2, 4, 5, 1, 3, 0},\n{5, 4, 2, 3, 1, 0}};\nnodes[0] = cell.vertexID(0);\nnodes[1] = cell.vertexID(1);\nnodes[2] = cell.vertexID(2);\nnodes[3] = cell.vertexID(3);\nint alignment = cell.edgeAlignment(0);\nint offset = mesh.numVertices();\nnodes[4] = offset + 4*cell.edgeID(0) + edge_reordering[alignment][0];\nnodes[5] = offset + 4*cell.edgeID(0) + edge_reordering[alignment][1];\nnodes[6] = offset + 4*cell.edgeID(0) + edge_reordering[alignment][2];\nnodes[7] = offset + 4*cell.edgeID(0) + edge_reordering[alignment][3];\nalignment = cell.edgeAlignment(1);\nnodes[8] = offset + 4*cell.edgeID(1) + edge_reordering[alignment][0];\nnodes[9] = offset + 4*cell.edgeID(1) + edge_reordering[alignment][1];\nnodes[10] = offset + 4*cell.edgeID(1) + edge_reordering[alignment][2];\nnodes[11] = offset + 4*cell.edgeID(1) + edge_reordering[alignment][3];\n...\nalignment = cell.faceAlignment(0);\noffset = offset + 4*mesh.numEdges();\nnodes[28] = offset + 6*cell.faceID(0) + face_reordering[alignment][0];\nnodes[29] = offset + 6*cell.faceID(0) + face_reordering[alignment][1];\nnodes[30] = offset + 6*cell.faceID(0) + face_reordering[alignment][2];\nnodes[31] = offset + 6*cell.faceID(0) + face_reordering[alignment][3];\nnodes[32] = offset + 6*cell.faceID(0) + face_reordering[alignment][4];\nnodes[33] = offset + 6*cell.faceID(0) + face_reordering[alignment][5];\n...\noffset = offset + 6*mesh.numFaces();\nnodes[52] = offset + 4*cell.id() + 0;\nnodes[53] = offset + 4*cell.id() + 1;\nnodes[54] = offset + 4*cell.id() + 2;\nnodes[55] = offset + 4*cell.id() + 3;\n}\n\nTable 19. A C++ implementation (excerpt) of the mapping from local to global\nnode numbers for continuous fifth-degree Lagrange finite elements on\ntetrahedra. One node is associated with each vertex, four nodes with\neach edge, six nodes with each face and four nodes with the tetrahedron\nitself.\n\n\fAutomating the Finite Element Method\n\n37\n\nIn some cases however, it may be more efficient to compute the element tensor by\nquadrature, either using the direct approach of Section 5.1 or by a tensor contraction\nrepresentation of the quadrature evaluation as in Section 5.3. Which approach is more\nefficient depends on the multilinear form and the function spaces on which it is defined. In\nparticular, the relative efficiency of a quadrature-based approach increases as the number\nof coefficients in the multilinear form increases, since then the rank of the reference tensor\nincreases. On the other hand, the relative efficiency of the (affine) tensor contraction\nrepresentation increases when the polynomial degree of the basis functions and thus the\nnumber of quadrature points increases. See [87] for a more detailed account.\n7.1 Tensor Contractions as Matrix\u2013Vector Products\nAs demonstrated above, the representation of the element tensor AK as a tensor contraction AK = A0 : GK may be generated automatically from a given multilinear form. To\nevaluate the element tensor AK , it thus remains to evaluate the tensor contraction. A simK and for each entry AK\nple approach would be to iterate over the entries {AK\ni }i\u2208IK of A\ni\ncompute the value of the entry by summing over the set of secondary indices as outlined in\nAlgorithm 3.\nAlgorithm 3 AK = ComputeElementTensor()\nfor i \u2208 IK\nAK\ni =0\nfor \u03b1 \u2208 A\nK\n0\n\u03b1\nAK\ni = Ai + Ai\u03b1 GK\nend for\nend for\n\nExamining Algorithm 3, we note that by an appropriate ordering of the entries in AK ,\nand GK , one may rephrase the tensor contraction as a matrix\u2013vector product and call\nan optimized library routine6 for the computation of the matrix\u2013vector product.\n|IK |\nTo see how to write the tensor contraction as a matrix\u2013vector product, we let {ij }j=1\nbe\nA0\n\n|A|\n\nan enumeration of the set of primary multiindices IK and let {\u03b1j }j=1 be an enumeration of\nthe set of secondary multiindices A. As an example, for the computation of the 6\u00d76 element\ntensor for Poisson's equation with quadratic elements on triangles, we may enumerate the\nprimary and secondary multiindices by\n|I |\n\nK\n{ij }j=1\n= {(1, 1), (1, 2), . . . , (1, 6), (2, 1), . . . , (6, 6)},\n\n|A|\n\n{\u03b1j }j=1 = {(1, 1), (1, 2), (2, 1), (2, 2)}.\n\n(99)\n\nBy similarly enumerating the 36 entries of the 6 \u00d7 6 element tensor AK and the four entries\nof the 2 \u00d7 2 geometry tensor GK , one may define two vectors aK \u2208 R36 and gK \u2208 R4\ncorresponding to the two tensors AK and GK respectively.\nIn general, the element tensor AK and the geometry tensor GK may thus be flattened\n6\n\nSuch a library call is available with the standard level 2 BLAS [18] routine DGEMV, with optimized\nimplementations provided for different architectures by ATLAS [109, 119, 120].\n\n\fAnders Logg\n\n38\n\nto create the corresponding vectors aK \u2194 AK and gK \u2194 GK , defined by\nK\nK\n\u22a4\naK = (AK\ni1 , Ai2 , . . . , Ai|IK | ) ,\n1\n\n2\n\n|A|\n\n(100)\n\nk = 1, 2, . . . , |A|.\n\n(101)\n\ngK = (G\u03b1K , G\u03b1K , . . . , G\u03b1K )\u22a4 .\nSimilarly, we define the |IK | \u00d7 |A| matrix \u01000 by\n\u01000jk = A0ij \u03b1k ,\n\nj = 1, 2, . . . , |IK |,\n\nSince now\naK\nj\n\n=\n\nAK\nij\n\n=\n\nX\n\nA0ij \u03b1 G\u03b1K\n\n=\n\n\u03b1\u2208A\n\n|A|\nX\nk=1\n\nk\nA0ij \u03b1k G\u03b1K\n\n=\n\n|A|\nX\n\n\u01000jk (gK )k ,\n\n(102)\n\nk=1\n\nit follows that the tensor contraction AK = A0 : GK corresponds to the matrix\u2013vector\nproduct\naK = \u01000 gK .\n(103)\nAs noted earlier, the element tensor AK may generally be expressed as a sum of tensor\ncontractions, rather than as a single tensor contraction, that is,\nX\nAK =\nA0,k : GK,k .\n(104)\nk\n\nIn that case, we may still compute the (flattened) element tensor AK by a single matrix\u2013\nvector product,\n\uf8f9\n\uf8ee\ngK,1\nX\n\uf8fa\n\u0002\n\u0003\uf8ef\n0\n\uf8fa\n(105)\n\u01000,k gK,k = \u01000,1 \u01000,2 * * * \uf8ef\naK =\n\uf8f0 gK,2 \uf8fb = \u0100 gK .\n..\nk\n.\n\nHaving thus phrased the general tensor contraction (104) as a matrix\u2013vector product,\nwe note that by grouping the cells of the mesh T into subsets, one may compute the set of\nelement tensors for all cells in a subset by one matrix\u2013matrix product (corresponding to a\nlevel 3 BLAS call) instead of by a sequence of matrix\u2013vector products (each corresponding\nto a level 2 BLAS call), which will typically lead to improved floating-point performance.\nThis is possible since the (flattened) reference tensor \u01000 remains constant over the mesh.\nThus, if {Kk }k \u2282 T is a subset of the cells in the mesh, we have\n\u0002 K K\n\u0003 \u0002\n\u0003\na 1 a 2 * * * = \u01000 gK1 \u01000 gK2 . . . = \u01000 [gK1 gK2 . . .] .\n(106)\n\nThe optimal size of each subset is problem and architecture dependent. Since the geometry\ntensor may sometimes contain a large number of entries, the size of the subset may be\nlimited by the available memory.\n7.2 Finding an Optimized Computation\nAlthough the techniques discussed in the previous section may often lead to good floatingpoint performance, they do not take full advantage of the fact that the reference tensor is\ngenerated automatically. In [85] and later in [89], it was noted that by knowing the size\nand structure of the reference tensor at compile-time, one may generate very efficient code\nfor the computation of the reference tensor.\n\n\fAutomating the Finite Element Method\n\n39\n\nLetting gK \u2208 R|A| be the vector obtained by flattening the geometry tensor GK as\nK\nabove, we note that each entry AK\ni of the element tensor A is given by the inner product\n0\nAK\ni = ai * gK ,\n\n(107)\n\na0i = (A0i\u03b11 , A0i\u03b12 , . . . , A0i\u03b1|A| )\u22a4 .\n\n(108)\n\nwhere a0i is the vector defined by\n\nTo optimize the evaluation of the element tensor, we look for dependencies between the\nvectors {a0i }i\u2208IK and use the dependencies to reduce the operation count. There are many\nsuch dependencies to explore. Below, we consider collinearity and closeness in Hamming\ndistance between pairs of vectors a0i and a0i\u2032 .\n7.2.1 Collinearity\n\nWe first consider the case when two vectors a0i and a0i\u2032 are collinear, that is,\na0i\u2032 = \u03b1a0i ,\n\n(109)\n\nfor some nonzero \u03b1 \u2208 R. If a0i and a0i\u2032 are collinear, it follows that\n0\nK\n0\nAK\ni\u2032 = ai\u2032 * gK = (\u03b1ai ) * gK = \u03b1Ai .\n\n(110)\n\nK\nWe may thus compute the entry AK\ni\u2032 in a single multiplication, if the entry Ai has already\nbeen computed.\n\n7.2.2 Closeness in Hamming distance\n\nAnother possibility is to look for closeness between pairs of vectors a0i and a0i\u2032 in Hamming\ndistance (see [29]), which is defined as the number entries in which two vectors differ. If\nthe Hamming distance between a0i and a0i\u2032 is \u03c1, then the entry A0i\u2032 may be computed from\nthe entry A0i in at most \u03c1 multiply\u2013add pairs. To see this, we assume that a0i and a0i\u2032 differ\nonly in the first \u03c1 entries. It then follows that\nAK\ni\u2032\n\n=\n\na0i\u2032\n\n* gK =\n\na0i\n\n\u03c1\n\u03c1\nX\nX\nk\n0\n0\n\u03b1k\nK\n* gK +\n(Ai\u2032 \u03b1k \u2212 Ai\u03b1k )GK = Ai +\n(A0i\u2032 \u03b1k \u2212 A0i\u03b1k )G\u03b1K ,\nk=1\n\n(111)\n\nk=1\n\nwhere we note that the vector (A0i\u2032 \u03b11 \u2212 A0i\u03b11 , A0i\u2032 \u03b12 \u2212 A0i\u03b12 , . . . , A0i\u2032 \u03b1\u03c1 \u2212 A0i\u03b1\u03c1 )\u22a4 may be precomputed at compile-time. We note that the maximum Hamming distance between a0i\nand a0i\u2032 is \u03c1 = |A|, that is, the length of the vectors, which is also the cost for the direct\ncomputation of an entry by the inner product (107). We also note that if a0i = a0i\u2032 and\nK\nK\nconsequently AK\ni = Ai\u2032 , then the Hamming distance and the cost of obtaining Ai\u2032 from\nK\nAi are both zero.\n7.2.3 Complexity-reducing relations\n\nIn [89], dependencies between pairs of vectors, such as collinearity and closeness in Hamming\ndistance, that can be used to reduce the operation count in computing one entry from\nanother, are referred to as complexity-reducing relations. In general, one may define for any\npair of vectors a0i and a0i\u2032 the complexity-reducing relation \u03c1(a0i , a0i\u2032 ) \u2264 |A| as the minimum\nof all complexity complexity reducing relations found between a0i and a0i\u2032 . Thus, if we look\nfor collinearity and closeness in Hamming distance, we may say that \u03c1(a0i , a0i\u2032 ) is in general\ngiven by the Hamming distance between a0i and a0i\u2032 unless the two vectors are collinear, in\nwhich case \u03c1(a0i , a0i\u2032 ) \u2264 1.\n\n\fAnders Logg\n\n40\n\n7.2.4 Finding a minimum spanning tree\n\nGiven the set of vectors {a0i }i\u2208IK and a complexity-reducing relation \u03c1, the problem is now\nto find an optimized computation of the element tensor AK by systematically exploring\nthe complexity-reducing relation \u03c1. In [89], it was found that this problem has a simple\nsolution. By constructing a weighted undirected graph G = (V, E) with vertices given by\nthe vectors {a0i }i\u2208IK and the weight at each edge given by the value of the complexityreducing relation \u03c1 evaluated at the pair of end-points, one may find an optimized (but not\nnecessarily optimal) evaluation of the element tensor by computing the minimum spanning\ntree7 G\u2032 = (V, E \u2032 ) for the graph G.\nThe minimum spanning tree directly provides an algorithm for the evaluation of the\nelement tensor AK . If one first computes the entry of AK corresponding to the root vertex\nof the minimum spanning tree, which may be done in |A| multiply\u2013add pairs, the remaining\nentries may then be computed by traversing the tree (following the edges), either breadthfirst or depth-first, and at each vertex computing the corresponding entry of AK from the\nparent vertex at a cost given by the weight of the connecting edge. The total cost of\ncomputing the element tensor AK is thus given by\n|A| + |E \u2032 |,\n\n(112)\n\nwhere |E \u2032 | denotes the weight of the minimum spanning tree. As we shall see, computing\nthe minimum spanning tree may significantly reduce the operation count, compared to the\nstraightforward approach of Algorithm 3 for which the operation count is given by |IK | |A|.\n7.2.5 A concrete example\n\nTo demonstrate these ideas, we compute the minimum spanning tree for the computation\nof the 36 entries of the 6 \u00d7 6 element tensor for Poisson's equation with quadratic elements\non triangles and obtain a reduction in the operation count from from a total of |IK | |A| =\n36 \u00d7 4 = 144 multiply\u2013add pairs to less than 17 multiply\u2013add pairs. Since there are 36\nentries in the element tensor, this means that we are be able to compute the element tensor\nin less than one operation per entry (ignoring the cost of computing the geometry tensor).\nAs we saw above in Section 5.2, the rank four reference tensor is A0 is given by\nA0i\u03b1\n\n=\n\nZ\n\nK0\n\n\u2202\u03a61i1 \u2202\u03a62i2\ndX\n\u2202X\u03b11 \u2202X\u03b12\n\n\u2200i \u2208 IK\n\n\u2200\u03b1 \u2208 A,\n\n(113)\n\nwhere now IK = [1, 6]2 and A = [1, 2]2 . To compute the 62 \u00d7 22 = 144 entries of the\nreference tensor, we evaluate the set of integrals (113) for the basis defined in (57). In\nTable 20, we give the corresponding set of (scaled) vectors {a0i }i\u2208IK displayed as a 6 \u00d7 6\nmatrix of vectors with rows corresponding to the first component i1 of the multiindex i\nand columns corresponding to the second component i2 of the multiindex i. Note that the\nentries in Table 20 have beenRscaled with a factor 6 for ease of notation (corresponding to\nthe bilinear form a(v, U ) = 6 \u03a9 \u2207v * \u2207U dx). Thus, the entries of the reference tensor are\ngiven by A01111 = A01112 = A01121 = A01122 = 3/6 = 1/2, A01211 = 1/6, A01212 = 0, etc.\nA spanning tree for a graph G = (V, E) is any connected acyclic subgraph (V, E \u2032 ) of (V, E), that is,\neach vertex in V is connected to an edge in E \u2032 \u2282 E and there are no cycles. The (generally non-unique)\nminimum spanning tree of a weighted graph G is a spanning tree G\u2032 = (V, E \u2032 ) that minimizes the sum\nof edge weights for E \u2032 . The minimum spanning tree may be computed using standard algorithms such as\nKruskal's and Prim's algorithms, see [29].\n7\n\n\fAutomating the Finite Element Method\n\n41\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n1\n\n(3, 3, 3, 3)\u22a4\n\n(1, 0, 1, 0)\u22a4\n\n(0, 1, 0, 1)\u22a4\n\n(0, 0, 0, 0)\u22a4\n\n\u2212(0, 4, 0, 4)\u22a4\n\n\u2212(4, 0, 4, 0)\u22a4\n\n2\n\n(1, 1, 0, 0)\u22a4\n\n(3, 0, 0, 0)\u22a4\n\n\u2212(0, 1, 0, 0)\u22a4,\n\n(0, 4, 0, 0)\u22a4\n\n(0, 0, 0, 0)\u22a4\n\n\u2212(4, 4, 0, 0)\u22a4\n\n3\n\n(0, 0, 1, 1)\u22a4\n\n\u2212(0, 0, 1, 0)\u22a4\n\n(0, 0, 0, 3)\u22a4\n\n(0, 0, 4, 0)\u22a4\n\n\u2212(0, 0, 4, 4)\u22a4\n\n(0, 0, 0, 0)\u22a4\n\n4\n\n(0, 0, 0, 0)\u22a4\n\n(0, 0, 4, 0)\u22a4\n\n(0, 4, 0, 0)\u22a4\n\n(8, 4, 4, 8)\u22a4\n\n\u2212(8, 4, 4, 0)\u22a4\n\n\u2212(0, 4, 4, 8)\u22a4\n\n5\n\n\u2212(0, 0, 4, 4)\u22a4\n\n(0, 0, 0, 0)\u22a4\n\n\u2212(0, 4, 0, 4)\u22a4\n\n\u2212(8, 4, 4, 0)\u22a4\n\n(8, 4, 4, 8)\u22a4\n\n(0, 4, 4, 0)\u22a4\n\n6\n\n\u2212(4, 4, 0, 0)\u22a4\n\n\u2212(4, 0, 4, 0)\u22a4\n\n(0, 0, 0, 0)\u22a4\n\n\u2212(0, 4, 4, 8)\u22a4\n\n(0, 4, 4, 0)\u22a4\n\n(8, 4, 4, 8)\u22a4\n\nTable 20. The 6 \u00d7 6 \u00d7 2 \u00d7 2 reference tensor A0 for Poisson's equation with\nquadratic elements on triangles, displayed here as the set of vectors {a0i }i\u2208IK .\n\nBefore proceeding to compute the minimum spanning tree for the 36 vectors in Table 20, we note that the element tensor AK for Poisson's equation is symmetric, and as\na consequence we only need to compute 21 of the 36 entries of the element tensor. The\nremaining 15 entries are given by symmetry. Furthermore, since the geometry tensor GK\nis symmetric (see Table 11), it follows that\n21\n0\n22\n0\n11\n0\n12\n0\n0\nAK\ni = ai * gK = Ai11 GK + Ai12 GK + Ai21 GK + Ai22 GK\n0\n12\n0\n22\n0\n0\n= A0i11 G11\nK + (Ai12 + Ai21 )GK + Ai22 GK = \u0101i * \u1e21K ,\n\n(114)\n\nwhere\n\u01010i = (A0i11 , A0i12 + A0i21 , A0i22 )\u22a4 ,\n22 \u22a4\n12\n\u1e21K = (G11\nK , GK , GK ) .\n\n(115)\n\nAs a consequence, each of the 36 entries of the element tensor AK may be obtained in at\nmost 3 multiply\u2013add pairs, and since only 21 of the entries need to be computed, the total\noperation count is directly reduced from 144 to 21 \u00d7 3 = 63.\nThe set of symmetry-reduced vectors {\u0101011 , \u0101012 , . . . , \u0101066 } are given in Table 21. We\nimmediately note a number of complexity-reducing relations between the vectors. Entries\n\u0101012 = (1, 1, 0)\u22a4 , \u0101016 = (\u22124, \u22124, 0)\u22a4 , \u0101026 = (\u22124, \u22124, 0)\u22a4 and \u0101045 = (\u22128, \u22128, 0)\u22a4 are collinear,\nentries \u0101044 = (8, 8, 8)\u22a4 and \u0101045 = (\u22128, \u22128, 0)\u22a4 are close in Hamming distance8 etc.\nTo systematically explore these dependencies, we form a weighted graph G = (V, E) and\ncompute a minimum spanning tree. We let the vertices V be the set of symmetry-reduced\nvectors, V = {\u0101011 , \u0101012 , . . . , \u0101066 }, and form the set of edges E by adding between each pair\nof vertices an edge with weight given by the minimum of all complexity-reducing relations\nbetween the two vertices. The resulting minimum spanning tree is shown in Figure 6. We\nnote that the total edge weight of the minimum spanning tree is 14. This means that once\n8\n\nWe use an extended concept of Hamming distance by allowing an optional negation of vectors (which\nis cheap to compute).\n\n\fAnders Logg\n\n42\n\n1\n1\n2\n3\n\n(3, 6, 3)\u22a4\n\n2\n\n3\n\n4\n\n5\n\n6\n\n(1, 1, 0)\u22a4\n\n(0, 1, 1)\u22a4\n\n(0, 0, 0)\u22a4\n\n\u2212(0, 4, 4)\u22a4\n\n\u2212(4, 4, 0)\u22a4\n\n(3, 0, 0)\u22a4\n\n\u2212(0, 1, 0)\u22a4,\n\n(0, 4, 0)\u22a4\n\n(0, 0, 0)\u22a4\n\n\u2212(4, 4, 0)\u22a4\n\n(0, 0, 3)\u22a4\n\n(0, 4, 0)\u22a4\n\n\u2212(0, 4, 4)\u22a4\n\n(0, 0, 0)\u22a4\n\n(8, 8, 8)\u22a4\n\n\u2212(8, 8, 0)\u22a4\n\n\u2212(0, 8, 8)\u22a4\n\n(8, 8, 8)\u22a4\n\n(0, 8, 0)\u22a4\n\n4\n5\n\n(8, 8, 8)\u22a4\n\n6\n\nTable 21. The upper triangular part of the symmetry-reduced reference tensor A0\nfor Poisson's equation with quadratic elements on triangles.\n\n.\n\nthe value of the entry in the element tensor corresponding to the root vertex is known,\nthe remaining entries may be computed in at most 14 multiply\u2013add pairs. Adding the 3\nmultiply\u2013add pairs needed to compute the root entry, we thus find that all 36 entries of the\nelement tensor AK may be computed in at most 17 multiply\u2013add pairs.\nAn optimized algorithm for the computation of the element tensor AK may then be\nfound by starting at the root vertex and computing the remaining entries by traversing the\nminimum spanning tree, as demonstrated in Algorithm 4. Note that there are several ways\nto traverse the tree. In particular, it is possible to pick any vertex as the root vertex and\nstart from there. Furthermore, there are many ways to traverse the tree given the root\nvertex. Algorithm 4 is generated by traversing the tree breadth-first, starting at the root\nvertex \u0101044 = (8, 8, 8)\u22a4 . Finally, we note that the operation count may be further reduced\nby not counting multiplications with zeros and ones.\nAlgorithm 4 An optimized (but not optimal) algorithm for computing the upper triangular\npart of the element tensor AK for Poisson's equation with quadratic elements on triangles\nin 17 multiply\u2013add pairs.\nAK\n44\nAK\n46\nAK\n45\nAK\n55\nAK\n66\nAK\n56\nAK\n12\nAK\n16\nAK\n23\nAK\n24\nAK\n26\n\n0\n0\n12\n0\n22\n= A04411 G11\nK + (A4412 + A4421 )GK + A4422 GK\n11\n= \u2212AK\n+\n8G\n44\nK\n22\n= \u2212AK\n44 + 8GK\n= AK\n44\n= AK\n44\n11\n= \u2212AK\n45 \u2212 8GK\n1 K\n= \u2212 8 A45\n= 12 AK\n45\n11\n= \u2212AK\n12 + 1GK\nK\n11\n= \u2212A16 \u2212 4GK\n= AK\n16\n\nAK\n13\nAK\n14\nAK\n34\nAK\n15\nAK\n25\nAK\n22\nAK\n33\nAK\n36\nAK\n35\nAK\n11\n\nK\n= \u2212AK\n23 + 1G22\nK\n= 0A23\n= AK\n24\n= \u22124AK\n13\n= AK\n14\nK\n= AK\n14 + 3G11\nK\n= A14 + 3GK\n22\n= AK\n14\n= AK\n15\nK\nK\n= AK\n22 + 6G12 + 3G22\n\n\fAutomating the Finite Element Method\n\n43\n\n\u0101044 = (8, 8, 8)\u22a4\n\n1\n\n1\n\n\u0101046 = \u2212(0, 8, 8)\u22a4\n\n1\n\n1\n\n\u0101012 = (1, 1, 0)\u22a4\n\n\u0101056 = (0, 8, 0)\u22a4\n\n\u0101016 = \u2212(4, 4, 0)\u22a4\n\n1\n\n1\n\n\u0101013 = (0, 1, 1)\u22a4\n\n1\n\n1\n\n\u0101026 = \u2212(4, 4, 0)\u22a4\n\n0\n\n\u0101034 = (0, 4, 0)\u22a4\n\n\u0101014 = (0, 0, 0)\u22a4\n\n0\n\n0\n\n\u0101024 = (0, 4, 0)\u22a4\n\n\u0101023 = \u2212(0, 1, 0)\u22a4\n\n1\n\n\u0101066 = (8, 8, 8)\u22a4\n\n\u0101055 = (8, 8, 8)\u22a4\n\n\u0101045 = \u2212(8, 8, 0)\u22a4\n\n1\n\n0\n\n0\n\n1\n\n0\n1\n\n\u0101015 = \u2212(0, 4, 4)\u22a4\n\n0\n\n\u0101035 = \u2212(0, 4, 4)\u22a4\n\n\u0101025 = (0, 0, 0)\u22a4\n\n\u0101022 = (3, 0, 0)\u22a4\n\n\u0101033 = (0, 0, 3)\u22a4\n\n\u0101036 = (0, 0, 0)\u22a4\n\n2\n\n\u0101011 = (3, 6, 3)\u22a4\n\nFigure 6. The minimum spanning tree for the optimized computation of the upper\ntriangular part (Table 21) of the element tensor for Poisson's equation\nwith quadratic elements on triangles. Solid (blue) lines indicate zero\nHamming distance (equality), dashed (blue) lines indicate a small but\nnonzero Hamming distance and dotted (red) lines indicate collinearity.\n\n\fAnders Logg\n\n44\n\n7.2.6 Extensions\n\nBy use of symmetry and relations between subsets of the reference tensor A0 we have seen\nthat it is possible to significantly reduce the operation count for the computation of the\ntensor contraction AK = A0 : GK . We have here only discussed the use of binary relations\n(collinearity and Hamming distance) but further reductions may be made by considering\nternary relations, such as coplanarity, and higher-arity relations between the vectors.\n8 AUTOMATION AND SOFTWARE ENGINEERING\nIn this section, we comment briefly on some topics of software engineering relevant to the\nautomation of the finite element method. A number of books and papers have been written\non the subject of software engineering for the implementation of finite element methods,\nsee for example [92, 93, 3, 104, 105]. In particular these works point out the importance of\nobject-oriented, or concept-oriented, design in developing mathematical software; since the\nmathematical concepts have already been hammered out, it may be advantageous to reuse\nthese concepts in the system design, thus providing abstractions for important concepts,\nincluding Vector, Matrix, Mesh, Function, BilinearForm, LinearForm, FiniteElement\netc.\nWe shall not repeat these arguments, but instead point out a couple of issues that might\nbe less obvious. In particular, a straightforward implementation of all the mathematical\nconcepts discussed in the previous sections may be difficult or even impossible to attain.\nTherefore, we will argue that a level of automation is needed also in the implementation or\nrealization of an automation of the finite element method, that is, the automatic generation\nof computer code for the specific mathematical concepts involved in the specification of any\nparticular finite element method and differential equation, as illustrated in Figure 7.\n\nFigure 7. A machine (computer program) that automates the finite element\nmethod by automatically generating a particular machine (computer\nprogram) for a suitable subset of the given input data.\n\nWe also point out that the automation of the finite element method is not only a software\nengineering problem. In addition to identifying and implementing the proper mathematical\nconcepts, one must develop new mathematical tools and ideas that make it possible for the\nautomating system to realize the full generality of the finite element method. In addition,\nnew insights are needed to build an efficient automating system that can compete with or\noutperform hand-coded specialized systems for any given input.\n\n\fAutomating the Finite Element Method\n\n45\n\n8.1 Code Generation\nAs in all types of engineering, software for scientific computing must try to find a suitable\ntrade-off between generality and efficiency; a software system that is general in nature, that\nis, it accepts a wide range of inputs, is often less efficient than another software system that\nperforms the same job on a more limited set of inputs. As a result, most codes used by\npractitioners for the solution of differential equations are very specific, often specialized to\na specific method for a specific differential equation.\nHowever, by using a compiler approach, it is possible to combine generality and efficiency\nwithout loss of generality and without loss of efficiency. Instead of developing a potentially\ninefficient general-purpose program that accepts a wide range of inputs, a suitable subset of\nthe input is given to an optimizing compiler that generates a specialized program that takes\na more limited set of inputs. In particular, one may automatically generate a specialized\nsimulation code for any given method and differential equation.\nAn important task is to identify a suitable subset of the input to move to a precompilation phase. In the case of a system automating the solution of differential equations by\nthe finite element method, a suitable subset of input includes the variational problem (29)\nand the choice of approximating finite element spaces. We thus develop a domain-specific\ncompiler that accepts as input a variational problem and a set of finite elements and generates optimized low-level code (in some general-purpose language such as C or C++).\nSince the compiler may thus work on only a small family of inputs (multilinear forms),\ndomain-specific knowledge allows the compiler to generate very efficient code, using the\noptimizations discussed in the previous section. We return to this in more detail below in\nSection 9.2 when we discuss the FEniCS Form Compiler FFC.\nWe note that to limit the complexity of the automating system, it is important to\nidentify a minimal set of code to be generated at a precompilation stage, and implement\nthe remaining code in a general-purpose language. It makes less sense to generate the code\nfor administrative tasks such as reading and writing data to file, special algorithms like\nadaptive mesh refinement etc. These tasks can be implemented as a library in a generalpurpose language.\n8.2 Just-In-Time Compilation\nTo make an automating system for the solution of differential equations truly useful, the\ngeneration and precompilation of code according to the above discussion must also be\nautomated. Thus, a user should ultimately be presented with a single user-interface and\nthe code should automatically and transparently be generated and compiled just-in-time\nfor a given problem specification.\nAchieving just-in-time compilation of variational problems is challenging, not only to\nconstruct the exact mechanism by which code is generated, compiled and linked back in at\nrun-time, but also to reduce the precompilation phase to a minimum so that the overhead\nof code generation and compilation is acceptable. To compile and generate the code for the\nevaluation of a multilinear form as discussed in Section 5, we need to compute the tensor\nrepresentation (80), including the evaluation of the reference tensor. Even with an optimized\nalgorithm for the computation of the reference tensor as discussed in [88], the computation of\nthe reference tensor may be very costly, especially for high-order elements and complicated\nforms. To improve the situation, one may consider caching previously computed reference\ntensors (similarly to how LATEX generates and caches fonts in different resolutions) and\nreuse previously computed reference tensors. As discussed in [88], a reference tensor may\nbe uniquely identified by a (short) string referred to as a signature. Thus, one may store\nreference tensors along with their signatures to speed up the precomputation and allow\nrun-time just-in-time compilation of variational problems with little overhead.\n\n\fAnders Logg\n\n46\n\n9 A PROTOTYPE IMPLEMENTATION (FEniCS)\nAn algorithm must be seen to be believed, and the best way\nto learn what an algorithm is all about is to try it.\nDonald E. Knuth\nThe Art of Computer Programming (1968)\nThe automation of the finite element method includes its own realization, that is, a\nsoftware system that implements the algorithms discussed in Sections 3\u20136. Such a system\nis provided by the FEniCS project [60, 36]. We present below some of the key components\nof FEniCS, including FIAT, FFC and DOLFIN, and point out how they relate to the\nvarious aspects of the automation of the finite element method. In particular, the automatic\ntabulation of finite element basis functions discussed in Section 4 is provided by FIAT [83,\n82, 84], the automatic evaluation of the element tensor as discussed in Section 5 is provided\nby FFC [98, 87, 88, 99] and the automatic assembly of the discrete system as discussed\nin Section 6 is provided by DOLFIN [62, 68, 63]. The FEniCS project thus serves as a\ntestbed for development of new ideas for the automatic and efficient implementation of\nfinite element methods. At the same, it provides a reference implementation of these ideas.\nFEniCS software is free software [55]. In particular, the components of FEniCS are\nlicensed under the GNU General Public License [53].9 The source code is freely available\non the FEniCS web site [60] and the development is discussed openly on public mailing\nlists.\n9.1 FIAT\nThe FInite element Automatic Tabulator FIAT [83] was first introduced in [82] and implements the ideas discussed above in Section 4 for the automatic tabulation of finite element\nbasis functions based on a linear algebraic representation of function spaces and constraints.\nFIAT provides functionality for defining finite element function spaces as constrained\nsubsets of polynomials on the simplices in one, two and three space dimensions, as well\nas a library of predefined finite elements, including arbitrary degree Lagrange [27, 20],\nHermite [27, 20], Raviart\u2013Thomas [111], Brezzi\u2013Douglas\u2013Marini [22] and Nedelec [106]\nelements, as well as the (first degree) Crouzeix\u2013Raviart element [31]. Furthermore, the\nplan is to support Brezzi\u2013Douglas\u2013Fortin\u2013Marini [23] and Arnold\u2013Winther [4] elements in\nfuture versions.\nIn addition to tabulating finite element nodal basis functions (as linear combinations of\na reference basis), FIAT generates quadrature points of any given order on the reference\nsimplex and provides functionality for efficient tabulation of the basis functions and their\nderivatives at any given set of points. In Figure 8 and Figure 9, we present some examples\nof basis functions generated by FIAT.\nAlthough FIAT is implemented in Python, the interpretive overhead of Python compared to compiled languages is small, since the operations involved may be phrased in terms\nof standard linear algebra operations, such as the solution of linear systems and singular\nvalue decomposition, see [84]. FIAT may thus make use of optimized Python linear algebra\nlibraries such Python Numeric [107]. Recently, a C++ version of FIAT called FIAT++ has\nalso been developed with run-time bindings for Sundance [103, 101, 102].\n9.2 FFC\nThe FEniCS Form Compiler FFC [98], first introduced in [87], automates the evaluation of\nmultilinear forms as outlined in Section 5 by automatically generating code for the efficient\n9\n\nFIAT is licensed under the Lesser General Public License [54].\n\n\fAutomating the Finite Element Method\n\nFigure 8. The first three basis functions for a fifth-degree Lagrange finite element on a triangle, associated with the three vertices of the triangle.\n(Courtesy of Robert C. Kirby.)\n\nFigure 9. A basis function associated with an interior point for a fifth-degree\nLagrange finite element on a triangle. (Courtesy of Robert C. Kirby.)\n\n47\n\n\fAnders Logg\n\n48\n\ncomputation of the element tensor corresponding to a given multilinear form. FFC thus\nfunctions as domain-specific compiler for multilinear forms, taking as input a set of discrete\nfunction spaces together with a multilinear form defined on these function spaces, and\nproduces as output optimized low-level code, as illustrated in Figure 10. In its simplest\nform, FFC generates code in the form of a single C++ header file that can be included in\na C++ program, but FFC can also be used as a just-in-time compiler within a scripting\nenvironment like Python, for seamless definition and evaluation of multilinear forms.\n\nFigure 10. The form compiler FFC takes as input a multilinear form together with\na set of function spaces and generates optimized low-level (C++) code\nfor the evaluation of the associated element tensor.\n\n9.2.1 Form language\n\nThe FFC form language is generated from a small set of basic data types and operators that\nallow a user to define a wide range of multilinear forms, in accordance with the discussion\nof Section 5.4.3. As an illustration, we include below the complete definition in the FFC\nform language of the bilinear forms for the test cases considered above in Tables 10\u201313.\nWe refer to the FFC user manual [99] for a detailed discussion of the form language, but\nnote here that in addition to a set of standard operators, including the inner product dot,\nthe partial derivative D, the gradient grad, the divergence div and the rotation rot, FFC\nsupports Einstein tensor-notation (Table 24) and user-defined operators (operator epsilon\nin Table 25).\nelement = FiniteElement(\"Lagrange\", \"tetrahedron\", 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\na = v*U*dx\n\nTable 22. The complete definition of the bilinear form a(v, U ) =\nFFC form language (test case 1).\n\nR\n\n\u03a9\n\nv U dx in the\n\n9.2.2 Implementation\n\nThe FFC form language is implemented in Python as a collection of Python classes (including BasisFunction, Function, FiniteElement etc.) and operators on theses classes.\nAlthough FFC is implemented in Python, the interpretive overhead of Python has been\n\n\fAutomating the Finite Element Method\n\n49\n\nelement = FiniteElement(\"Lagrange\", \"tetrahedron\", 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\na = dot(grad(v), grad(U))*dx\nR\n\nTable 23. The complete definition of the bilinear form a(v, U ) =\nin the FFC form language (test case 2).\n\n\u03a9\n\n\u2207v * \u2207U dx\n\nelement = FiniteElement(\"Vector Lagrange\", \"tetrahedron\", 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\nw = Function(element)\na = v[i]*w[j]*D(U[i],j)*dx\n\nTable 24. The complete definition of the bilinear form a(v, U ) =\nin the FFC form language (test case 3).\n\nR\n\n\u03a9\n\nv * (w * \u2207)U dx\n\nelement = FiniteElement(\"Vector Lagrange\", \"tetrahedron\", 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\ndef epsilon(v):\nreturn 0.5*(grad(v) + transp(grad(v)))\na = dot(epsilon(v), epsilon(U))*dx\n\nTable 25. The complete definition of the bilinear form a(v, U ) =\nin the FFC form language (test case 4).\n\nR\n\n\u03a9\n\n\u01eb(v) : \u01eb(U ) dx\n\n\fAnders Logg\n\n50\n\nminimized by judicious use of optimized numerical libraries such as Python Numeric [107].\nThe computationally most expensive part of the compilation of a multilinear form is the\nprecomputation of the reference tensor. As demonstrated in [88], by suitably pretabulating\nbasis functions and their derivatives at a set of quadrature points (using FIAT), the reference tensor can be computed by assembling a set of outer products, which may each be\nefficiently computed by a call to Python Numeric.\nCurrently, the only optimization FFC makes is to avoid multiplications with any zeros of\nthe reference tensor A0 when generating code for the tensor contraction AK = A0 : GK . As\npart of the FEniCS project, an optimizing backend, FErari (Finite Element Re-arrangement\nAlgorithm to Reduce Instructions), is currently being developed. Ultimately, FFC will\ncall FErari at compile-time to find an optimized computation of the tensor contraction,\naccording to the discussion in Section 7.\n9.2.3 Benchmark results\n\nAs a demonstration of the efficiency of the code generated by FFC, we include in Table 26\na comparison taken from [87] between a standard implementation, based on computing the\nelement tensor AK on each cell K by a loop over quadrature points, with the code automatically generated by FFC, based on precomputing the reference tensor A0 and computing\nthe element tensor AK by the tensor contraction AK = A0 : GK on each cell.\nForm\nMass 2D\nMass 3D\nPoisson 2D\nPoisson 3D\nNavier\u2013Stokes 2D\nNavier\u2013Stokes 3D\nElasticity 2D\nElasticity 3D\n\nq=1\n12\n21\n8\n9\n32\n77\n10\n14\n\nq=2\n31\n81\n29\n56\n33\n100\n43\n87\n\nq=3\n50\n189\n56\n143\n53\n61\n67\n103\n\nq=4\n78\n355\n86\n259\n37\n42\n97\n134\n\nq=5\n108\n616\n129\n427\n-\n-\n-\n-\n\nq=6\n147\n881\n144\n341\n-\n-\n-\n-\n\nq=7\n183\n1442\n189\n285\n-\n-\n-\n-\n\nq=8\n232\n1475\n236\n356\n-\n-\n-\n-\n\nTable 26. Speedups for test cases 1\u20134 (Tables 10\u201313 and Tables 22\u201325) in two\nand three space dimensions.\n\nAs seen in Table 26, the speedup ranges between one and three orders of magnitude,\nwith larger speedups for higher degree elements. In Figure 11 and Figure 12, we also plot\nthe dependence of the speedup on the polynomial degree for test cases 1 and 2 respectively.\nIt should be noted that the total work in a simulation also includes the assembly of the\nlocal element tensors {AK }K\u2208T into the global tensor A, solving the linear system, iterating\non the nonlinear problem etc. Therefore, the overall speedup may be significantly less than\nthe speedups reported in Table 26. We note that if the computation of the local element\ntensors normally accounts for a fraction \u03b8 \u2208 (0, 1) of the total run-time, then the overall\nspeedup gained by a speedup of size s > 1 for the computation of the element tensors will\nbe\n1\n1\n1<\n\u2264\n,\n(116)\n1 \u2212 \u03b8 + \u03b8/s\n1\u2212\u03b8\nwhich is significant only if \u03b8 is significant. As noted in [85], \u03b8 may be significant in many\ncases, in particular for nonlinear problems where a nonlinear system (or the action of a\nlinear operator) needs to be repeatedly reassembled as part of an iterative method.\n\n\fAutomating the Finite Element Method\n\n10 4\n\nCPU time / s\n\n10 3\n\n51\n\nMass matrix 2D (1 million triangles)\nQuadrature\nFFC\n\n10 2\n10 1\n10 0\n10 -1\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n7\n\n8\n\nMass matrix 3D (1 million tetrahedra)\n\nCPU time / s\n\n10 5\n\nQuadrature\nFFC\n\n10 4\n10 3\n10 2\n10 1\n10 0\n10 -1\n1\n\n2\n\n3\n\n4\n\nq\n\n5\n\n6\n\nFigure 11. Benchmark results for test case 1, the mass matrix, specified in FFC\nby a = v*U*dx.\n\n10 4\n\nCPU time / s\n\n10 3\n\nPoisson 2D (1 million triangles)\nQuadrature\nFFC\n\n10 2\n10 1\n10 0\n10 -1\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n7\n\n8\n\nPoisson 3D (1 million tetrahedra)\n\nCPU time / s\n\n10 5\n\nQuadrature\nFFC\n\n10 4\n10 3\n10 2\n10 1\n10 0\n1\n\n2\n\n3\n\n4\n\nq\n\n5\n\n6\n\nFigure 12. Benchmark results for test case 2, Poisson's equation, specified in FFC\nby a = dot(grad(v), grad(U))*dx.\n\n\fAnders Logg\n\n52\n\n9.2.4 User interfaces\n\nFFC can be used either as a stand-alone compiler on the command-line, or as a Python\nmodule from within a Python script. In the first case, a multilinear form (or a pair of\nbilinear and linear forms) is entered in a text file with suffix .form and then compiled by\ncalling the command ffc with the form file on the command-line.\nBy default, FFC generates C++ code for inclusion in a DOLFIN C++ program (see\nSection 9.3 below) but FFC can also compile code for other backends (by an appropriate\ncompiler flag), including the ASE (ANL SIDL Environment) format [91], XML format, and\nLATEX format (for inclusion of the tensor representation in reports and presentations). The\nformat of the generated code is separated from the parsing of forms and the generation of\nthe tensor contraction, and new formats for alternative backends may be added with little\neffort, see Figure 13.\n\nFigure 13. Component diagram for FFC.\n\nAlternatively, FFC can be used directly from within Python as a Python module, allowing definition and compilation of multilinear forms from within a Python script. If used\ntogether with the recently developed Python interface of DOLFIN (PyDOLFIN), FFC\nfunctions as a just-in-time compiler for multilinear forms, allowing forms to be defined and\nevaluated from within Python.\n9.3 DOLFIN\nDOLFIN [62, 68, 63], Dynamic Object-oriented Library for FINite element computation,\nfunctions as a general programming interface to DOLFIN and provides a problem-solving\nenvironment (PSE) for differential equations in the form of a C++/Python class library.\nInitially, DOLFIN was developed as a self-contained (but modularized) C++ code for\nfinite element simulation, providing basic functionality for the definition and automatic\nevaluation of multilinear forms, assembly, linear algebra, mesh data structures and adaptive\nmesh refinement, but as a consequence of the development of focused components for each\nof these tasks as part of the FEniCS project, a large part (but not all) of the functionality\nof DOLFIN has been delegated to these other components while maintaining a consistent\nprogramming interface. Thus, DOLFIN relies on FIAT for the automatic tabulation of finite\nelement basis functions and on FFC for the automatic evaluation of multilinear forms. We\ndiscuss below some of the key aspects of DOLFIN and its role as a component of the FEniCS\nproject.\n\n\fAutomating the Finite Element Method\n\n53\n\n9.3.1 Automatic assembly of the discrete system\n\nDOLFIN implements the automatic assembly of the discrete system associated with a given\nvariational problem as outlined in Section 6. DOLFIN iterates over the cells {K}K\u2208T of a\ngiven mesh T and calls the code generated by FFC on each cell K to evaluate the element\ntensor AK . FFC also generates the code for the local-to-global mapping which DOLFIN\ncalls to obtain a rule for the addition of each element tensor AK to the global tensor A.\nSince FFC generates the code for both the evaluation of the element tensor and for\nthe local-to-global mapping, DOLFIN needs to know very little about the finite element\nmethod. It only follows the instructions generated by FFC and operates abstractly on the\nlevel of Algorithm 2.\n9.3.2 Meshes\n\nDOLFIN provides basic data structures and algorithms for simplicial meshes in two and\nthree space dimensions (triangular and tetrahedral meshes) in the form of a class Mesh,\nincluding adaptive mesh refinement. As part of PETSc [9, 8, 10] and the FEniCS project,\nthe new component Sieve [81, 80] is currently being developed. Sieve generalizes the mesh\nconcept and provides powerful abstractions for dimension-independent operations on mesh\nentities and will function as a backend for the mesh data structures in DOLFIN.\n9.3.3 Linear algebra\n\nPreviously, DOLFIN provided a stand-alone basic linear algebra library in the form of a\nclass Matrix, a class Vector and a collection of iterative and direct solvers. This implementation has recently been replaced by a set of simple wrappers for the sparse linear\nalgebra library provided by PETSc [9, 8, 10]. As a consequence, DOLFIN is able to provide\nsophisticated high-performance parallel linear algebra with an easy-to-use object-oriented\ninterface suitable for finite element computation.\n9.3.4 ODE solvers\n\nDOLFIN also provides a set of general order mono-adaptive and multi-adaptive [94, 95, 50,\n97, 100] ODE-solvers, automating the solution of ordinary differential equations. Although\nthe ODE-solvers may be used in connection with the automated assembly of discrete systems, DOLFIN does currently not provide any level of automation for the discretization of\ntime-dependent PDEs. Future versions of DOLFIN (and FFC) will allow time-dependent\nPDEs to be defined directly in the FFC form language with automatic discretization and\nadaptive time-integration.\n9.3.5 PDE solvers\n\nIn addition to providing a class library of basic tools that automate the implementation\nof adaptive finite element methods, DOLFIN provides a collection of ready-made solvers\nfor a number of standard equations. The current version of DOLFIN provides solvers for\nPoisson's equation, the heat equation, the convection\u2013diffusion equation, linear elasticity,\nupdated large-deformation elasticity, the Stokes equations and the incompressible Navier\u2013\nStokes equations.\n9.3.6 Pre- and post-processing\n\nDOLFIN relies on interaction with external tools for pre-processing (mesh generation) and\npost-processing (visualization). A number of output formats are provided for visualization,\nincluding DOLFIN XML [63], VTK [90] (for use in ParaView [116] or MayaVi [110]),\nOctave [37], MATLAB [118], OpenDX [1], GiD [28] and Tecplot [2]. DOLFIN may also be\neasily extended with new output formats.\n\n\fAnders Logg\n\n54\n\n9.3.7 User interfaces\n\nDOLFIN can be accessed either as a C++ class library or as a Python module, with the\nPython interface generated semi-automatically from the C++ class library using SWIG [15,\n14]. In both cases, the user is presented with a simple and consistent but powerful programming interface.\nAs discussed in Section 9.3.5, DOLFIN provides a set of ready-made solvers for standard\ndifferential equations. In the simplest case, a user thus only needs to supply a mesh, a set\nof boundary conditions and any parameters and variable coefficients to solve a differential\nequation, by calling one of the existing solvers. For other differential equations, a solver\nmay be implemented with minimal effort using the set of tools provided by the DOLFIN\nclass library, including variational problems, meshes and linear algebra as discussed above.\n9.4 Related Components\nWe also mention two other projects developed as part of FEniCS. One of these is Puffin[70,\n69], a light-weight educational implementation of the basic functionality of FEniCS for\nOctave/MATLAB, including automatic assembly of the linear system from a given variational problem. Puffin has been used with great success in introductory undergraduate\nmathematics courses and is accompanied by a set of exercises [79] developed as part of the\nBody and Soul reform project [48, 41, 42, 40] for applied mathematics education.\nThe other project is the Ko mechanical simulator [76]. Ko uses DOLFIN as the computational backend and provides a specialized interface to the simulation of mechanical\nsystems, including large-deformation elasticity and collision detection. Ko provides two\ndifferent modes of simulation: either a simple mass\u2013spring model solved as a system of\nODEs, or a large-deformation updated elasticity model [78] solved as a system of timedependent PDEs. As a consequence of the efficient assembly provided by DOLFIN, based\non efficient code being generated by FFC, the overhead of the more complex PDE model\ncompared to the simple ODE model is relatively small.\n10 EXAMPLES\nIn this section, we present a number of examples chosen to illustrate various aspects of\nthe implementation of finite element methods for a number of standard partial differential\nequations with the FEniCS framework. We already saw in Section 2 the specification of the\nvariational problem for Poisson's equation in the FFC form language. The examples below\ninclude static linear elasticity, two different formulations for the Stokes equations and the\ntime-dependent convection\u2013diffusion equations with the velocity field given by the solution\nof the Stokes equations. For simplicity, we consider only linear problems but note that the\nframework allows for implementation of methods for general nonlinear problems. See in\nparticular [78] and [65, 64, 66].\n10.1 Static Linear Elasticity\nAs a first example, consider the equation of static linear elasticity [20] for the displacement\nu = u(x) of an elastic shape \u03a9 \u2208 Rd ,\n\u2212\u2207 * \u03c3(u) = f\nu = u0\n\u03c3(u)n\u0302 = 0\n\nin \u03a9,\non \u03930 \u2282 \u2202\u03a9,\non \u2202\u03a9 \\ \u03930 ,\n\n(117)\n\nwhere n\u0302 denotes a unit vector normal to the boundary \u2202\u03a9. The stress tensor \u03c3 is given by\n\u03c3(v) = 2\u03bc \u01eb(v) + \u03bb trace(\u01eb(v))I,\n\n(118)\n\n\fAutomating the Finite Element Method\n\n55\n\nwhere I is the d \u00d7 d identity matrix and where the strain tensor \u01eb is given by\n\u0011\n1\u0010\n\u01eb(v) =\n\u2207v + (\u2207v)\u22a4 ,\n2\n\n\u2202vi\n+\nthat is, \u01ebij (v) = 12 ( \u2202x\nj\n\n\u2202vj\n\u2202xi )\n\n(119)\n\nfor i, j = 1, . . . , d. The Lam\u00e9 constants \u03bc and \u03bb are given by\n\n\u03bc=\n\nE\n,\n2(1 + \u03bd)\n\n\u03bb=\n\nE\u03bd\n,\n(1 + \u03bd)(1 \u2212 2\u03bd)\n\n(120)\n\nwith E the Young's modulus of elasticity and \u03bd the Poisson ratio, see [121]. In the example\nbelow, we take E = 10 and \u03bd = 0.3.\nTo obtain the discrete variational problem corresponding to (117), we multiply with a\ntest function v in a suitable discrete test space V\u0302h and integrate by parts to obtain\nZ\nZ\nv * f dx \u2200v \u2208 V\u0302h .\n(121)\n\u2207v : \u03c3(U ) dx =\n\u03a9\n\n\u03a9\n\nThe corresponding formulation in the FFC form language is shown in Table 27 for an\napproximation with linear Lagrange elements on tetrahedra. Note that by defining the\noperators \u03c3 and \u01eb, it is possible to obtain a very compact notation that corresponds well\nwith the mathematical notation of (121).\nelement = FiniteElement(\"Vector Lagrange\", \"tetrahedron\", 1)\nv = BasisFunction(element)\nU = BasisFunction(element)\nf = Function(element)\nE = 10.0\nnu = 0.3\nmu = E / (2*(1 + nu))\nlmbda = E*nu / ((1 + nu)*(1 - 2*nu))\ndef epsilon(v):\nreturn 0.5*(grad(v) + transp(grad(v)))\ndef sigma(v):\nreturn 2*mu*epsilon(v) + lmbda*mult(trace(epsilon(v)), Identity(len(v)))\na = dot(grad(v), sigma(U))*dx\nL = dot(v, f)*dx\n\nTable 27. The complete specification of the variational problem (121) for static\nlinear elasticity in the FFC form language.\n\nComputing the solution of the variational problem for a domain \u03a9 given by a gear,\nwe obtain the solution in Figure 14. The gear is clamped at two of its ends and twisted\n30 degrees, as specified by a suitable choice of Dirichlet boundary conditions on \u03930 .\n\n\f56\n\nAnders Logg\n\nFigure 14. The original domain \u03a9 of the gear (above) and the twisted gear (below),\nobtained by displacing \u03a9 at each point x \u2208 \u03a9 by the value of the solution\nu of (117) at the point x.\n\n\fAutomating the Finite Element Method\n\n57\n\n10.2 The Stokes Equations\nNext, we consider the Stokes equations,\n\u2212\u2206u + \u2207p = f\n\u2207*u = 0\nu = u0\n\nin \u03a9,\nin \u03a9,\non \u2202\u03a9,\n\n(122)\n\nfor the velocity field u = u(x) and the pressure p = p(x) in a highly viscous medium. By\nmultiplying the two equations with a pair of test functions (v, q) chosen from a suitable\ndiscrete test space V\u0302h = V\u0302hu \u00d7 V\u0302hp , we obtain the discrete variational problem\nZ\nZ\nv * f dx \u2200(v, q) \u2208 V\u0302h .\n(123)\n\u2207v : \u2207U \u2212 (\u2207 * v)P + q\u2207 * U dx =\n\u03a9\n\n\u03a9\n\nfor the discrete approximate solution (U, P ) \u2208 Vh = Vhu \u00d7 Vhp . To guarantee the existence of\na unique solution of the discrete variational problem (123), the discrete function spaces V\u0302h\nand Vh must be chosen appropriately. The Babu\u0161ka\u2013Brezzi [5, 21] inf\u2013sup condition gives\na precise condition for the selection of the approximating spaces.\n10.2.1 Taylor\u2013Hood elements\n\nOne way to fulfill the Babu\u0161ka\u2013Brezzi condition is to use different order approximations for\nthe velocity and the pressure, such as degree q polynomials for the velocity and degree q \u2212 1\nfor the pressure, commonly referred to as Taylor\u2013Hood elements, see [19, 20]. The resulting\nmixed formulation may be specified in the FFC form language by defining a Taylor\u2013Hood\nelement as the direct sum of a degree q vector-valued Lagrange element and a degree q \u2212 1\nscalar Lagrange element, as shown in Table 28. Figure 16 shows the velocity field for the\nflow around a two-dimensional dolphin computed with a P2 \u2013P1 Taylor-Hood approximation.\nP2 = FiniteElement(\"Vector Lagrange\", \"triangle\", 2)\nP1 = FiniteElement(\"Lagrange\", \"triangle\", 1)\nTH = P2 + P1\n(v, q) = BasisFunctions(TH)\n(U, P) = BasisFunctions(TH)\nf = Function(P2)\na = (dot(grad(v), grad(U)) - div(v)*P + q*div(U))*dx\nL = dot(v, f)*dx\n\nTable 28. The complete specification of the variational problem (123) for the\nStokes equations with P2 \u2013P1 Taylor\u2013Hood elements.\n\n10.2.2 A stabilized equal-order formulation\n\nAlternatively, the Babu\u0161ka\u2013Brezzi condition may be circumvented by an appropriate modification (stabilization) of the variational problem (123). In general, an appropriate modification may be obtained by a Galerkin/least-squares (GLS) stabilization, that is, by modifying\n\n\fAnders Logg\n\n58\n\nthe test function w = (v, q) according to w \u2192 w + \u03b4Aw, where A is the operator of the\ndifferential equation and \u03b4 = \u03b4(x) is suitable stabilization parameter. Here, we a choose\nsimple pressure-stabilization obtained by modifying the test function w = (v, q) according\nto\n(v, q) \u2192 (v, q) + (\u03b4\u2207q, 0).\n(124)\nThe stabilization (124) is sometimes referred to as a pressure-stabilizing/Petrov-Galerkin\n(PSPG) method, see [72, 56]. Note that the stabilization (124) may also be viewed as a\nreduced GLS stabilization.\nWe thus obtain the following modified variational problem: Find (U, P ) \u2208 Vh such that\nZ\nZ\n\u2207v : \u2207U \u2212 (\u2207 * v)P + q\u2207 * U + \u03b4\u2207q * \u2207P dx = (v + \u03b4\u2207q) * f dx \u2200(v, q) \u2208 V\u0302h . (125)\n\u03a9\n\n\u03a9\n\nTable 29 shows the stabilized equal-order method in the FFC form language, with the\nstabilization parameter given by\n\u03b4 = \u03b2h2 ,\n(126)\nwhere \u03b2 = 0.2 and h = h(x) is the local mesh size (cell diameter).\nvector = FiniteElement(\"Vector Lagrange\", \"triangle\", 1)\nscalar = FiniteElement(\"Lagrange\", \"triangle\", 1)\nsystem = vector + scalar\n(v, q) = BasisFunctions(system)\n(U, P) = BasisFunctions(system)\nf = Function(vector)\nh = Function(scalar)\nd = 0.2*h*h\na = (dot(grad(v), grad(U)) - div(v)*P + q*div(U) + d*dot(grad(q), grad(P)))*dx\nL = dot(v + mult(d, grad(q)), f)*dx\n\nTable 29. The complete specification of the variational problem (125) for the\nStokes equations with an equal-order P1 \u2013P1 stabilized method.\n\nIn Figure 15, we illustrate the importance of stabilizing the equal-order method by\nplotting the solution for the pressure with and without stabilization. Without stabilization,\nthe solution oscillates heavily. Note that the scaling is chosen differently in the two images,\nwith the oscillations scaled down by a factor two in the unstabilized solution. The situation\nwithout stabilization is thus even worse than what the figure indicates.\n10.3 Convection\u2013Diffusion\nAs a final example, we compute the temperature u = u(x, t) around the dolphin (Figure 17)\nfrom the previous example by solving the time-dependent convection\u2013diffusion equations,\nu\u0307 + b * \u2207u \u2212 \u2207 * (c\u2207u) = f\nu = u\u2202\nu = u0\n\nin \u03a9 \u00d7 (0, T ],\non \u2202\u03a9 \u00d7 (0, T ],\nat \u03a9 \u00d7 {0},\n\n(127)\n\n\fAutomating the Finite Element Method\n\nFigure 15. The pressure for the flow around a two-dimensional dolphin, obtained\nby solving the Stokes equations (122) by an unstabilized P1 \u2013P1 approximation (above) and a stabilized P1 \u2013P1 approximation (below).\n\n59\n\n\f60\n\nAnders Logg\n\nFigure 16. The velocity field for the flow around a two-dimensional dolphin, obtained by solving the Stokes equations (122) by a P2 \u2013P1 Taylor-Hood\napproximation.\n\nFigure 17. The temperature around a hot dolphin in surrounding cold water with\na hot inflow, obtained by solving the convection\u2013diffusion equation with\nthe velocity field obtained from a solution of the Stokes equations with\na P2 \u2013P1 Taylor\u2013Hood approximation.\n\n\fAutomating the Finite Element Method\n\n61\n\nwith velocity field b = b(x) obtained by solving the Stokes equations.\nWe discretize (127) with the cG(1)cG(1) method, that is, with continuous piecewise\nlinear functions in space and time (omitting stabilization for simplicity). The interval [0, T ]\nis partitioned into a set of time intervals 0 = t0 < t1 < * * * < tn\u22121 < tn < * * * < tM = T and\non each time interval (tn\u22121 , tn ], we pose the variational problem\nZ tn Z\nZ tn Z\nv f dx dt \u2200v \u2208 V\u0302h ,\n(128)\n(v, U\u0307 ) + v b * \u2207U + c\u2207v * \u2207U dx dt =\ntn\u22121\n\n\u03a9\n\ntn\u22121\n\n\u03a9\n\nwith V\u0302h the space of all continuous piecewise linear functions in space. Note that the\ncG(1) method in time uses piecewise constant test functions, see [74, 73, 51, 39, 94]. As a\nconsequence, we obtain the following variational problem for U n \u2208 Vh = V\u0302h , the piecewise\nlinear in space solution at time t = tn ,\nZ\nU n \u2212 U n\u22121\nv\n+ v b * \u2207(U n + U n\u22121 )/2 + c \u2207v * \u2207(U n + U n\u22121 )/2 dx\nk\nn\n\u03a9\nZ tn Z\n(129)\nv f dx dt \u2200v \u2208 V\u0302h ,\n=\ntn\u22121\n\n\u03a9\n\nwhere kn = tn \u2212 tn\u22121 is the size of the time step. We thus obtain a variational problem of\nthe form\na(v, U n ) = L(v) \u2200v \u2208 V\u0302h ,\n(130)\nwhere\nkn\n(v b * \u2207U n + c \u2207v * \u2207U n ) dx,\n2\n\u03a9\nZ tn Z\nZ\n\u0001\nkn\nn\u22121\nn\u22121\nn\u22121\nv f dx dt.\nv b * \u2207U\n+ c \u2207v * \u2207U\nvU\ndx \u2212\ndx +\nL(v) =\n2\ntn\u22121 \u03a9\n\u03a9\n(131)\nn\n\na(v, U ) =\n\nZ\n\nv U n dx +\n\nThe corresponding specification in the FFC form language is presented in Table 30,\nwhere for simplicity we approximate the right-hand side with its value at the right endpoint.\n11 OUTLOOK: THE AUTOMATION OF CMM\nThe automation of the finite element method, as described above, constitutes an important step towards the Automation of Computational Mathematical Modeling (ACMM), as\noutlined in [96]. In this context, the automation of the finite element method amounts to\nthe automation of discretization, that is, the automatic translation of a given continuous\nmodel to a system of discrete equations. Other key steps include the automation of discrete\nsolution, the automation of error control, the automation of modeling and the automation\nof optimization. We discuss these steps below and also make some comments concerning\nautomation in general.\n11.1 The Principles of Automation\nAn automatic system carries out a well-defined task without intervention from the person or\nsystem actuating the automatic process. The task of the automating system may be formulated as follows: For given input satisfying a fixed set of conditions (the input conditions),\nproduce output satisfying a given set of conditions (the output conditions).\n\n\fAnders Logg\n\n62\n\nscalar = FiniteElement(\"Lagrange\", \"triangle\", 1)\nvector = FiniteElement(\"Vector Lagrange\", \"triangle\", 2)\nv\nU1\nU0\nb\nf\n\n=\n=\n=\n=\n=\n\nBasisFunction(scalar)\nBasisFunction(scalar)\nFunction(scalar)\nFunction(vector)\nFunction(scalar)\n\nc = 0.005\nk = 0.05\na = v*U1*dx + 0.5*k*(v*dot(b, grad(U1)) + c*dot(grad(v), grad(U1)))*dx\nL = v*U0*dx - 0.5*k*(v*dot(b, grad(U0)) + c*dot(grad(v), grad(U0)))*dx + k*v*f*dx\n\nTable 30. The complete specification of the variational problem (130) for cG(1)\ntime-stepping of the convection\u2013diffusion equation.\n\nAn automatic process is defined by an algorithm, consisting of a sequential list of instructions (like a computer program). In automated manufacturing, each step of the algorithm\noperates on and transforms physical material. Correspondingly, an algorithm for the Automation of CMM operates on digits and consists of the automated transformation of digital\ninformation.\nA key problem of automation is the design of a feed-back control, allowing the given\noutput conditions to be satisfied under variable input and external conditions, ideally at a\nminimal cost. Feed-back control is realized through measurement, evaluation and action;\na quantity relating to the given set of conditions to be satisfied by the output is measured,\nthe measured quantity is evaluated to determine if the output conditions are satisfied or\nif an adjustment is necessary, in which case some action is taken to make the necessary\nadjustments. In the context of an algorithm for feed-back control, we refer to the evaluation\nof the set of output conditions as the stopping criterion, and to the action as the modification\nstrategy.\nA key step in the automation of a complex process is modularization, that is, the hierarchical organization of the complex process into components or sub processes. Each sub\nprocess may then itself be automated, including feed-back control. We may also express this\nas abstraction, that is, the distinction between the properties of a component (its purpose)\nand the internal workings of the component (its realization).\nModularization (or abstraction) is central in all engineering and makes it possible to\nbuild complex systems by connecting together components or subsystems without concern\nfor the internal workings of each subsystem. The exact partition of a system into components is not unique. Thus, there are many ways to partition a system into components. In\nparticular, there are many ways to design a system for the Automation of Computational\nMathematical Modeling.\nWe thus identify the following basic principles of automation: algorithms, feed-back\ncontrol, and modularization.\n\n\fAutomating the Finite Element Method\n\n63\n\n11.2 Computational Mathematical Modeling\nIn automated manufacturing, the task of the automating system is to produce a certain\nproduct (the output) from a given piece of material (the input), with the product satisfying\nsome measure of quality (the output conditions).\nA(u) = f\nU \u2248u\nTOL > 0\n\nFigure 18. The Automation of Computational Mathematical Modeling.\n\nFor the Automation of CMM, the input is a given model of the form\nA(u) = f,\n\n(132)\n\nfor the solution u on a given domain \u03a9 \u00d7 (0, T ] in space-time, where A is a given differential\noperator and where f is a given source term. The output is a discrete solution U \u2248 u\nsatisfying some measure of quality. Typically, the measure of quality is given in the form\nof a tolerance TOL > 0 for the size of the error e = U \u2212 u in a suitable norm, kek \u2264 TOL,\nor alternatively, the error in some given functional M ,\n|M (U ) \u2212 M (u)| \u2264 TOL.\n\n(133)\n\nIn addition to controlling the quality of the computed solution, one may also want to determine a parameter that optimizes some given cost functional depending on the computed\nsolution (optimization). We refer to the overall process, including optimization, as the\nAutomation of CMM.\nThe key problem for the Automation of CMM is thus the design of a feed-back control\nfor the automatic construction of a discrete solution U , satisfying the output condition\n(133) at minimal cost. The design of this feed-back control is based on the solution of\nan associated dual problem, connecting the size of the residual R(U ) = A(U ) \u2212 f of the\ncomputed discrete solution to the size of the error e, and thus to the output condition (133).\n11.3 An Agenda for the Automation of CMM\nFollowing our previous discussion on modularization as a basic principle of automation, we\nidentify the following key steps in the Automation of CMM:\n(i) the automation of discretization, that is, the automatic translation of a continuous\nmodel of the form (132) to a system of discrete equations;\n(ii) the automation of discrete solution, that is, the automatic solution of the system of\ndiscrete equations obtained from the automatic discretization of (132),\n(iii) the automation of error control, that is, the automatic selection of an appropriate\nresolution of the discrete model to produce a discrete solution satisfying the given\naccuracy requirement with minimal work;\n\n\fAnders Logg\n\n64\n\n(iv) the automation of modeling, that is, the automatic selection of the model (132), either\nby constructing a model from a given set of data, or by constructing from a given\nmodel a reduced model for the variation of the solution on resolvable scales;\n(v) the automation of optimization, that is, the automatic selection of a parameter in the\nmodel (132) to optimize a given goal functional.\nIn Figure 19, we demonstrate how (i)\u2013(iv) connect to solve the overall task of the\nAutomation of CMM (excluding optimization) in accordance with Figure 18. We discuss\n(i)\u2013(v) in some detail below. In all cases, feed-back control, or adaptivity, plays a key role.\n\nU \u2248u\n\nA(u) = f\n(iv)\n\nA(\u016b) = f \u0304 + \u1e21(u)\nF (x) = 0\n(i)\n\n(V\u0302h , Vh )\n\n(ii)\n\nX\u2248x\n\nU \u2248u\n\ntol > 0\nU \u2248u\n\nTOL\n(iii)\n\nFigure 19. A modularized view of the Automation of Computational Mathematical\nModeling.\n\n11.4 The Automation of Discretization\nThe automation of discretization amounts to automatically generating a system of discrete\nequations for the degrees of freedom of a discrete solution U approximating the solution u\nof the given model (132), or alternatively, the solution u \u2208 V of a corresponding variational\nproblem\na(u; v) = L(v) \u2200v \u2208 V\u0302 ,\n(134)\nwhere as before a : V \u00d7 V\u0302 \u2192 R is a semilinear form which is linear in its second argument\nand L : V\u0302 \u2192 R is a linear form. As we saw in Section 3, this process may be automated\nby the finite element method, by replacing the function spaces (V\u0302 , V ) with a suitable pair\n(V\u0302h , Vh ) of discrete function spaces, and an approach to its automation was discussed in\nSections 4\u20136. As we shall discuss further below, the pair of discrete function spaces may be\nautomatically chosen by feed-back control to compute the discrete solution U both reliably\nand efficiently.\n\n\fAutomating the Finite Element Method\n\n65\n\n11.5 The Automation of Discrete Solution\nDepending on the model (132) and the method used to automatically discretize the model,\nthe resulting system of discrete equations may require more or less work to solve. Typically,\nthe discrete system is solved by some iterative method such as the conjugate gradient\nmethod (CG) or GMRES, in combination with an appropriate choice of preconditioner, see\nfor example [114, 32].\nThe resolution of the discretization of (132) may be chosen automatically by feed-back\ncontrol from the computed solution, with the target of minimizing the computational work\nwhile satisfying a given accuracy requirement. As a consequence, see for example [94], one\nobtains an accuracy requirement on the solution of the system of discrete equations. Thus,\nthe system of discrete equations does not need to be solved to within machine precision, but\nonly to within some discrete tolerance tol > 0 for some error in a functional of the solution\nof the discrete system. We shall not pursue this question further here, but remark that the\nfeed-back control from the computed solution to the iterative algorithm for the solution\nof the system of discrete equations is often weak, and the problem of designing efficient\nadaptive iterative algorithms for the system of discrete equations remains open.\n11.6 The Automation of Error Control\nAs stated above, the overall task is to produce a solution of (132) that satisfies a given\naccuracy requirement with minimal work. This includes an aspect of reliability, that is, the\nerror in an output quantity of interest depending on the computed solution should be less\nthan a given tolerance, and an aspect of efficiency, that is, the solution should be computed\nwith minimal work. Ideally, an algorithm for the solution of (132) should thus have the\nfollowing properties: Given a tolerance TOL > 0 and a functional M , the algorithm shall\nproduce a discrete solution U approximating the exact solution u of (132), such that\n(A) |M (U ) \u2212 M (u)| \u2264 TOL;\n(B) the computational cost of obtaining the approximation U is minimal.\nConditions (A) and (B) can be satisfied by an adaptive algorithm, with the construction of\nthe discrete representation (V\u0302h , Vh ) based on feed-back from the computed solution.\nAn adaptive algorithm typically involves a stopping criterion, indicating that the size\nof the error is less than the given tolerance, and a modification strategy to be applied if\nthe stopping criterion is not satisfied. Often, the stopping criterion and the modification\nstrategy are based on an a posteriori error estimate E \u2265 |M (U ) \u2212 M (u)|, estimating the\nerror in terms of the residual R(U ) = A(U ) \u2212 f and the solution \u03c6 of a dual problem\nconnecting to the stability of (132).\n11.6.1 The dual problem\n\nThe dual problem of (132) for the given output functional M is given by\n\u2217\n\nA\u2032 \u03c6 = \u03c8,\n\n(135)\n\n\u2217\n\non \u03a9 \u00d7 [0, T ), where A\u2032 denotes the adjoint10 of the Fr\u00e9chet derivative A\u2032 of A evaluated\nat a suitable mean value of the exact solution u and the computed solution U ,\nA\u2032\n10\n\n=\n\nZ\n\n1\n\nA\u2032 (sU + (1 \u2212 s)u) ds,\n\n(136)\n\n0\n\nThe adjoint is defined by (Av, w) = (v, A\u2217 w) for all v, w \u2208 V such that v = w = 0 at t = 0 and t = T .\n\n\fAnders Logg\n\n66\n\nand where \u03c8 is the Riesz representer of a similar mean value of the Fr\u00e9chet derivative M \u2032\nof M ,\n(v, \u03c8) = M \u2032 v \u2200v \u2208 V.\n(137)\nBy the dual problem (135), we directly obtain the error representation\n\u2217\n\nM (U ) \u2212 M (u) = M \u2032 (U \u2212 u) = (U \u2212 u, \u03c8) = (U \u2212 u, A\u2032 \u03c6) = (A\u2032 (U \u2212 u), \u03c6)\n= (A(U ) \u2212 A(u), \u03c6) = (A(U ) \u2212 f, \u03c6) = (R(U ), \u03c6).\n\n(138)\n\nNoting now that if the solution U is computed by a Galerkin method and thus (R(U ), v) = 0\nfor any v \u2208 V\u0302h , we obtain\nM (U ) \u2212 M (u) = (R(U ), \u03c6 \u2212 \u03c0h \u03c6),\n\n(139)\n\nwhere \u03c0h \u03c6 is a suitable approximation of \u03c6 in V\u0302h . One may now proceed to estimate the\nerror M (U ) \u2212 M (u) in various ways, either by estimating the interpolation error \u03c0h \u03c6 \u2212 \u03c6\nor by directly evaluating the quantity (R(U ), \u03c6 \u2212 \u03c0h \u03c6). The residual R(U ) and the dual\nsolution \u03c6 give precise information about the influence of the discrete representation (V\u0302h , Vh )\non the size of the error, which can be used in an adaptive feed-back control to choose a\nsuitable discrete representation for the given output quantity M of interest and the given\ntolerance TOL for the error, see [38, 17, 52, 94].\n11.6.2 The weak dual problem\n\nWe may estimate the error similarly for the variational problem (134) by considering the\nfollowing weak (variational) dual problem: Find \u03c6 \u2208 V\u0302 such that\n\u2217\n\na\u2032 (U, u; v, \u03c6) = M \u2032 (U, u; v)\n\n\u2200v \u2208 V,\n\n(140)\n\n\u2217\n\nwhere a\u2032 denotes the adjoint of the bilinear form a\u2032 , given as above by an appropriate\nmean value of the Fr\u00e9chet derivative of the semilinear form a. We now obtain the error\nrepresentation\n\u2217\n\nM (U ) \u2212 M (u) = M \u2032 (U, u; U \u2212 u) = a\u2032 (U, u; U \u2212 u, \u03c6) = a\u2032 (U, u; \u03c6, U \u2212 u)\n= a(U ; \u03c6) \u2212 a(u; \u03c6) = a(U ; \u03c6) \u2212 L(\u03c6).\n\n(141)\n\nAs before, we use the Galerkin orthogonality to subtract a(U ; \u03c0\u03c6) \u2212 L(\u03c0\u03c6) = 0 for some\n\u03c0h \u03c6 \u2208 V\u0302h \u2282 V\u0302 and obtain\nM (U ) \u2212 M (u) = a(U ; \u03c6 \u2212 \u03c0\u03c6) \u2212 L(\u03c6 \u2212 \u03c0\u03c6).\n\n(142)\n\nTo automate the process of error control, we thus need to automatically generate and\nsolve the dual problem (135) or (140) from a given primal problem (132) or (134). We\ninvestigate this question further in [61].\n11.7 The Automation of Modeling\nThe automation of modeling concerns both the problem of finding the parameters describing\nthe model (132) from a given set of data (inverse modeling), and the automatic construction\nof a reduced model for the variation of the solution on resolvable scales (model reduction).\nWe here discuss briefly the automation of model reduction.\nIn situations where the solution u of (132) varies on scales of different magnitudes,\nand these scales are not localized in space and time, computation of the solution may be\n\n\fAutomating the Finite Element Method\n\n67\n\nvery expensive, even with an adaptive method. To make computation feasible, one may\ninstead seek to compute an average \u016b of the solution u of (132) on resolvable scales. Typical\nexamples include meteorological models for weather prediction, with fast time scales on the\nrange of seconds and slow time scales on the range of years, or protein folding represented\nby a molecular dynamics model, with fast time scales on the range of femtoseconds and\nslow time scales on the range of microseconds.\nModel reduction typically involves extrapolation from resolvable scales, or the construction of a large-scale model from local resolution of fine scales in time and space. In both\ncases, a large-scale model\nA(\u016b) = f \u0304 + \u1e21(u),\n(143)\nfor the average \u016b is constructed from the given model (132) with a suitable modeling term\n\u1e21(u) \u2248 A(\u016b) \u2212 \u0100(u).\nReplacing a given model with a computable reduced model by taking averages in space\nand time is sometimes referred to as subgrid modeling. Subgrid modeling has received much\nattention in recent years, in particular for the incompressible Navier\u2013Stokes equations,\nwhere the subgrid modeling problem takes the form of determining the Reynolds stresses\ncorresponding to \u1e21. Many subgrid models have been proposed for the averaged Navier\u2013\nStokes equations, but no clear answer has been given. Alternatively, the subgrid model\nmay take the form of a least-squares stabilization, as suggested in [65, 64, 66]. In either\ncase, the validity of a proposed subgrid model may be verified computationally by solving an\nappropriate dual problem and computing the relevant residuals to obtain an error estimate\nfor the modeling error, see [77].\n11.8 The Automation of Optimization\nThe automation of optimization relies on the automation of (i)\u2013(iv), with the solution\nof the primal problem (132) and an associated dual problem being the key steps in the\nminimization of a given cost functional. In particular, the automation of optimization\nrelies on the automatic generation of the dual problem.\nThe optimization of a given cost functional J = J (u, p), subject to the constraint (132),\nwith p a function (the control variables) to be determined, can be formulated as the problem\nof finding a stationary point of the associated Lagrangian,\nL(u, p, \u03c6) = J (u, p) + (A(u, p) \u2212 f (p), \u03c6),\n\n(144)\n\nwhich takes the form of a system of differential equations, involving the primal and dual\nproblems, as well as an equation expressing stationarity with respect to the control variables p,\nA(u, p) = f (p),\n\u2032 \u2217\n\n(A ) (u, p)\u03c6 = \u2212\u2202J /\u2202u,\n\u2202J /\u2202p = (\u2202f /\u2202p)\u2217 \u03c6 \u2212 (\u2202A/\u2202p)\u2217 \u03c6.\n\n(145)\n\nIt follows that the optimization problem may be solved by the solution of a system of\ndifferential equations. Note that the first equation is the given model (132), the second\nequation is the dual problem and the third equation gives a direction for the update of the\ncontrol variables. The automation of optimization thus relies on the automated solution\nof both the primal problem (132) and the dual problem (135), including the automatic\ngeneration of the dual problem.\n\n\f68\n\nAnders Logg\n\n12 CONCLUDING REMARKS\nWith the FEniCS project [60], we have the beginnings of a working system automating\n(in part) the finite element method, which is the first step towards the Automation of\nComputational Mathematical Modeling, as outlined in [96]. As part of this work, a number\nof key components, FIAT, FFC and DOLFIN, have been developed. These components\nprovide reference implementations of the algorithms discussed in Sections 3\u20136.\nAs the current toolset, focused mainly on an automation of the finite element method\n(the automation of discretization), is becoming more mature, important new areas of research and development emerge, including the remaining key steps towards the Automation\nof CMM. In particular, we plan to explore the possibility of automatically generating dual\nproblems and error estimates in an effort to automate error control.\nACKNOWLEDGMENT\nThis work is in large parts based on the joint efforts of the people behind the FEniCS\nproject, in particular Todd Dupont, Johan Hoffman, Johan Jansson, Claes Johnson, Robert\nC. Kirby, Matthew G. Knepley, Mats G. Larson, L. Ridgway Scott, Andy Terrel and Garth\nN. Wells.\n\n\fAutomating the Finite Element Method\n\n69\n\nREFERENCES\n1 OpenDX, 2006. URL: http://www.opendx.org/.\n2 Tecplot, 2006. URL: http://www.tecplot.com/.\n3 S. E. Arge, A. M. Bruaset, and H. P. Langtangen, eds., Modern Software Tools for\nScientific Computing, Birkh\u00e4user, 1997.\n4 D. N. Arnold and R. Winther, Mixed finite elements for elasticity, Numer. Math., 92\n(2002), pp. 401\u2013419.\n5 I. Babu\u0161ka, Error bounds for finite element method, Numer. Math., 16 (1971), pp. 322\u2013333.\n6 B.\nBagheri\nand\nL.\nR.\nScott,\nAnalysa,\nhttp://people.cs.uchicago.edu/~ridg/al/aa.html.\n\n2003.\n\nURL:\n\n7 B. Bagheri and L. R. Scott, About Analysa, Tech. Rep. TR\u20132004\u201309, University of Chicago,\nDepartment of Computer Science, 2004.\n8 S. Balay, K. Buschelman, V. Eijkhout, W. D. Gropp, D. Kaushik, M. G. Knepley,\nL. C. McInnes, B. F. Smith, and H. Zhang, PETSc users manual, Tech. Rep. ANL-95/11\n- Revision 2.1.5, Argonne National Laboratory, 2004.\n9 S. Balay, K. Buschelman, W. D. Gropp, D. Kaushik, M. G. Knepley, L. C. McInnes,\nB. F. Smith, and H. Zhang, PETSc, 2006. URL: http://www.mcs.anl.gov/petsc/.\n10 S. Balay, V. Eijkhout, W. D. Gropp, L. C. McInnes, and B. F. Smith, Efficient\nmanagement of parallelism in object oriented numerical software libraries, in Modern Software\nTools in Scientific Computing, E. Arge, A. M. Bruaset, and H. P. Langtangen, eds., Birkh\u00e4user\nPress, 1997, pp. 163\u2013202.\n11 W. Bangerth, Using modern features of C++ for adaptive finite element methods:\nDimension-independent programming in deal.II, in Proceedings of the 16th IMACS World\nCongress 2000, Lausanne, Switzerland, 2000, M. Deville and R. Owens, eds., 2000. Document Sessions/118-1.\n12 W. Bangerth, R. Hartmann, and G. Kanschat, deal.II Differential Equations Analysis\nLibrary, 2006. URL: http://www.dealii.org/.\n13 W. Bangerth and G. Kanschat, Concepts for object-oriented finite element software \u2013 the\ndeal.II library, Preprint 99-43 (SFB 359), IWR Heidelberg, Oct. 1999.\n14 D. M. Beazley, SWIG : An easy to use tool for integrating scripting languages with C and\nC++, presented at the 4th Annual Tcl/Tk Workshop, Monterey, CA, (2006).\n15 D. M. Beazley et al., Simplified Wrapper and Interface Generator, 2006.\nhttp://www.swig.org/.\n\nURL:\n\n16 E. B. Becker, G. F. Carey, and J. T. Oden, Finite Elements: An Introduction, Prentice\u2013\nHall, Englewood\u2013Cliffs, 1981.\n17 R. Becker and R. Rannacher, An optimal control approach to a posteriori error estimation\nin finite element methods, Acta Numerica, 10 (2001), pp. 1\u2013102.\n18 L. S. Blackford, J. Demmel, J. Dongarra, I. Duff, S. Hammarling, G. Henry,\nM. Heroux, L. Kaufman, A. Lumsdaine, A. Petitet, R. Pozo, K. Remington, and\nR. C. Whaley, An updated set of Basic Linear Algebra Subprograms (BLAS), ACM Transactions on Mathematical Software, 28 (2002), pp. 135\u2013151.\n\n\fAnders Logg\n\n70\n\n19 D. Boffi, Three-dimensional finite element methods for the Stokes problem, SIAM J. Numer.\nAnal., 34 (1997), pp. 664\u2013670.\n20 S. C. Brenner and L. R. Scott, The Mathematical Theory of Finite Element Methods,\nSpringer-Verlag, 1994.\n21 F. Brezzi, On the existence, uniqueness and approximation of saddle-point problems arising\nfrom lagrangian multipliers, RAIRO Anal. Num\u00e9r., R\u20132 (1974), pp. 129\u2013151.\n22 F. Brezzi, J. Douglas, Jr., and L. D. Marini, Two families of mixed finite elements for\nsecond order elliptic problems, Numer. Math., 47 (1985), pp. 217\u2013235.\n23 F. Brezzi and M. Fortin, Mixed and hybrid finite element methods, vol. 15 of Springer Series\nin Computational Mathematics, Springer-Verlag, New York, 1991.\n24 A. M. Bruaset, H. P.\nhttp://www.diffpack.com/.\n\nLangtangen,\n\net\n\nal.,\n\nDiffpack,\n\n2006.\n\nURL:\n\n25 C. A. P. Castigliano, Th\u00e9orie de l'\u00e9quilibre des syst\u00e8mes \u00e9lastiques et ses applications, A.F.\nNegro ed., Torino, 1879.\n26 P. G. Ciarlet, Numerical Analysis of the Finite Element Method, Les Presses de l'Universite\nde Montreal, 1976.\n27\n\n, The Finite Element Method for Elliptic Problems, North-Holland, Amsterdam, New\nYork, Oxford, 1978.\n\n28 CIMNE International Center for Numerical Methods in Engineering, GiD, 2006.\nURL: http://gid.cimne.upc.es/.\n29 T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to Algorithms,\nThe MIT Press, second ed., 2001.\n30 R. Courant, Variational methods for the solution of problems of equilibrium and vibrations,\nBull. Amer. Math. Soc., 49 (1943), pp. 1\u201323.\n31 M. Crouzeix and P. A. Raviart, Conforming and nonconforming finite element methods\nfor solving the stationary stokes equations, RAIRO Anal. Num\u00e9r., 7 (1973), pp. 33\u201376.\n32 J. W. Demmel, Applied Numerical Linear Algebra, SIAM, 1997.\n33 M. Dubiner, Spectral methods on triangles and other domains, J. Sci. Comput., 6 (1991),\npp. 345\u2013390.\n34 P. Dular and C. Geuzaine, GetDP Reference Manual, 2005.\n35 P. Dular and C. Geuzaine, GetDP: a General environment for the treatment of Discrete\nProblems, 2006. URL: http://www.geuz.org/getdp/.\n36 T. Dupont, J. Hoffman, C. Johnson, R. C. Kirby, M. G. Larson, A. Logg, and L. R.\nScott, The FEniCS project, Tech. Rep. 2003\u201321, Chalmers Finite Element Center Preprint\nSeries, 2003.\n37 J. W. Eaton, Octave, 2006. URL: http://www.octave.org/.\n38 K. Eriksson, D. Estep, P. Hansbo, and C. Johnson, Introduction to adaptive methods\nfor differential equations, Acta Numerica, 4 (1995), pp. 105\u2013158.\n39\n\n, Computational Differential Equations, Cambridge University Press, 1996.\n\n\fAutomating the Finite Element Method\n\n71\n\n40 K. Eriksson, D. Estep, and C. Johnson, Applied Mathematics: Body and Soul, vol. III,\nSpringer-Verlag, 2003.\n41\n\n, Applied Mathematics: Body and Soul, vol. I, Springer-Verlag, 2003.\n\n42\n\n, Applied Mathematics: Body and Soul, vol. II, Springer-Verlag, 2003.\n\n43 K. Eriksson and C. Johnson, Adaptive finite element methods for parabolic problems III:\nTime steps variable in space, in preparation.\n44\n\n, Adaptive finite element methods for parabolic problems I: A linear model problem, SIAM\nJ. Numer. Anal., 28, No. 1 (1991), pp. 43\u201377.\n\n45\n\n, Adaptive finite element methods for parabolic problems II: Optimal order error estimates\nin l\u221e l2 and l\u221e l\u221e , SIAM J. Numer. Anal., 32 (1995), pp. 706\u2013740.\n\n46\n\n, Adaptive finite element methods for parabolic problems IV: Nonlinear problems, SIAM\nJ. Numer. Anal., 32 (1995), pp. 1729\u20131749.\n\n47\n\n, Adaptive finite element methods for parabolic problems V: Long-time integration, SIAM\nJ. Numer. Anal., 32 (1995), pp. 1750\u20131763.\n\n48 K. Eriksson, C. Johnson, J. Hoffman, J. Jansson, M. G. Larson, and\nA. Logg, Body and Soul applied mathematics education reform project, 2006. URL:\nhttp://www.bodysoulmath.org/.\n49 K. Eriksson, C. Johnson, and S. Larsson, Adaptive finite element methods for parabolic\nproblems VI: Analytic semigroups, SIAM J. Numer. Anal., 35 (1998), pp. 1315\u20131325.\n50 K. Eriksson, C. Johnson, and A. Logg, Explicit time-stepping for stiff ODEs, SIAM J.\nSci. Comput., 25 (2003), pp. 1142\u20131157.\n51 D. Estep and D. French, Global error control for the continuous Galerkin finite element\nmethod for ordinary differential equations, M2 AN, 28 (1994), pp. 815\u2013852.\n52 D. Estep, M. Larson, and R. Williams, Estimating the error of numerical solutions of\nsystems of nonlinear reaction\u2013diffusion equations, Memoirs of the American Mathematical Society, 696 (2000), pp. 1\u2013109.\n53 Free\nSoftware\nFoundation,\nhttp://www.gnu.org/copyleft/gpl.html.\n\nGNU\n\nGPL,\n\n1991.\n\nURL:\n\n54\n\n, GNU LGPL, 1999. URL: http://www.gnu.org/copyleft/lesser.html.\n\n55\n\n, The free software definition, 2006. URL: http://www.gnu.org/philosophy/free-sw.html.\n\n56 T.-P. Fries and H. G. Matthies, A review of Petrov\u2013Galerkin stabilization approaches and\nan extension to meshfree methods, Tech. Rep. Informatikbericht 2004\u201301, Institute of Scientific\nComputing, Technical University Braunschweig.\n57 B. G. Galerkin, Series solution of some problems in elastic equilibrium of rods and plates,\nVestnik inzhenerov i tekhnikov, 19 (1915), pp. 897\u2013908.\n58 G. H. Golub and C. F. van Loan, Matrix Computations, The Johns Hopkins University\nPress, third ed., 1996.\n59 F. Hecht, O. Pironneau, A. L. Hyaric, and K. Ohtsuka, FreeFEM++ manual, 2005.\n\n\fAnders Logg\n\n72\n\n60 J. Hoffman, J. Jansson, C. Johnson, M. G. Knepley, R. C. Kirby, A. Logg, L. R.\nScott, and G. N. Wells, FEniCS, 2006. http://www.fenics.org/.\n61 J. Hoffman, J. Jansson, C. Johnson, and A. Logg, Automation of duality-based error\ncontrol in finite element methods, in preparation, (2006).\n62 J. Hoffman, J. Jansson, A.\nhttp://www.fenics.org/dolfin/.\n63\n\nLogg,\n\nand\n\nG.\n\nN.\n\nWells,\n\nDOLFIN, 2006.\n\n, DOLFIN User Manual, 2006.\n\n64 J. Hoffman and C. Johnson, Encyclopedia of Computational Mechanics, Volume 3, Chapter\n7: Computability and Adaptivity in CFD, Wiley, 2004.\n65\n\n, A new approach to computational turbulence modeling, to appear in Comput. Meth.\nAppl. Mech. Engrg, (2004).\n\n66\n\n, Computational Turbulent Incompressible Flow: Applied Mathematics: Body and Soul\nVol 4, Springer-Verlag, 2006.\n\n67 J. Hoffman, C. Johnson, and A. Logg, Dreams of Calculus - Perspectives on Mathematics Education, Springer-Verlag, 2004.\n68 J. Hoffman and A. Logg, DOLFIN: Dynamic Object oriented Library for FINite element\ncomputation, Tech. Rep. 2002\u201306, Chalmers Finite Element Center Preprint Series, 2002.\n69\n\n, Puffin User Manual, 2004.\n\n70\n\n, Puffin, 2006. URL: http://www.fenics.org/puffin/.\n\n71 T. J. R. Hughes, The Finite Element Method: Linear Static and Dynamic Finite Element\nAnalysis, Prentice-Hall, 1987.\n72 T. J. R. Hughes, L. P. Franca, and M. Balestra, A new finite element formulation\nfor computational fluid dynamics. V. Circumventing the Babu\u0161ka-Brezzi condition: a stable\nPetrov-Galerkin formulation of the Stokes problem accommodating equal-order interpolations,\nComput. Methods Appl. Mech. Engrg., 59 (1986), pp. 85\u201399.\n73 B. L. Hulme, Discrete Galerkin and related one-step methods for ordinary differential equations, Math. Comput., 26 (1972), pp. 881\u2013891.\n74\n\n, One-step piecewise polynomial Galerkin methods for initial value problems, Math. Comput., 26 (1972), pp. 415\u2013426.\n\n75 International Organization for Standardization, ISO/IEC 14977:1996: Information\ntechnology - Syntactic metalanguage - Extended BNF, 1996.\n76 J. Jansson, Ko, 2006. URL: http://www.fenics.org/ko/.\n77 J. Jansson, C. Johnson, and A. Logg, Computational modeling of dynamical systems,\nMathematical Models and Methods in Applied Sciences, 15 (2005), pp. 471\u2013481.\n78\n\n, Computational elasticity using an updated lagrangian formulation, in preparation, (2006).\n\n79 J. Jansson, A. Logg, et al., Body and Soul Computer Sessions, 2006.\nhttp://www.bodysoulmath.org/sessions/.\n\nURL:\n\n80 D. A. Karpeev and M. G. Knepley, Flexible representation of computational meshes,\nsubmitted to ACM Trans. Math. Softw., (2005).\n\n\fAutomating the Finite Element Method\n\n81\n\n73\n\n, Sieve, 2006. URL: http://www.fenics.org/sieve/.\n\n82 R. C. Kirby, FIAT: A new paradigm for computing finite element basis functions, ACM Trans.\nMath. Software, 30 (2004), pp. 502\u2013516.\n, FIAT, 2006. URL: http://www.fenics.org/fiat/.\n\n83\n84\n\n, Optimizing FIAT with the level 3 BLAS, to appear in ACM Trans. Math. Software,\n(2006).\n\n85 R. C. Kirby, M. G. Knepley, A. Logg, and L. R. Scott, Optimizing the evaluation of\nfinite element matrices, SIAM J. Sci. Comput., 27 (2005), pp. 741\u2013758.\n86 R. C. Kirby, M. G. Knepley, and L. R. Scott, Evaluation of the action of finite element\noperators, submitted to BIT, (2005).\n87 R. C. Kirby and A. Logg, A compiler for variational forms, to appear in ACM Trans. Math.\nSoftw., (2006).\n88\n\n, Optimizing the FEniCS Form Compiler FFC: Efficient pretabulation of integrals, submitted to ACM Trans. Math. Softw., (2006).\n\n89 R. C. Kirby, A. Logg, L. R. Scott, and A. R. Terrel, Topological optimization of the\nevaluation of finite element matrices, to appear in SIAM J. Sci. Comput., (2005).\n90 Kitware, The Visualization ToolKit, 2006. URL: http://www.vtk.org/.\n91 M. G. Knepley and B. F. Smith,\nhttp://www-unix.mcs.anl.gov/ase/.\n\nANL SIDL Environment,\n\n2006.\n\nURL:\n\n92 H. P. Langtangen, Computational Partial Differential Equations \u2013 Numerical Methods and\nDiffpack Programming, Lecture Notes in Computational Science and Engineering, Springer,\n1999.\n, Python Scripting for Computational Science, Springer, second ed., 2005.\n\n93\n\n94 A. Logg, Multi-adaptive Galerkin methods for ODEs I, SIAM J. Sci. Comput., 24 (2003),\npp. 1879\u20131902.\n95\n\n, Multi-adaptive Galerkin methods for ODEs II: Implementation and applications, SIAM\nJ. Sci. Comput., 25 (2003), pp. 1119\u20131141.\n\n96\n\n, Automation of Computational Mathematical Modeling, PhD thesis, Chalmers University\nof Technology, Sweden, 2004.\n, Multi-adaptive time-integration, Applied Numerical Mathematics, 48 (2004), pp. 339\u2013\n\n97\n354.\n98\n\n, FFC, 2006. http://www.fenics.org/ffc/.\n\n99\n\n, FFC User Manual, 2006.\n\n100\n\n, Multi-adaptive Galerkin methods for ODEs III: A priori error estimates, SIAM J. Numer.\nAnal., 43 (2006), pp. 2624\u20132646.\n\n101 K. Long, Sundance, a rapid prototyping tool for parallel PDE-constrained optimization, in\nLarge-Scale PDE-Constrained Optimization, Lecture notes in computational science and engineering, Springer-Verlag, 2003.\n\n\fAnders Logg\n\n74\n\n102\n\n, Sundance 2.0 tutorial, Tech. Rep. TR\u20132004\u201309, Sandia National Laboratories, 2004.\n\n103\n\n, Sundance, 2006. URL: http://software.sandia.gov/sundance/.\n\n104 R. I. Mackie, Object oriented programming of the finite element method, Int. J. Num. Meth.\nEng., 35 (1992).\n105 I. Masters, A. S. Usmani, J. T. Cross, and R. W. Lewis, Finite element analysis of\nsolidification using object-oriented and parallel techniques, Int. J. Numer. Meth. Eng., 40 (1997),\npp. 2891\u20132909.\n106 J.-C. N\u00e9d\u00e9lec, Mixed finite elements in R3 , Numer. Math., 35 (1980), pp. 315\u2013341.\n107 T. Oliphant et al., Python Numeric, 2006. URL: http://numeric.scipy.org/.\n108 O. Pironneau, F. Hecht, A. L. Hyaric, and K. Ohtsuka, FreeFEM, 2006. URL:\nhttp://www.freefem.org/.\n109 R. C. Whaley and J. Dongarra\nhttp://math-atlas.sourceforge.net/.\n\nand\n\nothers,\n\nATLAS,\n\n2006.\n\nURL:\n\n110 P. Ramachandra, MayaVi, 2006. URL: http://mayavi.sourceforge.net/.\n111 P.-A. Raviart and J. M. Thomas, A mixed finite element method for 2nd order elliptic\nproblems, in Mathematical aspects of finite element methods (Proc. Conf., Consiglio Naz. delle\nRicerche (C.N.R.), Rome, 1975), Springer, Berlin, 1977, pp. 292\u2013315. Lecture Notes in Math.,\nVol. 606.\n112 Rayleigh, On the theory of resonance, Trans. Roy. Soc., A161 (1870), pp. 77\u2013118.\n113 W. Ritz, \u00dcber eine neue Methode zur L\u00f6sung gewisser Variationsprobleme der mathematischen Physik, J. reine angew. Math., 135 (1908), pp. 1\u201361.\n114 Y. Saad, Iterative Methods for Sparse Linear Systems, SIAM, second ed., 2003.\n115 A. Samuelsson and N.-E. Wiberg, Finite Element Method Basics, Studentlitteratur, 1998.\n116 Sandia National Laboratories, ParaView, 2006. URL: http://www.paraview.org/.\n117 G. Strang and G. J. Fix, An Analysis of the Finite Element Method, Prentice-Hall, Englewood Cliffs, 1973.\n118 The Mathworks, MATLAB, 2006. URL: http://www.mathworks.com/products/matlab/.\n119 R. C. Whaley and J. Dongarra, Automatically Tuned Linear Algebra Software, Tech. Rep. UT-CS-97-366, University of Tennessee, December 1997.\nURL:\nhttp://www.netlib.org/lapack/lawns/lawn131.ps.\n120 R. C. Whaley, A. Petitet, and J. J. Dongarra, Automated empirical optimization of software and the ATLAS project, Parallel Computing, 27 (2001), pp. 3\u201335. Also\navailable as University of Tennessee LAPACK Working Note #147, UT-CS-00-448, 2000\n(www.netlib.org/lapack/lawns/lawn147.ps).\n121 O. C. Zienkiewicz, R. L. Taylor, and J. Z. Zhu, The Finite Element Method - Its Basis\nand Fundamentals, 6th edition, Elsevier, 2005, first published in 1976.\n\n\fAutomating the Finite Element Method\n\nNOTATION\nA\nA\nA0\n\u01000\nAK\na\naK\naK\nA\nB\ne\nFK\nGK\ngK\nI\nIK\n\u03b9K\n\u03b9\u0302K\n\u03b9jK\nK\nK0\nL\nm\nN\nNj\nNq\nn0\nnK\nn\u0302K\nnjK\nN\nN\u0302\nNj\nN0\nNK\nN\u0302K\nj\nNK\n\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\nthe differential operator of the model A(u) = f\nthe global tensor with entries {Ai }i\u2208I\nthe reference tensor with entries {A0i\u03b1 }i\u2208IK ,\u03b1\u2208A\nthe matrix representation of the (flattened) reference tensor A0\nthe element tensor with entries {AK\ni }i\u2208IK\nthe semilinear, multilinear or bilinear form\nthe local contribution to a multilinear form a from K\nthe vector representation of the (flattened) element tensor AK\nthe set of secondary indices\nthe set of auxiliary indices\nthe error, e = U \u2212 u\nthe mapping from K0 to K\nthe geometry tensor with entries {G\u03b1K }\u03b1\u2208A\nthe vector representation of the (flattened) geometry tensor GK\nQ\nthe set rj=1 [1, N j ] of indices for the global tensor A\nQ\nthe set rj=1 [1, njK ] of indices for the element tensor AK (primary indices)\nthe local-to-global mapping from NK to N\nthe local-to-global mapping from N\u0302K to N\u0302\nj\nthe local-to-global mapping from NK\nto N j\na cell in the mesh T\nthe reference cell\nthe linear form (functional) on V\u0302 or V\u0302h\nthe number of discrete function spaces used in the definition of a\nthe dimension of V\u0302h and Vh\nthe dimension Vhj\nthe number of quadrature points on a cell\nthe dimension of P0\nthe dimension of PK\nthe dimension of P\u0302K\nj\nthe dimension of PK\nthe set of global nodes on Vh\nthe set of global nodes on V\u0302h\nthe set of global nodes on Vhj\nthe set of local nodes on P0\nthe set of local nodes on PK\nthe set of local nodes on P\u0302K\nj\nthe set of local nodes on PK\n\n75\n\n\fAnders Logg\n\n76\n\n\u03bdi0\n\u03bdiK\n\u03bd\u0302iK\n\u03bdiK,j\nP0\nP\u03020\nP0j\nPK\nP\u0302K\nj\nPK\nPq (K)\nPK\nR\nr\nU\n(Ui )\nu\nV\nV\u0302\nVh\nV\u0302h\nVhj\n|V |\n\u03a6i\n\u03a6\u0302i\n\u03a6ji\n\u03c6i\n\u03c6\u0302i\n\u03c6ji\n\u03c6K\ni\n\u03c6\u0302K\ni\n\u03c6K,j\ni\n\u03c6\nT\n\u03a9\n\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\u2013\n\na node on P0\na node on PK\na node on P\u0302K\nj\na node on PK\nthe function space on K0 for Vh\nthe function space on K0 for V\u0302h\nthe function space on K0 for Vhj\nthe local function space on K for Vh\nthe local function space on K for V\u0302h\nthe local function space on K for Vhj\nthe space of polynomials of degree \u2264 q on K\nj m\nthe local function space on K generated by {PK\n}j=1\nthe residual, R(U ) = A(U ) \u2212 f\nthe arity of the multilinear form a (the rank of A and AK )\nthe discrete approximate solution, U \u2248 u\nP\nthe vector of expansion coefficients for U = N\ni=1 Ui \u03c6i\nthe exact solution of the given model A(u) = f\nthe space of trial functions on \u03a9 (the trial space)\nthe space of test functions on \u03a9 (the test space)\nthe space of discrete trial functions on \u03a9 (the discrete trial space)\nthe space of discrete test functions on \u03a9 (the discrete test space)\na discrete function space on \u03a9\nthe dimension of a vector space V\na basis function in P0\na basis function in P\u03020\na basis function in P0j\na basis function in Vh\na basis function in V\u0302h\na basis function in Vhj\na basis function in PK\na basis function in P\u0302K\nj\na basis function in PK\nthe dual solution\nthe mesh\na bounded domain in Rd\n\n\f"}