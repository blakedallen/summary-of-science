{"id": "http://arxiv.org/abs/cs/0702007v1", "guidislink": true, "updated": "2007-02-01T12:02:23Z", "updated_parsed": [2007, 2, 1, 12, 2, 23, 3, 32, 0], "published": "2007-02-01T12:02:23Z", "published_parsed": [2007, 2, 1, 12, 2, 23, 3, 32, 0], "title": "Power Optimal Scheduling for Guaranteed Throughput in Multi-access\n  Fading Channels", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0001012%2Ccs%2F0001024%2Ccs%2F0001004%2Ccs%2F0001026%2Ccs%2F0001006%2Ccs%2F0001001%2Ccs%2F0702005%2Ccs%2F0702138%2Ccs%2F0702037%2Ccs%2F0702101%2Ccs%2F0702041%2Ccs%2F0702155%2Ccs%2F0702047%2Ccs%2F0702029%2Ccs%2F0702014%2Ccs%2F0702112%2Ccs%2F0702148%2Ccs%2F0702100%2Ccs%2F0702133%2Ccs%2F0702123%2Ccs%2F0702011%2Ccs%2F0702143%2Ccs%2F0702058%2Ccs%2F0702009%2Ccs%2F0702046%2Ccs%2F0702153%2Ccs%2F0702021%2Ccs%2F0702055%2Ccs%2F0702022%2Ccs%2F0702097%2Ccs%2F0702062%2Ccs%2F0702137%2Ccs%2F0702004%2Ccs%2F0702111%2Ccs%2F0702001%2Ccs%2F0702027%2Ccs%2F0702164%2Ccs%2F0702161%2Ccs%2F0702025%2Ccs%2F0702061%2Ccs%2F0702075%2Ccs%2F0702073%2Ccs%2F0702036%2Ccs%2F0702007%2Ccs%2F0702010%2Ccs%2F0702053%2Ccs%2F0702079%2Ccs%2F0702165%2Ccs%2F0702008%2Ccs%2F0702108%2Ccs%2F0702118%2Ccs%2F0702051%2Ccs%2F0702089%2Ccs%2F0702052%2Ccs%2F0702124%2Ccs%2F0702060%2Ccs%2F0702157%2Ccs%2F0702083%2Ccs%2F0702135%2Ccs%2F0702035%2Ccs%2F0702018%2Ccs%2F0702121%2Ccs%2F0702154%2Ccs%2F0702023%2Ccs%2F0702158%2Ccs%2F0702057%2Ccs%2F0702141%2Ccs%2F0702169%2Ccs%2F0702096%2Ccs%2F0702012%2Ccs%2F0702031%2Ccs%2F0702082%2Ccs%2F0702125%2Ccs%2F0702033%2Ccs%2F0702065%2Ccs%2F0702110%2Ccs%2F0702129%2Ccs%2F0702017%2Ccs%2F0702107%2Ccs%2F0702016%2Ccs%2F0702064%2Ccs%2F0702162%2Ccs%2F0702030%2Ccs%2F0702078%2Ccs%2F0702045%2Ccs%2F0702013%2Ccs%2F0702050%2Ccs%2F0702172%2Ccs%2F0702024%2Ccs%2F0702054%2Ccs%2F0702038%2Ccs%2F0702145%2Ccs%2F0702087%2Ccs%2F0702163%2Ccs%2F0702109%2Ccs%2F0702067%2Ccs%2F0702168%2Ccs%2F0702142%2Ccs%2F0702128%2Ccs%2F0702072%2Ccs%2F0702132&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Power Optimal Scheduling for Guaranteed Throughput in Multi-access\n  Fading Channels"}, "summary": "A power optimal scheduling algorithm that guarantees desired throughput and\nbounded delay to each user is developed for fading multi-access multi-band\nsystems. The optimization is over the joint space of all rate allocation and\ncoding strategies. The proposed scheduling assigns rates on each band based\nonly on the current system state, and subsequently uses optimal multi-user\nsignaling to achieve these rates. The scheduling is computationally simple, and\nhence scalable. Due to uplink-downlink duality, all the results extend in\nstraightforward fashion to the broadcast channels.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0001012%2Ccs%2F0001024%2Ccs%2F0001004%2Ccs%2F0001026%2Ccs%2F0001006%2Ccs%2F0001001%2Ccs%2F0702005%2Ccs%2F0702138%2Ccs%2F0702037%2Ccs%2F0702101%2Ccs%2F0702041%2Ccs%2F0702155%2Ccs%2F0702047%2Ccs%2F0702029%2Ccs%2F0702014%2Ccs%2F0702112%2Ccs%2F0702148%2Ccs%2F0702100%2Ccs%2F0702133%2Ccs%2F0702123%2Ccs%2F0702011%2Ccs%2F0702143%2Ccs%2F0702058%2Ccs%2F0702009%2Ccs%2F0702046%2Ccs%2F0702153%2Ccs%2F0702021%2Ccs%2F0702055%2Ccs%2F0702022%2Ccs%2F0702097%2Ccs%2F0702062%2Ccs%2F0702137%2Ccs%2F0702004%2Ccs%2F0702111%2Ccs%2F0702001%2Ccs%2F0702027%2Ccs%2F0702164%2Ccs%2F0702161%2Ccs%2F0702025%2Ccs%2F0702061%2Ccs%2F0702075%2Ccs%2F0702073%2Ccs%2F0702036%2Ccs%2F0702007%2Ccs%2F0702010%2Ccs%2F0702053%2Ccs%2F0702079%2Ccs%2F0702165%2Ccs%2F0702008%2Ccs%2F0702108%2Ccs%2F0702118%2Ccs%2F0702051%2Ccs%2F0702089%2Ccs%2F0702052%2Ccs%2F0702124%2Ccs%2F0702060%2Ccs%2F0702157%2Ccs%2F0702083%2Ccs%2F0702135%2Ccs%2F0702035%2Ccs%2F0702018%2Ccs%2F0702121%2Ccs%2F0702154%2Ccs%2F0702023%2Ccs%2F0702158%2Ccs%2F0702057%2Ccs%2F0702141%2Ccs%2F0702169%2Ccs%2F0702096%2Ccs%2F0702012%2Ccs%2F0702031%2Ccs%2F0702082%2Ccs%2F0702125%2Ccs%2F0702033%2Ccs%2F0702065%2Ccs%2F0702110%2Ccs%2F0702129%2Ccs%2F0702017%2Ccs%2F0702107%2Ccs%2F0702016%2Ccs%2F0702064%2Ccs%2F0702162%2Ccs%2F0702030%2Ccs%2F0702078%2Ccs%2F0702045%2Ccs%2F0702013%2Ccs%2F0702050%2Ccs%2F0702172%2Ccs%2F0702024%2Ccs%2F0702054%2Ccs%2F0702038%2Ccs%2F0702145%2Ccs%2F0702087%2Ccs%2F0702163%2Ccs%2F0702109%2Ccs%2F0702067%2Ccs%2F0702168%2Ccs%2F0702142%2Ccs%2F0702128%2Ccs%2F0702072%2Ccs%2F0702132&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A power optimal scheduling algorithm that guarantees desired throughput and\nbounded delay to each user is developed for fading multi-access multi-band\nsystems. The optimization is over the joint space of all rate allocation and\ncoding strategies. The proposed scheduling assigns rates on each band based\nonly on the current system state, and subsequently uses optimal multi-user\nsignaling to achieve these rates. The scheduling is computationally simple, and\nhence scalable. Due to uplink-downlink duality, all the results extend in\nstraightforward fashion to the broadcast channels."}, "authors": ["Prasanna Chaporkar", "Kimmo Kansanen", "Ralf R. M\u00fcller"], "author_detail": {"name": "Ralf R. M\u00fcller"}, "author": "Ralf R. M\u00fcller", "links": [{"href": "http://arxiv.org/abs/cs/0702007v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0702007v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.IT", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.IT", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0702007v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0702007v1", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "Power Optimal Scheduling for Guaranteed\nThroughput in Multi-access Fading Channels\nPrasanna Chaporkar, Kimmo Kansanen, Ralf R. M\u00fcller\nInstitute of Electronics and Telecommunications\nNorwegian University of Science and Technology\n\narXiv:cs/0702007v1 [cs.IT] 1 Feb 2007\n\nTrondheim, Norway\nAbstract\nA power optimal scheduling algorithm that guarantees desired throughput and bounded delay to\neach user is developed for fading multi-access multi-band systems. The optimization is over the joint\nspace of all rate allocation and coding strategies. The proposed scheduling assigns rates on each band\nbased only on the current system state, and subsequently uses optimal multi-user signaling to achieve\nthese rates. The scheduling is computationally simple, and hence scalable. Due to uplink-downlink\nduality, all the results extend in straightforward fashion to the broadcast channels.\n\nIndex Terms\nPower minimization, scheduling, stability, convex optimization, super-position encoding and\nsuccessive decoding.\n\nDRAFT\n\n\f1\n\nI. I NTRODUCTION\nWe consider a multi-access fading channel with N users and a single access point. Each user k\nrequires certain long term rate (throughput) guarantee ak . Our aim is to design a scheduling strategy\nthat arbitrates, in every slot, the instantaneous rate assignment to each user and coding strategy to\nrealize the assigned rates depending on the current fading states so that the throughput requirement\nfor each user is fulfilled and the total power expenditure is minimized.\nIn their seminal work, Tse and Hanly have characterized so called throughput capacity and delaylimited capacity of the multi-access fading channel with Gaussian noise [1], [2]. The throughput\ncapacity region quantifies the achievable rate region with average power constraint for ergodic fading.\nFor the delay limited capacity, each user must be given the required rate irrespective of its fading\nstates in every slot (strict delay of one slot). The aim here is to obtain a coding and power allocation\nscheme to minimize the energy.\nThe notion of throughput capacity leads to schemes that take advantage of users' differential channel\nqualities. Specifically, it is known that the sum throughput in the system is maximized by letting only\none user with the best channel transmit. Schemes that take current channel states into account while\nmaking scheduling decisions are referred to as \"Opportunistic Scheduling\" and may result in unfair\nrate allocation if the fading statistics are not symmetric which is typical in wireless systems. To\nalleviate this limitation, several opportunistic scheduling schemes with fairness constraints have been\ndesigned [3], [4]. Among them, Proportional Fair Scheduling (PFS) has many desirable properties\nincluding provable fairness guarantees and suitability for on-line implementation, i.e., without prior\nknowledge of channel statistics [5]. But, PFS does not guarantee the required throughput to users.\nUnlike opportunistic scheduling schemes, the delay-limited schemes guarantee the required throughput to every user. Specifically, super-position encoding and successive decoding is shown to minimize\npower for achieving the required throughputs [2]. But, the minimization is achieved under an additional\nconstraint that the required rate should be provided to each user in each slot irrespective of its channel\nstate. Thus, these schemes can not benefit from users' channel variability over time. Recently, we\nhave shown that the significant power saving can be achieved by exploiting a small delay tolerance\nof the application [6]. In absence of a specific delay constraint, the proposed scheme is shown to\nminimize power while guaranteeing the desired throughput and bounded delay for each user. The\noptimality result has been shown in asymptotic case, i.e., as the number of users go to infinity [6].\nOptimality for the finite users case has remained open.\nFor finite users case, [7], [8], [9] have found back-pressure based scheduling strategies to minimize\nthe energy consumption in the wireless system with ergodic fading while providing the required\n\nDRAFT\n\n\f2\n\nthroughputs and bounded delays to the users. These schemes assume that the coding strategy is\npredefined and for the given coding strategy determine the rate to be provided in each slot by solving\nan optimization problem. The optimization problem may be non-linear depending on coding/signaling\nstrategy used, and hence may become computationally expensive in practice.\nHere, we consider the finite users case, and propose a computationally simple power optimal scheme\nthat provides the required throughputs and bounded delays to the users. The optimization is over the\njoint space of coding and rate allocations. Specifically, the proposed optimal policy is back-pressure\nbased policy like that in [7], [8], [9], and employees super-position encoding and successive decoding\nin each slot. The proposed policy arbitrates scheduling based only on the users' current backlogs and\nthe channel states. In spite of using this limited information, it is shown to be optimal even in the\nclass of offline policies that take into account the channel states and arrivals in past, present and even\nthe future slots. One of the main challenges in execution of the proposed policy is that the optimal\nrate allocation can only be obtained by solving a convex optimization in every slot. But, we obtain\na computationally simple algorithm that exploits the problem structure and solves the optimization.\nAll the results extend in straightforward fashion to the broadcast case because of uplink-downlink\nduality [10].\nThe paper is arranged as follows. In Section II, we present our system model. In Section III, we\npresent some known results that we use. In Section IV, we propose our optimal policy and prove its\noptimality. In Section V, we conclude.\nII. S YSTEM M ODEL\nWe consider a multi-access channel with N users. Time is slotted. For each user k, let {Ak (t)}t\u22651\ndenote the random process of arrivals, i.e., Ak (t) denote the arrivals for k in slot t. We assume that\n~\nA(t)\n= [A1 (t) * * * AN (t)] are the independent and identically distributed (i.i.d.) random vectors\n\nacross the slots. Moreover, let ak = E[Ak (t)]. Alternatively, ak denotes the throughput requirement\nof user k. We assume that ak < \u221e for every k. The arrivals for each user k are queued in the infinite\n~\ncapacity buffer. We denote by Q(t)\n= [Q1 (t) * * * QN (t)], where Qk (t) is the backlog or queue length\n\nfor user k in slot t, i.e., Qk (t) is the difference between the total arrivals minus the total departures\nuntil time t.\nNow, we describe our channel model. We assume multi-band system. Specifically, we assume that\nthere are M non-interfering bands available for communication. Let d~k (t) = [dk,1 (t) * * * dk,M (t)]\ndenote the vector of channel gains for user k in slot t on each of the bands. Thus, if Ek,m (t) denotes\nthe transmit energy per symbol for user k on sub-band m in slot t, then the received energy on\nthe sub-band is given by dk,m (t)Ek,m (t). We assume that {d~k (t) : k = 1, . . . , n}t\u22651 is a positive\nDRAFT\n\n\f3\n\nrecurrent finite state Markov process. Note that this assumption is not restrictive as correlated Rician\nand Rayleigh fading channels can be modeled reasonably well using a finite state Markov process\n[11], [12]. Let N0 denote the noise power spectral efficiency.\nLet Rk,m (t) denote the service rate for user k on sub-band m in slot t. Then, for every k, the\nqueue length dynamics is characterized by\n(\n\nQk (t + 1) = max Qk (t) + Ak (t) \u2212\n\nM\nX\n\n)\n\nRk,m (t), 0 .\n\nm=1\n\nClearly, Rk,m (t) depends on the channel gains, transmit energies and the coding strategy used. We\nconsider the space of coding strategies such that the rates achieved on sub-band m is independent of\nthe rates on the other sub-bands. Alternatively, communications on various sub-bands are independent.\nNote that the communication on the same sub-band for various users may not be independent.\nDefinition 1 (Scheduling Strategy): A scheduling policy \u2206 arbitrates the rate allocation Rk,m (t)\nand coding strategy for every user k and sub-band m in every slot t.\nThis class includes offline policies that decide their rate allocation and coding based on the\nknowledge of arrivals and channel states in each past, present and even future slots.\n~\nWe assume that Q(t)\nand d~k (t) for every k is known and a scheduling policy can utilize this\n\nknowledge in its decision process. In case of a possible ambiguity, we use superscript \u2206 to indicate\n\u2206 (t) and E \u2206 (t) will denote the rate and transmit\nthe dependence of various terms on \u2206, e.g., Rk,m\nk,m\n\nenergy respectively for user k in sub-band m in slot t under \u2206.\nDefinition 2 (Stability): The multi-access system is said to be stable if the mean queue length\nin every slot t for every user k is upper bounded by a number that is independent on t, i.e.,\nsupt\u22651 {E[Qk (t)]} < \u221e for every k. A scheduling policy that stabilizes the system is called stable\n\nscheduling policy.\nNote that every stable scheduling policy guarantees the required throughput ak to every user k,\nand in addition, guarantees bounded delay for the arrivals.\nDefinition 3 (Power Efficiency): The power efficiency of scheduling policy \u2206 is defined as\nT N M\n1 XX X \u2206\nEk,m (t).\nT \u2192\u221e T t=1 k=1 m=1\nDefinition 4 (Optimality): A stable policy \u2206 is said to be optimal if with probability (w.p.) 1 it\n\nP \u2206 = lim sup\n\nattains the smallest power efficiency among all the stable policies.\nLet Pmin (C) be the infimum of the power efficiencies of all the stable policies in a class C of\nscheduling policies. If C does not contain any stable policy, then Pmin (C) is defined to be \u221e.\nFurthermore, let Pmin denote the optimal power efficiency, i.e., Pmin = Pmin (C) where C is the\nset of all policies.\n\nDRAFT\n\n\f4\n\nDefinition 5 (\u01eb-optimality): A scheduling policy \u2206 is said to be \u01eb-optimal in class C of scheduling\npolicies if it is stable and P \u2206 \u2264 Pmin (C) + \u01eb w.p. 1. Moreover, \u2206 is said to be \u01eb-optimal if it is\nstable and P \u2206 \u2264 Pmin + \u01eb w.p. 1.\nIII. BACKGROUND\nWe present the following known results for the sake of completeness. To be consistent, we state\nthese results in the notation introduced here.\nFix a sequence of coding strategies in every slot and let C denote the class of scheduling policies\nthat use this fixed sequence of the coding strategies. Also, let \u22061 (V ) \u2208 C denote a parametrized\nscheduling policy that assigns the rates by solving the optimization problem\nhP\ni\nPN\nP\nN\nV\nE\n(t)\n\u2212\nQ\n(t)R\n(t)\nMinimize: M\nk,m\nk\nk,m\nk=1\nk=1\nm=1\n\nSubject to: Rk,m (t) \u2265 0 for every k and m,\n\nwhere V is a fixed constant. Then, the following are the performance guarantees for \u22061 (V ).\nTheorem 1 (Result from [7], [8], [9]): For every \u01eb > 0, there exists Vb > 0 such that for every\n\nV > Vb , \u22061 (V ) is \u01eb-optimal in C .\n\nWe present the intuition for the result. Consider a case when Qk (t) is much smaller than V .\n\nBroadly, it implies that the user was receiving the desired rate in the past. Thus, \u22061 (V ) provides\npositive rate to the user only if the corresponding energy cost is much smaller, i.e., when the user's\nchannel gain is large. On the contrary, if Qk (t) is much larger than V , then it implies that the user\nwas not receiving the desired rate and also that the user's average channel gain is small. Thus, \u22061 (V )\nprovides positive rate to the user even when the user has, potentially, small channel gain in order to\npreserve stability. Alternatively, the current queue length represents the history of the rate provided\nto the user and its channel quality. Thus, \u22061 (V ) estimates users' desired throughput and channel\nquality using the current queue length, and then invests just enough power to maintain stability.\nGiven coding strategies, Theorem 1 provides a way to obtain \u01eb-optimal policies. Thus, it remains to\ndetermine how optimal coding strategy can be obtained in every slot. The following theorem provides\nuseful guidelines in this direction.\nTheorem 2 (Results in [2]): For a given rate assignment R1 , . . . , RN and channel states d1 , . . . , dN\nP\nthe total sum energy N\nk=1 Ek required to realize the rates is minimized by super-position coding and\n\nsuccessive decoding. Moreover, for optimal signaling, the successive decoding order depends only on\nchannel gains, but not on the rate assignment.\nLet ~\u03c0 denote the permutation that sorts the gains in the increasing order, i.e., d\u03c01 \u2264 d\u03c02 \u2264 * * * \u2264\nd\u03c0N . Then, the required transmit energy per symbol for user \u03c0k is given by\n\u0003 P\nN0 \u0002 R\u03c0\nE\u03c0k =\ne k \u2212 1 e i<k R\u03c0i .\nd\u03c0k\n\n(1)\n\nDRAFT\n\n\f5\n\nIV. \u01eb- OPTIMAL S CHEDULING P OLICY\nLet us define the following function for a fixed constant V .\n~ m (t)) def\nF (R\n=\n\nN\nX\nk=1\n\nwhere\n\n~\u03c0 m\n\nN\ni P\nX\nV N0 h R\u03c0m ,m (t)\nm\ni<k R\u03c0i ,m (t)\nk\n\u22121 e\n\u2212\ne\nQ\u03c0km (t)R\u03c0km ,m (t),\nd\u03c0km ,m (t)\nk=1\n\nis a permutation that sorts the gains on sub-band m in the increasing order. Now, let us\n\nconsider a parametrized scheduling policy \u2206\u2217 (V ) that assigns in every slot the rates Rk,m (t) that\nsolve\nOptimization (O1) - Minimize:\n\nPM\n\n~\n\nm=1 F (Rm (t))\n\nSubject to: Rk,m (t) \u2265 0 for every k and m,\nand then achieves the rates using super-position coding and successive decoding on each sub-band\n\u2206\u2217 (V )\n\nseparately. Clearly, Rk,m (t) = 0 for every m, if Qk (t) = 0. We show the following optimality\nresult for \u2206\u2217 (V ).\nTheorem 3: For every \u01eb > 0, there exists Vb > 0 such that for every V > Vb , \u2206\u2217 (V ) is \u01eb-optimal.\n\nProof: Let C \u2217 denote the class of scheduling policies that use super-position coding and successive\n\ndecoding in every slot. Then, we show that Pmin = Pmin (C \u2217 ).\nLet \u22061 denote any stable policy. Now, we construct \u22062 \u2208 C \u2217 as follows. For every k, m and\n\u22061\n\u22062\n(t). Clearly, \u22062 is also stable. Moreover, by Theorem 2, for every t\n(t) = Rk,m\nt choose Rk,m\nP\nPN\nPM PN\nM\n\u22061\n\u22062\n\u22061 \u2265 P \u22062 . Since, \u2206 is an\n1\nm=1\nk=1 Ek,m (t). Thus, by Definition 3, P\nm=1\nk=1 Ek,m (t) \u2264\n\narbitrary stable scheduling policy, we conclude that Pmin = Pmin (C \u2217 ).\nNow, the result follows from Theorem 1 and (1).\n\nNote that Theorem 3 provides a way to minimize power while stabilizing the system. The minimization is over the space of all coding and rate assignment strategies. The policy \u2206\u2217 (V ) achieves the\noptimality by taking into account only the current system state, and does not require the knowledge\nof statistics of the arrival and channel processes a priori. Moreover, optimality holds among the class\nof off-line scheduling policies. In spite of these desirable properties, \u2206\u2217 (V ) has one major limitation\nwhich is that it needs to solve a non-linear optimization (O1) in every slot to obtain the optimal rate\nassignment. Solving (O1) may be computationally expensive, and thereby limit the practicality of\n\u2206\u2217 (V ). In the following discussion, we focus on (O1) and derive certain properties of the optimal\n\nsolution and using these propose an algorithm that obtains optimal rate allocation with polynomial\ncomplexity.\nSince the communication on each of the sub-bands is independent, to solve (O1), it suffices to\nsolve separately for every m\n~ m (t))\nOptimization (O2) - Minimize: F (R\n\nSubject to: Rk,m (t) \u2265 0 for every k.\nDRAFT\n\n\f6\n\nMoreover, since the nature of optimization (objective function and constraints) is identical for every\nm, an algorithm to solve (O2) for a given m can be utilized for all m's. So, we fix m and t and\n\nfocus on (O2).\nIn the following discussion, for notational brevity, we omit m and t. Also, without loss of generality,\nlet \u03c0km = k. With this simplified notation (O2) becomes\n\u0003 P\n\u0002\n~ = PN V N0 eRk \u2212 1 e i<k Ri \u2212 PN Qk Rk\nMinimize: F (R)\nk=1 dk\nk=1\nSubject to: Rk \u2265 0 for every k.\n\nNote that (O2) is strictly convex (see Appendix I). This can be verified by checking that the Hessian\nis positive definite in the positive half plane [13]. For convex optimization, polynomial complexity\nalgorithms using the interior point method have been proposed [14]. These algorithms obtain a solution\nwithin \u03b4 > 0 neighborhood of the optimal value. The computational complexity of these algorithms is\nO(N 3 ) per accuracy digit [14]. We, however, propose the O(N 2 ) complexity algorithm that computes\n\nthe exact optimal solution.\nWe start by looking at the Lagrange relaxation of (O2).\n\u0003 P\n\u0002\n~ ~\u03bb) = PN V N0 eRk \u2212 1 e i<k Ri \u2212 PN (Qk + \u03bbk )Rk ,\nMinimize: F (R,\nk=1 dk\nk=1\n\nwhere ~\u03bb = {\u03bb1 , . . . , \u03bbN } are Lagrange multipliers. Now, for every k\n\nN\nX\n~ ~\u03bb)\n\u0001 Pi\u22121\n\u2202F (R,\nV N0 Ri\nV N0 Pki=1 Ri\n=\ne\n\u2212 (Qk + \u03bbk ).\ne \u2212 1 e u=1 Ru +\n\u2202Rk\ndi\ndk\n\n(2)\n\ni=k+1\n\n~~\n\n(R,\u03bb)\n= 0 for every k.\nLemma 1: The following relations satisfy \u2202F\u2202R\nk\nh\ni\uf8f6\n\uf8eb\n1\n[(Qk + \u03bbk ) \u2212 (Qk+1 + \u03bbk+1 )] dk\u22121\n\u2212 d1k\ni \uf8f8 for k > 1\nh\nRk = log \uf8ed\n1\n[(Qk\u22121 + \u03bbk\u22121 ) \u2212 (Qk + \u03bbk )] d1k \u2212 dk+1\n\uf8eb\n\uf8f6\n(Q1 + \u03bb1 ) \u2212 (Q2 + \u03bb2 ) \uf8f8\nh\ni\nR1 = log \uf8ed\n,\nV N0 d11 \u2212 d12\n\n(3)\n\n(4)\n\nby defining dN +1 = \u221e and QN +1 = \u03bbN +1 = 0.\n\nProof: We show the required by proving that for every k,\nP\n\ne\n\nu\u2264k\n\nRu\n\n=\n\n~ ~\n\u2202F (R,\n\u03bb)\n\u2202Rk\n\n(Qk + \u03bbk ) \u2212 (Qk+1 + \u03bbk+1 )\nh\ni\n.\n1\nV N0 d1k \u2212 dk+1\n\n= 0 implies\n\n(5)\n\nWe prove the above using induction on k.\n\nAs a base case we show (5) for k = N . Note that substituting k = N in (2) and equating it to 0,\nwe obtain (5). Thus, (5) holds for k = N . Now, for induction, we assume that (5) holds for every\nk \u2265 s + 1 and verify it for k = s.\n\nDRAFT\n\n\f7\n\nConsider the second term in (2) with k = s.\nN\nX\n\u0001 Pi\u22121\nV N0 Ri\ne \u2212 1 e u=1 Ru\ndi\n\ni=s+1\n\n=\n\nN\nN\nX\nX\nV N0 Pi\u22121\nV N0 Piu=1 Ru\ne\ne u=1 Ru\n\u2212\ndi\ndi\ni=s+1\n\ni=s+1\n\n=\n\nN\n\u22121\nX\n\ni=s+1\n\nV N0\n\n\u0014\n\n\u0015\n\nPi\n1\nV N0 PNu=1 Ru V N0 Psu=1 Ru\n1\n\u2212\ne\ne\ne u=1 Ru +\n\u2212\ndi di+1\ndN\nds+1\n\n= (Qs+1 + \u03bbs+1 ) \u2212\n\nV N0 Psu=1 Ru\ne\n.\nds+1\n\nLast equality follows from (5) and the induction hypothesis. Now, substituting the above in (2), we\nobtain the desired.\nFinally, (3) follows by observing Rk = log\nk = 1.\n\n\u0012\n\nPk\n\ne u=1 Ru\nPk\u22121\ne u=1 Ru\n\n\u0013\n\nand (4) is obtained directly from (5) with\n\n~ \u2032 and ~\u03bb\u2032 are said to satisfy Karush-Kuhn-Tucker\nDefinition 6 (From [15], pp. 328): The vectors R\n\n(KKT) conditions if they satisfy the following relations.\n~ ~\u03bb)\n\u2202F (R,\n\u2202Rk\n\n= 0 for every k\n\n(6)\n\n\u2265 ~0\n\n(7)\n\n~\u03bb\u2032 \u2265 ~0\n\n(8)\n\n~ R\n~\u2032\nR=\n~\u2032\n\nR\n\nRk\u2032 \u03bb\u2032k = 0 for every k.\n\n(9)\n\nSince (O2) is strictly convex in the feasible region, we conclude the following [15].\n1) The optimal solution is unique.\n~ \u2032 is optimal iff there exists ~\u03bb\u2032 such that R\n~ \u2032 and ~\u03bb\u2032 satisfy the KKT conditions.\n2) The rate allocation R\n\nAlso, such ~\u03bb\u2032 is unique since linear independence constraint qualification holds.\n~ and Lagrange\nIn Figure 1, we propose a general procedure for obtaining a rate allocation R\n~ and d~. We first intuitively describe the\nmultipliers ~\u03bb that satisfy the KKT conditions for any given Q\n\nproposed algorithm and subsequently prove that the algorithm optimally solves (O2).\n~ and the\nThe main procedure Computation of Optimal Rates takes current queue length vector Q\n~ . In this procedure, we define two\nchannel gains d~ as input and outputs the optimal rate allocation R\n\nsets A and E that partition the set of all users. The set A (E , resp.) denotes the set of active (inactive,\nresp.) users. A user k is said to be active if Rk > 0, i.e., it is served at positive rate; k is inactive\notherwise. Initially, all the users are assumed to be active (Line 1). Next, the algorithm iterates and\nin each iteration determines an inactive user using (10) and (11) (Line 2). Once the inactive user is\ndetermined the sets A and E are updated (Lines 3 and 4), and subsequently the Lagrange multipliers\nDRAFT\n\n\f8\n\n~ ,d~)\nComputation of Optimal Rates(Q\nbegin\n1: Initialize A \u2190 {1, . . . , N }, E \u2190 \u03c6 and ~\u03bb \u2190 ~0\n2: while There exists k \u2208 A such that\n(Qk\u22121 + \u03bbk\u22121 )\nQk\n\nQ1\n\n<\n\n<\n\nV N0\n\n\u00bb\n\n1\n1\n\u2212\nd1\nd2\n\nh\n\n\u2013\n\n1\ndk\n\n\u2212\n\n1\ndk+1\n\nh\n\ni\n\n1\ndk\u22121\n\n+ (Qk+1 + \u03bbk+1 )\ni\n\u2212d1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\nfor k > 1\n\n(10)\n\nk+1\n\n+ (Q2 + \u03bb2 )\n\n(11)\n\ndo\n\n3:\n4:\n5:\n\nE \u2190 E \u222a {k}\nA \u2190 A \u2212 {k}\nUpdate Lagrange Multipliers(A, E)\n{/* Optimal Rate computation */}\n\n6: Rk \u2190 0 for every k \u2208 E\n7: Compute Rk for every k \u2208 A using (3) and (4)\n\nend\nUpdate Lagrange Multipliers(A, E )\nbegin\n1: \u03bbk \u2190 0 for every k \u2208 E\n2: if {1, . . . , u \u2212 1} \u2286 E and u \u2208 A then\n3:\nfor every m \u2208 {1, . . . , u \u2212 1}\n\u03bbm \u2190 V N0\n\n\u00bb\n\n1\n1\n\u2212\ndm\ndu\n\n\u2013\n\n+ (Qu \u2212 Qm ).\n\n(12)\n\n4: if {v + 1, . . . , u \u2212 1} \u2286 A and {v, u} \u2286 E then\n5:\nfor every m \u2208 {v + 1, . . . , u \u2212 1}\nQv\n\u03bbm \u2190\n\nh\n\n1\ndm\n\n\u2212\n\n1\ndu\n\nh\n\ni\n\n1\ndv\n\nh\n+ Qu d1 \u2212\ni v\n\u2212 d1\n\n1\ndm\n\ni\n\n\u2212 Qm .\n\n(13)\n\nu\n\nend\n\nFig. 1.\n\nFigure shows the pseudo code of an algorithm that computes the optimal rate allocation in a given slot\n\nare also updated (Line 5). If no user in A satisfy (10) and (11), then the algorithm terminates after\ncomputing the rate allocation using (3) and (4) (Lines 6 and 7). This ensures that (6) is satisfied for\nall k \u2208 E . Now, we explain why a user satisfying (10) or (11) should be inactive. Note that (10)\nand (11) are equivalent to Rk < 0 in (3) and (4), respectively. Since the assigned rates can only be\nnon-negative, we put such a user k in E and update corresponding \u03bbk so as to ensure Rk = 0.\nNow, we briefly explain how the procedure Update Lagrange Multipliers computes Lagrange multipliers in each iteration. Note that for every active user k, \u03bbk must be zero in order to satisfy the\nKKT condition (9). Thus in the first step, the procedure assigns \u03bbk = 0 for every k \u2208 A (Line 1).\nDRAFT\n\n\f9\n\nNext, for every k \u2208 E , it computes \u03bbk so that Rk in (3) or (4) equals zero (Lines 2 to 5). This ensures\nthat (6), (7) and (9) hold for every k \u2208 A. We need to recompute all the Lagrange multipliers in\nevery iteration because the value of \u03bbk is a function of \u03bbk\u22121 and \u03bbk+1 as can be seen from (3) and\n(4).\nEven though the algorithm is straightforward, mainly, two questions are unanswered. First, whether\n\u03bbk is non-negative for every k \u2208 E . Second, since the \u03bbk 's for many users (not only the recently\n\nadded user) in E are updated, how is it ensured that an inactive user does not become active in the\nsubsequent iterations. We formally address these questions and prove the optimality of the proposed\nalgorithm.\n~ \u2217 and ~\u03bb\u2217 denote the rate vector\nFor analysis, we introduce the following additional notation. Let R\n\nand Lagrange multipliers computed by the algorithm at termination. Also, let A\u2217 and E \u2217 denote the\nsets A and E , respectively, when the algorithm terminates. Next, we distinguish between the value\nof ~\u03bb, A and E computed by the algorithms in every iteration. Let ~\u03bbi , Ai and E i denote ~\u03bb, A and\nE , respectively, computed by the algorithm in ith iteration. Because of the initialization in Line 1 of\n\nprocedure Computation of Optimal Rates, ~\u03bb0 = ~0, A0 = {1, . . . , N } and E 0 = \u03c6. Let the algorithm\nterminate in I iterations. Then, clearly, I \u2264 N and ~\u03bbI = ~\u03bb\u2217 , AI = A\u2217 and E I = E \u2217 . Now, we show\nthe following result.\n~ \u2217 and ~\u03bb\u2217 satisfy the KKT conditions.\nLemma 2: If ~\u03bb\u2217 \u2265 ~0, then R\n\nProof: Note that for every k \u2208 A\u2217 , Rk\u2217 is computed using (3) and (4). Thus by Lemma 1,\nclearly, (6) is satisfied for every k \u2208 A\u2217 . Now, we show that (6) also holds for every k \u2208 E \u2217 . Note\nthat Rk\u2217 = 0 for every k \u2208 E \u2217 . Thus, it suffices to show that when the chosen ~\u03bb\u2217 is substituted in\n(3) and (4) yields Rk\u2217 = 0 for every k \u2208 E \u2217 . The required can be easily verified using elementary\nalgebra. Thus (6) holds for every k.\nNow, we show that ~\u03bb\u2217 satisfy (7). Since, Rk\u2217 = 0 for every k \u2208 E \u2217 , (7) clearly holds for every\nk \u2208 E \u2217 . Now, we show (7) for every k \u2208 A\u2217 . We show the required using contradiction. Let there\n\nbe k \u2208 A\u2217 such that Rk\u2217 < 0. But then from (3) and (4) it implies that\nh\nh\ni\n1\n1\n(Qk\u22121 + \u03bb\u2217k\u22121 ) d1k \u2212 dk+1\n+ (Qk+1 + \u03bb\u2217k+1 ) dk\u22121\n\u2212\nh\ni\nQk <\n1\n1\ndk\u22121 \u2212 dk+1\n\u0015\n\u0014\n1\n1\n\u2212\n+ (Qk+1 + \u03bb\u2217k+1 ) if k = 1.\nQk < V N0\ndk\ndk+1\n\n1\ndk\n\ni\n\nif k > 1\n\nNow, from (10) and (11), we conclude that the algorithm will not terminate, but instead add k to E\n~ \u2217 satisfy (7).\nand continue. Thus, no such index exists. So, ~\u03bb\u2217 and R\n~ \u2217 satisfy (8) because of the supposition in the lemma. Moreover, the vectors\nThe vectors ~\u03bb\u2217 and R\n\nsatisfy (9) because Rk\u2217 = 0 for every k \u2208 E \u2217 , while \u03bb\u2217k = 0 for every k \u2208 A\u2217 .\nDRAFT\n\n\f10\n\nIn the following theorem, we show that ~\u03bb\u2217 is non-negative.\nTheorem 4: For every i < I , ~\u03bbi \u2264 ~\u03bbi+1 .\nNote that since ~\u03bb0 = ~0, Theorem 4 implies that ~\u03bb\u2217 \u2265 ~0. We prove the above theorem by showing\nthe required in each of the cases that may be arise in the execution of the algorithm. The proofs use\nelementary algebra. For better readability, proofs for all the cases are given in Appendix II.\nFinally, we prove the optimality of the proposed algorithm.\n~ \u2217 is the unique optimal solution of (O2).\nTheorem 5: The rate allocation R\n\nProof: The result follows immediately from the strict convexity of (O2), Lemma 2 and Theorem 4.\nV. C ONCLUSION\nWe have considered a multi-access channel with N -users. We have proposed a parametrized\nscheduling policy \u2206\u2217 (V ) which is \u01eb-optimal for every \u01eb > 0 for appropriate choice of the parameter\nV even among the offline strategies in spite of considering only the current queue lengths and channel\n\ngains in its decision process. Moreover, the optimization is over the joint space of coding and rate\nallocation strategies. The policy \u2206\u2217 (V ) needs to solve a convex optimization in every slot to obtain the\noptimal rate allocation. We have proposed a O(N 2 ) algorithm that accurately solves the optimization.\nAll the results extend in straightforward fashion to broadcast case because of uplink-downlink duality.\nR EFERENCES\n[1] D. Tse and S. Hanly, \"Multi-access fading channels-part i: Polymatroid structure, optimal resource allocation and\nthroughput capacities,\" IEEE Transactions on Information Theory, vol. 44, no. 7, pp. 2796\u20132815, Nov. 1998.\n[2] S. Hanly and D. Tse, \"Multi-access fading channels-part ii: Delay-limited capacities,\" IEEE Transactions on\nInformation Theory, vol. 44, no. 7, pp. 2816\u20132831, Nov. 1998.\n[3] P. Bender, P. Black, M. Grob, R. Padovani, N. Sindhushayana, and A. Viterbi, \"Cdma/hdr: A bandwidth-efficient\nhigh-speed wireless data service for nomadic users,\" IEEE Commun. Mag., vol. 38, no. 7, pp. 70\u201377, Jul. 2000.\n[4] D. Tse, \"Multiuser diversity through proportional fair scheduling,\" in Communication theory workshop, May 2001.\n[5] P. Viswanath, D. Tse, and R. Laroia, \"Opportunistic beamforming using dumb antennas,\" IEEE Transactions on\nInformation Theory, vol. 48, no. 6, Jun. 2002.\n[6] P. Chaporkar, K. Kansanen, and R. M\u00fcller, \"Channel and multiuser diversities in wireless systems: Delayenergy tradeoff,\" Norwegian University of Science and Technology, Trondheim, Norway, Tech. Rep., Dec 2006,\nhttp://www.iet.ntnu.no/\u223cralf/Publications.html.\n[7] P. Chaporkar and S. Sarkar, \"Stable scheduling policies for maximizing throughput in generalized constrained\nqueueing,\" in IEEE INFOCOM'06, Barcelona, Spain, Apr. 2006.\n[8] M. Neely, \"Energy optimal control for time varying wireless networks,\" in IEEE INFOCOM'05, Mar. 2005.\n[9] A. Stolyar, \"Maximizing queueing network utility subject to stability: Greedy primal-dual algorithm,\" Queueing\nSystems, vol. 50, no. 4, pp. 401\u2013457, Aug. 2005.\n\nDRAFT\n\n\f11\n\n[10] N. Jindal, S. Vishwanath, and A. Goldsmith, \"On duality of gaussian multiple-access and broadcast channels,\" IEEE\nTransactions on Information Theory, vol. 50, no. 5, pp. 768\u2013783, May 2004.\n[11] Q. Zhang and S. Kassam, \"Finite state markov model for rayleigh fading channel,\" IEEE Transactions on communications, vol. 47, no. 11, pp. 1688\u20131692, Nov 1999.\n[12] C. Pimentel, T. Falk, and L. Lisboa, \"Finite-state markov modeling of correlated rician-fading channels,\" IEEE\ntransactions on vehicular technology, vol. 53, no. 5, pp. 1491\u20131501, May 2004.\n[13] S. Boyd and L. Vandenberghe, Convex Optimization.\n\nCambridge University Press, Mar 2004.\n\n[14] Y. Nesterov and A. Nemirovskii, Interior-Point Polynomial Algorithms in Convex Programming, ser. Studies in Applied\nand Numerical Mathematics.\n\nSociety for Industrial & Applied Mathematics, Jul 1995.\n\n[15] J. Nocedal and S. J. Wright, Numerical optimization.\n\nNew York: Springer-Verlag, 1999.\n\nA PPENDIX I\nC ONVEXITY\n\nOF\n\nO PTIMIZATION (O2)\n\n~ is as follows.\nThe second partial derivative of F (R)\n\uf8f1 P\nPk\n\u0001 Pi\u22121\nN\nV N0\n\uf8f2\n~\neRi \u2212 1 e u=1 Ru + VdNk 0 e i=1 Ri\n\u2202 2 F (R)\ni=k+1 di\n=\nP\n\u0001 Pi\u22121\nV N0\n\uf8f3 V N0 e ju=1 Ru + PN\n\u2202Rk \u2202Rj\neRi \u2212 1 e u=1 Ru\ni=j+1\n\ndj\n\n~ \u2208 [0, \u221e)N ,\nNote that for every R\n\n~\n\u2202 2 F (R)\n\u2202Rk \u2202Rj\n\ndi\n\n: j\u2264k\n: j > k.\n\n> 0 for any k and j . This shows that the Hessian of\n\n~ is positive definite. Also, it is clear that the feasible region [0, \u221e)N is a convex set. Thus, (O2)\nF (R)\n\nis an instance of convex optimization.\nA PPENDIX II\nS UPPORTING L EMMAS\n\nFOR\n\nP ROVING T HEOREM 4\n\nLemma 3: Let index k be added to the set E i\u22121 in the ith iteration. Then for all users u such that\nthere exists v \u2208 Ai between k and u, \u03bbiu = \u03bbi\u22121\nu .\nProof: The proof follows immediately from the procedure Update Lagrange Multipliers in Figure 1.\nLemma 4: Let index k be added to the set E i\u22121 in the ith iteration. Also, let {k \u2212 1, k + 1} \u2208 Ai\u22121 .\n\u2265 0 for every n.\nThen, \u03bbin \u2212 \u03bbi\u22121\nn\n= 0.\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\nk\n\nSecond, from (10)\nQk <\n\ni\u22121\n)\n(Qk\u22121 + \u03bbk\u22121\n\nh\n\n1\ndk\n\n\u2212\n\n1\n\ni\n\ni\u22121\ndk+1 + (Qk+1 + \u03bbk+1 ))\ni\nh\n1\n1\n\u2212\ndk\u22121\ndk+1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(14)\n\ni\u22121\n= \u03bbi\u22121\nNote that \u03bbk\u22121\nk+1 = 0. Thus the result follows from (13), (14) and Lemma 3.\n\nLemma 5: Let index 1 be added to the set E i\u22121 in the ith iteration. Also, let {2, . . . , m\u22121} \u2286 E i\u22121\n\u2265 0 for every n.\nand m 6\u2208 E i\u22121 . Then, \u03bbin \u2212 \u03bbi\u22121\nn\nDRAFT\n\n\f12\n\nProof: Since index 1 is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\n1\nSecond, from (11)\nQ1 < V N0\n\n\u0014\n\n\u0015\n1\n1\n\u2212\n+ (Q2 + \u03bbi\u22121\n2 ).\nd1 d2\n\n(15)\n\nMoreover, since {2, . . . , m\u22121} \u2286 E i\u22121 and m 6\u2208 E i\u22121 , we also know that for every n \u2208 {2, . . . , m\u2212\n1},\n\u03bbi\u22121\n=\nn\n\nh\n\nQ1\n\n1\ndn\n\n1\ndm\n\n\u2212\n\nh\n\ni\n\n1\nd1\n\n+ Qm\ni\n\u2212 d1m\n\nNow, substituting \u03bbi\u22121\nfrom (16) in (15), we obtain\n2\nQ1 < V N0\n\n=\u21d2 Q1 < V N0\n\n\u0014\n\n\u0014\n\n\u0015\n\n1\n1\n\u2212\n+\nd1 d2\n\nQ1\n\nh\n\nh\n\n1\nd1\n\n1\nd2\n\n1\ndn\n\n\u2212\n\n\u2212\n\n\u0015\n1\n1\n\u2212\n+ Qm .\nd1 dm\n\n1\ndm\n\nh\n\ni\n\ni\n\n1\nd1\n\n\u2212 Qn .\n\n+ Qm\ni\n\u2212 d1m\n\nh\n\n(16)\n\n1\nd1\n\n\u2212\n\n1\nd2\n\ni\n\n(17)\n\nNow, note that from (12), for every n = 1, . . . , m \u2212 1\n\u0015\n\u0014\n1\n1\ni\n\u2212\n\u03bbn = V N0\n+ (Qm \u2212 Qn ).\ndn dm\n\n(18)\n\nFrom (17), clearly, \u03bbi1 > 0. Now, from (16) and (18), it follows that for every n = 2, . . . , m \u2212 1\nh\ni\ni\nh\n1\n1\n1\n1\n\u0015\n\u0014\n+\nQ\n\u2212\n\u2212\nQ\nm\n1\ndn\ndm\nd1\ndn\n1\n1\ni\nh\n+ Qn\n\u2212\n+ (Qm \u2212 Qn ) \u2212\n\u03bbin \u2212 \u03bbi\u22121\n= V N0\nn\n1\n1\ndn dm\n\u2212\nd1\ndm\ni\nh\n1\n1\ndn \u2212 dm\ni \u03bbi1 \u2265 0.\n= h\n1\n1\nd1 \u2212 dm\n\nThe last inequality follows from the fact that dk \u2264 dk+1 for every k and \u03bbi1 > 0. Furthermore, by\n\nLemma 3, for n 6\u2208 {1, . . . , m \u2212 1}, \u03bbi\u22121\n= \u03bbin . Thus, the result follows.\nn\nLemma 6: Let index k > 1 be added to the set E i\u22121 in the ith iteration. Also, let {v+1, . . . , k\u22121} \u2286\nE i\u22121 and {v, k + 1} \u2286 Ai . Then, \u03bbin \u2212 \u03bbi\u22121\n\u2265 0 for every n.\nn\n\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\nk\nSecond, from (10)\nQk <\n\ni\u22121\n(Qk\u22121 + \u03bbk\u22121\n)\n\nh\n\n1\ndk\n\n\u2212\n\ni\n\n+ (Qk+1 + \u03bbi\u22121\nk+1 ))\nh\ni\n1\n1\ndk\u22121 \u2212 dk+1\n\n1\ndk+1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(19)\n\nMoreover, since {v + 1, . . . , k \u2212 1} \u2286 E i\u22121 and {v, k, k + 1} \u2286 Ai\u22121 , we also know that for every\nn \u2208 {v + 1, . . . , k \u2212 1},\n\u03bbi\u22121\n=\nn\n\nQv\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndk\n\nh\n\ni\n\n1\ndv\n\nh\n+ Qk d1v \u2212\ni\n\u2212 d1k\n\n1\ndn\n\ni\n\n\u2212 Qn .\n\n(20)\n\nDRAFT\n\n\f13\n\ni\u22121\nNow, substituting \u03bbi\u22121\nk+1 = 0 and \u03bbk\u22121 from (20) in (19), we obtain\nQv\n\n\u00bb\n\n1\ndk\u22121\n\nv\n\nQk <\n\n=\u21d2 Qk <\n\n\u00bb\n\u2013\n\u2013\n\u2212 d1 +Qk d1 \u2212 d 1\nv\nk\nk\u22121\ni\nh\n1\n\u2212 d1\nd\n\nQv\n\nh\n\n1\ndk\n\n\u2212\n\nk\n\n1\ndk+1\n\nh\n\nh\n\ni\n\n+ Qk+1\ni\n1\n\u2212 dk+1\n\n1\ndv\n\nh\n\n1\ndv\n\n1\ndk\n\nh\n\n\u2212\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\n1\ndk+1\n\n\u2212\n\ni\n\ni\n\n+ (Qk+1 + \u03bbi\u22121\nk+1 ))\ni\n\n1\ndk+1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(21)\n\nNow, note that from (13), for every n = v + 1, . . . , k\ni\nh\nh\n1\n+ Qk+1 d1v \u2212\nQv d1n \u2212 dk+1\ni\nh\n\u03bbin =\n1\n1\n\u2212\ndv\ndk+1\n\n1\ndn\n\ni\n\n\u2212 Qn .\n\n(22)\n\nFrom (21) and (22), clearly, \u03bbik > 0. Now, from (20) and (22), it follows that for every n = v +\n1, . . . , k \u2212 1\n\u03bbin \u2212 \u03bbi\u22121\n=\nn\n\n=\n\nQv\nh\n\nh\n\n1\ndv\n1\ndv\n\nh\n\n1\ndn\n\n\u2212\n\n\u2212\n\n1\ndn\n\n\u2212\n\n1\ndk\n\n1\ndk+1\n\ni\n\nh\n\ni\n\n1\ndv\n\n+ Qk+1\ni\n1\n\u2212 dk+1\n\nh\n\n1\ndv\n\n\u2212\n\n1\ndn\n\ni\n\n\u2212\n\nQv\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndk\n\nh\n\ni\n\n1\ndv\n\nh\n+ Qk d1v \u2212\ni\n\u2212 d1k\n\n1\ndn\n\ni\n\ni \u03bbik \u2265 0.\n\nThe last inequality follows from the fact that dn \u2264 dn+1 for every n and \u03bbik > 0. Furthermore, by\n= \u03bbin . Thus, the result follows.\nLemma 3, for n 6\u2208 {v + 1, . . . , k}, \u03bbi\u22121\nn\n\nLemma 7: Let index k > 1 be added to the set E i\u22121 in the ith iteration. Also, let {1, . . . , k \u2212 1} \u2286\nE i\u22121 and k + 1 \u2208 Ai . Then, \u03bbin \u2212 \u03bbni\u22121 \u2265 0 for every n.\n\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\nk\nSecond, from (10)\nQk <\n\ni\u22121\n(Qk\u22121 + \u03bbk\u22121\n)\n\nh\n\n1\ndk\n\n\u2212\n\ni\n\ni\u22121\ndk+1 + (Qk+1 + \u03bbk+1 ))\nh\ni\n1\n1\ndk\u22121 \u2212 dk+1\n1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(23)\n\nMoreover, since {1, . . . , k \u2212 1} \u2286 E i\u22121 and k \u2208 Ai\u22121 , we also know that for every n \u2208 {1, . . . , k \u2212\n1},\n\u03bbi\u22121\nn\n\n= V N0\n\n\u0014\n\n\u0015\n1\n1\n\u2212\n+ (Qk \u2212 Qn ).\ndn dk\n\ni\u22121\nNow, substituting \u03bbi\u22121\nk+1 = 0 and \u03bbk\u22121 from (24) in (23), we obtain\nh\n\u0010\ni\n\u0011h\ni\nh\n1\n1\n1\nV N0 dk\u22121\n+ Qk+1 dk\u22121\n\u2212 d1k + Qk d1k \u2212 dk+1\n\u2212\ni\nh\nQk <\n1\n1\ndk\u22121 \u2212 dk+1\n\u0015\n\u0014\n1\n1\n\u2212\n=\u21d2 Qk < V N0\n+ Qk+1 .\ndk\ndk+1\n\n(24)\n\n1\ndk\n\ni\n\n(25)\n\n(26)\n\nDRAFT\n\n\f14\n\nNow, note that from (13), for every n = 1, . . . , k\n\u0014\n\u0015\n1\n1\ni\n\u03bbn = V N0\n\u2212\n+ (Qk+1 \u2212 Qn ).\ndn dk+1\n\n(27)\n\nFrom (26) and (27), clearly, \u03bbik > 0. Now, from (24) and (27), it follows that for every n = 1, . . . , k\u22121\n\u0015\n\u0014\n1\n1\ni\ni\u22121\n\u2212\n+ (Qk+1 \u2212 Qk )\n\u03bbn \u2212 \u03bbn\n= V N0\ndk\ndk+1\n= \u03bbik \u2265 0.\n\n= \u03bbin . Thus, the result follows.\nFurthermore, by Lemma 3, for n 6\u2208 {1, . . . , k}, \u03bbi\u22121\nn\n\nLemma 8: Let index k > 1 be added to the set E i\u22121 in the ith iteration. Also, let {k+1, . . . , u\u22121} \u2286\nE i\u22121 and {k \u2212 1, u} \u2286 Ai . Then, \u03bbin \u2212 \u03bbi\u22121\n\u2265 0 for every n.\nn\n\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\nk\nSecond, from (10)\nQk <\n\ni\u22121\n(Qk\u22121 + \u03bbk\u22121\n)\n\nh\n\n1\ndk\n\n1\n\ni\n\ni\u22121\ndk+1 + (Qk+1 + \u03bbk+1 ))\ni\nh\n1\n1\n\u2212\ndk\u22121\ndk+1\n\n\u2212\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(28)\n\nMoreover, since {k + 1, . . . , u \u2212 1} \u2286 E i\u22121 and {k \u2212 1, k, u} \u2286 Ai\u22121 , we also know that for every\nn \u2208 {k + 1, . . . , u \u2212 1},\nQk\n\n\u03bbi\u22121\n=\nn\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndu\n\nh\n\ni\n\n1\ndk\n\nh\n+ Qu d1k \u2212\ni\n\u2212 d1u\n\ni\n\n1\ndn\n\n\u2212 Qn .\n\n(29)\n\ni\u22121\n= 0 and \u03bbi\u22121\nNow, substituting \u03bbk\u22121\nk+1 from (29) in (28), we obtain\n\nQk\u22121\nQk <\n\n=\u21d2 Qk <\n\nQk\u22121\n\nh\n\n1\ndk\n\nh\n\n1\ndk\n\n\u2212\n\n1\ndk+1\n\ni\n\nQk\n\n+\n\n\u00bb\n\nh\n\n\u00bb\n\u2013\n\u2013\n1\n1\n1\n+Q\n\u2212\n\u2212\nu\ndk+1\ndu\ndk\ndk+1\nh\ni\n1\n1\n\u2212\nd\nd\n1\n\nk\n\n1\ndk\u22121\n\n1\ndk+1\n\n\u2212\n\nh\ni\n1\n\u2212 d1u + Qu dk\u22121\n\u2212\nh\ni\n1\n1\ndk\u22121 \u2212 du\n\n1\ndk\n\ni\n\niu\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\nNow, note that from (13), for every n = k, . . . , u \u2212 1\nh\ni\nh\n1\n\u2212\nQk\u22121 d1n \u2212 d1u + Qu dk\u22121\ni\ni\nh\n\u03bbn =\n1\n1\ndk\u22121 \u2212 du\n\n(30)\n\n1\ndn\n\ni\n\n\u2212 Qn .\n\n(31)\n\nFrom (30) and (31), clearly, \u03bbik > 0. Now, from (29) and (31), it follows that for every n = k +\n\n1, . . . , u \u2212 1\n\u03bbin \u2212 \u03bbi\u22121\n=\nn\n\n=\n\nQk\u22121\nh\n\nh\n\n1\ndn\n1\ndk\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndu\n\n\u2212\n\n1\ndu\n\nh\ni\n1\n\u2212 d1u + Qu dk\u22121\n\u2212\nh\ni\n1\n1\ndk\u22121 \u2212 du\ni\n\n1\ndn\n\ni\n\n\u2212\n\nQk\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndu\n\nh\n\ni\n\n1\ndk\n\nh\n+ Qu d1k \u2212\ni\n\u2212 d1u\n\n1\ndn\n\ni\n\ni \u03bbik \u2265 0.\n\nDRAFT\n\n\f15\n\nThe last inequality follows from the fact that dn \u2264 dn+1 for every n and \u03bbik > 0. Furthermore, by\n= \u03bbin . Thus, the result follows.\nLemma 3, for n 6\u2208 {k, . . . , u \u2212 1}, \u03bbi\u22121\nn\n\nLemma 9: Let index k > 1 be added to the set E i\u22121 in the ith iteration. Also, let {v + 1, . . . , k \u2212\n1} \u222a {k + 1, . . . , u \u2212 1} \u2286 E i\u22121 and {v, u} \u2286 Ai . Then, \u03bbin \u2212 \u03bbi\u22121\n\u2265 0 for every n.\nn\n\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\nk\nSecond, from (10)\nQk <\n\ni\u22121\n(Qk\u22121 + \u03bbk\u22121\n)\n\nh\n\n1\ndk\n\n\u2212\n\ni\n\ni\u22121\ndk+1 + (Qk+1 + \u03bbk+1 ))\nh\ni\n1\n1\n\u2212\ndk\u22121\ndk+1\n1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(32)\n\nMoreover, since {v + 1, . . . , k \u2212 1} \u222a {k + 1, . . . , u \u2212 1} \u2286 E i\u22121 and {v, k, u} \u2286 Ai\u22121 , we also\nknow that for every n \u2208 {v + 1, . . . , k \u2212 1},\ni\nh\nh\nQv d1n \u2212 d1k + Qk d1v \u2212\ni\nh\n\u03bbi\u22121\n=\nn\n1\n1\n\u2212\ndv\ndk\n\nand for every n \u2208 {k + 1, . . . , u \u2212 1},\nh\nh\ni\nQk d1n \u2212 d1u + Qu d1k \u2212\nh\ni\n\u03bbi\u22121\n=\nn\n1\n1\n\u2212\ndk\ndu\n\n1\ndn\n\ni\n\n1\ndn\n\ni\n\n\u2212 Qn ,\n\n(33)\n\n\u2212 Qn .\n\n(34)\n\ni\u22121\nNow, substituting \u03bbk\u22121\nand \u03bbi\u22121\nk+1 from (33) and (34), respectively, in (32), we obtain\nQv\n\n\u00bb\n\nv\n\nQk <\n\n=\u21d2 Qk <\n\n\u00bb\n\u2013\n\u2013\n1\n1\n1\n\u2212\n\u2212\n+Q\nk\ndk\u22121\ndk\ndv\ndk\u22121\nh\ni\n1\n1\n\u2212\nd\nd\n1\n\nQv\n\nh\n\n1\ndk\n\n\u2212\n\n1\ndu\n\nh\n\nk\n\ni\n\n1\ndv\n\nh\n+ Qu d1v \u2212\ni\n\u2212 d1u\n\nh\n\n1\ndk\n\n1\ndk\n\ni\n\n\u2212\n\n1\ndk+1\n\nh\n\ni\n\n1\ndk\u22121\n\nQk\n\n+\n\u2212\n\n\u00bb\n\n\u00bb\n\u2013\n\u2013\n1\n1\n1\n+Q\n\u2212\n\u2212\nu\ndk+1\ndu\ndk\ndk+1\nh\ni\n1\n1\n\u2212\nd\nd\n\n1\ndk+1\n\n1\n\ni\n\nu\n\nk\n\nh\n\n1\ndk\u22121\n\n.\n\n\u2212\n\n1\ndk\n\ni\n\n(35)\n\nNow, note that from (13), for every n = v + 1, . . . , u \u2212 1\nh\ni\nh\nQv d1n \u2212 d1u + Qu d1v \u2212\ni\nh\n\u03bbin =\n1\n1\n\u2212\ndv\ndu\n\n1\ndn\n\ni\n\n\u2212 Qn .\n\n(36)\n\nFrom (35) and (36), clearly, \u03bbik > 0. Now, from (33) and (36), it follows that for every n = v +\n1, . . . , k \u2212 1\n\u03bbin \u2212 \u03bbi\u22121\n=\nn\n\n=\n\nQv\nh\n\nh\n\n1\ndv\n1\ndv\n\nh\n\n1\ndn\n\n\u2212\n\n\u2212\n\n1\ndn\n\n\u2212\n\n1\ndk\n\n1\ndu\n\nh\n\ni\n\ni\n\n1\ndv\n\nh\n+ Qu d1v \u2212\ni\n\u2212 d1u\n\n1\ndn\n\ni\n\n\u2212\n\nQv\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndk\n\nh\n\ni\n\n1\ndv\n\nh\n+ Qk d1v \u2212\ni\n\u2212 d1k\n\n1\ndn\n\ni\n\ni \u03bbik \u2265 0.\nDRAFT\n\n\f16\n\nThe last inequality follows from the fact that dn \u2264 dn+1 for every n and \u03bbik > 0. Moreover, from\n(34) and (36), it follows that for every n = k + 1, . . . , u \u2212 1\nh\nh\nh\nh\ni\ni\ni\nQv d1n \u2212 d1u + Qu d1v \u2212 d1n\nQk d1n \u2212 d1u + Qu d1k \u2212\nh\nh\ni\ni\n\u03bbin \u2212 \u03bbi\u22121\n=\n\u2212\nn\n1\n1\n1\n1\n\u2212\n\u2212\ndv\ndu\ndk\ndu\nh\ni\n1\n1\ndn \u2212 du\ni \u03bbik \u2265 0.\n= h\n1\n1\ndk \u2212 du\n\n1\ndn\n\ni\n\n= \u03bbin . Thus, the result follows.\nFurthermore, by Lemma 3, for n 6\u2208 {v + 1, . . . , u \u2212 1}, \u03bbi\u22121\nn\n\nLemma 10: Let index k > 1 be added to the set E i\u22121 in the ith iteration. Also, let {1, . . . , k \u2212\n1} \u222a {k + 1, . . . , u \u2212 1} \u2286 E i\u22121 and u \u2208 Ai . Then, \u03bbin \u2212 \u03bbi\u22121\n\u2265 0 for every n.\nn\n\nProof: Since index k is added to E i\u22121 in the ith iteration, we know the following. First, \u03bbi\u22121\n= 0.\nk\nSecond, from (10)\nQk <\n\ni\u22121\n(Qk\u22121 + \u03bbk\u22121\n)\n\nh\n\n1\ndk\n\n\u2212\n\ni\n\ni\u22121\ndk+1 + (Qk+1 + \u03bbk+1 ))\ni\nh\n1\n1\n\u2212\ndk\u22121\ndk+1\n1\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n.\n\n(37)\n\nMoreover, since {1, . . . , k \u2212 1} \u222a {k + 1, . . . , u \u2212 1} \u2286 E i\u22121 and {k, u} \u2286 Ai\u22121 , we also know\nthat for every n \u2208 {1, . . . , k \u2212 1},\n\u03bbi\u22121\n= V N0\nn\n\nand for every n \u2208 {k + 1, . . . , u \u2212 1},\n\u03bbi\u22121\n=\nn\n\nQk\n\nh\n\n1\ndn\n\n\u0014\n\u2212\n\n\u0015\n1\n1\n\u2212\n+ (Qk \u2212 Qn ),\ndn dk\n1\ndu\n\nh\n\ni\n\n1\ndk\n\nh\n+ Qu d1k \u2212\ni\n\u2212 d1u\n\n1\ndn\n\ni\n\n(38)\n\n\u2212 Qn .\n\n(39)\n\ni\u22121\nNow, substituting \u03bbi\u22121\nk\u22121 and \u03bbk+1 from (38) and (39), respectively, in (37), we obtain\n\nQk <\n\nh\n\nV N0\n\n=\u21d2 Qk < V N0\n\n\u0014\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n+ Qk\n\n\u0015\n1\n1\n\u2212\n+ Qu .\ndk\ndu\n\nih\n\n1\ndk\n\n\u2212\n\n1\ndk+1\n\nh\n\ni\n\n1\ndk\u22121\n\nQk\n\n+\n\u2212\n\n\u00bb\n\n1\ndk+1\n\n1\ndk+1\n\ni\n\n\u00bb\n\u2013\n\u2013\n\u2212 d1 +Qu d1 \u2212 d 1\nu\nk\nk+1\nh\ni\n1\n1\n\u2212\nd\nd\n\nNow, note that from (13), for every n = 1, . . . , u \u2212 1\n\u0015\n\u0014\n1\n1\ni\n\u2212\n+ (Qu \u2212 Qn ).\n\u03bbn = V N0\ndn du\n\nk\n\nu\n\nh\n\n1\ndk\u22121\n\n\u2212\n\n1\ndk\n\ni\n\n(40)\n\n(41)\n\nFrom (40) and (41), clearly, \u03bbik > 0. Now, from (38) and (41), it follows that for every n = 1, . . . , k\u22121\n\u0014\n\u0015\n\u0015\n\u0014\n1\n1\n1\n1\n\u03bbin \u2212 \u03bbi\u22121\n=\nV\nN\n\u2212\n\u2212\n+\n(Q\n\u2212\nQ\n)\n\u2212\nV\nN\n\u2212 (Qk \u2212 Qn )\n0\nu\nn\n0\nn\ndn du\ndn dk\n= \u03bbik \u2265 0.\n\nDRAFT\n\n\f17\n\nThe last inequality follows from the fact that and \u03bbik > 0. Moreover, from (39) and (41), it follows\nthat for every n = k + 1, . . . , u \u2212 1\n\u03bbin \u2212 \u03bbi\u22121\n= V N0\nn\n=\n\n\u0014\n\n\u0014\n\n\u0015\n\n1\n1\n\u2212\n+ Qu \u2212\ndn du\n\n\u0015\n1\n1\n\u2212\n\u03bbi \u2265 0.\ndn du k\n\nQk\n\nh\n\n1\ndn\n\n\u2212\n\n1\ndu\n\nh\n\ni\n\n1\ndk\n\nh\n+ Qu d1k \u2212\ni\n\u2212 d1u\n\n1\ndn\n\ni\n\n= \u03bbin . Thus, the result follows.\nFurthermore, by Lemma 3, for n 6\u2208 {1, . . . , u \u2212 1}, \u03bbi\u22121\nn\n\nDRAFT\n\n\f"}