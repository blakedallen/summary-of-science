{"id": "http://arxiv.org/abs/cond-mat/0101136v1", "guidislink": true, "updated": "2001-01-10T15:38:08Z", "updated_parsed": [2001, 1, 10, 15, 38, 8, 2, 10, 0], "published": "2001-01-10T15:38:08Z", "published_parsed": [2001, 1, 10, 15, 38, 8, 2, 10, 0], "title": "Percolation Threshold, Fisher Exponent, and Shortest Path Exponent for 4\n  and 5 Dimensions", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cond-mat%2F0101158%2Ccond-mat%2F0101136%2Ccond-mat%2F0101180%2Ccond-mat%2F0101115%2Ccond-mat%2F0101234%2Ccond-mat%2F0101470%2Ccond-mat%2F0101048%2Ccond-mat%2F0101434%2Ccond-mat%2F0101193%2Ccond-mat%2F0101441%2Ccond-mat%2F0101338%2Ccond-mat%2F0101328%2Ccond-mat%2F0101182%2Ccond-mat%2F0101167%2Ccond-mat%2F0101052%2Ccond-mat%2F0101106%2Ccond-mat%2F0101179%2Ccond-mat%2F0101376%2Ccond-mat%2F0101406%2Ccond-mat%2F0101450%2Ccond-mat%2F0101474%2Ccond-mat%2F0101147%2Ccond-mat%2F0101322%2Ccond-mat%2F0101323%2Ccond-mat%2F0101277%2Ccond-mat%2F0101054%2Ccond-mat%2F0101346%2Ccond-mat%2F0101086%2Ccond-mat%2F0101159%2Ccond-mat%2F0101068%2Ccond-mat%2F0101078%2Ccond-mat%2F0101369%2Ccond-mat%2F0101021%2Ccond-mat%2F0101215%2Ccond-mat%2F0101426%2Ccond-mat%2F0101305%2Ccond-mat%2F0101443%2Ccond-mat%2F0101267%2Ccond-mat%2F0101181%2Ccond-mat%2F0101143%2Ccond-mat%2F0101297%2Ccond-mat%2F0101412%2Ccond-mat%2F0101438%2Ccond-mat%2F0101156%2Ccond-mat%2F0101002%2Ccond-mat%2F0101456%2Ccond-mat%2F0101378%2Ccond-mat%2F0101004%2Ccond-mat%2F0101074%2Ccond-mat%2F0101465%2Ccond-mat%2F0101433%2Ccond-mat%2F0101020%2Ccond-mat%2F0101125%2Ccond-mat%2F0101269%2Ccond-mat%2F0101236%2Ccond-mat%2F0101194%2Ccond-mat%2F0101025%2Ccond-mat%2F0101416%2Ccond-mat%2F0101479%2Ccond-mat%2F0101392%2Ccond-mat%2F0101155%2Ccond-mat%2F0101359%2Ccond-mat%2F0101373%2Ccond-mat%2F0101058%2Ccond-mat%2F0101380%2Ccond-mat%2F0101473%2Ccond-mat%2F0101038%2Ccond-mat%2F0101257%2Ccond-mat%2F0101094%2Ccond-mat%2F0101468%2Ccond-mat%2F0101453%2Ccond-mat%2F0101423%2Ccond-mat%2F0101209%2Ccond-mat%2F0101363%2Ccond-mat%2F0101455%2Ccond-mat%2F0101445%2Ccond-mat%2F0101187%2Ccond-mat%2F0101475%2Ccond-mat%2F0101237%2Ccond-mat%2F0101220%2Ccond-mat%2F0101135%2Ccond-mat%2F0101371%2Ccond-mat%2F0101128%2Ccond-mat%2F0101429%2Ccond-mat%2F0101105%2Ccond-mat%2F0101218%2Ccond-mat%2F0101244%2Ccond-mat%2F0101253%2Ccond-mat%2F0101298%2Ccond-mat%2F0101126%2Ccond-mat%2F0101307%2Ccond-mat%2F0101110%2Ccond-mat%2F0101057%2Ccond-mat%2F0101235%2Ccond-mat%2F0101211%2Ccond-mat%2F0101418%2Ccond-mat%2F0101368%2Ccond-mat%2F0101116%2Ccond-mat%2F0101248%2Ccond-mat%2F0101347%2Ccond-mat%2F0101439&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Percolation Threshold, Fisher Exponent, and Shortest Path Exponent for 4\n  and 5 Dimensions"}, "summary": "We develop a method of constructing percolation clusters that allows us to\nbuild very large clusters using very little computer memory by limiting the\nmaximum number of sites for which we maintain state information to a number of\nthe order of the number of sites in the largest chemical shell of the cluster\nbeing created. The memory required to grow a cluster of mass s is of the order\nof $s^\\theta$ bytes where $\\theta$ ranges from 0.4 for 2-dimensional lattices\nto 0.5 for 6- (or higher)-dimensional lattices. We use this method to estimate\n$d_{\\scriptsize min}$, the exponent relating the minimum path $\\ell$ to the\nEuclidean distance r, for 4D and 5D hypercubic lattices. Analyzing both site\nand bond percolation, we find $d_{\\scriptsize min}=1.607\\pm 0.005$ (4D) and\n$d_{\\scriptsize min}=1.812\\pm 0.006$ (5D). In order to determine\n$d_{\\scriptsize min}$ to high precision, and without bias, it was necessary to\nfirst find precise values for the percolation threshold, $p_c$:\n$p_c=0.196889\\pm 0.000003$ (4D) and $p_c=0.14081\\pm 0.00001$ (5D) for site and\n$p_c=0.160130\\pm 0.000003$ (4D) and $p_c=0.118174\\pm 0.000004$ (5D) for bond\npercolation. We also calculate the Fisher exponent, $\\tau$, determined in the\ncourse of calculating the values of $p_c$: $\\tau=2.313\\pm 0.003$ (4D) and\n$\\tau=2.412\\pm 0.004$ (5D).", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cond-mat%2F0101158%2Ccond-mat%2F0101136%2Ccond-mat%2F0101180%2Ccond-mat%2F0101115%2Ccond-mat%2F0101234%2Ccond-mat%2F0101470%2Ccond-mat%2F0101048%2Ccond-mat%2F0101434%2Ccond-mat%2F0101193%2Ccond-mat%2F0101441%2Ccond-mat%2F0101338%2Ccond-mat%2F0101328%2Ccond-mat%2F0101182%2Ccond-mat%2F0101167%2Ccond-mat%2F0101052%2Ccond-mat%2F0101106%2Ccond-mat%2F0101179%2Ccond-mat%2F0101376%2Ccond-mat%2F0101406%2Ccond-mat%2F0101450%2Ccond-mat%2F0101474%2Ccond-mat%2F0101147%2Ccond-mat%2F0101322%2Ccond-mat%2F0101323%2Ccond-mat%2F0101277%2Ccond-mat%2F0101054%2Ccond-mat%2F0101346%2Ccond-mat%2F0101086%2Ccond-mat%2F0101159%2Ccond-mat%2F0101068%2Ccond-mat%2F0101078%2Ccond-mat%2F0101369%2Ccond-mat%2F0101021%2Ccond-mat%2F0101215%2Ccond-mat%2F0101426%2Ccond-mat%2F0101305%2Ccond-mat%2F0101443%2Ccond-mat%2F0101267%2Ccond-mat%2F0101181%2Ccond-mat%2F0101143%2Ccond-mat%2F0101297%2Ccond-mat%2F0101412%2Ccond-mat%2F0101438%2Ccond-mat%2F0101156%2Ccond-mat%2F0101002%2Ccond-mat%2F0101456%2Ccond-mat%2F0101378%2Ccond-mat%2F0101004%2Ccond-mat%2F0101074%2Ccond-mat%2F0101465%2Ccond-mat%2F0101433%2Ccond-mat%2F0101020%2Ccond-mat%2F0101125%2Ccond-mat%2F0101269%2Ccond-mat%2F0101236%2Ccond-mat%2F0101194%2Ccond-mat%2F0101025%2Ccond-mat%2F0101416%2Ccond-mat%2F0101479%2Ccond-mat%2F0101392%2Ccond-mat%2F0101155%2Ccond-mat%2F0101359%2Ccond-mat%2F0101373%2Ccond-mat%2F0101058%2Ccond-mat%2F0101380%2Ccond-mat%2F0101473%2Ccond-mat%2F0101038%2Ccond-mat%2F0101257%2Ccond-mat%2F0101094%2Ccond-mat%2F0101468%2Ccond-mat%2F0101453%2Ccond-mat%2F0101423%2Ccond-mat%2F0101209%2Ccond-mat%2F0101363%2Ccond-mat%2F0101455%2Ccond-mat%2F0101445%2Ccond-mat%2F0101187%2Ccond-mat%2F0101475%2Ccond-mat%2F0101237%2Ccond-mat%2F0101220%2Ccond-mat%2F0101135%2Ccond-mat%2F0101371%2Ccond-mat%2F0101128%2Ccond-mat%2F0101429%2Ccond-mat%2F0101105%2Ccond-mat%2F0101218%2Ccond-mat%2F0101244%2Ccond-mat%2F0101253%2Ccond-mat%2F0101298%2Ccond-mat%2F0101126%2Ccond-mat%2F0101307%2Ccond-mat%2F0101110%2Ccond-mat%2F0101057%2Ccond-mat%2F0101235%2Ccond-mat%2F0101211%2Ccond-mat%2F0101418%2Ccond-mat%2F0101368%2Ccond-mat%2F0101116%2Ccond-mat%2F0101248%2Ccond-mat%2F0101347%2Ccond-mat%2F0101439&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We develop a method of constructing percolation clusters that allows us to\nbuild very large clusters using very little computer memory by limiting the\nmaximum number of sites for which we maintain state information to a number of\nthe order of the number of sites in the largest chemical shell of the cluster\nbeing created. The memory required to grow a cluster of mass s is of the order\nof $s^\\theta$ bytes where $\\theta$ ranges from 0.4 for 2-dimensional lattices\nto 0.5 for 6- (or higher)-dimensional lattices. We use this method to estimate\n$d_{\\scriptsize min}$, the exponent relating the minimum path $\\ell$ to the\nEuclidean distance r, for 4D and 5D hypercubic lattices. Analyzing both site\nand bond percolation, we find $d_{\\scriptsize min}=1.607\\pm 0.005$ (4D) and\n$d_{\\scriptsize min}=1.812\\pm 0.006$ (5D). In order to determine\n$d_{\\scriptsize min}$ to high precision, and without bias, it was necessary to\nfirst find precise values for the percolation threshold, $p_c$:\n$p_c=0.196889\\pm 0.000003$ (4D) and $p_c=0.14081\\pm 0.00001$ (5D) for site and\n$p_c=0.160130\\pm 0.000003$ (4D) and $p_c=0.118174\\pm 0.000004$ (5D) for bond\npercolation. We also calculate the Fisher exponent, $\\tau$, determined in the\ncourse of calculating the values of $p_c$: $\\tau=2.313\\pm 0.003$ (4D) and\n$\\tau=2.412\\pm 0.004$ (5D)."}, "authors": ["Gerald Paul", "Robert M. Ziff", "H. Eugene Stanley"], "author_detail": {"name": "H. Eugene Stanley"}, "author": "H. Eugene Stanley", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1103/PhysRevE.64.026115", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/cond-mat/0101136v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cond-mat/0101136v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cond-mat.stat-mech", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cond-mat.stat-mech", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cond-mat.dis-nn", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cond-mat/0101136v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cond-mat/0101136v1", "arxiv_comment": null, "journal_reference": null, "doi": "10.1103/PhysRevE.64.026115", "fulltext": "Percolation Threshold, Fisher Exponent,\nand Shortest Path Exponent for 4 and 5 Dimensions\nGerald Paul,1\u2217 Robert M. Ziff,2 and H. Eugene Stanley1\n\narXiv:cond-mat/0101136v1 [cond-mat.stat-mech] 10 Jan 2001\n\n1\n\nCenter for Polymer Studies and Department of Physics\nBoston University, Boston, MA 02215\n2\nCenter for Theoretical Physics and Department of Chemical Engineering\nUniversity of Michigan, Ann Arbor, MI 48109-2136\n(pzs.tex\n10 January 2001 )\nWe develop a method of constructing percolation clusters that allows us to build very large\nclusters using very little computer memory by limiting the maximum number of sites for which we\nmaintain state information to a number of the order of the number of sites in the largest chemical\nshell of the cluster being created. The memory required to grow a cluster of mass s is of the order\nof s\u03b8 bytes where \u03b8 ranges from 0.4 for 2-dimensional lattices to 0.5 for 6- (or higher)-dimensional\nlattices. We use this method to estimate dmin , the exponent relating the minimum path l to the\nEuclidean distance r, for 4D and 5D hypercubic lattices. Analyzing both site and bond percolation,\nwe find dmin = 1.607 \u00b1 0.005 (4D) and dmin = 1.812 \u00b1 0.006 (5D). In order to determine dmin to\nhigh precision, and without bias, it was necessary to first find precise values for the percolation\nthreshold, pc : pc = 0.196889 \u00b1 0.000003 (4D) and pc = 0.14081 \u00b1 0.00001 (5D) for site and pc =\n0.160130\u00b10.000003 (4D) and pc = 0.118174\u00b10.000004 (5D) for bond percolation. We also calculate\nthe Fisher exponent, \u03c4 , determined in the course of calculating the values of pc : \u03c4 = 2.313 \u00b1 0.003\n(4D) and \u03c4 = 2.412 \u00b1 0.004 (5D).\n\nwe stop the growth), the more accurately we can estimate z. The limitations on the size, lmax , to which the\nclusters can be grown have been the computer memory\navailable for the simulation and the computer processing power needed to build these clusters. The method\nof \"data blocking\" [5,6] has helped ameliorate the need\nfor large amounts of memory. In this method, the lattice\nis logically divided into blocks; memory for a block is\nnot allocated until the lattice grows into that block. The\ndata blocking method has been used recently to obtain\nprecise estimates for the percolation threshold and associated exponents for bond and site percolation on a number\nof lattices [6,7]. Ultimately, however, although sufficient\ncomputer power is available to build larger clusters, the\ncluster size is limited by the amount of memory available.\nThis becomes particularly true as the dimension of the\nlattice d increases since at criticality the cluster becomes\nless dense as d increases [8]. To reach the same cluster\nmass or lmax , we must have larger lattices.\n\nI. INTRODUCTION\n\nPercolation is a standard model for disordered systems\n[1,2]. In percolation systems, sites or bonds on a lattice\nare populated with probability p. The value of p at which\ninfinite clusters are formed is known as the critical probability or percolation threshold pc . The shortest path\nexponent, dmin , is defined by the relation [2\u20134]\nhli \u223c rdmin ,\n\n(1)\n\nwhere r is the Euclidean distance between two sites on a\ncluster and l is the length of the shortest path traveling\nalong occupied sites and bonds in the percolation cluster\n(\"chemical distance\"). We can also write\nhri \u223c lz ,\n\n(2)\n\nwhich defines the exponent z = 1/dmin. With the exceptions of d \u2265 6 (where z = 1/2) and d = 1 (where z = 1),\nz is not known exactly. The most common method of\ndetermining z numerically (and the one we will use) is\nto grow clusters, calculating the average distance hri of\nsites in the cluster from the seed of the cluster as a function of chemical distance, l, from the seed. In order that\nfinite size effects do not play a role, the lattice must be\nlarge enough such that the clusters which are grown do\nnot reach the boundaries of the lattice.\nBecause corrections-to-scaling decrease with increasing\nl, the larger the value of lmax (the value of l at which\n\n\u2217\n\nIn this paper we describe a method of constructing\nclusters which dramatically reduces the memory requirements needed to grow large clusters relative to previous\nmethods. Using this method of building large clusters,\nwe estimate z for hypercubic lattices in 4, and 5, dimensions. The study of critical properties in higher dimensions is important because one can use the results to\ntest relations which are conjectured to hold in all dimensions (hyperscaling relations) and exponents which are\nbelieved to be the same in all dimensions (superuniversal\n\nelectronic address: gerryp@bu.edu\n\n1\n\n\fexponents). The current best estimates of dmin for 4 and\n5 dimensions, 1.5 and 1.8, respectively [1], are of relatively low precision compared to the estimates available\nin 2 and 3 dimensions 1.1307 \u00b1 0.0004 and 1.374 \u00b1 0.006,\nrespectively [2,3].\n\nA. Occupancy Status\n\nWe address the need to maintain information about\nwhether a bond is occupied or not by using a random\nnumber generation scheme in which the random number\nassociated with a bond is determined by the location of\nthe bond in the lattice and the orientation of the bond.\nThis is done by first assigning a unique number n to\nany site in the lattice as follows: Let (x1 , x2 , x3 . . . xd )\nbe the coordinates of the site in the lattice, and let\n(L1 , L2 , L3 . . . Ld ) be the lengths of the sides of the lattice. Then\n\nII. CLUSTER GENERATION\n\nOne method of cluster generation is the Leath method\n[9]. In this method a site is chosen as the seed site of the\ncluster. Using a random number generator and a given\nbond occupation probability, one determines whether the\nbonds connected to the seed site are occupied or not [10].\nIf a bond is occupied, the site to which this bond connects is considered to be part of the cluster and becomes\na \"growth site.\" These sites are at chemical distance of\nunity from the seed site; all sites at the same chemical\ndistance, l, from the seed site are considered to be in\n\"chemical shell l.\" The process is then repeated for each\nof these growth sites with the next set of growth sites being at chemical distance 2 from the seed site. The cluster\ncontinues to grow until the growth stops naturally, the\ngrowth is terminated by the sides of the d-dimensional\nlattice of edge L, or the maximum chemical distance,\nlmax , is reached.\nWe use the Leath method to construct clusters, but we\nkeep track of which bonds are occupied and which sites\nhave been visited by a method different from that traditionally used. Traditionally, this state information is\nstored in an array of size equal to the number of lattice\nsites. In the data blocking method, memory usage can be\nimproved by allocating blocks in this array dynamically.\nVollmayr [11] eliminated the use of this array, storing\nstatus of visited sites in a data structure thus reducing\nmemory requirements to grow a cluster of mass s to O(s).\nWe extend the approach of Ref. [11] further, reducing the\nmemory required to O(s\u03b8 ) where \u03b8 ranges from 0.4 for 2dimensional lattices to 0.5 for 6- (or higher)-dimensional\nlattices.\nTo see how this can be done, we first consider the uses\nof this state information:\n\nn(x1 , x2 , x3 . . . xd ) =\n[({[(x1 L2 ) + x2 ]L3 } + x3 . . .)Ld + xd ]\n\n(3)\n\nassigns a unique number to any site in the lattice. We\nassign a unique number, n\u2032 , to any bond in the lattice by\ndefining\nn\u2032 (x1 , x2 , x3 . . . xd , o) = [n(x1 , x2 , x3 . . . xd )d] + o, (4)\nwhere o is the orientation of a bond attached to site x\n(assuming values 0 to d \u2212 1).\nFurthermore we want to assign unique numbers to\nbonds over many different realizations. We then define\nn\u2032\u2032 (x1 , x2 , x3 . . . xd , o, m) =\n[n\u2032 (x1 , x2 , x3 . . . xd , o)M ] + m,\n\n(5)\n\nwhere m is the number of the realization and M is the\nmaximum number of realizations we plan to create.\nWe then generate a 64-bit random number, R, using\nan encryption-like algorithm f (n\u2032\u2032 ) [12] using n\u2032\u2032 as its\ninput,\nR = f (n\u2032\u2032 ).\n\n(6)\n\nA bond is occupied if R > 264 p. In practice, because\nfor large lattices and a large number of realizations n\u2032\u2032\nis greater than 264 , the maximum size of the input to\nthe random number algorithm, we actually determine the\nrandom number in two steps,\n\n(a) Occupancy status: Information concerning whether\na site/bond is occupied is maintained so that it\nis the same, independent of when in the growth\nprocess it is accessed. For example, we would not\ngenerate a cluster with the proper statistics if we\ntreated a bond as occupied during one stage of the\ncluster growth and then treated it as empty during\na later stage.\n\nR\u0304 = f ({[f (n)d] + o}M + m).\n\n(7)\n\nThat is, we first create an intermediate random number based only on the coordinates of the bond and then\ncreate the final random number based on the intermediate random number, the orientation of the bond and\nthe realization number. Using the test described in [13],\nwe confirm that, within statistical error, our algorithm\ngenerates unbiased random numbers. This test is important because there is only a small difference between\n\n(b) Visited status: Information concerning whether a\nsite has been visited or not is maintained in order\nthat (a) we do not multiply count the presence of\na site in the cluster and (b) we do not retrace our\nsteps during cluster generation, causing the growth\nprocess to never end.\n2\n\n\fthe inputs to the random number generator for neighboring sites. Any correlations between the outputs would\ncause incorrect results [13]. The generation of random\nnumbers using Eq. (7) is slower than congruence or shift\nregister techniques [13] but is somewhat compensated by\neliminating the processing done to store and access bond\nstate when maintained in an array. In any case, the net\neffect of using this approach is about a factor of 5 increase in calculation time because of the slowness of the\nencryption-like random number generator that we used.\n\nh(K) maps the keys uniformly\nso we obtain few long chains.\nsize M = 2m , where m is an\nthe unique number, n, of the\nfunction is [14]\nh(n) =\n\nover the slots in the table\nIf we use a hash table of\ninteger and choose K as\nsite, an effective hashing\n\n1\n[(n C) mod 2w ] ,\n2w\u2212m\n\n(8)\n\nwhere w is the word size(in bits) of our computer and\nthe hash constant, C is the least significant\n\u221a w bits of the\nproduct of 2w and the \"golden ratio\", ( 5 \u2212 1)/2. Thus\nh(n) yields the upper m bits (shift right w \u2212 m bits) of\nthe result of taking the lower w bits of the product of\nthe unique site number and the hash constant, C. We\nimplement the ability to chain entries in the data structure by defining another field in the data structure entry\nwhich serves as a chain pointer field. To find an entry in\nthe data structure for a site, we calculate the unique site\nnumber using Eq. (3), find the offset in the hash table using Eq. (8), and then walk the chain of entries to find the\nentry with the desired coordinates. If we make the size of\nthe hash table equal to the size of the site data structure,\nwe find the average number of hash \"collisions\" to be less\nthan 2 so we can determine if a site has been visited very\nefficiently.\nThis approach of keeping the status of visited sites in\na special data structure (not in the lattice array) applies\nto any lattice model. In the case of growing percolation\nclusters we can further reduce the amount of memory\nneeded significantly. This is accomplished by recognizing\nthat a site which is multiply visited is done so during the\ngrowth of a single chemical shell. This is the key insight\nthat allows us to reduce the memory requirement and can\nbe confirmed by considering the bonds adjacent to a site\nin a lower chemical shell: (i) an occupied bond adjacent\nto a site in a lower chemical shell cannot be a path to\nre-visit that site because we do not back-track and (ii)\nan unoccupied bond adjacent to a site in a lower chemical shell cannot be on the path to revisit that site. Sites\nin the same chemical shell can, however, be visited by\nmultiple paths as shown in Fig. 1(a). Thus we need only\nkeep state information about growth sites which themselves have not yet been used to create entries for the\nnext chemical shell. The number of such sites at any\npoint in the growth process will be of the order of the\nsize of the current chemical shell.\nThe discussion so far has been for hypercubic lattices.\nFor these lattices, we ensure that we did not doublecount site or backtrack by maintaining information about\ngrowth sites which themselves have not yet been used\nto create entries for the next chemical shell and then\nchecking for duplicates. More generally (e.g., for triangular lattices), the situation is a little more complicated\nas shown in the example in Fig. 1(b). A similar situation is shown in Fig. 1(c), where we grow a cluster from\nmultiple seeds. To treat both types of situation, we must\nmaintain (i) state information about growth sites which\nthemselves have not yet been used to create entries for\n\nB. Visited Status\n\nWe address the need to maintain information about\nwhether a site has been visited or not by storing information about visited sites in a data structure. Each entry\nin the data structure contains the coordinates of the site,\nthe chemical shell of the site, and a bit map with one bit\nfor each direction from which the site can be visited. The\ndata structure can be accessed as a \"circular list\" (lastin-first-out queue) so entries can be added and deleted.\nSince a site can be visited from different directions, we\nmust ensure that a site is counted only once and that\nbacktracking does not occur. To accomplish this, before\nadding a site to the list of growth sites, we first check to\nsee if it is already in the list.\n\u2022 If it is already on the list, we do not add a new entry but, in the entry for the site already in the list,\nwe do set the bit corresponding to the orientation\nof the connected bond which was traversed to visit\nthe site.\n\u2022 If it is not in the list, we add it (storing the coordinates and chemical length and setting the bit\ncorresponding to the direction from which the site\nwas visited).\nWhen we are about to process the entry for a growth\nsite, we only count the site once in the mass of the cluster, and only attempt to grow the cluster in directions\nother than those from which the site was visited. In this\nway we avoid backtracking along already traveled paths.\nIf the data structure had to be searched sequentially every time we were about to create a growth site, the time\nneeded would make this approach impractical. In [11],\nthe data structure was maintained as a binary tree in order to reduce search time. We use the faster \"hash table\"\nmethod [14] to access entries for the visited sites.\nThe hashing technique works as follows: A key, K, is\nassociated with each entry of the data structure. We use\na function h(K) to map the key into a \"slot\" at offset\nh(K) in a \"hash table\". If the slot in the table is not\nalready used, we store the number or address of the entry in this slot; if the slot is used (this is referred to as a\n\"collision\") we add the entry to a chain of entries all of\nwhich map to the same value h(K). Ideally the function\n3\n\n\fone proposed in this work is that the state of all sites are\nrecorded (as described in appendix A), so it allows using a fast random number generator. The data blocking\nmethod method allows lattices of sufficient size to keep\nfinite-size effects under control, with sufficient speed to\nachieve good statistics. (The hashing method described\nin this paper could also have been used for this calculation.)\nIn 4D, we use a virtual lattice of (512)4 sites, broken up\ninto blocks of (16)4 sites each. In 5D, the virtual lattice of\nsize (128)5 is divided into blocks of size 85 . The clustersize cutoff, smax , is 217 = 131, 072 and 214 = 16, 384 for\n4D and 5D, respectively. The threshold is determined as\nthe value of p that leads to the cluster size distribution ns\nbest following a power-law ns \u223c s\u2212\u03c4 . Simulating about\n108 clusters for each case, and using the data analysis\ntechniques employed in [5], we find\n\uf8f1\n0.196889 \u00b1 0.000003 [4D site]\n\uf8f4\n\uf8f2\n0.160130 \u00b1 0.000003 [4D bond]\npc =\n.\n(13)\n[5D site]\n\uf8f4\n\uf8f3 0.14081 \u00b1 0.00001\n0.118174 \u00b1 0.000004 [5D bond]\n\nthe next chemical shell and (ii) state information about\nall sites in the chemical shell previous to the one being\nbuilt. Before we add a site to the list of growth sites, we\ncheck if it is already present in the previous shell; if it is,\nwe do not add it.\nThe size of a chemical shell can be estimated as follows.\nThe chemical distance, l, scales with the mean Euclidean\nradius of the cluster, r, as\nl \u223c rdmin ,\n\n(9a)\n\nwhile the cluster mass (the number of sites in the cluster),\ns, scales as\ns \u223c r df ,\n\n(9b)\n\nwhere dmin has values 1.13 and 2 for d = 2 and 6, respectively [2,3,15,16]; df , the fractal dimension of the cluster\nmass, has the exact values 91/48 = 1.89 and 4 for d = 2\nand 6, respectively [1,2]. Then\ns \u223c ldf /dmin ,\n\n(10)\n\nAlso, for \u03c4 we find the values\n\u001a\n2.313 \u00b1 0.003 [4D]\n\u03c4=\n.\n2.412 \u00b1 0.0004 [5D]\n\nand\nds \u223c l(df /dmin)\u22121 dl = (sdmin /df )(df /dmin )\u22121 dl =\ns1\u2212(dmin/df ) dl.\n\nThese results are more precise than some of the published\nvalues for pc = 0.16005 \u00b1 0.00015 [17], 0.1407 \u00b1 0.0003\n[18], and 0.11819 \u00b1 0.00004 [17] for 4D bond, 5D site,\nand 5D bond percolation, respectively and for \u03c4 = 2.41\nfor 5D percolation; for 4D site percolation, Ballesteros\net al. [19] found the comparably precise value pc =\n0.196901 \u00b1 0.000005 (just slightly higher than ours) and\n\u03c4 = 2.3127 \u00b1 0.0007. All simulation parameters and our\nresults are summarized in Table I.\nThe precision of our results is sufficiently high that we\nexpect that statistical errors in pc will not have an effect\non our value of dmin .\n\n(11)\n\nSetting dl = 1, we find the size of the outermost chemical\nshell of a cluster of mass s scales as\nsshell (s) \u223c s\u03b8\n\n(14)\n\n(12)\n\nwhere \u03b8 = 1 \u2212 dmin /df .\nThe values of \u03b8 range from \u2248 0.4 to 0.5 for d = 2 to\nd = 6. Thus the size of the data structure to contain the\nvisited status is only of the order of the square root of\nthe size of the cluster size because we only store status\nfor the largest chemical shell.\n\nIV. SHORTEST PATH EXPONENT\nIII. PERCOLATION THRESHOLD AND FISHER\nEXPONENT\n\nTo calculate the shortest path exponent, we ran simulations at the percolation thresholds found above. We\nstopped cluster growth at lmax = 2048 for 4D bond and\nsite percolation and lmax = 1024 for 5D bond and site\npercolation. We simulated 73 \u00d7 106 , 39 \u00d7 106 , 105 \u00d7 106 ,\nand 20 \u00d7 106 realizations for 4D bond, 4D site, 5D bond,\nand 5D site percolation, respectively. During our simulations, we kept track of the maximum and minimum\nlattice points to which our clusters extended. Using this\ninformation, we determined the size of the lattice that we\nwould have needed to build if we had been using conventional memory techniques. For d = 5 the lattice would\nhave had sides of length L = 245 resulting in approximately 900 \u00d7 109 lattice sites (\u2248 1TB memory); the actual memory used was less than \u2248 106 (1MB), six orders\nof magnitude smaller.\n\nIn order to determine dmin to high precision and without bias, it is necessary to first find values of the percolation threshold substantially more precise than previously\nknown (in most cases). To determine these thresholds\nwe used the method of measuring cluster-size statistics\nof individual clusters grown on large virtual lattices as\ndescribed in [6]. The data-blocking method [5] used involves assigning memory to parts of the lattice only when\nthe cluster grows into it. With the data-blocking method,\nlike the hashing method, a table is used to access a data\nstructure but in this case, the data structure entries represent blocks of sites instead of individual sites; there are\nno collisions, but some memory is wasted. The advantage of using the data-blocking method as opposed to the\n4\n\n\ftwo point at l and 2l is the value of the slope between\nthese points in a log-log plot of hr(l)i\n\nFigure 2a shows plots of hri for 4D site and bond percolation, while Fig. 2b shows plots of hri for 5D site\nand bond percolation. While the plots resemble straight\nlines, the effects of corrections-to-scaling are, in fact, considerable. One customarily assumes that corrections-toscaling have the functional form [1\u20134]\nz\n\nhri \u223c l (1 + Al\n\n\u2212\u2206\n\n+ * * *),\n\nz(l) =\n\nThe l = 0 intercept of a plot of z(l) will be an estimate\nfor z, and the slope will be proportional to A. Our best\nestimate for \u2206 for d = 4 and d = 5 is 0.4 < \u2206 < 0.6, so we\nuse a value of \u2206 of 0.5 and plot z(l) for 4D site and bond\npercolation in Fig. 5a and 5D site and bond percolation\nin Fig. 5b. In Fig. 5a, the fact that the slopes of the lines\nchange suggests that we are seeing the effects of both the\ncorrection-to-scaling term in Eq. (15) as well as higher order terms which become less significant at larger values\nof l. In general, it is more efficient to generate smaller\nclusters and more of them, rather than fewer, larger ones.\nHowever, if the corrections-to-scaling are not well understood or large, then one must build the largest clusters\npossible. As we see here, strong corrections-to-scaling\nare present in 4D percolation where the plots of effective\nslope change at large l. If we had used smaller clusters using traditional memory-management techniques\nwe would have obtained incorrect results. In Fig. 5a,\nthe almost horizontal plot for site percolation indicates\nthat the amplitude, A, of the correction-to-scaling term\nis very small. From these plots and our estimates above\nof bounds on z, we estimate\n\u001a\n0.622 \u00b1 0.002 [4D]\nz=\n.\n(18)\n0.552 \u00b1 0.002 [5D]\n\n(15)\n\nwhere the constant A depends on the dimension, lattice\ntype and percolation type (bond or site) but the exponent \u2206 depends only on dimension. Let\nh(l) \u2261\n\nhri\nz\u2212z \u2032\n(1 + Al\u2212\u2206 + * * *),\n\u2032 \u223c l\nz\nl\n\nln[hr(2l)i] \u2212 ln[hr(l)i]\nln[hr(2l)i/hr(l)i]\n=\n. (17)\nln[2l] \u2212 ln[l]\nln[2]\n\n(16)\n\nwhere z \u2032 is an estimated value of z. If lmax were infinitely\nlarge, we could determine z as the value of z \u2032 , which results in a plot of h(l) which asymptotically approaches a\nconstant (i.e., has zero slope as l \u2192 \u221e); however, since\nlmax is finite, we may obtain misleading results if we determine z in this manner. Nevertheless, we can use this\napproach to determine bounds on z.\nTo see how this is accomplished, first consider Fig. 3a,\nin which we plot h(l) for 4D bond percolation for various values of z \u2032 . From this figure and Eq. (16) it is clear\nthat A is positive. Hence, we know that if for large l the\nslope of h(l) becomes an increasing function, the lead\u2032\ning power-law term lz\u2212z will dominate because z > z \u2032 .\nThus a lower bound on z is that value of z \u2032 at which h(l)\nasymptotically becomes an increasing function. From\nFig. 3a this value is 0.620.\nWe can proceed similarly by considering site percolation in 4D, plotting h(l) for 4D site percolation for various values of z \u2032 in Fig. 3b. From these plots it is clear\nthat A for bond percolation is negative. Hence we know\nthat if for large l the slope of h(l) becomes a decreasing\n\u2032\nfunction, we are seeing the leading power-law term lz\u2212z\ndominate because z < z \u2032 . Thus an upper bound on z is\nthat value of z \u2032 at which h(l) asymptotically becomes a\ndecreasing function. From Fig. 3b this value is 0.625.\nProceeding in the same manner for site and bond percolation in 5D (see Fig. 4a,b), we find that the constant\nA is positive for both bond and site percolation, allowing\nus to determine only an upper bound of z = 0.5515 (the\nlower of the upper bounds for site and bond percolation).\nWhile this method of finding bounds on z by identifying the value of z \u2032 at which the slope of h(l) changes\nsign does not always yield both upper and lower bounds,\nit has the advantage that it does not require any estimation of the parameters A and \u2206 in Eq. (12) and, in\nfact, is somewhat insensitive to the exact form of the the\ncorrections-to-scaling terms.\nWe also analyze our data using another more\ncommonly-used method [3\u20135]. That method is to plot\nthe effective exponents, z(l), between points l and 2l versus l\u2212\u2206 using an estimated value of \u2206 which yields the\nstraightest line. The effective exponent, z(l), between\n\nIn terms of dmin , this corresponds to\n\u001a\n1.607 \u00b1 0.005 [4D]\ndmin =\n.\n1.812 \u00b1 0.006 [5D]\n\n(19)\n\nThe previously published values for dmin are 1.5 and 1.8\nfor 4D and 5D [1]. Thus our estimates of dmin are of considerably higher accuracy than the existing ones and have\naccuracy comparable to that for the estimate of dmin in\n3 dimensions, 1.374 \u00b1 0.006 [3]. Our results and all simulation parameters are summarized in Table II.\nV. DISCUSSION\n\nWe have developed a technique which allows us to build\nvery large percolation clusters using very little memory. In fact, using the method described here, relative\nto computer processing power available today and in the\nforeseeable future, computer memory is no longer a constraint on building percolation clusters near the percolation threshold. The critical computer resource thus\nbecomes solely processing power. For example, by extrapolating from our simulations, we find that with our\nmethod, with less than 108 bytes of memory, we could\nbuild a 5D cluster of 1012 sites, which would have required a lattice of 1017 sites, and reach a value of lmax of\n5\n\n\f107 (versus the 1024 cutoff we used in our simulations).\nBut the time to build a single trillion-site cluster would\nbe about 2000 hours on current workstations. As processor speeds increase, our technique for reducing memory\nusage should allow critical exponents and constants to be\ndetermined with greater precision. Current techniques of\ngrowing clusters, including the one described in this paper, require computer processing resource of O(s), where\ns is the size of the cluster grown.\nWe note that the technique we have developed is useful when we can count the quantities in which we are\ninterested as we build the cluster (e.g., cluster mass, average distance to sites in a chemical shell). On the other\nhand, it is not clear how we could calculate the mass\nof the backbone, for example, using our method because\ncurrent methods of determining backbone mass require\nknowing all the sites in the cluster, not just those in the\ncurrent chemical shell. To obtain backbone properties\none could, however, reduce memory required to \u223c s (versus Ld ) by maintaining information about all visited sites\n(not just those in the current chemical shell) in a data\nstructure as opposed to maintaining the full lattice data\nstructure [11]. In Appendix A, we describe an alternative method of cluster generation which can be used when\ninformation about all visited sites must be maintained.\nFinally, it is useful to compare our method with\nthe Hoshen-Kopelman method [20], which constructs all\nclusters in a d-dimensional lattice by successively populating d \u2212 1 dimensional slices of the lattice. Memory is\nused to store the last and current slice of the lattice so the\nmemory needed scales as Ld\u22121 . The Hoshen-Kopelman\nmethod is much less memory efficient than the method\npresented here, and becomes less effective as the dimension increases since Ld\u22121 /Ld \u2192 1 with increasing d. Also,\nthe Hoshen-Kopelman method cannot be used to calculate dmin . On the other hand, the Hoshen-Kopelman\nmethod is better suited to other problems, such as calculating the number of clusters that span across a rectangular system, than our method, based on the Leath\nalgorithm.\n\n(ii) an adjacent site is not vacant we simply do not\nmake a determination of whether the bond is occupied.\nIn this way we make a determination about whether a\ngiven bond is occupied no more than once.\nNow consider the case in which we do have a need to\nknow whether a bond is occupied or not (e.g., we are\ncounting the number of bonds in the cluster or we will\nbe determining the backbone of the cluster). In this case,\nwhen considering a growth site, if:\n(i) an adjacent site is vacant, we determine whether\nthe bond connected to that site is occupied or not.\n(ii) an adjacent site is not vacant and is in a higher\nchemical shell, we also determine whether the bond\nis connected to that site is occupied or not.\n(iii) an adjacent site is not vacant and is in the same\nchemical shell as the growth site, we make a determination about whether the bond is occupied only\nif the direction from the growth site to the adjacent site is positive. In this way, the determination\nabout whether the bond is occupied is done only\nonce. This situation arises in non-cubic (e.g., triangular) lattices and when we start cluster growth\nwith multiple seeds.\n(iv) an adjacent site is not vacant and is in a lower\nchemical shell than the growth site, we make no\ndetermination about whether the bond to that site\nis occupied; whether the bond is occupied has been\ndetermined earlier in the growth process. In fact,\nthe bond must be unoccupied because if it were\noccupied we would have reached the growth site\nearlier directly from the adjacent site.\nThus we ensure that we determine whether a bond is occupied once and only once. If one needs to keep a record\nof whether a given bond is occupied (e.g., to later determine the backbone) this information can be stored in the\nentry in the data structure for the site with which the\nbonds are associated along with the coordinates of the\nsite, etc.\nThis method trades off memory (we keep state for\nall visited sites) versus performance (we can use the\nfaster traditional random number generators as opposed\nto the encryption-like random number generator). Also,\nin cases where we, for some other reason, must keep state\ninformation about all the sites, we can obtain the benefit\nof the using a faster random number generator.\n\nAppendix A: Alternative Method of Cluster Growth\n\nWe discuss a variant of our approach in which we still\nstore information concerning which sites are visited in\na data structure and access the entries using a hash table. However, if one stores information about all visited\nsites, not just for those in the last shell(s), then a traditional random number generator (one which does not\ntake the coordinates/orientation of the bond as input)\ncan be used. Let us first consider the case where we have\nno need for occupied bond information (e.g., we are simply counting the number of sites in the cluster). When\nconsidering a growth site, if:\n\nAcknowledgements\n\nWe thank S. V. Buldyrev, D. Stauffer, and Y. Ashkenazy for helpful discussions, and BP Amoco and NSF for\nfinancial support.\n\n(i) an adjacent site is vacant we determine whether the\nbond connected to that site is occupied or not.\n6\n\n\f[10] We will use bond percolation in our discussion here. Application to site percolation is straightforward.\n[11] H. Vollmayr, J. Stat. Phys. 74, 919 (1994).\n[12] W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B.\nP. Flannery, Numerical Recipes in C, 2nd Edition (Cambridge University Press, Cambridge, 1992), p. 300.\n[13] R. M. Ziff, Computers in Physics 12, 385 (1998).\n[14] D. E. Knuth, Sorting and Searching, The Art of Computer Programming, Vol. 3 (Addison-Wesley, Reading\nMA, 1973), p. 513.\n[15] R. Pike and H. E. Stanley, J. Phys. A 14, L169 (1981).\n[16] H. J. Herrmann and H. E. Stanley, J. Phys. A 21, L829\n(1988).\n[17] J. Adler, Y. Meir, A. Aharony, and A. B. Harris, Phys.\nRev. B, 41,9183 (1990)\n[18] S. C. van der Marck, J. Phys. A 31, 3449 (1998).\n[19] H. G. Ballesteros, L. A. Fernandez, V. Martin-Mayor, A.\nMunoz Sudupe, G. Parisi, and J. J. Ruiz-Lorenzo, Phys.\nLett. B400, 346 (1997).\n[20] J. Hoshen and R. Kopelman, Phys. Rev. B 14, 3438\n(1976).\n\n[1] D. Stauffer and A. Aharony, Introduction to Percolation\nTheory, 2nd Edition (Taylor and Francis, London, 1994).\n[2] A. Bunde and S. Havlin, eds., Fractals and Disordered\nSystems, 2nd Edition (Springer, New York, 1996).\n[3] P. Grassberger, J. Phys. A: Math. Gen. 25, 5475 (1992).\n[4] P. Grassberger, J. Phys. A: Math. Gen. 25, 5867 (1992).\n[5] R. M. Ziff, P. T. Cummings, and G. Stell, J. Phys. A 17,\n3009 (1973).\n[6] C. D. Lorenz and R. M. Ziff, Phys. Rev. E. 57, 230\n(1998).\n[7] D. Stauffer and R. M. Ziff, Int. J. Mod. Phys. C 11, 205\n(2000).\n[8] The density of a cluster of size L is (1/L)d\u2212df where df\nis the fractal dimension. Since the co-dimension, d \u2212 df ,\nincreases with d, the density decreases with d.\n[9] P. L. Leath, Phys. Rev. B 14, 5046 (1976).\n\n7\n\n\fTABLE I. Simulation parameters and results for pc and the Fisher exponent \u03c4 .\ndimension\n\ntype\nbond\n\n# of realizations\n108\n\nsmax\n131 073\n\npc\n0.160130 \u00b1 0.000003\n\nsite\nbond\n\n108\n108\n\n131 073\n16 383\n\n0.196889 \u00b1 0.000003\n0.118174 \u00b1 0.000004\n\nsite\n\n108\n\n16 383\n\n0.14081 \u00b1 0.00001\n\n4\n\n\u03c4\n2.313 \u00b1 0.003\n\n5\n\n2.412 \u00b1 0.004\n\nTABLE II. Simulation parameters and results for the spreading exponent z and shortest path exponent dmin .\ndimension\n\ntype\nbond\n\npc\n0.160130\n\n# of realizations\n73 \u00d7 106\n\nlmax\n2048\n\nsite\nbond\n\n0.196889\n0.118174\n\n39 \u00d7 106\n105 \u00d7 106\n\n2048\n1024\n\nsite\n\n0.14081\n\n20 \u00d7 106\n\n1024\n\n4\n\n5\n\n8\n\nz\n\ndmin\n\n0.622 \u00b1 0.002\n\n1.607 \u00b1 0.005\n\n0.552 \u00b1 0.002\n\n1.812 \u00b1 0.006\n\n\f(a)\n\nA C\nB\n\n(b)\n\n(c)\n\nC\nA D\nB\n\nA\nB\n\nC\nD\n\nFIG. 1. Examples of cluster growth at the beginning of the population of sites at chemical distance 3 from the seed site.\nThe seed sites are denoted by striped circles. (a) Example of a square lattice in which a site, C, is multiply-visited from sites\nA and B. (b) Example of a triangular lattice in which site C can be multiply-visited from sites A and D and in which site\nD can be multiply-visited from sites B and C. (c) Example in which the cluster is grown from multiple seeds. Site C can be\nmultiply-visited from sites A and D; site D can be multiply-visited from sites B and C.\n\n9\n\n\fFIG. 2. Euclidean distance hri versus chemical distance l for site percolation (upper line) and bond percolation (lower line)\nfor (a) 4D and (b) 5D. The slightly different apparent slopes of the plots for bond and site cases are due to different values of\nthe correction-to-scaling parameters.\n\n10\n\n\fFIG. 3. h(l) \u2261 hri/lz versus l for (a) 4D bond percolation for values of (from top to bottom) z \u2032 = 0.615, 0.620 and 0.625 (b)\n4D site percolation for values of (from top to bottom) z \u2032 = 0.623, 0.625, and 0.627. The dashed horizontal lines are provided\nas guides to the eye to allow one to better see that, for large l, the middle plots of h(l) in (a) and (b) are increasing and\ndecreasing, respectively.\n\n11\n\n\fFIG. 4. h(l) \u2261 hri/lz versus l for (a) 5D site percolation for values of (from top to bottom) z \u2032 = 0.5510, 0.5515 and 0.5520,\nand (b) 5D bond percolation for values of (from top to bottom) z \u2032 = 0.5595, 0.5615, and 0.5635. The dashed horizontal lines\nare provided as guides to the eye to allow one to better see that, for large l, the the middle plots of h(l) in (a) and (b) are\ndecreasing.\n\n12\n\n\fFIG. 5. Effective exponent z versus 1/l\u2212\u2206 with \u2206 = 0.5 for bond percolation (upper line) and site percolation (lower line)\nfor (a) 4D and (b) 5D.\n\n13\n\n\f"}