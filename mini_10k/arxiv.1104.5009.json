{"id": "http://arxiv.org/abs/1104.5009v2", "guidislink": true, "updated": "2011-05-03T19:05:31Z", "updated_parsed": [2011, 5, 3, 19, 5, 31, 1, 123, 0], "published": "2011-04-26T19:58:46Z", "published_parsed": [2011, 4, 26, 19, 58, 46, 1, 116, 0], "title": "3-List Colouring Permutation Graphs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.0886%2C1104.5357%2C1104.5152%2C1104.2705%2C1104.1860%2C1104.4165%2C1104.3659%2C1104.0604%2C1104.0052%2C1104.1653%2C1104.0259%2C1104.4914%2C1104.4666%2C1104.4345%2C1104.1451%2C1104.0997%2C1104.4253%2C1104.1663%2C1104.3458%2C1104.0769%2C1104.0075%2C1104.0563%2C1104.3748%2C1104.5422%2C1104.4724%2C1104.3537%2C1104.1289%2C1104.1444%2C1104.1949%2C1104.0262%2C1104.2461%2C1104.3733%2C1104.0929%2C1104.1854%2C1104.0985%2C1104.0425%2C1104.3112%2C1104.5369%2C1104.2020%2C1104.3077%2C1104.4455%2C1104.0396%2C1104.1665%2C1104.2958%2C1104.5673%2C1104.5170%2C1104.2258%2C1104.1356%2C1104.1857%2C1104.4984%2C1104.3015%2C1104.4592%2C1104.5009%2C1104.2668%2C1104.2346%2C1104.0925%2C1104.2739%2C1104.3885%2C1104.0057%2C1104.5693%2C1104.1102%2C1104.4375%2C1104.4121%2C1104.4485%2C1104.1891%2C1104.0245%2C1104.3080%2C1104.0669%2C1104.5376%2C1104.2529%2C1104.5278%2C1104.4063%2C1104.4098%2C1104.5437%2C1104.5267%2C1104.0010%2C1104.1953%2C1104.0601%2C1104.4909%2C1104.2978%2C1104.0009%2C1104.1643%2C1104.1468%2C1104.5689%2C1104.5665%2C1104.5521%2C1104.1003%2C1104.4316%2C1104.5669%2C1104.3786%2C1104.3902%2C1104.2899%2C1104.2735%2C1104.4330%2C1104.4778%2C1104.4690%2C1104.3901%2C1104.5353%2C1104.1181%2C1104.0238%2C1104.1990&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "3-List Colouring Permutation Graphs"}, "summary": "3-list colouring is an NP-complete decision problem. It is hard even on\nplanar bipartite graphs. We give a polynomial-time algorithm for solving 3-list\ncolouring on permutation graphs.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1104.0886%2C1104.5357%2C1104.5152%2C1104.2705%2C1104.1860%2C1104.4165%2C1104.3659%2C1104.0604%2C1104.0052%2C1104.1653%2C1104.0259%2C1104.4914%2C1104.4666%2C1104.4345%2C1104.1451%2C1104.0997%2C1104.4253%2C1104.1663%2C1104.3458%2C1104.0769%2C1104.0075%2C1104.0563%2C1104.3748%2C1104.5422%2C1104.4724%2C1104.3537%2C1104.1289%2C1104.1444%2C1104.1949%2C1104.0262%2C1104.2461%2C1104.3733%2C1104.0929%2C1104.1854%2C1104.0985%2C1104.0425%2C1104.3112%2C1104.5369%2C1104.2020%2C1104.3077%2C1104.4455%2C1104.0396%2C1104.1665%2C1104.2958%2C1104.5673%2C1104.5170%2C1104.2258%2C1104.1356%2C1104.1857%2C1104.4984%2C1104.3015%2C1104.4592%2C1104.5009%2C1104.2668%2C1104.2346%2C1104.0925%2C1104.2739%2C1104.3885%2C1104.0057%2C1104.5693%2C1104.1102%2C1104.4375%2C1104.4121%2C1104.4485%2C1104.1891%2C1104.0245%2C1104.3080%2C1104.0669%2C1104.5376%2C1104.2529%2C1104.5278%2C1104.4063%2C1104.4098%2C1104.5437%2C1104.5267%2C1104.0010%2C1104.1953%2C1104.0601%2C1104.4909%2C1104.2978%2C1104.0009%2C1104.1643%2C1104.1468%2C1104.5689%2C1104.5665%2C1104.5521%2C1104.1003%2C1104.4316%2C1104.5669%2C1104.3786%2C1104.3902%2C1104.2899%2C1104.2735%2C1104.4330%2C1104.4778%2C1104.4690%2C1104.3901%2C1104.5353%2C1104.1181%2C1104.0238%2C1104.1990&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "3-list colouring is an NP-complete decision problem. It is hard even on\nplanar bipartite graphs. We give a polynomial-time algorithm for solving 3-list\ncolouring on permutation graphs."}, "authors": ["Jessica Enright", "Lorna Stewart"], "author_detail": {"name": "Lorna Stewart"}, "author": "Lorna Stewart", "links": [{"href": "http://arxiv.org/abs/1104.5009v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1104.5009v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1104.5009v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1104.5009v2", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "3-List Colouring Permutation Graphs\n\narXiv:1104.5009v2 [cs.DM] 3 May 2011\n\nJessica Enright\n\nLorna Stewart\n\nAbstract\n3-list colouring is an NP-complete decision problem. It is hard even on\nplanar bipartite graphs. We give a polynomial-time algorithm for solving\n3-list colouring on permutation graphs.\n\n1\n\nIntroduction\n\nIn the vertex colouring problem, we try to assign each vertex in a graph a\ncolour such that no two adjacent vertices are assigned the same colour using the\nminimum number of colours.\nIn the vertex list colouring problem, each vertex has a list of colours, and we\ntry to assign each vertex a colour from its list such that no two vertices are assigned the same colour. Determining if this is possible is a decision problem and\nis NP-complete, as it is a generalization of vertex colouring [3]. List colouring\nremains hard even on interval graphs [2].\nList colouring with fixed colour bound of 3 is a generalization of 3-vertex\ncolouring, and so is NP-complete. It remains NP-complete on planar bipartite\ngraphs [4], but is solvable in polynomial time on graphs of fixed treewidth [2].\nWe give a polynomial-time algorithm for solving list colouring with fixed colour\nbound three on a class of intersection graphs that does not have fixed treewidth.\nPermutation graphs are exactly comparability cocomparability graphs - the\ngraphs that admit transitive orientations of both their edges and their nonedges.\nIn this paper we give a polynomial algorithm for list colouring with a fixed colour\nbound of 3 on permutation graphs.\nOur algorithm uses the layers of a breadth-first search rooted at a particular\nvertex in what we call a multi-chain ordering. This ordering is closely related to\nthe strong ordering used by Heggernes et al. [1] to compute the bandwidth of\nbipartite permutation graphs in polynomial time. Our ordering, which applies\nto the larger class of permutation graphs, is expressed in terms of the layers\nof a breadth first search. This sort of ordering gives insight into the structure\nof permutation graphs, and may lead to to algorithms for other problems on\npermutation graphs.\n\n2\n\nDefinitions and Preliminaries\n\nA graph G = (V, E) is a tuple of vertex set V and edge set E composed of\nsubsets of V of size two. All graphs that we consider are connected, finite,\nsimple, and loopless. A directed graph G = (V, E) is a tuple of vertex set V\nand edge set E composed of ordered pairs of V .\n\n1\n\n\fA transitive orientation of the edges of a graph is an orientation such that\nthe presence of edge (u \u2192 v) and (v \u2192 w) implies edge (u \u2192 w). A comparability graph is a graph that admits a transitive orientation of its edges.\nA cocomparability graph is a graph that admits a transitive orientation of its\nnonedges.\nLet G = (V, E) be a graph. A list mapping of G is a mapping that assigns\nto each vertex in G a list of colours. A colouring of G that obeys a list mapping\nP of G is a colouring such that every vertex is assigned a colour that is in that\nvertex's list in P. A 3-list colouring is a proper list colouring in which at most\nthree colours are used.\nWe might sometimes say that a list mapping precolours a vertex. By this\nwe mean that the list mapping assigns a list with only a single colour to that\nvertex.\n\n2.1\n\nMulti-chain ordering\n\nLet G = (V, E) be a graph and L = [L0 ...Lk ] be the layers of a breadth-first\ntraversal of G with vertex v0 as the starting point. We call L a multi-chain\nordering of G if for every two vertices u, v in layer Li the neighbourhood of u\nin Li\u22121 is a subset of the neighbourhood of v in Li\u22121 (or vice versa) and the\nneighbourhood of u in Li+1 is a subset of the neighbourhood of v in Li+1 (or\nvice versa).\n\u2192\n\u2212\n\u2192\n\u2212\nLemma 1. Let G = (V, E ) be a transitive orientation of a comparability graph\nG = (V, E) in which v0 is a source or a sink, and [L0 ...Lk ] be the layers of\na breadth first search traversal of G starting at v0 . For every two consecutive\n\u2192\n\u2212\nlayers Li , Li+1 for 0 \u2264 i < k, either all edges in E between vertices of Li and\n\u2192\n\u2212\nLi+1 are directed toward Li or all edges in E between vertices of Li and Li+1\nin are directed toward Li+1 .\n\u2192\n\u2212\nProof. This follows from the fact that v0 is a source or sink in G , and the\nobservation that there are no edges between nonconsecutive layers of a breadth\nfirst search.\n\u2192\n\u2212\n\u2192\n\u2212\nLemma 2. Let G = (V, E ) be a transitive orientation of the complement of\na comparability graph G = (V, E) in which v0 is a sink and L = [L0 ...Lk ] are\nthe layers of a breadth-first search traversal of G starting at v0 . Then for every\npair of layers Li , Lj where 0 \u2264 i < j \u2264 k all nonedges between Li and Lj are\ndirected toward Li .\nProof. We proceed by induction. First, consider the level L0 . Because the only\nvertex on L0 is a sink in G, all nonedges between another level and the vertex\non level L0 are directed toward L0 .\nAssume that for every layer Lh such that h \u2264 i, all nonedges between Lh\nand a layer of index greater than h are directed toward Lh . Then consider Li+1 .\nNow we continue by contradiction. Assume that there is a nonedge between\nvertex vi+1 in Li+1 and vertex vj in some layer Lj where j > i that is directed\ntoward Lj . Let vi be a neighbour of vi+1 in layer Li . Because the layers are\nproduced by a breadth first traversal, there is a nonedge between vj and vi ,\nand by the inductive assumption, it is directed toward vi . Then we have in G\n\n2\n\n\fa nonedge directed from vi+1 to vj and from vj to vi , but no nonedge between\nvi and vi+1 , a contradiction.\n\u2192\n\u2212\nLemma 3. Let G = (V, E) be a permutation graph and let G be a transitive\n\u2192\n\u2212\norientation of G in which v0 is a source or a sink, and G a transitive orientation\nof the complement of G in which v0 is a sink. Let L = [L0 ...Lk ] be the layers\nof a breadth-first search traversal of G rooted at v0 . Then L is a multi-chain\nordering.\nProof. Let u, v be two vertices on Li . We consider two cases: if u, v are adjacent,\nand if they are not adjacent.\nWe proceed by contradiction. Assume that u, v are adjacent and that there\nare vertices x, y in Li+1 such that x is adjacent to u but not v and y is adjacent\nto v but not u. By Lemma 1, the edges between u and x and between v and y\nare either both directed toward Li , or both directed toward Li+1 . In either case\nthere is no transitive orientation of the edge between u and v, a contradiction.\nSimilarly, if x, y are in Li\u22121 by Lemma 1, the edges are either both directed\ntoward Li , or both directed toward Li+1 . In either case there is no transitive\norientation of the edge between u and v, a contradiction.\nNow assume that u, v are not adjacent and that there are vertices x, y in\nLi+1 such that x is adjacent to u but not v and y is adjacent to v but not u.\nBy Lemma 2, these nonedges are directed as (x \u2192 v) and (y \u2192 u). Then there\nis no transitive orientation of the nonedge between u and v, a contradiction.\nSimilarly, if x, y are in Li\u22121 then by Lemma 2, these nonedges are directed as\n(v \u2192 x) and (u \u2192 y). Then there is no transitive orientation of the nonedge\nbetween u and v, a contradiction.\nWe have shown that whether or not two vertices u, v on layer Li are adjacent,\nthe neighbourhood of one in Li\u22121 is a subset of the neighbourhood of the other\nin Li\u22121 , and the neighbourhood of one in Li+1 is a subset of the neighbourhood\nof the other in Li+1 .\nTheorem 4. Every permutation graph has a multi-chain ordering.\nProof. This follows from the comparability cocomparability orderings of permutation graphs and the previous three lemmas.\nBut also observe that:\nObservation 5. Not every graph with a multi-chain ordering is a permutation\ngraph.\nWhat does this neighbourhood containment mean for our list colouring? In\neach layer there is a vertex with a maximal neighbourhood in the previous layer,\nand a vertex with a maximal neighbourhood in the following layer. Because each\nvertex in a layer has at least one neighbour in the previous layer, this means\nthat there is a vertex in each layer adjacent to all vertices in the next layer.\nTherefore:\nObservation 6. No single layer in a multi-chain ordering can have vertices of\nmore than two colours in it in a valid 3-list-colouring.\n\n3\n\n\fAlso observe that because there is a vertex in each layer adjacent to all\nvertices in the next layer that there are no triangles on any layer. Then we can\ndeal with each layer as a collection of connected bipartite components.\nLet G = (V, E) be a graph with multi-chain ordering L = [L0 ...Lk ], and list\nmapping P. A good colour assignment Q is a relation between the three colours\nand the layers in L such that each layer is assigned exactly two colours, two\nadjacent layers are not assigned the same two colours, and if there is a vertex\non layer Li that is precoloured Cx by P, then Cx is one of the colours assigned\nto Li by Q. We use Q(i) to denote the colours assigned by Q to layer i.\nA list colouring C of graph G admits Q if every vertex is coloured by C with\na colour assigned to its layer by Q.\nA layer is precoloured with a colour by P if there is at least one vertex on\nlayer Li that is precoloured with that colour by P.\nLet vertex vi be on layer Li of a multi-chain ordering. Vertex vi is quasiprecoloured by colour assignment Q and list mapping P if any of the following\nare true:\n\u2022 There is a single colour in the intersection of P(vi ) and Q(i).\n\u2022 vi is adjacent to two vertices that are on opposite sides of a connected\nbipartite component of one of G[Li\u22121 ] or G[Li+1 ]\n\u2022 vi is in a connected bipartite component of G[Li ] such that at least one\nother vertex in that connected bipartite component is quasi-precoloured\nVertices vi in Li , and vi+1 in Li+1 are almost-adjacent if vi+1 is part of a\nbipartite component Cj with bipartition B1 , B2 where vi+1 is in B2 and vi is\nadjacent to at least one vertex in B2 . Two vertices are almost-neighbours if they\nare almost-adjacent. An almost-path P = [v1 ...vk ] is a sequence of vertices such\nthat for 1 < i < k vertex vi is almost-adjacent to vertices vi\u22121 and vi+1 .\nA quasi-bad chain P = [vh ...vl ] is a sequence of vertices in layers Lh ...Ll\nsuch that:\n\u2022 Each vertex is in a different layer, proceeding consecutively through L and\n\u2022 Vertices vi , vi+1 are either adjacent or almost-adjacent and\n\u2022 Each layer Li for h < i < l is assigned two colours Cx , Cy by Q such that\nCx is assigned to Li\u22121 and Cy is assigned to Li+1 and\n\u2022 vh is quasi-precoloured with the colour assigned to Lh+1 but not Lh+2 ,\nand\n\u2022 vl is quasi-precoloured with the colour assigned to Ll\u22121 but not Ll\u22122 .\nLet Q be a good assignment of colours to multi-chain ordering L. Let\nP = [vh ...vl ] be a quasi-bad chain, given Q. Observe that:\nObservation 7. Q does not assign the same colour to three consecutive layers that contain vertices of P , nor does it assign the same colour pairs to two\nconsecutive layers.\n\n4\n\n\fLet Ll be the highest-indexed layer in L that contains a vertex of quasi-bad\nchain P . We say that P is an N2 quasi-bad chain if for every other quasi-bad\nchain P \u2032 with respect to Q, the highest-indexed layer containing a vertex of P \u2032\nhas index at most h.\nGiven a good colour assignment Q to multi-chain ordering L of G = (V, E)\nwith list mapping P, how can we produce a 3-list colouring of the vertices of G\nthat is consistent with Q and P?\nWe claim that we can use a simple greedy approach as given in Algorithm 1.\nThis algorithm traverses the layers of the multi-chain ordering from smallest to\nlargest index and colours vertices in each layer first if they are quasi-precoloured.\nIf a vertex is not quasi-precoloured, the algorithm tries to colour the vertex\nwith the colour its layer does not share with the next layer. As a last resort,\nit colours a vertex with the colour its layer shares with the next layer. The\nalgorithm handles all the vertices of a connected bipartite components of the\nlayer as a group.\nLemma 8. Let G = (V, E) be a graph with chain ordering L = [L0 ...Lk ], list\nmapping P, and let Q be a good assignment of colours to layers in L. If there\nis no 3-list colouring of G that admits Q, then there exists a quasi-bad chain\nP = [vh ...vl ] within L with respect to colour assignment Q.\nProof. If there is no 3-list colouring of G that admits Q, then Algorithm 1 will\nfail.\nWe first show that if the conservative colouring algorithm fails in the component colouring section, then there is a quasi-bad chain P = [vh ...vl ] within\nL with respect to colour assignment Q. Assume that the component colouring\nalgorithm fails. Then let C be the component on layer Li on which the section\nfails and Cx and Cy be the colours assigned to Li by Q. There are no vertices\nin C that are quasi-precoloured by P.\nThen either a single vertex in C has neighbours outside of L of both colours\nCx , Cy , or vertices on both sides of the bipartition of C have neighbours of one\nof colour Cx or Cy . We consider these three cases.\nIf a single vertex in C has neighbours outside of L of both colours Cx , Cy ,\nthe neighbour vi+1 of colour Cy is in layer Li+1 and the neighbour vi\u22121 of colour\nCx is in layer Li\u22121 . Because the execution of Algorithm 1 has not yet reached\nLi+1 , vertex vi+1 must be quasi-precoloured.\nVertex vi is a vertex that is not quasi-precoloured, is coloured by the conservative algorithm with the colour layer Li shares with layer Li+1 and there is\nan almost-path between vi\u22121 and vi such that every vertex on the path is not\nprecoloured, and is coloured by the conservative algorithm with the colour its\nlayer shares with the next layer.\nLet vj on level Lj be a vertex with those properties such that j is minimal.\nThen vj is only coloured with the colour Lj shares with Lj+1 because it has a\nneighbour of the colour Lj does not share with Lj+1 . Then, by the minimality\nof j, this neighbour must be quasi-precoloured. We refer to it as vj\u22121 . The\npath from vj\u22121 to vi+1 that contains no other quasi-precoloured vertices is by\ndefinition a quasi-bad chain.\nIf vertices on both sides of the bipartition of C have neighbours of colour\nCy , then at least one of those neighbours is adjacent to vertices on both sides\nof the bipartition of C, and so it is quasi-precoloured by P with colour Cz , a\ncontradiction to it being coloured Cy .\n5\n\n\fSimilarly, if vertices on both sides of the bipartition of C have neighbours of\ncolour Cx , then we can derive a contradiction.\nWe now proceed assuming that the Conservative Colouring Algorithm fails\nat some point other than while executing the component colouring section. Let\nvi be the first vertex encountered by Algorithm 1 that cannot be coloured and\nCx , Cy be the colours assigned to Li .\nVertex vi has at least one almost-neighbour that is coloured each of Cx , Cy .\nBecause the failure is outside the component colouring section, neither of these\ncoloured almost-neighbours are in layer Li .\nSince Li shares at most one colour with Li\u22121 and at most one with Li+1 ,\none of these neighbours is on level Li\u22121 and one (we will call it vi+1 ) on Li+1 .\nBecause of the execution of Algorithm 1, vi+1 is quasi-precoloured.\nVertex vi is a vertex that is not quasi-precoloured, is coloured by the conservative algorithm with the colour layer Li shares with layer Li+1 and there\nis a almost-path between vi\u22121 and vi such that every vertex on the path is not\nprecoloured, and is coloured by the conservative algorithm with the colour its\nlayer shares with the next layer.\nLet vj on level Lj be the lowest-numbered vertex with that property. Then\nvj is only coloured with the colour Lj shares with Lj+1 because it has an almostneighbour of the colour Lj does not share with Lj+1 . Then, by the minimality\nof j, this almost-neighbour must be quasi-precoloured. We refer to it as vj\u22121 .\nThe path from vj\u22121 to vi+1 that contains no other quasi-precoloured vertices is\nby definition a quasi-bad chain.\nThen from the previous lemma and the fact that a quasi-bad chain prevents\nany 3-list colouring it follows that:\nLemma 9. Let G = (V, E) be a graph with chain ordering L = [L0 ...Lk ], and\nlist mapping P. Let Q be a good assignment of colours to layers in L that obeys\nthe allowable pairs. There is a 3-list colouring of G that admits Q if and only\nif there is no quasi-bad chain within L, with respect to Q.\n\n3\n\nAllowable Colour Array\n\nOur approach to finding a 3-list colouring for a graph G = (V, E) with multichain ordering L = [L0 ...Lk ] is based on finding a good colour assignment Q of\ntwo colours to each layer in L such that there is a 3-list colouring of G in which\neach vertex on a layer is coloured with one of the two colours assigned to that\nlayer.\nTo do this we use an allowable colour array. For a graph G = (V, E) with\nmulti-chain ordering L = [L0 ...Lk ] an allowable array A will be an array of\nlength k. Each entry A[i] will contain a list of the pairs of colour assignments\nthat are allowable for Li , Li+1 .\nWhat do we mean by allowable? We mean that they have not been precluded\nby any of a number of rules we will develop. For example, an assignment of\ncolours 1, 2 is not allowable to a layer that has on it a vertex precoloured with\nthe colour 3. The remainder of this section is concerned with formally describing\nthe allowable array, and a polynomial-time algorithm for computing it given a\ngraph with a list mapping.\n\n6\n\n\fAlgorithm 1 Conservative Colouring Algorithm. Input: Graph G, list mapping\nP, good colour assignment Q, multi-chain ordering L, integer start, integer end.\nReturns: false if forced into an incorrect colouring, true otherwise.\n1: for all i from start to end do\n2:\nnotBelow \u2190 the colour assigned to Li but not Li+1 by Q\n3:\nwithBelow \u2190 the colour assigned to both Li and Li+1 by Q\n4:\nfor all uncoloured vj \u2208 Li do\n5:\nif vj is in a connected bipartite component of more than two vertices\nin Li then\n6:\nCOMMENT: Beginning of Component Colouring Section\n7:\nC \u2190 component in Li that contains v\n8:\nB1 \u2190 one side of bipartition of C\n9:\nB2 \u2190 other side of bipartition of C\n10:\nnotBelow \u2190 the colour assigned to Li but not Li+1 by Q\n11:\nwithBelow \u2190 the colour assigned to both Li and Li+1 by Q\n12:\nif a vertex in B1 has neighbour of colour notBelow then\n13:\ncolour all vertices in B1 with colour withBelow\n14:\ncolour all vertices in B2 with colour notBelow\n15:\nelse if a vertex in B2 has neighbour of colour notBelow then\n16:\ncolour all vertices in B1 with colour notBelow\n17:\ncolour all vertices in B2 with colour withBelow\n18:\nelse\n19:\nvB1 \u2190 member of B1 with maximal neighbourhood in Li+1\n20:\nvB2 \u2190 member of B2 with maximal neighbourhood in Li+1\n21:\nif (Li+1 \u2229 N (vB1 )) \u2282 (Li+1 \u2229 N (vB2 )) then\n22:\ncolour all vertices in B1 with colour withBelow\n23:\ncolour all vertices in B2 with colour notBelow\n24:\nelse\n25:\ncolour all vertices in B1 with colour notBelow\n26:\ncolour all vertices in B2 with colour withBelow\n27:\nend if\n28:\nend if\n29:\nCB1 \u2190 colour assigned to vertices in B1\n30:\nCB2 \u2190 colour assigned to vertices in B2\n31:\nif any vertex in B1 has a neighbour of colour CB1 then\n32:\nreturn false\n33:\nend if\n34:\nif any vertex in B2 has a neighbour of colour CB2 then\n35:\nreturn false\n36:\nend if\n37:\nCOMMENT: End of Component Colouring Section\n38:\nelse if vj has a neighbour of colour notBelow then\n39:\ncolour vj with withBelow\n40:\nif vj has a neighbour of colour withBelow then\n41:\nreturn false\n42:\nend if\n43:\nelse\n44:\ncolour vj with notBelow\n45:\nend if\n46:\nend for\n47: end for\n48: return true\n7\n\n\fLet A be an array of length k such that each entry A[i] contains a list of\npairs of colour assignments. Each colour assignment must consist of two distinct\ncolours. Let Q be a colour assignment of two colours to each layer in L such\nthat for every two adjacent layers Li , Li+1 , the colour assignments made by Q\nto Li , Li+1 are listed in A[i].\nLet Li , Li+1 be adjacent layers that are assigned Cx , Cy and Cy , Cz , respectively, by Q. We say that Li is adjustable with respect to A if Cx , Cz and Cy , Cz\nare listed as a pair in A[i].\nLet P = [vh ...vl ] be a quasi-bad chain, and Lh ...Ll the layers that contain\nmembers of P . We say that the colour assignments by Q to Ll , Ll\u22121 are quasibad forcing P with respect to A if no colour assignment to a layer Li where\nh \u2264 i < l \u2212 1 is adjustable with respect to A.\nLet A be an array of length k such that each entry A[i] contains a list of\npairs of colour assignments, each consisting of two distinct colours. A is an\nallowable array for G = (V, E), L, P if there is no pair of colour assignments\nCx , Cy and Cy , Cz to layers Li , Li+1 such that one of the following is true:\n\u2022 there is a vertex on Li precoloured by P with colour Cz , or a vertex on\nLi+1 precoloured by P with colour Cx ,\n\u2022 assigning these colours to these layers results in a quasi-precolouring such\nthat two adjacent vertices are given the same colour,\n\u2022 there is no pair of colour assignments for Li\u22121 , Li that assigns Cx , Cy to\nLi ,\n\u2022 there is no pair of colour assignments for Li+1 , Li+2 that assigns Cx , Cz\nto Li+1 ,\n\u2022 the colour assignments Cx , Cy and Cy , Cz to layers Li , Li+1 are quasi-bad\nforcing.\nWe say that a colour assignment Q to layers L obeys an allowable array A\nif for every two adjacent layers Li , Li+1 , the colour assignments made by Q to\nLi , Li+1 are listed as a possibility in A[i].\nLemma 10. If Algorithm 2 removes a pair of colour assignments from A then\nthere is no colouring of G that is consistent with those removed colour assignments. Algorithm 2 produces the allowable array of the input graph G, chain\nordering L and list mapping P.\nProof. We will argue this inductively.\nWe will show that if we remove an allowable pair from the listing during\nexecution of Algorithm 2, then there is no colouring of G that admits P in\nwhich that pair of colour assignments were assigned to their specified layers.\nConsider the first allowable pair that we remove. Let the pair removed be\nCx , Cy assigned to layer Li , and Cy , Cz assigned to Li+1 . There are four cases.\n\u2022 There is a vertex precoloured by P with Cz on Li , or a vertex precoloured\nby P with Cx on Li+1 .\n\u2022 Assigning Cx , Cy to layer Li , and Cy , Cz to layer Li+1 results in two\nadjacent vertices being quasi-precoloured the same colour.\n8\n\n\f\u2022 There is no allowable pair for Li\u22121 , Li in which Li is assigned Cx , Cy , or\nthere is no allowable pair for Li+1 , Li+2 in which Li+1 is assigned Cy , Cz .\n\u2022 Assigning Cx , Cy to layer Li , and Cy , Cz to layer Li+1 quasi-bad forces a\nbad chain P = [vh ...vi+1 ].\nBecause we call Algorithm 2 with an array that initially contains all possible\ncolour assignments for every pair of layers, no colour assignments can be quasibad forcing, so every layer is adjustable. Similarly, with an initially-full array,\nneither of the if statements on lines 11 or 15 will evaluate to true.\nTherefore, only the first two cases can result in the first removal of a colour\nassignment pair. In either case, there is no colouring of G that admits P such\nthat Li and Li+1 are assigned Cx , Cy and Cy , Cz .\nNow, assume that for each of the first k allowable pairs removed by Algorithm\n2, there is no colouring of G that admits Q such that that allowable pair is\nassigned to the specified layers.\nThen let the (k + 1)th pair removed be Cx , Cy assigned to layer Li , and\nCy , Cz assigned to Li+1 .\nAs in the base case, there are four cases.\n\u2022 There is a vertex precoloured by P with Cz on Li , or a vertex precoloured\nby P with Cx on Li+1 .\n\u2022 Assigning Cx , Cy to layer Li , and Cy , Cz to layer Li+1 results in two\nadjacent vertices being quasi-precoloured the same colour.\n\u2022 There is no allowable pair for Li\u22121 , Li in which Li is assigned Cx , Cy , or\nthere is no allowable pair for Li+1 , Li+2 in which Li+1 is assigned Cy , Cz .\n\u2022 Assigning Cx , Cy to layer Li , and Cy , Cz to layer Li+1 quasi-bad forces a\nbad chain P = [vh ...vi+1 ].\nThe first two cases are straightforward, as in the base case.\nIn the third case, there is no colouring of G that admits P such that the\nlevels Li\u22121 , Li are assigned colours such that Li is assigned colours Cx , Cy , or\nthere is no colouring of G that admits P such that the levels Li+1 , Li+2 are\nassigned colours such that Li+1 is assigned colours Cy Cz . Therefore, there is no\ncolouring of G that admits P such that Li is assigned colours Cx , Cy and Li+1\nis assigned colours Cy , Cz .\nIn the fourth case, by Lemma 8, the inductive hypothesis, and the quasi-bad\nforcing there is no colouring of G that admits P such that Li is assigned colours\nCx , Cy and Li+1 is assigned colours Cy , Cz .\nNow assume that after executing Algorithm 2 A is not the allowable array\nof the input graph G, chain ordering L and list colouring P.\nThen there is a pair of colour assignments Cx , Cy and Cy , Cz to layers\nLi , Li+1 such that one of the following is true:\n1. there is a vertex on Li precoloured by P with colour Cz ,\n2. there is a vertex on Li+1 precoloured by P with colour Cx ,\n3. assigning these colours to these layers results in a quasi-precolouring such\nthat two adjacent vertices are given the same colour,\n9\n\n\f4. there is no pair of colour assignments for Li\u22121 , Li that assigns Cx , Cy to\nLi .,\n5. there is no pair of colour assignments for Li+1 , Li+2 that assigns Cx , Cz\nto Li+1 ,\n6. or the colour assignments Cx , Cy and Cy , Cz to layers Li , Li+1 are quasibad forcing.\nWe consider each of these cases. The first case would have been detected by\nthe if statement on line 4 of Algorithm 3 after it was called by Algorithm 2, and\nso will not occur in A after processing, having been removed on line 6.\nThe second case would have been detected by the if statement on line 4 of\nAlgorithm 3 after it was called by Algorithm 2, and so will not occur in A after\nprocessing, having been removed on line 7.\nThe third case would have been detected by the if statement on line 15 of\nAlgorithm 3 after it was called by Algorithm 2, and so will not occur in A after\nprocessing, having been removed on line 16.\nThe fourth case would have been detected by the if statement on line 11 of\nAlgorithm 2, and so will not occur, having been removed on line 12.\nThe fifth case would have been detected by the if statement on line 15 of\nAlgorithm 2, and so will not occur, having been removed on line 16.\nThe sixth case would have been detected by the if statement on line 22 of\nAlgorithm 2, and so will not occur, having been removed on line 23.\nBy Lemma 10, Algorithm 2 gives the allowable array for G = (V, E), L, P.\nEach iteration except the last of the while loop on line 7 of Algorithm 2 removes\nat least one allowable pair. Because we have a fixed number (3) of colours\n\u0001 and\nare selecting exactly two colours for each layer, there are at most 32 ! = 6\nallowable pairs for each pair of adjacent layers, and so at most 6n = O(n)\ntotal allowable pairs. Therefore, the while loop on line 7 executes O(n) times.\nBecause O(n2 ) work is done in each iteration, Algorithm 2 has time complexity\nO(n3 ).\n\n4\n\nUsing the Allowable List to get a Colour Assignment\n\nOnce we have an allowable array A, we need to extract a list of assignments of\ntwo colours to each layer that obeys A. Let Q be a colour assignment, A an\nallowable array for multichain ordering L of graph G = (V, E).\nImagine that we have a good colour assignment Q that obeys A, and we\ndecide to change the colour assignment in Q at layer Li to some other colour\npair that A allows for Li . If we change only that layer, Q may no longer obey A,\nand may no longer be good. We informally give an algorithm for propagating a\nchange through Q to make Q obedient and good.\nWe will first proceed by increasing level index. Then for a layer j starting\nat j = i + 1 we change the colour assignment Q(j) to be Cx , Cy for any Cx , Cy\nsuch that if layer Q(j \u2212 1) is Cx , Cz , then [{Cx , Cz }, {Cx , Cy }] is in A[j \u2212 1]. If\n\n10\n\n\fAlgorithm 2 Allowable Pair List Generating Algorithm Iterative. Input:\nGraph G, Layers L, natural number start, list mapping P\n1: Array of list of pairs of pairs of size |L| \u2212 1 A \u2190 null\n2: for all i from 0 to |A| \u2212 1 do\n3:\nA[i] \u2190 {[{C1 , C2 }, {C1 , C3 }], [{C1 , C2 }, {C2 , C3 }], [{C2 , C3 }, {C1 , C2 }],\n[{C2 , C3 }, {C1 , C3 }], [{C1 , C3 }, {C1 , C2 }], [{C1 , C3 }, {C2 , C3 }], }\n4: end for\n5: Allowable Pair List Generating Algorithm Fixed(G, L, start, P, A)\n6: changeMade \u2190 true\n7: while changeMade do\n8:\nfor all i from 0 to |A| \u2212 1 do\n9:\nfor all Allowable pairs W \u2208 A[i] do\n10:\nLet the allowable pair be [{Cx , Cy }, {Cy , Cz }]\n11:\nif there is no allowable pair [\u2217, {Cx , Cy }] \u2208 A[i \u2212 1] then\n12:\nRemove [{Cx , Cy }, {Cy , Cz }] from A[i]\n13:\nchangeMade \u2190 true\n14:\nend if\n15:\nif there is no allowable pair [{Cy , Cz }, \u2217] \u2208 A[i + 1] then\n16:\nRemove [{Cx , Cy }, {Cy , Cz }] from A[i]\n17:\nchangeMade \u2190 true\n18:\nend if\n19:\nend for\n20:\nfor all Allowable pairs W \u2208 A[i] do\n21:\nCOMMENT Here we're checking for quasi-bad forcing\n22:\nif forcesQuasiBad(G, L, A, i, W, P) then\n23:\nRemove W from A[i]\n24:\nchangeMade \u2190 true\n25:\nend if\n26:\nend for\n27:\nend for\n28: end while\nA[j] contains [{Cx , Cy }, Q(j + 1)] then we stop. Otherwise we continue on by\nincrementing j and repeating the process for the next layer.\nThen we can repeat this process starting at j = i + 1 and decrementing\ninstead of incrementing j. We call this procedure the Colour Propagation Algorithm. To extract a colour assignment out of an allowable array instead of\nmodifying one, we need only use this algorithm on a colour assignment with\nempty colour assignments and start at an arbitrary layer with an arbitrary\ncolour assignment choice present in A.\nLemma 11. Let G = (V, E) be a graph with multi-chain ordering L, allowable\narray A, and colour assignment Q such that from layer Li , Q needs adjustment.\nIf none of the entries in the allowable array are empty then the colour change\npropagation algorithm started at Li changes Q to be a good colour assignment\nthat obeys A.\nProof. We argue inductively in the case of propagation on decreasing level index j. Let Cx , Cy be the colour assignment made by Q to Lj+1 . Then by the\ndefinition of allowable pairs, there is at least one allowable pair of colour assign11\n\n\fAlgorithm 3 Allowable Pair List Generating Algorithm Fixed . Input: Graph\nG, Layers L, natural number start, list mapping P, list of allowed A\n1: COMMENT Remove pairs that are not allowable due to precolouring in P\n2: for all i from 0 to |A| \u2212 1 do\n3:\nfor all Colour Cx \u2208 C1 , C2 , C3 do\n4:\nif there is a vertex on Li precoloured with Cx then\n5:\nLet Cy , Cz be the two colours that are not Cx\n6:\nRemove [{Cy , Cz }, \u2217] from A[i]\n7:\nRemove [\u2217, {Cy , Cz }] from A[i \u2212 1]\n8:\nend if\n9:\nend for\n10: end for\n11: COMMENT Remove pairs that are not allowable due to quasi-precolouring\nforcing adjacent vertices of the same colour\n12: for all i from 0 to size of A \u2212 1 do\n13:\nfor all Allowable pairs W \u2208 A[i] do\n14:\nLet the allowable pair be [{Cx , Cy }, {Cy , Cz }]\n15:\nif there exist adjacent vertices vi , vi+1 in Li , Li+1 such that P[vi ] \u2229\n{Cx , Cy } = Cy and P[vi+1 ] \u2229 {Cy , Cz } = Cy then\n16:\nRemove [{Cx , Cy }, {Cy , Cz }] from A[i]\n17:\nend if\n18:\nend for\n19: end for\nments to Lj , Lj+1 such that Cx , Cy is assigned to Lj . Then we can make an\nassignment to Lj that is obedient and good.\nBy the definition of an allowable array, any colour assignment that obeys an\nallowable array is good.\nA similar proof applies in the case of iteration on increasing level index.\n\n5\n\nFixing Quasi-Bad Chains\n\nWe have shown how to build an allowable array, how to extract a good colouring\nassignment from an allowable array, and shown that there is a colouring of G\nthat admits a good colour assignment if and only if there is no quasi-bad chain.\nWe now show, given an allowable array with no empty entries and a good colour\nassignment obeying that array that has quasi-bad chains, how to produce a\ngood colour assignment with reduced quasi-bad chains. Applying this inductively allows us to produce a good colour assignment with no quasi-bad chains,\nand therefore a 3-list colouring of G.\nLemma 12. Let A be the allowable array for graph G = (V, E) with multi-chain\nordering L and list mapping P. Let Q be a good colour assignment to L such\nthat Q obeys A, and P = [vh ...vl ] is an N2 quasi-bad chain with respect to Q.\nWe can modify Q such that it remains good, and all highest-indexed layers\ncontaining vertices of N2 quasi-bad chains have indices lower than l.\n\n12\n\n\fAlgorithm 4 forcesQuasiBad: determines if input colour assignment pair is\nquasi-bad forcing with regard to a list of colour pairs A. Input: Graph G, Layers\nL, List of lists of pairs of colour assignments A, integer i, colour assignment pair\nW , list mapping P\nLet {Cx , Cy } assigned to layer Li\u22121 and {Cy , Cz } to layer Li be the colour\nassignments in W\nList Q \u2190 \u2205\nQ(i \u2212 1) \u2190 {Cx , Cy }\nQ(i) \u2190 {Cy , Cz }\ninteger counter \u2190 i \u2212 1\nboolean forced \u2190 true\nset of colours belowColour \u2190 {Cx , Cy }\nwhile forced do\nif There is only one colour assignment pair W \u2032 in A[counter \u2212 1] that\nmatches [\u2217, belowColour] then\ncounter \u2190 counter \u22121\ncounterColour \u2190 the first member of W \u2032\nQ(counter) \u2190 counterColour\nbelowColour \u2190 counterColour\nelse\nforced \u2190 false\nend if\nend while\nreturn conservativeColouring(G, Q, counter, i)\n\nProof. Let P = [vh ...vl ] be a quasi-bad chain such that Ll , the layer that contains vl has the highest index of any quasi-bad chain.\nLet Li where h \u2264 i \u2264 l \u2212 2 be the lowest-indexed layer that is adjustable.\nWe know that there is such a layer because no colour assignment is quasi-bad\nforcing. Any quasi-bad forcing colour assignment would have been removed\nfrom the allowable array during its construction.\nWithout loss of generality, let Q(Li ) = {Cx , Cy } and Q(Li+1 ) = {Cx , Cz }.\nThen because all of Li , Li+1 , Li+2 contain vertices in a quasi-bad chain, then by\nObservation 7, Q(Li+2 ) = {Cy , Cz }.\nWe modify Q by setting Q(Li ) to {Cy , Cz } and propagating this in decreasing layer index using the Colour Assignment Propagation Algorithm. By the\nadjustability of Li , this change obeys A.\nBy Lemma 11 this produces a good colour assignment.\nBy Observation 7 there is no quasi-bad chain with respect to Q that has an\nendpoint with a higher layer index than i and an endpoint with a lower layer\nindex than i \u2212 1 because all of Li , Li+1 , Li+2 are assigned colour Cz . Because\ncolour assignments are the same in Q below Li+1 and P was an N2 quasi-bad\nchain, the last vertex of every quasi-bad chain with respect to Q\u2032 is in a layer\nwith an index lower than i.\nLemma 13. Let A be the allowable array for graph G = (V, E) with layers L\nand list mapping P. We can produce Q, a good colour assignment to layers in\nL such that Q obeys A, such that there are no quasi-bad chains with respect to\nQ.\n13\n\n\fProof. By iterative application of Lemma 12.\nLemma 14. Let A be the allowable array for graph G = (V, E) with multichain ordering L and list mapping P. If there is at least one allowable pair in\nA for every adjacent pair of layers in L, then we can produce a good colour\nassignment Q of two colours to each layer in L such that the Conservative\nColouring algorithm executed using Q gives a 3-list colouring of G.\nProof. Follows from Lemma 13 and Statement 9\n\nReferences\n[1] Pinar Heggernes, Dieter Kratsch, and Daniel Meister. Bandwidth of bipartite permutation graphs in polynomial time. In Proceedings of the 8th Latin\nAmerican conference on Theoretical informatics, LATIN'08, pages 216\u2013227,\nBerlin, Heidelberg, 2008. Springer-Verlag.\n[2] Mihaly Hujter and Zsolt Tuza. Precoloring extension 3: Classes of perfect\ngraphs. Combinatorics, Probability & Computing, pages 35\u201356, 1996.\n[3] T. R. Jensen and B. Toft. Graph Coloring Problems. John Wiley & Sons,\nNew York, NY, USA, 1994.\n[4] Jan Kratochvil. Precoloring extension with fixed color bound. Acta Math.\nUniv. Comen., 62:139\u2013153, 1994.\n\n14\n\n\f"}