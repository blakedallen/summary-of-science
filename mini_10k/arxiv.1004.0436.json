{"id": "http://arxiv.org/abs/1004.0436v1", "guidislink": true, "updated": "2010-04-03T10:59:30Z", "updated_parsed": [2010, 4, 3, 10, 59, 30, 5, 93, 0], "published": "2010-04-03T10:59:30Z", "published_parsed": [2010, 4, 3, 10, 59, 30, 5, 93, 0], "title": "On the parity complexity measures of Boolean functions", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1004.3995%2C1004.0914%2C1004.4418%2C1004.0546%2C1004.1095%2C1004.3906%2C1004.2374%2C1004.0436%2C1004.4174%2C1004.2982%2C1004.3834%2C1004.3465%2C1004.3373%2C1004.5273%2C1004.2360%2C1004.0601%2C1004.4403%2C1004.2171%2C1004.2683%2C1004.1474%2C1004.2913%2C1004.1162%2C1004.1029%2C1004.1158%2C1004.4557%2C1004.2561%2C1004.0308%2C1004.3350%2C1004.1849%2C1004.2743%2C1004.2595%2C1004.3829%2C1004.5218%2C1004.1783%2C1004.1767%2C1004.0581%2C1004.0176%2C1004.4219%2C1004.4136%2C1004.2100%2C1004.1606%2C1004.5049%2C1004.0158%2C1004.2321%2C1004.0253%2C1004.2507%2C1004.3541%2C1004.1409%2C1004.4530%2C1004.4664%2C1004.4162%2C1004.2304%2C1004.4037%2C1004.5387%2C1004.3445%2C1004.4331%2C1004.2005%2C1004.3617%2C1004.2946%2C1004.3097%2C1004.0756%2C1004.1177%2C1004.4368%2C1004.2578%2C1004.1337%2C1004.4147%2C1004.3395%2C1004.0895%2C1004.2735%2C1004.5302%2C1004.2055%2C1004.3874%2C1004.1570%2C1004.0103%2C1004.1097%2C1004.4656%2C1004.5140%2C1004.5494%2C1004.0722%2C1004.5318%2C1004.5533%2C1004.3497%2C1004.2887%2C1004.0843%2C1004.0015%2C1004.5442%2C1004.1091%2C1004.1719%2C1004.5325%2C1004.1403%2C1004.2072%2C1004.3090%2C1004.1771%2C1004.3276%2C1004.3054%2C1004.0833%2C1004.4095%2C1004.1083%2C1004.1128%2C1004.2751%2C1004.1873&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "On the parity complexity measures of Boolean functions"}, "summary": "The parity decision tree model extends the decision tree model by allowing\nthe computation of a parity function in one step. We prove that the\ndeterministic parity decision tree complexity of any Boolean function is\npolynomially related to the non-deterministic complexity of the function or its\ncomplement. We also show that they are polynomially related to an analogue of\nthe block sensitivity. We further study parity decision trees in their\nrelations with an intermediate variant of the decision trees, as well as with\ncommunication complexity.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1004.3995%2C1004.0914%2C1004.4418%2C1004.0546%2C1004.1095%2C1004.3906%2C1004.2374%2C1004.0436%2C1004.4174%2C1004.2982%2C1004.3834%2C1004.3465%2C1004.3373%2C1004.5273%2C1004.2360%2C1004.0601%2C1004.4403%2C1004.2171%2C1004.2683%2C1004.1474%2C1004.2913%2C1004.1162%2C1004.1029%2C1004.1158%2C1004.4557%2C1004.2561%2C1004.0308%2C1004.3350%2C1004.1849%2C1004.2743%2C1004.2595%2C1004.3829%2C1004.5218%2C1004.1783%2C1004.1767%2C1004.0581%2C1004.0176%2C1004.4219%2C1004.4136%2C1004.2100%2C1004.1606%2C1004.5049%2C1004.0158%2C1004.2321%2C1004.0253%2C1004.2507%2C1004.3541%2C1004.1409%2C1004.4530%2C1004.4664%2C1004.4162%2C1004.2304%2C1004.4037%2C1004.5387%2C1004.3445%2C1004.4331%2C1004.2005%2C1004.3617%2C1004.2946%2C1004.3097%2C1004.0756%2C1004.1177%2C1004.4368%2C1004.2578%2C1004.1337%2C1004.4147%2C1004.3395%2C1004.0895%2C1004.2735%2C1004.5302%2C1004.2055%2C1004.3874%2C1004.1570%2C1004.0103%2C1004.1097%2C1004.4656%2C1004.5140%2C1004.5494%2C1004.0722%2C1004.5318%2C1004.5533%2C1004.3497%2C1004.2887%2C1004.0843%2C1004.0015%2C1004.5442%2C1004.1091%2C1004.1719%2C1004.5325%2C1004.1403%2C1004.2072%2C1004.3090%2C1004.1771%2C1004.3276%2C1004.3054%2C1004.0833%2C1004.4095%2C1004.1083%2C1004.1128%2C1004.2751%2C1004.1873&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The parity decision tree model extends the decision tree model by allowing\nthe computation of a parity function in one step. We prove that the\ndeterministic parity decision tree complexity of any Boolean function is\npolynomially related to the non-deterministic complexity of the function or its\ncomplement. We also show that they are polynomially related to an analogue of\nthe block sensitivity. We further study parity decision trees in their\nrelations with an intermediate variant of the decision trees, as well as with\ncommunication complexity."}, "authors": ["Zhiqiang Zhang", "Yaoyun Shi"], "author_detail": {"name": "Yaoyun Shi"}, "author": "Yaoyun Shi", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1016/j.tcs.2010.03.027", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1004.0436v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1004.0436v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "submitted to TCS on 16-MAR-2009", "arxiv_primary_category": {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1004.0436v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1004.0436v1", "journal_reference": null, "doi": "10.1016/j.tcs.2010.03.027", "fulltext": "On the parity complexity measures of Boolean\nfunctions\nZhiqiang Zhang\u2217\n\narXiv:1004.0436v1 [cs.CC] 3 Apr 2010\n\nInstitute for Theoretical Computer Science, Center for Advanced Study,\nTsinghua University, Beijing, 100084, P.R. China\nand\nYaoyun Shi\u2020\nDepartment of Electrical Engineering and Computer Science,\nUniversity of Michigan, 2260 Hayward Street, Ann Arbor, MI 48109-2121, USA\n\nAbstract\nThe parity decision tree model extends the decision tree model by allowing the\ncomputation of a parity function in one step. We prove that the deterministic\nparity decision tree complexity of any Boolean function is polynomially related to\nthe non-deterministic complexity of the function or its complement. We also show\nthat they are polynomially related to an analogue of the block sensitivity. We\nfurther study parity decision trees in their relations with an intermediate variant of\nthe decision trees, as well as with communication complexity.\n\n1\n\nIntroduction and summary of results\n\nThe decision tree model is perhaps the simplest model of computation. It is, however, capable of capturing the inherent complexity of many natural computational\nproblems. Its relations with other models of computation have also proved to be\nuseful. In this section, we will first review some definitions and key results on\ndecision trees, before we present a summary of our results.\nLet f : {0, 1}n \u2192 {0, 1} be a Boolean function throughout this paper, unless\nspecified otherwise. Formally, a decision tree algorithm for computing f is a full\nbinary tree T , labeled as follows: (1) each non-leaf vertex is labeled with an index\ni \u2208 {1, 2, ..., n} to the input bits, (2) each leaf and each edge is labeled with either\n0 or 1. The computation of T on an input x \u2208 {0, 1}n is the path that starts\nat the root and follows the xi edge from a vertex labeled with i. The leaf label\n\u2217\n\nEmail:zhang@itcs.tsinghua.edu.cn. Supported in part by the National Natural Science Foundation\nof China Grant 60553001, and the National Basic Research Program of China Grant 2007CB807900,\n2007CB807901.\n\u2020\nEmail:shiyy@eecs.umich.edu. Supported in part by National Science Foundation of the United States\nunder the grants 0347078 and 0622033.\n\n1\n\n\freached by this path is the output of T on x. The depth of the tree is the worst-case\ncomplexity of the algorithm. The minimum depth of all decision trees computing f\nis the deterministic decision tree complexity of f , denoted by D(f ).\nA set of decision trees non-deterministically computes f , if for any input x,\nf (x) = 1, if and only if a decision tree from the set outputs 1. The non-deterministic\ndecision tree complexity of f , denoted by C 1 (f ), is the smallest integer k such that f\nis computed non-deterministically by a set of depth-k decision trees. Alternatively,\nC 1 (f ) is characterized by the smallest integer k, such that for any input x with\nf (x) = 1, there is a subset S \u2286 {1, ..., n} such that any input x\u2032 with the same value\nas x on bits indexed by S must also have f (x\u2032 ) = 1. Thus C 1 (f ) is also commonly\ndef\n\ncalled the 1-certificate complexity. The 0-certificate complexity, C 0 (f ) = C 1 (1 \u2212 f ),\ndef\n\nand the certificate complexity, C(f ) = max{C 0 (f ), C 1 (f )}.\nIt follows straightforwardly from the definitions that C(f ) \u2264 D(f ). A key result [2] is, for any f ,\nD(f ) \u2264 C 1 (f )C 0 (f ).\n(1)\nThus for any Boolean function, its deterministic complexity is polynomially related\nwith its non-deterministic complexity or that of its complement. This is in sharp\ncontrast with the fact that for Turing machine computations the corresponding\nquestion of P versus NP remains open. In fact, several other complexity measures\nsuch as randomized and quantum decision tree complexities are also known to be\npolynomially related to the deterministic decision tree complexity. A comprehensive\nsurvey on the subject is [3] by Buhrman and de Wolf.\nIf in a decision tree, each non-leaf vertex is labeled with a c \u2208 {0, 1}n instead, and\ndef P\nthe computation path follows the edge labeled with hx, ci = i xi ci mod 2, we call\nthis extended decision tree a parity decision tree and the corresponding complexity\nas the parity decision tree complexity, denoted by D\u2295 (f ). This model was first\ndefined in [4], which derived some simple properties of the complexity. The parity\n0 (f ), C 1 (f ), and C (f ), can be defined in analogy to the\ncertificate complexities, C\u2295\n\u2295\n\u2295\ncertificate complexities (see Definition 2.1). They measure the non-deterministic\nparity decision tree complexities of f (or 1 \u2212 f ). Our first main result is in analogy\nto (1).\n0 (f )C 1 (f ).\nTheorem 1.1. For any Boolean function f , D\u2295 (f ) \u2264 C\u2295\n\u2295\n\nThe block-sensitivity of f , bs(f ), is the smallest integer k such that for any input\nx \u2208 {0, 1}n there are k pair-wise disjoint subsets of {1, ..., n} such that flipping all\nbits in any of those subsets flips f (x). Nisan [8] showed that, for any f ,\nC(f ) \u2264 bs2 (f ).\n\n(2)\n\nTogether with the simple relation that bs(f ) \u2264 C(f ), this result shows that bs(f ) is\npolynomially related with C(f ), thus with D(f ). We define (in Definition 3.3) the\nparity block sensitivity bs\u2295 (f ), and show that a similar relation holds.\nTheorem 1.2. For any Boolean function f , bs\u2295 (f ) \u2264 C\u2295 (f ) \u2264 bs2\u2295 (f ).\nThe above three classes of parity complexities we study satisfy the following\nsymmetry properties. Let c \u2208 {0, 1}n . The function obtained by shifting f by c is\nfc : x 7\u2192 f (x + c). Let A be a linear transformation on {0, 1}n (as the n-dimensional\nlinear space over the field F2 ), fA is the function defined as fA (x) = f (Ax). For any\n\n2\n\n\fcoset H of {0, 1}n (i.e. a shift of a subspace), denote by f |H the restriction of f on\nH. A complexity measure \u0398 defined on Boolean functions is said to be invariant\nunder shift if \u0398(fc ) = \u0398(f ) for any c \u2208 {0, 1}n . It is said to be invariant under\nrotation if \u0398(fA ) = T (f ) for any invertible transformation A over Fn2 .\nWhen \u0398 is invariant under shift and rotation, we can extend the domain of \u0398\nto include any function g defined on a coset H of {0, 1}n . For such a g, and a coset\nH = c + S where c \u2208 {0, 1}n and S is a subspace with basis {e1 , * * * , em }, we define\ng\u2032 : {0, 1}m \u2192 {0, 1} as follows,\ndef\n\ng\u2032 (x1 x2 * * * xm ) = g(c + x1 e1 + * * * + xm em ) for all x \u2208 {0, 1}m ,\n\n(3)\n\nand extend \u0398 to g by setting,\ndef\n\n\u0398(g) = \u0398(g\u2032 ).\n\n(4)\n\nThen \u0398(g) is well defined, as it is independent of the choice of the basis and c for H\ndue to \u0398 being invariant under shift and rotation. We say a complexity measure \u0398\ninvariant under shift and rotation is monotone if for any n \u2265 1, f : {0, 1}n \u2192 {0, 1},\nand coset H \u2286 {0, 1}n , \u0398(f |H ) \u2264 \u0398(f ).\nAll the classical complexity measures of Boolean functions such as decision tree\ncomplexity, certificate complexity, and block sensitivity are invariant only under\nshift but not under rotation. The parity version complexities we study are, however,\ninvariant under both shift and rotation, and are monotone.\nTo contrast those two sets of complexity measures, we may \"symmetrize\" every\ndef\nclassical complexity measure \u0398 to \u0398I by defining \u0398I (f ) = minB \u0398(fB ), where\nB takes value from all invertible linear transformations. A natural question is if\neach parity complexity is identical, or at least polynomially related, to the rotation\ninvariant version of the corresponding classical complexity. We show that this is\nnot the case. In this sense, the parity decision tree model is an inherently more\npowerful model than the decision tree model.\nTheorem 1.3. For infinitely many n, there exists fn : {0, 1}n \u2192 {0, 1}, such that\nD\u2295 (fn ) = O(log n) and DI (fn ) = \u0398(n).\nParity decision trees are closely related to the communication complexity of XOR\nfunctions [10]. Communication complexity is a major branch of complexity theory\nthat studies the inherent communication cost for distributive computation. The\ndeterministic communication complexity of F : {0, 1}n \u00d7 {0, 1}n \u2192 {0, 1}, denoted\nby DC(F ), is the smallest integer k, such that there is a communication protocol\nbetween two parties Alice and Bob satisfying the following conditions: (1) Alice's\ninput is an x \u2208 {0, 1}n , and Bob's input is a y \u2208 {0, 1}n . (2) Alice and Bob take\nturn to send each other a message, each message is determined by each party's input\nas well as the messages s/he has received previously. (3) At the end of the protocol\none party knows F (x, y). (4) The total number of bits in the messages is \u2264 k. This\nmodel as well as its several variants have been extensively studied. For surveys, see\n[5, 9, 6].\nDetermining DC(F ) may be a highly nontrivial problem, even for the following\nclass of functions of a simple structure. A function F : {0, 1}n \u00d7 {0, 1}n \u2192 {0, 1}\nis called an XOR function [10] if for some f : {0, 1}n \u2192 {0, 1}, F (x, y) = f (x + y),\nfor all x, y \u2208 {0, 1}n . The computation of a parity decision tree T for f can be\n\n3\n\n\fsimulated by Alice and Bob for computing F : each query c is simulated by Alice\nand Bob computing hc, xi and hc, yi, respectively, and exchange the outcomes.\nProposition 1.4. For any XOR function F : {0, 1}n \u00d7 {0, 1}n \u2192 {0, 1} with\nF (x, y) = f (x + y), DC(F ) \u2264 2D\u2295 (f ).\nIn Section 5, we show that C 1 (f ), times log n, also gives an upper bound on\nthe non-deterministic communication complexity of F . A natural question is if\nthose upper bounds are far from being tight. While we are not able to answer this\nquestion, we conjecture they are. We also put forward a conjecture that, if true,\nwould also imply the well-known Log-Rank Conjecture [7] when restricted to XOR\nfunctions.\n\n2\n\nParity certificate complexity\n\nWe consider {0, 1}n as a n-dimensional vector space over F2 , the two-element finite\nfield, as well as an Abelian group with respect to the bit-wise XOR. Then a coset\nof {0, 1}n is a set b + V , where b \u2208 {0, 1}n and V is a subspace of {0, 1}n . The\nco-dimension of b + V is n \u2212 dim(V ). Equivalently, a coset is the set of solutions\nto a system of linear equations, and the minimum number of the equations defining\nthe same coset is the co-dimension. Informally, the parity certificate complexity\nmeasures how many linear constraints have to be given on the input in order to fix\nthe value of f .\nDefinition 2.1. Let f : D \u2192 {0, 1} be defined on D \u2286 {0, 1}n , and x \u2208 D. A coset\nS of {0, 1}n is called a parity certificate of f on x if s \u2208 S and f is constant on S \u2229D.\nThe size of the certificate is defined to be the co-dimension of S. The minimum size\nof a parity certificate for x is denoted by C\u2295 (f, x). The parity certificate complexity\nof f , denoted by C\u2295 (f ), is maxx C\u2295 (f, x).\nA parity certificate S is called a 0- (or 1-) parity certificate if f (x) = 0 (or f (x) =\n1, respectively) for all x \u2208 S \u2229D. The 0- and 1-parity certificate complexities of f are\ndef\n\ndef\n\n0 (f ) = max\n1\nC\u2295\nx:f (x)=0 C\u2295 (f, x), and C\u2295 (f ) = maxx:f (x)=1 C\u2295 (f, x), respectively.\n1 (f ) (or C 0 (f ), respectively) is not defined. We may\nIf f \u2261 0 (or f \u2261 1), then C\u2295\n\u2295\nrepresent a parity certificate S of size T (or a coset S of co-dimension T ) by a pair\n(C, r), where C \u2208 {0, 1}T \u00d7n and r \u2208 {0, 1}T , such that S = {x : Cx = r}. It follows\nfrom the definitions that when B \u2208 {0, 1}n\u00d7n takes value from invertible matrices,\n\nC\u2295 (f, x) = min C(fB , B \u22121 x).\nB\n\n(5)\n\nSimilar relations between the 0- and 1-parity certificates/certificates also hold. Note\nthat 0- and 1-parity certificate complexity measure the non-deterministic parity\ndecision tree complexity of f and 1 \u2212 f , respectively, with the non-deterministic\nparity decision tree complexity defined in analogy to the non-deterministic decision\ntree complexity. Since any parity decision tree gives a certificate of size no more\nthan the depth of the tree for any input, we have the following relation.\nProposition 2.2. For any Boolean function f , C\u2295 (f ) \u2264 D\u2295 (f ).\n0 (f )C 1 (f ), for any f .\nWe now prove Theorem 1.1, which states that D\u2295 (f ) \u2264 C\u2295\n\u2295\n\n4\n\n\fProof of Theorem 1.1. The idea of the proof is similar to that in [2] for proving Inequality (1). We give an algorithm that computes f using no more than\n1 (f )C 0 (f ) queries.\nC\u2295\n\u2295\ndef\n\nFix an input x0 . For a sequence of cosets (C1 , r1 ), (C2 , r2 ), ..., define Vi = {x :\ndef\n\nCj x = Cj x0 , j = 1, 2, ..., i} for i \u2265 1 and V0 = {0, 1}n . By definition, V0 \u2287 V1 \u2287\nV2 \u2287 * * * . The algorithm will examine a sequence of 1-parity certificates, (C1 , r1 ),\n(C2 , r2 ), ..., that it constructs incrementally from an initially empty sequence. It\nproceeds as follows: For i = 1, 2, ..., if f |Vi\u22121 is constant, output that constant and\nterminate. Otherwise, extend the current sequence of 1-parity certificates with a\nnew one (Ci , ri ) for f |Vi\u22121 of the smallest size. Since f |Vi\u22121 is not constant, such a\n1-parity certificate exists. Query the rows in Ci . If the answers agree with ri , return\n1. Otherwise continue with i incremented by 1.\nThe algorithm clearly outputs the correct answer. Since restricting a function on\n1 , at most C 1 (f ) queries are made in the ith iteration,\na subset does not increase C\u2295\n\u2295\n0 (f ). Assume otherwise\nfor each i. We prove that f |VT is constant for some T \u2264 C\u2295\n\u2032\n\u2032\n0\nand fix an x0 \u2208 VT with T = C\u2295 (f ) and f (x0 ) = 0. We argue that for each i,\n1 \u2264 i \u2264 T,\n(6)\nC\u2295 (f |Vi , x\u20320 ) \u2264 C\u2295 (f |Vi\u22121 , x\u20320 ) \u2212 1.\nFix a parity certificate (C, r) for f |Vi\u22121 containing x\u20320 and of the smallest size. Since\nthe linear system {Ci x = ri , Cx = r} does not have a solution in Vi\u22121 but the system\n{Ci x = ri } does (by the definition of (Ci , ri ) being a 1-parity certificate for f |Vi\u22121 ,\nwhich is non-constant), the row space of C has a non-empty intersection with the\nspace spanned by the rows of C1 , ..., Ci . Assume without loss of generality that the\nintersection is spanned by the first k rows, for some k \u2265 1, in C (otherwise, apply an\nappropriate invertible matrix on both sides of Cx = r), and denote the sub-matrix\nof C and r containing those rows by C \u2032 and r \u2032 , and the remaining portions by C \u2032\u2032\nand r \u2032\u2032 . Any x \u2208 Vi satisfying C \u2032\u2032 x = r \u2032\u2032 must have C \u2032 x = C \u2032 x0 = C \u2032 x\u20320 = r \u2032 , thus\nCx = r, implying f (x) = 0. Thus (C \u2032\u2032 , r \u2032\u2032 ) is a parity certificate containing x\u20320 for\nf |Vi , and Eqn. (6) holds. Consequently, C\u2295 (f, x\u20320 ) \u2265 T + C\u2295 (f |VT , x\u20320 ) \u2265 T + 1 >\n0 (f ), a contradiction. Therefore f |\n1\nC\u2295\nVT is constant for some T \u2264 C\u2295 (f ), and the\n1 (f )C 0 (f ) number of queries.\nalgorithm uses no more than C\u2295\n\u2294\n\u2293\n\u2295\n\n3\n\nParity block sensitivity\n\nRecall that the block sensitivity of f on an input x, bs(f, x), is the smallest integer\nk, such that there exist S1 , S2 , ..., Sk \u2286 {1, 2, ..., n} that are pair-wise disjoint, and\nfor each i, 1 \u2264 i \u2264 k, f (x) 6= f (xSi ), where xSi \u2208 {0, 1}n is obtained from x by\nflipping each bit indexed by Si . The block sensitivity of f , bs(f ), is maxx bs(f, x).\nWe define the parity analogues of those concepts. First define weak parity block\nsensitivity wbs(f, x) similar to the definition of parity certificate complexity.\nDefinition 3.1. The weak parity block sensitivity of f on x is\ndef\n\nwbs\u2295 (f, x) = min bs(fB , B \u22121 x).\nB\n\nThe weak parity block sensitivity of f is\ndef\n\nwbs\u2295 (f ) = max wbs\u2295 (f, x).\nx\n\n5\n\n\fNote that wbs\u2295 (f ) is invariant under shift and rotation, so we can extend it to\nfunctions defined on a coset through Eqn. (4). The following example shows that\nwbs\u2295 (f ) is not monotone.\nExample 3.2. Consider f (x1 , x2 , x3 ) = x1 \u2295 (x2 \u2228 x3 ). For any input x, we can\nalways choose a basis {e1 , e2 , e3 } such that f (x+ei ) = f (x), i = 1, 2, 3. For example,\nwhen x = 011 we can choose the basis {010, 001, 111}. For such bases, any sensitive\nblock contains at least two base vectors. So there is at most one sensitive block,\nimplying wbs\u2295 (f, x) \u2264 1. But with H = {x : x1 = 0}, f |H (x2 , x3 ) = x2 \u2228 x3 . This\nis the OR function on two variables, of which the parity block sensitivity is 2 at 0.\nThus for this f , wbs\u2295 (f ) < wbs\u2295 (f |H ).\nWe modify wbs\u2295 to a parity complexity measure by taking maximum over all\nrestrictions to cosets. Then it will be invariant under shift and rotation, and is\nmonotone.\nDefinition 3.3. For a Boolean function f : {0, 1}n \u2192 {0, 1}, its parity block sensitivity, bs\u2295 (f ), is\nbs\u2295 (f ) = max wbs\u2295 (f |H ),\nH\n\nwhere H takes value from the cosets of {0, 1}n .\nSimilar to Inequality (2), Theorem 1.2 implies that the parity block sensitivity\nis polynomially related to parity certificate complexity. We give below the proof for\nthe Theorem, which states that bs\u2295 (f ) \u2264 C\u2295 (f ) \u2264 bs2\u2295 (f ) for any f . The proof\nidea is also similar to that for proving (2) in [8].\nProof of Theorem 1.2. Since C\u2295 is monotone, to prove bs\u2295 (f ) \u2264 C\u2295 (f ), it suffices\nto prove wbs\u2295 (f, x) \u2264 C\u2295 (f ), for any x. This follows straightforwardly from the\ndefinition, the relation between block sensitivity and certificate complexity, and\nEqn. (5):\nwbs\u2295 (f, x) = min bs(fB , B \u22121 x) \u2264 min C(fB , B \u22121 x) = C\u2295 (f, x).\nB\n\nB\n\nWe prove the second inequality by showing C\u2295 (f ) \u2264 wbs\u2295 (f )bs\u2295 (f ). Since the\nthree quantities are both invariant under shift, we assume without loss of generality\nthat C\u2295 (f ) is achieved at x = 0. Also assume without loss of generality that\nf (0) = 0. Since C\u2295 (f, x) = C\u2295 (fB , B \u22121 x) for any invertible B and any x, we can\ndef\n\nfurther assume without loss of generality that b = wbs\u2295 (f, 0) = bs(f, 0). Let S1 , S2 ,\n..., Sb \u2286 {1, 2, ..., n} be a collection of disjoint and minimal sets achieving bs(f, 0).\nConsider S = {x : xi = 0, i \u2208 S1 \u222aS2 \u222a* *\u0010* Sb }. Then S is a parity\ncertificate for f , as\n\u0011\nSb\n\u2032\n\u2032\notherwise there would be a block S \u2286 {1, ..., S} \u2212 i=1 Si such that f (0S ) = 1,\ncontradicting that b = bs(f, 0).\nFix an i, 1 \u2264 i \u2264 b. Let m = |Si | and Si = {a1 , a2 , ..., am }. Consider f |Hi , where\ndef\n\nHi = {x : xj = 0, j \u2208 {1, 2, ..., n} \u2212 Si }. Then f |Hi : {0, 1}m \u2192 {0, 1} and\n!\nm\nX\nyi eai , for all y \u2208 {0, 1}m .\nf |Hi (y) = f\ni=1\n\n\u2032\n\nSince Si is minimal, for any Si\u2032 \u2286 Si , f (0Si ) = 1 if and only if Si\u2032 = Si . Thus f |Hi (y)\nis the AND function on m variables. Therefore\nwbs\u2295 (f |Hi ) = m. Consequently,\nP\nm \u2264 bs\u2295 (f ). Thus C\u2295 (f ) = C\u2295 (f, 0) \u2264 bi=1 |Si | \u2264 wbs\u2295 (f, 0)bs\u2295 (f ), implying\nC\u2295 (f ) \u2264 wbs\u2295 (f )bs\u2295 (f ).\n\u2294\n\u2293\n\n6\n\n\f4 The gap between parity measures and symmetrized classical measures\nIn this section, we prove Theorem 1.3, which states that for infinitely many n, there\nexists fn : {0, 1}n \u2192 {0, 1}, such that D\u2295 (fn ) = O(log n) and DI (fn ) = \u0398(n). We\nwill define the desired function fn by a random parity decision tree of logarithmic\ndepth, then show that there exists such a parity decision tree of which the function\nrequires linear certificate complexity, thus linear decision tree complexity.\nFor A \u2208 {0, 1}m\u00d7n , s \u2208 {0, 1}n , define\ndef\n\n\u03c4A (s) = min{|s + v| : v \u2208 row space of A}.\nWe will need the following lemma to lower bound the certificate complexity.\nLemma 4.1. Let f : {0, 1}n \u2192 {0, 1}, s \u2208 {0, 1}n and f (x) = hx, si for all x in a\ncoset H = (A, r). Then C(f ) \u2265 \u03c4A (s). In particular, D(f ) \u2265 \u03c4A (s).\ndef\n\nProof. Choose an arbitrary x0 \u2208 H. Let l = C(f, x0 ) \u2264 C(f ). Suppose that\nE \u2208 {0, 1}l\u00d7n describes a certificate. That is, each row in E contains all 0 but a\nsingle 1, and all x\u2032 with Ex\u2032 = Ex0 must have f (x\u2032 ) = f (x0 ).\nNow consider two sets of equations on the unknown y \u2208 {0, 1}n :\n\uf8f1\n\uf8f1\n\uf8f2 Ey = Ex0\n\uf8f2 Ey = Ex0\nAy = r\nand\nAy = r\n.\n\uf8f3\n\uf8f3\nhs, yi = hs, x0 i\nhs, yi = 1 \u2212 hs, x0 i\n\nThe first set of equations has a solution (e.g. y = x0 ) but not the second set,\nsince all y satisfying Ay = r must have hs, yi = hs, x0 i. This is possible only when\ns is in the span of the rows in E and in A. Thus for some v in the row space of\nA, s + v is in the row space of E. Thus \u03c4A (s) \u2264 l. Therefore, \u03c4A (s) \u2264 C(f ). That\nD(f ) \u2265 \u03c4A (s) follows from the fact that C(f ) \u2264 D(f ).\n\u2294\n\u2293\nWe are ready to prove Theorem 1.3.\nProof of Theorem 1.3. Let n = 2k . We construct a function f with n variables\ndecided by a parity decision tree T of depth k + 4. For 1 \u2264 i \u2264 k + 3, all the i-th\ndef\nlayer nodes are labeled by ei = 0i\u22121 10n\u2212i . The t-th node of the last layer before\nthe output, 1 \u2264 t \u2264 8n, is labeled by a random st \u2208 {0, 1}n . The answer to this\nquery hx, st i is the output.\nFix an invertible matrix B. Then fB is computed by the parity tree that replaces\neach query c in T by B T c. In this parity decision tree, the inputs that arrive at a\ndef\nnode with query s\u2032t = B T st form a coset Ht = (Ct , rt ) of co-dimension k + 3, and\nfB (x) = hx, s\u2032t i for all x \u2208 Ht . By Lemma 4.1, D(fB ) \u2265 \u03c4Ct (s\u2032t ).\nFor each v in the row space of Ct , s\u2032t + v is uniformly distributed. Thus by\nHoeffding's Inequality, Pr(|s\u2032t + v| \u2264 n/4) \u2264 e\u2212n/8 . Thus\nPr(\u03c4Ct (s\u2032t ) \u2264 n/4) \u2264 2k+3 e\u2212n/8 = 8ne\u2212n/8 .\nThere are 8n independently chosen sj , thus\n\u00118n\n\u0010\n2\nPr(D(fB ) \u2265 n/4) \u2265 1 \u2212 8ne\u2212n/8\n= 1 \u2212 (8n)8n e\u2212n .\n\n7\n\n\f2\n\nThere are at most (2n )n = 2n different transformations B(the exact number is\nn\u22121 n\u2212i\n\u03a0i=0\n(2\n\u2212 1)). Therefore,\n8n \u2212n2\n\nP (min D(fB ) \u2265 n/4) \u2265 1 \u2212 (8n) e\nB\n\nn2\n\n*2\n\n8n\n\n= 1 \u2212 (8n)\n\n\u0012 \u0013n 2\n2\n\u2192 1.\ne\n\nThis implies that when n is large enough, almost all the functions f computed by\nthe above parity trees have DI (f ) = minB D(fB ) \u2265 n/4. In contrast, the parity\ndecision tree complexity of these f is no more than k + 4 = log2 n + 4.\n\u2294\n\u2293\nThe following corollary follows from the polynomial relations among certificate\ncomplexity and block sensitivity with decision tree complexity and their analogy for\nparity complexities.\nCorollary 4.2. For infinitely many n, there exists a n-variate fn such that the gaps\nbetween C\u2295 (f ) and CI (f ) and between bs\u2295 (f ) and bsI (f ) are exponential.\n\n5 Connection with communication complexities\nIn a non-deterministic communication protocol for computing F : {0, 1}n \u00d7{0, 1}n \u2192\n{0, 1}, Alice or Bob may non-deterministically choose from a set of strategies for\nthe rest of the communication. We say that the protocol computes F if for any\n(x, y), F (x, y) = 1 if and only if for some choice in the non-deterministic steps\nthe protocol outputs 1. Denote the non-deterministic communication complexity of F by N 1 (F ). A fundamental result by Aho, Ullman and Yannakakis [1]\nis DC(F ) = O(N 1 (F )N 1 (1 \u2212 F )), a relation similar to those about decision tree\ncomplexity and parity decision tree complexity. The main result of this section\n1 (f ) for XOR functions F with F (x, y) = f (x + y).\nrelates N 1 (F ) with C\u2295\n1 (f ) log n.\nTheorem 5.1. For any XOR function F (x, y) = f (x \u2295 y), N 1 (F ) \u2264 C\u2295\n\nTo prove this result, we will make use of the following notion.\nDefinition 5.2. A set C of 1-parity certificates for f is called essential if (1) for any\nx with f (x) = 1 there is an element in C containing x, (2) no element is a subset of\n1 (f ).\nthe union of all the other elements, and (3) any element is of a size C\u2295\nClearly there exists an essential set of 1-parity certificates, as one could start with\n1 (f ) if necessary,\none smallest 1-parity certificate for each x, increase its size to C\u2295\nand remove any element contained in the union of the rest of the set.\n1 (f ). Fix an essential set C = {(C , r ) :\nProof of Theorem 5.1.\nLet d = C\u2295\ni i\n1 \u2264 i \u2264 K} of 1-parity certificates. The following is a simple non-deterministic\ncommunication protocol for F . bits of communication: Alice non-deterministically\nchooses (Ci , ri ) \u2208 C, sends i, as well as Ci x. Bob checks if Ci x+Ci y = ri . He accepts\nif yes, rejects otherwise. The correctness of the protocol follows from the definition\nof 1-parity certificate and the assumption that C contains a 1-parity certificate for\nany 1-input. The total cost is d + \u2308log2 (K + 1)\u2309. Lemma 5.3 below shows that\nK = nO(d) . Thus N 1 (F ) = O(d log n).\n\u2294\n\u2293\n\n8\n\n\fLemma 5.3. Let C be an essential set of 1-parity certificates for f : {0, 1}n \u2192 {0, 1}\n1 (f ). Then |C| \u2264 nO(d) .\nand d = C\u2295\nProof. Let P be the number of pairs (x, C) that x \u2208 C and C \u2208 C. Since |C| = 2n\u2212d\nfor each C,\nP = 2n\u2212d |C|.\n(7)\nFor each x \u2208 {0, 1}n , let S1 , S2 , ..., Sk \u2208 C be those that contains x. Then\ndef\n\nVi = x + Si , 1 \u2264 i \u2264 k, are n \u2212 d-dimensional subspaces none of which is a subset\nof the union of the rest. We show below any such set of subspaces must have\nk = nO(d) . Thus P = 2n nO(d) . Together with Eqn. (7), this implies the conclusion\nthat |C| = nO(d) .\nLet Ci \u2208 {0, 1}d\u00d7n\nS such that Vi = {x : Ci x = 0}, 1 \u2264 i \u2264 k. For any i, let xi \u2208 Vi\nbe such that xi 6\u2208 j6=i Vj . Then Ci xi = 0, but Cj xi 6= 0 for all j 6= i. Consider a\nkd \u00d7 k matrix\n\uf8ee\n\uf8f9\nC1\n\uf8ef C2 \uf8fa\n\uf8fa\nG=\uf8ef\n\uf8f0 * * * \uf8fb [x1 , x2 * * * , xk ].\nCk\n\nLet rank2 denote the rank over filed F2 . Then rank2 (G) \u2264 n from the above\nfactorization of G. Represent G by a k \u00d7 k block matrix aij , where each block aij\nis a d \u00d7 1 vector.\nFor each t, 1 \u2264 t \u2264 d, define the k \u00d7 k submatrix Gt = [atij ]1\u2264i,j\u2264k , where atij is\nthe t-th element of aij . Since Gt is a submatrix of G, rank2 (Gt ) \u2264 rank2 (G) \u2264 n.\nLet M = G1 \u2228 G2 \u2228 * * * \u2228 Gd be the entry-wise conjunction of G1 , G2 , * * * , Gd .\nNotice that for any matrix A and B, A \u2228 B = A + B + A \u2299 B, where A \u2299 B is the\nentry-wise product of A and B. Since rank2 (A \u2299 B) \u2264 rank2 (A)rank2 (B), we have\nrank2 (A \u2228 B) \u2264 rank2 (A) + rank2 (B) + rank2 (A \u2299 B) \u2264 3rank2 (A)rank2 (B).\n\nThus rank2 (M ) < (3n)d . On the other hand, from the fact that aij = 0 iff i = j,\nM = I \u2212 J, where I is the identity matrix and J the all 1 matrix. Thus rank2 (M ) \u2265\nrank2 (I) \u2212 rank2 (J) = k \u2212 1. This implies k = |V| \u2264 (3n)d .\n\u2294\n\u2293\nThe following conjecture, if true, would imply that DC(F ) is polynomially related to D\u2295 (f ) (as well as C\u2295 (f )), by the Aho-Ullman-Yannakakis Theorem and\nTheorem 1.1.\n1 (f )).\nConjecture 5.4. For any XOR function F based on f , N 1 (F ) = \u03a9(C\u2295\n\nA major open problem on deterministic communication complexity is the LogRank Conjecture [7]. Denote by rank(F ) = rank([F (x, y)]x,y\u2208{0,1}n ), where rank(*)\nis the rank over the reals. The Log-Rank Conjecture states that\nDC(F ) = logO(1) rank(F ),\n\nfor any F .\n\n(8)\n\nThe study of XOR functions is partly motivated by the Log-Rank Conjecture. Denote by\nkf\u02c6k0 = |{f\u02c6w 6= 0 : w \u2208 {0, 1}n }|,\nwhere\n\n1\nf\u02c6w = n\n2\n\nX\n\n(\u22121)hx,wi f (x)\n\nx\u2208{0,1}n\n\n9\n\n\fis the Fourier coefficient of f on w. Then for any XOR function F based on f ,\nrank(F ) = kf\u02c6k0 . Our conjecture below, if true, would imply the Log-Rank Conjecture on XOR functions.\nConjecture 5.5. For any Boolean function f : {0, 1}n \u2192 {0, 1}, D\u2295 (f ) and C\u2295 (f )\nare polynomially related with log kf\u02c6k0 .\n\n6\n\nAcknowledgments\n\nWe thank Xiaoming Sun and Andrew Yao for helpful discussions.\n\nReferences\n[1] A. V. Aho, J. D. Ullman, and M. Yannakakis. On notions of information\ntransfer in vlsi circuits. In Proceedings of the fifteenth annual ACM symposium\non Theory of computing, pages 133\u2013139, New York, NY, USA, 1983.\n[2] R. Beals, H. Buhrman, R. Cleve, M. Mosca, and R. de Wolf. Quantum lower\nbounds by polynomials. Journal of the ACM, 48(4):778\u2013797, July 2001.\n[3] H. Buhrman and R. de Wolf. Complexity measures and decision tree complexity: a survey. Theoretical Computer Science, 288(1):21\u201343, 2002.\n[4] E. Kushilevitz and Y. Mansour. Learning decision trees using the fourier spectrum. In Proceedings of the twenty-third annual ACM symposium on Theory\nof computing, pages 455\u2013464, New York, NY, USA, 1991. ACM.\n[5] E. Kushilevitz and N. Nisan. Communication Complexity. Cambridge University Press, Cambridge, 1997.\n[6] T. Lee and A. Shraibman. Lower bounds in communication complexity. Foundations and Trends in Theoretical Computer Science, 3(4):263\u2013398, 2009.\n[7] L. Lov\u00e1sz and M. Saks. Lattices, mobius functions and communication complexity. In 29th Annual Symposium on Foundations of Computer Science\n(FOCS '88), pages 81\u201390, Los Angeles, Ca., USA, Oct. 1988. IEEE Computer\nSociety Press.\n[8] N. Nisan. CREW PRAMs and decision trees. SIAM Journal on Computing,\n20(6):999\u20131007, Dec. 1991.\n[9] A. A. Sherstov. Communication lower bounds using dual polynomials. Bulletin\nof the European Association for Theoretical Computer Science, 95:59\u201393, June\n2008.\n[10] Z. Zhang and Y. Shi. Communication complexities of symmetric XOR functions. Quantum Information and Computation, 9:255\u2013263, 2009.\n\n10\n\n\f"}