{"id": "http://arxiv.org/abs/0804.0735v2", "guidislink": true, "updated": "2009-04-14T17:36:47Z", "updated_parsed": [2009, 4, 14, 17, 36, 47, 1, 104, 0], "published": "2008-04-04T13:36:19Z", "published_parsed": [2008, 4, 4, 13, 36, 19, 4, 95, 0], "title": "Generalized Traveling Salesman Problem Reduction Algorithms", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0804.1895%2C0804.1300%2C0804.2913%2C0804.4240%2C0804.2637%2C0804.1250%2C0804.0885%2C0804.0431%2C0804.2301%2C0804.0652%2C0804.0669%2C0804.4251%2C0804.3144%2C0804.1608%2C0804.1337%2C0804.0735%2C0804.0112%2C0804.1540%2C0804.4817%2C0804.2687%2C0804.3050%2C0804.4382%2C0804.2210%2C0804.3128%2C0804.1677%2C0804.1797%2C0804.3377%2C0804.4078%2C0804.3894%2C0804.1133%2C0804.3747%2C0804.1156%2C0804.2057%2C0804.0922%2C0804.2750%2C0804.0270%2C0804.4846%2C0804.3719%2C0804.3001%2C0804.0206%2C0804.3405%2C0804.0199%2C0804.1579%2C0804.0210%2C0804.1356%2C0804.3852%2C0804.2580%2C0804.4720%2C0804.4784%2C0804.1633%2C0804.4555%2C0804.0863%2C0804.0742%2C0804.0315%2C0804.4421%2C0804.3153%2C0804.3344%2C0804.1464%2C0804.2332%2C0804.2605%2C0804.1211%2C0804.3998%2C0804.3806%2C0804.0327%2C0804.1722%2C0804.0256%2C0804.0471%2C0804.2428%2C0804.2418%2C0804.0033%2C0804.0714%2C0804.0948%2C0804.0041%2C0804.1622%2C0804.3797%2C0804.1599%2C0804.1810%2C0804.0147%2C0804.0061%2C0804.0272%2C0804.2051%2C0804.0637%2C0804.0586%2C0804.0229%2C0804.4644%2C0804.4207%2C0804.1376%2C0804.4284%2C0804.1924%2C0804.4885%2C0804.3415%2C0804.0608%2C0804.1743%2C0804.4792%2C0804.4439%2C0804.4400%2C0804.2537%2C0804.0564%2C0804.4714%2C0804.2849%2C0804.1273&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Generalized Traveling Salesman Problem Reduction Algorithms"}, "summary": "The generalized traveling salesman problem (GTSP) is an extension of the\nwell-known traveling salesman problem. In GTSP, we are given a partition of\ncities into groups and we are required to find a minimum length tour that\nincludes exactly one city from each group. The aim of this paper is to present\na problem reduction algorithm that deletes redundant vertices and edges,\npreserving the optimal solution. The algorithm's running time is O(N^3) in the\nworst case, but it is significantly faster in practice. The algorithm has\nreduced the problem size by 15-20% on average in our experiments and this has\ndecreased the solution time by 10-60% for each of the considered solvers.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0804.1895%2C0804.1300%2C0804.2913%2C0804.4240%2C0804.2637%2C0804.1250%2C0804.0885%2C0804.0431%2C0804.2301%2C0804.0652%2C0804.0669%2C0804.4251%2C0804.3144%2C0804.1608%2C0804.1337%2C0804.0735%2C0804.0112%2C0804.1540%2C0804.4817%2C0804.2687%2C0804.3050%2C0804.4382%2C0804.2210%2C0804.3128%2C0804.1677%2C0804.1797%2C0804.3377%2C0804.4078%2C0804.3894%2C0804.1133%2C0804.3747%2C0804.1156%2C0804.2057%2C0804.0922%2C0804.2750%2C0804.0270%2C0804.4846%2C0804.3719%2C0804.3001%2C0804.0206%2C0804.3405%2C0804.0199%2C0804.1579%2C0804.0210%2C0804.1356%2C0804.3852%2C0804.2580%2C0804.4720%2C0804.4784%2C0804.1633%2C0804.4555%2C0804.0863%2C0804.0742%2C0804.0315%2C0804.4421%2C0804.3153%2C0804.3344%2C0804.1464%2C0804.2332%2C0804.2605%2C0804.1211%2C0804.3998%2C0804.3806%2C0804.0327%2C0804.1722%2C0804.0256%2C0804.0471%2C0804.2428%2C0804.2418%2C0804.0033%2C0804.0714%2C0804.0948%2C0804.0041%2C0804.1622%2C0804.3797%2C0804.1599%2C0804.1810%2C0804.0147%2C0804.0061%2C0804.0272%2C0804.2051%2C0804.0637%2C0804.0586%2C0804.0229%2C0804.4644%2C0804.4207%2C0804.1376%2C0804.4284%2C0804.1924%2C0804.4885%2C0804.3415%2C0804.0608%2C0804.1743%2C0804.4792%2C0804.4439%2C0804.4400%2C0804.2537%2C0804.0564%2C0804.4714%2C0804.2849%2C0804.1273&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The generalized traveling salesman problem (GTSP) is an extension of the\nwell-known traveling salesman problem. In GTSP, we are given a partition of\ncities into groups and we are required to find a minimum length tour that\nincludes exactly one city from each group. The aim of this paper is to present\na problem reduction algorithm that deletes redundant vertices and edges,\npreserving the optimal solution. The algorithm's running time is O(N^3) in the\nworst case, but it is significantly faster in practice. The algorithm has\nreduced the problem size by 15-20% on average in our experiments and this has\ndecreased the solution time by 10-60% for each of the considered solvers."}, "authors": ["Gregory Gutin", "Daniel Karapetyan"], "author_detail": {"name": "Daniel Karapetyan"}, "author": "Daniel Karapetyan", "arxiv_comment": "To appear in Algorithmic Operations Research", "links": [{"href": "http://arxiv.org/abs/0804.0735v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0804.0735v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0804.0735v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0804.0735v2", "journal_reference": "Algorithmic Operations Research 4 (2009) 144-154", "doi": null, "fulltext": "Generalized Traveling Salesman Problem Reduction\nAlgorithms\n\narXiv:0804.0735v2 [cs.DS] 14 Apr 2009\n\nGregory Gutin\u2217\n\nDaniel Karapetyan\u2020\n\nAbstract\nThe generalized traveling salesman problem (GTSP) is an extension of the well-known\ntraveling salesman problem. In GTSP, we are given a partition of cities into groups and we\nare required to find a minimum length tour that includes exactly one city from each group.\nThe aim of this paper is to present a problem reduction algorithm that deletes redundant\nvertices and edges, preserving the optimal solution. The algorithm's running time is O(N 3 )\nin the worst case, but it is significantly faster in practice. The algorithm has reduced the\nproblem size by 15\u201320% on average in our experiments and this has decreased the solution\ntime by 10\u201360% for each of the considered solvers.\nKeywords Generalized Traveling Salesman Problem, Preprocessing, Reduction Algorithm\n\n1\n\nIntroduction\n\nThe generalized traveling salesman problem (GTSP) is defined as follows. We are given a weighted\ncomplete undirected graph G on N vertices and a partition V = V1 \u222aV2 \u222a. . .\u222aVM of its vertices; the\nsubsets Vi are called clusters. The objective is to find a minimum weight cycle containing exactly\none vertex from each cluster. There are many publications on GTSP (see, e.g., the surveys [4, 6]\nand the references therein). The problem has many applications, see, e.g., [2, 11]. It is NP-hard,\nsince the traveling salesman problem (TSP) is its special case (when |Vi | = 1 for each i). The\nweight of an edge xy of G is denoted dist(x, y) and will be often called the distance between x and\ny.\nVarious approaches to GTSP have been studied. There are exact algorithms such as branchand-bound and branch-and-cut described in [3]. Another approach uses the fact that GTSP can\nbe converted to an equivalent TSP with the same number of vertices [2, 13, 14, 15] and then can\nbe solved with some efficient TSP solver such as Concorde [1]. Heuristic GTSP algorithms have\nalso been invistigated, see, e.g., [7, 8, 10, 18, 19, 20, 21].\nDifferent preprocessing procedures are often used for hard problems to reduce the computation\ntime. There are examples of such approaches in integer and linear programming (e.g., [9, 17]) as\n\u2217 Department of Computer Science, Royal Holloway University of London, Egham, Surrey TW20 0EX, UK,\nG.Gutin@rhul.ac.uk\n\u2020 Department of Computer Science, Royal Holloway University of London, Egham, Surrey TW20 0EX, UK,\nDaniel.Karapetyan@gmail.com\n\n1\n\n\fwell as for the Vehicle Routing Problem [12]. In some cases preprocessing plays the key role in\nan algorithm (e.g., [5]). We introduce preprocessing procedure for GTSP. A feature of GTSP is\nthat not every vertex of a problem should be visited and, thus, GTSP may contain vertices that a\npriori are not included in the optimal solution and may be removed. We have a similar situation\nwith edges.\nThe experimental results show that almost each GTSP instance tested in the literature can be\nreduced by the presented procedure at a very low cost and that this reduction is almost always\nbeneficial for the GTSP solvers.\n\n2\n\nVertex Reduction\n\nSince GTSP solution covers only M vertices, up to N \u2212 M vertices may be reduced without a\nchange of the optimal solution. We present an approach to detect some of the redundant vertices\nin a reasonable time.\nDefinition 1. Let C be a cluster, |C| > 1. We say that a vertex r \u2208 C is redundant if for each\npair x, y of vertices from distinct clusters different from C, there exists a vertex s \u2208 C \\ {r} such\nthat dist(x, s) + dist(s, y) \u2264 dist(x, r) + dist(r, y).\nIn other words, if for each path xry there exists another path xsy, s \u2208 C \\ {r}, with the\nsame or smaller weight, vertex r can be removed. Testing this condition for every vertex will take\napproximately O(N 3 * |V |), where |V | = N/M is the average cluster size. In the symmetric case\nof the problem there is an efficient heuristic that usually allows to reduce the preprocessing time\nsignificantly.\nLet us take two distinct vertices r and s in some cluster C. We can calculate the differences\nbetween the distances to r and s from each vertex x \u2208\n/ C (\u2206r,s\nx = dist(x, r) \u2212 dist(x, s)) and save\nthis information to a Differences Table such as Table 1. Notice that in Table 1 we assume that\nclusters 1 and 2 have three vertices each and cluster 3 has two vertices, r belongs to the first cluster\nand it is the first vertex in the cluster, i.e., vertex s can be only the second and the third vertices\nof cluster 1.\nTable 1: Differences Table example.\ncl.2 v.2 cl.2 v.3\ncl.3 v.1 cl.3 v.2\n\ns\\x\n\ncl.2 v.1\n\nv.2\nv.3\n\n2\n\u22121\n\n0\n\u22122\n\n\u22121\n\u22121\n\n\u22123\n1\n\n4\n2\n\nmax\n\n2\n\n0\n\n\u22121\n\n1\n\n4\n\nmin{2, 0, \u22121} = \u22121\n\nNegative #\n2\n3\n\nmin{1, 4} = 1\n\nObserve that a vertex r is redundant if there is no pair of vertices from different clusters such\nthat the sum of differences \u2206 (see above) for these vertices is negative for every s, i.e., r is redundant\nr,s\nif for every x and y there exists s \u2208 C \\ {r} such that \u2206r,s\nx + \u2206y \u2265 0, where x and y belong to\n\n2\n\n\fdistinct clusters. That is due to\nr,s\n\u2206r,s\nx + \u2206y\n\n= dist(x, r) \u2212 dist(x, s) + dist(y, r) \u2212 dist(y, s)\n\u0001\n= dist(x, r) + dist(r, y) \u2212 dist(x, s) + dist(s, y)\nTherefore we need to check every pair of columns (col1 , col2 ) (except the pairs of columns\ncorresponding to the same clusters) in the Differences Table Trow,col. If T1,col1 + T1,col2 < 0, we\ncheck the second row (T2,col1 + T2,col2 ). If the result is still negative, we check the third row, etc. If\nall the rows are checked and each time we obtain a negative sum, the vertex r cannot be removed\nand the rest of the procedure may be skipped.\nExample 1. In the example above (Table 1) it is necessary to perform up to 6 tests provided in\nTable 2.\nTable 2: Vertices pairs for the example.\nPair\nSum for s = v.2\nSum for s = v.3\ncl.2\ncl.2\ncl.2\ncl.2\ncl.2\ncl.2\n\nv.1-cl.3\nv.1-cl.3\nv.2-cl.3\nv.2-cl.3\nv.3-cl.3\nv.3-cl.3\n\nv.1\nv.2\nv.1\nv.2\nv.1\nv.2\n\n\u22121\n6\n\u22123\n4\n\u22124\n3\n\n0\n\u22121\n\u22121\n0\n0\n1\n\nThe only test that does not allow us to declare the vertex r redundant is in the row 3 of the\nTable 2 (cl.2 v.2-cl.3 v.1) as both sums (for s = v.2 and for s = v.3) are negative. (Certainly,\nthere is no need to calculate the sum for s = v.3 in rows 2, 4, and 6 in the example above, and the\ncalculations may be stopped after the row 3.)\nRemoving redundant vertex may cause a previously irredundant vertex to become redundant.\nThus, it is useful to check redundancy of vertices in cyclic order until we see that, in the last cycle,\nno vertices are found to be redundant. However, in the worst case, that would lead to \u0398(N 2 )\nredundancy tests. (Recall that N is the total number of vertices in GTSP.) Our computational\nexperience has shown that almost all redundant vertices will be found even if we restrict ourselves\nto testing each vertex of GTSP at most twice. Thus, we assume in the rest of the paper that each\nvertex is tested at most twice for redundancy.\n\n2.1\n\nAcceleration Heuristic\n\nIn some cases it is possible to determine faster that a vertex r is not redundant. If\nr,s\nmin max \u2206r,s\nx + min max \u2206x < 0\nx\u2208Z\n/ s\u2208C\n\nx\u2208Z s\u2208C\n\nfor some cluster Z, then r cannot be reduced. This condition means that there exist two columns\nin the Differences Table corresponding to distinct clusters and the sum of these columns maxima\nis negative. This ensures that the sum for every row of these columns is also negative.\n3\n\n\fWe can use an equivalent condition:\nx\u2208\n\nmin\nS\n\nr,s\nmax \u2206r,s\nx + min max \u2206x < 0\n\ns\u2208C\nj<i Vj\n\nx\u2208Vi s\u2208C\n\nThis condition can be tested during the Difference Table generation. For each column we calculate\nthe maximum value:\nvertexmax(x) = max \u2206r,s\nx\ns\u2208C\n\nAlso for each cluster Z, we have\nclustermin(Z) = min vertexmax(x)\nx\u2208Z\n\nWe define totalmin(i) = minj<i clustermin(Vj ); if totalmin(i) + clustermin(Vi ) < 0 for some i,\nwe can conclude that vertex r is not redundant.\nIn the example above, the heuristic performs just one check for V2 and V3 . We have totalmin(3) =\nclustermin(V2 ) = \u22121 and clustermin(V3 ) = 1 and \u22121 + 1 \u2265 0 so the acceleration heuristic does\nnot reduce our computations in this case.\nAnother way to make the redundancy test faster is to order the rows of the Differences Table\nsuch that the row with the minimal number of negative values would be the first one. Notice that,\nif this row contains no negative values, it is obvious that r is redundant.\n\n2.2\n\nAlgorithm Complexity\n\nLet Kmin and Kmax be the minimum and the maximum number of tests (of vertices) for redundancy.\nObserve that Kmin = N , since we will perform only N tests if no vertex is detected to be redundant.\nSince we have assumed that no vertex is tested more than twice for redundancy, Kmax = 2N \u2212 1.\nNow consider how many operations are required for each redundancy test (with a fixed vertex\nr). The test requires table generation and table processing. Due to the acceleration heuristic,\ntable generation can be aborted already after processing of two clusters. Thus, in the best case it\ntakes Emin = (|C| \u2212 1)(|X| + |Y |) operations where r \u2208 C, and X and Y are some other clusters.\nThe average size of a cluster can be estimated as N/M (recall that M is the number of clusters).\nTherefore, in the best case each redundancy test requires approximately\n\u0013\n\u0012 \u2032 \u00132\n\u0013\u0012\n\u0012 \u2032\nN\nN\u2032\nN\n\u22482*\n\u22121\n2*\nEmin (N \u2032 ) \u2248\nM\nM\nM\noperations, where N \u2032 is the current number of vertices in the problem.\nIn the worst case both the table generation and the further table inspection will be completed\nnormally. Table generation will take (|C| \u2212 1)(N \u2032 \u2212 |C|) operations. Table inspection takes about\n\u0010\n\u00112\nN \u2032 \u2212 |C| \u2212 |V | (|C| \u2212 1) /2 operations in the worst case, where |V | is the average cluster size.\nThus, we have the following number of operations per test in the worst case:\n\u0010\n\u00112\nN \u2032 \u2212 |C| \u2212 |V | (|C| \u2212 1)\nEmax (N \u2032 ) \u2248 (|C| \u2212 1) (N \u2032 \u2212 |C|) +\n2\n(N \u2032 )3\n(N \u2032 )2 * |C|\n\u2032\n\u2248\n.\n\u2248 |C| * N +\n2\n2M\n4\n\n\fThe total number of operations in the worst case is\nKmax * Emax (N ) \u2248 2 * N *\n\nN4\nN3\n=\n.\n2M\nM\n\nThe total operation number in the best case is\nKmin * Emin (N ) \u2248 N * 2 *\n\n\u0012\n\nN\nM\n\n\u00132\n\n=2*\n\nN3\n.\nM2\n\nSince usually M = \u0398(N ), the algorithm complexity changes from O(N ) to O(N 3 ). The experimental algorithm complexity is \u0398(N 2.4 ) (see Section 4.1).\n\n3\n\nEdge Reduction\n\nDefinition 2. Let u, v be a pair of vertices from distinct clusters U and C respectively. Then\nthe edge uv is redundant if for each vertex x \u2208 V \\ U \\ C there exists v \u2032 \u2208 C \\ {v} such that\ndist(u, v \u2032 ) + dist(v \u2032 , x) \u2264 dist(u, v) + dist(v, x).\nTesting this condition for every edge will work for both symmetric and asymmetric cases and\nwill take approximately O(N 3 *|V |), where |V | is the average cluster size. We introduce an algorithm\nfor edge reduction for the symmetric case of the problem; it proceeds as follows. Given a vertex\nv \u2208 C, where |C| > 1, we detect redundant edges incident with v using the following procedure:\n1. Select an arbitrary vertex v \u2032\u2032 \u2208 C \\ {v}.\n\u2032\u2032\n\n2. Set Px = \u2206v,v\nfor each vertex x \u2208 V \\ C (recall that \u2206r,s\nx\nx = dist(x, r) \u2212 dist(x, s)).\n3. Sort array P in non-decreasing order.\n4. For each cluster U 6= C and for each vertex u \u2208 U do the following:\n(a) \u03b4 = \u2206v,v\nu\n\n\u2032\u2032\n\u2032\u2032\n\n\u2032\u2032\n\n(b) For each item \u2206v,v\nof the array P such that \u2206v,v\n+ \u03b4 < 0 check the following: if x \u2208\n/U\nx\nx\n\u2032\nv,v \u2032\n\u2032\n\u2032\u2032\nand \u2206v,v\n+\n\u2206\n<\n0\nfor\nevery\nv\n\u2208\nC\n\\\n{v,\nv\n},\nthe\nedge\nuv\nis\nnot\nredundant,\ncontinue\nx\nu\nwith the next u.\n(c) Edge uv is redundant, set dist(u, v) = \u221e.\nTo prove that the above edge reduction algorithm works correctly, let fix some edge uv, u \u2208 U ,\nv \u2208 C, U 6= C. The algorithm declares this edge redundant if the following condition holds for\neach x \u2208\n/ C (see 4b):\n\u2032\u2032\n\n\u2032\u2032\n\n\u2206v,v\n+ \u2206v,v\n\u22650\nx\nu\n\u2032\n\u2206v,v\nx\n\n+\n\n\u2032\n\u2206v,v\nu\n\n\u22650\n\nor\nfor some v \u2032 \u2208 C \\ {v, v \u2032\u2032 }\n\nThis condition is equivalent to\n\u2032\n\n\u2032\n\n\u2206v,v\n+ \u2206v,v\n\u22650\nx\nu\n\nfor some v \u2032 \u2208 C \\ {v}\n5\n\n\fSo the algorithm declares the edge uv redundant if for each x \u2208 V \\C \\U there exists v \u2032 \u2208 C \\{v}\n\u2032\n\u2032\nsuch that \u2206v,v\n+ \u2206v,v\n\u2265 0.\nx\nu\ndist(x, v) \u2212 dist(x, v \u2032 ) + dist(u, v) \u2212 dist(u, v \u2032 ) \u2265 0\ndist(u, v) + dist(v, x) \u2265 dist(u, v \u2032 ) + dist(v \u2032 , x).\n\nand\n\nLet us evaluate the algorithm's complexity. The edge reduction algorithm performs the following steps for every cluster C, |C| > 1 for each v \u2208 C:\n\u2022 Array P generation. This takes \u0398(N ) operation.\n\u2022 Array P sorting. This takes \u0398(N log2 N ) operations.\n\u2022 Edges uv testing. Each test takes O(1) to O(N *|C|) operations and \u0398(N ) tests are performed.\nThus the complexity of the entire algorithm is \u0398(N 2 log2 N ) in the best case, and \u0398(N 3 * |C|)\nin the worst case.\nAs usually |C| = \u0398(N ), we may say that this algorithm's complexity varies from \u0398(N 2 log2 N )\nto \u0398(N 3 ). The experimental algorithm complexity is \u0398(N 2.6 ) (see Section 4.1).\nAfter the search for redundant edges has been completed, the edge reduction algorithm finds\nredundant vertices using the following observation: if after the edge reduction procedure some\nvertex has finite distance edges to at most one cluster, then this vertex can be declared redundant.\nThis reduction takes O(N 2 ) operations.\n\n4\n\nExperiments\n\nWe tested the reduction algorithms on the standard GTSP instances (see, e.g., [2, 18, 19, 20]) which\nwere generated from some TSPLIB [16] instances by applying the clustering procedure of Fischetti,\nSalazar and Toth [3]. The algorithms were implemented in C++ and tested on a computer with\nAMD Atlon 64 X2 Core Dual processor (3 GHz frequency).\nWe have tested three reduction algorithms: the Vertex Reduction Algorithm (see Section 2),\nthe Edge Reduction Algorithm (see Section 3), and the Combined Algorithm witch first applies\nthe Vertex Reduction Algorithm and then the Edge Reduction Algorithm.\n\n4.1\n\nExperimental Results\n\nEach test was repeated ten times. The columns of the table are as follows:\n\u2022 Instance is the instance name. The prefix number is the number of clusters of the instance;\nthe suffix number is the number of vertices (before any preprocessing).\n\u2022 Rv is the number of vertices detected as redundant.\n6\n\n\f\u2022 Re is the number of edges detected as redundant. For the Combined Algorithm Re shows\nthe number of redundant edges in the already reduced by the Vertex Reduction Algorithm\nproblem.\n\u2022 T is the preprocessing time in seconds.\nTable 3: Test results of the Reduction Algorithms.\nVertex reduction\n\nEdge reduction\n\nCombined reduction\n\nInstance\n\nRv\n\nRv , %\n\nT\n\nRe , %\n\nRv\n\nT\n\nRv , %,\n\nRe , %\n\nT\n\n4ulysses16\n4gr17\n5gr21\n5ulysses22\n5gr24\n6fri26\n6bayg29\n9dantzig42\n10att48\n10gr48\n10hk48\n11berlin52\n11eil51\n12brazil58\n14st70\n16eil76\n16pr76\n20gr96\n20rat99\n20kroA100\n20kroB100\n20kroC100\n20kroD100\n20kroE100\n20rd100\n21eil101\n21lin105\n22pr107\n24gr120\n25pr124\n26bier127\n26ch130\n28pr136\n28gr137\n29pr144\n30ch150\n30kroA150\n\n9\n11\n8\n11\n13\n13\n12\n6\n15\n18\n6\n15\n9\n14\n12\n12\n2\n13\n11\n16\n8\n19\n19\n21\n11\n14\n9\n9\n15\n17\n2\n16\n14\n10\n19\n22\n20\n\n56.3\n64.7\n38.1\n50.0\n54.2\n50.0\n41.4\n14.3\n31.3\n37.5\n12.5\n28.8\n17.6\n24.1\n17.1\n15.8\n2.6\n13.5\n11.1\n16.0\n8.0\n19.0\n19.0\n21.0\n11.0\n13.9\n8.6\n8.4\n12.5\n13.7\n1.6\n12.3\n10.3\n7.3\n13.2\n14.7\n13.3\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n62.0\n35.8\n48.7\n44.3\n33.1\n28.7\n37.9\n36.2\n41.5\n27.0\n34.2\n36.1\n32.6\n24.5\n36.5\n28.8\n29.0\n25.8\n23.7\n20.9\n28.1\n27.2\n27.9\n26.4\n32.1\n35.5\n35.4\n35.6\n28.4\n32.5\n21.5\n25.9\n22.4\n19.9\n33.2\n19.9\n22.5\n\n4\n3\n3\n2\n3\n3\n5\n0\n7\n4\n3\n1\n3\n3\n3\n2\n1\n3\n3\n2\n2\n2\n2\n1\n2\n1\n3\n0\n4\n3\n1\n3\n1\n1\n2\n2\n6\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n56.3\n64.7\n38.1\n50.0\n54.2\n50.0\n41.4\n14.3\n31.3\n37.5\n12.5\n28.8\n17.6\n24.1\n17.1\n15.8\n2.6\n13.5\n11.1\n16.0\n8.0\n19.0\n19.0\n21.0\n11.0\n13.9\n8.6\n8.4\n12.5\n13.7\n1.6\n12.3\n10.3\n7.3\n13.2\n14.7\n13.3\n\n23.5\n23.0\n45.0\n39.5\n10.4\n20.3\n33.6\n24.9\n25.3\n25.5\n32.3\n35.0\n28.8\n29.0\n24.6\n28.6\n29.7\n20.6\n23.2\n18.8\n25.0\n24.2\n19.8\n20.2\n28.8\n31.5\n32.4\n35.9\n29.6\n22.2\n19.7\n21.2\n26.3\n17.0\n31.1\n18.1\n19.5\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n\n7\n\n\fVertex reduction\n\nEdge reduction\n\nCombined reduction\n\nInstance\n\nRv\n\nRv , %\n\nT\n\nRe , %\n\nRv\n\nT\n\nRv , %,\n\nRe , %\n\nT\n\n30kroB150\n31pr152\n32u159\n35si175\n36brg180\n39rat195\n40d198\n40kroA200\n40kroB200\n41gr202\n45ts225\n45tsp225\n46pr226\n46gr229\n53gil262\n53pr264\n56a280\n60pr299\n64lin318\n64linhp318\n80rd400\n84fl417\n87gr431\n88pr439\n89pcb442\n99d493\n107att532\n107ali535\n107si535\n113pa561\n115u574\n115rat575\n131p654\n132d657\n134gr666\n145u724\n157rat783\n200dsj1000\n201pr1002\n207si1032\n212u1060\n217vm1084\n235pcb1173\n259d1291\n\n14\n34\n33\n45\n97\n12\n7\n16\n7\n4\n40\n12\n12\n1\n16\n11\n20\n15\n13\n13\n11\n43\n0\n10\n24\n4\n21\n29\n96\n147\n11\n18\n88\n8\n0\n34\n25\n8\n20\n85\n36\n241\n11\n48\n\n9.3\n22.4\n20.8\n25.7\n53.9\n6.2\n3.5\n8.0\n3.5\n2.0\n17.8\n5.3\n5.3\n0.4\n6.1\n4.2\n7.1\n5.0\n4.1\n4.1\n2.8\n10.3\n0.0\n2.3\n5.4\n0.8\n3.9\n5.4\n17.9\n26.2\n1.9\n3.1\n13.5\n1.2\n0.0\n4.7\n3.2\n0.8\n2.0\n8.2\n3.4\n22.2\n0.9\n3.7\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.1\n0.0\n0.1\n0.0\n0.0\n0.1\n0.0\n0.0\n0.1\n0.0\n0.1\n0.1\n0.2\n0.1\n0.6\n0.1\n0.2\n\n23.8\n37.5\n23.5\n27.4\n57.9\n22.2\n23.1\n20.3\n19.1\n18.8\n20.0\n20.5\n29.6\n22.0\n21.8\n21.5\n19.4\n16.2\n20.5\n20.5\n14.8\n28.3\n17.2\n14.7\n11.9\n17.8\n20.5\n16.6\n26.5\n31.3\n14.4\n11.2\n32.6\n10.8\n11.6\n10.1\n9.8\n9.6\n9.2\n12.1\n14.4\n24.0\n8.2\n12.4\n\n2\n7\n3\n5\n51\n1\n4\n2\n1\n1\n2\n2\n1\n0\n3\n1\n1\n0\n2\n2\n1\n5\n0\n1\n0\n1\n2\n2\n9\n5\n1\n2\n2\n0\n0\n3\n2\n1\n2\n12\n1\n8\n0\n2\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.1\n0.1\n0.3\n0.2\n0.1\n0.2\n0.3\n0.5\n0.3\n0.3\n0.2\n0.2\n0.8\n0.3\n1.0\n0.5\n0.4\n2.4\n3.0\n1.2\n1.7\n2.3\n1.5\n2.3\n\n9.3\n22.4\n20.8\n25.7\n53.9\n6.2\n3.5\n8.0\n3.5\n2.0\n17.8\n5.3\n5.3\n0.4\n6.1\n4.2\n7.1\n5.0\n4.1\n4.1\n2.8\n10.3\n0.0\n2.3\n5.4\n0.8\n3.9\n5.4\n17.9\n26.2\n1.9\n3.1\n13.5\n1.2\n0.0\n4.7\n3.2\n0.8\n2.0\n8.2\n3.4\n22.2\n0.9\n3.7\n\n23.4\n26.6\n15.1\n17.5\n16.9\n20.4\n24.2\n20.6\n18.5\n18.5\n11.2\n17.1\n28.4\n21.6\n18.9\n20.7\n16.1\n14.7\n20.8\n20.8\n13.0\n22.7\n17.2\n15.0\n9.7\n19.4\n18.1\n14.3\n17.9\n22.6\n14.0\n10.9\n28.2\n9.6\n11.6\n8.8\n8.4\n9.4\n8.7\n10.2\n11.2\n8.9\n8.2\n9.8\n\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.0\n0.1\n0.3\n0.1\n0.1\n0.2\n0.3\n0.5\n0.1\n0.1\n0.2\n0.1\n0.5\n0.3\n1.0\n0.4\n0.3\n1.5\n1.6\n0.9\n2.0\n1.3\n1.3\n1.7\n\n8\n\n\fVertex reduction\n\nEdge reduction\n\nCombined reduction\n\nInstance\n\nRv\n\nRv , %\n\nT\n\nRe , %\n\nRv\n\nT\n\nRv , %,\n\nRe , %\n\nT\n\n261rl1304\n265rl1323\n276nrw1379\n280fl1400\n287u1432\n316fl1577\n331d1655\n350vm1748\n364u1817\n378rl1889\n421d2103\n431u2152\n464u2319\n479pr2392\n608pcb3038\n759fl3795\n893fnl4461\n1183rl5915\n1187rl5934\n1480pla7397\n2370rl11849\n2702usa13509\n\n19\n23\n11\n23\n33\n44\n14\n285\n5\n17\n8\n10\n24\n33\n29\n21\n22\n28\n38\n196\n37\n21\n\n1.5\n1.7\n0.8\n1.6\n2.3\n2.8\n0.8\n16.3\n0.3\n0.9\n0.4\n0.5\n1.0\n1.4\n1.0\n0.6\n0.5\n0.5\n0.6\n2.6\n0.3\n0.2\n\n0.2\n0.2\n0.2\n0.9\n0.2\n0.4\n0.2\n2.5\n0.1\n0.7\n0.2\n0.3\n0.6\n0.9\n1.4\n4.9\n3.4\n7.9\n9.4\n31.5\n40.7\n98.7\n\n7.9\n7.8\n7.4\n17.4\n7.7\n10.3\n6.7\n19.8\n6.2\n7.3\n6.7\n5.2\n3.9\n5.9\n4.7\n6.4\n3.1\n2.4\n3.0\n4.6\n\n2\n1\n1\n0\n1\n2\n1\n2\n0\n3\n1\n0\n0\n1\n1\n0\n0\n2\n2\n1\n\n2.6\n4.1\n3.7\n6.5\n3.2\n5.0\n3.7\n11.4\n4.9\n10.9\n2.9\n7.8\n10.3\n15.4\n45.4\n127.2\n80.2\n258.1\n308.3\n2147.9\n\n1.5\n1.7\n0.8\n1.6\n2.3\n2.8\n0.8\n16.3\n0.3\n0.9\n0.4\n0.5\n1.0\n1.4\n1.0\n0.6\n0.5\n0.5\n0.6\n2.6\n\n7.2\n7.0\n7.1\n17.5\n6.6\n9.2\n6.7\n11.0\n5.8\n6.8\n6.6\n5.0\n3.8\n5.3\n4.7\n6.5\n2.9\n2.3\n2.7\n3.6\n\n2.0\n2.9\n2.6\n5.3\n2.6\n4.5\n3.7\n5.5\n4.5\n7.2\n2.7\n6.6\n9.7\n13.4\n36.2\n94.5\n46.7\n114.1\n139.6\n1001.3\n\nThe results of the experiments show that the preprocessing time for the Vertex Reduction is\nnegligible for all the instances up to 212u1060, i.e., for almost all TSPLIB-based GTSP instances\nused in the literature. The average percentage of detected redundant vertices for these instances is\n14%, and it is 11% for all considered instances. The experimental algorithm complexity is about\nO(N 2.4 ).\nThe Edge Reduction is more time-consuming than the Vertex Reduction. The running time\nis negligible for all instances up to 115rat575. Note that in most of the GTSP literature, only\ninstances with N < 500 are considered. The average per cent of the detected redundant edges\nfor these instances is about 27%, and it is 21% for all instances in Table 3. The experimental\nalgorithm's complexity is O(N 2.6 ).\n\n4.2\n\nAlgorithms Application Results\n\nCertainly, one can doubt the usefulness of our reduction algorithms since they may not necessarily\ndecrease the running time of GTSP solvers. Therefor, we tested the improvement of the running\ntime of the following GTSP solvers:\n1. Exact algorithm (Exact) based on a transformation of GTSP to TSP [2]; the algorithm\nfrom [4] was not available. The algorithm that we use converts a GTSP instance with N\n9\n\n\fvertices to a TSP instance with 3N vertices in polynomial time, solves the obtained TSP\nusing the Concorde solver [1], and then converts the obtained TSP solution to GTSP solution\nalso in polynomial time.\n2. Memetic algorithm from [19] (SD). A memetic algorithm (MA) is a combination of a genetic\nalgorithm with local search.\n3. MA from [7] (GKK).\n4. MA from [18] (SG).\n5. A modified version of MA from [8], the state-of-the-art GTSP memetic solver, (GK).\nEach test was repeated ten times. The columns of the tables not described in Section 4.1 are\nas follows:\n\u2022 T0 is the initial problem solution time.\n\u2022 B is the time benefit, i.e., (T0 \u2212 Tpr )/T0 , where Tpr is the preprocessed problem solution\ntime; it includes preprocessing time as well.\n\nTable 4: Time benefit for Exact.\nVertices Red.\nEdge Red.\nInstance\n5gr21\n5ulysses22\n5gr24\n6fri26\n6bayg29\n10gr48\n10hk48\n11eil51\n14st70\nAverage\n\nCombined Reduction\n\nT0 , sec\n\nRv , %\n\nB, %\n\nRe , %\n\nB, %\n\nRv , %\n\nRe , %\n\nB, %\n\n0.8\n1.7\n0.2\n0.9\n6.0\n16.1\n52.7\n32.8\n150.4\n\n38.1\n50.0\n54.2\n50.0\n41.4\n37.5\n12.5\n17.6\n17.1\n\n40\n60\n74\n67\n19\n57\n16\n37\n43\n\n48.7\n44.3\n33.1\n28.7\n0.0\n27.0\n34.2\n32.6\n36.5\n\n52\n48\n53\n18\n59\n2\n6\n17\n17\n\n38.0\n50.0\n54.1\n50.0\n41.3\n37.5\n12.5\n17.6\n17.1\n\n45.0\n39.5\n10.4\n20.3\n33.6\n25.5\n32.3\n28.8\n24.6\n\n56\n79\n81\n74\n70\n55\n22\n42\n50\n\n35.4\n\n45.9\n\n31.7\n\n30.2\n\n35.3\n\n28.9\n\n58.8\n\nThe experiments show that the Vertex Reduction, the Edge Reduction and the Combined\nReduction Technique significantly reduce the running time of the Exact, SD and GKK solvers.\nHowever, the Edge Reduction (and because of that the Combined Reduction Techique) is not that\nsuccessful for SG (Table 7) and the original version of GK. That is because not every algorithm\nprocesses infinite edges well.\nNext we show that a solver can be adjusted to work better with preprocessed instances. For\nthis purpose we modified GK as follows:\n\u2022 The 2-opt heuristic [8] was extended with the cluster optimization. For every iteration of\n2-opt, where edges v1 v2 and v3 v4 are removed, instead of replacing them with v1 v3 and v2 v4\n10\n\n\fTable 5: Time benefit for GKK.\nVertices Red.\nEdge Red.\nInstance\n89pcb442\n99d493\n107att532\n107ali535\n107si535\n113pa561\n115u574\n115rat575\n131p654\n132d657\n134gr666\n145u724\n157rat783\n200dsj1000\nAverage\n\nCombined Reduction\n\nT0 , sec\n\nRv , %\n\nB, %\n\nRe , %\n\nB, %\n\nRv , %\n\nRe , %\n\nB, %\n\n60.7\n85.2\n101.2\n99.3\n166.1\n101.8\n103.6\n219.3\n165.4\n189.1\n224.8\n232.9\n392.7\n898\n\n5.4\n0.8\n3.9\n5.4\n17.9\n26.2\n1.9\n3.1\n13.4\n1.2\n0.0\n4.6\n3.1\n0.8\n\n4\n14\n9\n0\n12\n15\n-3\n38\n21\n10\n26\n25\n1\n6\n\n11.9\n17.8\n20.5\n16.6\n26.5\n31.3\n14.4\n11.2\n32.6\n10.8\n11.6\n10.1\n9.8\n9.6\n\n17\n19\n20\n47\n14\n21\n12\n36\n12\n22\n36\n29\n16\n52\n\n5.4\n0.8\n3.9\n5.4\n17.9\n26.2\n1.9\n3.1\n13.4\n1.2\n0.0\n4.6\n3.1\n0.8\n\n9.7\n19.4\n18.1\n14.3\n17.9\n22.6\n14.0\n10.9\n28.2\n9.6\n11.6\n8.8\n8.4\n9.4\n\n35\n29\n20\n51\n41\n47\n28\n45\n38\n24\n57\n55\n29\n51\n\n6.3\n\n12.7\n\n16.8\n\n25.2\n\n6.3\n\n14.5\n\n39.3\n\nwe replace them with v1\u2032 v3 and v2\u2032 v4 , where v1\u2032 \u2208 cluster(v1 ) and v2\u2032 \u2208 cluster(v2 ) and v1\u2032\nand v2\u2032 are selected to minimize the solution objective value. (Here cluster(v) is the cluster\ncorresponding to the vertex v: v \u2208 cluster(v).) Thereby, while the initial 2-opt heuristic\ncould decline some good 2-opt if w(v1 v3 ) = \u221e or w(v2 v4 ) = \u221e, the extended 2-opt will pass\nround the infinite edges.\n\u2022 Direct 2-opt heuristic [8] is excluded from the Local Search Procedure.\n\u2022 Every time before starting the Cluster Optimization [8] we remove all vertices that cannot\nbe included in the solution, i.e., if a fragment of the solution corresponds to clusters C1 , C2\nand C3 and there is no edge from C1 to v \u2208 C2 or there is no edge from v to C3 then v can\nbe excluded for the current Cluster Optimization run.\n\u2022 Since the modified Local Search Procedure is more powerful than the previous one, we\nreduced the number of solutions in a generation and the termination condition is also\nchanged (now r = 0.2G + 0.03M + 8 while previously r = 0.2G + 0.05M + 10 and Icur \u2265\nmax(1.5Imax , 0.025M + 2) instead of Icur \u2265 max(1.5Imax , 0.05M + 5), see [8]).\nThe modified algorithm does not reproduce exactly the results of the initial GK heuristic; it\ngives a little bit better solution quality at the cost of slightly larger running times. However, one\ncan see (Table 8) that all the Reduction Algorithms proposed in this paper influence the modified\nGK algorithm positively.\nDifferent reductions have different degree of success for different solvers. The Edge Reduction\nis more efficient than the Vertex Reduction for GKK and SD; in other cases the Vertex Reduction\nis more successful. For every solver except SG the Combined Technique is preferred to separate\nreductions.\n11\n\n\fTable 6: Time benefit for SD.\nVertices Red.\nEdge Red.\nInstance\n157rat783\n200dsj1000\n201pr1002\n207si1032\n212u1060\n217vm1084\n235pcb1173\n259d1291\n261rl1304\n265rl1323\n276nrw1379\n\nCombined Reduction\n\nT0 , sec\n\nRv , %\n\nB, %\n\nRe , %\n\nB, %\n\nRv , %\n\nRe , %\n\nB, %\n\n23.6\n100.3\n54.9\n21.3\n88.8\n78.1\n107.9\n169.4\n140.4\n132.6\n111.5\n\n3.2\n0.8\n1.9\n8.2\n3.3\n22.2\n0.9\n3.7\n1.5\n1.8\n0.8\n\n11\n47\n12\n3\n8\n49\n5\n9\n9\n20\n4\n\n9.8\n9.6\n9.2\n12.1\n14.4\n24.0\n8.2\n12.4\n7.9\n7.8\n7.4\n\n5\n36\n22\n-1\n35\n-2\n30\n25\n47\n20\n22\n\n3.1\n0.8\n1.9\n8.2\n3.3\n22.2\n0.9\n3.7\n1.4\n1.7\n0.7\n\n8.4\n9.4\n8.7\n10.2\n11.2\n8.9\n8.2\n9.8\n7.2\n7.0\n7.1\n\n36\n42\n43\n24\n42\n57\n32\n26\n66\n32\n46\n\n4.4\n\n16.1\n\n11.2\n\n21.7\n\n4.4\n\n8.7\n\n40.5\n\nAverage\n\nPreprocessing is called to reduce the solution time. On the other hand, there is no guaranty\nthat the outcome of the preprocessing will be noticeable. Thus, it is important to ensure at least\nthat the preprocessing time is significantly shorter than the solution time.\nFive GTSP solvers are considered in this paper. The first solver, Exact, is an exact one and,\nthus, it is clear that its time complexity is larger than \u0398(N 2.6 ) (see Section 4.1) or even the upper\nbound O(N 3 ). The time complexities of the other four solvers were estimated experimentally, i.e.,\nexperiments were conducted for problems of different size obtained from TSPLIB [16] and then an\napproximation for \"solution time\"/\"instance size\" dependence was found. The experimental complexity of SD is about \u0398(N 3 ) and it is about \u0398(N 3.5 ) for GK, SG and GKK. Table 9 demonstrates\nthe quality of our estimate for SD (here Testimate (N ) = 6.3319 * 10\u22128 * N 3 ).\nHaving the solvers time complexities, we can conclude that the preprocessing time is significantly smaller than the solution time for arbitrary large instances as the experimental complexity\nof preprocessing is smaller than the complexity of even the fastest of the considered solvers.\n\n5\n\nConclusion\n\nThe GTSP reduction techniques allow one to significantly decrease the problem complexity at a\nvery low cost. Experiments show that the Combined Reduction is often the most powerful among\nthe presented algorithms and takes even less time than the single Edge Reduction. While the\nVertex Reduction yields very natural problems and is successful with every considered solver, the\nEdge Reduction changes some edge weights to infinity values and, thus, not every solver benefits\nfrom it. However, in this paper, it is shown that a solver can be modified to process such problems\nwell.\nIn this paper we consider the symmetric case only, i.e., dist(x, y) = dist(y, x) for every pair of\n\n12\n\n\fTable 7: Time benefit for SG.\nVertices Red.\nInstance\n84fl417.gtsp\n87gr431.gtsp\n88pr439.gtsp\n89pcb442.gtsp\n99d493.gtsp\n107att532.gtsp\n107si535.gtsp\n107ali535.gtsp\n113pa561.gtsp\n\nT0 , sec\n\nRv , %\n\nB, %\n\n4.5\n8.3\n10.2\n11.5\n20.0\n25.1\n16.9\n29.1\n14.5\n\n10.3\n0.0\n2.3\n5.4\n0.8\n3.9\n17.9\n5.4\n26.2\n\n12\n6\n-3\n0\n7\n11\n34\n20\n31\n\n8.0\n\n13\n\nAverage\n\nvertices x and y. Other vertex and edge reduction algorithms that can be immediately derived\nfrom Definitions 1 and 2 exist for the asymmetric case, and their time complexity is O(N 3 ). Recall\nthat N is the total number of problem vertices.\nAcknowledgement We would like to thank Larry Snyder and John Silberholz for kindly providing\nthe source codes of SD and SG, respectively.\n\nReferences\n[1] D. Applegate, R. E. Bixby, V. Chv\u00e1tal, and W. J. Cook. Concorde TSP Solver. Available at\nhttp://www.tsp.gatech.edu.\n[2] D. Ben-Arieh, G. Gutin, M. Penn, A. Yeo, and A. Zverovitch. Transformations of generalized\nATSP into ATSP, Operations Research Letters 31 (2003), pp. 357\u2013365.\n[3] M. Fischetti, J. J. S. Gonz\u00e1lez, and P. Toth. A Branch-and-Cut algorithm for the symmetric\ngeneralized traveling salesman problem. Operations Research 45 (3) (1997), pp. 378\u2013394.\n[4] M. Fischetti, J. J. S. Gonz\u00e1lez, and P. Toth. The Generalized Traveling Salesman and Orienteering Problems. In The Traveling Salesman Problem and its Variations (G. Gutin and\nA. Punnen, eds.), Kluwer, Dordrecht, 2002.\n[5] R. Fourer, D. M. Gay. Experience with a Primal Presolve Algorithm. Large Scale Optimization:\nState of the Art (1994), pp. 135\u2013154.\n[6] G. Gutin. Traveling Salesman Problems. In Handbook of Graph Theory (J. Gross, and J. Yellen,\neds.), CRC Press, 2003.\n[7] G. Gutin, D. Karapetyan, and N. Krasnogor. A memetic algorithm for the asymmetric generalized traveling salesman problem. In Proc. NICSO 2007, Studies in Computational Intelligence\n129 (2008), pp. 199\u2013210, Springer.\n13\n\n\fTable 8: Time benefit for GK.\nVertices Red.\nEdge Red.\nInstance\n89pcb442.gtsp\n99d493.gtsp\n107att532.gtsp\n107si535.gtsp\n107ali535.gtsp\n113pa561.gtsp\n115u574.gtsp\n115rat575.gtsp\n131p654.gtsp\n\nCombined Reduction\n\nT0 , sec\n\nRv , %\n\nB, %\n\nRe , %\n\nB, %\n\nRv , %\n\nRe , %\n\nB, %\n\n3.43\n6.36\n5.96\n4.52\n8.91\n6.86\n7.43\n7.29\n5.47\n\n5.4\n0.8\n3.9\n17.9\n5.4\n26.2\n1.9\n3.1\n13.5\n\n16\n2\n7\n14\n17\n20\n-2\n0\n11\n\n12.0\n17.9\n20.6\n26.5\n16.6\n31.3\n14.4\n11.3\n32.7\n\n-2\n0\n10\n8\n19\n6\n-6\n0\n2\n\n5.4\n0.8\n3.9\n17.9\n5.4\n26.2\n1.9\n3.1\n13.5\n\n9.8\n19.4\n18.1\n18.0\n14.3\n22.6\n14.0\n10.9\n28.3\n\n7\n2\n11\n15\n25\n23\n-1\n2\n13\n\n8.7\n\n9\n\n20.4\n\n4\n\n8.7\n\n17.3\n\n11\n\n[8] G. Gutin, and D. Karapetyan. A memetic algorithm for the generalized traveling salesman\nproblem. To appear in Natural Computing, Springer 2009.\n[9] P. Gutman, and I. Ioslovich. On the generalized Wolf problem: Preprocessing of nonnegative large-scale linear programming problems with group constraints. Automation and Remote\nControl, Volume 68, Number 8, August 2007, pp. 1401\u20131409.\n[10] H. Huang, X. Yang, Z. Hao, C. Wu, Y. Liang, and X. Zhao. Hybrid Chromosome Genetic\nAlgorithm for Generalized Traveling Salesman Problems. Phys. Rev. E, American Physical\nSociety, 2004, 70.\n[11] G. Laporte, A. Asef-Vaziri, and C. Sriskandarajah. Some applications of the generalized travelling salesman problem. Journal of the Operational Research Society 47 (12) (1996), pp. 1461\u2013\n1467.\n[12] G. Laporte, H. Mercure, and Y. Nobert. A Branch and Bound Algorithm for a Class of\nAsymmetrical Vehicle Routing Problems. The Journal of the Operational Research Society,\nVol. 43, No. 5, Mathematical Programming in Honour of Ailsa Land. (May, 1992), pp. 469\u2013\n481.\n[13] G. Laporte, and F. Semet. Computational evaluation of a transformation procedure for the\nsymmetric generalized traveling salesman problem, INFOR 37 (1999) (2), pp. 114-120.\n[14] Y. N. Lien, E. Ma, and B. W.-S. Wah (1993). Transformation of the Generalized TravelingSalesman Problem into the Standard Traveling-Salesman Problem. Information Sciences 74,\npp. 177\u2013189.\n[15] C. E. Noon, and J. C. Bean (1993). An Efficient Transformation of the Generalized Traveling\nSalesman Problem. INFOR 31, pp. 39\u201344.\n[16] G. Reinelt. TSPLIB-A traveling salesman problem library. ORSA Journal on Computing. 3\n(1991), pp. 376-384, http://www.crpc.rice.edu/softlib/tsplib/.\n\n14\n\n\fTable 9: SD work time estimation.\nInstance name Real solution time, sec Estimation, sec\n45ts225\n45tsp225\n46pr226\n46gr229\n53gil262\n53pr264\n60pr299\n64lin318\n64linhp318\n80rd400\n84fl417\n87gr431\n88pr439\n89pcb442\n107si535\n113pa561\n115u574\n115rat575\n131p654\n134gr666\n145u724\n157rat783\n200dsj1000\n201pr1002\n207si1032\n212u1060\n217vm1084\n235pcb1173\n259d1291\n261rl1304\n265rl1323\n276nrw1379\n\n0.6\n0.5\n0.7\n0.8\n0.9\n1.2\n1.3\n1.8\n1.6\n3.5\n3.5\n3.7\n4.7\n5.5\n5.7\n6.7\n13.2\n11.1\n10.2\n14.0\n27.9\n23.6\n100.3\n54.9\n21.3\n88.8\n78.1\n107.9\n169.4\n140.4\n132.6\n111.5\n\n0.72\n0.72\n0.73\n0.76\n1.14\n1.17\n1.69\n2.04\n2.04\n4.05\n4.59\n5.07\n5.36\n5.47\n9.70\n11.18\n11.97\n12.04\n17.71\n18.70\n24.03\n30.40\n63.32\n63.70\n69.59\n75.41\n80.65\n102.19\n136.24\n140.40\n146.63\n166.05\n\n[17] M.W.P. Savelsbergh. Preprocessing and probing techniques for mixed integer programming\nproblems. ORSA Journal on Computing 6 (1994), pp. 445\u2013454.\n[18] J. Silberholz, B. Golden. The Generalized Traveling Salesman Problem: a new Genetic Algorithm approach. Extending the Horizons: Advances in Computing, Optimization, and Decision\nTechnologies (2007), pp. 165\u2013181.\n[19] L. V. Snyder, and M. S. Daskin. A random-key genetic algorithm for the generalized traveling\nsalesman problem. European Journal of Operational Research 174 (2006), pp. 38\u201353.\n\n15\n\n\f[20] M. F. Tasgetiren, P. N. Suganthan, and Q.-K. Pan. A discrete particle swarm optimization\nalgorithm for the generalized traveling salesman problem. GECCO '07: Proceedings of the 9th\nannual conference on Genetic and evolutionary computation, 2007, pp. 158\u2013167.\n[21] X. Zhao, J. Lin, H. Huang, and Z. Hao. Void Vertex Genetic Algorithm for ProductionDistribution Supply Chain GTSP Model. Journal of Information and Computing Science, Volume 1, Number 5, December 2006, pp. 259\u2013265.\n\n16\n\n\f"}