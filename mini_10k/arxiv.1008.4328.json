{"id": "http://arxiv.org/abs/1008.4328v1", "guidislink": true, "updated": "2010-08-25T18:07:40Z", "updated_parsed": [2010, 8, 25, 18, 7, 40, 2, 237, 0], "published": "2010-08-25T18:07:40Z", "published_parsed": [2010, 8, 25, 18, 7, 40, 2, 237, 0], "title": "Distributed solving through model splitting", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1008.3312%2C1008.2505%2C1008.2045%2C1008.0238%2C1008.1569%2C1008.1244%2C1008.4248%2C1008.4328%2C1008.3322%2C1008.0030%2C1008.1033%2C1008.1024%2C1008.1506%2C1008.4046%2C1008.3708%2C1008.0213%2C1008.0072%2C1008.1634%2C1008.4643%2C1008.1736%2C1008.2894%2C1008.3611%2C1008.2998%2C1008.3126%2C1008.2604%2C1008.2420%2C1008.2492%2C1008.2887%2C1008.4279%2C1008.4743%2C1008.0158%2C1008.0927%2C1008.5276%2C1008.0769%2C1008.3660%2C1008.4222%2C1008.4160%2C1008.0641%2C1008.4970%2C1008.4371%2C1008.5010%2C1008.5102%2C1008.4983%2C1008.1312%2C1008.0148%2C1008.1345%2C1008.0948%2C1008.3976%2C1008.0752%2C1008.3304%2C1008.1070%2C1008.5279%2C1008.4645%2C1008.0058%2C1008.0441%2C1008.5222%2C1008.0507%2C1008.1878%2C1008.3808%2C1008.4069%2C1008.1239%2C1008.3926%2C1008.1256%2C1008.0845%2C1008.4416%2C1008.1274%2C1008.0202%2C1008.5235%2C1008.1665%2C1008.1177%2C1008.1894%2C1008.0607%2C1008.4045%2C1008.3816%2C1008.4437%2C1008.3494%2C1008.3711%2C1008.1907%2C1008.0175%2C1008.3253%2C1008.4122%2C1008.4565%2C1008.0347%2C1008.3801%2C1008.2920%2C1008.1638%2C1008.1191%2C1008.3487%2C1008.1220%2C1008.1996%2C1008.4947%2C1008.5314%2C1008.4822%2C1008.2905%2C1008.1791%2C1008.4017%2C1008.0200%2C1008.4810%2C1008.4543%2C1008.4992%2C1008.1914&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Distributed solving through model splitting"}, "summary": "Constraint problems can be trivially solved in parallel by exploring\ndifferent branches of the search tree concurrently. Previous approaches have\nfocused on implementing this functionality in the solver, more or less\ntransparently to the user. We propose a new approach, which modifies the\nconstraint model of the problem. An existing model is split into new models\nwith added constraints that partition the search space. Optionally, additional\nconstraints are imposed that rule out the search already done. The advantages\nof our approach are that it can be implemented easily, computations can be\nstopped and restarted, moved to different machines and indeed solved on\nmachines which are not able to communicate with each other at all.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1008.3312%2C1008.2505%2C1008.2045%2C1008.0238%2C1008.1569%2C1008.1244%2C1008.4248%2C1008.4328%2C1008.3322%2C1008.0030%2C1008.1033%2C1008.1024%2C1008.1506%2C1008.4046%2C1008.3708%2C1008.0213%2C1008.0072%2C1008.1634%2C1008.4643%2C1008.1736%2C1008.2894%2C1008.3611%2C1008.2998%2C1008.3126%2C1008.2604%2C1008.2420%2C1008.2492%2C1008.2887%2C1008.4279%2C1008.4743%2C1008.0158%2C1008.0927%2C1008.5276%2C1008.0769%2C1008.3660%2C1008.4222%2C1008.4160%2C1008.0641%2C1008.4970%2C1008.4371%2C1008.5010%2C1008.5102%2C1008.4983%2C1008.1312%2C1008.0148%2C1008.1345%2C1008.0948%2C1008.3976%2C1008.0752%2C1008.3304%2C1008.1070%2C1008.5279%2C1008.4645%2C1008.0058%2C1008.0441%2C1008.5222%2C1008.0507%2C1008.1878%2C1008.3808%2C1008.4069%2C1008.1239%2C1008.3926%2C1008.1256%2C1008.0845%2C1008.4416%2C1008.1274%2C1008.0202%2C1008.5235%2C1008.1665%2C1008.1177%2C1008.1894%2C1008.0607%2C1008.4045%2C1008.3816%2C1008.4437%2C1008.3494%2C1008.3711%2C1008.1907%2C1008.0175%2C1008.3253%2C1008.4122%2C1008.4565%2C1008.0347%2C1008.3801%2C1008.2920%2C1008.1638%2C1008.1191%2C1008.3487%2C1008.1220%2C1008.1996%2C1008.4947%2C1008.5314%2C1008.4822%2C1008.2905%2C1008.1791%2C1008.4017%2C1008.0200%2C1008.4810%2C1008.4543%2C1008.4992%2C1008.1914&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Constraint problems can be trivially solved in parallel by exploring\ndifferent branches of the search tree concurrently. Previous approaches have\nfocused on implementing this functionality in the solver, more or less\ntransparently to the user. We propose a new approach, which modifies the\nconstraint model of the problem. An existing model is split into new models\nwith added constraints that partition the search space. Optionally, additional\nconstraints are imposed that rule out the search already done. The advantages\nof our approach are that it can be implemented easily, computations can be\nstopped and restarted, moved to different machines and indeed solved on\nmachines which are not able to communicate with each other at all."}, "authors": ["Lars Kotthoff", "Neil C. A. Moore"], "author_detail": {"name": "Neil C. A. Moore"}, "author": "Neil C. A. Moore", "links": [{"href": "http://arxiv.org/abs/1008.4328v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1008.4328v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1008.4328v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1008.4328v1", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "Distributed solving through model splitting\nLars Kotthoff and Neil C.A. Moore\n{larsko,ncam}@cs.st-andrews.ac.uk\n\narXiv:1008.4328v1 [cs.AI] 25 Aug 2010\n\nUniversity of St Andrews\n\nAbstract. Constraint problems can be trivially solved in parallel by\nexploring different branches of the search tree concurrently. Previous\napproaches have focused on implementing this functionality in the solver,\nmore or less transparently to the user. We propose a new approach,\nwhich modifies the constraint model of the problem. An existing model\nis split into new models with added constraints that partition the search\nspace. Optionally, additional constraints are imposed that rule out the\nsearch already done. The advantages of our approach are that it can be\nimplemented easily, computations can be stopped and restarted, moved\nto different machines and indeed solved on machines which are not able\nto communicate with each other at all.\n\n1\n\nIntroduction\n\nConstraint problems are typically solved by searching through the possible assignments of values to variables. After each such assignment, propagation can\nrule out possible future assignments based on past assignments and the constraints. This process builds a search tree that explores the space of possible\n(partial) solutions to the constraint problem.\nThere are two different ways to build up these search trees \u2013 n-way branching\nand 2-way branching. This refers to the number of new branches which are\nexplored after each node. In n-way branching, all the n possible assignments to\nthe next variable are branched on. In 2-way branching, there are two branches.\nThe left branch is of the form x = y where x is a variable and y is a value from\nits domain. The right branch is of the form x 6= y.\nThe more commonly used way is 2-way branching, implemented for example\nin the Minion constraint solver [5]1 . However, regardless of the way the branching is done, exploring the branches can be done concurrently. No information\nbetween the branches needs to be exchanged in order to find a solution to the\nproblem.\nWe exploit this fact by, given the model of a constraint problem, generating\nnew models which partition the remaining search space. These models can then\nbe solved independently. We furthermore represent the state of the search by\nadding additional constraints such that the splitting of the model can occur at\nany point during search. The new models can be resumed, taking advantage of\nboth the splitting of the search space and the search already performed.\n1\n\nhttp://minion.sf.net\n\n\f2\n\nBackground\n\nThe parallelisation of depth-first search has been the subject of much research\nin the past. The first papers on the subject study the distribution over various\nspecific hardware architectures and investigate how to achieve good load balancing [13, 7]. Distributed solving of constraint problems specifically was first\nexplored only a few years later [2].\nBacktracking search in a distributed setting has also been investigated by\nseveral authors [12, 15]. A special variant for distributed scenarios, asynchronous\nbacktracking, was proposed in [17]. Yokoo et al formalise the distributed constraint satisfaction problem and present algorithms for solving it [18].\nSchulte presents the architecture of a system that uses networked computers [16]. The focus of his approach is to provide a high-level and reusable design\nfor parallel search and achieve a good speedup compared to sequential solving\nrather than good resource utilisation. More recent papers have explored how to\ntransparently parallelise search without having to modify existing code [10].\nMost of the existing work is concerned with the problem of effectively distributing the workload such that every compute node is kept busy. The most\nprevalent technique used to achieve this is work stealing. The compute nodes\ncommunicate with each other and nodes which are idle request a part of the\nwork that a busy node is doing. Blumofe and Leiserson propose and discuss a\nwork stealing scheduler for multithreaded computations in [1]. Rolf and Kuchcinski investigate different algorithms for load balancing and work stealing in the\nspecific context of distributed constraint solving [14].\nSeveral frameworks for distributed constraint solving have been proposed\nand implemented, e.g. FRODO [11], DisChoco [3] and Disolver [6]. All of these\napproaches have in common that the systems to solve constraint problems are\nmodified or augmented to support distribution of parts of the problem across\nand communication between multiple compute nodes. The constraint model of\nthe problem remains unchanged however; no special constructs have to be used\nto take advantage of distributed solving. All parallelisation is handled in the\nrespective solver. This does not preclude the use of an entirely different model of\nthe problem to be solved for the distributed case in order to improve efficiency,\nbut in general these solvers are able to solve the same model both with a single\nexecutor and distributed across several executors.\nThe decomposition of constraint problems into subproblems which can be\nsolved independently has been proposed in [9], albeit in a different context. In\nthis work, we explore the use of this technique for parallelisation. A similar\napproach was taken in [14], but requires parallelisation support in the solver.\n\n3\n\nModel splitting\n\nWe now describe our new approach to the distributed solving of constraint problems which modifies the constraint solver to modify the constraint model and\ndoes not require explicit parallelisation support in the solver.\n\n\fBefore splitting, the solver is stopped. As well as stopping, it is designed to\noutput restart nogoods for the problem in the solver's own input language [8].\nThese constraints, when added to the problem, will prevent the search space just\nexplored from being repeated in any split model2 .\nTo split the search space for an existing model, partition the domain for the\nvariable currently under consideration into n pieces of roughly equal size. Then\ncreate n new models and to each in turn add constraints ruling out n\u22121 partitions\nof that domain. Each one of these models restricts the possible assignments to\nthe current variable to one nth of its domain.\nAs an example, consider the case n = 2. If the variable under consideration is\nx and its domain is {1, 2, 3, 4}, we generate 2 new models. One of them has the\nconstraint x \u2264 2 added and the other one x \u2265 3. Thus, solving the first model\nwill try the values 1 and 2 for x, whereas the second model will try 3 and 4.\nThe main problem when splitting constraint problems into parts that can be\nsolved in parallel is that the size of the search space for each of the splits is impossible to predict reliably. This directly affects the effectiveness of the splitting\nhowever \u2013 if the search space is distributed unevenly, some of the workers will\nbe idle while the others do most of the work.\nWe address this problem by providing the ability to split a constraint model\nafter search has started. The approach is very similar to the one explained above.\nThe only difference is that in addition to the constraints that partition the search\nspace, we also add constraints that rule out the search space that has been\nexplored already.\nAssume for example that we are doing 2-way branching, the variable currently\nunder consideration is again x with domain {1, 2, 3, 4} and the branches that we\nhave taken to get to the point where we are are x 6= 1 and x 6= 2. The generated\nnew models will all have the constraints x 6= 1 and x 6= 2 to get to the point in\nthe search tree where we split the problem. Then we add constraints to partition\nthe search space based on the remaining values in the domain of x similar to the\nprevious example.\nUsing this technique, we can create new chunks of work whenever a worker\nbecomes idle by simply asking one of the busy workers to stop and generate\nsplit models. The search is then resumed from where it was stopped and the\nremaining search space is explored in parallel by the two workers. Note that\nthere is a runtime overhead involved with stopping and resuming search because\nthe constraints which enable resumption must be propagated and the solver\nneeds to explore a small number of search nodes to get to the point where it\nwas stopped before. There is also a memory overhead because the additional\nconstraints need to be stored.\nWe have implemented this approach in a development version of Minion,\nwhich we are planning to release to the public after further testing and verifi2\n\nThis same technique allows Minion to be paused and resumed: the nogoods are\nprovided when the solver is interrupted, and can be used to restart search, potentially\nusing a different solver, different search strategy or on a different machine.\n\n\fcation. Initial experiments showed that the overhead of stopping, splitting and\nresuming is minimal and not significant for large problems.\nIn practice, we run Minion for a specified amount of time, then stop, split\nand resume instead of splitting at the beginning and when workers become idle.\nThe algorithm is detailed in Figure 1. This creates an n-ary split tree of models\nfor n new models generated at each split. Initially, the potential for distribution\nis small but grows exponentially as more and more search is performed.\n\nInput : constraint problem X, allotted time Tmax and splitting factor n \u2265 2\nOutput: a solution to X or nothing if no solution has been found\nrun Minion with input X until termination or Tmax ;\nif solved?(X) then\nterminate workers;\nreturn solution;\nelse if search space exhausted? then\nreturn;\nelse\nX 0 \u2190 X with new constraints ruling out search already performed;\nsplit X 0 into n parts X10 , . . . , Xn0 ;\nfor i \u2190 1 to n do in parallel\ndistSolve(Xn0 , Tmax ,n);\nend\nend\nFig. 1. distSolve(X,Tmax ,n): Recursive procedure to find the first solution to a\nconstraint problem distributed across several workers.\n\n4\n\nComparison to existing approaches\n\nWe see the main advantage of our approach in not requiring any involved changes\nto the constraint solving system to support distributed solving; in particular\ncommunications between workers. Conventionally, distribution is achieved with\nthe aid of recomputation and cloning; established techniques used e.g. in [16].\nWe require two features of our solver: partitioning using constraints, and ability to output restart nogoods. Our system makes use of cloning, which we call\n\"splitting\" and implement by means of nogoods added to the constraint model\nin order to partition the domain of a variable. However, where other systems use\nrecompution, our system uses restart nogoods. In a system based on recomputation the clone begins at specific search path, e.g. stolen from another worker;\nwith restart nogoods notionally multiple search paths are provided and the solver\nmay explore these in any way it wishes, not necessarily one after the other. It is\n\n\fmerely a convenient and compact way of encoding the situation where a solver\nis relinquishing all its remaining work.\nContemporary constraint solvers make it easy to change or amend the search\nprocedure to support distribution across several executors, but even then changes\nto the constraint solving system are required. While an initial implementation\nof distributed search can be done relatively quickly, handling failure properly\nand supporting things like nodes being added and removed dynamically requires\nsignificantly more effort. Our approach separates this part completely from the\nconstraint solving system.\nThere are several advantages to implementing distributed solving the way\ngiven in Figure 1. First, by creating regular \"snapshots\" of the search done, the\nresilience against failure increases. Every time we stop, split and resume, the\nmodified models are saved. As they contain constraints that rule out the search\nalready done, we only lose the work done after that point if a worker fails. This\nmeans that the maximum amount of work we lose in case of a total failure of all\nworkers is the allotted time Tmax times the number of workers |w|.\nThe fact that the modified models can be stored can also be exploited to\nmove the solving process to a different set of workers after it has been started\nwithout losing any work. It furthermore means that we require no communication\nbetween the individual workers solving the problem; they only need to be able\nto receive the problem to solve and send the solution or split models back.\nAnother advantage is that small problems which Minion can solve within\nthe allotted time are not split and no distribution overhead is incurred. Solving\nproceeds as it would in a standard, non-distributed fashion.\nOur approach is particularly suitable for use with existing grid-computing\nsoftware or workload management systems such as Condor3 . Every time new\nmodels are generated, they are submitted to the system which queues them\nand allocates a worker as soon as one becomes available. By leveraging existing\nsoftware to perform this task, a huge amount of development time is saved and\nerrors are avoided. For large problems, the number of queued jobs will usually\nexceed the number of workers, ensuring good resource utilisation.\nThe management system to monitor the search, queue split models and terminate the workers if a solution has been found can be implemented efficiently in\njust a few lines of code. We have written a Ruby script that performs this task in\nlittle more than an hour. Obviously there is potential for trying different search\nstrategies for different branches or modifying other search parameters in order to\nimprove efficiency. With the appropriate modifications, the management system\ncould adapt the search procedure specifically for individual parts of the search\ntree. We are planning to explore these possibilities in future work.\nA downside of the approach is that the number of models which can be\nsolved in parallel will be small to start with. This means that the utilisation of\nresources in the beginning will be suboptimal. Only as more and more search\nspace is explored and more and more split models are generated, the utilisation\nwill improve. This however can be mitigated by dynamically adapting the time\n3\n\nhttp://www.cs.wisc.edu/condor/\n\n\ffor which Minion is run before splitting the problem \u2013 in the beginning, we set it\nto a small value to quickly get many models that we can solve in parallel. Then\nwe gradually increase the allotted time as the resource utilisation improves.\nOur technique is intended to be used for very large problems which take a\nlong time (many hours, days or weeks) to solve. It is unlikely to be efficient\nfor problems that can be solved in minutes, but on the other hand there is no\nneed for distributed solving if the problem can be solved sequentially in a short\namount of time. Only large search spaces can be split in a way that many workers\nare kept busy without a high communication overhead.\n\n5\n\nDetailed example\n\nWe will now have a detailed look at how our approach works for a specific\nproblem. Consider the 4-queens problem. We want to place 4 queens on a 4 \u00d7 4\nchessboard such that no queen is attacking another queen. Queens can move\nalong rows, columns and diagonals. The constraints therefore have to forbid\nthat two or more queens are in the same row, the same column or on the same\ndiagonal. The constraint model in Figure 2 captures this problem.\nlanguage Dominion 0.1\nletting n = 4\ndim queens[n]: int\nfind queens[..]: int {1..n}\nsuch that\nalldifferent alldiff(queens[..])\ndiagonals1 [ not(eq1 eq(queens[i],\ni in {0..n-2}, j in {i+1..n-1}\ndiagonals2 [ not(eq2 eq(queens[i],\ni in {0..n-2}, j in {i+1..n-1}\n\nadd(queens[j], j-i))) |\n]\nadd(queens[j], i-j))) |\n]\n\nFig. 2. Model for the 4-queens problem in the Dominion language [4]. The model\ndescribes the n-queens problem in general and is specialised for 4-queens in the\nsecond line.\nWe assume variable ordering queens0 , queens1 , queens2 , queens3 , ascending\nvalue ordering from 1 to 4 and n-way branching. The search tree for a simple\nbacktracking algorithm is depicted in Figure 3. Even for a very small problem\nlike this, there is significant potential for distributed solving.\nWe now start solving the problem until we reach the assignment queens0 = 2.\nThen we stop. The constraint we need to add to resume the search at the same\npoint is\nresume not(innerresume eq(queens[0], 1))\n\n\fqueens0\n\nqueens1\n\nqueens2\n\n1\n\n1\n\n2\n\n2\n\n3\n\n1\n\n2\n\n4\n\n3\n\n4\n\nqueens3\n\n1\n\n1\n\n2\n\n1\n\n2\n\n3\n\n3\n\n4\n\n2\n\n3\n\n4\n\n4\n\n1\n\n1\n\n2\n\n3\n\nFig. 3. First solution search tree for 4-queens. The triangles depict subtrees\nwhich are not explored because the partial assignment so far cannot be part of\na solution. The bold, rightmost node is where the solution is found. The levels\nof the tree show assignments to the variables shown on the left.\n(note that resume and innerresume are simply identifiers given to the specific\nconstraints as required in the Dominion language [4]).\nLet us assume a splitting factor of 2. We add the constraints to split the\nremaining search space as follows. The variable currently under consideration is\nqueens1 , its domain is {1, 2, 3, 4} and therefore the constraints are\nleft leq(queens[1], 2)\n\nand\n\nright leq(3, queens[1]).\n\nThe search is restarted with two workers, each exploring separate branches\nof the remaining search space. The first worker finds no solutions in its part of\nthe search space, terminates and returns. The second worker finds a solution and\nreturns it. Search terminates and no further splitting is performed.\n\n6\n\nConclusions and future work\n\nWe have proposed and detailed a novel approach for distributing constraint\nproblems across multiple computers. Instead of modifying the solver to support\ndistributed operation, we only require some simple and generic modifications\nthat post additional constraints to the model.\nThe main advantages of our approach are that it does not require networked\nmachines, is resilient against failure and can be implemented easily in constraint\nsolvers which are aware of the state of the search.\nThe main drawback of this paper is that we do not have performed a systematic experimental evaluation of our approach yet. In the future, we would\nlike to evaluate it in terms of solving speedup and resource utilisation on large,\nreal-world problems. Furthermore, we would like to investigate finding all solutions to a constraint problem and solving constrained optimisation problems in\na distributed manner.\n\n\fAdapting the search procedure and parameters dynamically during search is\nanother promising area for future work. The solving process could be tailored to\nthe characteristics of parts of the search space to improve efficiency.\nAnother direction for future work is to support a higher level of abstraction\nfor decomposing problems into subproblems. This would be necessary to support\nproblems which cannot be decomposed by simply adding constraints that split\nthe domain of a variable.\n\nAcknowledgements\nThe authors thank Chris Jefferson for help with implementing the model splitting in Minion and the anonymous reviewers for their feedback. Lars Kotthoff\nis supported by a SICSA studentship.\n\nReferences\n1. Blumofe, R.D., Leiserson, C.E.: Scheduling multithreaded computations by work\nstealing. J. ACM 46(5), 720\u2013748 (1999)\n2. Collin, Z., Dechter, R., Katz, S.: On the feasibility of distributed constraint satisfaction. In: IJCAI. pp. 318\u2013324 (1991)\n3. Ezzahir, R., Bessiere, C., Belaissaoui, M., Bouyakhf, H., Mohammed, U., Agdal,\nV.: DisChoco: A platform for distributed constraint programming (2007)\n4. Gent, I.P., Jefferson, C., Kotthoff, L., Miguel, I., Nightingale, P.: The DOMINION\ninput language version 0.1. CIRCA preprint 2009/21, University of St Andrews\n(2009), http://www-circa.mcs.st-and.ac.uk/Preprints/InLangSpec.pdf\n5. Gent, I.P., Jefferson, C., Miguel, I.: MINION: a fast, scalable, constraint solver. In:\nECAI. pp. 98\u2013102 (2006)\n6. Hamadi, Y.: Disolver 3.0: the Distributed Constraint Solver version 3.0 (2007)\n7. Kumar, V., Rao, V.N.: Parallel depth first search. Part II. analysis. Int. J. Parallel\nProgram. 16(6), 501\u2013519 (1987)\n8. Lecoutre, C., Sais, L., Tabary, S., Vidal, V.: Nogood recording from restarts. In:\nIJCAI'07: Proceedings of the 20th international joint conference on Artifical intelligence. pp. 131\u2013136. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA\n(2007)\n9. Michel, L., Hentenryck, P.V.: A decomposition-based implementation of search\nstrategies. ACM Trans. Comput. Logic 5(2), 351\u2013383 (2004)\n10. Michel, L., See, A., Hentenryck, P.V.: Parallelizing constraint programs transparently. In: CP. pp. 514\u2013528 (2007)\n11. Petcu, A.: FRODO: a FRamework for Open/Distributed constraint optimization.\nTechnical report no. 2006/001, Swiss Federal Institute of Technology (EPFL)\n(2006), http://liawww.epfl.ch/frodo/\n12. Rao, V.N., Kumar, V.: On the efficiency of parallel backtracking. IEEE Trans.\nParallel Distrib. Syst. 4(4), 427\u2013437 (1993)\n13. Rao, V.N., Kumar, V.: Parallel depth first search. Part I. implementation. Int. J.\nParallel Program. 16(6), 479\u2013499 (1987)\n14. Rolf, C.C., Kuchcinski, K.: Load-balancing methods for parallel and distributed\nconstraint solving. In: CLUSTER. pp. 304\u2013309 (2008)\n\n\f15. Sanders, P.: Better algorithms for parallel backtracking. In: Workshop on Algorithms for Irregularly Structured Problems. pp. 333\u2013347 (1995)\n16. Schulte, C.: Parallel search made simple. In: Proceedings of TRICS. pp. 41\u201357\n(2000)\n17. Yokoo, M., Durfee, E.H., Ishida, T., Kuwabara, K.: Distributed constraint satisfaction for formalizing distributed problem solving. In: 12th IEEE International\nConference on Distributed Computing Systems. pp. 614\u2013621 (1992)\n18. Yokoo, M., Durfee, E.H., Ishida, T., Kuwabara, K.: The distributed constraint\nsatisfaction problem: Formalization and algorithms. IEEE Trans. on Knowl. and\nData Eng. 10(5), 673\u2013685 (1998)\n\n\f"}