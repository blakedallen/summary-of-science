{"id": "http://arxiv.org/abs/quant-ph/0507174v1", "guidislink": true, "updated": "2005-07-18T21:29:44Z", "updated_parsed": [2005, 7, 18, 21, 29, 44, 0, 199, 0], "published": "2005-07-18T21:29:44Z", "published_parsed": [2005, 7, 18, 21, 29, 44, 0, 199, 0], "title": "Quantum Error Correction and Fault-Tolerance", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0507076%2Cquant-ph%2F0507025%2Cquant-ph%2F0507263%2Cquant-ph%2F0507212%2Cquant-ph%2F0507209%2Cquant-ph%2F0507052%2Cquant-ph%2F0507004%2Cquant-ph%2F0507276%2Cquant-ph%2F0507145%2Cquant-ph%2F0507141%2Cquant-ph%2F0507020%2Cquant-ph%2F0507055%2Cquant-ph%2F0507144%2Cquant-ph%2F0507065%2Cquant-ph%2F0507250%2Cquant-ph%2F0507151%2Cquant-ph%2F0507172%2Cquant-ph%2F0507266%2Cquant-ph%2F0507228%2Cquant-ph%2F0507021%2Cquant-ph%2F0507131%2Cquant-ph%2F0507135%2Cquant-ph%2F0507067%2Cquant-ph%2F0507110%2Cquant-ph%2F0507253%2Cquant-ph%2F0507031%2Cquant-ph%2F0507125%2Cquant-ph%2F0507217%2Cquant-ph%2F0507216%2Cquant-ph%2F0507042%2Cquant-ph%2F0507208%2Cquant-ph%2F0507086%2Cquant-ph%2F0507239%2Cquant-ph%2F0507236%2Cquant-ph%2F0507221%2Cquant-ph%2F0507165%2Cquant-ph%2F0507124%2Cquant-ph%2F0507148%2Cquant-ph%2F0507214%2Cquant-ph%2F0507094%2Cquant-ph%2F0507109%2Cquant-ph%2F0507174%2Cquant-ph%2F0507245%2Cquant-ph%2F0507062%2Cquant-ph%2F0507188%2Cquant-ph%2F0507074%2Cquant-ph%2F0507162%2Cquant-ph%2F0507230%2Cquant-ph%2F0507069%2Cquant-ph%2F0507002%2Cquant-ph%2F0507246%2Cquant-ph%2F0507005%2Cquant-ph%2F0507232%2Cquant-ph%2F0507167%2Cquant-ph%2F0507278%2Cquant-ph%2F0507237%2Cquant-ph%2F0507100%2Cquant-ph%2F0507084%2Cquant-ph%2F0507090%2Cquant-ph%2F0507123%2Cquant-ph%2F0507050%2Cquant-ph%2F0507120%2Cquant-ph%2F0507060%2Cquant-ph%2F0507183%2Cquant-ph%2F0507130%2Cquant-ph%2F0507269%2Cquant-ph%2F0507104%2Cquant-ph%2F0507229%2Cquant-ph%2F0507257%2Cquant-ph%2F0507121%2Cquant-ph%2F0507155%2Cquant-ph%2F0507138%2Cquant-ph%2F0507077%2Cquant-ph%2F0507219%2Cquant-ph%2F0507166%2Cquant-ph%2F0507173%2Cquant-ph%2F0507132%2Cquant-ph%2F0507116%2Cquant-ph%2F0507080%2Cquant-ph%2F0507242%2Cquant-ph%2F0507122%2Cquant-ph%2F0507078%2Cquant-ph%2F0507018%2Cquant-ph%2F0507056%2Cquant-ph%2F0507244%2Cquant-ph%2F0507241%2Cquant-ph%2F0507243%2Cquant-ph%2F0507053%2Cquant-ph%2F0507098%2Cquant-ph%2F0507247%2Cquant-ph%2F0507103%2Cquant-ph%2F0507111%2Cquant-ph%2F0507274%2Cquant-ph%2F0507207%2Cquant-ph%2F0507096%2Cquant-ph%2F0507101%2Cquant-ph%2F0507119%2Cquant-ph%2F0507180%2Cquant-ph%2F0507115%2Cquant-ph%2F0507254%2Cquant-ph%2F0507063&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Quantum Error Correction and Fault-Tolerance"}, "summary": "I give an overview of the basic concepts behind quantum error correction and\nquantum fault tolerance. This includes the quantum error correction conditions,\nstabilizer codes, CSS codes, transversal gates, fault-tolerant error\ncorrection, and the threshold theorem.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0507076%2Cquant-ph%2F0507025%2Cquant-ph%2F0507263%2Cquant-ph%2F0507212%2Cquant-ph%2F0507209%2Cquant-ph%2F0507052%2Cquant-ph%2F0507004%2Cquant-ph%2F0507276%2Cquant-ph%2F0507145%2Cquant-ph%2F0507141%2Cquant-ph%2F0507020%2Cquant-ph%2F0507055%2Cquant-ph%2F0507144%2Cquant-ph%2F0507065%2Cquant-ph%2F0507250%2Cquant-ph%2F0507151%2Cquant-ph%2F0507172%2Cquant-ph%2F0507266%2Cquant-ph%2F0507228%2Cquant-ph%2F0507021%2Cquant-ph%2F0507131%2Cquant-ph%2F0507135%2Cquant-ph%2F0507067%2Cquant-ph%2F0507110%2Cquant-ph%2F0507253%2Cquant-ph%2F0507031%2Cquant-ph%2F0507125%2Cquant-ph%2F0507217%2Cquant-ph%2F0507216%2Cquant-ph%2F0507042%2Cquant-ph%2F0507208%2Cquant-ph%2F0507086%2Cquant-ph%2F0507239%2Cquant-ph%2F0507236%2Cquant-ph%2F0507221%2Cquant-ph%2F0507165%2Cquant-ph%2F0507124%2Cquant-ph%2F0507148%2Cquant-ph%2F0507214%2Cquant-ph%2F0507094%2Cquant-ph%2F0507109%2Cquant-ph%2F0507174%2Cquant-ph%2F0507245%2Cquant-ph%2F0507062%2Cquant-ph%2F0507188%2Cquant-ph%2F0507074%2Cquant-ph%2F0507162%2Cquant-ph%2F0507230%2Cquant-ph%2F0507069%2Cquant-ph%2F0507002%2Cquant-ph%2F0507246%2Cquant-ph%2F0507005%2Cquant-ph%2F0507232%2Cquant-ph%2F0507167%2Cquant-ph%2F0507278%2Cquant-ph%2F0507237%2Cquant-ph%2F0507100%2Cquant-ph%2F0507084%2Cquant-ph%2F0507090%2Cquant-ph%2F0507123%2Cquant-ph%2F0507050%2Cquant-ph%2F0507120%2Cquant-ph%2F0507060%2Cquant-ph%2F0507183%2Cquant-ph%2F0507130%2Cquant-ph%2F0507269%2Cquant-ph%2F0507104%2Cquant-ph%2F0507229%2Cquant-ph%2F0507257%2Cquant-ph%2F0507121%2Cquant-ph%2F0507155%2Cquant-ph%2F0507138%2Cquant-ph%2F0507077%2Cquant-ph%2F0507219%2Cquant-ph%2F0507166%2Cquant-ph%2F0507173%2Cquant-ph%2F0507132%2Cquant-ph%2F0507116%2Cquant-ph%2F0507080%2Cquant-ph%2F0507242%2Cquant-ph%2F0507122%2Cquant-ph%2F0507078%2Cquant-ph%2F0507018%2Cquant-ph%2F0507056%2Cquant-ph%2F0507244%2Cquant-ph%2F0507241%2Cquant-ph%2F0507243%2Cquant-ph%2F0507053%2Cquant-ph%2F0507098%2Cquant-ph%2F0507247%2Cquant-ph%2F0507103%2Cquant-ph%2F0507111%2Cquant-ph%2F0507274%2Cquant-ph%2F0507207%2Cquant-ph%2F0507096%2Cquant-ph%2F0507101%2Cquant-ph%2F0507119%2Cquant-ph%2F0507180%2Cquant-ph%2F0507115%2Cquant-ph%2F0507254%2Cquant-ph%2F0507063&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "I give an overview of the basic concepts behind quantum error correction and\nquantum fault tolerance. This includes the quantum error correction conditions,\nstabilizer codes, CSS codes, transversal gates, fault-tolerant error\ncorrection, and the threshold theorem."}, "authors": ["Daniel Gottesman"], "author_detail": {"name": "Daniel Gottesman"}, "author": "Daniel Gottesman", "arxiv_comment": "8 pages, to appear in Encyclopaedia of Mathematical Physics", "links": [{"href": "http://arxiv.org/abs/quant-ph/0507174v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/quant-ph/0507174v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/quant-ph/0507174v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/quant-ph/0507174v1", "journal_reference": "Encyclopedia of Mathematical Physics, eds. J.-P. Francoise, G. L.\n  Naber and S. T. Tsou, Oxford: Elsevier, 2006 (ISBN 978-0-1251-2666-3), vol.\n  4, pp. 196-201", "doi": null, "fulltext": "Quantum Error Correction and Fault-Tolerance\n\narXiv:quant-ph/0507174v1 18 Jul 2005\n\nDaniel Gottesman\n\nAbstract\n\nrors E = {Ea } iff \u2203R s.t. R is a quantum operation\nand (R \u25e6 Ea )(|\u03c8i) = |\u03c8i for all Ea \u2208 E, |\u03c8i \u2208 C.\n\nI give an overview of the basic concepts behind quantum error correction and quantum fault tolerance.\nThis includes the quantum error correction conditions, stabilizer codes, CSS codes, transversal gates,\nfault-tolerant error correction, and the threshold theorem.\n\n1\n\nR is called the recovery or decoding operation and\nserves to actually perform the correction of the state.\nThe decoder is sometimes also taken to map Hn into\nan unencoded Hilbert space Hlog K isomorphic to C.\nThis should be distinguished from the encoding operation which maps Hlog K into Hn , determining the\nimbedding of C. The computational complexity of\nthe encoder is frequently a great deal lower than that\nof the decoder. In particular, the task of determining what error has occurred can be computationally\ndifficult (NP-hard, in fact), and designing codes with\nefficient decoding algorithms is an important task in\nquantum error correction, as in classical error correction.\nThis article will cover only binary quantum codes,\nbuilt with qubits as registers, but all of the techniques discussed here can be generalized to higherdimensional registers, or qudits.\nTo determine whether a given subspace is able to\ncorrect a given set of errors, we can apply the quantum error-correction conditions [2, 7]:\n\nQuantum Error Correction\n\nBuilding a quantum computer or a quantum communications device in the real world means having to\ndeal with errors. Any qubit stored unprotected or one\ntransmitted through a communications channel will\ninevitably come out at least slightly changed. The\ntheory of quantum error-correcting codes has been\ndeveloped to counteract noise introduced in this way.\nBy adding extra qubits and carefully encoding the\nquantum state we wish to protect, a quantum system can be insulated to great extent against errors.\nTo build a quantum computer, we face an even\nmore daunting task: If our quantum gates are imperfect, everything we do will add to the error. The\ntheory of fault-tolerant quantum computation tells\nus how to perform operations on states encoded in a\nquantum error-correcting code without compromising the code's ability to protect against errors.\nIn general, a quantum error-correcting code is a\nsubspace of a Hilbert space designed so that any of a\nset of possible errors can be corrected by an appropriate quantum operation. Specifically:\n\nTheorem 1 A QECC C corrects the set of errors E\niff\n(1)\nh\u03c8i |Ea\u2020 Eb |\u03c8j i = Cab \u03b4ij ,\nwhere Ea , Eb \u2208 E and {|\u03c8i i} form an orthonormal\nbasis for C.\n\nThe salient point in these error-correction conditions is that the matrix element Cab does not depend\non the encoded basis states i and j, which roughly\nDefinition 1 Let Hn be a 2n -dimensional Hilbert speaking indicates that neither the environment nor\nspace (n qubits), and let C be a K-dimensional sub- the decoding operation learns any information about\nspace of Hn . Then C is an ((n, K)) (binary) quantum the encoded state. We can imagine the various possierror-correcting code (QECC) correcting the set of er- ble errors taking the subspace C into other subspaces\n1\n\n\fof Hn , and we want those subspaces to be isomorphic\nto C, and to be distinguishable from each other by an\nappropriate measurement. For instance, if Cab = \u03b4ab ,\nthen the various erroneous subspaces are orthogonal\nto each other.\nBecause of the linearity of quantum mechanics, we\ncan always take the set of errors E to be a linear\nspace: If a QECC corrects Ea and Eb , it will also correct \u03b1Ea +\u03b2Eb using the same recovery operation. In\naddition, if we write any superoperator S in\nPterms of\nits operator-sum representation S(\u03c1) 7\u2192\nAk \u03c1A\u2020k ,\na QECC that corrects the set of errors {Ak } automatically corrects S as well. Thus, it is sufficient in\ngeneral to check that the error-correction conditions\nhold for a basis of errors.\nFrequently, we are interested in codes that correct\nany error affecting t or fewer physical qubits. In that\ncase, let us consider tensor products of the Pauli matrices\n\u0012\n\u0013\n\u0012\n\u0013\n1 0\n0 1\nI=\n,\nX=\n,\n0 1\n1 0\n\u0012\n\u0013\n\u0012\n\u0013\n0 \u2212i\n1 0\nY =\n, Z=\n.\n(2)\ni 0\n0 \u22121\n\nfails.\nWe use the notation ((n, K, d)) to refer to an ((n, K))\nQECC with distance d. Note that for P, Q \u2208 Pn ,\nwt(P Q) \u2264 wt(P ) + wt(Q). Then by comparing\nthe definition of distance with the quantum errorcorrection conditions, we immediately see that a\nQECC corrects t general errors iff its distance d > 2t.\nIf we are instead interested in erasure errors, when\nthe location of the error is known but not its precise\nnature, a distance d code corrects d\u22121 erasure errors.\nIf we only wish to detect errors, a distance d code can\ndetect errors on up to d \u2212 1 qubits.\nOne of the central problems in the theory of quantum error correction is to find codes which maximize\nthe ratios (log K)/n and d/n, so they can encode as\nmany qubits as possible and correct as many errors\nas possible. Conversely, we are also interested in the\nproblem of setting upper bounds on achievable values of (log K)/n and d/n. The quantum Singleton\nbound (or Knill-Laflamme bound [7]) states that any\n((n, K, d)) QECC must satisfy\nn \u2212 log K \u2265 2d \u2212 2.\n\nDefine the Pauli group Pn as the group consisting of\ntensor products of I, X, Y , and Z on n qubits, with\nan overall phase of \u00b11 or \u00b1i. The weight wt(P ) of\na Pauli operator P \u2208 Pn is the number of qubits on\nwhich it acts as X, Y , or Z (i.e., not as the identity).\nThen the Pauli operators of weight t or less form a\nbasis for the set of all errors acting on t or fewer\nqubits, so a QECC which corrects these Pauli operators corrects all errors acting on up to t qubits. If\nwe have a channel which causes errors independently\nwith probability O(\u01eb) on each qubit in the QECC,\nthen the code will allow us to decode a correct state\nexcept with probability O(\u01ebt+1 ), which is the probability of having more than t errors. We get a similar\nresult in the case where the noise is a general quantum operation on each qubit which differs from the\nidentity by something of size O(\u01eb).\n\n(4)\n\nWe can set a lower bound on the existence of QECCs\nusing the quantum Gilbert-Varshamov bound, which\nstates that, for large n, an ((n, 2k , d)) QECC exists\nprovided that\nk/n \u2264 1 \u2212 (d/n) log 3 \u2212 h(d/n),\n\n(5)\n\nwhere h(x) = \u2212x log x\u2212(1\u2212x) log(1\u2212x) is the binary\nHamming entropy. Note that the Gilbert-Varshamov\nbound simply states that codes at least this good\nexist; it does not suggest that better codes cannot\nexist.\n\n2\n\nStabilizer Codes\n\nIn order to better manipulate and discover quantum error-correcting codes, it is helpful to have a\nDefinition 2 The distance d of an ((n, K)) QECC\nmore detailed mathematical structure to work with.\nis the smallest weight of a nontrivial Pauli operator\nThe most widely-used structure gives a class of codes\nE \u2208 Pn s.t. the equation\nknown as stabilizer codes [3, 5]. They are less general\nh\u03c8i |E|\u03c8j i = C(E)\u03b4ij\n(3) than arbitrary quantum codes, but have a number of\n2\n\n\fuseful properties that make them easier to work with fact no need to detect it, since all codewords remain\nfixed under P , making it equivalent to the identity\nthan the general QECC.\noperation. A distance d stabilizer code which has\nDefinition 3 Let S \u2282 Pn be an Abelian subgroup of nontrivial P \u2208 S with wt(P ) < d is called degenerthe Pauli group that does not contain \u22121 or \u00b1i, and ate, whereas one which does not is non-degenerate.\nlet C(S) = {|\u03c8i s.t. P |\u03c8i = |\u03c8i \u2200P \u2208 S}. Then The phenomenon of degeneracy has no analogue for\nC(S) is a stabilizer code and S is its stabilizer.\nclassical error correcting codes, and makes the study\nof quantum codes substantially more difficult than\nBecause of the simple structure of the Pauli group, the study of classical error correction. For instance,\nany Abelian subgroup has order 2n\u2212k for some k and a standard bound on classical error correction is the\ncan easily be specified by giving a set of n \u2212 k com- Hamming bound (or sphere-packing bound), but the\nmuting generators.\nanalogous quantum Hamming bound\nThe codewords of the QECC are by definition in\nthe +1-eigenspace of all elements of the stabilizer,\nk/n \u2264 1 \u2212 (t/n) log 3 \u2212 h(t/n)\n(7)\nbut an error E acting on a codeword will move the\nstate into the \u22121-eigenspace of any stabilizer element for [[n, k, 2t+1]] codes (when n is large) is only known\nM which anticommutes with E:\nto apply to non-degenerate quantum codes (though\nin fact we do not know of any degenerate QECCs\nthat violate the quantum Hamming bound).\nAn example of a stabilizer code is the 5-qubit code,\nThus, measuring the eigenvalues of the generators of\na\n[[5,\n1, 3]] code whose stabilizer can be generated by\nS tells us information about the error that has occurred. The set of such eigenvalues can be repreX \u2297 Z \u2297 Z \u2297 X \u2297 I,\nsented as an (n\u2212k)-dimensional binary vector known\nas the error syndrome. Note that the error syndrome\nI \u2297 X \u2297 Z \u2297 Z \u2297 X,\ndoes not tell us anything about the encoded state,\nX \u2297 I \u2297 X \u2297 Z \u2297 Z,\nonly about the error that has occurred.\nZ \u2297 X \u2297 I \u2297 X \u2297 Z.\nM (E|\u03c8i) = \u2212EM |\u03c8i = \u2212E|\u03c8i.\n\n(6)\n\nTheorem 2 Let S be a stabilizer with n \u2212 k generators, and let S \u22a5 = {E \u2208 Pn s.t. [E, M ] = 0 \u2200M \u2208 The 5-qubit code is a non-degenerate code, and is\nS}. Then S encodes k qubits and has distance d, the smallest possible QECC which corrects 1 error\nwhere d is the smallest weight of an operator in (as one can see from the quantum Singleton bound).\nIt is frequently useful to consider other representaS \u22a5 \\ S.\ntions of stabilizer codes. For instance, P \u2208 Pn can be\nWe use the notation [[n, k, d]] to a refer to such a represented by a pair of n-bit binary vectors (pX |pZ )\nstabilizer code. Note that the square brackets specify where pX is 1 for any location where P has an X or\nthat the code is a stabilizer code, and that the middle Y tensor factor and is 0 elsewhere, and pZ is 1 for any\nterm k refers to the number of encoded qubits, and location where P has a Y or Z tensor factor. Two\nnot the dimension 2k of the encoded subspace, as for Pauli operators P = (pX |pZ ) and Q = (qX |qZ ) comthe general QECC (whose dimension might not be a mute iff pX * qZ + pZ * qX = 0. Then the stabilizer for\npower of 2).\na code becomes a pair of (n \u2212 k) \u00d7 n binary matrices,\nS \u22a5 is the set of Pauli operators that commute with and most interesting properties can be determined\nall elements of the stabilizer. They would therefore by an appropriate linear algebra exercise. Another\nappear to be those errors which cannot be detected by useful representation is to map the single-qubit Pauli\nthe code. However, the theorem specifies the distance operators I, X, Y , Z to the finite field GF(4), which\nof the code by considering S \u22a5 \\ S. A Pauli operator sets up a connection between stabilizer codes and a\nP \u2208 S cannot be detected by the code, but there is in subset of classical codes on 4-dimensional registers.\n3\n\n\f3\n\nCSS codes\n\nd \u2265 min(d1 , d2 ).\nThe smallest distance-3 CSS code is the 7-qubit\ncode, a [[7, 1, 3]] QECC created from the classical\nHamming code (consisting of all sums of classical\nstrings 1111000, 1100110, 1010101, and 1111111).\nThe encoded |0i for this code consists of the superposition of all even-weight classical codewords and\nthe encoded |1i is the superposition of all odd-weight\nclassical codewords. The 7-qubit code is much studied because its properties make it particularly wellsuited to fault-tolerant quantum computation.\n\nCSS codes are a very useful class of stabilizer codes\ninvented by Calderbank and Shor, and by Steane [4,\n10]. The construction takes two binary classical linear codes and produces a quantum code, and can\ntherefore take advantage of much existing knowledge\nfrom classical coding theory. In addition, CSS codes\nhave some very useful properties which make them\nexcellent choices for fault-tolerant quantum computation.\nA classical [n, k, d] linear code (n physical bits, k\nlogical bits, classical distance d) can be defined in\nterms of an (n \u2212 k) \u00d7 n binary parity check matrix H\n- every classical codeword v must satisfy Hv = 0.\nEach row of the parity check matrix can be converted\ninto a Pauli operator by replacing each 0 with an I\noperator and each 1 with a Z operator. Then the stabilizer code generated by these operators is precisely\na quantum version of the classical error-correcting\ncode given by H. If the classical distance d = 2t + 1,\nthe quantum code can correct t bit flip (X) errors,\njust as could the classical code.\nIf we want to make a QECC that can also correct phase (Z) errors, we should choose two classical\ncodes C1 and C2 , with parity check matrices H1 and\nH2 . Let C1 be an [n, k1 , d1 ] code and let C2 be an\n[n, k2 , d2 ] code. We convert H1 into stabilizer generators as above, replacing each 0 with I and each 1\nwith Z. For H2 , we perform the same procedure, but\neach 1 is instead replaced by X. The code will be\nable to correct bit flip (X) errors as if it had a distance d1 and to correct phase (Z) errors as if it had\na distance d2 . Since these two operations are completely separate, it can also correct Y errors as both\na bit flip and a phase error. Thus, the distance of the\nquantum code is at least min(d1 , d2 ), but might be\nhigher because of the possibility of degeneracy.\nHowever, in order to have a stabilizer code at all,\nthe generators produced by the above procedure must\ncommute. Define the dual C \u22a5 of a classical code C\nas the set of vectors w s.t. w * v = 0 for all v \u2208 C.\nThen the Z generators from H1 will all commute with\nthe X generators from H2 iff C2\u22a5 \u2286 C1 (or equivalently, C1\u22a5 \u2286 C2 ). When this is true, C1 and C2\ndefine an [[n, k1 + k2 \u2212 n, d]] stabilizer code, where\n\n4\n\nFault-Tolerance\n\nGiven a QECC, we can attempt to supplement it\nwith protocols for performing fault-tolerant operations. The basic design principle of a fault-tolerant\nprotocol is that an error in a single location - either a faulty gate or noise on a quiescent qubit -\nshould not be able to alter more than a single qubit\nin each block of the quantum error-correcting code.\nIf this condition is satisfied, t separate single-qubit or\nsingle-gate failures are required for a distance 2t + 1\ncode to fail.\nParticular caution is necessary, as computational\ngates can cause errors to propagate from their original location onto qubits that were previously correct.\nIn general, a gate coupling pairs of qubits allows errors to spread in both directions across the coupling.\nThe solution is to use transversal gates whenever\npossible [9]. A transversal operation is one in which\nthe ith qubit in each block of a QECC interacts only\nwith the ith qubit of other blocks of the code or of\nspecial ancilla states. An operation consisting only\nof single-qubit gates is automatically transversal. A\ntransversal operation has the virtue that an error occurring on the 3rd qubit in a block, say, can only ever\npropagate to the 3rd qubit of other blocks of the code,\nno matter what other sequence of gates we perform\nbefore a complete error-correction procedure.\nIn the case of certain codes, such as the 7-qubit\ncode, a number of different gates can be performed\ntransversally. Unfortunately, it does not appear to be\npossible to perform universal quantum computations\nusing just transversal gates. We therefore have to re4\n\n\fsort to more complicated techniques. First we create\nspecial encoded ancilla states in a non-fault-tolerant\nway, but perform some sort of check on them (in addition to error correction) to make sure they are not\ntoo far off from the goal. Then we interact the ancilla with the encoded data qubits using gates from\nour stock of transversal gates and perform a faulttolerant measurement. Then we complete the operation with a further transversal gate which depends\non the outcome of the measurement.\n\na logical Hadamard, and the transversal \u03c0/4 rotation\nperforms a logical \u2212\u03c0/4 rotation. Thus, for the 7qubit code, the full logical Clifford group is accessible\nvia transversal operations.\nUnfortunately, the Clifford group by itself does not\nhave much computational power: it can be efficiently\nsimulated on a classical computer. We need to add\nsome additional gate outside the Clifford group to\nallow universal quantum computation; a single gate\nwill suffice, such as the single-qubit \u03c0/8 phase rotation diag(1, exp(i\u03c0/4)). Note that this gives us a\nfinite generating set of gates. However, by taking\n5 Fault-Tolerant Gates\nappropriate products, we get an infinite set of gates,\none that is dense in the unitary group U (2n ), allowing\nWe will focus on stabilizer codes. Universal fault- universal quantum computation.\ntolerance is known to be possible for any stabilizer\nThe following circuit performs a \u03c0/8 rotation,\ncode, but in most cases the more complicated type of given an ancilla state |\u03c8\u03c0/8 i = |0i + exp(i\u03c0/4)|1i:\nconstruction is needed for all but a few gates. The\nPauli group Pk , however, can be performed transverg \b\nsally on any stabilizer code. Indeed, the set S \u22a5 \\ S of\nH ?\nundetectable errors is a boon in this case, as it allows\ns\n|\u03c8\u03c0/8 i\nPX\nus to perform these gates. In particular, each coset\n\u22a5\nS /S corresponds to a different logical Pauli operator (with S itself corresponding to the identity). On\na stabilizer code, therefore, logical Pauli operations\nHere P is the \u03c0/4 phase rotation diag(1, i), and\ncan be performed via a transversal Pauli operation X is the bit flip. The product is in the Clifford\non the physical qubits.\ngroup, and is only performed if the measurement\nStabilizer codes have a special relationship to a outcome is 1. Therefore, given the ability to perfinite subgroup Cn of the unitary group U (2n ) fre- form fault-tolerant Clifford group operations, faultquently called the Clifford group. The Clifford group tolerant measurements, and to prepare the encoded\non n qubits is defined as the set of unitary opera- |\u03c8\u03c0/8 i state, we have universal fault-tolerant quantions which conjugate the Pauli group Pn into itself; tum computation. A slight generalization of the\nCn can be generated by the Hadamard transform, fault-tolerant measurement procedure below can be\nthe CNOT, and the single-qubit \u03c0/4 phase rotation used to fault-tolerantly verify the |\u03c8\u03c0/8 i state, which\ndiag(1, i). The set of stabilizer codes is exactly the is a +1 eigenstate of P X. Using this or another veriset of codes which can be created by a Clifford group fication procedure, we can check a non-fault-tolerant\nconstruction.\nencoder circuit using |0i ancilla states.\nSome stabilizer codes have interesting symmetries\nunder the action of certain Clifford group elements,\nFault-Tolerant Measurement\nand these symmetries result in transversal gate oper- 6\nations. A particularly useful fact is that a transversal\nand Error Correction\nCNOT gate (i.e., CNOT acting between the ith qubit\nof one block of the QECC and the ith qubit of a sec- Since all our gates are unreliable, including those used\nond block for all i) acts as a logical CNOT gate on to correct errors, we will need some sort of faultthe encoded qubits for any CSS code. Furthermore, tolerant quantum error correction procedure. A numfor the 7-qubit code, transversal Hadamard performs ber of different techniques have been developed. All\n5\n\n\fdata block. Therefore, we must be careful and use\nsome sort of technique to verify the cat state, for instance by checking if random pairs of qubits are the\nsame. Also, note that a single phase error in the cat\nstate will cause the final measurement outcome to be\nwrong (even and odd switch places), so we should repeat the measurement procedure multiple times for\ngreater reliability.\nWe can then make a full fault-tolerant error correction procedure by performing the above measurement\ntechnique for each generator of the stabilizer. Each\nmeasurement gives us one bit of the error syndrome,\nwhich we then decipher classically to determine the\nactual error.\nMore sophisticated techniques for fault-tolerant error correction involve less interaction with the data\nbut at the cost of more complicated ancilla states.\nA procedure due to Steane uses (for CSS codes) one\nancilla in a logical |0i state of the same code and one\nancilla in a logical |0i + |1i state. A procedure due to\nKnill (for any stabilizer code) teleports the data qubit\nthrough an ancilla consisting of two blocks of the\nQECC containing an encoded Bell state |00i + |11i.\nBecause the ancillas in Steane and Knill error correction are more complicated than the cat state, it\nis especially important to verify the ancillas before\nusing them.\n\nof them share some basic features: they involve creation and verification of specialized ancilla states, and\nuse transversal gates which interact the data block\nwith the ancilla state.\nThe simplest method, due to Shor, is very general\nbut also requires the most overhead and is frequently\nthe most susceptible to noise. Note that the following procedure can be used to measure (non-faulttolerantly) the eigenvalue of any (possibly multiqubit) Pauli operator M : Produce an ancilla qubit\nin the state |+i = |0i + |1i. Perform a controlled-M\noperation from the ancilla to the state being measured. In the case where M is a multi-qubit Pauli\noperator, this can be broken down into a sequence of\ncontrolled-X, controlled-Y , and controlled-Z operations. Then measure the ancilla in the basis of |+i\nand |\u2212i = |0i \u2212 |1i. If the state is a +1 eigenvector\nof M , the ancilla will be |+i, and if the state is a \u22121\neigenvector, the ancilla will be |\u2212i.\nThe advantage of this procedure is that it measures\njust M and nothing more. The disadvantage is that\nit is not transversal, and thus not fault-tolerant. Instead of the unencoded |+i state, we must use a more\ncomplex ancilla state |00 . . . 0i + |11 . . . 1i known as a\n\"cat\" state. The cat state contains as many qubits as\nthe operator M to be measured, and we perform the\ncontrolled-X, -Y , or -Z operations transversally from\nthe appropriate qubits of the cat state to the appropriate qubits in the data block. Since, assuming the\ncat state is correct, all of its qubits are either |0i or\n|1i, the procedure either leaves the data state alone\nor performs M on it uniformly. A +1 eigenstate in\nthe data therefore leaves us with |00 . . . 0i + |11 . . . 1i\nin the ancilla and a \u22121 eigenstate leaves us with\n|00 . . . 0i\u2212|11 . . . 1i. In either case, the final state still\ntells us nothing about the data beyond the eigenvalue\nof M . If we perform a Hadamard transform and then\nmeasure each qubit in the ancilla, we get either a random even weight string (for eigenvalue +1) or an odd\nweight string (for eigenvalue \u22121).\nThe procedure is transversal, so an error on a single qubit in the initial cat state or in a single gate\nduring the interaction will only produce one error in\nthe data. However, the initial construction of the\ncat state is not fault-tolerant, so a single gate error then could eventually produce two errors in the\n\n7\n\nThe Threshold for\nFault-Tolerance\n\nIn an unencoded protocol, even one error can destroy\nthe computation, but a fully fault-tolerant protocol\nwill give the right answer unless multiple errors occur before they can be corrected. On the other hand,\nthe fault-tolerant protocol is larger, requiring more\nqubits and more time to do each operation, and therefore providing more opportunities for errors. If errors\noccur on the physical qubits independently at random\nwith probability p per gate or timestep, the faulttolerant protocol has probability of logical error for\na single logical gate or timestep at most Cp2 , where\nC is a constant that depends on the design of the\nfault-tolerant circuitry (assume the quantum error6\n\n\fcorrecting code has distance 3, as for the 7-qubit\ncode). When p < pt = 1/C, the fault-tolerance helps,\ndecreasing the logical error rate. pt is the threshold\nfor fault-tolerant quantum computation. If the error\nrate is higher than the threshold, the extra overhead\nmeans that errors will occur faster than they can be\nreliably corrected, and we are better off with an unencoded system.\n\nthe assumption of independent errors is at all necessary, and that can be considerably relaxed to allow short-range correlations and certain kinds of nonMarkovian environments. However, the effects of relaxing these assumptions on the threshold value and\noverhead requirements have not been well-studied.\n\nReferences\n\nTo further lower the logical error rate, we turn to a\nfamily of codes known as concatenated codes [1, 6, 8].\nGiven a codeword of a particular [[n, 1]] QECC, we\ncan take each physical qubit and again encode it using the same code, producing an [[n2 , 1]] QECC. We\ncould repeat this procedure to get an n3 -qubit code,\nand so forth. The fault-tolerant procedures concatenate as well, and after L levels of concatenation, the\nL\neffective logical error rate is pt (p/pt )2 (for a base\ncode correcting 1 error). Therefore, if p is below\nthe threshold pt , we can achieve an arbitrarily good\nerror rate \u01eb per logical gate or timestep using only\npoly(log \u01eb) resources, which is excellent theoretical\nscaling.\n\n[1] D. Aharonov and M. Ben-Or, \"Fault-tolerant\nquantum computation with constant error rate,\"\nquant-ph/9906129.\n[2] C. Bennett, D. DiVincenzo, J. Smolin, and\nW. Wootters, \"Mixed state entanglement and\nquantum error correction,\" Phys. Rev. A 54\n(1996), 3824\u20133851; quant-ph/9604024.\n[3] A. R. Calderbank, E. M. Rains, P. W. Shor, and\nN. J. A. Sloane, \"Quantum error correction via\ncodes over GF(4),\" IEEE Trans. Inform. Theory\n44 (1998), 1369\u20131387; quant-ph/9605005.\n\nUnfortunately, the practical requirements for this\nresult are not nearly so good. The best rigorous\nproofs of the threshold to date show that the threshold is at least 2 \u00d7 10\u22125 (meaning one error per 50, 000\noperations). Optimized simulations of fault-tolerant\nprotocols suggest the true threshold may be as high\nas 5%, but to tolerate this much error, existing protocols require enormous overhead, perhaps increasing\nthe number of gates and qubits by a factor of a million\nor more for typical computations. For lower physical\nerror rates, overhead requirements are more modest,\nparticularly if we only attempt to optimize for calculations of a given size, but are still larger than one\nwould like.\n\n[4] A. R. Calderbank and P. W. Shor, \"Good quantum error-correcting codes exist,\" Phys. Rev. A\n54 (1996), 1098\u20131105; quant-ph/9512032.\n[5] D. Gottesman, \"Class of quantum errorcorrecting codes saturating the quantum Hamming bound,\" Phys. Rev. A 54 (1996), 1862\u2013\n1868; quant-ph/9604038.\n[6] A. Y. Kitaev, \"Quantum error correction with\nimperfect gates,\" Quantum Communication,\nComputing, and Measurement (Proc. 3rd Int.\nConf. of Quantum Communication and Measurement) (Plenum Press, New York, 1997),\np. 181\u2013188.\n\nFurthermore, these calculations make a number\nof assumptions about the physical properties of the\ncomputer. The errors are assumed to be independent\nand uncorrelated between qubits except when a gate\nconnects them. It is assumed that measurements and\nclassical computations can be performed quickly and\nreliably, and that quantum gates can be performed\nbetween arbitrary pairs of qubits in the computer, irrespective of their physical proximity. Of these, only\n\n[7] E. Knill and R. Laflamme, \"A theory of quantum\nerror-correcting codes,\" Phys. Rev. A 55 (1997),\n900\u2013911; quant-ph/9604034.\n[8] E. Knill, R. Laflamme, and W. H. Zurek,\n\"Resilient quantum computation,\" Science 279\n(1998), 342\u2013345.\n7\n\n\f[9] P. W. Shor, \"Fault-tolerant quantum computation,\" Proc. 35th Ann. Symp. on Fundamentals\nof Computer Science (IEEE Press, Los Alamitos,\n1996), pp. 56\u201365; quant-ph/9605011.\n[10] A. M. Steane, \"Multiple particle interference and quantum error correction,\" Proc.\nRoy. Soc. London A 452 (1996), 2551\u20132577;\nquant-ph/9601029.\n\n8\n\n\f"}