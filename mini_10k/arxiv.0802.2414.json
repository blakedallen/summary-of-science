{"id": "http://arxiv.org/abs/0802.2414v1", "guidislink": true, "updated": "2008-02-18T04:12:18Z", "updated_parsed": [2008, 2, 18, 4, 12, 18, 0, 49, 0], "published": "2008-02-18T04:12:18Z", "published_parsed": [2008, 2, 18, 4, 12, 18, 0, 49, 0], "title": "Classical Enhancement of Quantum Error-Correcting Codes", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0802.4328%2C0802.2373%2C0802.2196%2C0802.2058%2C0802.4021%2C0802.3066%2C0802.0057%2C0802.4240%2C0802.1473%2C0802.2339%2C0802.0992%2C0802.1685%2C0802.2347%2C0802.1757%2C0802.1431%2C0802.2455%2C0802.1177%2C0802.3817%2C0802.2749%2C0802.4092%2C0802.3567%2C0802.3233%2C0802.1120%2C0802.3475%2C0802.1699%2C0802.0995%2C0802.0682%2C0802.3173%2C0802.3093%2C0802.0435%2C0802.0113%2C0802.2866%2C0802.2973%2C0802.3253%2C0802.1406%2C0802.4203%2C0802.0021%2C0802.3394%2C0802.2364%2C0802.0228%2C0802.1929%2C0802.2403%2C0802.3713%2C0802.1869%2C0802.2286%2C0802.3585%2C0802.0576%2C0802.1614%2C0802.2577%2C0802.1970%2C0802.2717%2C0802.1978%2C0802.0019%2C0802.0537%2C0802.1863%2C0802.3645%2C0802.2600%2C0802.0294%2C0802.2363%2C0802.1355%2C0802.1905%2C0802.3901%2C0802.2032%2C0802.1350%2C0802.3694%2C0802.3277%2C0802.3371%2C0802.2136%2C0802.2414%2C0802.1088%2C0802.1179%2C0802.3000%2C0802.0831%2C0802.2328%2C0802.4018%2C0802.1472%2C0802.2100%2C0802.0665%2C0802.3159%2C0802.3883%2C0802.4256%2C0802.1318%2C0802.0475%2C0802.1641%2C0802.3242%2C0802.1491%2C0802.4138%2C0802.1561%2C0802.2844%2C0802.2858%2C0802.0888%2C0802.2675%2C0802.0381%2C0802.2998%2C0802.0346%2C0802.2939%2C0802.0965%2C0802.4258%2C0802.3426%2C0802.0474%2C0802.2927&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Classical Enhancement of Quantum Error-Correcting Codes"}, "summary": "We present a general formalism for quantum error-correcting codes that encode\nboth classical and quantum information (the EACQ formalism). This formalism\nunifies the entanglement-assisted formalism and classical error correction, and\nincludes encoding, error correction, and decoding steps such that the encoded\nquantum and classical information can be correctly recovered by the receiver.\nWe formally define this kind of quantum code using both stabilizer and\nsymplectic language, and derive the appropriate error-correcting conditions. We\ngive several examples to demonstrate the construction of such codes.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0802.4328%2C0802.2373%2C0802.2196%2C0802.2058%2C0802.4021%2C0802.3066%2C0802.0057%2C0802.4240%2C0802.1473%2C0802.2339%2C0802.0992%2C0802.1685%2C0802.2347%2C0802.1757%2C0802.1431%2C0802.2455%2C0802.1177%2C0802.3817%2C0802.2749%2C0802.4092%2C0802.3567%2C0802.3233%2C0802.1120%2C0802.3475%2C0802.1699%2C0802.0995%2C0802.0682%2C0802.3173%2C0802.3093%2C0802.0435%2C0802.0113%2C0802.2866%2C0802.2973%2C0802.3253%2C0802.1406%2C0802.4203%2C0802.0021%2C0802.3394%2C0802.2364%2C0802.0228%2C0802.1929%2C0802.2403%2C0802.3713%2C0802.1869%2C0802.2286%2C0802.3585%2C0802.0576%2C0802.1614%2C0802.2577%2C0802.1970%2C0802.2717%2C0802.1978%2C0802.0019%2C0802.0537%2C0802.1863%2C0802.3645%2C0802.2600%2C0802.0294%2C0802.2363%2C0802.1355%2C0802.1905%2C0802.3901%2C0802.2032%2C0802.1350%2C0802.3694%2C0802.3277%2C0802.3371%2C0802.2136%2C0802.2414%2C0802.1088%2C0802.1179%2C0802.3000%2C0802.0831%2C0802.2328%2C0802.4018%2C0802.1472%2C0802.2100%2C0802.0665%2C0802.3159%2C0802.3883%2C0802.4256%2C0802.1318%2C0802.0475%2C0802.1641%2C0802.3242%2C0802.1491%2C0802.4138%2C0802.1561%2C0802.2844%2C0802.2858%2C0802.0888%2C0802.2675%2C0802.0381%2C0802.2998%2C0802.0346%2C0802.2939%2C0802.0965%2C0802.4258%2C0802.3426%2C0802.0474%2C0802.2927&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a general formalism for quantum error-correcting codes that encode\nboth classical and quantum information (the EACQ formalism). This formalism\nunifies the entanglement-assisted formalism and classical error correction, and\nincludes encoding, error correction, and decoding steps such that the encoded\nquantum and classical information can be correctly recovered by the receiver.\nWe formally define this kind of quantum code using both stabilizer and\nsymplectic language, and derive the appropriate error-correcting conditions. We\ngive several examples to demonstrate the construction of such codes."}, "authors": ["Isaac Kremsky", "Min-Hsiu Hsieh", "Todd A. Brun"], "author_detail": {"name": "Todd A. Brun"}, "author": "Todd A. Brun", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1103/PhysRevA.78.012341", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/0802.2414v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0802.2414v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "8 pages, submitted to PRA", "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0802.2414v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0802.2414v1", "journal_reference": "Phys. Rev. A 78, 012341 (2008)", "doi": "10.1103/PhysRevA.78.012341", "fulltext": "Classical Enhancement of Quantum Error-Correcting Codes\nIsaac Kremsky\nPhysics Department, University of Southern California, Los Angeles, CA 90089\n\nMin-Hsiu Hsieh\u2217 and Todd A. Brun\n\narXiv:0802.2414v1 [quant-ph] 18 Feb 2008\n\nMing Hsieh Electrical Engineering Department, University of Southern California, Los Angeles, CA 90089\n(Dated: November 2, 2018)\nWe present a general formalism for quantum error-correcting codes that encode both classical\nand quantum information (the EACQ formalism). This formalism unifies the entanglement-assisted\nformalism and classical error correction, and includes encoding, error correction, and decoding steps\nsuch that the encoded quantum and classical information can be correctly recovered by the receiver.\nWe formally define this kind of quantum code using both stabilizer and symplectic language, and\nderive the appropriate error-correcting conditions. We give several examples to demonstrate the\nconstruction of such codes.\nPACS numbers:\n\nI.\n\nINTRODUCTION\n\nSince Shor proposed the first quantum error correction\ncode (QECC) [21], research in this field has progressed\nrapidly. A broad theory of quantum error-correcting\ncodes was created with the stabilizer formalism and its\nsymplectic formulation [8, 11], that allow the systematic description of a large class of quantum error correction codes and their error-correcting properties. In this\nformulation, a QECC is defined to be a subspace fixed\nby a stabilizer group. At the same time, a construction\nof QECCs from classical error correction codes was proposed separately by Calderbank, Shor and Steane [9, 22],\nthe so-called CSS construction. Later this was generalized to give a stronger connection between quantum\ncodes and classical symplectic codes; however, it seemed\nthat this connection between quantum coding theory and\nclassical coding theory was not universal, since only certain symplectic codes possessed quantum equivalents.\nMore recent developments in quantum coding theory\nhave led to the development of the operator quantum error correction formalism (OQECC) [1, 2, 14, 15, 16, 19,\n20] and the entanglement-assisted quantum error correction formalism (EAQECC) [5, 6, 7]; moreover, it is possible to produce a unified formalism (EAOQECC) [13]\nthat combines both OQECCs and EAQECCs. This formalism demonstrates that a broader connection exists\nbetween classical and quantum error correction theory.\nGood QECCs can be obtained by a generalized CSS construction from good classical codes. This opens the door,\nfor example, to the construction of high-quality quantum\ncodes from modern classical codes, such as Turbo and\nLDPC codes [12].\nIn this paper, we generalize this construction in a different way, by proposing new quantum codes that can be\n\n\u2217 To whom correspondence should be addressed; Electronic address:\nminhsiuh@gmail.com\n\nused to transmit both classical and quantum information\nsimultaneously. We call this scheme the entanglementassisted, classically enhanced quantum error correction\nformalism, but throughout the paper it will be referred\nto simply as the EACQ formalism . The EACQ formalism can be considered a generalization EAQECCs, or as\na unification of quantum and classical linear error correction codes. This unification also makes contact with\nresults in quantum information theory, where bounds exist on the asymptotic transmission of simultaneous classical and quantum information, including the use of entanglement assistance. It is believed that these bounds\nare better than simple time-sharing between codes for\ntransmitting quantum and classical information separately through a quantum channel [10]. It is our hope\nthat it may be possible to construct classes of codes which\nachieve these rates in the limit of large block size.\nThis paper is organized as follows. We give a brief\nintroduction of the EAQECC formalism using both the\nstabilizer and the symplectic language in section II. In\nsection III, we formally define a quantum code (EACQ)\nthat can transmit both classical and quantum information at the same time. Several properties of this kind\nof quantum code are also discussed in this section. We\nprovide several examples in section IV, to demonstrate\nthe usefulness of this formalism. We conclude in section\nV by examining some special cases, and arguing that the\nEACQ formalism is indeed a generalization and unification of quantum and classical coding theory.\n\nII.\n\nEAQECC\n\nIn this section, we will review entanglement-assisted\nquantum error correction using both stabilizer and symplectic language.\nLet Gn be the n-fold Pauli Group [18]. Every operator in Gn has either eigenvalues \u00b11 or \u00b1i. An\n[[n, q, d; e]] EAQECC is a quantum code that encodes q logical quantum bits (qubits) into n phys-\n\n\f2\nical qubits with the help of e maximally entangled\npairs (ebits) shared between sender and receiver, and\ncan correct up to \u230ad/2\u230b single-qubit errors. Such an\nEAQECC is defined by a non-commuting group SQ =\nhZ 1 , * * * , Z s , Z s+1 , X s+1 , * * * , Z s+e , X s+e i \u2282 Gn of size\n2s+2e , where s + e + q = n, and the generators Z i and\nX i satisfy the following commutation relations:\n[Z i , Z j ] = 0\n\n\u2200i, j\n\n[X i , X j ] = 0\n\n\u2200i, j\n\n[X i , Z j ] = 0\n\n\u2200i 6= j\n\n{X i , Z i } = 0\n\nN(z|x) \u2261 Z z1 X x1 \u2297 Z z2 X x2 \u2297 * * * \u2297 Z zn X xn ,\nwhere zr (xr ) is the r-th element of z (x). Thus a set of\nm Pauli-operators acting on n qubits may be specified by\na matrix with m rows ui \u2208 (Z2 )2n , i = 1, 2, * * * , m. The\nsymplectic product between two vectors is defined as\n(z|x) \u2299 (z\u2032 |x\u2032 ) = z * x\u2032T \u2212 x * z\u2032T .\n\n(1)\n\n\u2200i.\n\nWe define the isotropic subgroup SQ,I of SQ to be the\nsubgroup generated by {Z 1 , * * * , Z s }; it is of size 2s . Similarly, the symplectic subgroup SQ,S of SQ is of size 22e\nand is generated by {Z s+1 , X s+1 , * * * , Z s+e , X s+e }. The\nisotropic subgroup SQ,I is Abelian; however, the symplectic subgroup SQ,S is not. We can easily construct an\nAbelian extension of SQ,S that acts on n + e qubits, by\nspecifying the following generators:\nZ1 \u2297\n..\n.\nZs \u2297\nZ s+1 \u2297\nX s+1 \u2297\n..\n.\nZ s+e \u2297\nX s+e \u2297\n\nu = (z|x). We define\n\n(Note that in the binary case, as here, subtraction is\nthe same as addition.) Two Pauli operators N(z|x) and\nN(z\u2032 |x\u2032 ) commute if and only if (z|x) \u2299 (z\u2032 |x\u2032 ) = 0.\nRecall that the stabilizer SQ of an [[n, q; e]] EAQECC\nis generated by s + 2e elements. Therefore, it can be\nspecified by an (s + 2e) \u00d7 2n symplectic matrix, F\u0302 , which\nwe will refer to as the quantum parity check matrix in\nthis paper. Thus,\nSQ = {Nu |u \u2208 Rowspace(F\u0302 )},\n\n(2)\n\n\uf8f6\nu1\n\uf8ec . \uf8f7\n\uf8ec .. \uf8f7\n\uf8f7\n\uf8ec\n\uf8ec us+e \uf8f7\n\uf8f7.\n\uf8ec\nF\u0302 = \uf8ec\n\uf8f7\n\uf8ec vs+1 \uf8f7\n\uf8ec .. \uf8f7\n\uf8ed . \uf8f8\nvs+e\n\n(3)\n\nwhere\n\n\uf8eb\n\nI,\n\nI,\nZ1 ,\nX1 .\n\nZe ,\nXe ,\n\nwhere the first n qubits are on the side of the sender (Alice) and the extra e qubits are taken to be on the side of\nthe receiver (Bob). The operators Zi or Xi to the right of\nthe tensor product symbol above is the Pauli operator Z\nor X acting on Bob's i-th qubit. The picture is that Alice\nand Bob initially share e ebits; Alice encodes her q qubits\ntogether with her halves of the e entangled pairs and s\nancilla qubits. Bob's qubits are his halves of the e entangled pairs. Because this code assumes pre-existing entanglement between Alice and Bob, it is an entanglementassisted quantum error-correcting code (EAQECC). We\ndenote such an Abelian extension of the group SQ,S by\nSeQ,S . This EAQECC can correct an error set E \u2282 Gn if\nfor all E1 , E2 \u2208 E, E2\u2020 E1 \u2208 SQ,I \u222a (Gn \u2212 N (SQ )), where\nN (S) is the normalizer of group S.\nBefore we describe EAQECCs using the symplectic\nlanguage, we need to first discuss some of the basic properties of the symplectic form which are relevant to the\ndiscussion that follows. The symplectic form of vectors\nin (Z2 )2n is useful for specifying Pauli operators on n\nqubits when the global phase may be ignored. We write\na vector u \u2208 (Z2 )2n in symplectic form by splitting it\ninto two vectors x, z \u2208 (Z2 )n and writing it as follows:\n\nIn this matrix, the rows u1 * * * us+e represent the generators Z 1 * * * Z s+e , and the rows vs+1 * * * vs+e represent\nX s+1 * * * X s+e . The commutation relations in (1) translate to the following:\nui \u2299 uj\nvi \u2299 vj\nui \u2299 vj\nui \u2299 vi\n\n=0\n=0\n=0\n=1\n\n\u2200i, j\n\u2200i, j\n\u2200i 6= j\n\u2200i.\n\n(4)\n\nThe isotropic subgroup SQ,I and the symplectic subgroup\nSQ,S can be rewritten as:\nSQ,I = {Nu |u \u2208 Rowspace(F\u0302I )},\nSQ,S = {Nu |u \u2208 Rowspace(F\u0302S )},\nup to an overall phase, where\n\uf8eb\n\n\uf8f6\nu1\n\uf8ec\n\uf8f7\nF\u0302I = \uf8ed ... \uf8f8 ,\nus\n\n\uf8f6\nus+1\n\uf8ec . \uf8f7\n\uf8ec .. \uf8f7\n\uf8f7\n\uf8ec\n\uf8ec us+e \uf8f7\n\uf8f7\nF\u0302S = \uf8ec\n\uf8ec vs+1 \uf8f7 .\n\uf8f7\n\uf8ec\n\uf8ec .. \uf8f7\n\uf8ed . \uf8f8\n\uf8eb\n\n(5)\n\nvs+e\n\nWe can now specify the error correcting condition in\nthe symplectic formulation. This EAQECC can correct\nan error set E \u2282 (Z2 )2n if for all e1 , e2 \u2208 E, either F\u0302 \u2299\n(e2 \u2212 e1 ) 6= 0 or (e2 \u2212 e1 ) \u2208 Rowspace(F\u0302I ).\n\n\f3\nIII.\n\nCLASSICALLY ENHANCED QUANTUM\nERROR CORRECTION\n\nIn this section, we will present a new quantum code\nthat can transmit both classical and quantum information at the same time.\n\nProof We begin with a canonical code that encodes\nthe quantum information |\u03c6i \u2208 (H2 )\u2297q together with\nclassical information xi in the following trivial way:\n\u0001 \u2297(s\u2212c1 )\nxi\n\u2297c1\n|0i\n|\u03c6i \u2212\u2192|\u03c8\ni i = N(0|xa ) |0i\ni\n\u0011\nh\u0010\n(11)\nN(xb |xb ) \u2297 I |\u03a6+ i\u2297c2 |\u03a6+ i\u2297e\u2212c2 |\u03c6i,\n2\n\nA.\n\nThe Stabilizer Formalism\n\nWe define an [[n, q : c, d; e]] entanglement-assisted,\nclassically enhanced quantum error correction code\n(EACQ) to be a quantum code which encodes q logical qubits and c classical bits into n physical qubits with\nthe help of e ebits. Our quantum information is given\nby the q-dimensional state |\u03c6i \u2208 (H2 )\u2297q , and our classical information i \u2208 {1, 2, . . . , 2c } is represented by a\nvector xi \u2208 (Z2 )c . Here, we keep the subscript i in xi\nto remind the reader that xi is the binary expression of\ni. Let us denote the 2q -dimensional Hilbert space of the\noriginal qubits by H \u2261 (H2 )\u2297q , and the subspaces of\nthe n-dimensional encoded states by C i . Our encoding\ni\n: H \u2192 C i consist of appending the anoperations \u00dbenc\n\u2297s\ncilla states |0i and maximally entangled states |\u03a6+ i\u2297e ,\nwhere s + e + q = n and |\u03a6+ i \u2261 \u221a12 (|00i + |11i) , to |\u03c6i\nfollowed by performing the unitary Ui . Thus, our encoded states, or \"codewords\", are defined as\n\u0001\n(6)\n|\u03a8i i \u2261 Ui |0i\u2297s \u2297 |\u03a6+ i\u2297e \u2297 |\u03c6i .\nWe require that h\u03a8i |\u03a8j i = \u03b4ij so that the classical information is perfectly retrievable.\n\nTheorem 1 We specify an [[n, q : c, d; e]] EACQ by the\npair of groups (SQ , SC ). The quantum stabilizer SQ =\nhSQ,I , SQ,S i of the code is generated by s+2e\u2212c elements:\nSQ,I = hZ c1 +1 , Z c1 +2 , * * * , Z s i,\nSQ,S\n\n.\n= hZ s+c2 +1 , X s+c2 +1 , * * * , Z s+e , X s+e i\n\n(7)\n\nThe classical stabilizer SC = hSC,I , SC,S i of the code is\ngenerated by c elements:\nSC,I = hZ 1 , Z 2 , * * * , Z c1 i,\nSC,S = hZ s+1 , * * * , Z s+c2 , X s+1 , * * * , X s+c2 i,\n\n(8)\n\nwhere q + s+ e = n and c1 + 2c2 = c, such that, \u2200gj \u2208 SQ ,\ngj |\u03a8i i = |\u03a8i i,\n\n(9)\n\ngj\u2032 |\u03a8i i = (\u22121)xij |\u03a8i i,\n\n(10)\n\nand\n\nwhere gj\u2032 is the j-th element of the generator set of SeC ,\nwhich is the Abelian extension of SC , and xij is the j-th\nelement of xi \u2208 (Z2 )c .\n\n1\n\nwhere xa \u2208 (Z2 )c1 and xb1 , xb2 \u2208 (Z2 )c2 , and I is the c2 \u00d7\nc2 identity acting on Bob's qubits. Instead of encoding\nxi as a whole, we separate xi into xa = xi1 . . . xic1 , xb1 =\nxi,(c1 +1) . . . xi,(c1 +c2 ) , and xb2 = xi,(c1 +c2 +1) . . . xic such\nthat c1 + 2c2 = c, and encode xb1 and xb2 using c2 pairs\nof maximally entangled states. xa Clearly, the set {|\u03c8i i}\n\u2032\n\u2032\n\u2032\nis stabilized by SQ\n= hSQ,I\n, SQ,S\ni, where\n\u2032\nSQ,I\n= hZc1 +1 , Zc1 +2 , * * * , Zs i,\n\u2032\nSQ,S\n= hZs+c2 +1 , Xs+c2 +1 , * * * , Zs+e , Xs+e i.\n\n(12)\n\n\u2032\n\u2032\n\u2032\nNow let SC\n= hSC,I\n, SC,S\ni, where\n\u2032\nSC,I\n= hZ1 , * * * , Zc1 i,\n\u2032\nSC,S\n= hZs+1 , * * * , Zs+c2 , Xs+1 , * * * , Xs+c2 i,\n\n(13)\n\n\u2032\n\u2032\nand let SeC\nbe the Abelian extension of SC\n. Then it is\neasy to verify that\n\ngj\u2032 |\u03c8i i = (\u22121)xij |\u03c8i i,\n\n(14)\n\n\u2032\nwhere gj\u2032 is the j-th generator of SeC\n.\n\u2032\n\u2032\nSince (SQ , SC ) is isomorphic to (SQ , SC ), there exists\n\u2032\n\u2032\nan unitary U such that SQ = U SQ\nU \u2020 and SC = U SC\nU \u2020.\nThe codewords {|\u03a8i i} can also be obtained by\n\nU |\u03c8i i = |\u03a8i i.\n\n(15)\n\nIt is then easy to verify that (9) and (10) hold.\n\u2737\nNotice that hSQ , SC i is the stabilizer of an [[n, q; e]]\nEAQECC code, and thus it fully specifies one of the\ncodewords from (6), |\u03a80 i. For c > 0, the additional codewords are just unitary transformations of |\u03a80 i. Theorem\n1 confirms that SC and SQ together are sufficient to fully\nspecify the codewords.\nNow that we have uniquely defined our code, we will\nconsider the conditions that make a set of errors correctable, as well as the decoding procedure for a given\nset of correctable errors. We will consider here only error\nsets which are subsets of G n , since it has been shown that\nthe ability to correct such a discrete error set implies the\nability to correct any linear combination of errors in that\nset.\nTheorem 2 A set of errors E \u2282 G n is correctable if for\n\u2020\nall Em ,Ep \u2208 E, Em\nEp \u2208 hSQ,I , SC,I i \u222a (G n \u2212 N (SQ )),\nwhere N (S) is the normalizer of group S.\nProof\n\nWe consider the following different cases.\n\n\f4\n\u2020\n1. If Em\nEp \u2208 G n \u2212 N (SQ ), then by definition there is\nat least one element gj \u2208 SQ such that\n\u2020\n[Em\nEp , gj ] 6= 0.\n\nThen we are guaranteed that Em and Ep have\ndifferent error syndromes on the set of codewords\n{|\u03a8i i}. We can then perform a recovery operation\nbased on the error syndrome. If it is determined\nthat the error Em occurred, the original codeword\nmay be recovered by simply performing the unitary\nEm since Em \u2208 G n .\n\u2020\n2. If Em\nEp \u2208 N (SQ ), there are three cases:\n\u2020\n\u2020\n(a) If Em\nEp \u2208 SQ,I , then Em\nEp |\u03a8i i = |\u03a8i i. The\nerrors have the same syndrome, but they also\nact on the code space the same way. (This is\nthe case of a degenerate code.)\n\u2020\n\u2020\n(b) If Em\nEp \u2208 SC,I , then by (10), Em\nEp |\u03a8i i =\n\u00b1|\u03a8i i. The errors have the same syndrome,\nbut their effects differ by a possible global\nphase without changing the classical information i embedded in the codeword |\u03a8i i. Therefore, we can still recover both the quantum\nand classical information. (See Theorem 3).\n\n(c) For all the rest, the errors act nontrivially\non the codewords {|\u03a8i i}, but do not have a\nunique syndrome. If this case applies to any\npair of errors Em , Ep \u2208 E then the error set E\nis uncorrectable.\n\n\u2020\nCombining these cases, we get that whenever Em\nEp \u2208\nn\nhSQ,I , SC,I i \u222a (G \u2212 N (SQ )) \u2200Em , Ep \u2208 E, the codewords\n{|\u03a8i i} can be recovered up to a possible globe phase. \u2737\n\nTheorem 3 Once error recovery has been performed, the\nclassical index i may be determined by measuring each of\nthe gk\u2032 \u2208 SeC observables. The original quantum state |\u03c6i\nmay be recovered by performing the unitary Ui\u22121 and then\ndiscarding the ancillae.\nProof After we have performed error recovery, the state\nin our possession will be \u00b1|\u03a8i i. Measuring the generator\nset {gk\u2032 } of SeC will guarantee proper identification of xi\nby (10). Once the classical index has been identified,\nwe can see from (6) that we may recover the original\nquantum state |\u03c6i by performing Ui\u22121 and discarding the\nstates \u00b1|0i\u2297s |\u03a6+ i\u2297e .\n\u2737\n\nB.\n\nThe Symplectic Formalism\n\nIn the following, we will use the symplectic formalism\nto formulate this problem and at the same time generalize Theorem 1. The goal here is to show that actually\nthe EACQs can be completely specified by some classical\nparity check matrix H and quantum parity check matrix \u0124. Since an [[n, q; e]] EAQECC can be defined by a\n(s + 2e) \u00d7 2n quantum parity check matrix F\u0302 as shown\nin (3), we may specify the quantum stabilizer SQ by F\u0302\nand a binary matrix F :\n\n\uf8f6\n0s\u2212c1 \u00d7c1 Is\u2212c1 \u00d7s\u2212c1 0s\u2212c1 \u00d7e\u2212c2 0s\u2212c1 \u00d7c2 0s\u2212c1 \u00d7e\u2212c2 0s\u2212c1 \u00d7c2\n0e\u2212c2 \u00d7c2 Ie\u2212c2 \u00d7e\u2212c2 0e\u2212c2 \u00d7e\u2212c2 0e\u2212c2 \u00d7c2 \uf8f8 ,\nF = \uf8ed 0e\u2212c2 \u00d7s\u2212c1 0e\u2212c2 \u00d7c1\n0e\u2212c2 \u00d7s\u2212c1 0e\u2212c2 \u00d7c1 0e\u2212c2 \u00d7e\u2212c2 0e\u2212c2 \u00d7c2\n0e\u2212c2 \u00d7c2 Ie\u2212c2 \u00d7e\u2212c2\n\uf8eb\n\nwhere Ir\u00d7r is the r \u00d7 r identity matrix, and 0r\u00d7t is the\nr \u00d7 t null matrix. That is,\nSQ = {Nv |v \u2208 Rowspace(\u011c)},\n\n(17)\n\nwhere \u011c = F F\u0302 .\nNow, we may take any full rank, (s + 2e) \u00d7 (s + 2e)\nmatrix M and write\nF F\u0302 = (F M )(M \u22121 F\u0302 ) = H \u0124,\nwhere H = F M and \u0124 = M \u22121 F\u0302 . Since M is full rank,\nRowspace(\u0124) = Rowspace(F\u0302 ), and \u0124 and F\u0302 specify the\nsame stabilizer. However, H may be any (s + 2e \u2212 c) \u00d7\n(s + 2e) matrix having linearly independent rows, so H\nis in fact an arbitrary classical parity-check matrix!\nAlthough one can always use Theorem 1 to specify\nthe code, it may be somewhat tedious to find the gk\u2032 \u2208\n\n(16)\n\nSC in practice. Therefore, when formulating a code in\nthe language of parity-check matrices, it may sometimes\nbe more convenient to use a different set of eigenvalue\nequations to take advantage of our a priori knowledge\nof the properties of the classical parity-check matrix H.\nH specifies a set of 2c classical codewords yi \u2208 (Z2 )s+2e\nsatisfying\nHyiT = 0, i = 1,2,. . . 2c .\n\n(18)\n\nTheorem 4 Assume we are given an (s + 2e) \u00d7 2n quantum parity-check matrix \u0124 with rows u\u2032l , l = 1, 2, . . . , (s+\n2e), and an (s + 2e \u2212 c) \u00d7 (s + 2e) classical parity-check\nmatrix H whose kernel is {yi }, i = 1, 2, . . . , 2c . Then we\nmay fully specify the codewords by the equations, \u2200i, l,\nNu\u2032l |\u03a8i i = (\u22121)yil |\u03a8i i.\n\n(19)\n\n\f5\nProof\n\nTheorem 1 can be rewritten as, \u2200i, j,\n\nC.\n\nNuj |\u03a8i i = (\u22121)xij |\u03a8i i,\nwhere {xi } is the kernel of F , and uj is the j-th row of\nF\u0302 . Since \u0124 = M \u22121 F\u0302 , then\nNu\u2032l |\u03a8i i =\n\ns+2e\nY\n\n(Num )(M\n\n\u22121\n\n)lm\n\n|\u03a8i i,\n\nm=1\n\nPs+2e\n\n= (\u22121) m=1 (M\n= (\u22121)yil |\u03a8i i,\n\n\u22121\n\n)lm xim\n\n(20)\n|\u03a8i i,\n\nwhere yi = M \u22121 xi . In order to be valid codewords,\n{|\u03a8i i} must also satisfy Nwj |\u03a8i i = |\u03a8i i, where wj is the\nj-th row of H \u0124. Then\n!\ns+2e\nY\nH\njl\nNwj |\u03a8i i =\n|\u03a8i i,\n(Nu\u2032l )\nl=1\nPs+2e\n\n= (\u22121) l=1 Hjl yil |\u03a8i i,\n= (\u22121)0 |\u03a8i i = |\u03a8i i.\n\nThis concludes our proof.\n\u2737\nWe have now established a new set of codewords with\nstabilizer\nn\no\nSQ = Nv |v \u2208 Rowspace(H \u0124) ,\n\nand a new way of specifying the codewords via (19). Theorem 2 was cast in general enough terms that it is applicable to our new code. So we are now in a position to\ngive the error-correcting conditions and to explain how\nto perform error detection and recovery in the language\nof the symplectic form as a corollary to Theorem 2.\nCorollary 5 The set of correctable errors E for a code\nspecified by the quantum parity-check matrix \u0124 and classical parity-check matrix H are such that for every distinct Ne , Ne\u2032 \u2208 E, either\n1. e \u2212 e\u2032 \u2208 Rowspace(\u0124I ), or\nT\n\n2. H \u0124 \u2299 (e \u2212 e\u2032 ) 6= 0.\nProof\n\nSince\nhSQ,I , SC,I i = {Nu |u \u2208 Rowspace(\u0124I )},\n\ncondition 1 corresponds to\nNe\u2212e\u2032 = Ne\u2020\u2032 Ne \u2208 hSQ,I , SC,I i.\nLet vj denote the j-th row of H \u0124; condition 2 is equivalent to the statement that for e and e\u2032 there exists a vj\nsuch that\nh\ni\nNe\u2020\u2032 Ne , Nvj 6= 0\n\nTherefore, conditions 1 and 2 together are equivalent to\nNe\u2020\u2032 Ne \u2208 hSQ,I , SC,I i\u222a(G n \u2212 N (SQ )), which are the error\ncorrecting conditions of Theorem 2.\n\u2737\n\nProperties of EACQs\n\nTheorem 6 We can transform any [[n, q + c, d1 ; e]]\nEAQECC code C1 into an [[n, q : c, d2 ; e]] EACQ code C2 ,\nand transform any [[n, q : c, d2 ; e]] EACQ code C2 into an\n[[n, q, d3 ; e]] EAQECC code C3 , where d1 \u2264 d2 \u2264 d3 .\nProof The stabilizer group SQ of C1 is of size 2s+2e ,\nwhere s + q + c + e = n. The isotropic subgroup SQ,I\nand the symplectic subgroup SQ,S of SQ is of size 2s and\n22e , respectively. If we simply add an Abelian group SC\nof size 2c such that SC \u2229 SQ = \u2205, then (SQ , SC ) defines\nan [[n, q : c, d2 ; e]] EACQ code C2 for some d2 , which\nfollows from Theorem 1. Let E1 be the error set that\ncan be corrected by C1 , and E2 be the error set that can\nbe corrected by C2 . Clearly, E1 \u2282 E2 (see table I), so C2\ncan correct more errors than C1 . Therefore, d2 \u2265 d1 .\nIn general, an [[n, q : c, d2 ; e]] EACQ code C2 is defined by SQ = hSQ,I , SQ,S i and SC = hSC,I , SC,S i, where\nthe isotropic subgroup SQ,I and the symplectic subgroup\nSQ,S of SQ is of size 2s\u2212c1 and 22(e\u2212c2 ) , respectively, and\nthe isotropic subgroup SC,I and the symplectic subgroup\nSC,S of SC is of size 2c1 and 22c2 , respectively. Here the\nparameters satisfy s + q + e = n and c1 + 2c2 = c. Now\n\u2032\n\u2032\nlet SQ,I\n= hSQ,I , SC,I i and SQ,S\n= hSQ,S , SC,S i. Then\n\u2032\n\u2032\n\u2032\nSQ = hSQ,I , SQ,S i defines an [[n, q, d3 ; e]] EAQECC code\nC3 . Let E3 be the error set that can be corrected by C3 .\nLet E \u2208 E2 , then either E \u2208 hSQ,I , SC,I i or E 6\u2208 N (SQ ).\n\u2032\n\u2022 If E \u2208 hSQ,I , SC,I i, then E \u2208 SQ,I\n. Thus, E \u2208 E3 .\n\u2032\n\u2032\n\u2022 Since SQ \u2282 SQ\n, we have N (SQ\n) \u2282 N (SQ ). If E 6\u2208\n\u2032\nN (SQ ), then E 6\u2208 N (SQ\n). Thus, E \u2208 E3 .\n\nPutting these together we get E2 \u2282 E3 . Therefore\nd3 \u2265 d2 .\n\u2737\nIt is worth pointing out that the theory of EACQ codes\nnaturally includes the set of classically enhanced quantum codes that do not require entanglement as a subclass.\nThese would be codes for which there is no nontrivial\nsymplectic subgroup for either SQ or SC , so that both of\nthese groups are purely isotropic. In terms of the parameters describing the code, this is the special case where\ne = 0. Our first example in the next section is exactly\nsuch a code.\nTo conclude this section, we list the different errorcorrecting criteria of an EAQECC and an EACQ:\nEAQECC\nEACQ\n\u2020\n\u2020\nEm\nEp 6\u2208 N (hSQ,I , SQ,S i) Em\nEp 6\u2208 N (hSQ,I , SQ,S i)\n\u2020\n\u2020\nEm\nEp \u2208 SQ,I\nEm\nEp \u2208 hSQ,I , SC,I i\n\nTABLE I: The error-correcting conditions of EAQECCs and\nEACQs.\n\n\f6\nIV.\nA.\n\nEXAMPLES\n\n[[9, 1 : 3, 3; 0]] EACQ\n\nWe first give an example of a code that starts from\nan overly redundant quantum code, and exploits that\nredundancy by additionally encoding classical information. Starting from the 9-qubit Shor code, we modify it\nto encode three additional classical bits into the quantum\ncode. The modified Shor code presented here encodes one\nqubit and three classical bits into nine physical qubits,\nand it is still able to correct an arbitrary error on a single\nqubit.\nThe code is a straightforward combination of the original 9 qubit Shor code, with parity-check matrix\n\uf8f6\n\uf8eb\n1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\uf8f7\n\uf8ec\n\uf8ec0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\u0124 = \uf8ec\n\uf8ec 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 \uf8f7,\n\uf8f7\n\uf8ec\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ed0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0\uf8f8\n0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1\n\nand the [8, 3] classical code,\n\uf8eb\n1 0 1\n\uf8ec0 0 0\n\uf8ec\n\uf8ec\nH = \uf8ec1 1 1\n\uf8ec\n\uf8ed1 0 0\n1 1 1\n\nwith parity check matrix\n\uf8f6\n0 1 0 0 0\n1 0 1 0 0\uf8f7\n\uf8f7\n\uf8f7\n0 0 0 0 0\uf8f7 .\n\uf8f7\n1 0 0 1 0\uf8f8\n1 1 1 0 1\n\nTable II gives the generators of SQ and SC as in (9) and\n(10) for the code.\n\nSQ\n\nSC\n\ng1\ng2\ng3\ng4\ng5\ng1\u2032\ng2\u2032\ng3\u2032\n\nZ\nI\nZ\nY\nZ\nZ\nI\nI\n\nZ\nI\nI\nY\nI\nZ\nZ\nI\n\nI\nI\nZ\nX\nZ\nI\nZ\nI\n\nZ\nI\nZ\nX\nY\nI\nI\nI\n\nZ\nZ\nZ\nY\nX\nI\nI\nZ\n\nI\nZ\nI\nY\nY\nI\nI\nZ\n\nZ\nI\nI\nI\nY\nI\nI\nI\n\nZ\nZ\nI\nI\nX\nI\nI\nI\n\nI\nZ\nI\nI\nY\nI\nI\nI\n\nTABLE II: The resulting [[9, 1 : 3, 3; 0]] EACQ encodes one\nqubit and three classical bits into nine physical qubits.\n\nProposition 7 The modified Shor code presented above\ncan correct an arbitrary error on a single qubit.\nProof This modified Shor code is degenerate. A singlequbit Z error on any of the qubits in the same triplet\n(that is, on any of qubits 1, 2, 3, or any of qubits 4, 5, 6,\n\nor any of qubits 7, 8, 9) result in the same error syndrome,\nand can be corrected using the same recovery operation.\nHowever, each of the single-qubit X errors gives a distinct\nerror syndrome, and can therefore be corrected. The\nsyndromes are obtained by measuring {g1 , * * * , g5 }. \u2737\n\nB.\n\n[[8, 1 : 3, 3; 1]] EACQ code\n\nThe following example comes from modifying the\n[[8, 1, 3; 1]] EAQECC code given in [13]. The [[8, 1 :\n3, 3; 1]] EACQ code comes from a combination of the\n[[8, 1, 3; 1]] EAQECC with the quantum parity check matrix\n\uf8f6\n\uf8eb\n1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\uf8f7\n\uf8ec\n\uf8ec1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0\uf8f7\n\uf8f7\n\u0124 = \uf8ec\n\uf8ec 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 \uf8f7,\n\uf8f7\n\uf8ec\n\uf8f7\n\uf8ec\n\uf8ec0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0\uf8f7\n\uf8f7\n\uf8ec\n\uf8ed0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0\uf8f8\n0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 1\nand the [8, 3] classical code, with parity check matrix\n\uf8eb\n1\n\uf8ec0\n\uf8ec\n\uf8ec\nH = \uf8ec1\n\uf8ec\n\uf8ed0\n0\n\n0\n1\n0\n0\n1\n\n1\n1\n1\n1\n1\n\n0\n0\n1\n1\n0\n\n1\n0\n0\n0\n1\n\n0\n0\n1\n0\n1\n\n0\n0\n0\n1\n0\n\n\uf8f6\n0\n0\uf8f7\n\uf8f7\n\uf8f7\n0\uf8f7 .\n\uf8f7\n0\uf8f8\n1\n\n\u0124 and H together specify (SQ , SC ) for the EACQ given\nin Table III. The resulting EACQ encodes one qubit and\ng1\nSQ,I g2\ng3\ng\nSQ,S 4\ng5\ng1\u2032\nSC g2\u2032\ng3\u2032\n\nZ\nZ\nY\nI\nZ\nZ\nI\nI\n\nZ\nI\nY\nI\nI\nZ\nZ\nI\n\nI\nZ\nX\nI\nZ\nI\nZ\nI\n\nZ\nZ\nX\nI\nY\nI\nI\nI\n\nZ\nZ\nY\nZ\nY\nI\nI\nZ\n\nI\nI\nY\nZ\nX\nI\nI\nZ\n\nZ\nI\nI\nI\nY\nI\nI\nI\n\nZ\nI\nI\nZ\nY\nI\nI\nI\n\nTABLE III: The resulting [[8, 1 : 3, 3; 1]] EACQ encodes one\nqubit and three classical bits into eight physical qubits with\nthe help of one ebit.\n\nthree classical bits into eight physical qubits with the\nhelp of one ebit. Since the [[8, 1, 3; 1]] code is derived\nfrom the Shor code, this EACQ is clearly related to our\nfirst example.\n\n\f7\nC.\n\nchosen to be\n\nEACQ codes from classical BCH codes\n\nHere, we will look at the [[63, 21, 9; 6]] EAQECC shown\nin [13], which is constructed from a classical binary\n[63, 39, 9] BCH code [17]. This EAQECC has the interesting property that removing the symplectic pairs from\nthe quantum parity check matrix will only decrease the\ndistance from d = 9 to d = 7 no matter how many pairs\nare removed. Therefore, if we switch all the ebits from\nSQ to SC , we will have a [[63,21:12,7;6]] EACQ. This example shows that it is possible to encode extra classical\ninformation using ebits without degrading the distance\nperformance too much.\nV.\n\nCONCLUSIONS\n\nIn this paper, we have demonstrated yet another\nextension of the standard quantum error correction\nscheme. The new formalism, EACQ, is a quantum errorcorrecting code that can transmit both classical and\nquantum information simultaneously. We consider this\nEACQ formalism as both a generalization and a unification of EAQECCs and classical error correction, in the\nfollowing sense:\n\u2022 For a purely quantum code (c = 0), we have SC =\n\u2205. Then this corresponds to the entanglementassisted formalism. In this case, the classical parity\ncheck matrix H is chosen to be\n\n\u0124 = (In\u00d7n |0n\u00d7n )\nsuch that the quantum parity-check matrix \u011c =\nH \u0124 = (H|0n\u00d7n ) for the code. The classical code\ncan be thought of as encoded in the Z basis.\nOn the other hand, the EACQ formalism provides further flexibility in the use of quantum error correcting\ncodes. As shown in the example section, the EACQ\ncan make use of extra redundancy in quantum codes by\nencoding additional classical information. We also note\nthat the passive error correcting ability of an EACQ is\nincreased at the cost of the quantum code rate of an\nEAQECC.\nWe are currently investigating the relation between\nEACQs and other extensions of standard quantum error\ncorrection, such as OQECC or \"operator algebra quantum error correction\" (OAQEC) [3]. Recently we are\naware of the work [4], which also allows correction of\nhybrid classical-quantum information based on operator\nalgebra. Given the wider variety of resources in quantum information theory compared to classical information theory, we can expect a correspondingly richer set\nof families of quantum error-correcting codes.\n\nAcknowledgments\n\n\u2022 For a purely classical code (q = 0), we have SQ = \u2205.\nIn this case, the quantum parity check matrix \u0124 is\n\nWe wish to acknowledge enlightening discussions with\nIgor Devetak, and Cedric Beny. TAB received financial support from NSF Grant No. CCF-0448658, and\nTAB and MHH both received support from NSF Grant\nNo. ECS-0507270. IK and MHH received financial support from NSF Grant No. CCF-0524811 and NSF Grant\nNo. CCF-0545845.\n\n[1] S.A. Aly, A. Klappenecker, and P. K. Sarvepalli. Subsystem codes, 2006. quant-ph/0610153.\n[2] D. Bacon. Operator quantum error correcting subsystems for self-correcting quantum memories. Phys. Rev.\nA, 73:012340, 2006.\n[3] Cedric Beny, Achim Kempf, and David W. Kribs. Generalization of quantum error correction via the heisenberg picture. Phys. Rev. Lett., 98:100502, 2007. quantph/0608071.\n[4] Cedric Beny, Achim Kempf, and David W. Kribs.\nQuantum error correction of observables, 2007.\narXiv:0705.1574.\n[5] G. Bowen.\nEntanglement required in achieving\nentanglement-assisted channel capacities. Phys. Rev. A,\n66:052313, 2002.\n[6] T. Brun, I. Devetak, and M. H. Hsieh. Catalytic quantum\nerror correction, 2006. quant-ph/0608027.\n[7] T. Brun, I. Devetak, and M. H. Hsieh. Correcting quan-\n\ntum errors with entanglement. Science, 314(5798):436\u2013\n439, 2006. DOI: 10.1126/Science.1131563.\nA. R. Calderbank, E. M. Rains, P. W. Shor, and N. J. A.\nSloane. Quantum error correction via codes over GF(4).\nIEEE Trans. Inf. Theory, 44:1369\u20131387, 1998.\nA. R. Calderbank and P. W. Shor. Good quantum errorcorrecting codes exist. Phys. Rev. A, 54:1098\u20131105, 1996.\nIgor Devetak, Patrick Hayden, and Debbie Leung. Towards a unification of quantum shannon theory. In preparation, 2008.\nD. Gottesman. Stabilizer codes and quantum error correction. PhD thesis, California Institute of Technology,\n1997.\nM. H. Hsieh, T. A. Brun, and I. Devetak. Quantum quasicyclic low-density parity-check codes, 2007. in preparation.\nM. H. Hsieh, I. Devetak, and T. Brun.\nGeneral\nentanglement-assisted quantum error-correcting codes.\n\nH = I(n\u2212q)\u00d7(n\u2212q)\nsuch that the quantum parity-check matrix is \u011c =\nH \u0124 = \u0124 for the code.\n\n[8]\n[9]\n[10]\n[11]\n\n[12]\n[13]\n\n\f8\nPhys. Rev. A, 76:062313, 2007. arXiv:0708.2142.\n[14] A. Klappenecker and P. K. Sarvepalli. Clifford code constructions of operator quantum error correcting codes,\n2006. quant-ph/0604161.\n[15] D. Kribs, R. Laflamme, and D. Poulin. A unified and\ngeneralized approach to quantum error correction. Phys.\nRev. Lett., 94:180501, 2005.\n[16] David W. Kribs and Robert W. Spekkens. Quantum\nerror correcting subsystems as unitarily recoverable subsystems, 2006. quant-ph/0608045.\n[17] F.J. MacWilliams and N.J.A. Sloane. The Theory of\nError-Correcting Codes. Elsevier, Amsterdam, 1977.\n[18] M. A. Nielsen and I. L. Chuang. Quantum Computation\n\n[19]\n\n[20]\n[21]\n[22]\n\nand Quantum Information. Cambridge University Press,\nNew York, 2000.\nM. A. Nielsen and D. Poulin. Algebraic and informationtheoretic conditions for operator quantum error correction. Phys. Rev. A, 75:064304, 2007.\nD. Poulin. Stabilizer formalism for operator quantum\nerror correction. Phys. Rev. Lett., 95:230504, 2005.\nP. W. Shor. Scheme for reducing decoherence in quantum\ncomputer memory. Phys. Rev. A, 52:2493\u20132496, 1995.\nA. M. Steane. Error-correcting codes in quantum theory.\nPhys. Rev. Lett., 77:793\u2013797, 1996.\n\n\f"}