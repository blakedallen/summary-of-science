{"id": "http://arxiv.org/abs/1109.0971v1", "guidislink": true, "updated": "2011-09-05T18:05:25Z", "updated_parsed": [2011, 9, 5, 18, 5, 25, 0, 248, 0], "published": "2011-09-05T18:05:25Z", "published_parsed": [2011, 9, 5, 18, 5, 25, 0, 248, 0], "title": "X-Vine: Secure and Pseudonymous Routing Using Social Networks", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1109.4420%2C1109.4645%2C1109.4312%2C1109.2699%2C1109.2096%2C1109.3434%2C1109.5549%2C1109.1198%2C1109.3214%2C1109.2663%2C1109.0483%2C1109.6701%2C1109.6355%2C1109.6522%2C1109.2810%2C1109.6587%2C1109.2875%2C1109.2186%2C1109.4102%2C1109.6064%2C1109.1962%2C1109.6344%2C1109.4262%2C1109.1237%2C1109.1140%2C1109.1267%2C1109.4583%2C1109.4718%2C1109.6591%2C1109.4715%2C1109.0178%2C1109.5493%2C1109.0576%2C1109.0968%2C1109.4703%2C1109.0967%2C1109.4328%2C1109.2892%2C1109.5669%2C1109.2619%2C1109.0230%2C1109.3541%2C1109.5376%2C1109.2824%2C1109.4620%2C1109.6049%2C1109.4217%2C1109.5930%2C1109.4931%2C1109.3017%2C1109.3037%2C1109.0932%2C1109.1549%2C1109.6145%2C1109.4465%2C1109.3341%2C1109.4345%2C1109.3162%2C1109.2465%2C1109.0862%2C1109.1387%2C1109.2157%2C1109.2428%2C1109.2557%2C1109.6761%2C1109.5722%2C1109.4869%2C1109.3294%2C1109.6259%2C1109.1697%2C1109.4404%2C1109.6057%2C1109.5609%2C1109.1389%2C1109.2244%2C1109.3733%2C1109.3129%2C1109.3896%2C1109.1053%2C1109.6898%2C1109.0971%2C1109.3994%2C1109.4803%2C1109.2088%2C1109.0901%2C1109.6887%2C1109.6371%2C1109.4433%2C1109.5542%2C1109.3669%2C1109.4207%2C1109.6585%2C1109.6802%2C1109.5989%2C1109.0593%2C1109.4001%2C1109.6724%2C1109.2687%2C1109.0846%2C1109.4424%2C1109.1088&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "X-Vine: Secure and Pseudonymous Routing Using Social Networks"}, "summary": "Distributed hash tables suffer from several security and privacy\nvulnerabilities, including the problem of Sybil attacks. Existing social\nnetwork-based solutions to mitigate the Sybil attacks in DHT routing have a\nhigh state requirement and do not provide an adequate level of privacy. For\ninstance, such techniques require a user to reveal their social network\ncontacts. We design X-Vine, a protection mechanism for distributed hash tables\nthat operates entirely by communicating over social network links. As with\ntraditional peer-to-peer systems, X-Vine provides robustness, scalability, and\na platform for innovation. The use of social network links for communication\nhelps protect participant privacy and adds a new dimension of trust absent from\nprevious designs. X-Vine is resilient to denial of service via Sybil attacks,\nand in fact is the first Sybil defense that requires only a logarithmic amount\nof state per node, making it suitable for large-scale and dynamic settings.\nX-Vine also helps protect the privacy of users social network contacts and\nkeeps their IP addresses hidden from those outside of their social circle,\nproviding a basis for pseudonymous communication. We first evaluate our design\nwith analysis and simulations, using several real world large-scale social\nnetworking topologies. We show that the constraints of X-Vine allow the\ninsertion of only a logarithmic number of Sybil identities per attack edge; we\nshow this mitigates the impact of malicious attacks while not affecting the\nperformance of honest nodes. Moreover, our algorithms are efficient, maintain\nlow stretch, and avoid hot spots in the network. We validate our design with a\nPlanetLab implementation and a Facebook plugin.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1109.4420%2C1109.4645%2C1109.4312%2C1109.2699%2C1109.2096%2C1109.3434%2C1109.5549%2C1109.1198%2C1109.3214%2C1109.2663%2C1109.0483%2C1109.6701%2C1109.6355%2C1109.6522%2C1109.2810%2C1109.6587%2C1109.2875%2C1109.2186%2C1109.4102%2C1109.6064%2C1109.1962%2C1109.6344%2C1109.4262%2C1109.1237%2C1109.1140%2C1109.1267%2C1109.4583%2C1109.4718%2C1109.6591%2C1109.4715%2C1109.0178%2C1109.5493%2C1109.0576%2C1109.0968%2C1109.4703%2C1109.0967%2C1109.4328%2C1109.2892%2C1109.5669%2C1109.2619%2C1109.0230%2C1109.3541%2C1109.5376%2C1109.2824%2C1109.4620%2C1109.6049%2C1109.4217%2C1109.5930%2C1109.4931%2C1109.3017%2C1109.3037%2C1109.0932%2C1109.1549%2C1109.6145%2C1109.4465%2C1109.3341%2C1109.4345%2C1109.3162%2C1109.2465%2C1109.0862%2C1109.1387%2C1109.2157%2C1109.2428%2C1109.2557%2C1109.6761%2C1109.5722%2C1109.4869%2C1109.3294%2C1109.6259%2C1109.1697%2C1109.4404%2C1109.6057%2C1109.5609%2C1109.1389%2C1109.2244%2C1109.3733%2C1109.3129%2C1109.3896%2C1109.1053%2C1109.6898%2C1109.0971%2C1109.3994%2C1109.4803%2C1109.2088%2C1109.0901%2C1109.6887%2C1109.6371%2C1109.4433%2C1109.5542%2C1109.3669%2C1109.4207%2C1109.6585%2C1109.6802%2C1109.5989%2C1109.0593%2C1109.4001%2C1109.6724%2C1109.2687%2C1109.0846%2C1109.4424%2C1109.1088&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Distributed hash tables suffer from several security and privacy\nvulnerabilities, including the problem of Sybil attacks. Existing social\nnetwork-based solutions to mitigate the Sybil attacks in DHT routing have a\nhigh state requirement and do not provide an adequate level of privacy. For\ninstance, such techniques require a user to reveal their social network\ncontacts. We design X-Vine, a protection mechanism for distributed hash tables\nthat operates entirely by communicating over social network links. As with\ntraditional peer-to-peer systems, X-Vine provides robustness, scalability, and\na platform for innovation. The use of social network links for communication\nhelps protect participant privacy and adds a new dimension of trust absent from\nprevious designs. X-Vine is resilient to denial of service via Sybil attacks,\nand in fact is the first Sybil defense that requires only a logarithmic amount\nof state per node, making it suitable for large-scale and dynamic settings.\nX-Vine also helps protect the privacy of users social network contacts and\nkeeps their IP addresses hidden from those outside of their social circle,\nproviding a basis for pseudonymous communication. We first evaluate our design\nwith analysis and simulations, using several real world large-scale social\nnetworking topologies. We show that the constraints of X-Vine allow the\ninsertion of only a logarithmic number of Sybil identities per attack edge; we\nshow this mitigates the impact of malicious attacks while not affecting the\nperformance of honest nodes. Moreover, our algorithms are efficient, maintain\nlow stretch, and avoid hot spots in the network. We validate our design with a\nPlanetLab implementation and a Facebook plugin."}, "authors": ["Prateek Mittal", "Matthew Caesar", "Nikita Borisov"], "author_detail": {"name": "Nikita Borisov"}, "author": "Nikita Borisov", "arxiv_comment": "15 pages", "links": [{"href": "http://arxiv.org/abs/1109.0971v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1109.0971v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1109.0971v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1109.0971v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:1109.0971v1 [cs.CR] 5 Sep 2011\n\nX-Vine: Secure and Pseudonymous Routing Using Social\nNetworks\nPrateek Mittal\n\nMatthew Caesar\n\nNikita Borisov\n\nDept. of ECE\nUniversity of Illinois\n\nDept. of CS\nUniversity of Illinois\n\nDept. of ECE\nUniversity of Illinois\n\nmittal2@illinois.edu\n\ncaesar@cs.illinois.edu\n\nnikita@illinois.edu\n\nABSTRACT\n\nlimiting the growth of the P2P user base, and at the same\ntime does not fully address the problem of Sybil attacks.\nTo address this, recent research proposes to use social network trust relationships to mitigate Sybil attacks [19,64,65].\nHowever, these systems share some key shortcomings:\nHigh control overhead: These systems rely on flooding or\nlarge numbers of repeated lookups to maintain state. For\nexample, Whanau [30] is the state-of-art design that secures\nrouting in DHTs, but it is built upon a one-hop DHT routing mechanism, and has high\n\u221a overheads: state and control\noverhead increases with O( n log n), where n is the number\nof participants in the social network. As networked systems\nbecome increasingly deployed at scale (e.g., in the wide area,\nacross service providers), in high-churn environments (e.g.,\ndeveloping regions, wireless, mobile social networks [36]),\nand for applications with stronger demands on correctness\nand availability (e.g., online storage, content voting, reputation systems) the problem of high overhead in existing works\nstands to become increasingly serious; multi-hop DHT routing mechanisms are going to be necessary.\nLack of privacy: These systems require a user to reveal social\ncontact information (friend lists). Some of these schemes require global distribution of this contact information. This is\nunfortunate, as social contacts are considered to be private\ninformation: leading real-world systems like Facebook [3]\nand LiveJournal [4] provide users with a functionality to\nlimit access to this information. Forcing users to reveal\nthis private information could greatly hinder the adoption\nof these technologies.\nA second privacy concern, common to both traditional\nDHTs and ones that use social networking information, is\nthat users must communicate directly with random peers,\nrevealing their IP addresses. This provides an opportunity\nfor the attacker to perform traffic analysis and compromise\nuser privacy [9,31]. Prior work [38,61]has demonstrated that\na colluding adversary can associate a DHT lookup with its\nlookup initiator, and thus infer the activities of a user. A\npseudonymous routing mechanism can defend against such\nattacks, and would be especially beneficial for privacy sensitive DHT applications [17, 39].\nTo address these shortcomings, we propose X-Vine, a protection mechanism for large-scale distributed systems that\nleverages social network trust relationships. X-Vine has several unique properties. X-Vine protects privacy of social relationships, by ensuring that a user's relationship information is revealed only to the user's immediate friends. At the\nsame time, X-Vine also protects correctness of DHT routing,\nby mitigating Sybil attacks while requiring only logarithmic\n\nDistributed hash tables suffer from several security and privacy vulnerabilities, including the problem of Sybil attacks.\nExisting social network-based solutions to mitigate the Sybil\nattacks in DHT routing have a high state requirement and\ndo not provide an adequate level of privacy. For instance,\nsuch techniques require a user to reveal their social network\ncontacts. We design X-Vine, a protection mechanism for\ndistributed hash tables that operates entirely by communicating over social network links. As with traditional peer-topeer systems, X-Vine provides robustness, scalability, and a\nplatform for innovation. The use of social network links for\ncommunication helps protect participant privacy and adds\na new dimension of trust absent from previous designs. XVine is resilient to denial of service via Sybil attacks, and in\nfact is the first Sybil defense that requires only a logarithmic\namount of state per node, making it suitable for large-scale\nand dynamic settings. X-Vine also helps protect the privacy\nof users social network contacts and keeps their IP addresses\nhidden from those outside of their social circle, providing\na basis for pseudonymous communication. We first evaluate our design with analysis and simulations, using several\nreal world large-scale social networking topologies. We show\nthat the constraints of X-Vine allow the insertion of only a\nlogarithmic number of Sybil identities per attack edge; we\nshow this mitigates the impact of malicious attacks while\nnot affecting the performance of honest nodes. Moreover,\nour algorithms are efficient, maintain low stretch, and avoid\nhot spots in the network. We validate our design with a\nPlanetLab implementation and a Facebook plugin.\n\n1.\n\nINTRODUCTION\n\nPeer-to-peer (P2P) networks have, in a short time, revolutionized communication on the Internet. One key feature of P2P networks is their ability to scale to millions of\nusers without requiring any centralized infrastructure support. The best scalability and performance is offered by\nmulti-hop distributed hash tables (DHTs), which offer a\nstructured approach to organizing peers [33,48,52,55]. Multihop DHTs are the subject of much research and are also used\nin several mainstream systems [2, 7, 23].\nSecuring DHTs has always been a challenging task [14,53,\n59], especially in the face of a Sybil attack [20], where one\nnode can pretend to have multiple identities and thus interfere with routing operations. Traditional solutions to this\nattack require participants to obtain certificates [14], prove\npossession of a unique IP address [39, 42], or perform some\ncomputation [11]. This creates a barrier to participation,\n1\n\n\fthese networks.\n\nstate and control overhead. To the best of our knowledge,\nX-Vine is the first system to provide both properties, which\nmay serve to make it a useful building block in constructing the next generation of social network based distributed\nsystems. Finally, X-Vine also provides a basis for pseudonymous communication; a user's IP address is revealed only to\nhis/her trusted social network contacts.\nX-Vine achieves these properties by incorporating social\nnetwork trust relationships in the DHT design. Unlike traditional DHTs, which route directly between overlay participants (e.g., [30]), X-Vine embeds the DHT directly into the\nsocial fabric, allowing communication through the DHT to\nleverage trust relationships implied by social network links.\nThis is done by using mechanisms similar to network layer\nDHTs like VRR [12]. We leverage this structure for two\npurposes. First, communication in X-Vine is carried out\nentirely across social-network links.The use of social network links enables pseudonymous communication; while the\nrecipient may know the opaque identifier (pseudonym) for\nthe source, the IP address of the source is revealed only to\nhis/her friends. Second, recent work has shown that social\nnetworks can be used to detect Sybil attacks by identifying a bottleneck cut that connects the Sybil identities to\nthe rest of the network [19, 64, 65]. X-Vine enables comparable Sybil resilience by bounding the number of DHT\nrelationships that can traverse a particular edge. With this\nmulti-hop approach, we can limit the number of Sybil identities per attack edge (attack edges illustrated in Figure 1)\nto logarithmic in the size of the network with logarithmic\ncontrol and routing state, a dramatic reduction from previous Sybil defense approaches. This allows X-Vine to scale\nto large user bases and high-churn environments.\nWe evaluate X-Vine both analytically and experimentally\nusing large scale real-world social network topologies. Since\nrecent work [58, 62] has advocated the use of interaction\nnetworks as a more secure realization of social trust, we\nalso demonstrate the performance of X-Vine on interaction\ngraphs. From our evaluation, we find that X-Vine is able\nto route using 10\u201315 hops (comparable to other DHTs) in\ntopologies with 100 000 nodes while using only O(log n) routing state. In particular, we show that the overhead of X-Vine\nis two orders of magnitude smaller than Whanau. With respect to Sybil resistance, we found that honest nodes are\nable to securely route to each other with probability greater\nthan 0.98 as long as the number of attack edges is g \u2208\no(n/(log n)). Using an implementation on PlanetLab, we\nestimate the median lookup latency in a 100 000 node topology to be less than 1.2 seconds. Even when 20% of the nodes\nfail simultaneously, the lookups still succeed with a probability greater than 95%. Finally, we also implement a plugin\nfor DHT designers that can enable them to easily integrate\nsocial network contacts with a DHT by leveraging existing\nonline social networks like Facebook.\nOur proposed techniques can be applied in a wide variety\nof scenarios that leverage DHTs:\n\n\u2022 Applications like Coral [23], Adeona [50], and Vanish [25] are built on top of DHTs. The security properties of these applications can often be compromised\nby exploiting vulnerabilities in the DHT. As an example, the security of Vanish was recently compromised\nby a low-cost Sybil attack on the Vuze network [63].\nOur proposed techniques protect these applications by\nbounding the number of Sybil identities in the DHT.\n\u2022 Decentralized P2P anonymous communication systems\nlike Tarzan [24], Salsa [42] and ShadowWalker [39] assume an external Sybil defense mechanism. X-Vine is\nparticularly suitable for designing Sybil-resilient P2P\nanonymous communication systems, since it provides\nsecure as well as pseudonymous routing.\n\u2022 Freenet [17] is a widely used censorship resistant overlay network, but its routing algorithm has been shown\nto be extremely vulnerable in presence of even a few\nmalicious nodes [21]. X-Vine can enable peers to resist\ncensorship by securely and pseudonymously retrieving\ndata objects from the Freenet network.\n\u2022 Membership concealing overlay networks (MCONs) [57]\nhide the identities of the peers participating in a network (different from pseudonymity). Our proposed\ntechniques can provide a substrate for designing fully\ndecentralized membership concealing networks.\nRoadmap: The rest of the paper describes and evaluates\nX-Vine. We start by giving a high-level overview of the problem we address and our approach (Section 2), followed by\na detailed description of our routing algorithm (Section 3)\nand its security mechanisms (Section 4). We then describe\nour experimental results (Section 5). Finally, we summarize related work (Section 6), discuss X-Vine's limitations\n(Section 7), and conclude (Section 8).\n\n2. X-VINE OVERVIEW\n2.1 Design Goals\nWe start by defining the goals for our design.\n1. Secure routing: if an honest node X performs a lookup\nfor an identifier ID, then the lookup mechanism must return\nthe global successor of ID (present in the routing tables of\nhonest nodes).\n2. Pseudonymous communication: an adversary should not\nbe able to determine the IP address corresponding to a user.\n3. Privacy of user relationships: an adversary should not be\nable to infer a user's social contacts.\n4. Low control overhead: the control overhead of the system\nshould be small to enable a scalable design. This excludes\nflooding-based and single-hop mechanisms.\n5. Low latency: the length of the path used to route to\nan arbitrary identifier should be small, in order to minimize\nlookup latency.\n6. Churn resilience: even when a significant fraction of\nnodes fail simultaneously, lookup queries should still succeed.\n7. Fully decentralized design: we target a fully decentralized\narchitecture without any central points of trust/failure.\n\n\u2022 Large scale P2P networks like Vuze/Kad/Overnet are\npopularly used for file sharing and content distribution. However, these networks are vulnerable to attacks on the routing protocol [60] and do not protect\nthe privacy of the user [38]. X-Vine protects against\nattacks that target the DHT mechanisms and provides\na basis for pseudonymous communication. Moreover,\nX-Vine is also robust to the high churn prevalent in\n2\n\n\fare directly connected by a social network link simply communicate via the IP layer. All communication performed by\na node is done only with its friends, and this communication is done in a manner that does not reveal the node's local\ntopology, preventing leakage of friendship list information to\nnon-friends. Routing over social links also enables a user to\ncommunicate pseudonymous with respect to non-friends.\nProtecting against Sybils: The scheme described above\ndoes not mitigate the Sybil attack, as a malicious node can\nrepeatedly join with different identifiers, and thereby \"take\nover\" a large portion of the identifier space. Malicious nodes\ncan in fact pretend that there is an entire network of Sybil\nnodes behind themselves (Figure 1). To protect against the\nFigure 1: Illustration of honest nodes, Sybil nodes,\nSybil attack, we constrain the number of paths between honand attack edges between them.\nest nodes and malicious nodes. Since Sybil nodes by their\nvery nature are likely to be behind a small \"cut\" in the graph,\nWe note that requirements 2, 3 and 4 distinguish us from\nby constraining the number of paths that may be set up, we\nprior work-state-of-the-art approaches do not provide pseudony- can constrain the impact that a Sybil node can have on the\nmous routing, do not preserve privacy of user relationships,\nentire network. In particular, honest nodes rate-limit the\nand have high control overhead.\nnumber of paths that are allowed to be constructed over their\nadjacent links, thereby limiting the ability of Sybil nodes to\n2.2 Threat Model and Assumptions\njoin the routing scheme, and hence participate in the network. When a joining node attempts to establish a trail over\nWe assume that a fraction of real users are compromised\nan edge that has reached its limit, the node adjacent to the\nand colluding. Recent work [19, 64, 65] has leveraged the infull link sends the joining node a message indicating failure\nsight that it is costly for an attacker to establish many trust\nof the join request. This limits Sybil nodes from constructrelationships. Following this reasoning, we assume that the\ning very many paths into the network. Since Sybil nodes\nnumber of attack edges, denoted by g, is bounded. Similar to\ncannot construct many trails, they cannot place many idenprior work, we assume that the attack edges are not specially\ntifiers into the DHT. Hence, an honest node can send traffic\nchosen. We also assume that the set of colluding comproto another honest node by forwarding traffic over the DHT,\nmised nodes is a Byzantine adversary, and can deviate from\nas trails are unlikely to traverse Sybil-generated regions of\nthe protocol in arbitrary ways by launching active attacks on\nthe network.\nthe routing protocol. In particular, the set of compromised\nnodes can launch a Sybil attack by trying to insert multiple\nfake identities in the system. The key assumption we make\n3. X-VINE PROTOCOL\nabout the adversary is that Sybil identities are distributed\nThe key feature of our design is that all DHT communirandomly in the DHT identifier space. We note that this ascation happens over social network links.1 By ensuring that\nsumption is a limitation of the X-Vine protocol, as discussed\nall communication takes place over social network links, we\nin Section 7. An exploration of defenses against adversaries\ncan leverage the trust relationships in the social network\nwho concentrate their nodes in a particular region of the\ntopology to enforce security properties. A trivial security\noverlay is beyond the scope of this paper.\nproperty of our design is that an adversary needs to be connected to honest users via a series of social network links to\n2.3 Solution Overview\ncommunicate with them. Moreover, the IP address of the\nWe start by describing our algorithm in the context of\nnodes only needs to be revealed to their contacts, enhancan abstract, static network. Suppose we have a graph G,\ning privacy for users. Most importantly, our design is able\nwhere nodes correspond to users of the social network, and\nto effectively resist Sybil attacks even when the number of\nedges correspond to social relationships between them. Our\nattack edges is large.\napproach runs a DHT-based routing scheme over the graph\nthat embeds path information in the network. We first describe how routing is performed, and then describe how the\npath information it creates can be used to mitigate Sybil\nattackers.\nPseudonymous routing in the social network: We\nconstruct a DHT on top of the social network, using mechanisms similar to network layer DHTs [12]. Each node in\nthe network selects a random numeric identifier, and maintains paths (trails) to its neighbors in the identifier space in\na DHT-like fashion. To join the network, a node performs\na discovery process to determine a path to its successors in\nthe DHT. Then, the node embeds trails in the network that\npoint back to the joining node's identifier. To route messages, packets are forwarded along these trails. By maintaining trails to each of the node's successors, a node can\nforward a message to any point in the namespace. Users that\n\n3.1 Routing Over Social Networks\nFigure 2 illustrates the design of X-Vine. Our design uses\na VRR-like [12] protocol to construct and maintain state at\nthe overlay layer. Here, we first describe the state maintained by each node, and then describe how that state is\nconstructed and maintained over time.\nState maintained by each node: X-Vine constructs a\nsocial overlay on top of the social network, where a node\nhas direct links to friends, but also maintains \"overlay links\"\nto remote nodes. These remote nodes (overlay endpoints)\nare selected in a manner similar to Chord [55]: each node\n1\nApplications such as Vuze may optionally choose to benefit only from X-Vine's Sybil resilience, and can forgo\npseudonymity by directly transferring files between overlay\nnodes after the lookup operation.\n\n3\n\n\fits join request using the bootstrap node as a proxy. Second, the joining node also needs to build trails to each of\nits endpoints (e.g., its successors). To do this, for each endpoint, it sends a trail construction request to the identifier of\nthat endpoint. As the request is routed, each intermediate\nnode along the path locally stores a record corresponding\nto the trail. Finally, when these steps are completed, the\njoining node can route to any node in the network (by forwarding packets through its endpoints), and it can receive\npackets from any node in the network (by accepting packets\nthrough its endpoints). To maintain this state, we need to\nachieve two things. First, we would like to correctly maintain the set of records along each trail in the presence of\nchurn, so each node can reach the trail endpoint. This is\ndone in a manner similar to AODV [45]: each node along the\npath locally probes its neighbors and removes trail records\n(sending teardown messages upstream if necessary) corresponding to failed trails. Second, we would like to make\nsure each trail points to the corresponding globally correct\nsuccessor/finger. To do this, we leverage the stabilization\nmechanisms from Chord and VRR [12, 55].\n\nFigure 2: Overview of X-Vine.\nis assigned an identifier from a ring namespace, and forms\noverlay links to nodes that are successors (immediately adjacent in the namespace), and (optionally) fingers (spaced\nexponentially around the ring). Unlike Chord however, a\nnode is not allowed to directly send packets to its overlay\nneighbor: for security reasons, nodes only receive packets\nfrom their social network links. Hence, to forward a packet\nfrom a node to one of its overlay endpoints, the packet will\nhave to traverse a path in the social network graph. To\nachieve this, corresponding to each of its overlay endpoints,\na node maintains a trail through the social network. Each\nnode along the trail locally stores a record consisting of four\nfields: the identifiers of the two endpoints of the trail, and\nthe IP addresses of the next and previous hops along the\ntrail. Using this information, a node can send a packet to its\nendpoints, by handing the packet off to the first node along\nthe trail, which looks up the next hop along the trail using\nits trail records, and so on. Furthermore, using a Chordlike routing algorithm, a node can route to any other node\nin the namespace, by (upon reaching an endpoint) selecting\nthe next overlay hop that maximizes namespace progress to\nthe destination (without overshooting). As an optimization,\ninstead of waiting until the endpoint is reached to determine\nthe next overlay hop, intermediate nodes along the path may\n\"shortcut\" by scanning all their trail records, and choosing\nthe endpoint that maximizes progress in the namespace (see\nAlgorithm 1 in Appendix B). If the intermediate node discovers an endpoint that makes more namespace progress to\nthe destination than the current next overlay hop, the intermediate node may choose to forward the packet towards this\nnew endpoint, to speed its progress (while explicitly maintaining the next overlay hop in the packet is not strictly\nnecessary for routing, we do so to simplify parts of our design described later).\nState construction and maintenance: Since nodes can\nroute, we can perform other DHT operations by simply performing routing atop this structure. For example, we can\nexecute a Chord-like join: upon arriving at the network,\na node can route a join request towards its own identifier,\nand the node that receives it can return back the identifiers\nwhich should be the joining node's successors. However,\nthere are two key changes we need to make. First, when a\nnode initially arrives, it does not yet have any trail state and\nhence cannot forward packets. To address this, the joining\nnode randomly selects one of its friends in the social network to act as a bootstrap node. The joining node sends\n\n3.2 Balancing Routing State\nTemporal correlation: while the scheme above is correct,\nit performs poorly in practice. The reason for this is due\nto temporal correlation-since trails are constructed using\nother trails, social network links that are initially chosen to\nbe part of a trail become increasingly likely to be part of later\ntrails. Because of this, nodes that join the network early\ntend to accumulate more state over time. To illustrate this\nproblem, we describe an example. Suppose a node X has d\nfriends a1 , a2 , .., ad . Suppose also that there is a trail from X\nto Y for which the next hop is node ad . Next, suppose node\nX is an intermediate node in a new overlay path that is being\nsetup from node a1 (which is also the previous hop). With\nprobability 2/d, the next hop of the overlay path will be ad .\nSimilarly, in the future, the probability of ad being chosen\nas the next hop in an overlay path increases to 3/(d+1), and\nthen to 4/(d + 2), and so on. This example illustrates that a\nsocial network link that was initially chosen as part of a trail\nhas an increasing chance of being chosen in trails that are\nset up in the future. Consequently nodes that join the social\nnetwork early tend to be part of many trails. This is not\ndesirable from both a security perspective or a performance\nperspective.\nStabilization algorithms: To address the problem of\ntemporal correlation, we propose two modifications to the\ncore X-Vine algorithms: The first algorithm leverages the\nsocial connections of new users to reduce the path lengths\nof existing trails. When a new node joins the system, its\nsocial contacts that are already part of the X-Vine system\nconsider all trails in their routing tables that have a path\nlength greater than a threshold thr 1 (set to the upper quartile of trail path path lengths). Corresponding to each such\ntrail, the social contacts check if modifying the trail via the\nnew node would reduce the path length, and if so, a teardown message is sent to the old trail and another trail via the\nnew node is setup. The threshold on the path length helps\nto avoid needless communication for trails that are already\nshort, and are thus unlikely to benefit much from new edges\nin the social graph topology. The second algorithm helps to\nload balance the routing state at nodes, and also leads to a\nreduction in the path lengths of trails. This algorithm is run\n4\n\n\fsuccessful. C then attempts to select an alternate next hop\nthat makes progress in the namespace (either a route to the\ncurrent next overlay hop, or a \"shortcut\" route that makes\nmore progress than the current next overlay hop). If C does\nnot have such a route, it sends a rejection message back to\nB, which inserts the entry (E, C) in its failed setup list. This\nprocess repeats until a path is discovered, or a time-to-live\n(TTL) contained in the packet is exceeded. When the TTL\nis exceeded, the path setup fails, and the source node must\nattempt to rejoin to establish the path.\n\nFigure 3: Example: backtracking.\nby all nodes whose routing state is greater than a threshold\nthr 2 . Such nodes consider all trails in their routing tables\nwhose path length is greater than a threshold thr 1 (similar\nto the previous algorithm), and send messages to the overlay\nend points to check if alternate trails can be established, and\nif their path length is shorter than the current path length.\nIf a shorter alternate trail exists, then it replaces the existing\ntrail. This helps reduce the routing state size at congested\nnodes, while simultaneously reducing the trail path lengths.\n\n4. SECURING X-VINE\nThe previous section described our approach to perform\nrouting atop the social network. In this section, we describe\nhow to extend and tune the design in the previous section\nto improve its resilience to attack. We start by providing an\noverview of attacks on our design(Section 4.1), and then propose extensions to improve resilience to them (Section 4.2).\n\n3.3 Bounding State With Local Policies\nWe have seen that the shortcut-based routing protocol described in Section 3.1 faces the problem of temporal correlation, leading to unbounded growth in routing state. To complement our stabilization algorithms, we propose a mechanism by which nodes can set a hard bound on their routing\nstate size using local routing policies. These policies can\nbe set to account for heterogeneity across nodes, users' desired degree of participation in the network, and to limit the\nworst-case state overhead at any particular node. Our architecture allows users to set two types of policies pertaining\nto state maintained at their local node:Bounding routes per\nlink: If the number of trails traversing an adjacent social\nnetwork link reaches a threshold bl , then the user's node refuses to set up any more trails traversing that link. Bounding\nroutes per node: If the number of trails traversing the user's\nnode reaches a threshold value bn , then the node refuses to\nset up any more trails via itself. Due to these routing policies, it is possible that a request to set up a trail may be\nunable to make forward progress in the overlay namespace.\nTo address this, we introduce a technique called backtracking\nthat explores alternate social network paths in case an intermediate node refuses to process a path setup request. To do\nthis, each node maintains a failed setup list, containing a list\nof trails that have failed to set up. When a node attempts to\nset up a trail via a next hop, and receives a rejection message\nindicating that the next hop is full, the node inserts an entry\ninto its failed setup list. Each record in the list contains the\nidentifier of the destination overlay endpoint that the packet\nwas traversing towards, and the identifier of the next hop in\nthe social network that rejected the path setup. When forwarding a message to a particular destination endpoint, a\nnode removes from consideration next hops contained in the\nfailed setup list corresponding to that endpoint (see Algorithm 2 in Appendix B). The failed setup list is periodically\ngarbage collected by discarding entries after a timeout.\nFor example (Figure 3), suppose node A wishes to establish a path to E, and determines B is the best next overlay\nhop. A places E into the next overlay hop field in the message, and forwards the message to B. Similarly, B forwards\nthe message to C. Suppose D is congested (has more than\nbn paths traversing it). In this case, C sends the path setup\nmessage to D, but D responds back with a rejection message. C then stores the entry (E, D) in its failed setup list,\nto indicate that establishing a path via D to reach E was un-\n\n4.1 Attacks on the Routing Protocol\nWe investigate defenses to the following attacks on DHTs:\nSybil attack [20]: The attacker can insert a large number of Sybil identities in the DHT, and set up paths with\ntheir successors and predecessors. The attack results in honest nodes' routing tables being populated by malicious Sybil\nidentities. This increases the probability that lookup queries\nwill traverse some malicious nodes, which can then drop or\nmisroute the lookup queries. Observe that to minimize resources, it suffices for Sybil identities to maintain paths with\nonly nodes in the predecessor list, since paths to the nodes\nin the successor list will result in a shortcut to the honest\nsuccessor nodes.\nAttacks on routing table maintenance: In addition\nto the Sybil attack, the adversary could also manipulate the\nrouting table maintenance protocols to increase the probability of malicious nodes being present in honest nodes'\nrouting tables. Intercepting trails: During churn, malicious\nnodes can become part of a large number of trail paths between nodes, in order to attract lookup traffic (for example,\nby refusing to send trail teardown messages). Attacking trail\nconstruction: The attacker could prevent honest nodes from\nfinding a trail path to their correct successor. This could\nbe done by dropping or misrouting the trail setup messages.\nAttacks on message integrity: Malicious nodes that forward\ncontrol traffic could modify the content of the messages, to\ndisrupt trail setup (for example, by creating routing loops).\nForgery attacks: The malicious nodes could spoof source\nidentifiers in messages sent to honest nodes (for example, to\ngive the appearance that the message came from the honest\nnode's friends).\nAttacks on lookups: Once the attacker is able to intercept a lookup query, it can either drop the packet or misroute\nit. Such attacks can prevent the honest nodes from either\ndiscovering their correct successor in the ring, or discovering a malicious successor list set respectively. By advertising malicious nodes as the successors of an honest joining\nnode, a significant fraction of the honest joining node's traffic would traverse malicious nodes. Note that attacks on\nboth overlay construction and overlay routing are captured\nby this attack, since in a DHT, both bootstrap and routing\nare accomplished by the same operation: a lookup.\n5\n\n\f4.2 Proposed Defenses\n\ntrails that traverse a social network link, also defends against\nmalicious nodes that attempt to be a part of a large number\nof trails. Specifically, the adversary has a quota of g *bl trails\nbetween honest nodes and itself, and it can choose to utilize\nthis quota either by inserting Sybil identities in the DHT\nor by being part of trails between two honest nodes. Either\nway, the effect of this attack is limited by the bound bl .\nTrail construction attacks: Suppose that a node X is trying to set up a trail with its overlay neighbor Y. To circumvent the scenario where a malicious intermediate node M\nsimply drops X's path set up request to Y, we propose that\nupon path setup the end point Y sends an acknowledgment\nalong the reverse path back to X. If after a timeout, the\nnode X does not receive an acknowledgment from Y, then\nit can retry sending the trail set up request over a different\nroute. Again, the fast-mixing nature of the social network\ntopology guarantees that two nodes are very likely to have\nmultiple paths between each other.\nMessage integrity and forgery attacks: To provide message integrity is the use of self-certifying identifiers [8,13,34].\nNodes can append their public keys to the message and produce a digital signature of the message along with the appended public key. The self-certifying nature of identifiers\nensures that the public key for a specified node identifier\ncannot be forged; this enables us to provide both message\nintegrity as well as authentication.\nSecuring the lookup protocol: Even if the routing\ntable maintenance protocol is secure, the adversary can still\ndrop or misroute lookup requests that traverse itself. We\nsecure the lookup protocol using redundant routing, similar\nto Castro et al. [14]. Instead of a single lookup, a node can\nchoose to perform r lookups for the destination (where r is\nthe redundancy parameter) using r diverse trusted links in\nthe social network topology. Redundant routing increases\nthe probability that at least one lookup will traverse only\nhonest nodes and find the correct successor. If the lookup\nis performed during route table maintenance, the correct\nsuccessor can be identified since it will be impossible to set\nup a trail to an incorrect one; if the lookup is searching for a\nparticular node or data item, then self-certifying techniques\ncan be used to identify incorrect responses.\n\nWe note that it is imperative to secure both the routing\ntable maintenance and lookup forwarding. If the routing table maintenance protocol were insecure, then the adversary\ncould manipulate the routing table entries of honest nodes\nto point to malicious nodes, and routing to honest nodes\nwould not be successful. However, even if the routing table\nmaintenance mechanisms are secure, the adversary still has\nthe opportunity to drop lookup packets or misroute them.\nMitigating the Sybil attack: To limit the impact of\nthe Sybil attack, we propose that nodes implement a routing policy that bounds the number of trails that traverse a\nsocial network edge. We denote the bound parameter as bl .\nSince the attacker has limited attack edges, this bounds the\nnumber of overlay paths between the honest subgraph and\nthe Sybil subgraph regardless of the attacker strategy. Thus,\nwe limit the number of Sybil identities that are part of the\nhonest node's routing table. The key challenge in this approach is to determine the bound bl that enables most honest\nnodes to set up trails with each other while hindering the\nability of Sybil nodes to join the DHT. Our analytic and\nexperimental results suggest that a bound of bl \u2208 \u0398(log n)\nworks quite well. Similar to Yu et al. [64], we assume that\nthe bound bl is a system wide constant known to all honest nodes. Honest nodes are able to set up trails with each\nother even though there is a bound on the number of trails\nper social network link because of the fast-mixing nature of\nthe social network. On the other hand, a Sybil attack gives\nrise to a sparse cut in the social network topology, and we\nuse this sparse cut to limit the impact of the Sybil identities.\nThe number of overlay paths between the honest and Sybil\nsubgraphs is bounded to g * bl . The adversary could choose\nto allocate each overlay path to a different Sybil identity,\nresulting in g * bl Sybil identities in the DHT (in the routing\ntables of honest nodes). We can further limit the number\nof Sybil identities in the routing tables of honest nodes by\nensuring that the adversary must allocate at least a threshold t number of overlay paths per Sybil identity. This would\nbound the number of Sybil identities in honest nodes routing\ntables to g * bl /t. Note that the number of overlay paths between the honest and Sybil regions does not change. We propose the following mechanism to ensure that the adversary\nsets up trails with at least a threshold t overlay neighbors.\nNodes periodically probe their overlay neighbors to check if\neach successor in their routing table has set up a trail with\nat least t other nodes in the overlay neighborhood. Note\nthat the check is performed by directly querying the overlay\nneighbors. The threshold t is set to t < 2 * num successors\nto account for malicious overlay nodes returning incorrect\nreplies. If the adversary does not allocate t trails per Sybil\nidentity (set up with its successors and predecessors), the\nhonest nodes can detect this via probing and can teardown\nthe trails to the malicious Sybil identity. Note that the adversary cannot game the probing mechanism unless it has\na large number of Sybil identities in the overlay neighborhood of a node. Since the Sybil identities are distributed at\nrandom in the overlay namespace, this is unlikely to happen unless the adversary has a large number of attack edges\n(g \u2208 \u03a9(n/(log n))).\nSecuring routing table maintenance: We provide the\nfollowing defenses to attacks on routing table maintenance:\nTrail interception attacks: Observe that our mechanism to\ndefend against Sybil attacks, i.e., bounding the number of\n\n4.3 Privacy Protection\nAll communication in X-Vine happens over social network\nlinks; while a user's IP address is revealed to his/her social\ncontacts, it is not exposed to random peers in the network.\nTherefore as long as a user's social contacts are trusted,\nhe/she can communicate pseudonymously. Moreover, observe that X-Vine's mechanisms do not require a user to\nexpose his/her social contacts. This is in sharp contrast to\nprior work [30], wherein this information is revealed as part\nof protocol operations to everyone in the network. Note that\nin the absence of a mapping from a DHT ID to an IP address,\nthe adversary cannot perform traffic analysis to infer social\ncontacts. The only source of information leakage is when\nthe adversary can map DHT IDs of two users to their respective IP addresses (for example, by virtue of being their\ntrusted contacts); in this case the adversary can perform\ntraffic analysis attacks to infer whether the two users have\na trust relationship or not. In X-Vine, the privacy risk is\nwith respect to social contacts, rather than random peers in\nthe network. Note that in this paper, we are only concerned\nwith overlay level adversaries; adversaries which operate at\n6\n\n\fthe ISP level, or have external sources of information [43]\nare outside the scope of our threat model.\n\n5.\n\nTable 1: Topologies\n\nEXPERIMENTS AND ANALYSIS\n\nWe evaluate X-Vine with theoretical analysis, experiments\nusing real-world social network topologies, and a prototype\nimplementation. We measure routing state size, lookup path\nlengths, security against Sybil attacks, resilience against churn,\nand lookup latency. We also developed a Facebook application to facilitate the use of our design.\nSimulation environment: We constructed an in-house\nevent-driven simulator. As done in [12], we bootstrap XVine by selecting a random node in the social network as\nthe first node, and the social network neighbors of that node\nthen become candidates to join the X-Vine network. Next,\none of these neighbors is selected to join, with a probability\nproportional to the number of trust relationships it has with\nnodes that are already a part of the X-Vine network. This\nprocess is then repeated. Note that some nodes may not\nbe successful in joining because of the bound on number of\ntrails per link (as discussed in detail later).\nData sets: Recent work has proposed the use of interaction graphs [58, 62] as a better indicator of real world trust\nthan friendship graphs. Hence we consider both traditional\nsocial network graph topologies as well as interaction graph\ntopologies in our evaluation. The datasets that we use have\nbeen summarized in Table 1.\nFacebook friendship graph from the New Orleans regional\nnetwork [58]: The original dataset consists of 60 290 nodes\nand 772 843 edges. We processed the dataset in a manner\nsimilar to the evaluation done in SybilLimit [64] and SybilInfer [19], by imposing a lower bound of 3 and an upper\nbound of 100 on the node degree (see [19, 64] for details) 2 .\nAfter processing, we are left with 50 150 nodes and 661 850\nedges.\nFacebook wall post interaction graph from the New Orleans\nregional network [58]: The original dataset consists of 60 290\nusers. After processing, we are left with 29 140 users and\n161 969 edges. Note that links in this dataset are directed,\nand we consider an edge between users only if there were\ninteractions in both directions.\nFacebook interaction graph from a moderate-sized regional 3\nnetwork [62]: The dataset consists of millions of nodes and\nedges, but our experiments are memory limited and do not\nscale to millions of nodes. Instead, we first truncate the\ndataset by considering only a four hop neighborhood from a\nseed node. After processing, we are left with 103 840 nodes\nand 961 418 edges.\nSynthetic scale-free graphs: Social networks exhibit a scalefree node degree topology [49]. Our network synthesis algorithm replicates this structure through preferential attachment, following the methodology of Nagaraja [41]. The use\nof synthetic scale free topologies enables us evaluate X-Vine\nwhile varying the number of nodes in the network.\n\nDataset\n\nNodes\n\nEdges\n\nNew Orleans Facebook\nFriendship graph\nNew Orleans Facebook\nInteraction graph\nAnonymous\nFacebook\nInteraction graph\n\n50 150\n\n661 850\n\nMean\nDegree\n26.39\n\n29 140\n\n161 969\n\n11.11\n\n103 840\n\n961 418\n\n18.51\n\nOverhead: Figure 4 plots the routing table size for different successor list sizes. We can see the temporal correlation effect here, as the distribution of state shows superexponential growth. Temporal correlation is highly undesirable both from a performance and a security standpoint. If\nthe few nodes with very large state become unavailable due\nto churn, the network could get destabilized. Moreover, if\none of these nodes is malicious, it could easily intercept a\nlarge number of lookups and drop them. To address this, we\nenable the routing policy that bounds the number of paths\ntraversing nodes and links. Based on our analytic model in\nAppendix A, we propose the following bound on the number of paths per link: bl = \u03b1 * 2 * num successors * log(n),\nwhere \u03b1 is a small fixed constant. The bound per link ensures that if a node has degree d, then its routing table size\nwill never exceed d * bl \u2208 O(log n). We can see that the\nrouting state does not undergo an exponential increase as\nin previous plots. Moreover, routing state increases with\nnode degrees, which is desirable. Based on these routing\ntable sizes, we can estimate the communication overhead of\nX-Vine by computing the cost of sending heartbeat traffic\nfor all records in the routing table. Considering the routing table size to be 125 records, UDP ping size to be 40\nbytes, and a heartbeat interval of 1 s, the estimated mean\ncommunication overhead is only 4.8 KBps.\nComparison with Whanau [30]: Routing state in Whanau\ndepends on the number of objects stored\nin the DHT. Rout\u221a\ning tables in Whanau are of size \u0398( no log no ), where no is\nthe number of objects in the DHT. If there are too many\nobjects stored in the DHT, Whanau resorts to maintaining\ninformation about all the nodes and edges in the social network (increasing state/overhead to \u0398(n)). If there are too\nfew objects in the DHT, Whanau resorts to flooding to find\nobjects [30]. We note that such properties make Whanau\nunsuitable for many common applications. Even if we consider the case where each node in the DHT stores only tens\nof objects, the average routing table size in Whanau for the\n103 840 node anonymous interaction graph is about 20 000\nrecords-an increase of more than two orders of magnitude\nas compared with X-Vine. If we consider a heartbeat interval of 1 second in Whanau (in order to accurately maintain object states for common DHT applications), the resulting communication overhead is about 800 KBps. This\ndifference increases further with an increase in the number\nof objects in the DHT or the size of the network. For instance, we scaled up our experiments to a larger 613 164 node\nanonymous interaction graph topology using a machine with\n128 GB RAM, and found that the average routing state in XVine using a successor list size of 10 was only 195 records, as\ncompared with more than 50 000 records in Whanau. (Note\nthat routing state in X-Vine is independent of the number\nof objects in the DHT.)\n\n2\nRecent work by Mohaisen et al. [40] shows that social networks may not be as fast mixing as previously believed.\nHowever, we note that their results do not directly apply\nto X-Vine since they did not consider node degree bounds\nin their analysis. X-Vine excludes users having few friends\nfrom participating in the routing protocol, though such users\ncould use their trusted friends to lookup keys.\n3\nBecause of privacy reasons, the name of the regional network has been left anonymous by the authors of [62].\n\n7\n\n\f100000\n\n10000\n1000\n100\n10\n1\n\n100000\nsucc=1\nsucc=5\nsucc=10\n\n10000\n\nRouting table size\n\nsucc=1\nsucc=5\nsucc=10\n\nRouting table size\n\nRouting table size\n\n100000\n\n1000\n100\n10\n1\n\n0\n\n10000\n\n20000\n\nsucc=1\nsucc=5\nsucc=10\n\n10000\n1000\n100\n10\n1\n\n0\n\n20000\n\nNode index\n\n40000\n\n0\n\n25000\n\nNode index\n\n(a)\n\n50000\n\n75000\n\n100000\n\nNode index\n\n(b)\n\n(c)\n\nFigure 4: Routing state, with no bounds on state: (a) New Orleans Interaction graph, (b) New Orleans\nFriendship graph, and the (c) Anonymous Interaction graph. Due to temporal correlation, some nodes\nexhibit high state requirements.\n100000\n\n10000\n1000\n100\n10\n1\n\n100000\nsucc=1\nsucc=5\nsucc=10\nDegree\n\n10000\n\nRouting table size\n\nsucc=1\nsucc=5\nsucc=10\nDegree\n\nRouting table size\n\nRouting table size\n\n100000\n\n1000\n100\n10\n1\n\n0\n\n10000\n20000\nNode index\n\nsucc=1\nsucc=5\nsucc=10\nDegree\n\n10000\n1000\n100\n10\n1\n\n0\n\n(a)\n\n20000\nNode index\n\n(b)\n\n40000\n\n0\n\n25000\n\n50000 75000\nNode index\n\n100000\n\n(c)\n\nFigure 5: Routing state, with node and edge bounds: (a) New Orleans Interaction graph, (b) New Orleans\nFriendship graph, and (c) Anonymous Interaction graph. Bounding state significantly reduces state requirements. Using a successor list of size 5, the average routing state for the three topologies is 67, 81, and 76\nrecords respectively. X-Vine requires orders of magnitude less state than Whanau [30].\nthan 15 hops. Increasing the successor list size to 20 (and\nkeeping r = 10) reduces this value to less than 11.5 for all\ndatasets.\nSecurity under Sybil Attack: Recall that if the adversary has g attack edges, then the number of trails between\nthe honest and the Sybil subgraph is bounded by g * bl (regardless of the attacker strategy). Our attack methodology\nis as follows: we randomly select a set of compromised nodes\nuntil the adversary has the desired number of attack edges.\nThe compromised nodes then launch a Sybil attack, and set\nup trails between Sybil identities and their overlay neighbors. If the trail set up request starting from a Sybil node\ngets shortcutted back to the Sybil identities, the request is\nbacktracked. This ensures that the adversary uses only a\nsingle attack edge per trail. Node identifiers of Sybil identities are chosen at random with the adversarial goal of intercepting as many lookups as possible. All lookups traversing\ncompromised/Sybil nodes are considered unsuccessful.\nFigure 6 plots the probability of a secure lookup as a function of number of attack edges, redundancy parameter, and\nsize of successor list. We find that the probability of secure lookup increases as the redundancy parameter is increased. This is because as the number of redundant lookups\nincreases, there is a greater chance that a lookup will traverse only honest nodes and return the correct result. We\nalso find that the probability of secure lookup also increases\nwhen the size of the successor list increases. This is because\nincreasing successor list size reduces the mean lookup path\n\nFalse Positive Analysis: Next, we consider the impact of\nlink/node path bounds on honest node's ability to join the\nDHT. We found that most honest nodes were able to join\nthe DHT due to the fast mixing nature of honest social networks. In fact, for all our experimental scenarios, the falsepositive rate was less than 0.5%, which is comparable to the\nstate-of-the-art systems [19, 64]. By tuning the parameter\nbl , it is possible to trade off the false-positive rate for Sybil\nresilience: bl will reduce the false-positive rate at the cost of\nincreasing the number of Sybil identities in the system. For\nthe remainder of the paper, we shall use \u03b1 = 1, \u03b2 = 5.\nPath Length Analysis: Table 2 depicts the mean lookup\npath lengths for the real world datasets with varying successor list sizes and varying redundancy parameter. We first\nobserve that lookup performance improves with increasing\nsuccessor list sizes. For example, in the New Orleans interaction graph, the mean lookup path length decreases from\n97.9 to 15.4 when the successor list size increases from 1 to\n20 (using r = 1). Further improvements in performance can\nbe realized by performing redundant lookups as described\nin Section 4 and caching the lookup with the smallest path\nlength. We can see that in the same dataset, mean lookup\npath length decreases from 15.4 to 10.3 when the redundancy\nparameter is increased from r = 1 to r = 5 (using successor\nlist of size 20). Further increases in redundancy show diminObserve that when the successor list size\nishing returns.\nis at least 10, and the redundancy parameter is at least 10,\nthen the mean lookup path lengths for all datasets are less\n\n8\n\n\fTable 2: Mean Lookup Path Length\nNew Orleans interaction graph\nr=1\nr=5\nr = 10\n97.9\n57.7\n51.7\n30.0\n18.2\n16.8\n20.2\n13.0\n12.16\n15.4\n10.3\n9.6\n\n1\n\nProbability of Secure Lookup\n\nProbability of Secure Lookup\n\n1\n5\n10\n20\n\n0.98\n0.96\n0.94\n0.92\n0.9\n\nr=2, succ=10\nr=5, succ=10\nr=2, succ=20\nr=5, succ=20\n\n0.88\n0.86\n0\n\n500\n\n1000\n\n1500\n\nNew Orleans friendship graph\nr=1\nr=5\nr = 10\n103.6\n57.5\n48.1\n34.8\n19.3\n16.7\n23.1\n13.7\n12.1\n17.0\n10.7\n9.45\n\n1\n0.98\n0.96\n0.94\n0.92\n0.9\n\nr=2, succ=10\nr=5, succ=10\nr=2, succ=20\nr=5, succ=20\n\n0.88\n0.86\n\n2000\n\n0\n\n1000\n\nAnonymous interaction graph\nr=1\nr=5\nr = 10\n166.7\n96.3\n81.0\n48.9\n25.5\n21.7\n29.9\n16.9\n14.8\n21.0\n12.8\n11.3\n\nProbability of Secure Lookup\n\n# Succ\n\n2000\n\n3000\n\n4000\n\n5000\n\n1\n0.98\n0.96\n0.94\n0.92\n0.9\n\nr=2, succ=10\nr=5, succ=10\nr=2, succ=20\nr=5, succ=20\n\n0.88\n0.86\n0\n\n2000\n\n4000\n\n6000\n\nAttack Edges\n\nAttack Edges\n\nAttack Edges\n\n(a)\n\n(b)\n\n(c)\n\n8000\n\n10000\n\nCDF\n\nFigure 6: Probability of secure lookup as a function of number of attack edges for (a) New Orleans interaction\ngraph, (b) New Orleans friendship graph, and (c) Anonymous Interaction graph.\n1\n0.9\n0.8\n0.7\n0.6\n0.5\n0.4\n0.3\n0.2\n0.1\n0\n100\n\nnetwork. We used a synthetic scale free graph as the social network topology. The duration of the experiment was\nset to 1 hour, and nodes performed lookups every 1 second. Figure 8 depicts the CDF of observed one-way lookup\nlatencies. We can see that the median lookup latency was\nonly 400 ms (as compared to 200 ms in Chord), for the mean\nlookup path length of 5 hops (not shown in the Figure). Using these values, we can estimate the median lookup latency\nfor mean lookup path lengths of 10 hops and 15 hops (that\nwere observed in our experiments over real world social network topologies in Table 2) to be about 800 ms and 1200 ms\nrespectively. We see some outliers in Figure 8 due to the\npresence of a few slow/unresponsive nodes in PlanetLab. For\nthis experiment, we mapped vertices in the social network\ntopology to random PlanetLab nodes (possibly in different\ngeographic locations). Thus, our analysis is conservative; accounting for locality of social network contacts would likely\nimprove the lookup performance.\nFacebook Application: To bootstrap a X-Vine node,\nits user needs to input the IP addresses of his/her friends.\nSince this can be a cumbersome for a user, we implemented a\nFacebook application (available at http://apps.facebook.\ncom/x--vine) that automates this process and improves the\nusability of our design. The work flow of the application is\nas follows: (i) When a user visits the Facebook application\nURL, Facebook checks the credentials of the user, the user\nauthorizes the application, and then the request gets redirected to the application hosting server. (ii) The application\nserver authenticates itself, and is then able to query Facebook for user information. The application server records\nthe user information along with the user IP address. (iii)\nThe application server then queries Facebook for a list of\nuser's friends, and returns their previously recorded IP addresses (if available) to the user.\nThis list of IP addresses could then be used by the DHT\nsoftware to bootstrap its operations. Our implementation\ndemonstrates that a user's social contacts can be integrated\ninto the DHT protocol using only a few hundred lines of glue\ncode. Keeping in spirit with our fully decentralized design\ngoal, in future, our application could be implemented on a\ndecentralized platform like Diaspora [1] such that the app\n\nX-Vine\nChord\n\n1000\nLatency (ms)\n\n10000\n\nFigure 8: Lookup latency\nlength, reducing the probability that an adversary can intercept the lookup query. As long as g \u2208 o(n/(log n)), the\nprobability of secure lookup can be made arbitrarily high by\nincreasing the redundancy parameter and the successor list\nsize. Finally, reducing bl would further limit the impact of\nSybil identities, at the cost of increased false positives.\nChurn Analysis: Next, we evaluate the performance of\nX-Vine under churn. We are interested in the static resilience of X-Vine, i.e., the probability of lookup success after a fraction of the nodes in the system fail simultaneously.\nTo account for churn, we modified the lookup algorithm to\nbacktrack whenever it cannot make forward progress in the\noverlay namespace. Figure 7 depicts the mean probability\nof lookup success as a function of the fraction of nodes that\nfail simultaneously, averaged over 100 000 lookups. Similar\nto the analysis of lookup security, we can see that an increase\nin either the redundancy parameter or the successor list size\nresult in improved resilience against churn. We can also see\nthat as the fraction of failed nodes increases, the probability\nof lookup success decreases, but is still greater than 0.95 for\nall scenarios using r = 4 and succ = 20.\nPlanetLab Implementation: To validate our design and\nevaluate lookup latency in real-world environments, we implemented the X-Vine lookup protocol in C++ as a singlethreaded program using 3 000 LOC. We used libasync [5, 6]\nand Tame [28] to implement non-blocking socket functionality (UDP) in an event-based fashion. We ran our implementation over 100 randomly selected nodes in the PlanetLab\n9\n\n\f0.94\n0.92\nsucc=10, r=1\nsucc=10, r=4\nsucc=20, r=1\nsucc=20, r=4\n\n0.9\n0.88\n0.86\n0\n\n2\n\n4\n\n6\n\n8 10 12 14 16 18 20\n\nPercentage of failed nodes\n\n(a)\n\n1\n\nProbability of successful lookup\n\n0.96\n\nProbability of successful lookup\n\nProbability of successful lookup\n\n1\n0.98\n\n0.98\n0.96\n0.94\n0.92\nsucc=10, r=1\nsucc=10, r=4\nsucc=20, r=1\nsucc=20, r=4\n\n0.9\n0.88\n0.86\n0\n\n2\n\n4\n\n6\n\n8 10 12 14 16 18 20\n\nPercentage of failed nodes\n\n(b)\n\n1\n0.95\n0.9\n0.85\n0.8\nsucc=10, r=1\nsucc=10, r=4\nsucc=20, r=1\nsucc=20, r=4\n\n0.75\n0.7\n0.65\n0\n\n2\n\n4\n\n6\n\n8 10 12 14 16 18 20\n\nPercentage of failed nodes\n\n(c)\n\nFigure 7: Lookup resilience against churn: (a) New Orleans Interaction graph, (b) New Orleans Friendship\ngraph, and (c) Anonymous Interaction graph.\nserver is not a central point of trust or failure.\n\n6.\n\nDHT functionality.\nWhanau [30] is the state of art Sybil resilient DHT [18,29]\nwhere nodes can communicate\nwith only one intermediate\n\u221a\nhop. Each node performs e random walks to sample nodes\nfor construction of their routing tables ; the Sybil resistant\nproperty of short random walks ensures that a high fraction\nof the sampled nodes are honest . By querying routing table\nentries, nodes can construct their successor lists. As compared to X-Vine,\u221aWhanau provides its properties at the cost\nof maintaining no log no state at each node (where no is\nthe number of objects). The large state requirements mean\nthat the system has difficulty maintaining accurate state in\nface of object churn. Whanau also requires the entire social\ngraph to be public, presenting significant privacy concerns.\nIn contrast, X-Vine builds upon network-layer DHTs, embedding the DHT directly into the social network fabric.\nThis enables X-Vine to provide good security while achieving improved scalability and privacy of social relationships.\nMoreover, X-Vine provides support for pseudonymous communication.\nThe concept of a bottleneck cut between a fast-mixing\nsocial network and Sybil nodes has been used in a number\nof other systems, such as SumUp [56], a protocol for online\ncontent rating that is resilient to Sybil attacks; Ostra [37],\na system to prevent unwanted communication from nodes;\nand Kaleidoscope [54], a system for censorship resistance.\nSecurity and privacy in DHTs: Other work deals with\nthe issue of secure routing when a fraction of nodes in the\nDHT are compromised [14,27,42,53,59]. Sit and Morris [53],\nas well as Wallach [59] discuss security issues in DHTs. Castro [14] proposed the use of redundant routing to improve\nthe lookup security. Nambiar and Wright [42] showed that\nredundant lookups in Chord may traverse a few common\nnodes, and thus a few malicious nodes could subvert all of\nthe redundant lookups. They designed the Salsa DHT in\nwhich redundant lookups are unlikely to traverse common\nnodes. Kapadia and Triandopoulos [27] propose to make redundant routes diverse by making use of the observation that\nto perform a lookup for A, it suffices to lookup the nodes\nwhich have A as its finger, and then query them. Unlike\nX-Vine these systems are not concerned with the problem\nof Sybil attacks. Another line of research deals with the\nprivacy of the DHT lookup. Borisov [10] as well as Ciaccio [16] proposed to incorporate anonymity into the lookup,\nbut their algorithms do not consider active attacks. More\nrecently, anonymous and secure lookups were considered in\nthe designs of Salsa [42], NISAN [44], and Torsk [35]. However, recent work [38, 61] showed vulnerabilities in all the\nthree designs. X-Vine improves the privacy of a user by en-\n\nRELATED WORK\n\nX-Vine provides multi-hop social network routing, logarithmic state Sybil defense, protects privacy of friendship information, and enables pseudonymous communication. Our\nwork is the first to provide these properties. However, XVine builds upon foundational work in several areas:\nSybil defense:\nSybil defenses must fundamentally impose a cost on participation in the network [20]. One approach, advocated by Castro et al. [14], requires users to\nprovide identity credentials and/or payment to a centralized authority, who then issues certificates allowing users\nto participate. This authority, of course, becomes a central\npoint of trust. Decentralized approaches instead allow nodes\nto directly verify some resource expenditure by other nodes,\nsuch as CPU computation, or the possession of a unique IP\naddress [11, 51]. All these solutions face a tradeoff between\ncreating too high a barrier for participation by honest users\nand making it too easy for malicious users to create Sybil\nidentities. More recent work has recognized that it is expensive for a malicious adversary to establish trust relationships\nwith honest users and thus social network topologies can be\nused to detect and mitigate social Sybil attacks. The design\nof X-Vine is based upon the same principle.\nSybilGuard [65] and SybilLimit [64] are decentralized systems for Sybil defense. These systems use special random\nwalks called random routes for Sybil defense. In SybilLimit,\nas long\u0010as the\u0011number of attack edges is less than a threshold\n(g = o logn n ), then with high probability, a short random\nwalk of O(log n) steps is likely to stay within\n\u221a the set of honest nodes. Nodes in SybilLimit perform e short random\nwalks (where e is the number of edges amongst the honest\nnodes) and keep track of their last edges (tails). By the\nbirthday paradox, two honest nodes will share a common\ntail with high probability. Each node allows only a certain\nnumber of random routes to traverse it, thereby limiting the\nnumber of Sybil identities that are validated by the honest\nnodes.\nSybilInfer [19] provides an algorithm for labeling nodes\nin a social network as honest users or Sybils controlled by\nan adversary. It takes as an input a social graph G, and\ngenerates a set of traces using short random walks. Using\na mathematical model of an honest social network, it performs Bayesian inference to output a set of dishonest nodes.\nThe Bayesian inference approach can even be used to assign\nprobabilities to nodes of being honest or dishonest. These\nsystems are standalone Sybil defenses and do not provide a\n10\n\n\fsystems [18], and that defending multi-hop DHTs against\ntargeted clustering attacks is currently an open problem. In\nfuture work, we will investigate the possibility of adapting\nthe cuckoo hashing mechanism [29] proposed by LesniewskiLaas (for one-hop DHTs) in the context of securing multihop DHTs. X-Vine also does not defend against attackers\nwho target users by compromising nodes close to them in the\nsocial network topology. Finally, applications using X-Vine\nexperience higher than usual latencies since all communications are pseudonymous and traverse multiple social network\nlinks.\n\nabling pseudonymous communication; the IP address of a\nuser is revealed only to a user's trusted friends.\nSocial networks and routing:\nThe benefits of using\nsocial network links for overlay routing has been recognized\nin a large body of academic work as well as deployed systems.\nHybrid routing using social network links: Systems in this\nclass maintain traditional peer-to-peer structures but also\nmake use of social network connections. Sprout [32] proposed augmenting the finger tables in traditional DHTs,\nsuch as Chord, with social network links. The authors showed\nthat the added connections could improve the security of\nthe routing mechanism. However, Sprout does not defend\nagainst Sybil attacks, and is not concerned with user privacy. OneSwarm [26] is a deployed peer-to-peer communication system for improving user privacy where routing is\nperformed by combining trusted and untrusted peer relationships. Tribler [47] increases download speed in BitTorrent by discovering and downloading file chunks stored at\npeers. Similarly, Maze [15] leverages a social network to discover peers and cooperatively download files. These three\nsystems leverage flooding to provide any-to-any reachability, and thus cannot scale to large networks. The hybrid\nsystems are not resilient to Sybil attacks. Moreover, they\nallow direct contacts over untrusted links, exposing users'\nIP addresses.\nRouting only using social network links: All communication\nin this class of systems is over social network links. This\nenables participants in the network to be hidden from each\nother, providing a high degree of privacy. Such a network\nis commonly known as a darknet. WASTE [22] is a deployed decentralized chat, instant messaging, and file sharing protocol, and is widely considered to be the first darknet.\nWASTE does not attempt to scale beyond small networks,\nand its suggested size is limited to 50 users. Turtle [46] is\na deployed decentralized anonymous peer-to-peer communication protocol. Nodes in Turtle do not maintain any state\ninformation other than their trusted friend links and use\ncontrolled flooding to search for data items. Flooding methods create significant overhead as network size increases.\nFreenet [17] is a deployed decentralized censorship-resistant\ndistributed storage system. Version 0.7 of Freenet nodes can\nbe configured to run in darknet or opennet mode; the latter\nallows connections from untrusted nodes, and is expected\nto be used by less privacy-sensitive users. Freenet's routing algorithm is heuristic and does not guarantee that data\nwill be found at all; it has also been shown to be extremely\nvulnerable even against a few malicious nodes [21]. Membership concealing overlay networks (MCONs) (formalized\nby Vasserman et al. [57]), hide the real-world identities of\nthe participants through the use of overlay and DHT-based\nrouting. However, their design makes use of a trusted centralized server and also requires flooding when a new user\njoins the network. In addition to these limitations, none of\nthe above systems are resilient to Sybil attacks.\n\n7.\n\n8. CONCLUSIONS\nWe describe X-Vine, a protection mechanism for DHTs\nthat operates entirely by communicating over social network links. X-Vine requires O(log n) state, two orders of\nmagnitude less in practical settings as compared with existing techniques, making it particularly suitable for large-scale\nand dynamic environments. X-Vine also enhances privacy\nby not revealing social relationship information and by providing a basis for pseudonymous communication.\n\n9. REFERENCES\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n[8]\n\n[9]\n\n[10]\n[11]\n[12]\n\n[13]\n\n[14]\n\n[15]\n\nLIMITATIONS\n\n[16]\n\nWe now discuss some limitations of our design. First,\nX-Vine requires a user's social contacts to be part of the\noverlay; the DHT needs to be bootstrapped from a single\ncontiguous trust network. Next, X-Vine assumes that Sybil\nidentities are distributed randomly in the DHT identifier\nspace. We emphasize that this assumption is shared by prior\n\n[17]\n\n11\n\nDiaspora. wwww.joindiaspora.com/.\neMule. http://www.emule-project.net/.\nFacebook. www.facebook.com.\nLivejournal. www.livejournal.com.\nSfslite. http://www.okws.org/doku.php?id=sfslite.\nUsing libasync.\nhttp://pdos.csail.mit.edu/6.824-2004/async/.\nThe Vuze Network. http://www.vuze.com/.\nD. G. Andersen, H. Balakrishnan, N. Feamster,\nT. Koponen, D. Moon, and S. Shenker. Accountable\nInternet protocol. In SIGCOMM, 2008.\nK. Bauer, D. Mccoy, D. Grunwald, and D. Sicker.\nBitstalker: Accurately and efficiently monitoring\nbittorent traffic. In Proceedings of the International\nWorkshop on Information Forensics and Security,\n2009.\nN. Borisov. Anonymous routing in structured\npeer-to-peer overlays. PhD thesis, UC Berkeley, 2005.\nN. Borisov. Computational puzzles as sybil defenses.\nIn IEEE P2P, 2006.\nM. Caesar, M. Castro, E. Nightingale, A. Rowstron,\nand G. O'Shea. Virtual Ring Routing: Network\nrouting inspired by DHTs. In SIGCOMM, 2006.\nM. Caesar, T. Condie, J. Kannan,\nK. Lakshminarayanan, and I. Stoica. ROFL: Routing\non Flat Labels. In SIGCOMM, September 2006.\nM. Castro, P. Druschel, A. Ganesh, A. Rowstron, and\nD. S. Wallach. Secure routing for structured\npeer-to-peer overlay networks. In OSDI, 2002.\nH. Chen, X. Li, and J. Han. Maze: a social\npeer-to-peer network. In In of CEC-East, 2004.\nG. Ciaccio. Improving sender anonymity in a\nstructured overlay with imprecise routing. In PETS,\nJune 2006.\nI. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.\nFreenet: A distributed anonymous information storage\nand retrieval system. In DPET, July 2000.\n\n\f[42] A. Nambiar and M. Wright. Salsa: a structured\napproach to large-scale anonymity. In CCS, pages\n17\u201326, New York, NY, USA, 2006. ACM.\n[43] A. Narayanan and V. Shmatikov. De-anonymizing\nsocial networks. In IEEE S & P, 2009.\n[44] A. Panchenko, S. Richter, and A. Rache. NISAN:\nnetwork information service for anonymization\nnetworks. In CCS, 2009.\n[45] C. Perkins, E. Belding-Royer, and S. Das. Ad hoc\non-demand distance vector (AODV) routing, 2003.\n[46] B. Popescu, B. Crispo, and A. S. Tanenbaum. Safe\nand private data sharing with Turtle: Friends team-up\nand beat the system. In 12'th Cambridge International\nWorkshop on Security Protocols, April 2004.\n[47] J. Pouwelse, P. Garbacki, J. Wang, A. Bakker,\nJ. Yang, A. Iosup, D. Epema, M. Reinders, M. van\nSteen, and H. Sips. Tribler: A social-based\npeer-to-peer system. Technical report, Delft University\nof Technology, Feb 2006.\n[48] S. Ratnasamy, P. Francis, M. Handley, and R. Karp.\nA scalable content-addressable network. In\nSIGCOMM, August 2001.\n[49] M. Ripeanu, A. Iamnitchi, and I. Foster. Mapping the\nGnutella network. IEEE Internet Computing, 2002.\n[50] T. Ristenpart, G. Maganis, A. Krishnamurthy, and\nT. Kohno. Privacy-preserving location tracking of lost\nor stolen devices: cryptographic techniques and\nreplacing trusted third parties with DHTs. In\nUSENIX Security, 2008.\n[51] H. Rowaihy, W. Enck, P. McDaniel, and T. L. Porta.\nLimiting sybil attacks in structured p2p networks. In\nINFOCOM, 2007.\n[52] A. Rowstron and P. Druschel. Pastry: scalable,\ndecentralized object location and routing for\nlarge-scale peer-to-peer systems. In ACM Middleware,\nNovember 2001.\n[53] E. Sit and R. Morris. Security considerations for\npeer-to-peer distributed hash tables. In IPTPS, 2002.\n[54] Y. Sovran, J. Li, and L. Subramanian. Unblocking the\ninternet: Social networks foil censors. Technical\nreport, NYU, 2008.\n[55] I. Stoica, R. Morris, D. Karger, M. Kaashoek, and\nH. Balakrishnan. Chord: a scalable peer-to-peer\nlookup service for Internet applications. In\nSIGCOMM, 2001.\n[56] N. Tran, B. Min, J. Li, and L. Subramanian.\nSybil-resilient online content voting. In NSDI, pages\n15\u201328, 2009.\n[57] E. Vasserman, R. Jansen, J. Tyra, N. Hopper, and\nY. Kim. Membership-concealing overlay networks. In\nCCS, pages 390\u2013399, 2009.\n[58] B. Viswanath, A. Mislove, M. Cha, and K. P.\nGummadi. On the evolution of user interaction in\nFacebook. In WOSN, 2009.\n[59] D. Wallach. A survey of peer-to-peer security issues.\nIn International Symposium on Software Security,\nTokyo, Japan, 2002.\n[60] P. Wang, J. Tyra, E. Chan-Tin, T. Malchow, D. F.\nKune, N. Hopper, and Y. Kim. Attacking the Kad\nnetwork. In SecureComm, 2008.\n[61] Q. Wang, P. Mittal, and N. Borisov. In search of an\n\n[18] G. Danezis, C. Lesniewski-Laas, M. F. Kaashoek, and\nR. Anderson. Sybil-resistant DHT routing. In\nESORICS, Milan, Italy, September 2005.\n[19] G. Danezis and P. Mittal. SybilInfer: Detecting sybil\nnodes using social networks. In NDSS, 2009.\n[20] J. Douceur. The Sybil Attack. In IPTPS, March 2002.\n[21] N. S. Evans, C. GauthierDickey, and C. Grothoff.\nRouting in the dark: Pitch black. ACSAC, 2007.\n[22] J. Frankel. http://waste.sourceforge.net.\n[23] M. J. Freedman, E. Freudenthal, and D. Mazi\u00e8res.\nDemocratizing content publication with Coral. In\nNSDI, 2004.\n[24] M. J. Freedman and R. Morris. Tarzan: a peer-to-peer\nanonymizing network layer. In CCS, 2002.\n[25] R. Geambasu, T. Kohno, A. A. Levy, and H. M. Levy.\nVanish: increasing data privacy with self-destructing\ndata. In USENIX Security, 2009.\n[26] T. Isdal, M. Piatek, A. Krishnamurthy, and\nT. Anderson. Privacy-preserving p2p data sharing\nwith oneswarm. In SIGCOMM, 2010.\n[27] A. Kapadia and N. Triandopoulos. Halo:\nHigh-assurance locate for distributed hash tables. In\nNDSS, 2008.\n[28] M. Krohn, E. Kohler, and M. F. Kaashoek. Events\ncan make sense. In USENIX ATC, 2007.\n[29] C. Lesniewski-Laas. A Sybil-proof one-hop DHT. In\nSocialNets, pages 19\u201324, 2008.\n[30] C. Lesniewski-Laas and M. F. Kaashoek.\nWhanaungatanga: A Sybil-proof distributed hash\ntable. In NSDI, 2010.\n[31] M. Liberatore, B. N. Levine, and C. Shields.\nStrengthening forensic investigations of child\npornography on p2p networks. In CONEXT, 2010.\n[32] S. Marti, P. Ganesan, and H. Garcia-Molina.\nSPROUT: P2P routing with social networks. In\nP2P&DB, 2004.\n[33] P. Maymounkov and D. Mazi\u00e8res. Kademlia: A\npeer-to-peer information system based on the xor\nmetric. In IPTPS, 2002.\n[34] D. Mazieres. Self-certifying file system. PhD thesis,\nMIT, 2000. Supervisor-Kaashoek, M. Frans.\n[35] J. McLachlan, A. Tran, N. Hopper, and Y. Kim.\nScalable onion routing with Torsk. In CCS, 2009.\n[36] E. Miluzzo, N. D. Lane, K. Fodor, R. Peterson, H. Lu,\nM. Musolesi, S. B. Eisenman, X. Zheng, and A. T.\nCampbell. Sensing meets mobile social networks: the\ndesign, implementation and evaluation of the cenceme\napplication. In SenSys, 2008.\n[37] A. Mislove, A. Post, P. Druschel, and K. P. Gummadi.\nOstra: leveraging trust to thwart unwanted\ncommunication. In NSDI, pages 15\u201330, 2008.\n[38] P. Mittal and N. Borisov. Information leaks in\nstructured peer-to-peer anonymous communication\nsystems. In CCS, 2008.\n[39] P. Mittal and N. Borisov. Shadowwalker: peer-to-peer\nanonymous communication using redundant\nstructured topologies. In CCS, 2009.\n[40] A. Mohaisen, A. Yun, and Y. Kim. Measuring the\nmixing time of social graphs. In IMC, 2010.\n[41] S. Nagaraja. Anonymity in the wild: Mixes on\nunstructured networks. In PET, pages 254\u2013271, 2007.\n\n12\n\n\f[62]\n\n[63]\n\n[64]\n\n[65]\n\nanonymous and secure lookup: attacks on structured\npeer-to-peer anonymous communication systems. In\nCCS, 2010.\nC. Wilson, B. Boe, A. Sala, K. P. Puttaswamy, and\nB. Y. Zhao. User interactions in social networks and\ntheir implications. In EuroSys, pages 205\u2013218, 2009.\nS. Wolchok, O. S. Hofmann, N. Heninger, E. W.\nFelten, J. A. Halderman, C. J. Rossbach, B. Waters,\nand E. Witchel. Defeating vanish with low-cost sybil\nattacks against large DHTs. In NDSS, 2010.\nH. Yu, P. Gibbons, M. Kaminsky, and F. Xiao.\nSybilLimit: A near-optimal social network defense\nagainst sybil attacks. In IEEE Security and Privacy,\n2008.\nH. Yu, M. Kaminsky, P. Gibbons, and A. Flaxman.\nSybilGuard: Defending against Sybil attacks via social\nnetworks. In SIGCOMM, 2006.\n\nFigure 9: X-Vine lookup\n\nlogd N\n2\n+ (1 \u2212 P (trail)) * (1 + l((logd N ) \u2212 1, 1, 2))\n\nL(0, 2) = P (trail) *\n\nAPPENDIX\nA. MATHEMATICAL ANALYSIS OF X-VINE:\nAs a first step in formally modeling X-Vine security, we\ndevelop an analytic model for routing in X-Vine. The model\nenhances our understanding of the relationship between operational parameters of X-Vine, and can serve as a stepping\nstone for a complete formal model to analyze X-Vine's security against Sybil identities.\nLet there be N nodes in the system with node identifiers\nranging from 0..N \u2212 1. Let L(0, w) be the expected lookup\npath length between the node with identifier 0 and w. Let\nus suppose that node maintain trails with a single successor.\nWithout loss of generality, the average lookup path length\ncan be computed as follows:\nE(L) =\n\nPw=N\u22121\nw=0\n\nL(0, w)\n\nN\n\nwhere l(x, y, z) is defined as the expected path length\nwhen z is the destination identifier, y is the next overlay\nhop in the lookup, and x is the physical distance along a\ntrail between the current node and y (Figure 9). This means\nthat l((logd N ) \u2212 1, 1, 2) is the expected path length when\nthe destination identifier is 2, the next overlay hop is 1, and\nthe next overlay hop is logd N hops away from the current\nnode.\nNote that each node maintains a trail to its successor,\nand the mean length of the trails is logd (N ). This means\nthat the average routing state maintained by a node in the\nsystem is logd (N ). Since each routing table entry specifies\ntwo end points for a trail, the probability that a node has a\n2 logd N\ntrail with a particular end point going through it is\n.\nN\nThus:\n\nL(0, 2) =\n\n(1)\n\n2 logd N logd N\n*\nN\n2\n\u0013\n\u0012\n2 logd N\n* (1 + l((logd N ) \u2212 1, 1, 2))\n+ 1\u2212\nN\n\nl(x, 1, 2) =\nL(0, 1) = Expected trail length\n\n(2a)\n(2b)\n\n(3b)\n\nWe now need to compute l(x, 1, 2). Similar to our computation of L(0, 2), again, there are three possible scenarios.\nIn the first case, the current node (say A) is a friend of node\n2. Then the path length is 1. In the second case, there is a\ntrail with an end point at node 2 going through node A. In\nthis case, the mean path length is logd2(N) . In the third case,\nthe packet continues along the current trail to node 1.\n\nIn the simplest case, L(0, 0) = 0. Let us first compute\nL(0, 1). Note that node 0 and node 1 have a trail between\nthem because they are overlay neighbors. Let d be the average node degree in the underlying topology. We assume that\nthe length of the trail between overlay neighbors is close to\ntheir shortest path in the social network topology (approximately logd (N )). The lookup will proceed from node 0 along\nthe trail to node 1. Thus we have that:\n\nL(0, 1) = logd (N )\n\n(3a)\n\n\u0012\n\u0013\nlogd N\n2 logd N\n*\nN\n2\n\u0012\n\u0013\n2 logd N\n+ 1\u2212\n* (1 + l(x \u2212 1, 1, 2))\nN\n\n(4)\n\nHere, the boundary conditions for terminating the recursion are as follows:\n\nNotice that there cannot be any shortcutting in the intermediate nodes on the trail path from node 0 to node 1\nbecause we have assumed the trail to be the shortest path\nin the social network topology. Let us now compute L(0, 2).\nThere are two possible scenarios. In the first case, there may\nbe a trail with an end point at node 2 going through node\n0. In this case, the packet is routed along the trail to node\n2. Again, there cannot be any shortcutting along this trail\nbecause it is the shortest path. The mean path length in\nthis case is log2d N . In the second case, the packet will be\nrouted towards overlay node 1 (successor of node 0). Thus\nwe have that:\n\nl(x, 1, 1) = x if 0 \u2264 x \u2264 logd N\nl(x, z, z) = x if 0 \u2264 x \u2264 logd N, 1 \u2264 z \u2264 N \u2212 1\n\n(5a)\n(5b)\n\nl(0, y, z) = L(y, z) = L(0, (z \u2212 y)) if 1 \u2264 y \u2264 z \u2264 N \u2212 1\n\n(5c)\n\nLet us now compute L(0, w). Consider the following two\nscenarios. In the first case, let the closest preceding node in\nnode 0's routing table be node i (shortcut to i 6= 1). Now\nnode i may either be a friend of node 0, in which case, the\n13\n\n\fpath length is 1 + L(i, w), or node i may be the end point\nof a trail going\n\u0010 through node\u0011 0, in which case, the path\nlength is 1 + l log2d N \u2212 1, i, w . In the second case, there is\nno shortcutting, and the lookup proceeds towards the next\noverlay hop node 1. Thus, we have that:\n\nMean Lookup Path Length\n\nL(0, w) =\n\nw\nX\n\n70\n\nP (shortcut to i) * P (shortcut via friend)\n\ni=2\n\n* (1 + L(i, w)) +\n\nw\nX\n\nP (shortcut to i)*\n\ni=2\n\n\u0012\n\n\u0012\n\n1+l\n\n(6)\n\n1| no shortcut to w). This is equal to 1 \u2212\nSimilarly, we can compute the probability of shortcutting to\nnode i as:\nP (shortcut to i) = P (no shortcut to w..i+1)*\n(7a)\n\nP (no shortcut to w..j) = P (no shortcut from w..j+1)*\n\u0013\n\u0012\nd + 2 logd N\n(7b)\n1\u2212\nN \u2212 (w \u2212 j)\n\nNow, given that the lookup shortcuts towards overlay\nhop node i, it may do so because of a friendship entry\nin the routing table, or a trail in the routing table. The\nprobability that the shortcut happened via a friend entry,\nd\nP (shortcut via friend) = d+2 log\n. The probability that\nd (N)\nthe shortcut happened because of a X-Vine entry is\n2 logd (N)\nP (shortcut via trail) = d+2 log\n. Thus, we can rewrite\nd (N)\nequation (6) as\nw\nX\n\nd\n* (1 + L(i, w))\nd + 2 logd N\n\u0012\n\u0012\n\u0013\u0013\nw\nX\nlogd N\n2 logd N\n+\n* 1+l\n\u2212 1, i, w\nP (shortcut to i) *\nd + 2 logd N\n2\ni=2\nL(0, w) =\n\nP (shortcut to i) *\n\ni=2\n\n+ P (no shortcutting) * (1 + l((logd N ) \u2212 1, 1, w))\n\n(8)\n\nSimilar to the above analysis, we can compute l(x, i, w) as\nfollows:\n\nl(x, j, w) =\n\nj+1\nX\n\nP (shortcut to i) *\n\ni=2\n\n+\n\nj+1\nX\ni=2\n\nP (shortcut to i)*\n\nd\n* (1 + L(i, w))\nd + 2 logd N\n\n\u0012\n\u0012\n\u0013\u0013\nlogd N\n2 logd N\n* 1+l\n\u2212 1, i, w\nd + 2 logd (N )\n2\n\n+ P (no shortcutting) * (1 + l(x \u2212 1, j, w))\n\n30\n20\n10\n2000\n\n4000\n6000\n8000\nNumber of Nodes\n\n10000\n\nFigure 10: Validation of Analytic Model using d = 10\n\nlogd N\n* d+2N\u22121\n.\n\nd + 2 logd N\nN \u2212 (w \u2212 i)\n\n40\n\n0\n\nLet us now compute the probability of shortcutting to a\nnode i. The probability of shortcutting to node w is simdN\n. The probability of shortcutting to node w \u2212 1\nply d+2 log\nN\ncan be computed as P (no shortcut to \u0010w)*P (shortcut\u0011to w \u2212\nd+2 logd N\nN\n\n50\n\n0\n\n\u0013\u0013\n\nlogd N\n\u2212 1, i, w\n2\n+ P (no shortcut) * (1 + l((logd N ) \u2212 1, 1, w))\n\nP (shortcut via trail) *\n\nAnalysis, s=1\nSimulation, s=1\nAnalysis, s=20\nSimulation, s=20\n\n60\n\n(9)\n\n14\n\nThe boundary conditions for the termination of recursion\nare the same as in equation (5).\nValidation of analytic model: Figure 10 plots the mean lookup\npath length as a function of number of nodes for a synthetic\nscale-free topology with average degree d = 10 using a redundancy parameter of r = 1. We can see that the results of\nsimulation are a very close match with our analytic model,\nincreasing confidence in our results. We note that our analytic model has implications for modeling network layer\nDHTs like VRR.\n\n\fB.\n\nPSEUDOCODE\n\nAlgorithm 1 Fwd lookup(identifier myid, message M): Determines next hop for a lookup message.\nbestroute=0\nforeach element E in RoutingTable\nif distance(E.endpoint,M.dest)<\ndistance(bestroute,M.dest)\nbestroute=E\nendfor\nreturn bestroute\n\nAlgorithm 2 Fwd trailsetup(identifier myid, message M):\nDetermines next hop for trail path setup message.\nbestroutes=\u2205\n/* select all routes that make progress */\nforeach element E in RoutingTable\nif distance(E.endpoint,M.dest)<distance(myid,M.dest)\nbestroutes.insert(E)\nendfor\n/* of these, discard (a) backtracked routes, (b) routes that\nhave reached bounds, (c) routes that don't make namespace progress compared to M.nextovlhop*/\nforeach element E in bestroutes\nif failed set.contains(E.endpoint,E.nexthop) or\n(E.nexthop.numtrails > bn ) or\n(numtrailsto(E.nexthop) > bl ) or\n(distance(E.endpoint,M.dest) <\ndistance(M.nextovlhop,M.dest)\nbestroutes.remove(E)\nendfor\n/* if no remaining options, backtrack */\nif bestroutes == \u2205\nsend reject to(M.prevhop)\nreturn\n/* of remaining routes, select route with maximum namespace progress */\nroutetouse=0\nforeach element E in bestroutes\nif distance(E.endpoint,M.dest)<\ndistance(routetouse,M.dest)\nroutetouse=E\nendfor\nreturn routetouse\n\n15\n\n\f"}