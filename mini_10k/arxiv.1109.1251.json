{"id": "http://arxiv.org/abs/1109.1251v1", "guidislink": true, "updated": "2011-09-06T18:05:36Z", "updated_parsed": [2011, 9, 6, 18, 5, 36, 1, 249, 0], "published": "2011-09-06T18:05:36Z", "published_parsed": [2011, 9, 6, 18, 5, 36, 1, 249, 0], "title": "Synthesis of Distributed Control and Communication Schemes from Global\n  LTL Specifications", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1109.5723%2C1109.0631%2C1109.1650%2C1109.1580%2C1109.4859%2C1109.1616%2C1109.3588%2C1109.2915%2C1109.0961%2C1109.3599%2C1109.1932%2C1109.1785%2C1109.3679%2C1109.5451%2C1109.0106%2C1109.4342%2C1109.4397%2C1109.5104%2C1109.3781%2C1109.3880%2C1109.0056%2C1109.3131%2C1109.0931%2C1109.1614%2C1109.5768%2C1109.2073%2C1109.4278%2C1109.3516%2C1109.1955%2C1109.4080%2C1109.5734%2C1109.4624%2C1109.6688%2C1109.1054%2C1109.0741%2C1109.6938%2C1109.0118%2C1109.1392%2C1109.1383%2C1109.0350%2C1109.3775%2C1109.4896%2C1109.2104%2C1109.5246%2C1109.5826%2C1109.3561%2C1109.0033%2C1109.0928%2C1109.0427%2C1109.1036%2C1109.5562%2C1109.5350%2C1109.3327%2C1109.6711%2C1109.4825%2C1109.0939%2C1109.4675%2C1109.2002%2C1109.1035%2C1109.4299%2C1109.1251%2C1109.2742%2C1109.1641%2C1109.1505%2C1109.5683%2C1109.0445%2C1109.6228%2C1109.0021%2C1109.1354%2C1109.3521%2C1109.0510%2C1109.5732%2C1109.4150%2C1109.0632%2C1109.1312%2C1109.5680%2C1109.2534%2C1109.6058%2C1109.6673%2C1109.1019%2C1109.4515%2C1109.6353%2C1109.5489%2C1109.4972%2C1109.3507%2C1109.2854%2C1109.4458%2C1109.3319%2C1109.2848%2C1109.3779%2C1109.6359%2C1109.2681%2C1109.6217%2C1109.5078%2C1109.6764%2C1109.6382%2C1109.4315%2C1109.5721%2C1109.5188%2C1109.0852%2C1109.1151&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Synthesis of Distributed Control and Communication Schemes from Global\n  LTL Specifications"}, "summary": "We introduce a technique for synthesis of control and communication\nstrategies for a team of agents from a global task specification given as a\nLinear Temporal Logic (LTL) formula over a set of properties that can be\nsatisfied by the agents. We consider a purely discrete scenario, in which the\ndynamics of each agent is modeled as a finite transition system. The proposed\ncomputational framework consists of two main steps. First, we extend results\nfrom concurrency theory to check whether the specification is distributable\namong the agents. Second, we generate individual control and communication\nstrategies by using ideas from LTL model checking. We apply the method to\nautomatically deploy a team of miniature cars in our Robotic Urban-Like\nEnvironment.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1109.5723%2C1109.0631%2C1109.1650%2C1109.1580%2C1109.4859%2C1109.1616%2C1109.3588%2C1109.2915%2C1109.0961%2C1109.3599%2C1109.1932%2C1109.1785%2C1109.3679%2C1109.5451%2C1109.0106%2C1109.4342%2C1109.4397%2C1109.5104%2C1109.3781%2C1109.3880%2C1109.0056%2C1109.3131%2C1109.0931%2C1109.1614%2C1109.5768%2C1109.2073%2C1109.4278%2C1109.3516%2C1109.1955%2C1109.4080%2C1109.5734%2C1109.4624%2C1109.6688%2C1109.1054%2C1109.0741%2C1109.6938%2C1109.0118%2C1109.1392%2C1109.1383%2C1109.0350%2C1109.3775%2C1109.4896%2C1109.2104%2C1109.5246%2C1109.5826%2C1109.3561%2C1109.0033%2C1109.0928%2C1109.0427%2C1109.1036%2C1109.5562%2C1109.5350%2C1109.3327%2C1109.6711%2C1109.4825%2C1109.0939%2C1109.4675%2C1109.2002%2C1109.1035%2C1109.4299%2C1109.1251%2C1109.2742%2C1109.1641%2C1109.1505%2C1109.5683%2C1109.0445%2C1109.6228%2C1109.0021%2C1109.1354%2C1109.3521%2C1109.0510%2C1109.5732%2C1109.4150%2C1109.0632%2C1109.1312%2C1109.5680%2C1109.2534%2C1109.6058%2C1109.6673%2C1109.1019%2C1109.4515%2C1109.6353%2C1109.5489%2C1109.4972%2C1109.3507%2C1109.2854%2C1109.4458%2C1109.3319%2C1109.2848%2C1109.3779%2C1109.6359%2C1109.2681%2C1109.6217%2C1109.5078%2C1109.6764%2C1109.6382%2C1109.4315%2C1109.5721%2C1109.5188%2C1109.0852%2C1109.1151&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We introduce a technique for synthesis of control and communication\nstrategies for a team of agents from a global task specification given as a\nLinear Temporal Logic (LTL) formula over a set of properties that can be\nsatisfied by the agents. We consider a purely discrete scenario, in which the\ndynamics of each agent is modeled as a finite transition system. The proposed\ncomputational framework consists of two main steps. First, we extend results\nfrom concurrency theory to check whether the specification is distributable\namong the agents. Second, we generate individual control and communication\nstrategies by using ideas from LTL model checking. We apply the method to\nautomatically deploy a team of miniature cars in our Robotic Urban-Like\nEnvironment."}, "authors": ["Yushan Chen", "Xu Chu Ding", "Calin Belta"], "author_detail": {"name": "Calin Belta"}, "author": "Calin Belta", "arxiv_comment": "Technical Report accompanying an accepted paper for CDC2011", "links": [{"href": "http://arxiv.org/abs/1109.1251v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1109.1251v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.RO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.RO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.SY", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.OC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1109.1251v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1109.1251v1", "journal_reference": null, "doi": null, "fulltext": "Synthesis of Distributed Control and Communication Schemes\nfrom Global LTL Specifications\n\narXiv:1109.1251v1 [cs.RO] 6 Sep 2011\n\nYushan Chen, Xu Chu Ding, and Calin Belta\nAbstract- We introduce a technique for synthesis of control\nand communication strategies for a team of agents from a\nglobal task specification given as a Linear Temporal Logic\n(LTL) formula over a set of properties that can be satisfied by\nthe agents. We consider a purely discrete scenario, in which the\ndynamics of each agent is modeled as a finite transition system.\nThe proposed computational framework consists of two main\nsteps. First, we extend results from concurrency theory to check\nwhether the specification is distributable among the agents.\nSecond, we generate individual control and communication\nstrategies by using ideas from LTL model checking. We apply\nthe method to automatically deploy a team of miniature cars\nin our Robotic Urban-Like Environment.\n\nI. I NTRODUCTION\nIn control problems, \"complex\" models, such as systems\nof differential equations, are usually checked against \"simple\" specifications, such as the stability of an equilibrium,\nthe invariance of a set, controllability, and observability.\nIn formal synthesis (verification), \"rich\" specifications such\nas languages and formulas of temporal logics are checked\nagainst \"simple\" models of software programs and digital\ncircuits, such as (finite) transition systems. Recent studies\nshow promising possibilities to bridge this gap by developing\ntheoretical frameworks and computational tools, which allow\none to synthesize controllers for continuous and hybrid\nsystems satisfying specifications in rich languages. Examples\ninclude Linear Temporal Logic (LTL) [1], fragments of LTL\n[2], [3], Computation Tree Logic (CTL) [4], mu-calculus [5],\nand regular expressions [6].\nA fundamental challenge in this area is to construct\nfinite models that accurately capture behaviors of dynamical\nsystems. Recent approaches are based on the notion of\nabstraction [7] and equivalence relations such as simulation\nand bisimulation [8]. Enabled by recent developments in\nhierarchical abstractions of dynamical systems [1], it is\nnow possible to model systems with linear dynamics [9],\npolynomial dynamics [10], and nonholonomic (unicycle)\ndynamics [11] as finite transition systems.\nMore recent work suggests that such hierarchical abstraction techniques for a single agent can be extended to\nmulti-agent systems, using parallel compositions [4], [12].\nY. Chen is with Department of Electrical and Computer Engineering,\nBoston University, Boston, MA, 02215, U.S.A yushanc@bu.edu\nX. C. Ding and C. Belta are with the Department of Mechanical Engineering, Boston University, Boston, MA, 02215, U.S.A\n\n{xcding,cbelta}@bu.edu\nY. Chen is the corresponding author.\nThis work was partially supported by ONR MURI N00014-09-1051,\nARO W911NF-09-1-0088, AFOSR YIP FA9550-09-1-020 and NSF CNS0834260 at Boston University.\n\nFig. 1. The topology of the Robotic Urban-Like Environment (RULE) and\nthe road, intersection, and parking lot labels.\n\nThe two main limitations of this approach are the state\nspace explosion problem and the need for frequent agent\nsynchronization. References [6], [13] addressed both of these\nlimitations with \"top-down\" approaches, by drawing inspirations from distributed formal synthesis [14]. The main idea is\nto decompose a global specification into local specifications,\nwhich can then be used to synthesize controllers for the\nindividual agents. The main drawback of these methods is\nthat, the expressivity is limited to regular languages.\nIn this paper, we address a purely discrete problem, in\nwhich each agent is modeled as a finite transition system:\nGiven 1) a set of properties of interest that need to be satisfied, 2) a team of agents and their capacities and cooperation\nrequirements for satisfying properties, 3) a task specification\ndescribing how the properties need to be satisfied subject to\nsome temporal and logical constraints in the form of an LTL\nformula over the set of properties; Find provably-correct individual control and communication strategies for each agent\nsuch that the task is accomplished. Drawing inspiration from\nthe areas of concurrency theory [15] and distributed formal\nsynthesis [14], we develop a top-down approach that allows\nfor the fully automatic synthesis of individual control and\ncommunication schemes. This framework is quite general\nand can be used in conjunction with abstraction techniques\nto control multiple agents with continuous dynamics.\nThe contribution of this work is threefold. First, we\ndevelop a computational framework to synthesize individual\ncontrol and communication strategies from global specifications given as LTL formulas over a set of interesting\nproperties. This is a significant improvement over [6] by\n\n\fincreasing the expressivity of specifications. Second, we\nextend the approach of checking closure properties of temporal logic specifications in [16] to generate distributed\ncontrol and communication strategies for a team of agents\nwhile considering their dynamics. Specifically, we show how\na satisfying distributed execution can be found when the\nglobal specification is traced-closed. Third, we implement\nand illustrate the computational framework in our Kheperabased Robotic Urban-Like Environment (RULE) (Fig. 1). In\nthis experimental setup, robotic cars can be automatically\ndeployed from specifications given as LTL formulas to\nservice requests that occur at the different locations while\navoiding the unsafe regions.\nThe remainder of the paper is organized as follows. Some\npreliminaries are introduced in Sec. II. The problem is\nformulated in Sec. III. An approach for distributing the\nglobal specification over a team of agents and synthesizing\nindividual control and communication strategies is presented\nin Sec. IV. The method is applied to the RULE platform in\nSec. V. We conclude with final remarks and directions for\nfuture work in Sec. VI.\nII. P RELIMINARIES\nFor a set \u03a3, we use |\u03a3|, 2\u03a3 , \u03a3\u2217 , and \u03a3\u03c9 to denote\nits cardinality, power set, set of finite words, and set of\ninfinite words, respectively. We define \u03a3\u221e = \u03a3\u2217 \u222a \u03a3\u03c9 and\ndenote the empty word by \u000f. In this section, we provide\nbackground material on Linear Temporal Logic, automaton,\nand concurrency theory.\nDefinition 1 (transition system): A transition system\n(TS) is a tuple T := (S, s0 , \u2192, \u03a3, h), consisting of (i) a\nfinite set of states S; (ii) an initial states s0 \u2208 S; (iii) a\ntransition relation \u2192\u2286 S \u00d7 S; (iv) a finite set of properties\n\u03a3; and (v) an output map h : S \u2192 \u03a3.\nA transition (s, s0 ) \u2208\u2192 is also denoted by s \u2192 s0 .\nProperties can be either true or false at each state of T .\nThe output map h(s), where s \u2208 S, defines the property\nvalid at state s. A finite trajectory of T is a finite sequence\nrT = s(0)s(1) . . . s(n) with the property that s(0) = s0\nand s(i) \u2192 s(i + 1), for all i \u2265 0. Similarly, an infinite\ntrajectory of T is an infinite sequence rT = s(0)s(1) . . . with\nthe same property. A finite or infinite trajectory generates a\nfinite or infinite word as a sequence of properties valid at\neach state, denoted by w = h(s(0))h(s(1)) . . . h(s(n)) or\nw = h(s(0))h(s(1)) . . ., respectively.\nWe employ Linear Temporal Logic (LTL) formulas to\nexpress global tasks for a team of agents. Informally, LTL\nformulas are built from a set of properties \u03a3, standard\nBoolean operators \u00ac (negation), \u2228 (disjunction), \u2227 (conjunction), and temporal operators\n(next), U (until), \u2666\n(eventually), \u0003 (always). The semantics of LTL formulas are\ngiven over infinite words w over \u03a3, such as those generated\nby a transition system defined in Def. 1. We say an infinite\ntrajectory rT of T satisfies an LTL formula \u03c6 if and only if\nthe word generated by rT satisfies \u03c6.\nA word satisfies an LTL formula \u03c6 if \u03c6 is true at the first\nposition of the word; \u03c6 states that at the next state, an LTL\n\nformula \u03c6 is true; \u2666\u03c6 means that \u03c6 eventually becomes true\nin the word; \u0003\u03c6 means that \u03c6 is true at all positions of the\nword; \u03c61 U\u03c62 means \u03c62 eventually becomes true and \u03c61 is\ntrue until this happens. More expressivity can be achieved\nby combining the above temporal and Boolean operators.\nExamples include \u0003\u2666\u03c6 (\u03c6 is true infinitely often) and \u2666\u0003\u03c6\n(\u03c6 becomes eventually true and stays true forever).\nFor every LTL formula \u03c6 over \u03a3, there exists a B\u00fcchi\nautomaton accepting all and only the words satisfying \u03c6\n[17]. We refer readers to [18] and references therein for\nefficient algorithms and freely downloadable implementations to translate a LTL formula \u03c6 to a corresponding B\u00fcchi\nautomaton.\nDefinition 2 (B\u00fcchi automaton): A B\u00fcchi automaton is a\ntuple B := (Q, Qin , \u03a3, \u03b4, F ), consisting of (i) a finite set of\nstates Q; (ii) a set of initial states Qin \u2286 Q; (iii) an input\nalphabet \u03a3; (iv) a transition function \u03b4 : Q \u00d7 \u03a3 \u2192 2Q ; (v) a\nset of accepting states F \u2286 Q.\nA run of the B\u00fcchi automaton over an infinite word\nw = w(0)w(1) . . . over \u03a3 is a sequence rB = q(0)q(1) . . .,\nsuch that q(0) \u2208 Qin and q(i + 1) \u2208 \u03b4(q(i), w(i)). A B\u00fcchi\nautomaton accepts a word w if and only if there exists rB\nover w so that inf(rB )\u2229F 6= \u2205, where inf(rB ) denotes the set\nof states appearing infinitely often in run rB . The language\naccepted by a B\u00fcchi automaton, denoted by L(B), is the set\nof all infinite words accepted by B. We use B\u03c6 to denote the\nB\u00fcchi automaton accepting the language satisfying \u03c6.\nRemark 1: In LTL model checking [19], several properties\ncan be valid at one state of a transition system (also called\nKripke structure). The words produced by a transition system\nand accepted by a B\u00fcchi automaton are over the power set\nof propositions (i.e., 2\u03a3 ). In this paper, by allowing only one\nproperty to be valid at a state, we consider a particular case\nwhere we allow only one property to be valid at each state\nof a TS by defining h in Def. 1 as a mapping from S to \u03a3.\nAs a consequence, the words generated by T and accepted\nby B are over \u03a3.\nDefinition 3 (distribution): Given a set \u03a3, a collection of\nsubsets {\u03a3i \u2286 \u03a3, i \u2208 I}, where I is an index set, is called\na distribution of \u03a3 if \u222ai\u2208I \u03a3i = \u03a3.\nDefinition 4 (projection): For a word w \u2208 \u03a3\u221e and a\nsubset S \u2286 \u03a3, we denote by w \u0016S the projection of w onto S,\nwhich is obtained by erasing all symbols \u03c3 in w that do not\nbelong to \u03a3. For a language L \u2286 \u03a3\u221e and a subset S \u2286 \u03a3,\nwe denote by L \u0016S the projection of L onto S, which is given\nby L \u0016S := {\u03c9 \u0016S | \u03c9 \u2208 L}.\nDefinition 5 (trace-closed language): Given a distribution {\u03a3i \u2286 \u03a3, i \u2208 I} and w, w0 \u2208 \u03a3\u221e , we say that\nw is trace-equivalent to w0 (w \u223c w0 1 ) if and only if\nw \u0016\u03a3i = w0 \u0016\u03a3i , for all i \u2208 I. We denote by [w] the\ntrace-equivalence class of w \u2208 \u03a3\u221e , which is given by\n[w] := {w0 \u2208 \u03a3\u221e | w \u223c w0 }. A trace-closed language\nover a distribution {\u03a3i \u2286 \u03a3, i \u2208 I} is a language L such\nthat for all w \u2208 L, [w] \u2286 L.\n1 Note that the trace-equivalence relation \u223c and class [*] are based on the\ngiven distribution {\u03a3i \u2286 \u03a3, i \u2208 I}. For simplicity of notations, we use \u223c\nand [*] without specifying the distribution when there is no ambiguity.\n\n\fDefinition 6 (product of languages): Given a distribution\n{\u03a3i \u2286 \u03a3, i \u2208 I}, the product of a set of languages Li over\n\u03a3i is denoted by ki\u2208I Li and defined as ki\u2208I Li := {w \u2208\n\u03a3\u221e | w \u0016\u03a3i \u2208 Li for all i \u2208 I}.\nProposition 1: Given a distribution {\u03a3i \u2286 \u03a3, i \u2208 I} of \u03a3\nand a word w \u2208 \u03a3\u221e , we have [w] =ki\u2208I {w \u0016\u03a3i }.\nProof: For all words w0 \u2208 [w], according to Def. 5,\n0\nw \u0016\u03a3i = w \u0016\u03a3i , \u2200i \u2208 I. According to Def. 6, since w0 \u2208 \u03a3\u221e\nand w0 \u0016\u03a3i = w \u0016\u03a3i , \u2200i \u2208 I, then w0 \u2208ki\u2208I {w \u0016\u03a3i }. Hence,\n[w] \u2286ki\u2208I {w \u0016\u03a3i }.\nFor all words w0 \u2208ki\u2208I {w \u0016\u03a3i }, according to Def. 6,\nw \u0016\u03a3i = w0 \u0016\u03a3i . According to Def. 5, w0 \u223c w, which implies\nw0 \u2208 [w]. Hence, ki\u2208I {w \u0016\u03a3i } \u2286 [w]. Combined with the\nfact that [w] \u2286ki\u2208I {w \u0016\u03a3i }, we have [w] =ki\u2208I {w \u0016\u03a3i }.\nWe refer to [15], [20] for more definitions and properties\nin concurrency theory.\nIII. P ROBLEM F ORMULATION AND A PPROACH\nAssume we have a team of agents {i | i \u2208 I}, where I is a\nlabel set. We use an LTL formula over a set of properties \u03a3 to\ndescribe a global task for the team. We model the capabilities\nof the agents to satisfy properties as a distribution {\u03a3i \u2286\n\u03a3, i \u2208 I}, where \u03a3i is the set of properties that can be\nsatisfied by agent i. A property can be shared or individual,\ndepending on whether it belongs to multiple agents or to a\nsingle agent. Shared properties are properties that need to be\nsatisfied by several agents simultaneously.\nWe model each agent as a transition system:\nTi = (Si , s0i , \u2192i , \u03a3i , hi ), i \u2208 I.\n\n(1)\n\nIn other words, the dynamics of agent i are restricted by\nthe transition relation \u2192i . The output hi (si ) represents the\nproperty that is valid (true) at state si \u2208 Si . An individual\nproperty \u03c3 is said to be satisfied if and only if the agent\nthat owns \u03c3 reaches state si at which \u03c3 is valid (i.e., ,\nhi (si ) = \u03c3). A shared property is said to be satisfied if\nand only if all the agents sharing it enter the states where \u03c3\nis true simultaneously.\nFor example, Ti can be used to model the motion capabilities of a robot (Khepera III miniature car) running in our\nurban-like environment (Fig. 1), where Si is a set of labels\nfor the roads, intersections and parking lots and \u2192i shows\nhow these are connected (i.e., \u2192i captures how robot i can\nmove among adjacent regions). Note that these transitions\nare, in reality, enabled by low-level control primitives (see\nSec. V). We assume that the selection of a control primitive at a region uniquely determines the next region. This\ncorresponds to a deterministic (control) transition system, in\nwhich each trajectory of Ti can be implemented by the robot\nin the environment by using the sequence of corresponding\nmotion primitives. For simplicity of notation, since the robot\ncan deterministically choose a transition, we omit the control\ninputs traditionally associated with transitions. Furthermore,\ndistribution {\u03a3i \u2286 \u03a3, i \u2208 I} can be used to capture\nthe capabilities of the robots to service requests and task\ncooperation requirements (e.g., some of the requests can be\n\nserviced by one robot, while others require the collaboration\nof two or more robots). The output map hi indicates the\nlocations of the requests. A robot services a request by\nvisiting the region at which this request occurs. A shared\nrequest occurring at a given location requires multiple robots\nto be at this location at the same time.\nDefinition 7 (cc-strategy): A finite (infinite) trajectory\nric = si (0)si (1) . . . si (n) (si (0)si (1) . . .) of Ti defines a\ncontrol and communication (cc) strategy for agent i in the\nfollowing sense: (i) si (0) = s0i , (ii) an entry si (k) means\nthat state si (k) should be visited, (iii) an entry si (k), where\nhi (si (k)) is a shared property, triggers a communication\nprotocol: while at state si (k), agent i broadcasts the property\nhi (si (k)) and listens for broadcasts of hi (si (k)) from all\nother agents that share the property with it; when they are\nall received, hi (si (k)) is satisfied and then agent i transits\nto the next state.\nBecause of the possible parallel satisfaction of individual\nproperties, and because the durations of the transitions are\nnot known, a set of cc-strategies {ric , i \u2208 I} can produce\nmultiple sequences of properties satisfied by the team. We\nuse products of languages (Def. 6) to capture all the possible\nbehaviors of the team.\nDefinition 8 (global behavior of the team): Given a set\nof cc-strategies {ric , i \u2208 I}, we denote\nLteam ({ric , i \u2208 I}) := ki\u2208I {wi }\n\n(2)\n\nas the set of all possible sequences of properties satisfied by\nthe team while the agents follow their individual cc-strategies\nric , where wi is the word of Ti generated by ric .\nFor simplicity of notation, we usually denote Lteam ({ric ,\ni \u2208 I}) as Lteam when there is no ambiguity.\nDefinition 9 (satisfying set of cc-strategies): A set of ccstrategies {ric , i \u2208 I} satisfies a specification given as an LTL\nformula \u03c6 if and only if Lteam 6= \u2205 and Lteam \u2286 L(B\u03c6 ).\nRemark 2: For a set of cc-strategies, the corresponding\nLteam could be an empty set by the definition of product\nof languages (since there may not exist a word w \u2208 \u03a3\u221e\nsuch that w \u0016\u03a3i = wi for all i \u2208 I). In practice, this case\ncorresponds to a deadlock scenario where one (or more)\nagent waits indefinitely for others to enter the states at which\na shared property \u03c3 is true. For example, if one of these\nagents is not going to broadcast \u03c3 but some other agents are\nwaiting for the broadcasts of \u03c3, then all those agents will be\nstuck in a deadlock state and wait indefinitely. When such a\ndeadlock scenario occurs, the behaviors of the team do not\nsatisfy the specification.\nWe are now ready to formulate the main problem:\nProblem 1: Given a team of agents represented by Ti , i \u2208\nI, a global specification \u03c6 in the form of an LTL formula\nover \u03a3, and a distribution {\u03a3i \u2286 \u03a3, i \u2208 I}, find a satisfying\nset of individual cc-strategies {ric , i \u2208 I}.\nOur approach to solve Prob. 1 can be divided into two\nmajor parts as shown in Fig 2: checking distributability and\nensuring implementability. Specifically, we (i) check whether\nthe global specification can be distributed among the agents\nwhile accounting for their capabilities to satisfy properties,\n\n\fInputs: \u03c6, {\u03a3i \u2286 \u03a3, i \u2208 I}, {Ti , i \u2208 I}\n\nDistributability\n\nImplementability\nLocal specifications Bi , i \u2208 I\nYes\n\nNo\n\nSolution\nnot found\n\nDistributable\nL(B\u03c6 )\n\nImplementable local\nspecifications Ei , i \u2208 I\nImplementable global\nbehaviors of the team:\n\ufffdi\u2208I Ei\n\nSelect a word from L(B\u03c6 ) \u2229 L(\ufffdi\u2208I Ei )\nGenerate individual cc strategies\n\nFig. 2.\n\n(a, a) (b, b) (c, c)\n\n(b, c)\n\n(b, c)\n\nConstruct B\u03c6\n\nIs L(B\u03c6 )\ntrace closed?\n\nC:\n\nSchematic representation of our approach to Prob. 1.\n\nand (ii) make sure that the individual cc-strategies are feasible for the agents. For (i), we make the connection between\ndistributability of global specifications and closure properties\nof temporal logic formulas [16]. Specifically, we check\nwhether the language satisfying the global specification \u03c6\nis trace-closed; if yes, then it is distributable; otherwise, a\nsolution cannot be found (see Sec. IV-A). Therefore, our\napproach is conservative, in the sense that we might not\nfind a solution even if one exists. For (ii), we construct\nan implementable automaton by adapting automata-based\ntechniques [21], [22] to obtain all the possible sequences\nof properties that could be satisfied by the team, while\nconsidering the dynamics and capabilities of the agents\n(Sec. IV-B and IV-C). Finally, an arbitrary word from the\nintersection of the trace-closed language satisfying \u03c6 and\nthe language of the implementable automaton is selected to\nsynthesize the individual cc-strategies for the agents.\nIV. S YNTHESIS OF INDIVIDUAL CC - STRATEGIES\nA. Checking Distributability\nWe begin with the conversion of the global specification \u03c6\nover \u03a3 to a B\u00fcchi automaton B\u03c6 = (Q, Qin , \u03a3, \u03b4, F ) (Def.\n4), which accepts exactly the language satisfying \u03c6 (using\nLTL2BA [18]). We need to find a local word wi for each\nagent i such that (i) all possible sequences of properties\nsatisfied by the team while each agent executes its local\nword satisfy the global specification (i.e., included in L(B\u03c6 )),\nand (ii) each local word wi can be implemented by the\ncorresponding agent (which will be detailed in the following\nsub-sections).\nGiven the global specification L(B\u03c6 ) and the distribution\n{\u03a3i \u2286 \u03a3, i \u2208 I}, we make the important observation that a\n\n(c, b)\n\n(c, b)\n\nFig. 3. B\u00fcchi automaton C (3) for the case when \u03a3 = {a, b, c}, \u03a31 =\n{a, b}, and \u03a32 = {a, c}. Relation I is given by I = {(b, c), (c, b)}.\n\ntrace-closed language (Def. 5) is sufficient to find a set of\nlocal words satisfying the first condition. Formally, we have:\nProposition 2: Given a language L \u2282 \u03a3\u221e and a distribution {\u03a3i \u2286 \u03a3, i \u2208 I}, if L is a trace-closed language and\nw \u2208 L, then ki {w \u0016\u03a3i } \u2286 L.\nProof: Follows from Prop. 1 and the definition of the\ntrace-closed language.\nThus, our approach aims to check whether L(B\u03c6 ) is traceclosed. If the answer is positive, by Prop. 2, an arbitrary\nword from L(B\u03c6 ) can be used to generate the suitable set of\nlocal words by projecting this word onto \u03a3i . The algorithm\n(adapted from [16]) to check if L(B\u03c6 ) is trace-closed can be\nviewed as a process to construct a B\u00fcchi automaton A, such\nthat each word accepted by A represents a pair of words\nw and w0 , such that w \u2208 L(B\u03c6 ), w0 \u2208\n/ L(B\u03c6 ), and w \u223c w0\n0\n(i.e., w is trace-equivalent to w ). Thus, if A has a non-empty\nlanguage, L(B\u03c6 ) is not trace-closed.\nTo obtain A, we first construct a B\u00fcchi automaton, denoted\nby C, to capture all pairs of trace-equivalent infinite words\nover \u03a3. Given the distribution {\u03a3i \u2286 \u03a3, i \u2208 I}, we define\na relation I such that (\u03c3, \u03c3 0 ) \u2208 I if there does not exist \u03a3i ,\ni \u2208 I such that \u03c3, \u03c3 0 \u2208 \u03a3i . Formally, C is defined as\nC = (QC , {qC0 }, \u03a3C , \u03b4C , FC ),\n\n(3)\n\nwhere \u03a3C = I \u222a {(\u03c3, \u03c3) | \u03c3 \u2208 \u03a3} and FC = {qC0 }. The\ntransition function \u03b4C is defined as (a) for all \u03c3 \u2208 \u03a3, there\nexists qC0 = \u03b4C (qC0 , (\u03c3, \u03c3)), and (b) for all (\u03c3, \u03c3 0 ) \u2208 I, there\nexists a state qC 6= qC0 such that qC = \u03b4C (qC0 , (\u03c3, \u03c3 0 )) and\nqC0 = \u03b4C (qC , (\u03c3 0 , \u03c3)). In other words, to obtain C, we first\ngenerate the initial state and then add a new state and the\ncorresponding transitions for every member of I. Thus, the\nnumber of states is |I| + 1. A simple example to illustrate\nthe construction of C is shown in Fig. 3.\nNext, we construct a B\u00fcchi automaton A1 to accommodate\nwords from L(B\u03c6 ). A word wA1 accepted by A1 is a\nsequence (\u03c31 , \u03c310 )(\u03c32 , \u03c320 ) . . .. We use wA1 |1 and wA1 |2 to\ndenote the sequence \u03c31 \u03c32 . . . and \u03c310 \u03c320 . . ., respectively. For\neach word wA1 accepted by A1 , we have wA1 |1 \u2208 L(B\u03c6 )\nand wA1 |2 \u2208 \u03a3\u03c9 . Similarly, we construct another B\u00fcchi\nautomaton A2 to capture words that do not belong to L(B\u03c6 ),\ni.e., for each word wA2 \u2208 L(A2 ), wA2 |1 \u2208 \u03a3\u03c9 and wA2 |2 \u2208\n/\nL(B\u03c6 ) always hold.\nFinally, we produce the B\u00fcchi automaton A such that\nL(A) = L(C) \u2229 L(A1 ) \u2229 L(A2 ) by taking the intersections\nof the B\u00fcchi automata. According to [16], L(B\u03c6 ) is traceclosed if and only if L(A) = \u2205. The construction of the\n\n\fintersection of several B\u00fcchi automata is given in [17]. We\nsummarize this procedure in Alg. 1.\nAlgorithm 1 : Check if L(B) is trace-closed\n\nInput: A B\u00fcchi automaton B = (Q, Qin , \u03a3, \u03b4, F ) (Def. 4)\nand a distribution {\u03a3i \u2286 \u03a3, i \u2208 I}\nOutput: Yes or No\n1: Construct C as defined in (3)\n2: Construct A1 = (Q, Qin , \u03a3A1 , \u03b4A1 , F ), where \u03a3A1 \u2286\n\u03a3 \u00d7 \u03a3 and \u03b4A1 : Q \u00d7 \u03a3A1 \u2192 2Q is defined as q 0 \u2208\n\u03b4A1 (q, (\u03c31 , \u03c32 )) if and only if q 0 \u2208 \u03b4(q, \u03c31 )\n3: Construct A2 = (Q, Qin , \u03a3A2 , \u03b4A2 , F ), where \u03a3A2 \u2286\n\u03a3 \u00d7 \u03a3 and \u03b4A2 : Q \u00d7 \u03a3A2 \u2192 2Q is defined as q 0 \u2208\n\u03b4A2 (q, (\u03c31 , \u03c32 )) if and only if q 0 \u2208 \u03b4(q, \u03c32 ).\n4: Construct A such that L(A) = L(C) \u2229 L(A1 ) \u2229 L(A2 )\n5: if L(A) = \u2205 return Yes else return No\nB. Implementable Local Specification\nIn the case that L(B\u03c6 ) is trace-closed, the global specification is distributable among the agents. We call L(B\u03c6 ) \u0016\u03a3i\nthe \"local\" specification for agent i because of the following\nproposition.\nProposition 3: If a set of cc-strategies {ric , i \u2208 I} is a\nsolution to Prob. 1, then the corresponding local words wic\nare included in L(B\u03c6 ) \u0016\u03a3i for all i \u2208 I.\nProof: If a set of cc-strategies {ric , i \u2208 I} is a\nsolution to Prob. 1, then we have ||i\u2208I {wic } \u2286 L(B\u03c6 ) and\n||i\u2208I {wic } =\n6 \u2205. We can find a word w1 \u2208 ||i\u2208I {wic } \u2286\nL(B\u03c6 ), such that wic = w1 \u0016\u03a3i for all i \u2208 I. Since wic =\nw1 \u0016\u03a3i and w1 \u0016\u03a3i \u2208 L(B\u03c6 ) \u0016\u03a3i , we have wic \u2208 L(B\u03c6 ) \u0016\u03a3i .\nGiven the agent model Ti , some of the local words might\nnot be feasible for the agent. Therefore, we aim to construct the \"implementable local\" specification for each agent;\nnamely, it captures all the words of L(B\u03c6 ) \u0016\u03a3i that can be\nimplemented by the agent. To achieve this, we first produce\nan automaton that accepts exactly the local specification.\nNote that the projection of the language satisfying the\nglobal specification that includes only infinite words on a\nlocal alphabet \u03a3i might contain finite words. For example,\ngiven an infinite word w = baaa . . ., if a \u2208\n/ \u03a3i , the projection\nof this word is b. Therefore, the local specification for each\nagent might have both finite and infinite words. To address\nthis, we employ a mixed B\u00fcchi automaton introduced in [22].\nThe mixed B\u00fcchi automaton is similar to the standard B\u00fcchi\nautomaton defined in Def. 4, except for it has two different\ntypes of accepting states: finitary and infinitary accepting\nstates. Formally, we define the mixed B\u00fcchi automaton as\nB M := (Q, Qin , \u03a3, \u03b4, F, F f in )\n\n(4)\n\nwhere F stands for the set of infinitary accepting states\nand F f in represents the set of finitary accepting states.\nThe mixed B\u00fcchi automaton accepts infinite words by using the set of infinitary accepting states, with the same\nacceptance condition as defined in Def. 4. A finite run\n\nrf in = q(0)q(1) . . . q(n) of B M over a finite word wf in =\nw(0)w(1) . . . w(n) satisfies q(0) \u2208 Qin and q(i + 1) \u2208\n\u03b4(q(i), w(i)), for all 0 \u2264 i < n. B M accepts a finite\nword wf in if and only if the finite run rf in over wf in\nsatisfying q(n) \u2208 F f in . We call a finitary accepting state\nq \u2208 F f in terminal if and only if no transition starts from q.\nWe assume that all the finitary accepting states are terminal in\nthis paper. An algorithm to obtain a mixed B\u00fcchi automaton\nf in\nBi = (Qi , Qin\n) which accepts L(B\u03c6 ) \u0016\u03a3i is\ni , \u03a3i , \u03b4i , Fi , Fi\nsummarized in Alg. 2.\nAlgorithm 2 : Construct Bi where L(Bi ) = L(B) \u0016\u03a3i\n\nInput: B = (Q, Qin , \u03a3, \u03b4, F ) and a subset \u03a3i \u2286 \u03a3\nf in\nOutput: Bi = (Qi , Qin\n)\ni , \u03a3Bi , \u03b4i , Fi , Fi\n\u000fin\n\u000f \u000f\n\u000f\n\u000f\n1: Construct Bi = (Qi , Qi , \u03a3i , \u03b4i , Fi\u000f ), where Q\u000fi = Q,\nQ\u000fi in = Qin , \u03a3\u000fi = \u03a3i \u222a {\u000f}, Fi\u000f = F and \u03b4i\u000f is defined\nas q 0 \u2208 \u03b4i\u000f (q, \u03c3) iff q 0 \u2208 \u03b4(q, \u03c3) and \u03c3 \u2208 \u03a3i , and q 0 \u2208\n\u03b4i\u000f (q, \u000f) iff \u2203\u03c3 \u2208 \u03a3\\\u03a3i s.t., q 0 \u2208 \u03b4(q, \u03c3).\n2: For all states q of Bi\u000f , we take the \u000f-closure [23] of q,\ndenoted as eclose(q).\nf in\n3: Build Bi = (Qi , Qin\n), where Qi =\ni , \u03a3Bi , \u03b4i , Fi , Fi\n\u000fin\n\u000f\nin\nQi , Qi = Qi , \u03a3Bi = \u03a3i , \u03b4i is defined as q 0 \u2208\n\u03b4i (q, \u03c3), iff \u2203q 00 \u2208 eclose(q), s.t., q 0 \u2208 \u03b4i\u000f (q 00 , \u03c3), Fi =\nFi\u000f and Fif in = \u2205.\nf in\n4: Obtain Fi\nby adding a new state q f in to Fif in for\n\u000f\n\u000f\n\u000f\neach q \u2208 Fi where a loop q \u2192\n\u2212 q1 \u2192\n\u2212 q2 . . . \u2192\n\u2212 q in Bi\u000f\nexists\nf in\n5: Add Fi\nto Qi .\nf in\n6: For each state q f in \u2208 Fi , we have q f in \u2208 \u03b4i (q 0 , \u03c3)\nif and only if the state's corresponding state of q \u2208 Fi\nsatisfying q \u2208 \u03b4i (q 0 , \u03c3)\nf in\n7: return Bi = (Qi , Qin\n)\ni , \u03a3Bi , \u03b4i , Fi , Fi\nProposition 4: The language of the mixed B\u00fcchi automaf in\nton Bi = (Qi , Qin\n) constructed in Alg. 2 is\ni , \u03a3i , \u03b4i , Fi , Fi\nequal to L(B\u03c6 ) \u0016\u03a3i .\nProof: By construction, Bi\u000f accepts L(B) \u0016\u03a3i . To prove\nthe above proposition, we first prove the following statement:\nBi obtained by Alg. 2 accepts the same infinite language as\nBi\u000f does. For the infinite language, we only need to consider\nBi constructed in step 3 of the algorithm since step 4, 5,\nand 6 are only related to the finite language. From now on,\nf in\nBi = (Qi , Qin\n) refers to Bi constructed in\ni , \u03a3i , \u03b4i , Fi , Fi\nstep 3.\nWe define \u03b4bi (Q1 , w), Q1 \u2286 Qi inductively to represent a\nset of states that can be reached from Q1 after taking w =\nw(1)w(2) . . . w(n) as inputs. Formally, we define \u03b4bi for a\nB\u00fcchi automaton's transition function \u03b4i by:\nBasis: \u03b4bi (Q1 , \u000f) = Q1 . That is, without reading any input\nsymbols, we are only in the state we began in.\nInduction: Suppose w is of the form w = xa, where a is\nthe final symbol of w and x is the rest of w. Also suppose\nthat \u03b4bi (Q1 , x) = {q1 , q2 , . . . , qk }. Let\nk\n[\n\nj=1\n\n\u03b4i ({qj }, a) = {r1 , r2 , . . . , rm }\n\n\fThen \u03b4bi (Q1 , w) = {r1 , r2 , . . . , rm }. Less formally, we\ncompute \u03b4bi (Q1 , w) by first computing \u03b4bi (Q1 , x), and then\nfollowing any transition from any of these states that is\nlabeled a.\nSimilarly, for the B\u00fcchi automaton with \u000f-transitions,\n\u03b4bi\u000f (Q2 , w), Q2 \u2286 Q\u000fi , is defined to represent the set of\nstates, which can be reached from the set of the states\nQ2 after taking a sequence of transitions given the input\nsequence w, while accounting for the transitions that can be\nmade spontaneously (i.e., \u000f-transitions).\nWith slight abuse of\nS\nnotation, we denote \u03b4i\u000f (Q2 , a) = q\u2208Q2 \u03b4i\u000f (q, a). Formally,\nwe define \u03b4bi\u000f for the transition function \u2192\u000fBi of a B\u00fcchi\nautomaton with \u000f-transitions as following:\nBasis: \u03b4bi\u000f (Q2 , \u000f) = Q2 .\nInduction: Suppose w is of the form w = xa. Also\nsuppose that \u03b4bi\u000f (Q2 , x) = {q1 , q2 , . . . , qk }. Let\nk\n[\n\nj=1\n\n\u03b4bi\u000f ({qj }, a) =\n\nk\n[\n\n\u03b4i\u000f (eclose(qj ), a))\n\nj=1\n\n= {r1 , r2 , . . . , rm }\n\nThen \u03b4bi\u000f (Q2 , w) = {r1 , r2 , . . . , rm }. Less formally, we\ncompute \u03b4bi\u000f (Q2 , w) by first computing \u03b4bi\u000f (Q2 , x), then following any \u000f-transition from any of these states, and finally\nfollowing any transition from the reached states that is\nlabeled a.\nTo prove the statement, what we prove first, by induction\non |w|, where w = w(1)w(2) . . . w(n) \u2208 \u03a3\u2217 , is that\nb\u000f \u000fin\n\u03b4bi (Qin\ni , w) = \u03b4i (Qi , w).\n\n(5)\n\nBasis: Let |w| = 0; that is, w = \u000f. By the basis definitions\n\u000fin\nin\nb\u000f \u000fin\nof \u03b4bi and \u03b4bi\u000f , \u03b4bi (Qin\ni , w) = Qi and \u03b4i (Qi , w) = Qi .\n\u000f\nin\nSince Qin\n= Qi , (5) holds.\ni = Qi\nInduction: Let w be of length n + 1, and assume (5)\nfor length n. Break w as w = xa. Let the set of states\nin Qi be {q1 , q2 , . . . , qk } and the set of states in Q\u000fi be\n{q1\u000f , q2\u000f , . . . , qk\u000f }, and qj\u000f = qj , 1 \u2264 j \u2264 k.\nBy the construction of \u2192Bi , we have q \u2208 \u03b4i ({qj }, a)\nif and only if q \u2208 \u03b4i\u000f (eclose(qj ), a). By definition, since\n\u03b4i ({qj }, a) = \u03b4i\u000f (eclose(qj ), a)) and qj\u000f = qj , we have\nSk\nSk b\u000f \u000f\nj=1 \u03b4i ({qj }, a) =\nj=1 \u03b4i ({qj }, a). Therefore, we have\nb\u000f (Q\u000fin , w).\n\u03b4bi (Qin\n,\nw)\n=\n\u03b4\ni\ni\ni\nWhen we observe that Bi constructed in step 3 and Bi\u000f\naccept an infinite word if and only if this word visits the\naccepting states Fi and Fi\u000f infinitely many time. Since Fi =\nb\u000f \u000fin\nFi\u000f , and \u03b4bi (Qin\ni , w) = \u03b4i (Qi , w), we have a proof that the\ntwo B\u00fcchi automata accept the same infinite language.\nNext, we consider the finite language. From now on,\nf in\nBi = (Qi , Qin\n) refers to Bi returned by the\ni , \u03a3i , \u03b4i , Fi , Fi\nalgorithm. Note that a finite word is accepted by Bi\u000f if and\nonly if its corresponding run ends at one of the accepting\nstates q \u000f \u2208 Fi\u000f , such that there exists a loop starting from\nand ending at it, with only \u000f-transitions. By the construction\nof Bi , for the state q \u000f , there exist two corresponding states:\nq \u2208 Fi and q f in \u2208 Fif in . Note that a run over a word can\nreach q f in if and only if it can reach q. Because of (5), a finite\n\nword, whose corresponding run on Bi can reach q \u2208 Fi and\nq f in \u2208 Fif in if and only if its corresponding run on Bi\u000f can\nreach q \u000f \u2208 Fi\u000f , which implies that this finite word is accepted\nby both B\u00fcchi automata. Hence, we have a proof that the\ntwo B\u00fcchi automata accept the same finite language. Since\nBi\u000f and Bi have the same language, the proof is complete.\nInspired from LTL model checking [21], we define a\nproduct automaton to obtain the implementable local specification. First, we extend the transition system Ti with a\ndummy state labelled as Start that has a transition to the\ninitial state s0i . The addition of this dummy state is necessary\nin the case that the initial state already satisfies partially the\nlocal specification. Let Tbi be the extended finite transition\nsystem, then\nb hbi )\nTbi = (Sbi , sc\nci , \u03a3,\n(6)\n0i , \u2192\n\nwhere Sbi = Si \u222a {Start}, sc\nci =\u2192i \u222a \u2192s\n0i = Start, \u2192\nb = \u03a3 and hbi is the\nwhere \u2192s is defined as Start \u2192s s0i , \u03a3\nsame output map as hi but extended by mapping the Start\nstate to a dummy observation. Note that Tbi and Ti generate\nthe same language.\nNow, consider the transition system Tbi that describes\nthe dynamics of agent i and Bi that represents the local\nspecification for agent i. The following product automaton\ncaptures all the words in L(Bi ) that can be generated by\nagent i.\nDefinition 10: The product automaton Ei = Tbi \u2297 Bi\nb hbi ) and a mixed B\u00fcchi\nbetween a TS Tbi = (Sbi , sc\nci , \u03a3,\n0i , \u2192\nin\nautomaton Bi = (Qi , Qi , \u03a3Bi , \u03b4i , Fi , Fif in ), is a mixed\nf in\nB\u00fcchi automaton Ei = (QEi , Qin\nEi , \u03a3Ei , \u03b4Ei , FEi , FEi ),\nconsisting of\nbi \u00d7 Qi ;\n\u2022 a set of states QEi = S\nin\nin\nc\n\u2022 a set of initial states QE = s\n0i \u00d7 Qi ;\ni\n\u2022 a set of inputs \u03a3Ei = \u03a3Bi ;\n0 0\n\u2022 a transition function \u03b4Ei defined as (s , q )\n\u2208\n\u03b4Ei ((s, q), hi (s0 )) iff s\u2192\nci s0 and q 0 \u2208 \u03b4i (q, hi (s0 ));\nbi \u00d7 Fi ;\n\u2022 a set of infinitary accepting states FEi = S\nf in\nbi \u00d7 F f in .\n\u2022 a set of finitary accepting states FE\n=\nS\ni\ni\nInformally, the B\u00fcchi automaton Bi restricts the behavior of the transition system Tbi by permitting only certain\nacceptable transitions. Note that we modify the traditional\ndefinition of product automata [19] to accommodate the\nfinitary accepting states. An example showing how to construct the product automaton given a transition system and a\nmixed B\u00fcchi automaton is illustrated in Fig. 4. The following\nproposition shows that L(Ei ) is exactly the implementable\nlocal specification for agent i.\nProposition 5: Given any accepted word w of Bi , there\nexist at least one trajectory of Ti generating w if and only if\nw \u2208 L(Ei ).\nProof: \"\u21d0=\": Given an infinite word w \u2208 L(Ei ), there\nexists an infinite run rEi = (Start, qi (1))(si (1), qi (2)) . . .\nof Ei which generates w, where s(1) = s0i . We define\nthe projection of rEi onto Ti as \u03b3Ti (rEi ) = si (1)si (2) . . ..\nBy the definition of the product automaton, \u03b3Ti (rEi ) is an\ninfinite trajectory of Ti generating w, which is a word of Bi .\n\n\fTi :\na\n\nb\n\ns1\n\nb\n\ns2\n\nT\ufffdi\n\na\n\ns2\n\nb\ns4\n\nc\n\nq1\n\nInfinitary Accepting:\na\n\nFinitary Accepting:\n\n\u2297\na\n\ns1, q1\n\ns1, q2\n\ns1, q3\n\ns2, q1\n\ns2, q2\n\ns2, q3\n\ns3, q1\n\ns3, q2\n\ns3, q3\n\ns4\n\ns3\n\nBi :\n\nStart, q1\n\na\n\nc\ns3\n\nEi :\n\nb\n\ns1\n\nStart\n\nb\n\nq4\n\nc\n\nb\n\na\n\ns2, q4\n\nb\n\nc\n\nq3\n\ns1, q4\n\nb\n\nq2\n\ns4, q1\n\ns4, q2\n\ns4, q3\n\ns3, q4\n\nb\ns4, q4\n\nFig. 4. An example of constructing Ei given a B\u00fcchi automaton Bi and a transition system Ti . As we can see in Ei , some states are unreachable from\nthe initial state or cannot reach any accepting state. Such states can be removed to reduce the size of Ei .\n\nGiven a finite word wf in \u2208 L(Ei ) with length\nk, there exists a finite run in the form of rEi =\n(Start, qi (1))(si (1), qi (2)) . . . (si (k), qi (k +1)) of Ei which\ngenerates w. The projection of rEi on Ti can be written\nas si (1)si (2) . . . si (n). By the definition of the product\nautomaton, si (1)si (2) . . . si (n) is a finite trajectory of Ti\ngenerating the finite word wf in , which means there exists\na trajectory of Ti generating wf in \u2208 L(Bi ).\n\"=\u21d2\": Given an infinite word w = w(1)w(2) . . . accepted\nby Bi and a trajectory rTi = si (1)si (2) . . . of Ti satisfying\nw, then we have si (j) \u2192i si (j + 1) and w(j) = hi (si (j))\nfor all j \u2265 1. Given w, we can find an accepted run\nof Bi , denoted by qi (1)qi (2) . . ., which generates w. According to (6) and Def. 10, there must exist a run rEi =\n(Start, qi (1))(si (1), qi (2)) . . ., which is accepted by Ei and\ngenerate word w. Hence we have w \u2208 L(Ei ).\nSimilarly, given a finite word wf in \u2208 L(Bi ) with length k\nand a trajectory rTi = si (1)si (2) . . . si (k) of Ti generating\nwf in , then we have si (j) \u2192i si (j +1) and w(j) = hi (si (j))\nfor all 1 \u2264 j \u2264 k. Given wf in , we can find an accepted run\nof Bi , denoted by qi (1)qi (2) . . . qi (k + 1), which generates\nw. According to (6) and Def. 10, there must exist a run\nrEi = (Start, q(1))(si (1), q(2)) . . . (si (k), q(k + 1)), which\nis accepted by Ei and generate word wf in . Hence we have\nwf in \u2208 L(Ei ).\nC. Implementable Global Behaviors\nTo solve Prob. 1, we need to select a word w satisfying\nthe (trace-closed) global specification and also guarantee that\nwi = w \u0016\u03a3i is executable for all the agents i \u2208 I. Such a\nword can be obtained from the intersection of the global\nspecification and the implementable global behaviors of the\nteam, which can be modeled by the synchronous product of\nthe implementable local B\u00fcchi automata Ei .\nDefinition 11 ([22]): The synchronous product of n\nmixed B\u00fcchi automata Ei = (QEi , Qin\nEi , \u03a3Ei , \u03b4Ei , FEi ), denoted by kni=1 Ei , is an automaton P = (QP , Qin\nP , \u03a3P , \u03b4P ),\nconsisting of\n\u2022 a set of states QP = QE1 \u00d7 . . . \u00d7 QEn ;\nin\nin\nin\n\u2022 a set of initial states QP = QE \u00d7 . . . \u00d7 QE ;\n1\nn\nn\n\u2022 a set of inputs \u03a3P = \u222ai=1 \u03a3Ei ;\n\na transition function \u03b4P : QP \u00d7 \u03a3P \u2192 2QP defined as\nq 0 \u2208 \u03b4P (q, \u03c3) such that if i \u2208 I\u03c3 , q 0 [i] \u2208 \u03b4i (q[i], \u03c3),\notherwise q[i] = q 0 [i], where I\u03c3 = {i \u2208 {1, . . . , n} |\n\u03c3 \u2208 \u03a3i } and q[i] denotes the ith component of q.\nThe synchronous product composes n components, each\nof which represents the implementable local specification Ei\nfor agent i. The synchronous product captures the synchronization among the agents as well as their parallel executions.\nInformally, a word w is accepted by P if and only if for each\ni \u2208 I, w \u0016\u03a3i is accepted by the corresponding component Ei .\nA method to find an accepted word of P is given in [22].\nThe next proposition shows that L(P) captures all possible\nglobal words that can be implemented by the team.\nProposition 6 ([22]): The language of P, where P =ki\u2208I\nEi , is equal to the product of the languages of Ei (i.e., ki\u2208I\nL(Ei )).\nFinally, we can produce the solution to Prob. 1 by selecting\nan arbitrary word w from L(P) \u2229 L(B\u03c6 ), obtaining the local\nword wi = w \u0016\u03a3i and generating the corresponding ccstrategy ric for each agent. To find w \u2208 L(P) \u2229 L(B\u03c6 ), we\ncan construct an automaton to accept L(P) \u2229 L(B\u03c6 ) because\nof the following proposition:\nProposition 7 ([22]): Let P 1 and P 2 be two synchronous\nproducts of mixed B\u00fcchi automata. Then a synchronous\nproduct P 3 can be effectively constructed such that L(P 3 ) =\nL(P 1 ) \u2229 L(P 2 ).\nSpecifically, we treat B\u03c6 as a synchronous product with\none component that includes only infinitary accepting states.\nThe overall approach is summarized in Alg. 3. The following\ntheorem shows that the output of Alg. 3 is indeed the solution\nto Prob. 1.\nTheorem 1: If L(B\u03c6 ) is trace-closed, the set of ccstrategies {ric , \u2208 I} obtained by Alg. 3 satisfies ki\u2208I {wi } =\n6\n\u2205 and ki\u2208I {wi } \u2286 L(B\u03c6 ), where wi is the corresponding\nword of Ti generated by ric .\nProof: Since w \u2208 L(B\u03c6 ) and L(B\u03c6 ) is trace-closed,\naccording to Prop: 2, we have ki\u2208I {wi } \u2286 L(B\u03c6 ). Since\nw \u2208ki\u2208I {wi }, we have ki\u2208I {wi } =\n6 \u2205. Since w \u2208 L(P)\nand L(P) =ki\u2208I L(Ei ), we have w \u2208ki\u2208I L(Ei ). According\nto Def. 6, wi \u2208 L(Ei ). According to Prop. 5, there exists a\ntrajectory of Ti ric generating wi , for all i \u2208 I.\n\u2022\n\n\fAlgorithm 3 : Synthesis of a set of cc-strategies for a team\nof agents from a global specification\nInput: A LTL formula \u03c6 over \u03a3, a distribution {\u03a3i \u2286\n\u03a3, i \u2208 I}, and a set of transition systems {Ti , i \u2208 I}\nOutput: A set of cc-strategies {ric , i \u2208 I}\n1: Convert \u03c6 to a B\u00fcchi automaton B\u03c6 using LTL2BA [18]\n2: Run Alg. 1\n3: if L(B\u03c6 ) is not trace-closed then\n4:\nreturn solution not found\n5: else\n6:\nConstruct Bi using Alg. 2 for each i \u2208 I\n7:\nConstruct Ei = Ti \u2297 Bi (Def. 10) for each i \u2208 I\n8:\nConstruct P (Def. 11) and then construct a synchronous product accepting L(P) \u2229 L(B\u03c6 )\n9:\nif L(P) \u2229 L(B\u03c6 ) = \u2205 then\n10:\nreturn solution not found\n11:\nelse\n12:\nObtain w \u2208 L(P) \u2229 L(B\u03c6 )\n13:\nObtain a set of local words {wi = w \u0016\u03a3i , i \u2208 I}\n14:\nConstruct a set of automata {Bic , i \u2208 I}, each of\nwhich accepts only the word wi .\n15:\nConstruct Eic = Bic \u2297 Ti (Def. 10) for all i \u2208 I\n16:\nFind an accepted run ri of Eic and project ri on Ti\nto obtain ric for all i \u2208 I.\n17:\nreturn {ric , i \u2208 I}\n18:\nend if\n19: end if\n\nRemark 3 (Completeness): In the case that L(B\u03c6 ) is\ntrace-closed, our approach is complete in the sense that we\nfind a solution to Prob. 1 if one exists. This follows directly\nfrom Prop. 5 and the fact that L(P) =ki\u2208I L(Ei ). If L(B\u03c6 )\nis not trace-closed, a complete solution to Prob. 1 requires\none to find a non-empty trace-closed subset of L(B\u03c6 ) if\none exists. This problem is not considered in this paper.\nTherefore, our overall approach to Prob. 1 is not complete.\nRemark 4 (Complexity): From a computational complexity point of view, the bottlenecks of the presented approach\nare the computations\nrelating to P, because |QP | is bounded\nQ\nabove by i\u2208I |QEi | and the upper bound of |QEi | is O(|Q|*\n|Si |). For most robotic applications, the size of the task\nspecification (i.e., |Q|) is usually much smaller comparing to\nthe size of the agent model (i.e., |Si |). Therefore, if we can\nshrink the size of QEi by removing the information about\nthe agent model from Ei , we can reduce the complexity\nsignificantly. Such reduction can be achieved by using LTL\nwithout the next operator and taking a stutter closure of Ei .\nThis will be addressed in our future work.\nV. AUTOMATIC D EPLOYMENT IN RULE\nIn this section, we show how our method can be used to\ndeploy a team of Khepera III car-like robots in our Robotic\nUrban-Like Environment (Fig. 1). The platform consists of\na collection of roads, intersections, and parking lots. Each\nintersection has traffic lights. The city is easily reconfigurable\nby re-taping the platform. All the cars can communicate\n\nH1\n\nH2\n\nP1\n\nP2\n\nR1r\n\nR5r\n\nI1\n\nI4\n\nR5l\nR2r\nR2l\nR1l\n\nR4r\n\nL1\nP4\n\nR4l\n\nP3\nI31\n\nR3l\nI2\n\nR3r\n\nI3\n\nP5\n\nFig. 5. Transition system T1 for robot 1. The states represents the vertices\nin the environmental graph (Fig. 1), s01 shows that robot 1 starts at R1r ;\n\u21921 captures the connectivity between the vertices; h1 captures the locations\nof the unsafe regions and the requests. The dummy request $1 is assigned\nto all the vertices that have no property and is omitted in this figure.\n\nthrough Wi-Fi with a desktop computer, which is used as an\ninterface to the user (i.e., to enter the global specification)\nand to perform all the computation necessary to generate the\nindividual cc-strategies. Once computed, these are sent to\nthe cars, which execute the task autonomously by interacting\nwith the environment and by communicating with each other,\nif necessary. We assume that inter-robot communication is\nalways possible.\nWe model the motion of each robot in the platform using\na transition system, as shown in Fig. 5. The set of states\nSi is the set of labels assigned to roads, intersections and\nparking lots (see Fig. 1) and the relation \u2192i shows how\nthese are connected. We distinguish one bound of a road\nfrom the other since the parking lots can only be located\non one side of each road. For example, we use R1r and\nR1l to denote the two bounds of road R1 . Each state of Ti\nis associated with a set of motion primitives. For example,\nat region R1r , which corresponds to the access point for\nparking lot P1 (see Fig. 5), the robot can choose between two\nmotion primitives: follow road and park, which allow\nthe robot to stay on the road or turn right into P1 . If the robot\nfollows the road, it reaches the vertex I2 , where three motion\nprimitives are available: U turn, turn right int, and\ngo straight int, which allow the robot to make a Uturn, turn right or go straight through the intersection. It\ncan be seen that, by selecting a motion primitive available\nat a region, the robot can correctly execute a trajectory of\nTi , given that it is initialized at a vertex of Ti . The choice\nof a motion primitive uniquely determines the next vertex.\nIn other words, a set of cc-strategies defined in Sec. III\nand obtained as described in Sec. IV can be immediately\nimplemented by the team.\nAssume that service requests, denoted by H1 , H2 , L1 , L2\nand L3 , occur at parking lots P1 , P2 , P4 , P5 and P3 , respectively. \"H\" stands for \"heavy\" requests requiring the efforts\nof multiple cars while \"L\" represents \"light\" requests that\n\n\fonly need one car to service. Specifically, H1 is shared by\nall three cars and H2 is shared between car 1 and 2. As we\ncan see in Fig. 1, the number of parking spaces of a parking\nlot equals the number of cars needed to service the request\nthat occurs at this parking lot. For example, P1 where H1\noccurs has three parking spaces. Besides the set of requests,\nwe also consider some regions to be unsafe. In this example,\nwe assume that intersection I3 is unsafe for all robots before\nrequest H1 is serviced. We use the output map hi of Ti\n(see Fig. 5) to capture the locations of requests and unsafe\nregions. A \"dummy request\" $i is assigned to all the other\nregions. We use a special semantics for $i : a robot does not\nservice any request when visiting a region where $i occurs.\nWe model the capabilities of the cars to service requests\nwhile considering unsafe regions as a distribution: \u03a31 =\n{H1 , H2 , L1 , I31 , $1 }, \u03a32 = {H1 , H2 , L2 , I32 , $2 } and \u03a33 =\n{H1 , L3 , I33 , $3 }. Note that we treat the unsafe region I3 as\nan independent property assigned to each car since it does\nnot require the cooperation of the cars. We aim to find a\nsatisfying set of individual cc-strategies for each robot to\nsatisfy the global specification \u03c6, which is the conjunction\nof the following LTL formulas over the set of properties\n\u03a3 = {H1 , H2 , L1 , L2 , L3 , I31 , I32 , I33 , $1 , $2 , $3 }:\n1) Request H2 is serviced infinitely often.\n\u0003\u2666H2\n2) First service request H1 , then service request L1 and\nL2 regardless of the order or request L3 .\n\u2666(H1 \u2227 (\u2666(L1 \u2227 L2 ) \u2228 \u2666L3 ))\n3) Do not visit intersection I3 until H1 is serviced.\n\u00ac(I31 \u2228 I32 \u2228 I33 ) U H1\nBy applying Alg. 3, we first learn that the language satisfying \u03c6 is trace-closed. Then, we obtain the implementable\nautomaton ki\u2208I Ei as described in Sec. IV-B and IV-C.\nFinally, we choose a word w \u2208 L(B\u03c6 ) \u2229 L(ki\u2208I Ei ) and\nproject w on the local alphabets \u03a3i , i \u2208 {1, 2, 3} to obtain\nthe local words, which lead to the following cc-strategies:\n\n(1)\n\n(2)\n\n(3)\n\n(4)\n\n(5)\n\n(6)\n\nFig. 6. Six snapshots from the deployment corresponding to the given\ncc-strategies. The labels for the roads, intersections, and parking spaces are\ngiven in Fig. 1. (1) the position of the cars immediately after the initial time,\nwhen robots 1, 2 and 3 are on roads R1r , R5r and R2r , respectively; (2)\nrobot 2 is waiting for the other two robots to enter parking lot P1 at which\nthe heavy request H1 occurs; (3) both robots 2 and 3 are at P1 waiting for\nrobot 1; (4) all three robots are at P1 simultaneously, and therefore request\nH1 is serviced; (5) robot 3 services the light request L3 at P3 and finishes\nits task; (6) eventually robots 1 and 2 stop at P2 and service H2 together\ninfinitely many times.\n\nVI. C ONCLUSIONS AND F UTURE W ORKS\nWe present an algorithmic framework to deploy a team\nof agents from a task specification given as an LTL formula\nover a set of properties. Given the agent capabilities to satisfy\nthe properties, and the possible cooperation requirements\nfor the shared properties, we find individual control and\ncommunication strategies such that the global behavior of\nthe system satisfies the given specification. We illustrate the\nproposed method with experimental results in our Robotic\nUrban-Like Environment (RULE).\nAs future work, we will consider reducing the computational complexity and applying this approach to a team\nof agents with continuous dynamics. Also, we plan to\naccommodate more realistic models of agents that can capture uncertainty and noise in the system, such as Markov\nDecision Processes(MDP) and Partially Observed Markov\nDecision Processes(POMDP), and probabilistic specification\nlanguages such as PLTL.\nR EFERENCES\n\nr1c\nr2c\nr3c\n\n=\n=\n=\n\nR1r I2 R2r I1 R1r P1 R1r I2 R3r I3 R4r I4 R5r P2 P2 . . . ,\nR5r I4 R1r P1 R1r I2 R2r I1 R5l I4 R5r P2 P2 . . . ,\nR2r I1 R1r P1 R1r I2 R1l P3 .\n\nThe language satisfying the global specification \u03c6 includes\nonly infinite words. Hence, both cars 1 and 2 have infinite\ncc-strategies, since H2 needs to be serviced infinitely many\ntimes. Note that car 3 has a finite cc-strategy. The synchronization is only triggered when the cars are about to service\nshared requests, i.e., when at P1 and P2 . Besides these\nsynchronization moments, the cars follow their cc-strategies\nand execute their individual tasks in parallel, which speed\nup the process of accomplishing the global task. Snapshots\nfrom a movie of the actual deployment are shown in Fig.\n6. The movie of the deployment in the RULE platform is\navailable at http://hyness.bu.edu/CDC2011.\n\n[1] M. Kloetzer and C. Belta, \"A fully automated framework for control of\nlinear systems from temporal logic specifications,\" IEEE Transactions\non Automatic Control, vol. 53, no. 1, pp. 287\u2013297, 2008.\n[2] H. K. Gazit, G. Fainekos, and G. J. Pappas, \"Where's Waldo?\nSensor-based temporal logic motion planning,\" in IEEE Conference\non Robotics and Automation, Rome, Italy, 2007.\n[3] T. Wongpiromsarn, U. Topcu, and R. M. Murray, \"Receding horizon\ntemporal logic planning for dynamical systems,\" in IEEE Conference\non Decision and Control, Shanghai, China, 2009.\n[4] M. M. Quottrup, T. Bak, and R. Izadi-Zamanabadi, \"Multi-robot\nmotion planning: a timed automata approach,\" in Proceedings of the\n2004 IEEE International Conference on Robotics and Automation,\nNew Orleans, LA, April 2004, pp. 4417\u20134422.\n[5] S. Karaman and E. Frazzoli, \"Sampling-based motion planning with\ndeterministic \u03bc-calculus specifications,\" in IEEE Conference on Decision and Control, Shanghai, China, 2009, pp. 2222 \u2013 2229.\n[6] Y. Chen, X. C. Ding, A. Stefanescu, and C. Belta, \"A formal approach\nto deployment of robotic teams in an urban-like environment,\" in 10th\nInternational Symposium on Distributed Autonomous Robotics Systems\n(DARS), 2010 (to appear).\n\n\f[7] R. Alur, T. Henzinger, G. Lafferriere, and G. Pappas, \"Discrete\nabstractions of hybrid systems,\" Proceedings of the IEEE, 2000.\n[8] R. Milner, Communication and Concurrency. Englewood CliDs, NJ:\nPrentice-Hall, 1989.\n[9] P. Tabuada and G. Pappas, \"Linear time logic control of discrete-time\nlinear sys.\" IEEE Transactions on Automatic Control, vol. 51, no. 12,\npp. 1862\u2013 1877, 2006.\n[10] A. Tiwari and G. Khanna, \"Series of abstractions for hybrid automata,\"\nin Hybrid Systems: Computation and Control HSCC, ser. LNCS, vol.\n2289, 2002, pp. 465\u2013478.\n[11] S. R. Lindemann, I. I. Hussein, and S. M. Lavalle, \"Real time feedback\ncontrol for nonholonomic mobile robots with obstacles,\" in IEEE\nConference on Decision and Control, 2006.\n[12] M. Kloetzer and C. Belta, \"Automatic deployment of distributed\nteams of robots from temporal logic motion specifications,\" IEEE\nTransactions on Robotics, vol. 26, no. 1, pp. 48\u201361, 2010.\n[13] M. Karimadini and H. Lin, \"Synchronized task decomposition for\ncooperative multi-agent systems,\" Co, vol. abs/0911.0231, 2009.\n[14] M. Mukund, \"From global specifications to distributed implementations,\" in Synthesis and Control of Discrete Event Systems. Kluwer,\n2002, pp. 19\u201334.\n[15] A. Mazurkiewicz, \"Introduction to trace theory,\" in The Book of\nTraces. WorldSciBook, 1995, pp. 3\u201341.\n[16] D. Peled, T. Wilke, and P. Wolper, \"An algorithmic approach for checking closure properties of temporal logic specifications and omegaregular languages,\" Theoretical Computer Science, vol. 195, no. 2,\npp. 183\u2013203, 1998.\n[17] M. Vardi and P. Wolper, \"Reasoning about infinite computations,\"\nInformation and Computation, vol. 115, no. 1, pp. 1\u201337, 1994.\n[18] P. Gastin and D. Oddoux, \"Fast LTL to B\u00fcchi automata translation,\"\nLecture Notes in Computer Science, pp. 53\u201365, 2001.\n[19] C. Baier and J. Katoen, Principles of Model Checking. MIT Press,\n2008.\n[20] M. Z. Kwiatkowska, \"Event fairness and non-interleaving concurrency,\" in Formal Aspects of Computing, vol. 1, 1989, pp. 213\u2013228.\n[21] E. M. Clarke, D. Peled, and O. Grumberg, Model Checking. MIT\nPress, 1999.\n[22] P. Thiagarajan, \"PTL over product state spaces,\" Technical Report\nTCS-95-4, School of Mathematics, SPIC Science Foundation, 1995,\nTech. Rep.\n[23] J. Hopcroft, R. Motwani, and J. D. Ullman, Introduction to Automata\nTheory, Languages, and Computation. Addison Wesley, 2007.\n\n\f"}