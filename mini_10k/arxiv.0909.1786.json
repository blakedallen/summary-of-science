{"id": "http://arxiv.org/abs/0909.1786v1", "guidislink": true, "updated": "2009-09-09T18:10:46Z", "updated_parsed": [2009, 9, 9, 18, 10, 46, 2, 252, 0], "published": "2009-09-09T18:10:46Z", "published_parsed": [2009, 9, 9, 18, 10, 46, 2, 252, 0], "title": "DBMSs Should Talk Back Too", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0909.3344%2C0909.0418%2C0909.1200%2C0909.0853%2C0909.3303%2C0909.1279%2C0909.0317%2C0909.5465%2C0909.4460%2C0909.3169%2C0909.1350%2C0909.5168%2C0909.0455%2C0909.1661%2C0909.5203%2C0909.3525%2C0909.4257%2C0909.0578%2C0909.3739%2C0909.0554%2C0909.2507%2C0909.3650%2C0909.2491%2C0909.0676%2C0909.0844%2C0909.1746%2C0909.2513%2C0909.2595%2C0909.3734%2C0909.3563%2C0909.1786%2C0909.2236%2C0909.2456%2C0909.5039%2C0909.1808%2C0909.0535%2C0909.4422%2C0909.2860%2C0909.0304%2C0909.0670%2C0909.3448%2C0909.4956%2C0909.0447%2C0909.2401%2C0909.1452%2C0909.3621%2C0909.4926%2C0909.2867%2C0909.0572%2C0909.1121%2C0909.5231%2C0909.2011%2C0909.0336%2C0909.0807%2C0909.0369%2C0909.5256%2C0909.3998%2C0909.1724%2C0909.2754%2C0909.3700%2C0909.1737%2C0909.0372%2C0909.0711%2C0909.1549%2C0909.3028%2C0909.4390%2C0909.5370%2C0909.0819%2C0909.4968%2C0909.3517%2C0909.0465%2C0909.0229%2C0909.4399%2C0909.3239%2C0909.4442%2C0909.3831%2C0909.2365%2C0909.2446%2C0909.3423%2C0909.2800%2C0909.4085%2C0909.1455%2C0909.3049%2C0909.0543%2C0909.0436%2C0909.2629%2C0909.3943%2C0909.4987%2C0909.3117%2C0909.5633%2C0909.5453%2C0909.3768%2C0909.4524%2C0909.1859%2C0909.4444%2C0909.0574%2C0909.3567%2C0909.3118%2C0909.3461%2C0909.2758%2C0909.0898&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "DBMSs Should Talk Back Too"}, "summary": "Natural language user interfaces to database systems have been studied for\nseveral decades now. They have mainly focused on parsing and interpreting\nnatural language queries to generate them in a formal database language. We\nenvision the reverse functionality, where the system would be able to take the\ninternal result of that translation, say in SQL form, translate it back into\nnatural language, and show it to the initiator of the query for verification.\nLikewise, information extraction has received considerable attention in the\npast ten years or so, identifying structured information in free text so that\nit may then be stored appropriately and queried. Validation of the records\nstored with a backward translation into text would again be very powerful.\nVerification and validation of query and data input of a database system\ncorrespond to just one example of the many important applications that would\nbenefit greatly from having mature techniques for translating such database\nconstructs into free-flowing text. The problem appears to be deceivingly\nsimple, as there are no ambiguities or other complications in interpreting\ninternal database elements, so initially a straightforward translation appears\nadequate. Reality teaches us quite the opposite, however, as the resulting text\nshould be expressive, i.e., accurate in capturing the underlying queries or\ndata, and effective, i.e., allowing fast and unique interpretation of them.\nAchieving both of these qualities is very difficult and raises several\ntechnical challenges that need to be addressed. In this paper, we first expose\nthe reader to several situations and applications that need translation into\nnatural language, thereby, motivating the problem. We then outline, by example,\nthe research problems that need to be solved, separately for data translations\nand query translations.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0909.3344%2C0909.0418%2C0909.1200%2C0909.0853%2C0909.3303%2C0909.1279%2C0909.0317%2C0909.5465%2C0909.4460%2C0909.3169%2C0909.1350%2C0909.5168%2C0909.0455%2C0909.1661%2C0909.5203%2C0909.3525%2C0909.4257%2C0909.0578%2C0909.3739%2C0909.0554%2C0909.2507%2C0909.3650%2C0909.2491%2C0909.0676%2C0909.0844%2C0909.1746%2C0909.2513%2C0909.2595%2C0909.3734%2C0909.3563%2C0909.1786%2C0909.2236%2C0909.2456%2C0909.5039%2C0909.1808%2C0909.0535%2C0909.4422%2C0909.2860%2C0909.0304%2C0909.0670%2C0909.3448%2C0909.4956%2C0909.0447%2C0909.2401%2C0909.1452%2C0909.3621%2C0909.4926%2C0909.2867%2C0909.0572%2C0909.1121%2C0909.5231%2C0909.2011%2C0909.0336%2C0909.0807%2C0909.0369%2C0909.5256%2C0909.3998%2C0909.1724%2C0909.2754%2C0909.3700%2C0909.1737%2C0909.0372%2C0909.0711%2C0909.1549%2C0909.3028%2C0909.4390%2C0909.5370%2C0909.0819%2C0909.4968%2C0909.3517%2C0909.0465%2C0909.0229%2C0909.4399%2C0909.3239%2C0909.4442%2C0909.3831%2C0909.2365%2C0909.2446%2C0909.3423%2C0909.2800%2C0909.4085%2C0909.1455%2C0909.3049%2C0909.0543%2C0909.0436%2C0909.2629%2C0909.3943%2C0909.4987%2C0909.3117%2C0909.5633%2C0909.5453%2C0909.3768%2C0909.4524%2C0909.1859%2C0909.4444%2C0909.0574%2C0909.3567%2C0909.3118%2C0909.3461%2C0909.2758%2C0909.0898&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Natural language user interfaces to database systems have been studied for\nseveral decades now. They have mainly focused on parsing and interpreting\nnatural language queries to generate them in a formal database language. We\nenvision the reverse functionality, where the system would be able to take the\ninternal result of that translation, say in SQL form, translate it back into\nnatural language, and show it to the initiator of the query for verification.\nLikewise, information extraction has received considerable attention in the\npast ten years or so, identifying structured information in free text so that\nit may then be stored appropriately and queried. Validation of the records\nstored with a backward translation into text would again be very powerful.\nVerification and validation of query and data input of a database system\ncorrespond to just one example of the many important applications that would\nbenefit greatly from having mature techniques for translating such database\nconstructs into free-flowing text. The problem appears to be deceivingly\nsimple, as there are no ambiguities or other complications in interpreting\ninternal database elements, so initially a straightforward translation appears\nadequate. Reality teaches us quite the opposite, however, as the resulting text\nshould be expressive, i.e., accurate in capturing the underlying queries or\ndata, and effective, i.e., allowing fast and unique interpretation of them.\nAchieving both of these qualities is very difficult and raises several\ntechnical challenges that need to be addressed. In this paper, we first expose\nthe reader to several situations and applications that need translation into\nnatural language, thereby, motivating the problem. We then outline, by example,\nthe research problems that need to be solved, separately for data translations\nand query translations."}, "authors": ["Alkis Simitsis", "Yannis Ioannidis"], "author_detail": {"name": "Yannis Ioannidis"}, "author": "Yannis Ioannidis", "arxiv_comment": "CIDR 2009", "links": [{"href": "http://arxiv.org/abs/0909.1786v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0909.1786v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DB", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DB", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.HC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0909.1786v1", "affiliation": "HP Labs", "arxiv_url": "http://arxiv.org/abs/0909.1786v1", "journal_reference": null, "doi": null, "fulltext": "DBMSs Should Talk Back Too\nYannis Ioannidis\n\nAlkis Simitsis\n\nUniversity of Athens\nAthens, Hellas (Greece)\n\nHP Labs\nPalo Alto, California, USA\n\nyannis@di.uoa.gr\n\nalkis@hp.com\n\nABSTRACT\nNatural language user interfaces to database systems have\nbeen studied for several decades now. They have mainly focused on parsing and interpreting natural language queries\nto generate them in a formal database language. We envision the reverse functionality, where the system would be\nable to take the internal result of that translation, say in\nSQL form, translate it back into natural language, and show\nit to the initiator of the query for verification. Likewise, information extraction has received considerable attention in\nthe past ten years or so, identifying structured information\nin free text so that it may then be stored appropriately and\nqueried. Validation of the records stored with a backward\ntranslation into text would again be very powerful. Verification and validation of query and data input of a database\nsystem correspond to just one example of the many important applications that would benefit greatly from having mature techniques for translating such database constructs into\nfree-flowing text.\nThe problem appears to be deceivingly simple, as there are\nno ambiguities or other complications in interpreting internal database elements, so initially a straightforward translation appears adequate. Reality teaches us quite the opposite, however, as the resulting text should be expressive,\ni.e., accurate in capturing the underlying queries or data,\nand effective, i.e., allowing fast and unique interpretation of\nthem. Achieving both of these qualities is very difficult and\nraises several technical challenges that need to be addressed.\nIn this paper, we first expose the reader to several situations and applications that need translation into natural\nlanguage, thereby, motivating the problem. We then outline,\nby example, the research problems that need to be solved,\nseparately for data translations and query translations.\n\n1.\n\nINTRODUCTION\n\nThe role of a database management system (DBMS) installed in a particular environment is to connect its users\nwith its underlying content. Natural language (NL) is of-\n\nThis article is published under a Creative Commons License Agreement\n(http://creativecommons.org/licenses/by/3.0/).\nYou may copy, distribute, display, and perform the work, make derivative\nworks and make commercial use of the work, but you must attribute the\nwork to the author and CIDR 2009.\n4th Biennial Conference on Innovative Data Systems Research (CIDR)\nJanuary 4-7, 2009, Asilomar, California, USA\n\nten an important tool on both ends of this connection: on\none hand, users may interact with the system in natural\nlanguage, while on the other, the original database content\nmay be in natural language. Nevertheless, for high performance and effectiveness, DBMSs prefer to deal with structured elements internally. For this reason, much research has\nbeen conducted on translating natural language queries and\nother user interaction expressions to (mostly) SQL, as well\nas on translating natural language documents to (mostly relational) database records, by extracting information from\nthem. The above implies that the external components of\na DBMS environment often talk to the DBMS in natural\nlanguage. Shouldn't the DBMS also be able to talk back in\nthe same language?\nIn this paper, we answer this question affirmatively and\ndescribe several applications where such translation of DBMS\ninternal elements to natural language would be very beneficial. Obtaining such DBMS-generated natural language\nconstructs, however, is far from trivial, making this largelyignored problem a rich field for exploration. Recent studies\nadvocate for \u2013and motivate to some extent\u2013 the need for\nsuch functionality. Automating computer-to-human speech\ntranslation is recognized as one of the seven most important\nIT challenge for the next 25 years by Gartner analysts who\nexamine technologies that will have a broad impact on all\naspects of people's lives [3]. In this direction, we identify\nwhat we believe are the key research issues that arise and\nneed to be addressed and some ideas for possible solutions.\nAlthough related to some extent, translating structured\ndatabase content into natural-language free text is quite distinct a problem from translating queries expressed in a formal language into equivalent commands in natural language.\nThe former is difficult because of the size of the underlying\ndata, the need to make choices on what to capture in a short\nnarrative and what to ignore, and the repetitive nature of\nsome data in the database that need to be factored out and\nexpressed once in the text generated for effective reading by\nthe user. The latter is difficult because the size and complexity of a query are essentially arbitrary and have no upper\nbounds (whereas the contents of a database necessarily follow the schema structure, which is bounded), thus allowing\ngeneration of rather convoluted queries, whose translation\nis a great challenge.\nAny attempt towards a solution of the content and/or\nthe query translation problems must balance out the desired concision and naturality of the generated text with\nthe complexity of the translation process itself. Our preliminary efforts have been leading to graph representations\n\nCIDR Perspectives 2009\n\n\fof database contents and queries (different from one to the\nother), template phrases associated with parts of the graph,\nand then graph traversal in particular directions to compose\nthe templates found on the way into the final text formation.\nIn the next section, we explore translations of database\ncontents, for which our work has progressed further, while\nin the section after that, we explore translations of database\nqueries. We conclude with some additional thoughts on the\nwhole problem.\n\nDIRECTED\n\nMOVIES\n\nCAST\n\nmid\ndid\n\nid\ntitle\nyear\n\nmid\naid\nrole\n\nGENRE\n\nACTOR\n\nmid\ngenre\n\nid\nname\n\nDIRECTOR\nid\nname\nbdate\nblocation\n\nFigure 1: Example database schema\n\n2.\n2.1\n\nDATABASE CONTENTS\nMotivation\n\nConsider that one wants to have a textual description of\nthe contents of a database. If the database is large, it would\nmake sense to create a textual summary of it, otherwise,\nthe result can be a description of the full contents. There\nare several situations where such translation into natural\nlanguage may be useful and desirable. Creating a short\ncompany description for a business plan or a bank-loan application or collateral material for marketing are some instances. Given other appropriate schemas, one can imagine\ntextual descriptions in several other practical cases: a short\ndescription of a museum's exhibits, possibly customized to\na visitor's particular interests; a brief history of a patient's\nmedical conditions; the highlights of a collection in a digital library, with a few sentences on the main authors in the\ncollection; a summary of a theater play in an information\nportal; and others.\nWhatever holds for whole databases, of course, holds for\nquery answers as well, especially those with some nontrivial\nstructure, i.e., entire relational databases, complex objects,\nand so on. Textual answers are often preferred by users,\nwhether experienced or not, as they convey the essence of\nthe entire query answer in an immediately understandable\nway. Moreover, the formation of textual answers becomes\ncritical in all situations for people with visual impairments\nor reading disabilities. Using a speech recognizer [2, 7] to\nconvert a speech signal to a query and a text-to-speech system (TTS) [7] to convert the textual form of the query answer into speech, these people would be given the chance to\ninteract with information systems, orally pose queries, and\nlisten to their answers.\nClearly, the idea of translating data into natural language\ncan be extended to all other forms of primary or derived\ndata that a database may contain. Database samples, histograms, data distribution approximations are all, in some\nsense, small databases and can be summarized textually as\nabove. Describing the schema itself, its basic entities, relationships, and other conceptual primitives offered by the\nmodel it is based on, is just a special case of a database description. User profiles maintained by the system for offering\npersonalized answers, browsing indexes, and other forms of\nmetadata are amenable to and may benefit from naturallanguage translation as well.\n\n2.2\n\nTranslating Database Content\n\nDatabases can be modeled conveniently as graphs, i.e.,\ndatabase schema graphs. The main entities, i.e., relations\nand attributes, constitute the nodes of the graph, whereas\nthe relationships among them, i.e., join and projection edges,\nrepresent the edges of the graph. A projection edge, one for\neach attribute node, emanates from its container relation\n\nnode and ends at the attribute node, representing the possible projection of the attribute in a query answer. A join\nedge emanates from a relation node and ends at another relation node, representing a potential join through a primary\nkey - foreign key relationship between these relations.\nThe graphical representation of the database schema facilitates its translation. In a previous work, we proposed\na template-based method for appropriately annotating the\ndatabase schema graph, and then showed how a graph traversal can produce meaningful narratives [9]. The solution suggests that both nodes and edges are annotated by appropriate template labels. These labels are assigned once, e.g.,\nby the designer, at an initial design phase, and are instantiated at query time, in order to produce textual descriptions.\nSome indicating examples will be shown in the subsequent\nparagraphs, as the overall approach is outlined. For the\nfull-fledged approach, we refer the interested reader to our\nprevious work [9].\nConsider for example a simple schema describing a movie\ndatabase (see Fig. 1). For clarity of presentation, only relation nodes and join edges are depicted. (Without loss of\ngenerality we may assume that the names of relations and\nattributes are meaningful; otherwise, appropriate aliases can\nbe used.) For translation purposes, we consider that each\nrelation has a conceptual and a physical meaning. For example, the relation M OV IE conceptually represents \"movies\"\nin real world. The physical meaning of a relation is represented by the name of one of its attributes, the one that\nis most characteristic of the relation tuples; this attribute\nis termed the heading attribute. In our example, T IT LE\nis the heading attribute for the relation M OV IE. Textual\nsentences about the relation contents are composed using\ntemplates based on the heading attribute, which is usually\nused as the subject of these sentences. For example, when\nwe want to refer to a movie, practically, we refer to its heading attribute, the title. A template attached as a label to the\nprojection edge connecting the relation M OV IE to its attribute Y EAR may be \"the YEAR of a MOVIE(.TITLE)\".\nSimilarly, a template attached to a join edge signifies the relationship between the heading attributes of the relations involved; e.g., \"the GENRE(.GENRE) of a MOVIE(.TITLE)\".\nThe translation of a simple database schema graph containing a single relation is performed by composing phrases\nbased on the templates of the respective projection edges\nconnecting the relation with its attributes. There are two\nalternatives for the translation of a relation's contents: (a)\ncreate a sentence using only a template based on the heading attribute of the relation or (b) using one or more templates to construct a sentence that combines the information\nstored in the heading attribute and the other attributes of\nthe relation under consideration. The former results into\n\nCIDR Perspectives 2009\n\n\fthe creation of simple phrases, such as \"The director's name\nis Woody Allen\". When we wish to combine information\ncoming from a single relation with information coming from\nother relations, then, such a short version frequently seems\nto be adequate (more details are given below). The second\nalternative for translating in more detail the content of a single relation results into the creation of different clauses, one\nper attribute, where inevitably the same subject has to be\nrepeated many times. To avoid this, we need to create these\nclauses using the appropriate templates, and then find common expressions in the clauses and replace them accordingly.\nFor example, for a translation of relation DIRECT OR involving the attributes BDAT E and BLOCAT ION , which\nstore information about the birth date and birth location of\na director, we may use the following templates that connect\nthese attributes with DN AM E, the heading attribute of the\nrelation ('+' indicates concatenation):\nDN AM E + \" was born\" + \" in \" + BLOCAT ION\nDN AM E + \" was born\" + \" on \" + BDAT E\nThe mechanism for resolving common expressions identifies DN AM E and \" was born\" as such and, instead of\ncreating two different phrases, it creates one that combines\nboth pieces of data:\nDN AM E was born in BLOCAT ION on BDAT E\nFor the translation of the contents of a whole database\ncontaining multiple relations, we need to traverse the entire schema graph. This can be realized in several ways,\ne.g, with a simple DFS-like traversal starting from a central\npoint of interest [9]. During this traversal, three possible\nstructural patterns on the graph can be found: the unary\nRi\npattern (Ri \u2212 Rj ), the join pattern (Ri1 > Rj ), and the split\nRj\n\n2\n\npattern (Ri <Rj1 ). Translating multiple relations requires\n2\na careful and well-tuned combination of the above patterns\nfor ensuring accurate and meaningful results.\nRj\nFor example, a split pattern Ri <Rj1 may create clauses\n2\nwhere the subject comes from the Ri relation and the rest\n(e.g., the predicates) is based on the Rj1 and Rj2 relations.\nA possible translation may contain two different template\nclauses involving relations Ri \u2013 Rj1 and Ri \u2013 Rj2 , respectively; an obvious challenge is to avoid repetition of the same\ninformation from Ri . (Observe that this case differs from\nthe previous example, as in here, the repetition involves the\nwhole information of Ri and how that merges meaningfully\nwith the translated content of the other two relations.) An\nappealing translation can be created by appropriately merging the above template clauses for producing a single template where the subordinate clauses are combined with a\nconjunctive term (e.g., \"and\"). For instance, the hypothetical schema DIRECT OR\u2190M OV IES\u2192ACT OR, where for\nsome reason the translation has to be realized following the\ndirection of the arrows, constitutes a split pattern. The\nstraightforward translation would contain one phrase combining only the heading attributes of the involved relations,\nand then, phrases translating the content of the each individual relation. However, instead of getting a vapid narrative\nlike:\n\"The movie M1 involves the director D1 and the actor\nA1. The director D1 was born in Italy. The actor A1\nis Greek.\"\n\nit would be more appealing to follow the aforementioned\nlogic and get the following translation:\n\"The movie M1 involves the director D1 who was born\nin Italy and the actor A1 who is Greek.\"\nAs a more detailed example, assume that we want to\ntranslate contents of a subset of the graph depicted in Fig.\n1 that contains relations DIRECT OR and M OV IE (this\ncase resembles a sequence of unary patterns: DIRECT OR\n\u2013 DIRECT ED \u2013 M OV IE). DIRECT ED participates in\nthe translation process (as a node of the database schema\ngraph) only for connecting the other two; none of its attributes contributes to the result, so it is not taken under\nconsideration for the construction of the narrative. Therefore, conceptually, this case resembles a single unary pattern:\nDIRECT OR \u2013 M OV IE. Consider, for example, that the\ncontents of this schema subset consist of three movies of director \"Woody Allen\". In this case, translation proceeds as\nfollows. First, we construct the template clause that corresponds to relation DIRECT OR:\nDN AM E was born in BLOCAT ION on BDAT E\nThe corresponding template clause for relation M OV IE\ncan be the following:\nT IT LE + \" (\" + Y EAR + \")\"\nSince relation M OV IE may contain more than one tuple,\nwe iterate over the above template for all the tuples. We\nproceed with the clause that corresponds to the relationship\nthat connects DIRECT OR and M OV IE. The template\nlabel of this relationship can be represented by the following:\n\"As a director, \" + DN AM E +\n\"p s work includes \" + M OV IE LIST\nM OV IE LIST contains two loops bounded by the arity\nof the movie tuples (similarly, arity of movie titles) and may\nbe defined as:\nDEF IN E M OV IE LIST as\n[i < arityOf (T IT LE)]\n{T IT LE[i] + \" (\" + Y EAR[i] + \"), \"}\n[i = arityOf (T IT LE)]\n\" and \" + {T IT LE[i] + \" (\" + Y EAR[i] + \").\"}\nThe result of applying all these steps, including instantiation of the template and the appropriate concatenations,\non the database part that is relevant to \"Woody Allen\" in\nrelation DIRECT OR may be the following:\n\"Woody Allen was born in Brooklyn, New York,\nUSA on December 1, 1935. As a director, Woody\nAllen's work includes Match Point (2005), Melinda\nand Melinda (2004), and Anything Else (2003).\"\nWith a slightly different template, we could represent the\nsame information using more than one clause:\n\"Woody Allen was born in Brooklyn, New York, USA\non December 1, 1935. As a director, Woody Allen's\nwork includes Match Point, Melinda and Melinda,\nAnything Else. Match Point was released in 2005.\nMelinda and Melinda was released in 2004. Anything\nElse was released in 2003.\"\nThe two pieces of text have some critical differences. The\nfirst one is more compact, does not have any overlaps, is\n\nCIDR Perspectives 2009\n\n\fdeclarative, and resembles genuine natural language. On the\nother hand, its creation is more complex and in more complicated cases may even be infeasible. For instance, if relation\nM OV IE contains more attributes and multiple clauses are\nneeded to describe them, then it is difficult to create such\nelegant result with the template method. The second piece\nof text is constructed in a procedural manner and consists of\na coalescence of several simple sentences. This kind of synthesis is simpler to create and can be used to describe more\ncomplex database schema graphs. Automatically choosing\nbetween the two based on the characteristics of the database\npart concerned at any point is a great challenge.\nAnother observation concerns the text size. Although in\nprinciple, the approach outlined above works with databases\nof any size, translation of a database with a very large number of relations, attributes or tuples, will most likely lead to\nless meaningful or concise answers. Based on some limited\ninteraction with potential users, it is clear that meaningful\nand interesting answers are short. Hence, an additional challenge is limiting the resulting text to the most interesting\ninformation. This can be realized either with structural constraints affecting the traversal of the database schema graph\nbased on weights on its nodes and/or edges, or with some\nnotion of ranking of the relations and tuples involved. The\nlatter would force the most significant tuples to be presented\nfirst and the less significant tuples to be ignored according to\nappropriate constraints. Additionally, it is possible to have\npersonalized settings (e.g., different heading attributes for\nrelations or different weights on nodes and edges) in order\nto produce customized narratives for different users or user\ngroups.\n\nempty answer, it is nice to know the parts of the query that\nare responsible for the failure. Similarly, when a query is\nexpected to return a very large number of answers, it is useful to know the reasons, in case a rewrite would reduce the\nnumber significantly and would serve the user better.\nClearly, the same can be said about all other commands\na user may give to a database system. Insertions, deletions,\nand updates, especially those with complicated qualifications or nested constructs, will benefit from a translation\ninto natural language. Likewise for view definitions and integrity constraints, which borrow most of their syntax from\nqueries. Also, although here we focus on SQL, similar arguments can be made about Relational Algebra queries, RDF\nqueries in SPARQL or RQL, even Datalog programs, and\nothers. One can claim that novice users may benefit by\ntextual specification of even queries posed by filling out a\nform. Especially for large forms, where a user is likely to not\nknow the underlying semantic connections among the fields\npresented in the form, a textual explanation may come in\nhandy.\nNeedless to say, offering the functionality described above\nis not trivial for complicated queries and other commands.\nPart of the complexity lies with the fact that there are several alternative expressions of a query in a formal language\nthat are equivalent, based on associativity, commutativity,\nand other algebraic properties of the query constructs. Capturing the query elements in the right order so that the corresponding textual expression is natural and meaningful independent of the way the user has expressed the query is not\nstraightforward. Similarly, expressing queries with complex\nembeddings or aggregations is hard.\n\n3.\n\n3.2\n\nUSER INTERACTION ELEMENTS\n\n3.1\n\nMotivation\n\nTraditionally, the application of natural-language techniques to the front-end of an information systems environment has been one-directional: from NL descriptions to\nqueries production. In this section, we examine the other\ndirection as well: translation of queries into narratives.\nMoving temporarilly away from the schema of Fig. 1, consider the following schema with two tables: EM P (eid, sal,\nage, did) and DEP T (did, dname, mgr). Consider someone\nposing the following SQL query:\nselect e1.name\nfrom EMP e1, EMP e2, DPT d\nwhere e1.did=d.did and d.mgr=e2.eid\nand e1.sal>e2.sal\nThere are several reasons why having the system provide\na natural language interpretation of the query may be useful. Before the query is sent for execution, it may be nice\nfor the user to see it expressed in the most familiar way, as\nverification that the query captures correctly the intended\nmeaning. Seeing something like \"Find the names of employees who make more than their managers\" for the above\nquery will be very helpful in making sure that this was indeed the user's original intention. The more complicated\nthe query, the more important such feedback is.\nIn general, in any situation where explanation of queries\nis warranted, such textual interpretation may be very useful and effective. For example, when a query returns an\n\nGraph-based Query Representation\n\nTo abstract away the details of the above difficulties and\ntranslate queries in a generic fashion, a graph-based model\ncan be used. Such a model is useful since (a) it is generic\nenough to capture queries expressed in different languages,\n(b) it can be visualized easily, so it offers an additional opportunity for studying queries, and (c) it can be annotated\nappropriately with suitable templates, so a narrative can\nthen be created using appropriate parsing techniques.\nUnfortunately, the graph model presented in 2.2 cannot\ncapture the full expressive power of SQL or other common\nquery languages, since queries cannot be always expressed in\nterms of subgraphs of the database schema graph. (This will\nbecome clearer with the examples of Section 3.3.) Hence, an\nextension to the schema graph model is needed. Next, without loss of generality, we sketch the necessary characteristics\nof such a model, relying on well-defined standard techniques,\ni.e., UML notation.\nThe schema graph representing the query, i.e., the query\ngraph, comprises a set of nodes representing relations involved in the query, along with additional nodes representing other query functionality, e.g., group-by or order-by semantics. Each relation R participating in a query Q can\nbe considered as a parameterized class (see Fig. 2), where\nthe parameter is an alias for the relation, relation alias,\ncorresponding to the tuple variables of the relation. Such\nalias is useful when multiple instances (tuple variables) of a\nrelation participate in query Q. We extend the traditional\ndefinition of a class, and we consider that it comprises four\nparts. The first part specifies the name of the class, i.e., of\nthe relation, relation name, and it is tagged with the label\n\nCIDR Perspectives 2009\n\n\f<<FROM>>\nrel_name\n\n<<FROM>>\nMovies\n\n<<alias>>\nrel_alias\n\n<<SELECT>>\nrel_alias.rel_name.attr1: alias1\n...\nrel_alias.rel_name.attrn: aliasn\n<<WHERE>>\nun_constraint1\n...\nun_constraintm\n\n<<ORDER BY>>\nrel_alias.rel_name.attri\n...\nrel_alias.rel_name.attrj\n\nM.id = C.mid\n\n<<FROM>>\nCast\n<<SELECT>>\n\n<<alias>>\nC\nC.aid = A.id\n\n<<FROM>>\nActor\n\n<<alias>>\nA\n\n<<SELECT>>\n\n<<WHERE>>\n\n<<WHERE>>\n\n<<WHERE>>\nA.name = ``Brad Pitt''\n\n<<HAVING>>\n\n<<HAVING>>\n\n<<HAVING>>\n\nFigure 3: A simple path query (Q1)\nselect m.title\nfrom MOVIES m, CAST c, ACTOR a\nwhere m.id = c.mid and c.aid = a.id\nand a.name = 'Brad\n\nFigure 2: Schematic representation of a relation participating in a generic SQL query\n<<F ROM >>. The second part involves those attributes of\nrelation R that participate in query Q and is tagged with the\nlabel <<SELECT >>. The elements of this part follow the\nform: relation alias.relation name.attribute: attribute alias.\nThe third part involves query constraints and is tagged with\nthe label <<W HERE>>. The last part comprises grouping\nconstraints and is tagged with the label <<HAV IN G>>.\nThe grouping attributes and the ordering of the relation\nare captured by two UML notes, <<GROU P BY >> and\n<<ORDER BY >>, respectively.\nThe edges of the query graph can be generic join edges\nexpressing arbitrary join conditions, projection edges connecting the relation with its attributes contained in the\nquery, edges that connect the relation with elements of its\n'WHERE' and 'HAVING' parts and with the 'GROUP BY'\nand 'ORDER BY' notes, and edges that connect the inner\nand outer parts of a nested query. Similarly to the annotation of the database graph (see Section 2.2), template labels\ncan be assigned to those edges.\nHence, again, the translation can be realized in terms of\ntraversing the query graph; however, this is nontrivial for\nall query types. To illustrate the difficulty that such translations represent, we present below several SQL query examples of escalating complexity. All queries correspond to\nthe schema depicted in (Fig. 1) and, whenever possible, we\nshow the respective query graphs considering only relation\nnodes and join edges. We do not aim at demonstrating a\ncomplete solution; rather, our goal is to pinpoint the existing challenges, to present a categorization of queries w.r.t.\nthe effort needed for their translation into narratives, and to\nshow that a graph-based approach similar to the one used for\nthe translation of the content is feasible for a large variety\nof queries.\n\n3.3.1\n\n<<SELECT>>\nM.Movies.Title: title\n\n<<GROUP BY>>\nrel_alias.rel_name.attrx\n...\nrel_alias.rel_name.attry\n\n<<HAVING>>\nhol_constraint1\n...\nhol_constraintk\n\n3.3\n\n<<alias>>\nM\n\nInteresting Cases\nPath Queries\n\nThese are simple queries, whose graph representation is a\npath on the schema graph. Algebraically, these are selectproject-join (SPJ) queries with at most two joins per relation\nand only one instance (tuple variable) per relation.\nQuery 1. Consider a simple query, Q1, which involves\nthe relations M OV IES, CAST , and ACT OR as follows:\n\nThe graph-based representation of Q1, a simple path, is\ndepicted in Fig. 3. The joins are based on foreign key (FK)\nrelationships and are depicted as edges connecting the relations involved. Each class representing a relation contains the appropriate attributes or constraints. Like all path\nqueries, Q1 can be translated relatively easily: using translation mechanisms similar to those for database contents (see\nSection 2.2) and following a simple DFS-like traversal of the\nquery graph, we can compose sentences such as:\n\"Find the titles of movies where the actor Brad Pitt plays\".\nFurthermore, using more elaborated translation techniques,\nwhen more complex template labels are available, we can\nproduce even more natural phrases, like:\n\"Find movies where Brad Pitt plays\"\nSuch phrases are created when the heading attribute is\nreplaced by the conceptual meaning of the relation \u2013e.g,\n'title'\u2192'movies' and 'name'\u2192'actor'\u2013 or by the tuple variable \u2013e.g., 'name'\u2192'actor' \u2192'Brad Pitt'.\n\n3.3.2\n\nSubgraph Queries\n\nThese are somewhat more difficult queries, whose graph\nrepresentation is any (acyclic) subgraph of the schema graph\n(not necessarily a path). Algebraically, these are still selectproject-join (SPJ) queries with only one instance (tuple variable) per relation, but no constraint on the number of joins\na relation participates in.\nQuery 2. Consider the following query, Q2, which involves a large number of relations interconnected via FK\njoin relationships:\nselect a.name, m.title\nfrom MOVIES m, CAST c, ACTOR a,\nDIRECTED r, DIRECTOR d, GENRE g\nwhere m.id = c.mid and c.aid = a.id\nand m.id = r.mid and r.did = d.id\nand m.id = g.mid and d.name = 'G. Loucas'\nand g.genre = 'action'\nThe graph-based representation of Q2 is depicted in Fig.\n4. Given that subgraph queries do not deviate at all from the\nunderlying database schema, they can again be translated\nusing translation mechanisms similar to those for database\ncontents (see Section 2.2). For example, with appropriate\ntemplates, Q2 can be translated into:\n\"Find the actors and titles of action movies directed\nby G. Loucas\"\n\nCIDR Perspectives 2009\n\n\f<<FROM>>\nDirected\n\n<<alias>>\nR\nM.id = R.mid\n\n<<SELECT>>\n\n<<alias>>\nM\n<<FROM>>\nMovies\nM.id = C.mid\n<<SELECT>>\nM.Movies.Title: title\n\n<<FROM>>\nCast\n\n<<alias>>\nC\n\n<<WHERE>>\n\n<<WHERE>>\n\n<<WHERE>>\n\n<<HAVING>>\n\n<<HAVING>>\n\n<<FROM>>\nDirector\n\n<<alias>>\nD\n\n<<SELECT>>\n\nM.id = G.mid\n<<FROM>>\nGenre\n\nC.aid = A.id\n\n<<alias>>\nG\n\n<<SELECT>>\n\n<<FROM>>\nActor\n\n<<alias>>\nA\n\n<<SELECT>>\nA.Actor.name: A.name\n\n<<WHERE>>\nD.name = ``G. Loucas''\n\n<<WHERE>>\nG.genre = ``action''\n\n<<WHERE>>\n\n<<HAVING>>\n\n<<HAVING>>\n\n<<HAVING>>\n\nM.id = C1.mid\n\n<<FROM>>\nMovies\n<<SELECT>>\n\n<<WHERE>>\n\n<<WHERE>>\n\n<<HAVING>>\n\n<<HAVING>>\n\nC1.aid = A1.id\n\nR.did = D.id\n\n<<alias>>\nC1\n\n<<SELECT>>\n\n<<SELECT>>\n\n<<HAVING>>\n\n<<FROM>>\nCast\n\n<<FROM>>\nActor\n\n<<alias>>\nM\n\n<<FROM>>\nCast\n\nM.id = C2.mid\n\n<<SELECT>>\n<<WHERE>>\n<<HAVING>>\nC2.aid = A2.id\n\n<<alias>>\nA1\n\n<<SELECT>>\nA1.Actor.name: A1.name\n\n<<alias>>\nC2\n\n<<FROM>>\nActor\n\n<<alias>>\nA2\n\n<<SELECT>>\nA2.Actor.name: A2.name\n\nA1.id > A2.id\n\n<<WHERE>>\n\n<<WHERE>>\n\n<<HAVING>>\n\n<<HAVING>>\n\nFigure 5: A multi-instance query (Q3)\nFigure 4: A more complex subgraph query (Q2)\n\n3.3.3\n\n<<alias>>\nM\n<<FROM>>\nMovies\nM.id = C.mid\n<<SELECT>>\nM.Movies.Title: title\n\nGraph Queries\n\nAt the next level of difficulty, one finds queries that can\nstill be represented by a graph that is a (possibly cyclic)\nsubgraph of the schema graph or at least of an extension of\nit; in the sense that it may contain multiple instances of an\nexisting node. Algebraically, these are all select-project-join\n(SPJ) queries with no restrictions.\nQuery 3. Consider the following query, Q3, which involves two instances (tuple variables) of some relations:\nselect a1.name, a2.name\nfrom MOVIES m, CAST c1, ACTOR a1,\nCAST c2, ACTOR a2\nwhere m.id = c1.mid and c1.aid = a1.id\nand m.id = c2.mid and c2.aid = a2.id\nand a1.id > a2.id\n\n<<WHERE>>\n\nC.role = M.title\n\n<<HAVING>>\n\n<<FROM>>\nCast\n\n<<alias>>\nC\n\n<<SELECT>>\n<<WHERE>>\n<<HAVING>>\n\nFigure 6: A cyclic query (Q4)\nselect m.title from MOVIES m, CAST c\nwhere m.id = c.mid and c.role = m.title\nObtaining its translation from its query graph (Fig. 6) is\na challenge:\n\"Find movies whose title is one of their roles\"\n\n3.3.4\n\nThe graph-based representation of Q3 is depicted in Fig.\n5. It is still based on the schema graph, but now it has\npieces of it repeated in multiple copies. Assuming that the\ntranslation templates are repeated on all of these copies and\nexist for the relevant non-FK joins, the database content\ntranslation techniques we have summarized above (in Section 2.2) could certainly be applied to generate a relevant\npiece of text. However, the result would be quite unnatural,\neven in the best case:\n\"Find the name of an actor who has played in a\nmovie, and the name of another actor who has played\nin the movie, and the id of the first actor is larger\nthan the id of the second actor\"\nGenerating a natural sentence for this query requires that\nwhole parts of the query graph be translated into individual\nphrases, essentially moving away from local template labels,\nthat are associated with single attributes and assigning them\nto larger schema/query parts. How to define such template\nlabels, whether or not there are any general patterns that\nshould be followed, and so on, are open issues that require\ninvestigation. Based on how a human would translate query\nQ3, which is given below, it seems that identifying an effective approach is nontrivial:\n\"Find pairs of actor who have played in the same movie\"\nQuery 4. Similar difficulties arise when the query graph\ncontains cycles. Again, non-local template labels are needed,\nincluding some for non-FK joins, to capture a query naturally. Query Q4 below belongs to this category:\n\nNon-Graph Queries\n\nNon-graph queries are those that cannot be represented\non top of the schema graph or an expanded version of it with\nmultiple copies of some of its parts. Algebraically, these are\nqueries that involve operators other than select-project-join,\nor at least expressing them with just these operators is not\nobvious from their syntax. There are essentially two types\nof such queries: nested and aggregate queries.\nNested queries can also be classified into two categories:\nthose that do have a flat (SPJ) equivalent and those that do\nnot, as exemplified below. Each category presents its own\nchallenges for translation.\nQuery 5. Consider the following nested query, Q5, where\nin is the only nesting connector:\nselect m.title from MOVIES m\nwhere id in (\nselect c.mid from CAST c\nwhere c.aid in (\nselect a.id from ACTOR a\nwhere a.name = 'Brad Pitt'))\nClearly, query Q5 has a flat equivalent described in query\nQ1:\nselect m.title from MOVIES m, CAST c, ACTOR a\nwhere m.id = c.mid and c.aid = a.id\nand a.name = 'Brad Pitt'\nHence, the translation desired would be similar to the\nfollowing:\n\nCIDR Perspectives 2009\n\n\fQ\n<<FROM>>\nCast\n\n<<alias>>\nC\n\n<<SELECT>>\ncount(*)\n\nhowever, that appear simply \"impossible\". These are queries\nwhose semantics are not derivable from the query-graph representation and require higher-order languages, which are a\nvery challenging to use every day.\n\n<<GROUP BY>>\nM.Movies.id\nM.Movies.title\n\n<<WHERE>>\n<<HAVING>>\nM.id = C.mid\n<<alias>>\nM\n<<FROM>>\nMovies\n<<SELECT>>\nM.Movies.id: id\nM.Movies.Title: title\n\nNQ1\n<<FROM>>\nGenre\n\nselect a.id, a.name\nfrom MOVIES m, CAST c, ACTOR a\nwhere m.id = c.mid and c.aid = a.id\ngroup by a.id, a.name\nhaving count(distinct m.year) = 1\n\n<<SELECT>>\ncount(*)\n\n<<WHERE>>\n<<HAVING>>\n1 < NQ1\n\n<<alias>>\nG\n\nQuery 8. In query Q8, the semantics is unclear. Syntactically, one sees a standard aggregate query, but in reality,\nit is the count aggregate that implies all and dominates the\nquery.\n\n<<WHERE>>\nM.id = G.mid\n\n<<HAVING>>\n\nHence, it is not obvious how to produce the correct narrative:\n\nFigure 7: An aggregate query (Q7)\n\n\"Find actors whose movies are all in the same year\"\n\n\"Find movies where Brat Pitt plays\"\nObtaining this from the original form is almost impossible, while it is straightforward to obtain from the flat form of\nthe query. Hence, identifying equivalent query forms is important and receives new life as a problem when motivated\nby translatability principles,\n\nQuery 9. In query Q9, the semantics is unclear as well,\nbut in a rather different way. This time, syntactically, one\ndoes see the all connector as the main challenge, but the\nexpression '= all' will have to be interpreted as 'earliest' in\nthis case, which is very difficult to obtain.\n\nQuery 6. Consider the following nested query, Q6, where\nconnectors other than in take part in the nesting:\n\nselect a.name\nfrom MOVIES m, CAST c, ACTOR a\nwhere m.id = c.mid and c.aid = a.id\nand year <= all (\nselect m1.year\nfrom MOVIES m1, MOVIES m2\nwhere m1.title = m.title and m2.title = m.title\nand m1.id != m2.id\n)\n\nselect a.title from MOVIES a\nwhere not exists (\nselect \u2217 from GENRE G1\nwhere not exists (\nselect \u2217 from GENRE a2\nwhere a2.mid = m.id))\nTranslating the above rather intertwined query is clearly\na complex task, as ideally, one would want something rather\nshort for its translation:\n\"Find movies that have all genres\"\nQuery 7. Aggregate queries present similar challenges,\nsince one cannot rely on the underlying graph. The magnitude of the problem is just shown with the query Q7:\nselect m.id, m.title, count(\u2217) from MOVIES m, CAST c\nwhere m.id = c.mid\ngroup by m.id, m.title\nhaving 1 < (select count(\u2217)\nfrom GENRE g\nwhere g.mid=m.id)\nA graphical representation of Q7 is depicted in Fig. 7.\nObserve that the nested part of the query is represented\ngraphically as an additional query (N Q1). (Again, for simplicity most of the edges are not depicted.) That facilitates\na procedural translation of the query; however, the challenge\nis to create a declarative one:\n\"Find the number of actors in movies of more than\none genre\"\n\n3.3.5\n\nImpossible Queries\n\nEven in the most difficult of the cases mentioned so far,\none could imagine ways to be explored in order to identify the appropriate translation techniques. There are some,\n\nConsequently, it is very difficult to produce the following\ntext:\n\"Find the actors who have played in the earliest versions of movies that have been repeated\"\nFor a system to recognize that a good way to express the\nmeaning of these relatively simple queries is with phrases\nlike the above is nontrivial. Identifying the correct use of\npronouns is one source of difficulties. Another one is related to whether or not the description will be declarative\n(as in the above two examples) or procedural, i.e., whether\nit will just specify what the query answer should satisfy or\nalso the actions that need to be performed for the answer\nto be generated. The former is always desirable, but for\ncomplicated queries, the latter may be the only reasonable\napproach. Identifying the complexity point where this becomes the case, however, is far from understood, and work\nmust be done on this.\n\n4.\n\nRELATED WORK\n\nEarlier interaction of databases and natural language processing has focused mainly on the opposite direction of the\none considered in this paper. Several works are presented\nconcerning NL Querying [5], NL and Schema Design [12],\nNL and Database interfaces [1, 6], and Question Answering\n[10]. Hence, as far as we are aware of, related literature\non NL and databases has focused on totally different issues\n\nCIDR Perspectives 2009\n\n\fsuch as the interpretation of users' phrasal questions to a\ndatabase language, e.g., SQL, or to the automatic database\ndesign, e.g., with the usage of ontologies [11]. Several recent efforts use phrasal patterns or question templates to\nfacilitate the answering procedure [6, 10].\nIn earlier work, we have studied the problem of translating\nsmall databases or query answers under certain constraints\nwith promising results [8, 9]. In that work, the translation\ninvolves databases with content, i.e., the translation is performed at the data level. In this work, we investigate issues\nrelated to the translation of queries too, thus, we mainly\nwork at the schema level. In a previous work, we have discussed the usefulness of translating SQL queries into narratives [4]. Here, we elaborate on that, we examine the space\nof the problem, and we discuss useful directions for reaching\nsuch goal.\n\n5.\n\nCONCLUSIONS\n\nIn this paper, we have looked into the intersection of the\nDatabase and Natural Language Processing areas and have\noutlined several interesting problems that arise when one\nattempts to translate database elements into natural language elements. We have discussed the translation of both\ndatabase contents and queries. Translating database content is not an easy task, mainly because it is not straightforward to choose the appropriate schema constructs and\ndata items for composing a concise and meaningful narrative. Apart from such structural problems, identifying the\nright linguistic constructs, introducing pronouns where appropriate, and synthesizing everything to produce a natural\nend result are equally complex. On the other hand, translating database content to natural language is simpler from\ntranslating queries, as the extent of alternative equivalent\nexpressions of schemas and data is much narrower than that\nof queries.\nAdditionally, we have offered example applications that\nindicate the practical usefulness of the problem, have identified several categories of database elements whose translation into text would be useful, and have briefly described\nsome of the technical challenges that need to be addressed in\nthe future. We hope that researchers will take up this type\nof problems and help to push this interesting area forward.\n\n6.\n\nACKNOWLEDGEMENTS\n\nWe are grateful to Georgia Koutrika for sharing her ideas\nwith us and for commenting on several versions of this paper.\n\n7.\n\nREFERENCES\n\n[1] I. Androutsopoulos, G. D. Ritchie, and P. Thanisch.\nNatural language interfaces to databases-an\nintroduction. CoRR, 9503016, 1995.\n[2] R. Cole, J. Mariani, H. Uszkoreit, G. Varile,\nA. Zaenen, V. Zue, and A. Zampolli. Survey of the\nState of the Art in Human Language Technology.\nCambridge University Press and Giardini, 1997.\n[3] Gartner. Gartner identifies seven grand challenges\nfacing IT. In Gartner Emerging Trends Symposium ITxpo, 2008.\n[4] Y. E. Ioannidis. From databases to natural language:\nThe unusual direction. In NLDB, pages 12\u201316, 2008.\n[5] E. M\u00e9tais, J.-N. Meunier, and G. Levreau. Database\nschema design: A perspective from natural language\ntechniques to validation and view integration. In ER,\npages 190\u2013205, 1993.\n[6] M. Minock. A phrasal approach to natural language\ninterfaces over databases. In NLDB, pages 333\u2013336,\n2005.\n[7] T. Schultz and K. Kirchhoff. Multilingual Speech\nProcessing, chapter 10. Speech-to-Speech Translation.\nElsevier, Academic Press, 2006.\n[8] A. Simitsis and G. Koutrika. Comprehensible answers\nto pr\u00e9cis queries. In CAiSE, pages 142\u2013156, 2006.\n[9] A. Simitsis, G. Koutrika, Y. Alexandrakis, and Y. E.\nIoannidis. Synthesizing structured text from logical\ndatabase subsets. In EDBT, pages 428\u2013439, 2008.\n[10] E. Sneiders. Automated question answering using\nquestion templates that cover the conceptual model of\nthe database. In NLDB, pages 235\u2013239, 2002.\n[11] V. C. Storey. Understanding and representing\nrelationship semantics in database design. In NLDB,\npages 79\u201390, 2000.\n[12] V. C. Storey, R. C. Goldstein, and H. Ullrich. Na\u0131\u0308ve\nsemantics to support automated database design.\nIEEE TKDE, 14(1):1\u201312, 2002.\n\nCIDR Perspectives 2009\n\n\f"}