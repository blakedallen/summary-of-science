{"id": "http://arxiv.org/abs/0904.2557v1", "guidislink": true, "updated": "2009-04-16T18:40:02Z", "updated_parsed": [2009, 4, 16, 18, 40, 2, 3, 106, 0], "published": "2009-04-16T18:40:02Z", "published_parsed": [2009, 4, 16, 18, 40, 2, 3, 106, 0], "title": "An Introduction to Quantum Error Correction and Fault-Tolerant Quantum\n  Computation", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0904.4071%2C0904.1939%2C0904.1793%2C0904.2715%2C0904.0572%2C0904.1757%2C0904.1923%2C0904.2048%2C0904.3399%2C0904.4016%2C0904.0854%2C0904.4483%2C0904.3206%2C0904.0845%2C0904.3092%2C0904.3401%2C0904.3544%2C0904.4456%2C0904.4144%2C0904.1126%2C0904.0226%2C0904.1635%2C0904.4389%2C0904.1045%2C0904.0446%2C0904.1486%2C0904.1148%2C0904.1086%2C0904.2547%2C0904.2557%2C0904.0297%2C0904.3615%2C0904.2041%2C0904.4558%2C0904.1530%2C0904.2781%2C0904.1636%2C0904.2697%2C0904.3115%2C0904.0878%2C0904.3449%2C0904.0077%2C0904.0979%2C0904.0656%2C0904.1583%2C0904.3849%2C0904.2359%2C0904.2183%2C0904.0052%2C0904.2447%2C0904.0628%2C0904.0191%2C0904.3389%2C0904.4721%2C0904.3953%2C0904.2795%2C0904.1995%2C0904.2592%2C0904.3716%2C0904.1857%2C0904.3906%2C0904.0413%2C0904.0187%2C0904.4553%2C0904.2039%2C0904.3072%2C0904.3564%2C0904.4577%2C0904.0228%2C0904.4775%2C0904.1227%2C0904.4913%2C0904.3050%2C0904.2784%2C0904.0094%2C0904.4608%2C0904.3289%2C0904.1618%2C0904.3943%2C0904.4207%2C0904.3894%2C0904.1024%2C0904.3179%2C0904.2906%2C0904.1837%2C0904.1893%2C0904.3241%2C0904.3909%2C0904.2759%2C0904.4622%2C0904.0402%2C0904.2684%2C0904.1128%2C0904.2580%2C0904.3386%2C0904.1374%2C0904.0886%2C0904.3917%2C0904.3406%2C0904.4776%2C0904.3705&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "An Introduction to Quantum Error Correction and Fault-Tolerant Quantum\n  Computation"}, "summary": "Quantum states are very delicate, so it is likely some sort of quantum error\ncorrection will be necessary to build reliable quantum computers. The theory of\nquantum error-correcting codes has some close ties to and some striking\ndifferences from the theory of classical error-correcting codes. Many quantum\ncodes can be described in terms of the stabilizer of the codewords. The\nstabilizer is a finite Abelian group, and allows a straightforward\ncharacterization of the error-correcting properties of the code. The stabilizer\nformalism for quantum codes also illustrates the relationships to classical\ncoding theory, particularly classical codes over GF(4), the finite field with\nfour elements. To build a quantum computer which behaves correctly in the\npresence of errors, we also need a theory of fault-tolerant quantum\ncomputation, instructing us how to perform quantum gates on qubits which are\nencoded in a quantum error-correcting code. The threshold theorem states that\nit is possible to create a quantum computer to perform an arbitrary quantum\ncomputation provided the error rate per physical gate or time step is below\nsome constant threshold value.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0904.4071%2C0904.1939%2C0904.1793%2C0904.2715%2C0904.0572%2C0904.1757%2C0904.1923%2C0904.2048%2C0904.3399%2C0904.4016%2C0904.0854%2C0904.4483%2C0904.3206%2C0904.0845%2C0904.3092%2C0904.3401%2C0904.3544%2C0904.4456%2C0904.4144%2C0904.1126%2C0904.0226%2C0904.1635%2C0904.4389%2C0904.1045%2C0904.0446%2C0904.1486%2C0904.1148%2C0904.1086%2C0904.2547%2C0904.2557%2C0904.0297%2C0904.3615%2C0904.2041%2C0904.4558%2C0904.1530%2C0904.2781%2C0904.1636%2C0904.2697%2C0904.3115%2C0904.0878%2C0904.3449%2C0904.0077%2C0904.0979%2C0904.0656%2C0904.1583%2C0904.3849%2C0904.2359%2C0904.2183%2C0904.0052%2C0904.2447%2C0904.0628%2C0904.0191%2C0904.3389%2C0904.4721%2C0904.3953%2C0904.2795%2C0904.1995%2C0904.2592%2C0904.3716%2C0904.1857%2C0904.3906%2C0904.0413%2C0904.0187%2C0904.4553%2C0904.2039%2C0904.3072%2C0904.3564%2C0904.4577%2C0904.0228%2C0904.4775%2C0904.1227%2C0904.4913%2C0904.3050%2C0904.2784%2C0904.0094%2C0904.4608%2C0904.3289%2C0904.1618%2C0904.3943%2C0904.4207%2C0904.3894%2C0904.1024%2C0904.3179%2C0904.2906%2C0904.1837%2C0904.1893%2C0904.3241%2C0904.3909%2C0904.2759%2C0904.4622%2C0904.0402%2C0904.2684%2C0904.1128%2C0904.2580%2C0904.3386%2C0904.1374%2C0904.0886%2C0904.3917%2C0904.3406%2C0904.4776%2C0904.3705&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Quantum states are very delicate, so it is likely some sort of quantum error\ncorrection will be necessary to build reliable quantum computers. The theory of\nquantum error-correcting codes has some close ties to and some striking\ndifferences from the theory of classical error-correcting codes. Many quantum\ncodes can be described in terms of the stabilizer of the codewords. The\nstabilizer is a finite Abelian group, and allows a straightforward\ncharacterization of the error-correcting properties of the code. The stabilizer\nformalism for quantum codes also illustrates the relationships to classical\ncoding theory, particularly classical codes over GF(4), the finite field with\nfour elements. To build a quantum computer which behaves correctly in the\npresence of errors, we also need a theory of fault-tolerant quantum\ncomputation, instructing us how to perform quantum gates on qubits which are\nencoded in a quantum error-correcting code. The threshold theorem states that\nit is possible to create a quantum computer to perform an arbitrary quantum\ncomputation provided the error rate per physical gate or time step is below\nsome constant threshold value."}, "authors": ["Daniel Gottesman"], "author_detail": {"name": "Daniel Gottesman"}, "author": "Daniel Gottesman", "arxiv_comment": "46 pages, with large margins. Includes quant-ph/0004072 plus 30 pages\n  of new material, mostly on fault-tolerance", "links": [{"href": "http://arxiv.org/abs/0904.2557v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0904.2557v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0904.2557v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0904.2557v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:0904.2557v1 [quant-ph] 16 Apr 2009\n\nProceedings of Symposia in Applied Mathematics\n\nAn Introduction to Quantum Error Correction and\nFault-Tolerant Quantum Computation\nDaniel Gottesman\nAbstract. Quantum states are very delicate, so it is likely some sort of quantum error correction will be necessary to build reliable quantum computers.\nThe theory of quantum error-correcting codes has some close ties to and some\nstriking differences from the theory of classical error-correcting codes. Many\nquantum codes can be described in terms of the stabilizer of the codewords.\nThe stabilizer is a finite Abelian group, and allows a straightforward characterization of the error-correcting properties of the code. The stabilizer formalism\nfor quantum codes also illustrates the relationships to classical coding theory,\nparticularly classical codes over GF(4), the finite field with four elements. To\nbuild a quantum computer which behaves correctly in the presence of errors, we\nalso need a theory of fault-tolerant quantum computation, instructing us how\nto perform quantum gates on qubits which are encoded in a quantum errorcorrecting code. The threshold theorem states that it is possible to create a\nquantum computer to perform an arbitrary quantum computation provided\nthe error rate per physical gate or time step is below some constant threshold\nvalue.\n\n1. Background: the need for error correction\nQuantum computers have a great deal of potential, but to realize that potential,\nthey need some sort of protection from noise.\nClassical computers don't use error correction. One reason for this is that\nclassical computers use a large number of electrons, so when one goes wrong, it is\nnot too serious. A single qubit in a quantum computer will probably be just one,\nor a small number, of particles, which already creates a need for some sort of error\ncorrection.\nAnother reason is that classical computers are digital: after each step, they\ncorrect themselves to the closer of 0 or 1. Quantum computers have a continuum\nof states, so it would seem, at first glance, that they cannot do this. For instance,\na likely source of error is over-rotation: a state \u03b1|0i + \u03b2|1i might be supposed to\nbecome \u03b1|0i + \u03b2ei\u03c6 |1i, but instead becomes \u03b1|0i + \u03b2ei(\u03c6+\u03b4) |1i. The actual state\nis very close to the correct state, but it is still wrong. If we don't do something\n2000 Mathematics Subject Classification. Primary 81P68, 94B60, 94C12.\nSections 1, 2, and part of section 3 of this chapter were originally published as [24].\nc 0000 (copyright holder)\n\n1\n\n\f2\n\nDANIEL GOTTESMAN\n\nabout this, the small errors will build up over the course of the computation, and\neventually will become a big error.\nFurthermore, quantum states are intrinsically delicate: looking at one collapses\nit. \u03b1|0i + \u03b2|1i becomes |0i with probability |\u03b1|2 and |1i with probability |\u03b2|2 . The\nenvironment is constantly trying to look at the state, a process called decoherence.\nOne goal of quantum error correction will be to prevent the environment from\nlooking at the data.\nThere is a well-developed theory of classical error-correcting codes, but it\ndoesn't apply here, at least not directly. For one thing, we need to keep the phase\ncorrect as well as correcting bit flips. There is another problem, too. Consider the\nsimplest classical code, the repetition code:\n(1)\n(2)\n\n0 \u2192 000\n\n1 \u2192 111\n\nIt will correct a state such as 010 to the majority value (becoming 000 in this case).1\nWe might try a quantum repetition code:\n(3)\n\n|\u03c8i \u2192 |\u03c8i \u2297 |\u03c8i \u2297 |\u03c8i\n\nHowever, no such code exists because of the No-Cloning theorem [17, 54]:\nTheorem 1 (No-Cloning). There is no quantum operation that takes a state\n|\u03c8i to |\u03c8i \u2297 |\u03c8i for all states |\u03c8i.\nProof. This fact is a simple consequence of the linearity of quantum mechanics. Suppose we had such an operation and |\u03c8i and |\u03c6i are distinct. Then, by the\ndefinition of the operation,\n(4)\n(5)\n(6)\n\n|\u03c8i \u2192 |\u03c8i|\u03c8i\n|\u03c6i \u2192 |\u03c6i|\u03c6i\n\n|\u03c8i + |\u03c6i \u2192 (|\u03c8i + |\u03c6i) (|\u03c8i + |\u03c6i) .\n\n(Here, and frequently below, I omit normalization, which is generally unimportant.)\nBut by linearity,\n(7)\n\n|\u03c8i + |\u03c6i \u2192 |\u03c8i|\u03c8i + |\u03c6i|\u03c6i.\n\nThis differs from (6) by the crossterm\n(8)\n\n|\u03c8i|\u03c6i + |\u03c6i|\u03c8i.\n\u0003\n2. Basic properties and structure of quantum error correction\n\n2.1. The nine-qubit code. To solve these problems, we will try a variant of\nthe repetition code [43].\n(9)\n(10)\n\n|0i \u2192 |0i = (|000i + |111i) (|000i + |111i) (|000i + |111i)\n\n|1i \u2192 |1i = (|000i \u2212 |111i) (|000i \u2212 |111i) (|000i \u2212 |111i)\n\n1Actually, a classical digital computer is using a repetition code \u2013 each bit is encoded in\nmany electrons (the repetition), and after each time step, it is returned to the value held by the\nmajority of the electrons (the error correction).\n\n\fQUANTUM ERROR CORRECTION\n\n3\n\n\u0012\n\n\u0013\n1 0\nI|ai = |ai\n\u00120 1 \u0013\n0 1\nBit Flip\nX=\nX|ai = |a \u2295 1i\n\u0012 1 0 \u0013\n1 0\nPhase Flip\nZ=\nZ|ai = (\u22121)a |ai\n0\n\u22121\n\u0012\n\u0013\n0 \u2212i\nBit & Phase Y =\n= iXZ Y |ai = i(\u22121)a |a \u2295 1i\ni 0\nTable 1. The Pauli matrices\nIdentity\n\nI=\n\nNote that this does not violate the No-Cloning theorem, since an arbitrary\ncodeword will be a linear superposition of these two states\n(11)\n\n\u22973\n\n6 [\u03b1(|000i + |111i) + \u03b2(|000i \u2212 |111i)]\n\u03b1|0i + \u03b2|1i =\n\n.\n\nThe superposition is linear in \u03b1 and \u03b2. The complete set of codewords for this (or\nany other) quantum code form a linear subspace of the Hilbert space, the coding\nspace.\nThe inner layer of this code corrects bit flip errors: We take the majority within\neach set of three, so\n(12)\n\n|010i \u00b1 |101i \u2192 |000i \u00b1 |111i.\n\nThe outer layer corrects phase flip errors: We take the majority of the three signs,\nso\n(13)\n\n(|*i + |*i)(|*i \u2212 |*i)(|*i + |*i) \u2192 (|*i + |*i)(|*i + |*i)(|*i + |*i).\n\nSince these two error correction steps are independent, the code also works if there\nis both a bit flip error and a phase flip error.\nNote that in both cases, we must be careful to measure just what we want to\nknow and no more, or we would collapse the superposition used in the code. I'll\ndiscuss this in more detail in section 2.3.\nThe bit flip, phase flip, and combined bit and phase flip errors are important, so\nlet's take a short digression to discuss them. We'll also throw in the identity matrix,\nwhich is what we get if no error occurs. The definitions of these four operators are\ngiven in table 1. The factor of i in the definition of Y has little practical significance\n- overall phases in quantum mechanics are physically meaningless - but it makes\nsome manipulations easier later. It also makes some manipulations harder, so either\nis a potentially reasonable convention.\nThe group generated by tensor products of these 4 operators is called the Pauli\ngroup. X, Y , and Z anticommute: XZ = \u2212ZX (also written {X, Z} = 0). Similarly, {X, Y } = 0 and {Y, Z} = 0. Thus, the n-qubit Pauli group Pn consists of\nthe 4n tensor products of I, X, Y , and Z, and an overall phase of \u00b11 or \u00b1i, for\na total of 4n+1 elements. The phase of the operators used is generally not very\nimportant, but we can't discard it completely. For one thing, the fact that this is\nnot an Abelian group is quite important, and we would lose that if we dropped the\nphase!\nPn is useful because of its nice algebraic properties. Any pair of elements of\nPn either commute or anticommute. Also, the square of any element of Pn is \u00b11.\nWe shall only need to work with the elements with square +1, which are tensor\n\n\f4\n\nDANIEL GOTTESMAN\n\nproducts of I, X, Y , and Z with an overall sign \u00b11; the phase i is only necessary\nto make Pn a group. Define the weight wt(Q) of an operator Q \u2208 Pn to be the\nnumber of tensor factors which are not I. Thus, X \u2297 Y \u2297 I has weight 2.\nAnother reason the Pauli matrices are important is that they span the space\nof 2 \u00d7 2 matrices, and the n-qubit Pauli group spans the space of 2n \u00d7 2n matrices.\nFor instance, if we have a general phase error\n\u0012 \u2212i\u03b8/2\n\u0013\n\u0012\n\u0013\n1 0\ne\n0\ni\u03b8/2\n(14)\nR\u03b8/2 =\n=e\n0 ei\u03b8\n0\nei\u03b8/2\n(again, the overall phase does not matter), we can write it as\n\u03b8\n\u03b8\nI \u2212 i sin Z.\n2\n2\nIt turns out that our earlier error correction procedure will also correct this\nerror, without any additional effort. For instance, the earlier procedure might use\nsome extra qubits (ancilla qubits) that are initialized to |0i and record what type\nof error occurred. Then we look at the ancilla and invert the error it tells us:\n\u0001\n\u0001\n(16)\nZ \u03b1|0i + \u03b2|1i \u2297 |0ianc \u2192 Z \u03b1|0i + \u03b2|1i \u2297 |Zianc\n\u0001\n(17)\n\u2192 \u03b1|0i + \u03b2|1i \u2297 |Zianc\n\u0001\n\u0001\nI \u03b1|0i + \u03b2|1i \u2297 |0ianc \u2192 I \u03b1|0i + \u03b2|1i \u2297 |no errorianc\n(18)\n\u0001\n(19)\n\u2192 \u03b1|0i + \u03b2|1i \u2297 |no errorianc\n\n(15)\n\nR\u03b8/2 = cos\n\nWhen the actual error is R\u03b8/2 , recording the error in the ancilla gives us a\nsuperposition:\n\u0001\n\u0001\n\u03b8\n\u03b8\n(20)\ncos I \u03b1|0i + \u03b2|1i \u2297 |no errorianc \u2212 i sin Z \u03b1|0i + \u03b2|1i \u2297 |Zianc\n2\n2\nThen we measure the ancilla, which with probability sin2 \u03b8/2 gives us\n\u0001\n(21)\nZ \u03b1|0i + \u03b2|1i \u2297 |Zianc ,\nand with probability cos2 \u03b8/2 gives us\n(22)\n\n\u0001\nI \u03b1|0i + \u03b2|1i \u2297 |no errorianc .\n\nIn each case, inverting the error indicated in the ancilla restores the original state.\nIt is easy to see this argument works for any linear combination of errors [43,\n46]:\nTheorem 2. If a quantum code corrects errors A and B, it also corrects any\nlinear combination of A and B. In particular, if it corrects all weight t Pauli errors,\nthen the code corrects all t-qubit errors.\nSo far, we have only considered individual unitary errors that occur on the\ncode. But we can easily add in all possible quantum errors. The most general\nquantum operation, including decoherence, interacts the quantum state with some\nextra qubits via a unitary operation, then discards some qubits. This process can\nturn pure quantum states into mixed quantum states, which are normally described\nusing density matrices. We can write the most general operation as a transformation\non density matrices\nX\n(23)\n\u03c1\u2192\nEi \u03c1Ei\u2020 ,\ni\n\n\fQUANTUM ERROR CORRECTION\n\n5\n\nP \u2020\nwhere the Ei s are normalized so\nEi Ei = I. The density matrix \u03c1 can be considered to represent an ensemble of pure quantum states |\u03c8i, each of which, in\nthis case, should be in the coding space of the code. Then this operation simply\nperforms the following operation on each |\u03c8i:\n\n(24)\n\n|\u03c8i \u2192 Ei |\u03c8i with probability |Ei |\u03c8i|2 .\n\nIf we can correct each of the individual errors Ei , then we can correct this general\nerror as well. For instance, for quantum operations that only affect a single qubit\nof the code, Ei will necessarily be in the linear span of I, X, Y , and Z, so we can\ncorrect it. Thus, in the statement of theorem 2, \"all t-qubit errors\" really does\napply to all t-qubit errors, not just unitary ones.\nWe can go even further. It is not unreasonable to expect that every qubit in\nour nine-qubit code will be undergoing some small error. For instance, qubit i\nexperiences the error I + \u01ebEi , where Ei is some single-qubit error. Then the overall\nerror is\nO\n\u0001\n(25)\n(I + \u01ebEi ) = I + \u01eb E1 \u2297 I \u22978 + I \u2297 E2 \u2297 I \u22977 + . . . + O(\u01eb2 )\nThat is, to order \u01eb, the actual error is the sum of single-qubit errors, which we\nknow the nine-qubit code can correct. That means that after the error correction\nprocedure, the state will be correct to O(\u01eb2 ) (when the two-qubit error terms begin\nto become important). While the code cannot completely correct this error, it still\nproduces a significant improvement over not doing error correction when \u01eb is small.\nA code correcting more errors would do even better.\n\n2.2. General properties of quantum error-correcting codes. Let us\ntry to understand what properties are essential to the success of the nine-qubit\ncode, and derive conditions for a subspace to form a quantum error-correcting code\n(QECC).\nOne useful feature was linearity, which will be true of any quantum code. We\nonly need to correct a basis of errors (I, X, Y , and Z in the one-qubit case), and\nall other errors will follow, as per theorem 2.\nIn any code, we must never confuse |0i with |1i, even in the presence of errors.\nThat is, E|0i is orthogonal to F |1i:\n(26)\n\nh0|E \u2020 F |1i = 0.\n\nIt is sufficient to distinguish error E from error F when they act on |0i and |1i.\nThen a measurement will tell us exactly what the error is and we can correct it:\n(27)\n\nh0|E \u2020 F |0i = h1|E \u2020 F |1i = 0\n\nfor E 6= F .\nBut (27) is not necessary: in the nine-qubit code, we cannot distinguish between\nZ1 and Z2 , but that is OK, since we can correct either one with a single operation.\nTo understand the necessary condition, it is helpful to look at the operators F1 =\n(Z1 + Z2 )/2 and F2 = (Z1 \u2212 Z2 )/2 instead of Z1 and Z2 . F1 and F2 span the same\nspace as Z1 and Z2 , so Shor's code certainly corrects them; let us try to understand\nhow. When we use the F s as the basis errors, now equation (27) is satisfied. That\nmeans we can make a measurement and learn what the error is. We also have to\ninvert it, and this is a potential problem, since F1 and F2 are not unitary. However,\nF1 acts the same way as Z1 on the coding space, so Z1\u2020 suffices to invert F1 on the\nstates of interest. F2 acts the same way as the 0 operator on the coding space. We\n\n\f6\n\nDANIEL GOTTESMAN\n\ncan't invert this, but we don't need to - since F2 annihilates codewords, it can\nnever contribute a component to the actual state of the system.\nThe requirement to invert the errors produces a third condition:\n(28)\n\nh0|E \u2020 E|0i = h1|E \u2020 E|1i.\n\nEither this value is nonzero, as for F1 , in which case some unitary operator will act\nthe same way as E on the coding space, or it will be zero, as for F2 , in which case\nE annihilates codewords and never arises.\nThese arguments show that if there is some basis for the space of errors for\nwhich equations (26), (27), and (28) hold, then the states |0i and |1i span a quantum\nerror-correcting code. Massaging these three equations together and generalizing\nto multiple encoded qubits, we get the following theorem [8, 31]:\nTheorem 3. Suppose E is a linear space of errors acting on the Hilbert space\nH. Then a subspace C of H forms a quantum error-correcting code correcting the\nerrors E iff\n(29)\n\nh\u03c8|E \u2020 E|\u03c8i = C(E)\n\nfor all E \u2208 E. The function C(E) does not depend on the state |\u03c8i.\nProof. Suppose {Ea } is a basis for E and {|\u03c8i i} is a basis for C. By setting\nE and |\u03c8i equal to the basis elements and to the sum and difference of two basis\nelements (with or without a phase factor i), we can see that (29) is equivalent to\n(30)\n\nh\u03c8i |Ea\u2020 Eb |\u03c8j i = Cab \u03b4ij ,\n\nwhere Cab is a Hermitian matrix independent of i and j.\nSuppose equation (30) holds. We can diagonalize Cab . This involves choosing\na new basis {Fa } for E, and the result is equations (26), (27), and (28). The\narguments before the theorem show that we can measure the error, determine it\nuniquely (in the new basis), and invert it (on the coding space). Thus, we have a\nquantum error-correcting code.\nNow suppose we have a quantum error-correcting code, and let |\u03c8i and |\u03c6i be\ntwo distinct codewords. Then we must have\n(31)\n\nh\u03c8|E \u2020 E|\u03c8i = h\u03c6|E \u2020 E|\u03c6i\n\nfor all E. That is, (29) must hold. If not, E changes the relative size of |\u03c8i and\n|\u03c6i. Both |\u03c8i + |\u03c6i and |\u03c8i + c|\u03c6i are valid codewords, and\n(32)\n\nE(|\u03c8i + |\u03c6i) = N (|\u03c8i + c|\u03c6i),\n\nwhere N is a normalization factor and\n(33)\n\nc = h\u03c8|E \u2020 E|\u03c8i/h\u03c6|E \u2020 E|\u03c6i.\n\nThe error E will actually change the encoded state, which is a failure of the code,\nunless c = 1.\n\u0003\nThere is a slight subtlety to the phrasing of equation (29). We require E to be\na linear space of errors, which means that it must be closed under sums of errors\nwhich may act on different qubits. In contrast, for a code that corrects t errors,\nin (30), it is safe to consider only Ea and Eb acting on just t qubits. We can restrict\n\n\fQUANTUM ERROR CORRECTION\n\n7\n\neven further, and only use Pauli operators as Ea and Eb , since they will span the\nspace of t-qubit errors. This leads us to a third variation of the condition:\n(34)\n\nh\u03c8|E|\u03c8i = C \u2032 (E),\n\nwhere E is now any operator acting on 2t qubits (that is, it replaces Ea\u2020 Eb in (30)).\nThis can be easily interpreted as saying that no measurement on 2t qubits can learn\ninformation about the codeword. Alternatively, it says we can detect up to 2t errors\non the code without necessarily being able to say what those errors are. That is,\nwe can distinguish those errors from the identity.\nIf the matrix Cab in (30) has maximum rank, the code is called nondegenerate.\nIf not, as for the nine-qubit code, the code is degenerate. In a degenerate code,\ndifferent errors look the same when acting on the coding subspace.\nFor a nondegenerate code, we can set a simple bound on the parameters of\nthe code simply by counting states. Each error E acting on each basis codeword\n|\u03c8i i produces a linearly independent state. All of these states must fit in the full\nHilbert space of n qubits, which has dimension 2n . If the code encodes k qubits,\nand corrects errors on up to t qubits, then\n\uf8f6\n\uf8eb\n\u0012 \u0013\nt\nX\nn\n\uf8f8 2k \u2264 2n .\n\uf8ed\n(35)\n3j\nj\nj=0\n\nThe quantity in parentheses is the number of errors of weight t or less: that is, the\nnumber of tensor products of I, X, Y , and Z that are the identity in all but t or\nfewer places. This inequality is called the quantum Hamming bound. While the\nquantum Hamming bound only applies to nondegenerate codes, we do not know of\nany codes that beat it.\nFor t = 1, k = 1, the quantum Hamming bound tells us n \u2265 5. In fact, there\nis a code with n = 5, which you will see later. A code that corrects t errors is said\nto have distance 2t + 1, because it takes 2t + 1 single-qubit changes to get from\none codeword to another. We can also define distance as the minimum weight of\nan operator E that violates equation (34) (a definition which also allows codes of\neven distance). A quantum code using n qubits to encode k qubits with distance d\nis written as an [[n, k, d]] code (the double brackets distinguish it from a classical\ncode). Thus, the nine-qubit code is a [[9, 1, 3]] code, and the five-qubit code is a\n[[5, 1, 3]] code.\nWe can also set a lower bound telling us when codes exist. I will not prove this\nhere, but an [[n, k, d]] code exists when\n\uf8f6\n\uf8eb\nd\u22121\nX \u0012n\u0013\n\uf8f8 2k \u2264 2n\n\uf8ed\n(36)\n3j\nj\nj=0\n(known as the quantum Gilbert-Varshamov bound [12]). This differs from the\nquantum Hamming bound in that the sum goes up to d \u2212 1 (which is equal to 2t)\nrather than stopping at t.\n\nTheorem 4. A quantum [[n, k, d]] code exists when (36) holds. Any nondegenerate [[n, k, d]] code must satisfy (35). For large n, R = k/n and p = d/2n fixed,\nthe best nondegenerate quantum codes satisfy\n(37)\n\n1 \u2212 2p log2 3 \u2212 H(2p) \u2264 R \u2264 1 \u2212 p log2 3 \u2212 H(p),\n\n\f8\n\nDANIEL GOTTESMAN\n\nwhere H(x) = \u2212x log2 x \u2212 (1 \u2212 x) log2 (1 \u2212 x).\nOne further bound, known as the Knill-Laflamme bound [31] or the quantum Singleton bound, applies even to degenerate quantum codes. For an [[n, k, d]]\nquantum code,\n(38)\n\nn \u2212 k \u2265 2d \u2212 2.\n\nThis shows that the [[5, 1, 3]] code really is optimal - a [[4, 1, 3]] code would violate\nthis bound.\nI will not prove the general case of this bound, but the case of k = 1 can be\neasily understood as a consequence of the No-Cloning theorem. Suppose r qubits\nof the code are missing. We can substitute |0i states for the missing qubits, but\nthere are r errors on the resulting codeword. The errors are of unknown type, but\nall the possibilities are on the same set of r qubits. Thus, all products Ea\u2020 Eb in\ncondition (30) have weight r or less, so this sort of error (an \"erasure\" error [25])\ncan be corrected by a code of distance r + 1. Now suppose we had an [[n, 1, d]] code\nwith n \u2264 2d \u2212 2. Then we could split the qubits in the code into two groups of\nsize at most d \u2212 1. Each group would have been subject to at most d \u2212 1 erasure\nerrors, and could therefore be corrected without access to the other group. This\nwould produce two copies of the encoded state, which we know is impossible.\n2.3. Stabilizer codes. Now let us return to the nine-qubit code, and examine\nprecisely what we need to do to correct errors.\nFirst, we must determine if the first three qubits are all the same, and if not,\nwhich is different. We can do this by measuring the parity of the first two qubits\nand the parity of the second and third qubits. That is, we measure\n(39)\n\nZ \u2297 Z \u2297 I and I \u2297 Z \u2297 Z.\n\nThe first tells us if an X error has occurred on qubits one or two, and the second\ntells us if an X error has occurred on qubits two or three. Note that the error\ndetected in both cases anticommutes with the error measured. Combining the two\npieces of information tells us precisely where the error is.\nWe do the same thing for the other two sets of three. That gives us four more\noperators to measure. Note that measuring Z \u2297 Z gives us just the information we\nwant and no more. This is crucial so that we do not collapse the superpositions\nused in the code. We can do this by bringing in an ancilla qubit. We start it in the\nstate |0i + |1i and perform controlled-Z operations to the first and second qubits\nof the code:\nX\nX\n\u0001\n(|0i + |1i)\ncabc |abci \u2192\n(40)\ncabc |0i|abci + (\u22121)a\u2295b |1i|abci\nabc\n\n(41)\n\nabc\n\n=\n\nX\nabc\n\n\u0010\n\u0011\ncabc |0i + (\u22121)parity(a,b) |1i |abci.\n\nAt this point, measuring the ancilla in the basis |0i \u00b1 |1i will tell us the eigenvalue\nof Z \u2297 Z \u2297 I, but nothing else about the data.\nSecond, we must check if the three signs are the same or different. We do this\nby measuring\n(42)\n\nX \u2297X \u2297X \u2297X \u2297X \u2297X \u2297I \u2297I \u2297I\n\n\fQUANTUM ERROR CORRECTION\n\n9\n\nZ Z I I I I I I I\nI Z Z I I I I I I\nI I I Z Z I I I I\nI I I I Z Z I I I\nI I I I I I Z Z I\nI I I I I I I Z Z\nX X X X X X I I I\nI I I X X X X X X\nTable 2. The stabilizer for the nine-qubit code. Each column\nrepresents a different qubit.\n\nand\n(43)\n\nI \u2297 I \u2297 I \u2297 X \u2297 X \u2297 X \u2297 X \u2297 X \u2297 X.\n\nThis gives us a total of 8 operators to measure. These two measurements detect\nZ errors on the first six and last six qubits, correspondingly. Again note that the\nerror detected anticommutes with the operator measured.\nThis is no coincidence: in each case, we are measuring an operator M which\nshould have eigenvalue +1 for any codeword:\n(44)\n\nM |\u03c8i = |\u03c8i.\n\nIf an error E which anticommutes with M has occurred, then the true state is E|\u03c8i,\nand\n(45)\n\nM (E|\u03c8i) = \u2212EM |\u03c8i = \u2212E|\u03c8i.\n\nThat is, the new state has eigenvalue \u22121 instead of +1. We use this fact to correct\nerrors: each single-qubit error E anticommutes with a particular set of operators\n{M }; which set, exactly, tells us what E is.\nIn the case of the nine-qubit code, we cannot tell exactly what E is, but it does\nnot matter. For instance, we cannot distinguish Z1 and Z2 because\n(46)\n\nZ1 Z2 |\u03c8i = |\u03c8i \u21d0\u21d2 Z1 |\u03c8i = Z2 |\u03c8i.\n\nThis is an example of the fact that the nine-qubit code is degenerate.\nTable 2 summarizes the operators we measured. These 8 operators generate an\nAbelian group called the stabilizer of the nine-qubit code. The stabilizer contains\nall operators M in the Pauli group for which M |\u03c8i = |\u03c8i for all |\u03c8i in the code.\nConversely, given an Abelian subgroup S of the Pauli group Pn (which, if you\nrecall, consists of tensor products of I, X, Y , and Z with an overall phase of \u00b11, \u00b1i),\nwe can define a quantum code T (S) as the set of states |\u03c8i for which M |\u03c8i = |\u03c8i\nfor all M \u2208 S. S must be Abelian and cannot contain \u22121, or the code is trivial: If\nM, N \u2208 S,\n(47)\n\n(48)\nso\n(49)\n\nM N |\u03c8i = M |\u03c8i = |\u03c8i\nN M |\u03c8i = N |\u03c8i = |\u03c8i\n\n[M, N ]|\u03c8i = M N |\u03c8i \u2212 N M |\u03c8i = 0.\n\nSince elements of the Pauli group either commute or anticommute, [M, N ] = 0.\nClearly, if M = \u22121 \u2208 S, there is no nontrivial |\u03c8i for which M |\u03c8i = |\u03c8i.\n\n\f10\n\nDANIEL GOTTESMAN\n\nIf these conditions are satisfied, there will be a nontrivial subspace consisting of\nstates fixed by all elements of the stabilizer. We can tell how many errors the code\ncorrects by looking at operators that commute with the stabilizer. We can correct\nerrors E and F if either E \u2020 F \u2208 S (so E and F act the same on codewords), or if\n\u2203M \u2208 S s.t. {M, E \u2020 F } = 0, in which case measuring the operator M distinguishes\nbetween E and F . If the first condition is ever true, the stabilizer code is degenerate;\notherwise it is nondegenerate.\nWe can codify this by looking at the normalizer N (S) of S in the Pauli group\n(which is in this case equal to the centralizer, composed of Pauli operators which\ncommute with S). The distance d of the code is the minimum weight of any operator\nin N (S) \\ S [12, 20].\nTheorem 5. Let S be an Abelian subgroup of order 2a of the n-qubit Pauli\ngroup, and suppose \u22121 6\u2208 S. Let d be the minimum weight of an operator in\nN (S) \\ S. Then the space of states T (S) stabilized by all elements of S is an\n[[n, n \u2212 a, d]] quantum code.\nTo correct errors of weight (d\u22121)/2 or below, we simply measure the generators\nof S. This will give us a list of eigenvalues, the error syndrome, which tells us\nwhether the error E commutes or anticommutes with each of the generators. The\nerror syndromes of E and F are equal iff the error syndrome of E \u2020 F is trivial. For\na nondegenerate code, the error syndrome uniquely determines the error E (up to\na trivial overall phase) - the generator that anticommutes with E \u2020 F distinguishes\nE from F . For a degenerate code, the error syndrome is not unique, but error\nsyndromes are only repeated when E \u2020 F \u2208 S, implying E and F act the same way\non the codewords.\nIf the stabilizer has a generators, then the code encodes n \u2212 a qubits. Each\ngenerator divides the allowed Hilbert space into +1 and \u22121 eigenspaces of equal\nsizes. To prove the statement, note that we can find an element G of the Pauli group\nthat has any given error syndrome (though G may have weight greater than (d \u2212\n1)/2, or even greater than d). Each G maps T (S) into an orthogonal but isomorphic\nsubspace, and there are 2a possible error syndromes, so T (S) has dimension at most\n2n /2a . In addition, the Pauli group spans U (2n ), so its orbit acting on any single\nstate contains a basis for H. Every Pauli operator has some error syndrome, so\nT (S) has dimension exactly 2n\u2212a .\n3. More quantum error-correcting codes and their structure\n3.1. Some other important codes. Stabilizers make it easy to describe\nnew codes. For instance, we can start from classical coding theory, which describes\na linear code by a generator matrix or its dual, the parity check matrix. Each\nrow of the generator matrix is a codeword, and the other codewords are all linear\ncombinations of the rows of the generator matrix. The rows of the parity check\nmatrix specify parity checks all the classical codewords must satisfy. (In quantum\ncodes, the stabilizer is closely analogous to the classical parity check matrix.) One\nwell-known code is the seven-bit Hamming code correcting one error, with parity\ncheck matrix\n\uf8eb\n\uf8f6\n1 1 1 1 0 0 0\n\uf8ed 1 1 0 0 1 1 0 \uf8f8.\n(50)\n1 0 1 0 1 0 1\n\n\fQUANTUM ERROR CORRECTION\n\nZ Z Z\nZ Z I\nZ I Z\nX X X\nX X I\nX I X\nTable 3. Stabilizer\n\n11\n\nZ I I I\nI Z Z I\nI Z I Z\nX I I I\nI X X I\nI X I X\nfor the seven-qubit code.\n\nIf we replace each 1 in this matrix by the operator Z, and 0 by I, we are really\nchanging nothing, just specifying three operators that implement the parity check\nmeasurements. The statement that the classical Hamming code corrects one error\nis the statement that each bit flip error of weight one or two anticommutes with\none of these three operators.\nNow suppose we replace each 1 by X instead of Z. We again get three operators,\nand they will anticommute with any weight one or two Z error. Thus, if we make a\nstabilizer out of the three Z operators and the three X operators, as in table 3, we\nget a code that can correct any single qubit error [46]. X errors are picked up by\nthe first three generators, Z errors by the last three, and Y errors are distinguished\nby showing up in both halves. Of course, there is one thing to check: the stabilizer\nmust be Abelian; but that is easily verified. The stabilizer has 6 generators on 7\nqubits, so it encodes 1 qubit - it is a [[7, 1, 3]] code.\nIn this example, we used the same classical code for both the X and Z generators, but there was no reason we had to do so. We could have used any two classical\ncodes C1 and C2 [14, 47]. The only requirement is that the X and Z generators\ncommute. This corresponds to the statement that C2\u22a5 \u2286 C1 (C2\u22a5 is the dual code to\nC2 , consisting of those words which are orthogonal to the codewords of C2 ). If C1 is\nan [n, k1 , d1 ] code, and C2 is an [n, k2 , d2 ] code (recall single brackets means a classical code), then the corresponding quantum code is an [[n, k1 + k2 \u2212 n, min(d1 , d2 )]]\ncode.2 This construction is known as the CSS construction after its inventors\nCalderbank, Shor, and Steane.\nThe codewords of a CSS code have a particularly nice form. They all must\nsatisfy the same parity checks as the classical code C1 , so all codewords will be\nsuperpositions of words of C1 . The parity check matrix of C2 is the generator\nmatrix of C2\u22a5 , so the X generators of the stabilizer add a word of C2\u22a5 to the state.\nThus, the codewords of a CSS code are of the form\nX\n(51)\n|u + wi,\nw\u2208C2\u22a5\n\nwhere u \u2208 C1 (C2\u22a5 \u2286 C1 , so u + w \u2208 C1 ). If we perform a Hadamard transform\n(52)\n(53)\n\n|0i \u2190\u2192 |0i + |1i\n\n|1i \u2190\u2192 |0i \u2212 |1i\n\n2In fact, the true distance of the code could be larger than expected because of the possibility\nof degeneracy, which would not have been a factor for the classical codes.\n\n\f12\n\nDANIEL GOTTESMAN\n\nX Z Z X I\nI X Z Z X\nX I X Z Z\nZ X I X Z\nTable 4. The stabilizer for the five-qubit code.\n\non each qubit of the code, we switch the Z basis with the X basis, and C1 with C2 ,\nso the codewords are now\nX\n(54)\n|u + wi (u \u2208 C2 ).\nw\u2208C1\u22a5\n\nThus, to correct errors for a CSS code, we can measure the parities of C1 in the Z\nbasis, and the parities of C2 in the X basis.\nAnother even smaller quantum code is the [[5, 1, 3]] code I promised earlier [8,\n34]. Its stabilizer is given in table 4. I leave it to you to verify that it commutes\nand actually does have distance 3. You can also work out the codewords. Since\nmultiplication by M \u2208 S merely rearranges elements of the group S, the sum\n!\nX\n(55)\nM |\u03c6i\nM\u2208S\n\nis in the code for any state |\u03c6i. You only need find two states |\u03c6i for which (55) is\nnonzero. Note that as well as telling us about the error-correcting properties of the\ncode, the stabilizer provides a more compact notation for the coding subspace than\nlisting the basis codewords.\nA representation of stabilizers that is often useful is as a pair of binary matrices,\nfrequently written adjacent with a line between them [12]. The first matrix has a\n1 everywhere the stabilizer has an X or a Y , and a 0 elsewhere; the second matrix\nhas a 1 where the stabilizer has a Y or a Z. Multiplying together Pauli operators\ncorresponds to adding the two rows for both matrices. Two operators M and\nN commute iff their binary vector representations (a1 |b1 ), (a2 , b2 ) are orthogonal\nunder a symplectic inner product: a1 b2 + b1 a2 = 0. For instance, the stabilizer for\nthe five-qubit code becomes the matrix\n\uf8f6\n\uf8eb\n0 1 1 0 0\n1 0 0 1 0\n\uf8ec 0 1 0 0 1\n0 0 1 1 0 \uf8f7\n\uf8f7.\n\uf8ec\n(56)\n\uf8ed 1 0 1 0 0\n0 0 0 1 1 \uf8f8\n1 0 0 0 1\n0 1 0 1 0\nAs an example of an application of this representation, let us prove a fact used\nabove:\n\nLemma 1. Given any stabilizer S, there is always at least one error with any\ngiven error syndrome.\nProof. Suppose S has a generators. The error syndrome of a Pauli operator\nE can be defined as an a-component binary vector with the ith entry indicating\nwhether the ith generator of S commutes with E (the ith bit is 0) or anticommutes\n(the ith bit is 1). Thus, if xi is the binary vector representing the ith generator\nof S and e is the binary vector representing E, then E has error syndrome v iff\nxi \u2299 e = vi , where \u2299 is the symplectic inner product. The generators of S give\n\n\fQUANTUM ERROR CORRECTION\n\nStabilizers\n\nGF(4)\n\nI\nZ\nX\nY\ntensor products\n\n0\n1\n\u03c9\n\u03c92\nvectors\n\n13\n\nmultiplication\naddition\n[M, N ] = 0\ntr(M * N ) = 0\nN (S)\ndual\nTable 5. Connections between stabilizer codes and codes over GF(4).\n\nlinearly-independent binary vectors, so we have a independent linear equations in\na 2n-dimensional binary vector space with a \u2264 n. By a standard linear algebra\ntheorem, these equations must always have a non-zero solution. (In fact, there is a\nwhole (2n \u2212 a)-dimensional subspace of solutions.)\n\u0003\n3.2. Codes over GF(4). The CSS construction is very nice in that it allows\nus to use the immense existing body of knowledge on classical binary codes to\nconstruct quantum codes. However, CSS codes cannot be as efficient as the best\nstabilizer codes - for instance, there is no [[5, 1, 3]] CSS code. Instead, if we want\nto construct the most general possible stabilizer codes, we should take advantage\nof another connection to classical coding theory.\nFrequently, classical coding theorists consider not just binary codes, but codes\nover larger finite fields. One of the simplest is GF(4), the finite field with four\nelements. It is a field of characteristic 2, containing the elements {0, 1, \u03c9, \u03c9 2}.\n\u03c9 3 = 1, \u03c9 + \u03c9 2 = 1\n\n(57)\n\nIt is also useful to consider two operations on GF(4). One is conjugation, which\nswitches the two roots of the characteristic polynomial x2 + x + 1:\n(58)\n\n1=1\n\n(59)\n\n0=0\n\n\u03c9 = \u03c92\n\u03c92 = \u03c9\n\nThe other is trace. tr x is the trace of the linear operator \"multiplication by x\"\nwhen GF(4) is considered as a vector space over Z2 :\n(60)\n\ntr 0 = tr 1 = 0\n\n(61)\n\ntr \u03c9 = tr \u03c9 2 = 1\n\nStabilizer codes make extensive use of the Pauli group Pn . We can make a\nconnection between stabilizer codes and codes over GF(4) by identifying the four\noperators I, X, Y , and Z with the four elements of GF(4), as in table 5 [13].\nThe commutativity constraint in the Pauli group becomes a symplectic inner\nproduct between vectors in GF(4). The fact that the stabilizer is Abelian can be\nphrased in the language of GF(4) as the fact that the code must be contained in its\ndual with respect to this inner product. To determine the number of errors corrected\nby the code, we must examine vectors which are in the dual (corresponding to N (S))\nbut not in the code (corresponding to S).\n\n\f14\n\nDANIEL GOTTESMAN\n\nThe advantage of making this correspondence is that a great deal of classical\ncoding theory instantly becomes available. Many classical codes over GF(4) are\nknown, and many of them are self-dual with respect to the symplectic inner product, so they define quantum codes. For instance, the five-qubit code is one such -\nin fact, it is just a Hamming code over GF(4)! Of course, mostly classical coding\ntheorists consider linear codes (which are closed under addition and scalar multiplication), whereas in the quantum case we wish to consider the slightly more general\nclass of additive GF(4) codes (that is, codes which are closed under addition of\nelements, but not necessarily scalar multiplication).\n3.3. Even more quantum error-correcting codes. There are, of course,\nmany quantum error-correcting codes that are not stabilizer codes, and a good deal\nof work has been done on other sorts of codes. Usually, you need to assume a\ncertain level of structure in order to be able to find and work with a code, and\nthere are a number of ways to ensure that you have sufficient structure available.\nOne very fruitful way is to consider codes not over qubits, but over higherdimensional registers, qudits. There is a natural generalization of stabilizer codes\nto this case [29], and a variety of qudit stabilizer codes are known (e.g., [1, 7, 26]).\nAnother route is to relax the stabilizer structure slightly and look for more efficient\nqubit codes [15]. One tool that has garnered interest over the last few years is\nknown as operator quantum error correction or subsystem codes [33, 36]. In this\ncase, we ignore certain degrees of freedom in the code, essentially encoding a state as\na linear subspace rather than another state. Subsystem codes offer no improvement\nin the basic error correction properties I have discussed so far, but do sometimes\nhelp when considering fault tolerance (sections 4 and 5).\nAnother interesting avenue is to study codes which are completely degenerate.\nSuch codes are known by various names, most commonly as decoherence-free subspaces (or DFS) [35]. If all of the possible errors for a code act as the identity on\nthe code subspace, then no active correction operation is needed - no matter what\nerror occurs, the state remains unchanged. Usually a DFS is considered for the case\nwhere errors occur continuously in time, in which case the set of possible errors generates a Lie algebra, and the DFS is then a degeneracy of the trivial representation\nof the Lie algebra acting on the Hilbert space of n qubits. One advantage of a DFS\nis that it continues to function even at very high noise levels, but decoherence-free\nsubspaces have the disadvantage that a non-trivial DFS only exists for certain very\nspecial noise models (although some, such as collective noise, have practical significance). In contrast, a more general QECC can reduce the effective error rate for a\nwide variety of types of noise, but only if the error rate is sufficiently low to begin\nwith.\nOf course, one can even go beyond quantum error correction to study other\nmethods of protecting qubits against noise. For instance, in dynamical decoupling [53], a series of quick operations is performed which cause the noise to cancel\nitself out. Dynamical decoupling only works when the noise is slowly varying compared to the rate at which we can perform operations. It has two advantages:\nlike a DFS, dynamical decoupling functions well even at relatively high error rates,\nbut unlike a DFS or QECC, dynamical decoupling does not require any additional\nqubits.\nThe problem of eliminating errors from a quantum computer is a difficult one,\nand we will want to use every tool that we can bring to bear on the problem. Most\n\n\fQUANTUM ERROR CORRECTION\n\n15\n\nlikely, this will include control techniques like dynamical decoupling as a first layer\nof defense, perhaps followed by specialized error-correcting codes such as a DFS or a\nphase QECC to handle certain dominant error types, with a more general quantum\nerror-correcting code as the final protection to deal with any kinds of errors not\neliminated by the first two layers. However, everything we do - every qubit we\nadd, every additional gate we perform - will have errors in it too, so additional\nspecialized layers of protection come with a cost, not just in additional overhead,\nbut also in additional errors that will need to be cleaned up by the final QECC. It\ncan become a difficult balancing act to judge precisely which protections are useful\nand which cause more trouble than they are worth.\n3.4. The logical Pauli group. The group N (S) has already played an important role in analyzing a code's ability to correct errors, and it will be nearly as\nimportant later when we discuss fault-tolerant quantum computation. Therefore,\nit is helpful to pause briefly to further consider its structure.\nThe elements of N (S) are those Pauli operators which commute with everything\nin the stabilizer. Consider how E \u2208 N (S) acts on a codeword of the stabilizer code.\nLet M \u2208 S; then\n(62)\n\nM (E|\u03c8i) = EM |\u03c8i = E|\u03c8i.\n\nThis is true \u2200M \u2208 S, so E|\u03c8i \u2208 T (S). That is, E takes valid codewords to valid\ncodewords. Now, if E \u2208 S itself, that is unsurprising: In that case, it takes valid\ncodewords to themselves. If E 6\u2208 S, this cannot be true - it must take at least one\ncodeword to a different codeword. It is a logical operation, acting on the encoded\nstate without interfering with the encoding.3 In general, I will indicate a logical\noperation by drawing a line over it. E.g., X is a bit flip on an individual physical\nqubit, and X is a logical bit flip, which changes an encoded qubit.\nNotice that if F = EM , with M \u2208 S, then F \u2208 N (S) as well and F |\u03c8i =\nEM |\u03c8i = E|\u03c8i for all |\u03c8i \u2208 T (S). Thus, two Pauli operators in the same coset of\nS in N (S) act the same way, so the different logical operations in N (S) are actually\nthe elements of N (S)/S. Similarly, note that two Pauli operators E and F have\nthe same error syndrome iff E and F are in the same coset of N (S) in Pn . There\nis always at least one error with any given error syndrome, and |Pn | = 4n+1 , so\n|N (S)| = 4 * 2n+k and |N (S)/S| = 4k+1 for an [[n, k, d]] code.\nWe can in fact identify N (S)/S with the logical Pauli group Pk . You can choose\nany maximal Abelian subgroup R of N (S)/S to represent the logical Z operators\n(including tensor products of Zs and Is). The size of a maximal Abelian subgroup\nis 4 * 2k , since an Abelian subgroup of N (S)/S corresponds to an Abelian subgroup\nof Pn which is larger by a factor |S| = 2n\u2212k . By choosing elements of N (S)/S that\nhave various syndromes with respect to R, you can also identify logical X operators.\nOf course, in order to make all this work, you need to choose the basis codewords\nappropriately. For instance, the encoded |00 . . . 0i state should be a +1-eigenstate\nof every element of R.\n3.5. The Clifford group. When working with stabilizer codes, a certain\ngroup of quantum gates shows up very often. These gates are sufficient to encode and decode stabilizer codes, and play an important role in the theory of\n3Incidentally, this proves that the distance d of a stabilizer code is not accidentally higher\nthan the distance given in Theorem 5.\n\n\f16\n\nDANIEL GOTTESMAN\n\nfault-tolerance. The group is most often known as the Clifford group (although its\nrelationship to Clifford algebras is tenuous), and is defined as\n(63)\n\nCn = {U \u2208 U (2n ) | U P U \u2020 \u2208 Pn \u2200P \u2208 Pn }.\n\nThat is, the Clifford group is the normalizer of Pn in the unitary group U (2n ).\nBesides being important in the theory of stabilizer codes, the Clifford group is\ninteresting in its own right. For one thing, it contains some very common quantum\ngates. The Hadamard transform H, \u03c0/4 phase rotation P , and CNOT gate are all\nin the Clifford group:\n\uf8eb\n\uf8f6\n1 0 0 0\n\u0012\n\u0013\n\u0012\n\u0013\n\uf8ec0 1 0 0\uf8f7\n1 1 1\n1 0\n\uf8f7\n, P =\n, CN OT = \uf8ec\n(64)\nH= \u221a\n\uf8ed0 0 0 1\uf8f8 .\n1\n\u22121\n0\ni\n2\n0 0 1 0\nWe can work out how each of these gates acts on the Pauli group by conjugation.\nFor instance, the Hadamard gate performs the following transformation:\n(65)\n\nX 7\u2192 Z\n\nZ 7\u2192 X.\n\nThere is no need to specify the action of H on Y , since conjugation is a group\nhomomorphism and Y = iXZ. We can therefore immediately determine that\nY 7\u2192 iZX = \u2212Y . In fact, it turns out that the Clifford group is generated by H,\nP , and CNOT.\nIn general, to specify a Clifford group operator U , it is sufficient to indicate its\naction on a generating set for the Pauli group, such as X and Z acting on each of\nthe n qubits. This is true because the Pauli group forms a basis for the 2n \u00d7 2n\nmatrices, allowing us to learn the action of U on any projector. However, there is\none remaining ambiguity, since if U = ei\u03b8 U \u2032 , then U and U \u2032 have the same action by\nconjugation. Since this sort of global phase has no physical significance, however,\nthis is not a very harmful ambiguity.\nThe Clifford group has a binary matrix representation just like stabilizers do.\nBased on the argument of the last paragraph, we can specify a Clifford group element (up to global phase) by specifying its action on the binary vectors corresponding to the Pauli operators. Since Clifford group elements preserve commutation and\nanti-commutation, they correspond to symplectic matrices over the 2n-dimensional\nbinary vector space. In fact, we can say more. The Pauli group Pn is, by definition,\na normal subgroup of Cn , and because Pauli operators either commute or anticommute, Pauli operators in Cn correspond to the identity symplectic matrix. The\ncenter Z(Cn ) consists of just the diagonal matrices ei\u03c6 I, and those also correspond\nto the identity symplectic matrix. Let Pn\u2032 = Z(Cn )Pn (that is, the Pauli group, but\nwith arbitrary phases, not just \u00b11, \u00b1i). Then Pn\u2032 is the kernal of the map from\nthe Clifford group to the group Sp(2n, Z2 ) of 2n \u00d7 2n binary symplectic matrices.\nThat is, Cn /Pn\u2032 \u223c\n= Sp(2n, Z2 ), which says that if we only care about the action of\nthe Clifford group up to phases, the Clifford group is effectively just the group of\nsymplectic matrices.\nAs a consequence of this equivalence, there is an efficient classical simulation\nof any circuit of Clifford group operators acting on an initial stabilizer state with\nfinal Pauli measurements [22]. Even though the overall action of the circuit is a\n\n\fQUANTUM ERROR CORRECTION\n\n17\n\nunitary transformation on a 2n -dimensional Hilbert space, each step can be represented as just a 2n \u00d7 2n binary matrix, and we can therefore rapidly compute the\noverall circuit action as the product of these matrices. This result can be extended\nto the case where the circuit includes not just unitary Clifford group gates but\nalso measurements of Pauli operators in the middle of the circuit, with later gates\ndependent on the outcome of the measurements.\n4. Fault-tolerant gates\n4.1. The need for fault tolerance. There is still a major hurdle before\nwe reach the goal of making quantum computers resistant to errors. We must\nalso understand how to perform operations on a state encoded in a quantum code\nwithout losing the code's protection against errors, and how to safely perform error\ncorrection when the gates used are themselves noisy. A protocol which performs\nthese tasks is called fault tolerant (FT for short). Shor presented the first protocols\nfor fault-tolerant quantum computation [44], but there have been some substantial\nimprovements since then. Now we know that, provided that the physical error rate\nper gate and per time step is below some constant threshold value, it is possible\nto make the logical quantum computation we wish to perform arbitrarily close to\ncorrect with overhead that is polylogarithmic in the length of the computation [1,\n28, 32].\nOur goal is to produce protocols which continue to produce the correct answer\neven though any individual component of the circuit may fail. The basic components which we need to create a universal quantum computer are\n(1) Preparation: Operations which prepare a new qubit in some standard\nstate. It is sufficient to have just one type of preparation that prepares\na |0i state, although we will actually use a number of different prepared\nstates.\n(2) Quantum Gates: A universal set of quantum gates. To have a universal\nset, it is sufficient\nto use\n\u0013 the gates H, CNOT, and the \u03c0/8 phase rota\u0012\n1\n0\n. This set of gates generates a group dense in\ntion R\u03c0/8 =\n0 ei\u03c0/4\nU (2n ) [9].\n(3) Measurement: Measurement of qubits. It is is sufficient to be able to\nmeasure individual qubits in the standard basis |0i, |1i.\n(4) Wait: In order to synchronize the operation of gates, we may sometimes\nneed to have qubits wait around without performing any action on them.\nThe individual qubits making up our quantum error-correcting code are called\nphysical qubits, and each of these actions is a physical action (e.g., a physical gate).\nEach instantiation of one of these components is called a physical location (or more\noften just location). The number of locations in a circuit is then at most the total\nnumber of qubits used times the total number of time steps used. The number of\nlocations will frequently be less than the maximum, as we will often prepare new\nqubits during the computation and measure qubits, which can then be discarded,\nbefore the computation is completed. Note that wait steps count as locations, but\nthat operations on classical data (in particular, measurement results) do not, as we\nwill assume that classical computation is perfect. Depending on the precise model\nwe are using, we may wish to simplify by assuming that modest amounts of classical\ncomputation take no time, but this is not essential.\n\n\f18\n\nDANIEL GOTTESMAN\n\nAny location can fail, including a wait step. We assume that when a location\nfails, it results in an error that can affect all of the qubits involved in the action. In\nthe case of preparation, a single-qubit quantum gate, measurement, or wait, that\nis just a single qubit. For a two-qubit quantum gate such as CNOT, we allow an\narbitrary error acting on the two qubits involved in the gate, including errors which\nentangle the two qubits. The actual error should be considered to be the action of\nthe failed component times the inverse of the desired component in that location.\nThus, if we wish to perform Z, but instead perform Y , the error is Y Z = iX. The\ngoal of fault tolerance is to take a quantum circuit which is designed to work in the\nabsence of errors and modify it to produce a new circuit which produces the same\noutput as the original circuit, but with the weaker assumption that the number of\nfailed locations is not too large. The precise rules for the probability of locations\nfailing and the type of errors produced when a location fails will be discussed in\nsection 5. I will sometimes refer to a location with an error in it as a faulty location.\nThe biggest obstacle which we must overcome in order to create a fault-tolerant\nprotocol is that of error propagation. Even if the gates we perform are themselves\nperfect, the action of those gates on the state can alter any errors that have already\noccurred and cause them to spread:\nU E|\u03c8i = (U EU \u2020 )U |\u03c8i.\n\n(66)\n\nThat is, a pre-existing error E on a state |\u03c8i followed by a correct gate U is\nequivalent to the correct state (U |\u03c8i), but with an error U EU \u2020 . When U is a\nsingle-qubit gate, this is not a very serious problem, since the weight of E does not\nchange, although the exact type of error may now be different. For instance, an X\nerror will become a Z error under the action of a Hadamard gate. The troublesome\ncase is when U is a two-qubit gate, in which case a single-qubit error E will often\nbecome a two-qubit error. For instance, notice that CNOT can propagate an X\nerror from the first qubit to the second, and can propagate Z from the second qubit\nto the first:\n(67)\n\nCN OT :\n\nX \u2297 I 7\u2192 X \u2297 X,\n\nI \u2297 Z 7\u2192 Z \u2297 Z.\n\nThis is a problem because it can increase the weight of an error. For instance, if\nwe are using a distance 3 code, it can handle a single-qubit error, but if we then\nperform a CNOT, even if the CNOT itself is perfect, that single-qubit error can\nbecome a two-qubit error, and our distance 3 code cannot necessarily correct that.\nSince we are not going to be able to make a universal quantum computer using\nonly single-qubit gates, clearly we are going to have be very careful as to how we\nuse two-qubit gates.\nThere is, of course, a solution to this problem, which I will discuss in the\nremainder of the chapter. Fault-tolerant circuits will be designed in such a way as\nto make sure error propagation does not get out of hand. Even though errors may\nspread somewhat, we can still correct the resulting errors, provided there are not\ntoo many to start with. Our eventual goal is to produce fault-tolerant versions of\nall the types of physical location. I will refer to each such construction as a gadget\nfor the particular operation. For instance, we will have fault-tolerant gates for each\nmember of a universal set of quantum gates. Each of these gadgets will simulate\nthe behavior of the corresponding non-fault-tolerant action, but instead of doing\nso on one or two physical qubits, it will perform the action on the logical qubits\nencoded in a quantum error-correcting code. When we are given a quantum circuit\n\n\fQUANTUM ERROR CORRECTION\n\n19\n\nwhich we would like to perform, we replace each of the locations in the original\ncircuit with the corresponding fault-tolerant gadget.\nGenerally, we assume that the original circuit takes no input: all qubits used\nin it must be prepared using preparation locations. This still allows us to perform\narbitrary quantum computations, since we can modify the quantum circuit based\non the classical description of the problem we wish to solve. (For instance, if we\nwish to factor a number N , we could tailor the exact quantum circuit to work with\nN .) Then the final fault-tolerant measurement gadgets will produce classical information which should, if the fault-tolerant circuit has done its work properly, give\nthe same outcome as the original circuit would have if we could have implemented\nit without error.\n4.2. Definition of fault tolerance. It is perhaps time to get more precise\nabout exactly what we mean by fault tolerance. A fault-tolerant gadget should\nhave two basic properties: When the input state to the gadget does not have too\nmany errors in it, and there are not too many errors on the physical locations in\nthe gadget, the output state should also not have too many errors; and, when there\nare not too many errors in the input state or during the course of the gadget, the\ngadget should perform the correct logical operation on the encoded state. To define\nthese properties rigorously, we need to first introduce the notions of an r-filter and\nan ideal decoder [3].\nDefinition 1. An r-filter is a projector onto the subspace spanned by all\nstates of the form Q|\u03c8i, where |\u03c8i is an arbitrary codeword and Q is a Pauli error\nof weight at most r. An ideal decoder is a map constructed by taking the input\nstate and performing a decoding operation (including error correction) consisting\nof a circuit with no faulty locations.\nThat is, the r-filter projects onto states with at most r errors. Of course, the\nr-filter has no way of knowing what the correct codeword is at this point of the\ncomputation, so even a 0-filter might project on the wrong state. The point is that\nthe only states that can pass through the r-filter are those which could possibly\nbe created from a valid codeword with at most r single-qubit errors. The ideal\ndecoder takes the encoded state, corrects any errors, and gives us an unencoded\nstate. The ideal decoder gives us a way of talking about the logical state of the\nquantum computer at any point during the computation, and the r-filter makes\nprecise the notion of a state having \"at most r errors.\"\nIt is convenient to use a graphical notation to represent these objects, as follows:\nr\n\nr-Filter\n\n@\n\nIdeal Decoder\n\nThe horizontal lines represent a single block of a QECC, except for the one on\nthe right end of the ideal decoder symbol, which is a single unencoded qubit. We\nwill focus on the case where the code we use is an [[n, 1, 2t + 1]] code. That is,\nthere is just one encoded qubit per block, the code can correct t errors, and the\nthick horizontal lines in the diagrams represent n qubits. It is also possible to\nachieve fault-tolerance with multiple qubits encoded per block [21], but matters\nare somewhat more complicated then.\n\n\f20\n\nDANIEL GOTTESMAN\n\nWe are going to need fault-tolerant gadgets representing state preparation,\nmeasurement, and gates. (The fault-tolerant \"wait\" gadget just consists of having\nall the encoded qubits wait.) In addition, we will need to correct errors during the\ncourse of the computation so that they do not build up to an unacceptable level.\nNaturally, our error correction step also needs to be fault tolerant, since otherwise\nperforming error correction would have a substantial risk of creating more errors\nthan it fixes. This may still happen if the error rate is too high, but at least by\ndesigning the error correction step properly, we have a fighting chance of improving\nmatters by doing error correction. We will represent all of these gadgets graphically\nas well:\n\u0013\ns\n\n\u0013\u0010\ns\nU\nGate U\n\u0012\u0011\n\nPreparation\n\n\u0012\n\u0010\ns\nMeasurement\n\u0011\n\nEC\n\ns\n\nError Correction\n\nAs before, the thick horizontal lines represent a block of an [[n, 1, 2t + 1]] QECC.\nIn the case of the encoded gate, if it is a two-qubit logical gate, the horizontal lines\nrepresent two blocks of the QECC, each containing one logical qubit involved in the\ngate. The s in each diagram represents the maximum number of faulty locations\nthat may be involved in the circuit represented by the graphic. For simplicity, let\nus restrict attention to cases where the error associated to each fault is a Pauli\noperator. A slight generalization of Theorem 2 will allow us to consider other sorts\nof errors by looking at linear combinations of diagrams with specific Pauli errors.\nIf I draw a similar diagram but with thin lines and no indication of the number\nof errors, that means the diagram represents an idealized unencoded version of the\nsame operation.\nNow we can say rigorously what it means for these gadgets to be fault tolerant.\nThe following definitions will involve t, the number of errors the code can correct,\nand the ideal decoder for the code. We only need to guarantee the behavior of the\nsystem when the total number of errors involved is less than t, since we expect the\nconstructions to fail no matter what we do when there are more errors than the\ncode can correct.\nDefinition 2 (Fault-Tolerant Measurement). A measurement gadget is fault\ntolerant if it satisfies the following property:\nr\n\nMeas:\n\n\u0010\ns\n=\n\u0011\n\nr\n\n@\n\n\u0010\n\u0011\n\nwhen r + s \u2264 t.\n\nThat is, if the total number of errors in the incoming state and measurement\ngadget is at most t, then we should get the same result out of the real gadget as\nif we had performed ideal decoding on the incoming state and measured the decoded qubit. By \"the same result,\" I mean not only that the various measurement\noutcomes have the same probability in both cases, but that the remainder of the\ncomputer is left in the same relative state, conditioned on the measurement outcome, for either diagram. Really, we are comparing two operations, each of which\ntransforms a quantum state of the whole computer into a quantum state for the\n\n\fQUANTUM ERROR CORRECTION\n\n21\n\ncomputer minus one encoded block, plus a classical measurement outcome. The\ntwo operations are the same when the measurement gadget is fault tolerant.\nDefinition 3 (Fault-Tolerant Preparation). A preparation gadget is fault tolerant if it satisfies the following two properties:\nPrep A:\nPrep B:\n\n\u0013\ns\n\n\u0012\n\u0013\ns\n\u0012\n\n\u0013\ns\n\u0012\n\n=\n@\n\n=\n\ns\n\nwhen s \u2264 t.\n\n\u0013\n\nwhen s \u2264 t.\n\n\u0012\n\nThat is, a fault-tolerant preparation step with s \u2264 t errors should output a\nstate that is within s errors of a properly encoded state, and that furthermore,\nthe state should decode to the correct state under an ideal decoder. In the above\ndiagram equation for Prep A, and in many of the equations below, when we have\na fault-tolerant gadget on both the left and right side of the equation, assume the\nfaults on both sides are in the same locations and of the same type.\nThe definitions for a fault-tolerant gate are slightly more complicated, but of\nmuch the same form:\nDefinition 4. A gate gadget is fault tolerant if it satisfies the following two\nproperties:\n\nP\n\u0013\u0010\n\u0013\u0010\ns+ i ri\nri\ns\ns\nP\nU\nU\n=\nwhen s + i ri \u2264 t.\nGate A:\n\u0012\u0011\n\u0012\u0011\n\u0013\u0010\n\u0013\u0010\nri\nri\ns\nP\n@\n@\nU\nU\n=\nwhen s + i ri \u2264 t.\nGate B:\n\u0012\u0011\n\u0012\u0011\nIn all of these diagrams, a separate filter is applied to each input block when\nU is a multiple-qubit gate. Input block i gets an ri -filter. In propertyPGate A, a\nseparate filter is applied to each output block, but in all cases it is an s+ i ri -filter.\nIn property Gate B, an ideal decoder is applied separately to each block.\nri\n\nProperty Gate A says that errors should not propagate too badly: it is OK (and\nunavoidable) for errors to propagate from one block to another, but they should not\nspread within a block. Thus, the final number of errors on the outgoing state of each\nblock should be no more than the total number of errors on the incoming states,\nplus the number of errors that occurred during the gate gadget. As before, this only\nneeds to apply when the total number of errors is less than t. Property Gate B says\nthat if there are not too many errors in the incoming blocks and gadget combined,\nthen the fault-tolerant gate gadget should perform the right encoded gate. Gate B\nalmost says that we can create a commutative diagram with the ideal decoder, the\nFT gate gadget, and the unencoded ideal gate gadget, but the commutation only\nneed hold when the incoming states have few total errors.\nFinally, we must define fault-tolerant error correction:\n\nDefinition 5. An error correction (EC) gadget is fault tolerant if it satisfies\nthe following two properties:\nEC A:\n\nEC\n\ns\n\n=\n\nEC\n\ns\n\ns\n\nwhen s \u2264 t.\n\n\f22\n\nDANIEL GOTTESMAN\n\nr\n\nEC B:\n\nEC\n\ns\n\n@\n\nr\n\n=\n\n@\n\nwhen r + s \u2264 t.\n\nThat is, after an error correction step with at most s faulty locations, the state\nis at most s errors away from some encoded state. Note that this must apply no\nmatter how many errors were in the incoming state. This does not necessarily mean\nthose errors were dealt with properly, only that the final state is near a codeword.\nIt might be the wrong codeword, but it is still a valid codeword. Property EC B\ndoes say that if the total number of incoming errors and errors during the FT EC\nstep is less than t, the state has been corrected, in the sense that the logical state\nafter the EC step is the same as the logical state before it.\n4.3. Transversal gates. Now we must try to find constructions that fulfill\nthese definitions. Let us start with gate gadgets. Indeed, we have already seen a\nconstruction of fault-tolerant gates: Recall that for an [[n, k, d]] stabilizer code with\nstabilizer S, N (S)/S \u223c\n= Pk , the logical Pauli group on the k encoded qubits. Thus,\nin the absence of any errors, we can perform a logical Z, for instance, by choosing\na representative Q of the appropriate coset in N (S)/S. Q \u2208 Pn , so to perform it,\nwe simply need to perform some Pauli matrix (or the identity) on each of the n\nphysical qubits in the code. Observe that this construction satisfies properties Gate\nA and Gate B: Since we are performing single-qubit gates, there is no opportunity\nfor errors to propagate to different qubits, so property Gate A is clearly satisfied\nfor any number of errors (even if it is greater than t). Property Gate B follows from\nthis fact as well (although in this case, we really do need to specify that the number\nof errors is at most t). If you want to prove more formally that these properties are\nsatisfied, the key step is to note that we can rearrange the errors to all come after\nthe logical gate. Moving errors through the Pauli operator Q may change their\nidentity - we conjugate by Q - but does not change their weight.\nOf course, the reason this is true is that Q is a tensor product of single-qubit\ngates. For many codes, we can find additional gates that can be performed this way.\nFor instance, for the 7-qubit code, you can check that performing the Hadamard\non all 7 qubits, H \u22977 , performs the logical Hadamard H. This construction of\nH is automatically fault-tolerant, again because conjugating an error by H does\nnot change the weight of the error. Similarly, for the 7-qubit code, one can faulttolerantly perform P (the \u03c0/4 rotation) by performing P \u2020 on each of the 7 physical\nqubits in the code [44].\nIf we wish to generalize to multiple-qubit gates - and we need to do that\nsomehow to get universal quantum computation - we can no longer assume that\nconjugating by U will leave the weight of an error unchanged. However, if we\nmake sure that any increase in the number of errors is spread out between multiple\nblocks of the code, we can ensure that each block is not overwhelmed with errors.\nIn particular, suppose we consider a gate (which\nN may act on m blocks of the code)\nwhich is constructed as a tensor product U =\nUi , where Ui acts on the ith qubit\nof each block. The Ui s can do whatever they like to the m qubits they act on; we\ndon't even make the constraint that all the Ui s be the same. A gate constructed\nthis way is called a transversal gate, and it will automatically be fault tolerant.\nWhen Ui conjugates any number of errors on the m ith qubits, we can get an error\nthat acts only on those m qubits. In particular, Ui will only ever propagate a single\n\n\fQUANTUM ERROR CORRECTION\n\n23\n\nerror into at most one qubit per block. Therefore, properties Gate A and Gate B\nwill also hold for transversal gates.\nNote that we insist in the definition of transversal that the ith qubit of one\nblock only interacts with the ith qubit of another block, and not some different\nqubit in the second block. If this were not true, the gate would still be fault tolerant\nprovided each qubit in one block interacted with only a single qubit in a different\nblock. However, such a construction could cause problems if we attempted to put\ntwo of them together. For instance, if we have a gate that interacts qubit i of block\n1 with qubit j 6= i of block 2, and then follow it by a traditional transversal gate,\nan initial error on qubit i of block 1 could propagate to qubit j of block 2 and then\nback to qubit j of block 1, leaving us with two errors in the first block. The product\nof two transversal gates is again transversal, and thus fault-tolerant, but this would\nnot be true if we changed the definition of transversal to allow permutations of the\nqubits in a block.\nAs an example of a transversal two-qubit gate, consider again the 7-qubit code.\nPerforming CNOT\u22977 - a transversal CNOT between corresponding qubits of the\ntwo blocks - implements the logical CNOT [44]. We sometimes use the terminology \"transversal U \" for the transversal gate U \u2297n . Even though transversal does not\nnecessarily mean that all the tensor components are the same, the most common\nexamples have this property, so the phrase is often used as a shorthand.\nIn fact, the transversal CNOT performs the logical CNOT for any CSS code,\nnot just the 7-qubit code. This fact is one reason that CSS codes are particularly\nfavorable for fault tolerance. (We shall see another in the following section.) The\n7-qubit code is particularly good. As I noted above, for the 7-qubit code, we have\ntransversal implementations of H, P , and CNOT. Since products of transversal\ngates are again transversal, this implies that the whole logical Clifford group can\nbe implemented transversally as well. However, the Clifford group is not universal\nfor quantum computation (it can even be efficiently simulated classically), and\nunfortunately, there are no other transversal logical gates for the 7-qubit code, so\nwe will have to resort to another type of construction to complete a universal set\nof logical gates. One might hope to avoid this by finding a better code, but in fact,\nno code allows a universal set of transversal gates [18].\n4.4. Fault-tolerant error correction and measurement. We will return\nto the task of completing the universal set of logical gates in a little bit, but first let\nus discuss another part of a fault-tolerant protocol, fault-tolerant error correction.\nBefore we do that, we should first consider precisely how we do non-fault-tolerant\nerror correction.\nWhen we have an [[n, k, d]] stabilizer code, to do error correction, we wish to\nmeasure the eigenvalue of each of the n \u2212 k generators of the stabilizer. Each\neigenvalue tells us one bit of the error syndrome. It is straightforward to measure\nthe eigenvalue of any unitary operator U using a standard phase kickback trick\n(see figure 1). Add a single ancilla qubit in the state |0i + |1i, and perform the\ncontrolled-U from the ancilla qubit to the data for which we wish to measure U .\nThen if the data is in an eigenstate of U with eigenvalue ei\u03c6 , the ancilla will remain\nunentangled with the data, but is now in the state |0i + ei\u03c6 |1i. (If the data is not\nin an eigenstate, than the ancilla becomes entangled with it, decohering the data in\nthe eigenbasis of U .) In the case where the eigenvalues of U are \u00b11, as for U \u2208 Pn ,\n\n\f24\n\nDANIEL GOTTESMAN\n\n|0i + |1i\n\nu\n\nH\n\n@\n\nEigenvalue\n\nU\n\nFigure 1. A non-fault-tolerant implementation of the measurement of U , which has eigenvalues \u00b11.\nwe can just measure \u03c6 by performing a Hadamard transform on the ancilla qubit\nand measuring it.\nHowever, this construction allows for runaway error propagation, even when U\nis as simple as a multiple-qubit Pauli operator. The controlled-U is implemented\nas a series of controlled-Qi gates, with Qi \u2208 P1 acting on the ith data qubit, but\neach controlled-Qi gate is capable of propagating errors in either direction between\nthe ancilla qubit and the ith data qubit. Therefore, a single error early on in this\nconstruction could easily propagate to many qubits in the data block.\nTo avoid this, we would like to spread out the ancilla qubit to make the\ncontrolled-U gate more like a transversal gate. However, we want either all the\nQi s to act or none of them. We can achieve this by using an ancilla in the n-qubit\n\"cat\" state |00 . . . 0i + |11 . . . 1i, as in figure 2. After interacting with the data, we\nwould like to distinguish the states |00 . . . 0i \u00b1 |11 . . . 1i. The most straightforward\nway to do this is to note that\nX\n(68)\n|xi\nH \u2297n (|00 . . . 0i + |11 . . . 1i) =\nwt(x)=even\n\n(69)\n\nH\n\n\u2297n\n\n(|00 . . . 0i \u2212 |11 . . . 1i) =\n\nX\n\nwt(x)=odd\n\n|xi.\n\nThus, by measuring each qubit of the ancilla in the Hadamard basis and taking\nthe parity, we can learn the eigenvalue of U . Now the ith qubit of the data only\ninteracts with the ith qubit of the ancilla, so there is no chance of catastrophic error\npropagation. Errors can only propagate between a single qubit of the ancilla and\na single qubit of the data. For simplicity, I described the cat state as an n-qubit\nstate, but of course, it only need be as large as the weight of U , since any additional\nqubits in the ancilla will not interact with the data at all.\nStill, this construction does not yet give us a fault-tolerant error correction\ngadget. There are two remaining problems. First, we have not specified how to\ncreate the ancilla cat state yet. Second, if even a single qubit of the ancilla has an\nerror, the measurement result could have the wrong parity, giving us an incorrect\nsyndrome bit. The solution to the second problem is tedious but straightforward:\nafter measuring every bit of the error syndrome to get a candidate error syndrome,\nwe repeat the process. If we repeat enough times, and the number of errors in the\ncourse of process is not too large, we can eventually be confident in the outcome,\nas a single faulty location can only cause a single measurement outcome to be\nincorrect. Actually, there are some additional complications due to the possibility\n\n\fQUANTUM ERROR CORRECTION\n\n|0 . . . 0i+\n|1 . . . 1i\n\nu\n\nu\n\nH\n\n@\n\nH\n\n@\n\nu H\n\n25\n\nEigenvalue\n\n@\n\nU1\nU2\nU3\nFigure 2. A component\nN of a fault-tolerant implementation of the\nmeasurement of U =\nUi , which has eigenvalues \u00b11.\n\nof errors occurring in the data qubits - which can cause the true error syndrome\nto change - in the middle of the correction process, but these too can be handled\nby sufficient repetition of the measurement.\nTo create a cat state, we must be somewhat careful. The obvious circuits to\ndo it are not fault-tolerant. For instance, we could put a single qubit in the state\n|0i + |1i, and then perform CNOTs to the other n \u2212 1 qubits, which are initially\nin the |0i state. However, an error halfway through this procedure could give us a\nstate such as |0011i + |1100i, which effectively has two bit flip errors on it. When\nwe interact with the data as in figure 2, the two bit flip errors will propagate into\nthe data block, resulting in a state with 2 errors in it. To avoid this, after creating\nthe cat state, we must verify it. One way to do so is to take pairs of qubits from the\ncat state and CNOT them both to an additional ancilla qubit which is initialized to\n|0i. Then we measure the additional ancilla, and if it is |1i, we know that the two\nqubits being tested are different, and we discard the cat state and try again. Even\nthough this verification procedure is not transversal, it is still going to allow us to\nfault-tolerantly verify the state due the nature of error propagation in a CNOT.\nThe ancilla qubit is the target of both CNOT operations, which means only phase\nerrors can propagate from it into the cat state. A single phase error can already\nruin our cat state, giving us the wrong syndrome bit as the outcome - that is why\nwe must repeat the measurement - so two phase errors are no worse. If we do\nsufficient verification steps, we can be confident that either the ancilla cat state is\ncorrect, with possibly s errors on it, or there were more than s faulty locations in\ntotal during the preparation and verification step for the cat state. That is enough\nto ensure that the error correction procedure, taken as a whole, is fault tolerant.\nTo summarize, we must first create many cat states. We do this via some\nnon-fault-tolerant procedure followed by verifying pairs of qubits within the cat\nstate to see if they are the same. We use each cat state to measure one bit of\nthe error syndrome, and repeat the measurement of the full syndrome a number\nof times. In the end, we deduce a consensus error syndrome and from it an error\nwhich we believe occurred on the data, and then correct that error. The above\nprocedure is known as Shor error correction [44], and it works for any stabilizer\ncode. A similar procedure can be used for measuring a logical Pauli operation on a\nstabilizer code, although in that case, we must be careful to perform error correction\n\n\f26\n\nDANIEL GOTTESMAN\n\nbefore repeating our measurement attempt, as an uncorrected error on the data can\ncause the measurement outcome to be incorrect even if the measurement procedure\nitself is completely free of errors. I have been somewhat cavalier about some of the\ndetails above partially because they are complicated and partly because Shor error\ncorrection is rather laborious, requiring many extra gates and a low physical error\nrate to work well. There are some much more efficient schemes for fault-tolerant\nerror correction available, so Shor error correction is rarely used.\nThe first such improved scheme is Steane error correction [48]. Steane error\ncorrection works only on CSS codes. (There is a more complicated version that\nworks on general stabilizer codes, but it is not usually used; the version in Steane's\npaper\nhas an error.) Recall that the codewords of a CSS code are of the form\nP\n\u22a5\nw\u2208C2 |u + wi where C2 is a classical linear code, and u \u2208 C1 . u tells us the\nlogical codeword encoded by this state. If we were to measure every qubit of a\nCSS code, in the absence of error, we would get the classical result u + w for some\nrandom w \u2208 C2\u22a5 . Since C2\u22a5 \u2286 C1 , u + w \u2208 C1 , but we can deduce u by seeing which\ncoset from C1 /C2\u22a5 u+w falls into. If there are some errors on the state, phase errors\nin the original state do not cause errors in the measurement outcome; however, a\nbit flip error on qubit i produces a bit flip error on the corresponding classical bit\ni. Thus the classical outcome is u + w + e, where e is a vector representing the\nlocations of the errors. But C1 is a classical error-correcting code, so by applying\nthe classical decoding procedure, we can deduce e, u, and w if there are not too\nmany errors.\nIf there are some faults in the physical measurement locations, then the outcome becomes u + w + e + f , where e represents the pre-existing bit flip errors\nbefore the measurement and f represents the errors caused by faulty measurement\nlocations. Note, however, that measurement is performed transversally, so a single\nfailed measurement only affects a single bit of the output; that is, wt(f ) \u2264 s when\nthere are s faulty measurement locations. In this case, provided wt(e + f ) \u2264 t1\n(assume the classical code C1 corrects t1 errors), we can deduce u, w, and e + f ;\nhowever, we cannot distinguish e and f . This is annoying, but not particularly\nharmful if we only wish to measure the state. In that case, u tells us the outcome\nof the measurement, and as long as we learn that, we are OK. This gives us a\nfault-tolerant measurement procedure for CSS codes.\nOf course, we have not achieved fault-tolerant error correction yet. Measuring\nthe qubits directly does tell us about bit flip errors, but only at the cost of destroying\nthe code block. Clearly that is not desirable. We will also need to learn about any\nphase flip errors in the state. To do so, we will again introduce some ancilla qubits.\nI noted above that transversal CNOT applies the logical CNOT for any CSS code.\nTherefore, let us create an ancilla block in a codeword of the CSS code we are using.\nThen do a transversal CNOT from the data block to the ancilla block. Afterwards,\nboth the data block and the ancilla block are still in codeword states. Furthermore,\nany bit flip errors in the data were propagated forward along the CNOTs to the\ncorresponding locations in the ancilla block. Now if we measure every qubit of\nthe ancilla block, as described above, we learn e + f for the ancilla block. That\nwill be a combination of the bit flip errors on the data block, pre-existing bit flip\nerrors on the ancilla, and bit flip errors that occurred during transversal CNOT or\nmeasurement. There are clearly a lot of extraneous errors to worry about, but at\nleast we have learned something about the errors in the data block.\n\n\fQUANTUM ERROR CORRECTION\n\ndata\n|0i + |1i\n|0i\n\n27\n\nk u\nk\n\nu H\n\n@ Error syndrome\n@\n\nFigure 3. Steane Error Correction. Each horizontal line represents a full n-qubit block of the code, and each gate or measurement\nrepresents a transversal implementation of that operation.\n\nStill, we need to be careful. We used a transversal CNOT to copy the errors\nfrom the data block to the ancilla, but we don't actually want to perform the logical\nCNOT gate. Error correction should leave the encoded data unchanged. Therefore,\nwe should start the ancilla not in just any codeword state, but in the encoded state\n|0i + |1i, an eigenstate of CNOT (when it is in the target block of the CNOT).\nThus, the encoded state of the data does not change when we perform the CNOT.\nThis also means that measuring u for the ancilla tells us nothing about the state of\nthe encoded data; indeed, u will be random, just like w. We have to also be careful\nabout error propagation: while bit flip errors are propagating from the data block\ninto the ancilla block, phase errors are propagating from the ancilla block into the\ndata block. Therefore, we must be careful that the procedure we use to create the\nancilla block does not result in too many errors. Since the ancilla block is just\nan encoded |0i + |1i state, the problem of creating such a state is identical to the\nproblem of creating a fault-tolerant preparation gadget, so I will defer discussion of\nhow to do this until section 4.6. For now, just assume that we have such a method\nwhich, when the encoding circuit has at most s faulty locations, creates the correct\nstate with at most s errors on it.\nTo correct bit flip errors on a CSS code, we thus create an ancilla encoded in\nthe same code in the state |0i + |1i, and perform transversal CNOT from the data\nblock to the code block. Then we measure all of the qubits of the ancilla block, and\ntreat the result as a classical codeword for the code C1 . We deduce the locations\nof the errors, and correct them in the data block. We can follow almost the same\nprocedure to correct phase errors: Instead, we create an ancilla block in the state\n|0i and perform transversal CNOT with the ancilla block as control and the data\nblock as target. This copies phase errors from the data block to the ancilla, and\nso we measure each ancilla qubit in the Hadamard-rotated basis. In that basis, the\ncode is a superposition of codewords from C2 , so we treat the measurement output\nas a classical codeword for C2 with some errors, and deduce those errors via the\nclassical decoding procedure for C2 . Then we correct phase errors in the resulting\nlocations in the data block. The whole procedure is summarized in figure 3.\nNow let us show that Steane EC satisfies properties EC A and EC B. Assume\nthat the incoming data block has errors in locations summarized by a vector e, with\ne composed of eP , phase errors, and eB , bit flip errors. In each of these vectors,\n1 in the ith component of the vector indicates an error acting on the ith qubit of\nthe block. eP and eB can have 1s in the same location, in which case there is a\nY error at that location. We can assume that all errors in the incoming block are\nPauli errors by linearity (a la Theorem 2).\n\n\f28\n\nDANIEL GOTTESMAN\n\nSuppose the phase ancilla, after its preparation is complete, has errors whose\nlocations can be summarized by a binary vector fP , and the bit flip ancilla has\nerrors that can be summarized by a binary vector fB . Let us summarize the\nfaults in CNOT gate locations by gP and gB . (Note that each such faulty gate\nlocation can affect both the corresponding data qubit and ancilla qubit, and not\nnecessarily with the same sort of error.) Finally, assume that during the Hadamard\nand measurement of the phase ancilla block, there are faults whose locations are\nsummarized together by a vector hP , and during the measurement of the bit flip\nancilla block, there are faults summarized by hB . For hP and hB , we will only\ncount errors that show up in the measurement result, since there is no possibility\nof these errors propagating into the data block except via the measurement result.\nFor the other sorts of errors (other than those in the incoming data block), we will\nmake no restrictions as to the types of errors. We will ignore errors that occur\nduring the final correction step where we fix the error deduced from the syndrome\nmeasurement, since the correction step itself can be done transversally. Errors that\noccur then count, of course, but each error during the final correction step can only\ncause one qubit to go wrong, so they can never cause EC A or EC B to fail.\nTo prove EC A, we assume that s = wt(fP ) + wt(fB ) + wt(gP ) + wt(gB ) +\nwt(hP ) + wt(hB ) \u2264 t, and we wish to show that the final state after correcting the\nmeasured error is at most s errors away from a valid codeword of some sort. In\nfact, I claim the following:\nClaim 1. The final state will have errors only on qubits from fP \u2228 fB \u2228 gP \u2228\ngB \u2228 hP \u2228 hB , where \u2228 represents the bitwise OR.\nThat is, the only qubits in the final state that have errors will be in a location\ncorresponding to one of the faults that occurred during the EC circuit, and there\nare at most s of those. By \"corresponding location,\" I mean that if a fault occurs\nin the ith qubit of one of the ancilla blocks, there could be a fault in the ith qubit\nof the data block.\n(i)\n\n(i)\n\n(i)\n\nProof. In the following proof, the fx , gx , and hx (x = P, B) will be vectors\nwhich indicate subsets of fx , gx , and hx . The content of the (i) superscripts has no\nparticular meaning except to label potentially different subsets.\n(1)\nThe error measured by the phase part of the error correction will be eP + fP +\n(1)\n(1)\ngP + hP . However, note that, since we are making no restriction on wt(eP ), it is\n(1)\n(1)\n(1)\npossible that wt(eP + fP + gP + hP ) > t2 , where the phase code C2 corrects t2\nerrors. In that case, the classical decoding procedure for C2 will instead deduce some\nerror d which might be different from the actual accumulated error. Still, d must\n(1)\n(1)\n(1)\n(1)\n(1)\n(1)\nhave the same syndrome as eP +fP +gP +hP , so v = d+eP +fP +gP +hP \u2208 C2 .\nSince the X generators of the CSS code are given by vectors of C2\u22a5 , it follows that\nthe operator Zv with Zs on all the qubits indicated by v \u2208 C2 commutes with\nevery X generator, and therefore Zv \u2208 N (S), and it maps any logical codeword to\nanother (potentially different) logical codeword.\nAfter interacting with the two ancilla blocks, but before we correct any errors,\n(2)\n(2)\n(2)\nthe data will have phase errors on qubits indicated by the set eP + gP + gB + fB .\nWhen we apply phase error correction to fix the errors on the qubits indicated\n(2)\n(2)\n(2)\nby d, we therefore get the net phase error d + eP + gP + gB + fB . Now, we\n(1)\n(1)\n(1)\nknow that d + eP = v + fP + gP + hP , so we can rewrite the net phase error\n\n\fQUANTUM ERROR CORRECTION\n\ndata\n\nu\n\n|0i + |1i\n\nu H\n\nk\n\n|0i\n\nk\n\n29\n\n2 cbits plus\n@ error syndrome\n@\n\n?\nQ\n\nFigure 4. Knill EC. Each horizontal line represents a full n-qubit\nblock of the code, and each gate or measurement represents a\ntransversal implementation of that operation. Q is a Pauli operator and contains a correction for both the teleportation outcome\nand error correction.\n(1)\n\n(2)\n\n(1)\n\n(2)\n\n(2)\n\n(1)\n\nas v + fP + fB + gP + gP + gB + hP . But Zv \u2208 N (S), so applying a phase\nto all the qubits of v only takes us to another codeword. Therefore, the final state,\n(1)\n(2)\npost-error correction, is equal to some codeword with a phase error fP + fB +\n(1)\n(2)\n(2)\n(1)\ngP + gP + gB + hP (plus possibly some bit flip errors). Note that this is a subset\nof fP \u2228 fB \u2228 gP \u2228 gB \u2228 hP \u2228 hB , showing that the phase errors on the final codeword\nsatisfy the claim.\nThe proof that the final bit flip errors are a subset of fP \u2228fB \u2228gP \u2228gB \u2228hP \u2228hB\nis similar.\n\u0003\nProving the property EC B is more straightforward, since we can now assume\nthat s + wt(e) \u2264 t. Again, the final errors will be a subset of fP \u2228 fB \u2228 gP \u2228 gB \u2228\nhP \u2228 hB , but now there is no shift by an element of N (S), so an ideal decoder after\nthe EC step will produce the same result as an ideal decoder applied before the EC\nstep, when there is just the error e.\nAnother useful method of fault-tolerant error correction is due to Knill [30].\nKnill error correction is at some level similar to Steane error correction, in that\nit uses an ancilla state which is encoded using the same code as the data block.\nHowever, Knill EC works for any stabilizer code. The basic idea is to perform\nquantum teleportation, moving the encoded state into a different block of the code.\nBecause of the encoding, the Bell measurement used in quantum teleportation gains\nmore information than is needed for teleportation, and the extra information tells\nus the error syndrome of the combined errors on the data and ancilla block. Knill\nerror correction is pictured in figure 4. Two blocks are measured in the course of\nteleportation. One is basically used to reconstruct the Xs in the stabilizer and\none to reconstruct the Zs. I will not go into the details of how Knill EC works\nhere - see [30] instead. Knill EC can easily be modified to allow fault-tolerant\nmeasurement as well. To do that, we substitute an ancilla in the state |0i for the\nencoded EPR pair in the error correction circuit. The encoded Bell measurement\nthen still tells us the error syndrome, but instead of two random classical bits for\nthe teleportation, it tells us the outcome of a logical measurement on the data block\nin the standard basis.\nSteane and Knill EC both work on the principle of moving as much work as\npossible in the EC step into the creation of a particular ancilla state. There are two\nadvantages to doing so [30, 39, 48]. First, it means we do not have to do much\nwork directly on the data, which means the qubits don't have to sit around waiting\nfor the EC step to finish and don't accumulate much additional error during that\ntime. Second, because the ancillas are created in known states, we can put a lot of\n\n\f30\n\nDANIEL GOTTESMAN\n\ndata\nBell\n|00i + |11i\n\n?\n@\n\ndata\n\n2 cbits\n\nQ\n\nBell\n\n=\nU\n\n|00i + |11i\n\n2 cbits\n?\n\n@\n\nU\n\nU QU \u2020\n\nFigure 5. Gate teleportation of U . The process of teleporting the\nstate followed by U is the same as teleporting the state through a\nspecial ancilla with an appropriately modified correction operation.\n\neffort into verifying that they are correct, which we could not do directly for the\nunknown data state.\n\n4.5. Gate teleportation and universal fault-tolerant quantum computation. Now let us return to the task of creating a universal set of fault-tolerant\ngates. Since it is not possible to do this transversally, we need to add a new component, and that component will be measurement. The basic strategy will be similar\nto that for Steane or Knill EC: we will put a lot of effort into creating an appropriate ancilla state, and then quickly interact it with the data, the result being an\nimplementation of some particular gate. Not every gate can be directly performed\nthis way, but some non-Clifford group gates can be, and combined with the Clifford\ngroup gates, that is enough to give us a universal set of quantum gates.\nThe construction can be described in terms of quantum teleportation, again on\nthe encoded states. Let us begin by not worrying about fault-tolerance, and simply\nattempt to perform some gate U on an encoded state. We will consider the case of\na single-qubit gate U first. Suppose we were to perform quantum teleportation and\nthen follow it, somehow, by an implementation of U . Then on input state |\u03c8i, the\noverall output state would of course be U |\u03c8i. Now imagine that Bob, who controls\nthe output block, gets impatient waiting for Alice's measurement outcome and\ndecides to perform U earlier than intended. Eventually Alice performs the logical\nBell measurement and sends Bob the two classical bits describing the outcome,\ncorresponding to a logical Pauli Q. To complete the teleportation procedure, Bob\nnow needs to do something slightly different than before: First, he must undo the\nU he performed prematurely, then perform Q, and then finally redo U , now in the\ncorrect place. That is, he should do the gate U QU \u2020 . This procedure is pictured in\nfigure 5. It may not seem like we have gained anything by doing this, but for some\nspecial gates U , we have. We can imagine the state (I \u2297 U)(|00i + |11i) as a special\nancilla state, a replacement for the EPR pair normally used in teleportation, and\nwe can prepare it separately. Since it is a fixed ancilla state, independent of the\ndata, we can apply some special tricks to preparing it.\nWe still have to perform the gate U QU \u2020 , which cannot be done ahead of time\non the ancilla, since Q depends on the outcome of a logical Bell measurement on\nthe data block. However, the gate U QU \u2020 might be simpler to perform than U was.\nFor instance, when U \u2208 C1 , U QU \u2020 \u2208 P1 - that is the defining property of the\nClifford group. For some gates U 6\u2208 C1 , it is nonetheless still true that U QU \u2020 \u2208 C1\n\n\fQUANTUM ERROR CORRECTION\n\n31\n\nfor any Q \u2208 P1 . For instance, the \u03c0/8 rotation R\u03c0/8 has this property:\n\u0012\n\u0013\n0\ne\u2212i\u03c0/4\n\u2020\nR\u03c0/8 XR\u03c0/8\n= i\u03c0/4\n(70)\n= ei\u03c0/4 XP \u2020\ne\n0\n(71)\n\n\u2020\nR\u03c0/8 ZR\u03c0/8\n=Z\n\nWe sometimes call the set of unitary operators with this property, of conjugating\nPauli operators into Clifford group operators, C3 . C1 is the Pauli group Pn , and C2\nis the Clifford group C1 .4 One can define a set Ck = {U |U QU \u2020 \u2208 Ck\u22121 \u2200Q \u2208 C1 },\nand the teleportation construction tells us how, given appropriate ancilla states, to\nperform a gate from Ck once we know how to perform gates from Ck\u22121 . Note that\nthe sets Ck are not closed under multiplication.\nThis gives us an indication of how to perform a universal set of fault-tolerant\ngates. For the 7-qubit code, and some similar CSS codes, we already know how to\nperform all logical Clifford group operations. The Bell measurement is a Clifford\ngroup operation (plus measurement, which we also know how to do fault-tolerantly),\n\u2020\nis also a Clifford group operation for Q \u2208 P.\nand now we have seen that R\u03c0/8 QR\u03c0/8\nThus, if we can just prepare the special ancilla state (I \u2297 R\u03c0/8 )(|00i + |11i) faulttolerantly, we can do the complete gate teleportation procedure for the 7-qubit code\nto implement a fault-tolerant R\u03c0/8 gate. Since the Clifford group plus R\u03c0/8 form a\nuniversal set of gates, that gives us a universal fault-tolerant gate set for the 7-qubit\ncode.\nIt is perhaps worth saying as an aside a few words about the nature of this\nuniversal set of gates. Note that for a fixed number of (logical) qubits, it contains a\nfinite set of gates. These gates do not commute with each other, and if we look at\nthe group generated by these gates, we find that it is an infinite group. However,\nthe unitary group is uncountable, so we will not be able to exactly implement all\nunitary gates. We can, however, get arbitrarily close to any gate we wish, and\nthe approximation procedure can be done quite efficiently as a consequence of the\nSolovay-Kitaev theorem [27, 45]. For any gate U , to approximate U to within a\ndistance \u01eb, we need only use polylog(1/\u01eb) gates.\nNow back to fault tolerance. I have described the construction above for singlequbit gates U , but that is in no way essential. For a multiple-qubit gate U , we simply\nneed, as an ancilla, a state composed of multiple encoded EPR pairs with U applied\njointly on the second half of all of them. For instance, we can perform the CNOT in\nthis way using a four-qubit ancilla. If we take any stabilizer code with stabilizer S,\nwe can perform the Bell measurement as part of Knill error correction, and N (S)\ngives us transversal implementations of the logical Pauli group. Thus, using gate\nteleportation, given an appropriate ancilla, we get a fault-tolerant implementation\nfor any Clifford group gate on S. Then we can use gate teleportation again to\nget a universal set of gates. Thus, we can perform a universal set of gates for any\nstabilizer code [21].\nFor certain gates, even simpler constructions are available that take advantage\nof special properties of the gate [9, 44, 55]. For instance, R\u03c0/8 is a diagonal gate,\nand that lets us use the construction in figure 6. The more efficient construction\nonly involves a single encoded block as ancilla, which is somewhat easier to create.\n4I apologize for the similar appearance of C and C . C will not appear outside this\nn\nk\nk\nparagraph.\n\n\f32\n\nDANIEL GOTTESMAN\n\ndata\n|0i + e\n\ni\u03c0/4\n\n|1i\n\nk\nu\n\n@\n\n1 cbit\n?\n\nI or XP \u2020\n\nFigure 6. More efficient gate teleportation of R\u03c0/8 . The CNOT\nrepresents a logical CNOT, perhaps performed transversally.\n\n4.6. Fault-tolerant state preparation. The constructions I have presented\nin the last few sections rely on the ability to fault-tolerantly prepare some particular\nstates. It may seem like we have just postponed the main difficulty in performing\nnon-Clifford group gates and fault-tolerant error correction, and to a certain extent\nthis is true. However, since the ancillas we use in the above procedures are being\nprepared in known states, we have more options as to how to create them than\nwe do for performing an operation (such as the \u03c0/8 rotation) on an unknown data\nstate.\nIn order to perform Steane or Knill EC, we need to know how to create encoded\n|0i and encoded |0i + |1i states with few errors in them. We also, of course, need\nencoded |0i states to initialize the fault-tolerant quantum computation. Our goal,\nin particular, is to avoid correlated errors in these states. The desired states can\neasily be created using some non-fault-tolerant encoding circuit, but because such\ncircuits inevitably involve gates interacting pairs of qubits within the code block\nwe are constructing, a single error during the encoding circuit can cause correlated\nerrors affecting multiple qubits in the new block. This would certainly fail to satisfy\nproperty Prep A, and could easily fail to satisfy Prep B as well.\nOne way to create states is to use a version of Shor error correction. If we add\na stabilizer generator corresponding to the Z (for |0i) or X (for |0i + |1i), then\nthere is just a single state in the code specified by the new stabilizer, and it is the\none we wish to create. Performing Shor EC to correct an arbitrary state to the one\ncodeword of this new code will then produce a fault-tolerant preparation gadget.\nSteane and Knill EC don't give us so immediately methods of state preparation\nsince they need themselves ancillas prepared for the state we are trying to create,\nbut they still point us in the right direction. Suppose we performed Steane EC\non the created state without first verifying the ancilla states. The result would\nnot be reliable, since the states involved could have multiple correlated errors due\nto only a single error in the encoding circuit. However, suppose that if instead\nof correcting the state based on the error syndrome we measure, we simply use\nthe procedure to detect whether errors are present. Then if we see any errors, we\ndiscard the main state we are trying to create as well as the measured ancillas. In\norder for a correlated error to slip past this procedure, we need correlated errors\nboth on the data block we are trying to verify and on one or both ancilla blocks, and\nfurthermore, those errors must cancel in the error syndrome. Since the data block\nand ancilla blocks are created separately, we need two separate faults for this to\nbe possible: one during the creation of the data block and one during the creation\nof the ancilla block. We may need to repeat this procedure using ancillas that\nthemselves have passed previous rounds of screening, but with a sufficient number\nof iterations, we can fault-tolerantly prepare states even for large distance codes.\n\n\fQUANTUM ERROR CORRECTION\n\n33\n\nFor gate teleportation, we need more complicated ancillas. I will not go into\nthe details, but simply mention some of the main methods used in preparing such\nstates. For the ancillas needed to teleport Clifford group gates, we can use the\nmethod based on Shor EC or similar verification procedures to those for |0i or\n|0i + |1i. We have the same two options for other gates such as R\u03c0/8 , but both\nmethods become more complicated. The ancilla states used for R\u03c0/8 and similar\ngates are eigenstates of Clifford group operators, and can be uniquely specified by\nthis fact. For instance, the state |0i + ei\u03c0/4 |1i is the unique codeword which is a +1\neigenstate of ei\u03c0/4 XP \u2020 . Thus, if we measure the eigenvalues of XP \u2020 , which we can\ndo using a Shor-like method involving a cat state and repetition, we can determine\nif the ancilla state is correct or not [44].\nThere is also a method for verifying this state and some other related ancilla\nstates which involves comparing a number of copies of the state to test if any have\nerrors on them. As before, we imagine using some non-fault-tolerant procedure to\ncreate candidate ancilla states, and then we put them through this verification procedure and discard any states that fail. The states that come out of the procedure\nare more likely to be error-free (or at least less likely to have errors dating from\nthe non-fault-tolerant encoding part of the protocol). We can then take a pool\nof previously-tested states and iterate the verification procedure to purify them\nfurther. For details, see [10].\n5. Fault-tolerant circuits and the threshold theorem\n5.1. Good and bad extended rectangles. We have finally shown that there\nexist gadgets for fault-tolerant state preparation, measurement, error correction,\nand a universal set of gates. Now we are ready to study what happens when\nwe apply these gadgets. I will first show that provided errors do not occur too\nfrequently, we can put together a sequence of fault-tolerant gadgets to create a\ncircuit that gives the same output as the ideal unencoded circuit.\nDefinition 6. Let C be a quantum circuit consisting of a set of locations Ci ,\nwhere each Ci is a preparation location, a measurement location, a gate location, or\na wait location. The preparation locations introduce new qubits into the circuit, and\nthe measurement locations remove qubits from the circuit. We assume that C can\nbe divided up into time steps so that at each time step, every qubit (not counting\nthose to be added at later time steps or removed at earlier time steps) is involved\nin exactly one location, that the first location for every qubit is a preparation\nlocation, and that the last location for every qubit is a measurement. Two locations\nare considered to be consecutive if they occur at adjacent time steps and they\nshare a qubit. (If both are two-qubit gates, they only need to share one qubit.)\nThe fault-tolerant protocol for C (using a particular [[n, 1, 2t + 1]] QECC) is a\nquantum circuit C \u2032 constructed by replacing each location Ci with a fault-tolerant\ngadget for Ci , and adding fault-tolerant error correction gadgets between any pair\nof consecutive locations. C \u2032 is referred to as a fault-tolerant circuit for C or a\nfault-tolerant simulation of C.\nHowever, it is a bit unwieldy to prove things directly about the circuit as a\nwhole. Therefore, it makes more sense to focus on smaller units. We will chop\nthe fault-tolerant circuit up into pieces that contain just a single location from the\noriginal circuit C:\n\n\f34\n\nDANIEL GOTTESMAN\n\n\u0013\ns1\n\n\u0012\n\u0013\ns2\n\u0012\n\ns3\n\nEC\ns4\n\nEC\n\n\u001b\u0018\ns5\nEC\nCNOT\nEC\n\u001a\u0019\n\ns6\n\ns7\n\n\u0013\u0010\ns8\nH\nEC\n\u0012\u0011\n\u0010\ns9\n\ns10\n\n\u0010\ns11\n\u0011\n\n\u0011\n\nFigure 7. A schematic representation of a sample fault-tolerant\nprotocol, with extended rectangles marked.\n\nDefinition 7. An extended rectangle (abbreviated ExRec) in the fault-tolerant\ncircuit for C consists of the fault-tolerant gadget corresponding to some location Ci\nfor the original circuit, plus all of the fault-tolerant EC gadgets between Ci and the\nadjacent locations. We can characterize an ExRec by the type of the location Ci\n- e.g., if Ci is a preparation location, then the corresponding extended rectangle\nis a preparation ExRec. The EC step(s) before the gadget for Ci are leading EC\nstep(s), and those after the gadget for Ci are trailing EC step(s).\nFigure 7 gives an example of a fault-tolerant circuit, with the ExRecs indicated\nby dashed lines. Note that a preparation ExRec or a measurement ExRec only\ncontains a single EC, while a gate (or wait) ExRec contains two EC steps for each\nqubit involved in the gate. Except for a preparation ExRec, all ExRecs start with\nEC steps. Also, adjacent extended rectangles overlap. This is a complication,\nbut is actually simpler to deal with than the alternative of having non-overlapping\nrectangles. This is because we would like to somehow capture a notion that a\nrectangle \"behaves correctly\" when it does not have too many faulty locations.\nHowever, if the rectangles do not overlap, there could be an accumulation of errors\nat the end of one rectangle and at the beginning of the subsequent rectangle. There\nis no time to correct any errors between the two rectangles, so those errors would\ncombine to produce more errors than one might na\u0131\u0308vely expect just counting faulty\nlocations in one rectangle. This can be dealt with, of course, but that means not\nonly that analyzing the behavior of a single rectangle depends on the behavior of\nthe previous rectangle, but also that we are not taking full advantage of the QECC's\nability to correct errors.\nSo what does it mean to say that an extended rectangle behaves correctly? It\nshould mean, roughly speaking, that the encoded state after the extended rectangle\nis the same as encoded state before the extended rectangle but with the appropriate\nlogical operation performed on the state. However, we still have the complication\nabout having a collection of errors just before the beginning of an ExRec and\nthen more just after the beginning. That could mean that the state just before\nthe beginning of the ExRec is correctable, but then after the first time step of\nthe ExRec, before error correction has really had a chance to act, it is no longer\ncorrectable. Instead of looking at the state before the beginning of the ExRec,\nwe should instead look at the state after the leading EC step(s) of the ExRec but\nbefore the main gadget for the location Ci . By that point, any errors from the\nprevious rectangle have either been corrected or at least combined with errors that\noccurred during the leading EC steps. Thus, we make the following definitions:\n\n\fQUANTUM ERROR CORRECTION\n\n35\n\nDefinition 8. A gate or wait ExRec is correct for some particular arrangements of faults if\ns1\n\n(72)\n\nEC\n\n\u0013\u0010\ns2\nEC\nU\n\u0012\u0011\n\ns3\n\ns1\n\n@\n\nEC\n\n=\n\n@\n\n\u0013\u0010\nU\n\u0012\u0011\n\nA preparation ExRec is correct for some particular arrangements of faults if\n\u0013\ns1\n\ns2\n\n\u0012\n\n(73)\n\nEC\n\n@\n\n\u0013\n\n=\n\n\u0012\n\nA measurement ExRec is correct for some particular arrangement of faults if\ns1\n\nEC\n\n(74)\n\n\u0010\ns2\n=\n\u0011\n\ns1\n\nEC\n\n\u0010\n\n@\n\n\u0011\n\nWe expect that an ExRec should be correct if it contains no more errors than\nthe code can correct. Thus, we make the following definition:\nDefinition 9. A full ExRec is good if it contains at most t faults, where the\nQECC in use corrects t errors. A full ExRec is bad if it is not good.\nThe caveat \"full ExRec\" is needed for a technical reason which I will explain\nlater. For now, ignore it.\nThe definition of good is justified by the following theorem:\nTheorem 6 (Good implies correct). A good ExRec is correct.\nProof. The proof is a fairly straightforward application of the definitions of\nfault-tolerant gadgets. I will present the case of a gate ExRec. Measurement\nand preparation ExRecs work similarly. Since the ExRec is good, in the following\ndiagrams, s1 + s2 + s3 \u2264 t.\ns1\n\nEC\n\n\u0013\u0010\ns2\nU\nEC\n\u0012\u0011\n\n(75)\n\n=\n\nEC\n\n(76)\n\n=\n\nEC\n\n(77)\n\n=\n\n@\n\ns1\n\ns1\n\ns1\n\ns1\n\ns1\n\nEC\n\ns3\n\ns1\n\n\u0013\u0010\ns2\nEC\nU\n\u0012\u0011\n\u0013\u0010\ns2\nU\n\u0012\u0011\n\u0013\u0010\ns2\nU\n\u0012\u0011\n\ns3\n\n@\n\ns1 +s2\n\ns3\n\nEC\n\ns1 +s2\n\nby EC A\n\n@\n\n@\n\nby Gate A\n\nby EC B\n\n\f36\n\nDANIEL GOTTESMAN\n\n(78)\n\n=\n\nEC\n\n(79)\n\n=\n\nEC\n\n(80)\n\n=\n\nEC\n\ns1\n\ns1\n\ns1\n\ns1\n\ns1\n\n@\n\n\u0013\u0010\ns2\n@\nU\n\u0012\u0011\n@\n\n\u0013\u0010\nU\n\u0012\u0011\n\n\u0013\u0010\nU\n\u0012\u0011\n\nby Gate A\n\nby Gate B\n\nby EC A\n\u0003\n\n5.2. Level reduction. Now let us consider the case of a complete faulttolerant circuit. Suppose all the extended rectangles in the circuit are good. Then\nby applying theorem 6 repeatedly, we can create ideal decoders using the correctness property for the measurement locations, push the ideal decoders all the way\nto the left using correctness for the gate and wait locations, and then eliminate\nthe ideal decoders using correctness for the preparation locations. We are left, as\ndesired, with the original circuit C which the fault-tolerant circuit is supposed to\nsimulate.\nTheorem 7. Suppose a fault-tolerant circuit for C contains only good extended\nrectangles. Then the output distribution of the fault-tolerant protocol is the same\nas the output distribution of C.\nThat's precisely the result we wanted, but unfortunately it only applies when\nall the extended rectangles are good. In a little bit, once we talk more concretely\nabout the model of errors, you will see that this result is enough to say that a faulttolerant protocol helps protect against errors, in that, for sufficiently low error rate,\nthe probability of having only good ExRecs in the complete fault-tolerant circuit is\ngreater than the probability of getting through the original circuit C without any\nerrors. Unfortunately, when C is large, it is still unlikely we can make it all the\nway through even a fault-tolerant circuit without having a bad extended rectangle\nunless we go to codes which can correct many errors. But if we do use codes with\nlarge t, we will need a special family of codes, since otherwise we have no good way\nto make the large ancillas we need for fault-tolerant gate constructions and faulttolerant error correction. Luckily, there are two known families of codes for which\nwe can solve this problem, giving a threshold theorem. One of them is based on\ntopological constructions [16]. I will consider the other, which is somewhat simpler\nto analyze: the family of concatenated codes.\nThe logic behind a concatenated code is quite straightforward. We have shown\n(up to a question of defining the right error model) that we can take any circuit\nC and create a fault-tolerant circuit C \u2032 that gives the same result and is more\nreliable than C. Why not, therefore, take C \u2032 and create a fault-tolerant circuit\nC \u2032\u2032 simulating it? Surely that should be even more reliable. And if that is not\nenough, we can do it again and again until the circuit is robust enough to give\nus the right answer, even if the original circuit C is very large. And indeed, this\nstrategy works. We can create a sequence of circuits C (k) , k = 1, . . . , L, where each\nC (k) is a fault-tolerant simulation of C (k\u22121) , with C (0) = C. When C is large, it is\nnot very likely that C (L) contains only good extended rectangles, but it will be true\n\n\fQUANTUM ERROR CORRECTION\n\n37\n\nthat it simulates a C (L\u22121) which contains (with high probability, when the error\nrate is low enough, . . . ) fewer bad extended rectangles than C (L) , and so on, until,\nwith very high probability, C (1) does contain only good extended rectangles, and\nthus gives us a nearly perfect simulation of C.\nIn order to prove this, however, we will need to understand what happens to\na bad extended rectangle when we push an ideal decoder through it from right to\nleft. We would like to say that a bad extended rectangle simulates a faulty location\nin the original circuit, and this is almost true. In particular, we would like for the\nfollowing to be true when s1 + s2 + s3 > t, for some erroneous gate U \u2032 :\ns1\n\n(81)\n\nEC\n\n\u0013\u0010\ns2\nEC\nU\n\u0012\u0011\n\ns3\n\n@\n\ns1\n\n=\n\nEC\n\n@\n\n\u0013\u0010\nU\u2032\n\u0012\u0011\n\nUnfortunately, we cannot easily make any such statement. The problem is that\nthe error that occurs on the physical gate after the ideal decoder can depend not\nonly on the faults in the gate gadget and trailing EC, but also on the faults in the\nleading EC and even the carryover error from the previous ExRec, so there is no\nway to define U \u2032 without looking at the larger context. To handle this problem,\nwe introduce an alternate ideal decoder, a *-decoder, which keeps track of the error\nsyndrome:\n@\n\n*-Decoder\n\nThe line dropping out the bottom of the *-decoder contains the information about\nthe error syndrome of the state input on the left. Consequently, the *-decoder is a\nunitary operation. To replace (81), we thus can write:\ns1\n\n(82)\n\nEC\n\n\u0013\u0010\ns2\nU\nEC\n\u0012\u0011\n\ns3\n\n@\n\n=\n\n@\n\n\u0013\u0010\nU\u2032\n\u0012\u0011\n\nThe erroneous gate U \u2032 uses the error syndrome as a control to tell it what sort of\nerror to apply to the decoded qubit. Notice that we have pushed the *-decoder all\nthe way through the ExRec, eliminating the leading EC as well as the gate gadget\nand trailing EC. This is needed so that bad ExRecs do not overlap, since that could\nproduce correlated errors in the circuit being simulated. I shall return to this point\nshortly.\nCorrectness is defined using *-decoders in a way that is essentially identical\nto using regular ideal decoders. The only difference is that we must account for\nwhat happens to the error syndrome. Even if we move a *-decoder through a\ngadget with no faults, the error syndrome produced will generally change to account\nfor any gates performed on the erroneous physical qubits. For instance, if we\nperform a transversal Hadamard, pre-existing physical X errors will change to\nphysical Z errors, which have a different error syndrome. For this reason, we can\ndefine correctness for *-decoders using identical diagrams to those for regular ideal\ndecoders, but with the error syndrome changed in some way, which we do not need\n\n\f38\n\nDANIEL GOTTESMAN\n\nto specify. I.e., a gate ExRec is correct for *-decoders if it satisfies\ns1\n\n(83)\n\nEC\n\n\u0013\u0010\ns2\nEC\nU\n\u0012\u0011\n\ns3\n\n@\n\ns1\n\n=\n\nEC\n\n@\n\n\u0013\u0010\nU\n\u0012\u0011\nV\n\nfor some operation V on the error syndrome. (V of course depends on the errors\nin the original ExRec as well as the gate U .) The definitions for preparation and\nmeasurement ExRecs are similar; for the preparation ExRec, the error syndrome is\nbrought in as a separate input on the RHS of the definition, and for the measurement\nExRec, the error syndrome is discarded immediately after being produced. We then\nget the following lemma:\nLemma 2. If an ExRec is correct for an ideal decoder, it is correct for a *decoder.\nProof. Note that the ideal decoder is just the *-decoder with the error syndrome discarded. The definition of correctness for an ideal decoder must apply for\nall input states, including superpositions and parts of entangled states. This could\nnot hold if the error syndrome output of the *-decoder had any further interaction\nwith the data block after the action of the *-decoder.\n\u0003\nThus, we also know that good extended rectangles are correct for *-decoders.\nWe are almost ready to revise theorem 7 to take into account bad ExRecs as well as\ngood ones, but there is one more complication. We would like to replace decoders\nwith *-decoders in the proof of theorem 7 and push the *-decoders all the way\nthrough the circuit. However, I have declared that a *-decoder should get pushed\nall the way through a bad ExRec to eliminate the leading EC step. That means\nthat if we push a *-decoder backwards through a bad ExRec, the previous ExRec\nwill be left without a trailing EC, and will no longer be an ExRec.\nDefinition 10. An ExRec missing one or more trailing ECs (in the case of a\nmultiple-qubit gate ExRec) is called a truncated ExRec. A truncated ExRec is good\nif it contains at most t faulty locations and is bad if it is not good. Within a larger\ncircuit, determine whether an ExRec should be good or bad and full or truncated\nby the following procedure: Start from the end of the circuit, with measurement\nExRecs, and determine whether they are good or bad. For each other ExRec in the\ncircuit, truncate it by eliminating a trailing EC step if that EC step participates as\na leading EC in a bad ExRec (full or truncated). Once we know whether the ExRec\nis truncated (on all its output blocks, if there is more than one), determine whether\nit is good or bad. We can then determine recursively the nature of all ExRecs in\nthe circuit.\nIt is straightforward to define correctness for both regular ideal decoders and\n*-decoders for truncated ExRecs by just removing the trailing EC step from each\ndiagram.\nLemma 3. A good truncated ExRec is correct for both ideal decoders and *decoders.\nProof. Since the ideal decoder is supposed to incorporate a perfect error correction, we could insert an EC gadget with 0 errors before any ideal decoder without\n\n\fQUANTUM ERROR CORRECTION\n\n39\n\nchanging the ouput at all. (We cannot do this before a *-decoder since the perfect\nEC gadget would clear the error syndrome.) Therefore, the correctness diagram for\nideal decoders is effectively the same for full and truncated ExRecs, and it follows\nthat a good truncated ExRec is correct for ideal decoders. Then, applying lemma 2\n(which also works for truncated ExRecs), we find that a good truncated ExRec is\ncorrect for *-decoders as well.\n\u0003\nThat leads us to the following improvement of theorem 7:\nTheorem 8. Suppose we have a fault-tolerant circuit C \u2032 for C. Assign good\nand bad extended rectangles to C \u2032 , and produce a circuit C\u0303 as follows: If the ExRec\nfor Ci is good, include Ci unchanged in C\u0303. If the ExRec for Ci is bad, replace\nCi by the erroneous gate U \u2032 from eq. (82) or the corresponding equation for the\ncorrect type of location. The circuit C\u0303 uses ancilla registers to control the types of\nU \u2032 errors. Then the output distribution of C \u2032 is the same as the output distribution\nof C\u0303.\nThat is, C \u2032 simulates a version of C with errors in place of the bad extended\nrectangles. We prove this theorem in the same way as theorem 7, by creating *decoders at the right end of the circuit and pushing them back to the left using\nthe correctness conditions and eq. (82). The ancilla registers used to determine the\ntype of errors are the error syndrome registers produced by the *-decoders.\nFinally, we are ready to talk about a concrete error model and to prove that\nfault tolerance reduces the error rate.\nDefinition 11. An uncorrelated error model assumes that each location Ci\nis faulty with probability pi , independently for different locations, and if there is\nan error at location Ci , it is chosen from some distribution Ei independent of the\nother locations. In an uncorrelated Pauli error model, if a location has a fault, there\nis probability pQi of Pauli error Q acting on the qubit(s) involved in the location\n(relative to the correct operation for that location). Usually, we assume that pi\nand pQi only depend on what type of location Ci is, and nothing else about it.\nOften, we assume that pi = p for all i. An uncorrelated depolarizing error model is\na special case of the uncorrelated Pauli error model where pQi does not depend on\nQ (except for Q = I, no error, which can be different).\nUncorrelated Pauli error models, and particularly uncorrelated depolarizing error models, are very convenient if one is doing simulations of fault-tolerant protocols\nto analyze their behavior and error tolerance. One reason for this is that EC steps\nfor CSS and general stabilizer codes can be performed using only Clifford group\ngates, and thus the behavior of Pauli errors on a fault-tolerant circuit involving\nonly logical Clifford group gates can be efficiently simulated on a classical computer. Under more general errors, the simulations quickly become unwieldy after\nonly a few steps.\nHowever, any kind of uncorrelated error model is not going to be quite enough\nfor us. The reason is that in theorem 8, even if the errors in C are uncorrelated,\nthe location of good and bad ExRecs is somewhat correlated (because the ExRecs\noverlap, and whether an ExRec is truncated or not depends on whether the following\nExRec(s) are good or bad). Furthermore, the type of errors in C\u0303 are even more\ncorrelated, even entangled, because the type of error on a location C\u0303i of C\u0303 depends\non the persistent error syndrome register produced by the *-decoder. Therefore,\n\n\f40\n\nDANIEL GOTTESMAN\n\neven if C \u2032 has a simple uncorrelated error model, Pauli or otherwise, C\u0303 will not.\nInstead, we have to go to a slightly more complicated type of error model.\nDefinition 12. Consider a full circuit C and suppose with probability pS ,\nthere are faults at precisely the set S of locations, in which case the error at those\nlocations can be any quantum operation consistent with the causal structure of S\n(i.e., if location Ci is chronologically before Cj , the error must act on Ci before Cj ).\nLet pi < 1 be fixed for each location Ci . For any set R of locations of C, suppose\nthat the total probability of having faults\nQ on every location in R (and possibly\nadditional locations outside R) is at most i\u2208R pi . Then we have a local stochastic\nerror model.\nAs before, we usually consider the case where pi only depends on the type of\nlocation Ci , and often specialize to the case where pi = p for all i. In that case,\nthe probability of having errors on all of a specified set of r locations is at most pr .\nNote that for this condition, we do not care what happens to locations outside the\nset R - some may have errors, others may not. In addition, we make no constraint\non the type of error that occurs at any given location Ci with i \u2208 R. Often, we\nimagine that the type of error is chosen by an adversary who is determined to make\nour lives as difficult as possible. The adversary can choose errors that entangle\ndifferent faulty locations; she may even choose to turn off the errors at some subset\nof locations if that will cause more trouble than leaving them on. However, the\nadversary is restricted to choose a strategy that has the probability of error on any\ngiven set of locations decreasing exponentially with the size of the set; it is in this\nsense that the error model is \"local.\" There is another important restriction which\nis implicit in the above definition - we have assumed that the locations of the\nfaults are chosen randomly, which is why it is a \"stochastic\" error model. This is\nnot the most general possibility. We could have had a superposition of faults in\ndifferent sets of locations, perhaps entangled with some environment qubits with\npersistent memory. It is possible to generalize the threshold theorem (theorem 10)\nto that case, but the details are somewhat complicated [3].\nAn uncorrelated error model will automatically be a local stochastic error\nmodel, with the same pi . However, as noted above, if C \u2032 is subject to an uncorrelated error model, then it does not generally follow that C\u0303 will experience an\nuncorrelated error model as well. That is the advantage of generalizing to a local\nstochastic model: If C \u2032 is subject to a local stochastic error model, then C\u0303 will also\nexperience a local stochastic error model.\nTheorem 9 (Level Reduction). Suppose we have a fault-tolerant circuit C \u2032\nfor C, and suppose C \u2032 experiences a local stochastic error model with error bounds\npi and probability pS of errors at precisely the set S of locations. Then for any\nparticular set S define C\u0303S as in theorem 8, and define an error model on C by\nreplacing C with C\u0303S with probability pS . This is a local stochastic error model. The\nerror bounds p\u2032i for C are given by\nXY\n(84)\np\u2032i \u2264\npi .\nR i\u2208R\n\nThe sum over R is taken over sets R of locations which are included in the ExRec\nfor location Ci and with |R| = t + 1. (Recall that t is the number of errors the\n\n\fQUANTUM ERROR CORRECTION\n\n41\n\nQECC corrects.) In the special case where pi \u2264 p for all i, we have\n(85)\n\np\u2032i \u2264 Apt+1 ,\n\nwhere A is the maximum over types of ExRecs of the number of sets of exactly t + 1\nlocations in the ExRec.\nProof. By theorem 8, we know that the error model for C has a stochastic\nform, namely that for any set of locations S \u2032 , there is some probability p\u2032S \u2032 of having\nfaults at exactly the locations of S \u2032 . To calculate a bound on the probability of\nhaving errors at a set R of locations of C (and possibly elsewhere), we should add\nup the probabilities pS of every set S of locations of C \u2032 which leads to bad ExRecs\nfor locations Ci , i \u2208 R.\nFor a single ExRec (say for the location Ci ), we can upper bound the probability\nthat it is bad by summing over all sets S which contain a subset R of locations\nwhich are included in the ExRec and have |R| = t + 1. (Any set of locations with\n|R| > t + 1 includes as a subset a number of sets with |R| = t + 1, and is therefore\nalready included in this sum.) By the union bound and the definition of a local\nstochastic error model, we therefore know that the probability of a single ExRec\nbeing bad is at most p\u2032i , with p\u2032i given by (84).\nFor a set of ExRecs given by the locations Ci , i \u2208 R\u2032 , we sum over sets S\nwhich contain subsets of t + 1 locations in Q\nevery ExRec in the set. If the ExRecs\ndo not overlap, we get exactly the bound i\u2208R\u2032 p\u2032i in this way, considering S to\ncontain a collection of sets Ri , |Ri | = t + 1, Ri a subset of the ExRec for Ci . When\nthe ExRecs overlap, we have to be slightly more careful, since the earlier ExRec\nis truncated for those cases where the later ExRec is bad, but that just means\nwe\nQ\nsum over Ri which are contained in the truncated ExRec. To get back to i\u2208R\u2032 p\u2032i ,\nwe must add in extra sets of locations which include Ri intersecting the truncated\nEC step; this can only increase the bound, which is acceptable.\n\u0003\nIt is for this theorem that we needed to truncate extended rectangles. When\ntwo ExRecs are completely separate, then in order for both to be bad, we need\nt + 1 errors in each, and therefore the probability of having both be bad is at most\np2(t+1) = (p\u2032i )2 when pi \u2264 p. However, for two overlapping rectangles, if we do not\ntruncate, only t + 1 errors are needed for both to be bad if all the errors are in the\nshared EC step. Then the probability of both failing would be O(p\u2032i ), not O((p\u2032i )2 ).\nWith some additional computational effort, we can actually set a tighter bound\non p\u2032i . While we have defined an ExRec to be bad when it has t + 1 or more faulty\nlocations, there are some sets of t + 1 locations (or more) for which the ExRec\nremains correct. One can define a malignant set of locations R to be a set for\nwhich the ExRec is not correct for some set of errors at R. Then the sum in\nequation (84) can be taken just over the minimal malignant sets of errors.\nNote that, when pi = p, the error rate p\u2032i for C is less than the physical error\nrate p for C \u2032 if Apt < 1. In that case, we can apply the idea of concatenated coding\nto make the logical error rate arbitrarily small. The threshold theorem then follows\neasily from theorem 9:\nTheorem 10. There is a threshold error rate pT . Suppose we have a local\nstochastic error model with pi \u2264 p < pT . Then for any ideal circuit C, and any\n\u01eb > 0, there exists a fault-tolerant circuit C \u2032 which, when it undergoes the error\nmodel, produces an output which has statistical distance at most \u01eb from the output\n\n\f42\n\nDANIEL GOTTESMAN\n\nof C. C \u2032 has a number of qubits and a number of timesteps which are at most\npolylog(|C|/\u01eb) times bigger than the number of qubits and timesteps in C, where |C|\nis the number of locations in C.\nProof. As noted above, we use concatenated codes. We take an [[n, 1, 2t + 1]]\nQECC and create a sequence of circuits C (k) , k = 1, . . . , L, where each C (k) is a\nfault-tolerant simulation of C (k\u22121) , with C (0) = C. C \u2032 = C (L) undergoes a local\nstochastic error model, and by theorem 9, so does C (k) for all k < L. The local\n(L\u2212k)\n\u2264 p(L\u2212k) , with p(0) = p and\nstochastic error model for C (k) has error bound pi\n\u0010\n\u0011t+1\n\u0010\n\u0011t\n(86)\np(j) \u2264 A p(j\u22121)\n= p(j\u22121) p(j\u22121) /pT ,\n2\n\nwith pT = 1/A1/t . It follows that p(1) /pT \u2264 (p/pT )t+1 , p(2) /pT \u2264 (p/pT )(t+1) , and\n(87)\n\nj\n\np(j) /pT \u2264 (p/pT )(t+1) .\n\nThe logical error rate after L levels of encoding thus decreases with L as a double\nexponential when p < pT .\nIf we wish to achieve a final error rate of \u01eb1 per location in C, we therefore need\nto choose\n\u0007\n\u0006\n(88)\nL = logt+1 [log(\u01eb1 /pT )/ log(p/pT )] .\n\nThat is, for this choice of L, we find that C undergoes a local stochastic error model\nwith error bound pi \u2264 \u01eb1 ; this gives an upper bound on the probability of having\na fault on location i. It therefore follows that the probability of having an error\nin some location of C is at most \u01eb = |C|\u01eb1 . With probability 1 \u2212 \u01eb there are no\nfaults in the simulated circuit C, and therefore the overall statistical difference of\nthe output is at most \u01eb from the correct output distribution.\nThe size of C \u2032 is given by L. The total number of qubits, including ancillas,\ninvolved in a fault-tolerant gadget is at most some constant G, as is the total\nnumber of time steps. Thus, the number of qubits and time steps involved in C (k)\nis at most G times the number of qubits and time steps involved in C (k\u22121) , and\nin particular, the number of qubits/time steps in C (L) is at most GL times the\nnumber of qubits/time steps in C. Choosing L as in equation (88), we find\n(89)\n\nGL \u2264 G [log(\u01eb1 /pT )/ log(p/pT )]\n\nlog G/ log(t+1)\n\n.\n\u0003\n\nTo be more explicit, we can choose a particular [[n, 1, 2t + 1]] QECC and faulttolerant protocol, and for that protocol determine A in equation (85). Then the\nthreshold for that protocol is at least pT = 1/A1/t . By choosing a different code\nor protocol, or a different method of analysis, we might get a higher threshold,\nand the true threshold pT is the supremum over all possible choices. If we use\nthe 7-qubit code and are careful counting malignant sets of errors, we find pT \u2265\n2.73 \u00d7 10\u22125 [3, 41]. People have studied a variety of different codes and faulttolerant protocols [11]. So far the best claimed thresholds have come in simulations\nby Knill [30], who has used elaborate ancilla preparation techniques to achieve a\nthreshold pT of as high as 5%, depending on the details of the error model. The\ncurrent best rigorous lower bound on the threshold, using those same techniques,\ngives a threshold of 10\u22123 [4, 42].\n\n\fQUANTUM ERROR CORRECTION\n\n43\n\nThe threshold theorem can be improved in various ways. A similar theorem\ncan be proven using more general noise produced by a weak interaction between\nthe computer and a non-Markovian environment [3, 52]. This includes systematic\nerrors - for instance, if every time we perform a R\u03b8 phase rotation, we overrotate by a consistent small angle. The gadgets presented in this paper assume\nwe can perform gates between arbitrary pairs of qubits, but it is also possible\nto devise gadgets which only involve nearest-neighbor interactions in one or two\ndimensions [1, 23, 38, 50, 51]. Most quantum gates have a tendency to mix\ndifferent types of Pauli errors, but if you are careful, it is possible to design faulttolerant protocols which can take advantage of a large asymmetry between X and\nZ errors [5]. When you attempt to optimize the threshold, it is generally at a large\nconstant factor cost in overhead. There has been some study of the tradeoff between\noverhead and threshold value [6, 11, 49], but much more could be done in that\ndirection. Recent work indicates that thresholds can be improved by not treating\neach level of concatenation separately, but by allowing the EC gadgets to use error\ninformation generated by the lower-level error correction procedures [6, 19, 37].\nNaturally, there are some assumptions inherent in theorem 10 that cannot be\nremoved. As long as the physical wait location has non-zero errors, we cannot let\nany qubit wait around a long time without being corrected. That means that we\nmust be able to perform operations in parallel; otherwise as the computer gets\nlarge, we could only correct errors on a vanishingly small fraction of the qubits\nat any given time. It also means we must be able to prepare qubits during the\ncomputation [2]. This is because we need to use ancilla qubits for error correction,\nand if the ancilla qubits were prepared only at the beginning of the computation,\nthey would have accumulated a large error rate by the time they are used in an\nEC gadget. We must also assume the errors do not remove qubits from our computer irrevocably; either an error takes us to a valid physical computational state\n(albeit an incorrect one) or at least takes us to a state which can be restored by\nan appropriate action to some valid computational state. Finally, we need some\nsort of bound on the correlations present in the error model. The local stochastic\nmodel allows very strong correlations in the errors, but at least assumes that the\nprobability of having an error on a particular large set of qubits decreases exponentially. This is roughly what we need in general; the non-Markovian model replaces\nthis assumption with the assumption, roughly speaking, that the amplitude of a\nmany-qubit error decreases exponentially. If instead we had merely a polynomial\ndecay in the amplitude of many-qubit errors, there would be a polynomially-small\nchance that every qubit in the computer would fail simultaneously, and there is no\nway we could recover from such a big failure.\nReferences\n[1] D. Aharonov and M. Ben-Or, Fault-tolerant quantum computation with constant error, Proc.\n29th Ann. ACM Symp. on Theory of Computation (ACM, New York, 1998), 176\u2013188;\narXiv:quant-ph/9611025; D. Aharonov and M. Ben-Or, Fault-tolerant quantum computation\nwith constant error rate, SIAM J. Comput. 38 (2008), 1207\u20131282; arXiv:quant-ph/9906129.\n[2] D. Aharonov, M. Ben-Or, R. Impagliazzo, N. Nisan, Limitations of Noisy Reversible Computation, arXiv:quant-ph/9611028 (1996).\n[3] P. Aliferis, D. Gottesman, and J. Preskill, Quantum accuracy threshold for concatenated\ndistance-3 codes, Quant. Info. Comp. 6 (2006), 97\u2013165; arXiv:quant-ph/0504218.\n, Accuracy threshold for postselected quantum computation, Quant. Info. Comp. 8\n[4]\n(2008), 181\u2013244; arXiv:quant-ph/0703264.\n\n\f44\n\nDANIEL GOTTESMAN\n\n[5] P. Aliferis and J. Preskill, Fault-tolerant quantum computation against biased noise, Phys.\nRev. A 78 (2008), 052331; arXiv:0710.1301 [quant-ph].\n, The Fibonacci scheme for fault-tolerant quantum computation, Phys. Rev. A 79\n[6]\n(2009), 012332; arXiv:0809.5063 [quant-ph].\n[7] A. Ashikhmin, E. Knill, Nonbinary Quantum Stabilizer Codes, IEEE Trans. Info. Theory 47\n(2001), 3065\u20133072; arXiv:quant-ph/0005008.\n[8] C. Bennett, D. DiVincenzo, J. Smolin, and W. Wootters, Mixed state entanglement and\nquantum error correction, Phys. Rev. A 54 (1996), 3824\u20133851; arXiv:quant-ph/9604024.\n[9] P. O. Boykin, T. Mor, M. Pulver, V. Roychowdhury, and F. Vatan, On Universal and FaultTolerant Quantum Computing, Proc. 40th Ann. Symp. on Found. of Comp. Sci. (IEEE, New\nYork, 1999), 486\u2013494; arXiv:quant-ph/9906054.\n[10] S. Bravyi, A. Kitaev, Universal Quantum Computation with ideal Clifford gates and noisy\nancillas, Phys. Rev. A 71 (2005), 022316; arXiv:quant-ph/0403025.\n[11] A. W. Cross, D. P. DiVincenzo, B. M. Terhal, A comparative code study for quantum faulttolerance, arXiv:0711.1556 [quant-ph] (2007).\n[12] A. R. Calderbank, E. M. Rains, P. W. Shor, and N. J. A. Sloane, Quantum error correction\nand orthogonal geometry, Phys. Rev. Lett. 78 (1997), 405\u2013408; arXiv:quant-ph/9605005.\n, Quantum error correction via codes over GF(4), IEEE Trans. Inform. Theory 44\n[13]\n(1998), 1369\u20131387; arXiv:quant-ph/9605005.\n[14] A. R. Calderbank and P. W. Shor, Good quantum error-correcting codes exist, Phys. Rev. A\n54 (1996), 1098\u20131105; arXiv:quant-ph/9512032.\n[15] A. Cross, G. Smith, J. A. Smolin, B. Zeng, Codeword Stabilized Quantum Codes, IEEE Trans.\nInfo. Theory 55 (2009), 433\u2013438; arXiv:0708.1021 [quant-ph].\n[16] E. Dennis, A. Kitaev, A. Landahl, J. Preskill, Topological quantum memory, J. Math. Phys.\n43 (2002), 4452\u20134505; arXiv:quant-ph/0110143.\n[17] D. Dieks, Communication by EPR devices, Phys. Lett. A 92 (1982), 271\u2013272.\n[18] B. Eastin, E. Knill, Restrictions on Transversal Encoded Quantum Gate Sets, arXiv:\n0811.4262 [quant-ph] (2008).\n[19] Z. W. E. Evans, A. M. Stephens, Optimal decoding in fault-tolerant concatenated quantum\nerror correction, arXiv:0902.4506v1 [quant-ph] (2009).\n[20] D. Gottesman, Class of quantum error-correcting codes saturating the quantum Hamming\nbound, Phys. Rev. A 54 (1996), 1862\u20131868; arXiv:quant-ph/9604038.\n, Theory of fault-tolerant quantum computation, Phys. Rev. A 57 (1998), 127\u2013137;\n[21]\narXiv:quant-ph/9702029.\n, The Heisenberg Representation of Quantum Computers, in Group22: Proceedings of\n[22]\nthe XXII International Colloquium on Group Theoretical Methods in Physics (International\nPress, Cambridge, MA, 1999), eds. S. P. Corney, R. Delbourgo, and P. D. Jarvis, 32\u201343;\narXiv:quant-ph/9807006.\n[23]\n, Fault-Tolerant Quantum Computation with Local Gates, J. Modern Optics 47 (2000),\n333\u2013345; arXiv:quant-ph/9903099.\n[24]\n, An Introduction to Quantum Error Correction, in Quantum Computation: A\nGrand Mathematical Challenge for the Twenty-First Century and the Millennium, ed.\nS. J. Lomonaco, Jr. (American Mathematical Society, Providence, Rhode Island, 2002), 221\u2013\n235; arXiv:quant-ph/0004072.\n[25] M. Grassl, T. Beth, and T. Pellizzari, Codes for the quantum erasure channel, Phys. Rev. A\n56 (1997), 33\u201338; arXiv:quant-ph/9610042.\n[26] A. Ketkar, A. Klappenecker, S. Kumar, P. K. Sarvepalli, Nonbinary stabilizer codes over\nfinite fields, IEEE Trans. Info. Theory 52 (2006), 4892\u20134914; arXiv:quant-ph/0508070.\n[27] A. Y. Kitaev, A. H. Shen, and M. N. Vyalyi, Classical and Quantum Computation (AMS,\nProvidence, RI, 2002).\n[28] A. Y. Kitaev, Quantum error correction with imperfect gates, Quantum Communication,\nComputing, and Measurement (Proc. 3rd Int. Conf. of Quantum Communication and Measurement) (Plenum Press, New York, 1997), p. 181\u2013188.\n[29] E. Knill, Non-binary Unitary Error Bases and Quantum Codes, arXiv:quant-ph/9608048\n(1996).\n, Quantum Computing with Realistically Noisy Devices, Nature 434 (2005),\n[30]\n39\u201344; E. Knill, Fault-tolerant Postselected Quantum Computation: Schemes, arXiv:\nquant-ph/0402171.\n\n\fQUANTUM ERROR CORRECTION\n\n45\n\n[31] E. Knill and R. Laflamme, A theory of quantum error-correcting codes, Phys. Rev. A 55\n(1997), 900\u2013911; arXiv:quant-ph/9604034.\n[32] E. Knill, R. Laflamme, and W. H. Zurek, Threshold accuracy for quantum computation,\narXiv:quant-ph/9610011; E. Knill, R. Laflamme, and W. H. Zurek, Resilient quantum computation, Science 279 (1998), 342\u2013345; E. Knill, R. Laflamme, and W. H. Zurek, Resilient\nquantum computation: error models and thresholds, Proc. Royal Soc. London A 454 (1998),\n365\u2013384, arXiv:quant-ph/9702058.\n[33] D. W. Kribs, R. Laflamme, D. Poulin, M. Lesosky, Operator quantum error correction, Quant.\nInf. Comp. 6 (2006), 383\u2013399; arXiv:quant-ph/0504189.\n[34] R. Laflamme, C. Miquel, J. P. Paz, and W. Zurek, Perfect quantum error correction code,\nPhys. Rev. Lett. 77 (1996), 198\u2013201; arXiv:quant-ph/9602019.\n[35] D. A. Lidar and K. B. Whaley, Decoherence-Free Subspaces and Subsystems, in Irreversible\nQuantum Dynamics (Springer Lecture Notes in Physics 622, Berlin, 2003), eds. F. Benatti\nand R. Floreanini, 83\u2013120; arXiv:quant-ph/0301032.\n[36] D. Poulin, Stabilizer Formalism for Operator Quantum Error Correction, Phys. Rev. Lett.\n95 (2005), 230504; arXiv:quant-ph/0508131.\n, Optimal and Efficient Decoding of Concatenated Quantum Block Codes, Phys. Rev.\n[37]\nA 74 (2006), 052333; arXiv:quant-ph/0606126.\n[38] R. Raussendorf, J. Harrington, Fault-tolerant quantum computation with high threshold in two dimensions, Phys. Rev. Lett. 98 (2007), 190504; arXiv:quant-ph/0610082;\nR. Raussendorf, J. Harrington, K. Goyal, Topological fault-tolerance in cluster state quantum\ncomputation, New J. Phys. 9 (2007), 199; arXiv: quant-ph/0703143.\n[39] B. W. Reichardt, Improved ancilla preparation scheme increases fault-tolerant threshold,\narXiv:quant-ph/0406025.\n, Improved magic states distillation for quantum universality, Quant. Inf. Proc. 4\n[40]\n(2005), 251\u2013264; arXiv:quant-ph/0411036.\n[41]\n, Fault-tolerance threshold for a distance-three quantum code, arXiv:quant-ph/0509203\n(2005).\n[42]\n, Error-Detection-Based Quantum Fault Tolerance Against Discrete Pauli Noise,\nBerkeley Ph.D. thesis (1996); arXiv:quant-ph/0612004.\n[43] P. W. Shor, Scheme for reducing decoherence in quantum memory, Phys. Rev. A 52 (1995),\n2493\u20132496.\n[44]\n, Fault-tolerant quantum computation, Proc. 35th Ann. Symp. on Foundations of\nComputer Science (IEEE Press, Los Alamitos, 1996), pp. 56\u201365; arXiv:quant-ph/9605011.\n[45] R. Solovay, unpublished.\n[46] A. M. Steane, Error correcting codes in quantum theory, Phys. Rev. Lett. 77 (1996), 793\u2013797.\n, Multiple particle interference and quantum error correction, Proc. Roy. Soc. London\n[47]\nA 452 (1996), 2551\u20132577; arXiv:quant-ph/9601029.\n[48]\n, Active stabilization, quantum computation, and quantum state synthesis, Phys. Rev.\nLett. 78 (1997), 2252; arXiv:quan-ph/9611027.\n[49]\n, Overhead and noise threshold of fault-tolerant quantum error correction, Phys. Rev.\nA 68 (2003), 042322 [19 pages]; arXiv:quant-ph/0207119.\n[50] A. M. Stephens, A. G. Fowler, L. C. L. Hollenberg, Universal fault tolerant quantum computation on bilinear nearest neighbor arrays, Quant. Info. Comp. 8 (2008), 330;\narXiv:quant-ph/0702201.\n[51] K. M. Svore, D. P. DiVincenzo, B. M. Terhal, Noise Threshold for a FaultTolerant Two-Dimensional Lattice Architecture, Quant. Inf. Comp. 7 (2007), 297\u2013318;\narXiv:quant-ph/0604090.\n[52] B. M. Terhal and G. Burkard, Fault-tolerant quantum computation for local non-Markovian\nnoise, Phys. Rev. A 71 (2005), 012336; arXiv:quant-ph/0402104.\n[53] L. Viola, E. Knill, S. Lloyd, Dynamical Decoupling of Open Quantum Systems, Phys. Rev.\nLett. 82 (1999), 2417\u20132421; arXiv:quant-ph/9809071.\n[54] W. K. Wooters and W. H. Zurek, A single quantum cannot be cloned, Nature 299 (1982),\n802\u2013803.\n[55] X. Zhou, D. W. Leung, I. L. Chuang, Methodology for quantum logic gate constructions,\nPhys. Rev. A 62 (2000), 052316; arXiv:quant-ph/0002039.\n\n\f46\n\nDANIEL GOTTESMAN\n\nPerimeter Institute for Theoretical Physics, Waterloo, ON N2L 2Y5, Canada\nE-mail address: dgottesman@perimeterinstitute.ca\nURL: http://www.perimeterinstitute.ca/personal/dgottesman/\n\n\f"}