{"id": "http://arxiv.org/abs/1004.2526v1", "guidislink": true, "updated": "2010-04-15T00:12:47Z", "updated_parsed": [2010, 4, 15, 0, 12, 47, 3, 105, 0], "published": "2010-04-15T00:12:47Z", "published_parsed": [2010, 4, 15, 0, 12, 47, 3, 105, 0], "title": "Local versus Global Search in Channel Graphs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1004.5468%2C1004.1636%2C1004.1868%2C1004.4568%2C1004.4406%2C1004.5295%2C1004.5196%2C1004.1251%2C1004.1994%2C1004.4322%2C1004.3694%2C1004.1494%2C1004.3779%2C1004.0700%2C1004.2045%2C1004.5039%2C1004.3915%2C1004.3582%2C1004.3064%2C1004.5328%2C1004.2272%2C1004.2218%2C1004.3759%2C1004.5162%2C1004.0404%2C1004.5066%2C1004.5074%2C1004.3398%2C1004.2998%2C1004.3155%2C1004.2445%2C1004.3743%2C1004.3148%2C1004.3154%2C1004.3161%2C1004.2274%2C1004.2443%2C1004.5441%2C1004.1431%2C1004.3685%2C1004.2760%2C1004.0142%2C1004.4349%2C1004.1406%2C1004.1003%2C1004.3027%2C1004.3131%2C1004.3443%2C1004.0276%2C1004.3574%2C1004.1330%2C1004.0639%2C1004.0643%2C1004.1632%2C1004.4489%2C1004.0844%2C1004.4654%2C1004.1939%2C1004.4770%2C1004.3349%2C1004.5553%2C1004.1574%2C1004.2793%2C1004.0502%2C1004.3160%2C1004.3605%2C1004.5413%2C1004.4552%2C1004.3856%2C1004.2646%2C1004.4096%2C1004.1064%2C1004.3158%2C1004.2557%2C1004.0917%2C1004.2476%2C1004.5386%2C1004.0706%2C1004.3279%2C1004.1656%2C1004.4410%2C1004.2947%2C1004.3503%2C1004.4282%2C1004.5371%2C1004.2540%2C1004.2713%2C1004.2956%2C1004.2526%2C1004.1235%2C1004.0318%2C1004.4824%2C1004.5141%2C1004.0395%2C1004.4036%2C1004.3353%2C1004.0016%2C1004.0356%2C1004.1276%2C1004.3126%2C1004.0984&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Local versus Global Search in Channel Graphs"}, "summary": "Previous studies of search in channel graphs has assumed that the search is\nglobal; that is, that the status of any link can be probed by the search\nalgorithm at any time. We consider for the first time local search, for which\nonly links to which an idle path from the source has already been established\nmay be probed. We show that some well known channel graphs may require\nexponentially more probes, on the average, when search must be local than when\nit may be global.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1004.5468%2C1004.1636%2C1004.1868%2C1004.4568%2C1004.4406%2C1004.5295%2C1004.5196%2C1004.1251%2C1004.1994%2C1004.4322%2C1004.3694%2C1004.1494%2C1004.3779%2C1004.0700%2C1004.2045%2C1004.5039%2C1004.3915%2C1004.3582%2C1004.3064%2C1004.5328%2C1004.2272%2C1004.2218%2C1004.3759%2C1004.5162%2C1004.0404%2C1004.5066%2C1004.5074%2C1004.3398%2C1004.2998%2C1004.3155%2C1004.2445%2C1004.3743%2C1004.3148%2C1004.3154%2C1004.3161%2C1004.2274%2C1004.2443%2C1004.5441%2C1004.1431%2C1004.3685%2C1004.2760%2C1004.0142%2C1004.4349%2C1004.1406%2C1004.1003%2C1004.3027%2C1004.3131%2C1004.3443%2C1004.0276%2C1004.3574%2C1004.1330%2C1004.0639%2C1004.0643%2C1004.1632%2C1004.4489%2C1004.0844%2C1004.4654%2C1004.1939%2C1004.4770%2C1004.3349%2C1004.5553%2C1004.1574%2C1004.2793%2C1004.0502%2C1004.3160%2C1004.3605%2C1004.5413%2C1004.4552%2C1004.3856%2C1004.2646%2C1004.4096%2C1004.1064%2C1004.3158%2C1004.2557%2C1004.0917%2C1004.2476%2C1004.5386%2C1004.0706%2C1004.3279%2C1004.1656%2C1004.4410%2C1004.2947%2C1004.3503%2C1004.4282%2C1004.5371%2C1004.2540%2C1004.2713%2C1004.2956%2C1004.2526%2C1004.1235%2C1004.0318%2C1004.4824%2C1004.5141%2C1004.0395%2C1004.4036%2C1004.3353%2C1004.0016%2C1004.0356%2C1004.1276%2C1004.3126%2C1004.0984&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Previous studies of search in channel graphs has assumed that the search is\nglobal; that is, that the status of any link can be probed by the search\nalgorithm at any time. We consider for the first time local search, for which\nonly links to which an idle path from the source has already been established\nmay be probed. We show that some well known channel graphs may require\nexponentially more probes, on the average, when search must be local than when\nit may be global."}, "authors": ["A. H. Hunter", "Nicholas Pippenger"], "author_detail": {"name": "Nicholas Pippenger"}, "author": "Nicholas Pippenger", "arxiv_comment": "i+13 pages, 2 figures", "links": [{"href": "http://arxiv.org/abs/1004.2526v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1004.2526v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "math.PR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1004.2526v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1004.2526v1", "journal_reference": null, "doi": null, "fulltext": "path.search.apr.mod.tex\n\narXiv:1004.2526v1 [cs.CC] 15 Apr 2010\n\nLocal versus Global Search in Channel Graphs\n\nA. H. Hunter\nahh@cs.washington.edu\nDepartment of Computer Science & Engineering\nUniversity of Washington\nAC101 Paul G. Allen Center, Box 352350\n185 Stevens Way\nSeattle, WA 98195-2350\n\nNicholas Pippenger\nnjp@math.hmc.edu\nDepartment of Mathematics\nHarvey Mudd College\n1250 Dartmouth Avenue\nClaremont, CA 91711\n\nAbstract: Previous studies of search in channel graphs has assumed that the search is global; that is, that\nthe status of any link can be probed by the search algorithm at any time. We consider for the first time\nlocal search, for which only links to which an idle path from the source has already been established may\nbe probed. We show that some well known channel graphs may require exponentially more probes, on the\naverage, when search must be local than when it may be global.\n\nKeywords: Circuit switching, path search, search algorithms, decision trees.\n\n\f1. Introduction\nA channel graph is an acyclic directed graph G = (V, E), with vertices V and edges E, in which there\nexist a source vertex s \u2208 V and a target vertex t \u2208 V such that every vertex lies on a directed path from s\n\nto t. (Such a source and target, if they exist, are clearly unique.) The vertices other than the source and\ntarget are called links.\n\nA state of a channel graph is an assignment of a status (busy or idle) to each link of the graph. We shall\nextend such an assignment to all vertices by agreeing that the source and target are always idle. We shall\ndeal in this paper with a particular probability distribution on the states of a channel graph. We choose a\nreal number q, in the range 0 \u2264 q \u2264 1, which we call the vacancy probability; its complement p = 1 \u2212 q is\n\ncalled the occupancy probability. We then define a random state of a channel graph to be one in which each\nlink is independently idle with probability q (and thus busy with probability p). This probability distribution\n\non states was introduced independently by Lee [L1] and Le Gall [L2, L3].\nWe shall say that a channel graph is linked in a given state if there exists a directed path from the source\nto the target consisting entirely of idle links. We shall say that a channel graph is blocked in a given state\nif there exists a cut between the source and the target consisting entirely of busy links. (Clearly, a channel\ngraph in a given state is either linked or blocked, but not both.) If a channel graph G is in a random state\nwith vacancy probability q, the linking probability will be denoted Q(G, q), and the complementary blocking\nprobability will be denoted P (G, q) = 1 \u2212 Q(G, q).\nConsider now a search algorithm that seeks to determine whether a known channel graph, in an unknown\nrandom state with a known vacancy probability, is linked or blocked. The algorithm gathers information\nabout the state of the graph by sequentially probing the status of links until all the links of either an idle\npath or a busy cut have been probed. (The algorithm may be adaptive, so that the decision as to which link\nto probe at a given step may depend on the outcomes of all previous probes.)\nSuch an algorithm may be modeled as a decision tree. The elements of such a tree will be called nodes\nand arcs (to distinguish them from the vertices and edges of the channel graph). Each node is either a probe\nnode, in which case it is labeled with the name of a link in the channel graph and has two outgoing arcs (one\nlabeled \"idle\" and one labeled \"busy\") leading to other nodes, or a leaf, in which case it is labeled with one of\nthe two possible outcomes (\"linked\" or \"blocked\") and has no outgoing arcs. There is a distinguished probe\nnode, called the root, that has no incoming arcs; every other node has exactly one incoming arc. Execution of\nthe algorithm begins at the root and proceeds in an obvious way, probing links and following the appropriate\narcs, until it arrives at a leaf that announces the final result. There is an obvious notion of such an algorithm\nbeing correct: every trajectory from the root to a leaf labeled \"linked\" probes every link on a path from\nthe source to the target in the channel graph and departs each of these probe nodes along the \"idle\" arc,\nand every trajectory from the root to a leaf labeled \"blocked\" probes every link on a cut between the source\nand the target in the channel graph and departs each of these probe nodes along the \"busy\" arc. This\nmodel of a search algorithm was introduced by Lin and Pippenger [L4], and subsequently used by Pippenger\n[P]. We shall denote by E(G, q) the minimum possible expected number of probes performed by any search\nalgorithm that correctly searches the channel graph G with vacancy probability q. This formulation of the\nsearch problem considers algorithms to be deterministic, with only the state of the network being random. It\nis clear, however, that a formulation allowing randomized algorithms would yield the same function E(G, q):\nfor a randomized algorithm may be regarded as a convex combination of deterministic algorithms (that is,\nas a probability distribution on decision trees, obtained by making all random choices at the outset), and at\n1\n\n\fleast one of these algorithms must use make an expected number of probes that is at most as large as that\nof the convex combination.\nIn the definition of \"search algorithm\" given above, any node in the decision tree may probe any link\nin the channel graph, regardless of previous probes and their outcomes. We shall call this situation global\nsearch. This model is appropriate for circumstances in which all parts of the network being searched are\ndirectly accessible by the computer performing the search. It will be unrealistic, however, if the probes\nthemselves require communication over the network being searched. An alternative appropriate to the latter\ncircumstances is to allow a link to be probed only if it is accessible, meaning that all the links on some path\nfrom the source to that link have previously been probed and found to be idle. This situation will be called\nlocal search.\nWe shall denote by E1 (G, q) the minimum possible expected number of probes performed by any local\nsearch algorithm that correctly searches the channel graph G with vacancy probability q. We clearly have\nE(G, q) \u2264 E1 (G, q), and the main question explored in this paper is: how much larger than E(G, q) can\n\nE1 (G, q) be? We shall see that the answer is: for some channel graphs G, and some values of the vacancy q,\nit can be exponentially larger. Preliminary versions of the results in this paper appeared in the first author's\nthesis [H2].\nThe graphs we shall study are called fully parallel graphs. Let Tk be a complete binary tree of depth k,\nwith root r and 2k leaves, and with all edges directed from the root towards the leaves. Let Tk\u2032 be a similar\ntree of depth k, with root r\u2032 and 2k leaves, and with all edges directed from the leaves towards the root. The\nfully parallel channel graph Fk is obtained by joining each leaf of Tk to the corresponding leaf of Tk\u2032 by an\nedge directed from the former to the latter. The source of Fk is s = r and the target is t = r\u2032 . The vertices\nof Fk will be partitioned into ranks: the vertices at depth j (0 \u2264 j \u2264 k) of Tk will constitute rank j; the\nvertices at depth j (0 \u2264 j \u2264 k) of Tk\u2032 will constitute rank 2k + 1 \u2212 j. Thus the source constitutes rank 0,\nand the target constitutes rank 2k + 1. An example is shown in Figure 1.\nt\n\n4\n\n4\n\n3\n\n3\n\n3\n\n3\n\n2\n\n2\n\n2\n\n2\n\n1\n\n1\n\ns\nFigure 1. The channel graph F2 . Links are annotated with their ranks.\nOur results in this paper will show that global search of Fk can be performed with an expected number\nof probes linear in k for any fixed q. We shall show, however, that local search of Fk requires an expected\nnumber of probes exponential in k for 1/2 < q < 1, and we shall determine the precise rate of exponential\ngrowth for q in this range.\n\n2\n\n\fSpecifically, we shall present in Section 2 an algorithm bilat-search that performs global search in\nFk using an expected number of probes at most 4k for any fixed k and for all sufficiently large k. (For\n0 \u2264 q < 1/2, the expected number of probes is in fact bounded as k \u2192 \u221e, but the bound depends on q.\n\nBecause we are primarily interested in the contrast between linear and exponential growth as a function of\nk, we shall in what follows frequently replace constants that depend on q with factors of k or 1/k. This\nreplacement will weaken our results slightly, but simplify them greatly, without affecting the contrast between\nlinear and exponential growth, or between different rates of exponential growth.) We shall also present an\nalgorithm unilat-search that performs local search in Fk using an expected number of probes at most\n4k max{1, min{(2q)k , 1/q k }} for any fixed q and for all sufficiently large k. The expected number of probes\n\nfor this algorithm thus grows linearly for 0 \u2264 q \u2264 1/2 and for q = 1, but grows exponentially in k for\n\u221a\n\u221a\n1/2 < q < 1, with a base that increases as 2q from 1 to 2 as q increases from 1/2 to 1/ 2, then decreases\n\u221a\n\u221a\nas 1/q from 2 to 1 as q increases from 1/ 2 to 1. In Section 3, we shall present lower bounds that show\nthat this rate of exponential growth is the best possible. Specifically, we shall show that any algorithm\n\u221a\nperforming local search in Fk must use an expected number of probes at least 1/kq k for 1/ 2 and for all\n\u221a\nsufficiently large k, and at least (2q)k /k 6 for 1/2 < q < 1/ 2 and for all sufficiently large k. (The factors\n1/k and 1/k 6 are consequences of our desire to keep our proofs as simple as possible. We in fact conjecture\nthat the algorithm unilat-search optimal not just in its rate of exponential growth, but in the stronger\nsense of using an expected number of probes exactly E1 (Fk , q).)\n\n2. Upper Bounds\nIn this section we shall obtain upper bounds to E(Fk , q) and E1 (G, q) by presenting and analyzing\nnatural path search algorithms. The upper bound for the global case is actually a special case of a result by\nLin and Pippenger [L4], but we shall give a simpler proof that can be adapted to the local case.\nThe results in this section and the next depend on results that are well known in the theory of branching\nprocesses (see Harris [H1]). A branching process is a random process that begins with one individual in\ngeneration zero, and in which each individual independently contributes an identically distributed random\nnumber of offspring to the next generation. Let Zl denote the number of individuals in the l-th generation. If\nf (x) is the generating function for the number of offspring contributed by an individual, then the generating\nfunction for Zl is the l-th iterate f (l) (x) of f (x), defined by f (0) (x) = x and f (l+1) (x) = f (f (l) (x)) =\nf (l) (f (x)).\nIn this section we shall be concerned with the branching process for which the generating function for\nthe number of offspring of an individual is f (x) = (1 \u2212 q 2 + q 2 x)2 , describing the number of successes in\n\ntwo independent trials that each succeed with probability q 2 . This branching process governs the blocking\nprobability P (Fk , q) in the following way. Any path from the source to the target in Fk that passes through\na link v in Tk also passes through the link v \u2032 in Tk\u2032 , and conversely. Consider the tree Tk\u2217 obtained from\nFk by identifying each vertex of Tk with the corresponding vertex of Tk\u2032 . The source and target of Fk are\nidentified to form the root of Tk\u2217 , which we take to be idle. Let every other vertex of Tk\u2217 be idle if and only if\nthe corresponding links in Tk and Tk\u2032 are both idle (which occurs with probability q 2 ) and busy if and only\nif either of the corresponding links in Tk and Tk\u2032 are busy (which occurs with probability 1 \u2212 q 2 ). Then it is\nclear that P (Fk , q) is equal to the probability that every path from the root to a leaf in Tk\u2217 contains at least\n\n3\n\n\fone busy vertex. This probability is just the probability that Zk = 0, which is the constant term f (k) (0) in\nf (k) (x). Thus we have the recurrence\nP (Fk , q) = f (P (Fk\u22121 , q))\n\n(2.1)\n\nfor k \u2265 1, with the initial condition P (F0 , q) = 0. We have P (Fk , q) \u2265 P (Fk\u22121 ) for k \u2265 1, since Zk\u22121 = 0\n\nimplies Zk = 0. Thus the sequence P (Fk , q) is non-decreasing in k. Since it is also bounded above by 1,\nit tends to a limit, which we shall denote P \u2217 , and we have P (Fk , q) \u2264 P \u2217 for all k \u2265 0. Letting k tend to\ninfinity in (2.1), and noting that f (x) is continuous, we see that P \u2217 must be a fixed-point of f (x), specifically\nthe smallest fixed-point greater than or equal to 0. Solving the quadratic equation f (P \u2217 ) = P \u2217 , we find that\n\u221a\n\u221a\nP \u2217 is equal to 1 for 0 \u2264 q \u2264 1/ 2, and equal to (1 \u2212 q 2 )2 /q 4 for 1/ 2 \u2264 q \u2264 1. Thus we have proved the\n\nfollowing lemma.\n\nLemma 2.1: For any 0 \u2264 q \u2264 1 and k \u2265 0, we have\n\uf8f1\n\u221a\n\uf8f2 1,\nif 0 \u2264 q \u2264 1/ 2;\nP (Fk , q) \u2264\n\u221a\n\uf8f3\n(1 \u2212 q 2 )2 /q 4 , if 1/ 2 \u2264 q \u2264 1.\n\u221a\n(Note that the two cases agree for q = 1/ 2.)\nOur upper bound for global path search in Fk is based on the following recursive algorithm. It should\nbe clear how, for a given value of k \u2265 0, it may be transformed into a decision tree of the form described\nin the introduction. The algorithm has been written to return true if its argument is linked and false if\nit is blocked. It would be straightforward to add data structures that would allow it to return an idle path\nor busy cut as appropriate. Since our main interest is in the cost of the search, however, we have only kept\ntrack of enough information to determine the sequence, and thus the number, of probes performed by the\nalgorithm.\nbilat-search(Fk :\n\nG):\n\nif k = 0:\nreturn true\nlet Fk\u22121 :\n\nG', G'' be the two copies of Fk\u22121 in G;\n\nif idle(source(G')) and idle(target(G')) and bilat-search(G'):\nreturn true\nif idle(source(G'')) and idle(target(G'')) and bilat-search(G''):\nreturn true\nreturn false\nWe assume short-circuiting conjunctions; that is, if f() evaluates to false, f() and g() is false and g() is\nnot evaluated.\nFrom the algorithm we can easily write a recurrence for the expected number of probes it performs,\nwhich leads to the following recurrence for E(Fk , q). We have\nE(Fk , q) \u2264 1 + q + q 2 E(Fk\u22121 , q) + (p + qp + q 2 P (Fk\u22121 , q))(1 + q + q 2 E(Fk\u22121 , q))\n= (1 + p + qp + q 2 P (Fk\u22121 , q))(1 + q + q 2 E(Fk\u22121 , q))\n4\n\n(2.2)\n\n\ffor k \u2265 1, with the initial condition E(F0 , q) = 0. In the right-hand side of the first line, the initial terms\n\n1 + q + q 2 E(Fk\u22121 , q) represents the expected cost of searching the first copy of Fk\u22121 , the first expression in\nparentheses represents the probability that no path through the first copy is found, so that the second copy\nmust be searched, and the second expression in parentheses (which is equal to the initial terms) represents\nthe expected cost of searching the second copy. In the second line, we have factored out the expected cost\nof searching a copy, so the first expression in parentheses now represents the expected number of copies that\nmust be searched. Using the bound from Lemma 2.1, we obtain\n1 + p + qp + q 2 P (Fk\u22121 , q) \u2264 1 + p + qp + q 2 P \u2217\n\n=\n\n\uf8f1\n\uf8f2 2,\n\uf8f3\n\n\u221a\nif 0 \u2264 q \u2264 1/ 2;\n\n\u221a\n1/q 2 , if 1/ 2 \u2264 q \u2264 1.\n\n(2.3)\n\nSubstituting the bounds (2.3) into the recurrence (2.2), we obtain\n\nE(Fk , q) \u2264\n\n\uf8f1\n\u221a\n\uf8f2 2(1 + q) + 2q 2 E(Fk\u22121 , q), if 0 \u2264 q \u2264 1/ 2;\n\uf8f3\n\n(1 + q)/q 2 + E(Fk\u22121 ),\n\n\u221a\nif 1/ 2 \u2264 q \u2264 1\n\n\u221a\nfor k \u2265 1. Applying the bounds 2(1 + q) \u2264 4 and 2q 2 \u2264 1 for 0 \u2264 q \u2264 1/ 2 and (1 + q)/q 2 \u2264 4 for\n\u221a\n1/ 2 \u2264 q \u2264 1 yields the recurrence\nE(Fk , q) \u2264 4 + E(Fk\u22121 , q).\n\nThis recurrence, together with the initial condition E(F0 , q) = 0, gives the following theorem.\nTheorem 2.2: For any 0 \u2264 q \u2264 1 and k \u2265 0, we have\nE(Fk , q) \u2264 4k.\nTo obtain an upper bound for local search, we transform the above algorithm as follows.\nunilat-search(Fk :\n\nG):\n\nif k = 0:\nreturn true\nlet Fk\u22121 :\n\nG', G'' be the two copies of Fk\u22121 in G;\n\nif (idle(source(G')) and unilat-search(G')) and idle(target(G'))\nreturn true\nif (idle(source(G'')) and unilat-search(G'')) and idle(target(G''))\nreturn true\nreturn false\nThe difference between these algorithms lies in the order of the conditions in the conjunction (... and\n... and ...). This change is necessary to keep the algorithm local; we may not probe target(G') until\nwe have successfully found a path through G', using a recursive call. Thus, the algorithm is much more\n\n5\n\n\flikely to make such a recursive call (with probability q instead of q 2 ) and its running time will grow much\nmore quickly. As before, we may read off the recurrence\nE1 (Fk , q) \u2264 (1 + p + qp + q 2 P (Fk\u22121 , q))(1 + qE1 (Fk\u22121 , q) + qQ(Fk\u22121 , q))\nfor k \u2265 1, with the initial condition E1 (F0 , q) = 0. Using the bounds Q(Fk\u22121 , q) \u2264 1 and P (Fk\u22121 , q) \u2264 P \u2217\n\ntogether with Lemma 2.1 as before, we obtain\n\uf8f1\n\u221a\n\uf8f2 4 + 2qE(Fk\u22121 , q),\nif 0 \u2264 q \u2264 1/ 2;\nE1 (Fk , q) \u2264\n\u221a\n\uf8f3\n2/q 2 + (1/q)E(Fk\u22121 ), if 1/ 2 \u2264 q \u2264 1\n\n\u221a\nfor k \u2265 1. Applying the bounds 2q \u2264 1 for 0 \u2264 q \u2264 1/2 and 2/q 2 \u2264 4 for 1/ 2 \u2264 q \u2264 1 yields the recurrence\n\uf8f1\n4 + E(Fk\u22121 , q),\nif 0 \u2264 q \u2264 1/2;\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\u221a\nE1 (Fk , q) \u2264 4 + 2qE(Fk\u22121 , q), if 1/2 \u2264 q \u2264 1/ 2;\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f3\n\u221a\n4 + (1/q)E(Fk\u22121 ), if 1/ 2 \u2264 q \u2264 1\n\nfor k \u2265 1. This recurrence, together with the initial condition E1 (F0 , q) = 0 yields the following theorem.\nTheorem 2.3: For any 0 \u2264 q \u2264 1 and k \u2265 0, we have\n\uf8f1\n4k,\nif 0 \u2264 q \u2264 1/2;\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\u221a\nE1 (Fk , q) \u2264 4k(2q)k , if 1/2 \u2264 q \u2264 1/ 2;\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f3\n\u221a\n4k/q k ,\nif 1/ 2 \u2264 q \u2264 1\n= 4k max{1, min{(2q)k , 1/q k }}.\n\n3. Lower Bounds\nIn this section, we shall prove the following theorem.\nTheorem 3.1: For 1/2 < q < 1, we have\nE1 (Fk , q) \u2265 min{(2q)k /k 6 , 1/kq k }\nfor all sufficiently large k. This result will show that the exponential rates of growth in Theorem 2.3 are the\nbest possible.\nTo prove Theorem 3.1, we consider an optimal algorithm T for local search in Fk with vacancy probability\n\nq, and define the random variable T to be the number of probes used by T . Since T is optimal, we have\nEx[T ] = E1 (Fk , q), so it will suffice to show that Ex[T ] satisfies the lower bound of Theorem 3.1.\nOur lower bounds will be based on the following principle. If, at any point during the execution of\nthe algorithm, we give the algorithm, at no cost, some information that it has not asked for, that gift can\nonly decrease the expected number of probes it needs to make to complete its task. This principle can be\nformalized in terms of decision trees in the following way. We shall transform the original decision tree T\n\ninto a modified decision tree T \u2217 . The tree T \u2217 will contain, in addition to internal nodes that make probes,\n6\n\n\finternal gift nodes that branch according to the information given for free. We shall prune the tree below\neach gift node, eliminating probe nodes whose outcome is determined by the gift nodes above them. It is\neasy to show that this transformation preserves correctness and can only decrease the expected number of\nprobes used: any state of the network corresponds to a path \u03c0 from the root to a leaf L in T , and a path\n\u03c0 \u2217 from the root to a leaf L\u2217 in T \u2217 ; the leaves L and L\u2217 will have the same label (\"linked\" or \"blocked\"),\nand any link of the network probed by node on \u03c0 \u2217 will also be probed by a node on \u03c0. We shall not dwell\nfurther on this process of formalization; instead we shall proceed directly to an informal presentation of our\nlower bounds based on this principle.\nWe shall begin by telling the algorithm, before it begins its execution, the status of all accessible links\nin ranks 1 through k, thereby informing it of which links in rank k + 1 are accessible. The accessible links\nin rank k + 1 will be called candidate links. The first probe by the algorithm will thus be to a candidate\nlink. Whenever the algorithm probes a candidate link, we shall tell it the status of all accessible links on\nthe path from that candidate link to the target. It follows that every probe by the algorithm will be to a\ncandidate link. This process is illustrated in Figure 2. Each such probe either reveals an idle path from the\nprobed candidate link to target (in which case the algorithm can announce \"linked\"), or discovers a busy\nlink that blocks the paths from some subset of the candidate links to the target (in which case the algorithm\nneed not probe these candidate links, since probing them could neither reveal an idle path to the target, nor\ndiscover a busy node that blocks any additional paths from candidate links to the target). The algorithm\nwill thus probe a sequence of candidate links until it either reveals an idle path to the target or discovers\na set of busy links that together block the paths from all candidate links to the target. It is clear that an\noptimal algorithm will never make a probe after the outcome of the search (\"linked\" or \"blocked\") has been\ndetermined, nor will it probe a candidate link after a busy link has already be discovered on the path from\nthat candidate link to the target.\nt\n\nFigure 2. After probing the marked candidate link (gray), discovering the status of all accesible\nlinks above it (heavy for idle, dotted for busy), and pruning now-useless links (light), only candidate\nlinks are accessible.\n\u221a\nWe can now prove the easier case, 1/ 2 < q < 1, of Theorem 3.1. Let It be the event \"T \u2265 t\"\n(so that the algorithm performs a t-th probe of a candidate link), and let Jt be the event \"the t-th probe\nreveals an idle path to the target\" (so that the algorithm announces \"linked\" after the t-th probe). We have\nPr[Jt | It ] = q k for any probe of a candidate link (since the path from any probed candidate link to the\n\n7\n\n\ftarget contains k links, each of which is independently idle with probability q). Furthermore, by Lemma 2.1\nwe have Q(Fk , q) = 1 \u2212 P (Fk , q) \u2265 1 \u2212 (1 \u2212 q 2 )2 /q 4 \u2265 1/k for all sufficiently large k. Thus we have\nEx[T ] =\n\nX\n\nPr[It ]\n\nt\u22651\n\n=\n\n1 X\nPr[Jt | It ] Pr[It ]\nqk\nt\u22651\n\n1\n= k Q(Fk , q)\nq\n1\n\u2265 k\nkq\n\u221a\nfor all sufficiently large k. This proves Theorem 3.1 for the case 1/ 2 < q < 1.\n\u221a\nFor the remaining case, 1/2 < q \u2264 1/ 2, we shall need to work with an additional branching process\nY0 , Y1 , . . . Yl , . . ., for which Y0 = 1 and the generating function for the number of offspring of an individual\nis g(x) = (1 \u2212 q + qx)2 , describing the number of successes in two independent trials that each succeed with\nprobability q. This branching process governs the number of accessible links in the successive ranks of Tk :\nthe number of links in rank 1 \u2264 l \u2264 k that are idle and accessible through an idle path from the source is\nYl . In particular the set of candidate links has cardinality Yk . Let A denote the event \"Yk < (2q)k /2k 2 \".\nLemma 3.2: For fixed 1/2 < q \u2264 1, we have\nPr[A] \u2264 1 \u2212\n\n5\nk\n\nfor all sufficiently large k.\nProof: Let M = (2q)k /2k 2 . Then for any x \u2264 1 we have\nX\n\nPr[A] =\n\nPr[Yk = m]\n\n0\u2264m<M\n\n\u2264\n\n1\nxM\n\n\u2264\n\n1\nxM\n\n=\n\n1 (k)\ng (x).\nxM\n\nX\n\nPr[Yk = m] xm\n\nX\n\nPr[Yk = m] xm\n\n0\u2264m<M\n\n0\u2264m\u22642k\n\nLet \u03b4 = k/(2q)k . Then taking x = 1 \u2212 \u03b4 yields\nPr[A] \u2264\n\n1\ng(k)(1 \u2212 \u03b4).\n(1 \u2212 \u03b4)M\n\nWe bound the first factor by using the inequality (1 \u2212 \u03b4)M \u2265 1 \u2212 M \u03b4 (which holds for 0 \u2264 \u03b4 \u2264 1 and M \u2265 1),\nobtaining\n\n1\n1\n\u2264\nM\n(1 \u2212 \u03b4)\n1 \u2212 (1/2k)\n1\n.\n=1+\n2k \u2212 1\n8\n\n\fIt will now suffice to show that\ng (k) (1 \u2212 \u03b4) \u2264 1 \u2212\nfor then we shall have\n\n6\n,\nk\n\n(3.1)\n\n\u0012\n1+\n\n\u0013\u0012\n\u0013\n1\n6\n1\u2212\n2k \u2212 1\nk\n1\n6\n\u22641\u2212 +\nk 2k \u2212 1\n5\n\u22641\u2212 ,\nk\n\nPr[A] \u2264\n\ncompleting the proof of the lemma.\nThe function g(x) has two fixed points, at x = 1 and at x = (1 \u2212 q)2 /q 2 < 1. Let \u03b3 = (1 \u2212 q)2 /q 2 denote\n\u0001\n\u0001\u000e\n\u0001\nthis smaller fixed point. Define G(y) = g \u03b3 + (1 \u2212 \u03b3)y \u2212 \u03b3\n1 \u2212 \u03b3 = 2(1 \u2212 q)y + (2q \u2212 1)y 2 . Since the\n\ntransformation y 7\u2192 \u03b3 + (1 \u2212 \u03b3)y is inverse to x 7\u2192 (x \u2212 \u03b3)/(1 \u2212 \u03b3), iterating G(y) is equivalent to iterating\n\u0001\n\u0001\ng(x): g (k) (x) = \u03b3 + (1 \u2212 \u03b3)G(k) (x \u2212 \u03b3)/(1 \u2212 \u03b3) . Next define H(y) = y/ 2q + (1 \u2212 2q)y . Then G(y) \u2264 H(y)\n\u0001\n\u0001\nfor all y \u2265 0, since 2(1 \u2212 q)y + (2q \u2212 1)y 2 2q + (1 \u2212 2q)y \u2212 y = \u2212y(2q \u2212 1)2 (y \u2212 1)2 \u2264 0. Straightforward\n\ninduction shows that\n\nH (k) (y) =\n\ny\n.\n(2q)k + (1 \u2212 (2q)k )y\n\nSubstituting x = 1 \u2212 \u03b4 in y = (x \u2212 \u03b3)/(1 \u2212 \u03b3), we obtain y = (1 \u2212 \u03b4 \u2212 \u03b3)/(1 \u2212 \u03b3) < 1 \u2212 \u03b4. From this we\n\nobtain, since H(y) and thus H (k) (y) are increasing functions of y for 0 \u2264 y \u2264 1,\n1\u2212\u03b4\n(2q)k + (1 \u2212 (2q)k )(1 \u2212 \u03b4)\n1\u2212\u03b4\n=\n(1 \u2212 \u03b4) + \u03b4(2q)k\n1\u2212\u03b4\n\u2264\n(1 \u2212 \u03b4) + k\n1\n.\n\u2264\n1+k\n\nH (k) (y) =\n\nSince G(k) (y) \u2264 H (k) (y), we obtain\nso we have\n\nG(k) (y) \u2264\n\n1\n,\n1+k\n\ng (k) (1 \u2212 \u03b4) = \u03b3 + (1 \u2212 \u03b3)G(k) (y)\n1\u2212\u03b3\n\u2264\u03b3+\n.\n1+k\n\nSince \u03b3 < 1, this inequality establishes (3.1), and thus completes the proof of the lemma. \u2293\n\u2294\nFor each link v in rank k \u2212 l of Fk for some 0 \u2264 l \u2264 k \u2212 1, let Xv denote the number of links in rank k\n\nthat are accessible through idle paths from v. For each link v in rank k \u2212l, let Bv be the event Xv > k 2 (2q)l \",\n\nand let B be the event \"for some l in the range 0 \u2264 l \u2264 k \u2212 1 and some link v in rank k \u2212 l, Xv > k 2 (2q)l \".\nLemma 3.3: For fixed 1/2 < q \u2264 1, we have\n\nPr[B] \u2264\n\nfor all sufficiently large k.\n\n9\n\n1\nk\n\n\fProof: There are at most 2 * 2k links in Tk . Thus it will suffice to prove that for any one link v in rank k \u2212 l,\n4\n,\nek\n\nPr[Bv ] \u2264\n\n(3.2)\n\nfor then, by Boole's inequality, we shall have\nPr[B] \u2264\n\nX\n\nPr[Bv ]\n\nv\n\n8 * 2k\nek\n1\n\u2264\nk\n\n\u2264\n\nfor all sufficiently large k.\nConsider a fixed link v in rank k \u2212 l. Let M = k 2 (2q)l . Then for any x \u2265 1 we have\nPr[Bv ] =\n\nX\n\nPr[Xv = m]\n\nM<m\u22642l\n\n\u2264\n\n1\nxM\n\n\u2264\n\n1\nxM\n\n\u2264\n\n1 (l)\ng (x).\nxM\n\nX\n\nPr[Xv = m] xm\n\nM<m\u22642l\n\nX\n\nPr[Xv = m] xm\n\n0\u2264m\u22642l\n\nLet \u03b4 = 1/k(2q)l . Then taking x = 1 + \u03b4 yields\nPr[Bv ] \u2264\n\n1\ng (l) (1 + \u03b4).\n(1 + \u03b4)M\n\nWe bound the first factor by using the inequality log(1 + z) \u2265 z \u2212 z 2 /2 (which holds for all z \u2265 0), obtaining\n1\n\u2264 exp (\u2212M log(1 + \u03b4))\n(1 + \u03b4)M\n\u0001\n\u2264 exp \u2212M (\u03b4 + \u03b4 2 /2)\n\u0001\n= exp \u2212k + 1/2(2q)l\n\u2264 exp (\u2212k + 1/2)\n\ne1/2\nek\n2\n\u2264 k,\ne\n=\n\n(3.3)\n\nfor all sufficiently large k. It will now suffice to show that\ng (l) (1 + \u03b4) \u2264 2,\n\n(3.4)\n\nfor all sufficiently large k, for this combined with (3.3) will yield (3.2), completing the proof of the lemma.\n\n10\n\n\fLet G(\u03b4) = g(1 + \u03b4) \u2212 1 = 2q\u03b4 + q 2 \u03b4 2 , and let H(\u03b4) = 2q\u03b4/(1 \u2212 \u03b4). Then G(\u03b4) \u2264 H(\u03b4) for all 0 \u2264 \u03b4 < 1,\n\nsince (2q\u03b4 + q 2 \u03b4 2 )(1 \u2212 \u03b4) = 2q\u03b4 \u2212 (2 \u2212 q)q\u03b4 2 \u2212 q 2 \u03b4 3 \u2264 2q\u03b4. Since G(\u03b4) and H(\u03b4) are both nondecreasing\nfunctions of \u03b4 for 0 \u2264 \u03b4 < 1, a straightforward induction on l \u2265 0 shows that\nG(l) (\u03b4) \u2264 H (l) (\u03b4)\n\u2264\n\n(2q)l \u03b4\n1 \u2212 l(2q)l\u22121 \u03b4\n\nfor 0 \u2264 \u03b4 < 1/l(2q)l\u22121 . Taking \u03b4 = 1/k(2q)l , we obtain\ng (l) (1 + \u03b4) = 1 + G(l) (\u03b4)\n1/k\n\u22641+\n1 \u2212 1/(2q)\n\u22642\n\nfor all sufficiently large k. This inequality establishes (3.4), and thus completes the proof of the lemma. \u2293\n\u2294\nLet C be the event \"neither A nor B occurs\". From Lemmas 2.2 and 2.3 we have\nPr[C] \u2265 1 \u2212 Pr[A] \u2212 Pr[B]\n\u0013\n\u0012\n1\n5\n\u2212\n\u22651\u2212 1\u2212\nk\nk\n4\n= .\nk\n\n(3.5)\n\nAs before, let It denote the event \"T \u2265 t\". If the t-th probe of a candidate link discovers l accessible idle\nlinks on the path from the candidate link to the target (before reaching a busy link or the target), we shall\nassociate with with that probe a \"payoff\" Kt = k 2 (2q)l . The number Lt of accessible idle links discovered\non the path from the probed candidate link to the target has the distribution Pr[Lt = l | It ] = (1 \u2212 q)q l\nfor 0 \u2264 l \u2264 k \u2212 1 and Pr[Lt = k | It ] = q k , and thus the payoff Kt of the t-th probe has the distribution\nPr[Kt = k 2 (2q)l | It ] = (1 \u2212 q)q l for 0 \u2264 l \u2264 k \u2212 1 and Pr[Kt = k 2 (2q)k | It ] = q k . We thus have\nEx[Kt | It ] \u2264 k 2\n\nX\n\n(2q)l q l\n\n0\u2264l\u2264k\n\n\u2264 2k 3 ,\nsince 2q 2 \u2264 1. We note that these distributions and expectations are independent of A, B and C.\nP\nLet K = y\u22651 Kt denote the total payoff from all probes. If C occurs, and after T probes of candidate\n\nlinks the algorithm announces \"linked\" or \"blocked\", the total payoff from all probes of candidate links must\nsatisfy K \u2265 (2q)k /2k 2 . For if the algorithm announces \"blocked\", then (because A did not occur) there must\n\nhave been at least (2q)k /2k 2 candidate links, and (because B did not occur) the number of candidate links\nwhose paths to the target were found to be blocked by the t-th probe was at most the payoff Kt (since the\n\ncandidate links whose paths to the target blocked by a busy link in rank k + 1 + l are accessible through idle\npaths from a link in rank k \u2212l). And if the algorithm announced \"linked\", the T -th probe must have revealed\n\nan idle path from a candidate link to the target, and this probe alone had payoff KT = k 2 (2q)k \u2265 (2q)k /2k 2 .\n\n11\n\n\fThus we have\n\nEx[T ] \u2265 Ex[T | C] Pr[C]\n1\n\u2265 Ex[T | C]\nk\n1X\n\u2265\nPr[It | C]\nk\nt\u22651\n\n\u2265\n\n1 1 X\nEx[Kt | It ] Pr[It | C]\nk 2k 3\nt\u22651\n\n1 1 X\nEx[K | C]\n\u2265\nk 2k 3\nt\u22651\n\n1 1 (2q)k\nk 2k 3 2k 2\n(2q)k\n=\n.\n4k 6\n\u2265\n\n\u221a\nThis completes the proof of Theorem 3.1 in the case 1/2 < q \u2264 1/ 2.\n4. Conclusion\nWe have presented a sequence Fk of channel graphs for which global path search is easy, in the sense\nthat its cost is O(k) for any vacancy probability q, as is shown by the natural bilateral depth-first search\nalgorithm presented in Section 2. We have shown in Section 3 that the cost of local path search in Fk is\nexponential in k for all 1/2 < q < 1. We have also presented in Section 2 a natural algorithm, unilateral\ndepth-first search, that shows that the exponential rate of growth in shown in Section 3 is the best possible,\nin the sense that it matches the exponential rate of growth of the cost of unilateral depth-first search. We\nconjecture that unilateral depth-first search is in fact optimal in the stronger sense of making the smallest\npossible expected number of probes for every k \u2265 0 and 0 \u2264 q \u2264 1.\nThe foregoing results may be summarized by saying that global search in Fk is cheap, but local search\nis expensive. If, however, we consider \"bilateral local search\", wherein a link may be probed if either there\nis an idle path from the source to it, or an idle path from it to the target, then search in Fk is again cheap,\nbecause the global search algorithm bilat-search probes only vertices meeting one of these conditions.\nAre there channel graphs in which global search is cheap, but even bilateral local search is expensive?\nThe answer is \"yes\", as can be seen by considering the graph Fk \u25e6 Fk obtained by connecting two copies of\n\nFk in series, with the target of the first copy identified with the source of the second copy to form a link u.\nGlobal search of Fk \u25e6 Fk is cheap: we first probe u; if it is idle, we then search the first copy of Fk ; and if\n\nthat copy is linked, we search the second copy. Thus\n\nE(Fk \u25e6 Fk , q) \u2264 1 + q(1 + Q(Fk , q))E(Fk , q).\nIf, however, we condition on the link u being idle, and give this information for free to the search algorithm,\nthen a path in Fk \u25e6 Fk is the concatenation of two paths, one in each copy of Fk , while a cut in Fk \u25e6 Fk\nmust include a cut in at least one copy of Fk . Since Fk is symmetric under reversal, every link probed by\na bilateral local search in Fk \u25e6 Fk can be probed in a \"unilateral\" local search of the first copy of Fk , or\nin a \"reverse unilateral\" local search of the second copy. Thus the lower bound of Section 3 for unilateral\n\n12\n\n\fsearch in Fk , when multiplied by the probability q that u is idle, becomes a lower bound for bilateral search\nin Fk \u25e6 Fk . Thus even bilateral local search of Fk \u25e6 Fk is expensive.\n5. Acknowledgment\nThe research reported in this paper was supported in part by Grant CCF 0646682 from the National\nScience Foundation.\n\n6. References\n[H1] T. E. Harris, The Theory of Branching Processes, Springer-Verlag, 1963.\n[H2] A. H. Hunter, Locality & Complexity in Path Search, B. S. Thesis, Department of Mathematics, Harvey\nMudd College, May 2009.\n[L1] C. Y. Lee, \"Analysis of Switching Networks\", Bell System Technical Journal, 34 (1955) 1287\u20131315.\n[L2] P. Le Gall, \"\u00c9tude du blocage dans les syst\u00e8mes de commutation t\u00e9l\u00e9phonique automatique utilisant\ndes commutateurs \u00e9lectroniques du type crossbar\", Ann. des T\u00e9l\u00e9comm., 11 (1956) 159\u2013171; 180\u2013194;\n197.\n[L3] P. Le Gall, \"\"M\u00e9thode de calcul de l'encombrement dans les syst\u00e8mes t\u00e9l\u00e9phonique automatique \u00e0\nmarquage\", Ann. des T\u00e9l\u00e9comm., 12 (1957) 374\u2013386.\n[L4] G. Lin and N. Pippenger, \"Routing Algorithms for Switching Networks with Probabilistic Traffic\",\nNetworks, 28:1 (1996) 21\u201329.\n[P] N. Pippenger, \"Upper and Lower Bounds for the Average-Case Complexity of Path Search\", Networks,\n33:4 (1999) 249\u2013259.\n\n13\n\n\f"}