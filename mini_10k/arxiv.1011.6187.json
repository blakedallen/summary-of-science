{"id": "http://arxiv.org/abs/1011.6187v1", "guidislink": true, "updated": "2010-11-29T10:46:27Z", "updated_parsed": [2010, 11, 29, 10, 46, 27, 0, 333, 0], "published": "2010-11-29T10:46:27Z", "published_parsed": [2010, 11, 29, 10, 46, 27, 0, 333, 0], "title": "Contractions, Removals and How to Certify 3-Connectivity in Linear Time", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1011.2169%2C1011.6398%2C1011.5101%2C1011.0949%2C1011.6537%2C1011.1580%2C1011.6457%2C1011.3150%2C1011.0746%2C1011.1039%2C1011.4476%2C1011.4137%2C1011.3482%2C1011.6487%2C1011.2682%2C1011.1654%2C1011.3564%2C1011.4151%2C1011.0481%2C1011.2694%2C1011.6400%2C1011.3288%2C1011.6210%2C1011.2048%2C1011.0779%2C1011.3398%2C1011.1194%2C1011.6268%2C1011.1200%2C1011.0946%2C1011.0491%2C1011.2658%2C1011.2741%2C1011.3836%2C1011.1837%2C1011.0321%2C1011.1302%2C1011.4982%2C1011.4448%2C1011.1793%2C1011.0536%2C1011.4220%2C1011.4743%2C1011.0520%2C1011.5846%2C1011.3322%2C1011.1905%2C1011.0274%2C1011.5282%2C1011.1290%2C1011.3693%2C1011.4352%2C1011.2779%2C1011.5952%2C1011.4424%2C1011.2186%2C1011.2069%2C1011.1849%2C1011.4374%2C1011.5655%2C1011.1307%2C1011.1991%2C1011.3562%2C1011.4113%2C1011.5239%2C1011.5175%2C1011.6654%2C1011.2066%2C1011.3256%2C1011.4684%2C1011.3101%2C1011.0600%2C1011.5061%2C1011.3641%2C1011.0013%2C1011.6177%2C1011.1327%2C1011.1155%2C1011.4262%2C1011.1493%2C1011.3520%2C1011.4899%2C1011.2713%2C1011.2146%2C1011.6525%2C1011.2157%2C1011.0065%2C1011.6373%2C1011.0221%2C1011.3073%2C1011.6187%2C1011.4532%2C1011.0559%2C1011.0252%2C1011.6231%2C1011.5316%2C1011.0584%2C1011.4728%2C1011.2446%2C1011.2726%2C1011.4760&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Contractions, Removals and How to Certify 3-Connectivity in Linear Time"}, "summary": "It is well-known as an existence result that every 3-connected graph G=(V,E)\non more than 4 vertices admits a sequence of contractions and a sequence of\nremoval operations to K_4 such that every intermediate graph is 3-connected. We\nshow that both sequences can be computed in optimal time, improving the\npreviously best known running times of O(|V|^2) to O(|V|+|E|). This settles\nalso the open question of finding a linear time 3-connectivity test that is\ncertifying and extends to a certifying 3-edge-connectivity test in the same\ntime. The certificates used are easy to verify in time O(|E|).", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1011.2169%2C1011.6398%2C1011.5101%2C1011.0949%2C1011.6537%2C1011.1580%2C1011.6457%2C1011.3150%2C1011.0746%2C1011.1039%2C1011.4476%2C1011.4137%2C1011.3482%2C1011.6487%2C1011.2682%2C1011.1654%2C1011.3564%2C1011.4151%2C1011.0481%2C1011.2694%2C1011.6400%2C1011.3288%2C1011.6210%2C1011.2048%2C1011.0779%2C1011.3398%2C1011.1194%2C1011.6268%2C1011.1200%2C1011.0946%2C1011.0491%2C1011.2658%2C1011.2741%2C1011.3836%2C1011.1837%2C1011.0321%2C1011.1302%2C1011.4982%2C1011.4448%2C1011.1793%2C1011.0536%2C1011.4220%2C1011.4743%2C1011.0520%2C1011.5846%2C1011.3322%2C1011.1905%2C1011.0274%2C1011.5282%2C1011.1290%2C1011.3693%2C1011.4352%2C1011.2779%2C1011.5952%2C1011.4424%2C1011.2186%2C1011.2069%2C1011.1849%2C1011.4374%2C1011.5655%2C1011.1307%2C1011.1991%2C1011.3562%2C1011.4113%2C1011.5239%2C1011.5175%2C1011.6654%2C1011.2066%2C1011.3256%2C1011.4684%2C1011.3101%2C1011.0600%2C1011.5061%2C1011.3641%2C1011.0013%2C1011.6177%2C1011.1327%2C1011.1155%2C1011.4262%2C1011.1493%2C1011.3520%2C1011.4899%2C1011.2713%2C1011.2146%2C1011.6525%2C1011.2157%2C1011.0065%2C1011.6373%2C1011.0221%2C1011.3073%2C1011.6187%2C1011.4532%2C1011.0559%2C1011.0252%2C1011.6231%2C1011.5316%2C1011.0584%2C1011.4728%2C1011.2446%2C1011.2726%2C1011.4760&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "It is well-known as an existence result that every 3-connected graph G=(V,E)\non more than 4 vertices admits a sequence of contractions and a sequence of\nremoval operations to K_4 such that every intermediate graph is 3-connected. We\nshow that both sequences can be computed in optimal time, improving the\npreviously best known running times of O(|V|^2) to O(|V|+|E|). This settles\nalso the open question of finding a linear time 3-connectivity test that is\ncertifying and extends to a certifying 3-edge-connectivity test in the same\ntime. The certificates used are easy to verify in time O(|E|)."}, "authors": ["Jens M. Schmidt"], "author_detail": {"name": "Jens M. Schmidt"}, "author": "Jens M. Schmidt", "arxiv_comment": "preliminary version", "links": [{"href": "http://arxiv.org/abs/1011.6187v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1011.6187v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1011.6187v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1011.6187v1", "journal_reference": null, "doi": null, "fulltext": "Contractions, Removals and How to Certify 3-Connectivity in\nLinear Time\nJens M. Schmidt\u2217\nFreie Universit\u00e4t Berlin, Germany\n\narXiv:1011.6187v1 [cs.DS] 29 Nov 2010\n\nAbstract\nIt is well-known as an existence result that every 3-connected graph G = (V, E) on more\nthan 4 vertices admits a sequence of contractions and a sequence of removal operations to\nK4 such that every intermediate graph is 3-connected. We show that both sequences can be\ncomputed in optimal time, improving the previously best known running times of O(|V |2 )\nto O(|V | + |E|). This settles also the open question of finding a linear time 3-connectivity\ntest that is certifying and extends to a certifying 3-edge-connectivity test in the same time.\nThe certificates used are easy to verify in time O(|E|).\n\n1\n\nIntroduction\n\nThe class of 3-connected graphs has been studied intensively for many reasons in the past 50\nyears. One algorithmic reason is that graph problems can often be reduced to handle 3-connected\ngraphs; applications include problems in graph drawing (see [18] for a survey), problems related\nto planarity [6, 12] and online problems on planar graphs (see [5] for a survey). From a complexity point of view, 3-connectivity is in particular important for problems dealing with longest\npaths, because it lies, somewhat surprisingly, on the borderline of NP-hardness: Finding a\nHamiltonian cycle is NP-hard for 3-connected planar graphs [11] but becomes solvable in linear\nrunning time [8] for higher connectivities, as 4-connected planar graphs have been proven to be\nHamiltonian [23].\nWe want to design efficient algorithms from inductively defined constructions of graph\nclasses. In general, such constructions start with a set of base graphs and apply iteratively\noperations from a fixed set of operations such that precisely the members of the graph class of\ninterest are constructed. This way we obtain a (not necessarily unique) sequence of graphs for\neach member G of the graph class, which we call a construction sequence of G. The construction\ndoes not only give a computational approach to test membership in these classes, it can also be\nexploited to prove properties of the graph class using only the fixed set of operations applied\nin every step. Fortunately, graph theory provides inductively defined constructions for many\ngraph classes, including planar graphs, triangulations, k-connected graphs for k \u2264 4, regular\ngraphs and various intersections of these classes [3, 4, 14]. However, most of these constructions\nhave not been exploited computationally.\nFor the class of 3-connected graphs, one of the most noted constructions is due to Tutte [24],\nbased on the following fact: Every 3-connected graph G on more than 4 vertices contains a\ncontractible edge, i. e., an edge that preserves the graph to be 3-connected upon contraction.\nContracting iteratively this edge yields a sequence of 3-connected graphs top-down from G to a\n\u2217\n\nThis research was supported by the Deutsche Forschungsgemeinschaft within the research training group\n\"Methods for Discrete Structures\" (GRK 1408). Email: jens.schmidt@inf.fu-berlin.de.\n\n1\n\n\fK4 -multigraph. Unfortunately, also non-3-connected graphs can contain contractible edges, but\nadding a side condition establishes a full characterization: A graph G on more than 4 vertices\nis 3-connected if and only if there is a sequence of contractions from G to a K4 -multigraph on\nedges e with both end vertices having at least 3 neighbors [9]. Every contracted edge in this\nsequence is then contractible. It is also possible to describe this sequence bottom-up from K4 to\nG by using the inverse operations edge addition and vertex splitting; in fact this is the original\nform as stated in Tutte's famous wheel theorem [24].\nBarnette and Gr\u00fcnbaum [2] and Tutte [25] give a different construction of 3-connected\ngraphs that is based on the following argument: Every 3-connected graph G 6= K4 contains\na removable edge. Removing this edge leads, similar as in the sequence of contractions, to a\ntop-down construction sequence from G to K4 . Adding a side condition then fully characterizes\n3-connected graphs. We will define removals and removable edges in Section 2. Again, the\noriginal proposed construction was given bottom-up from K4 to G, using three operations.\nAlthough both existence theorems on contractible and removable edges are used frequently in\ngraph theory [21, 22, 25], the first non-trivial computational results to create the corresponding\nconstruction sequences were published more than 45 years afterwards: In 2006, Albroscheit [1]\ngave an algorithm that computes a construction sequence for 3-connected graphs in O(|V |2 )\ntime in which contractions and removals are allowed to intermix. In 2010, an algorithm was\ngiven [20] that constructs the (pure) sequences of contractions and removals, respectively, in\nthe same running time. One of the building blocks of this algorithm is a straight-forward\ntransformation from the sequence of removals to the sequence of contractions in time O(|E|).\nThis shows that the sequence of Barnette and Gr\u00fcnbaum is algorithmically at least as powerful\nas the sequence of contractions. It is important to note that all algorithms do not rely on the\n3-connectivity test of Hopcroft and Tarjan [13], which runs in linear time but is rather involved.\nIt was also shown that all previously mentioned construction sequences can be stored in linear\nspace O(n + m) [20]. Nevertheless, we are not aware of any algorithm that computes any of\nthese sequences in subquadratic time up to now.\nThe main contribution of this paper is an optimal algorithm that computes the construction\nsequence of Barnette and Gr\u00fcnbaum bottom-up in time and space O(|V | + |E|). This has a\nnumber of consequences.\nTop-down and bottom-up variants of both constructions. One can immediately obtain\nthe sequence of removals out of Barnette and Gr\u00fcnbaum's construction sequence by replacing\nevery operation with its inverse removal operation. Applying the transformation of [20] implies\noptimal time and space algorithms for the sequence of contractions and its bottom-up variant\nas well.\nCertifying 3-connectivity in linear time. Blum and Kannan [7] initiated the concept of\nprograms that check their work. Mehlhorn and N\u00e4her [15, 16, 17] developed this idea further and\nintroduced the concept of certifying algorithms, which give a small and easy-to-verify certificate\nof correctness along with their output. Achieving such algorithms is a major goal for problems\nwhere the fastest solutions known are complicated and difficult to implement. Testing a graph\non 3-connectivity is such a problem, but surprisingly few work has been devoted to certify 3connectivity, although sophisticated linear-time recognition algorithms (not giving an easy-toverify certificate) are known for over 35 years [13, 26, 27]. The currently fastest algorithms that\ncertify 3-connectivity need O(|V |2 ) time and use construction sequences as certificates [1, 20].\nRecently, a linear time certifying algorithm for 3-connectivity has been given for the subclass\nof Hamiltonian graphs, when the Hamiltonian cycle is part of the input [9]. In general, finding\na certifying algorithm for 3-connectivity in subquadratic time is an open problem [9].\n2\n\n\fWe give a linear-time certifying algorithm for 3-connectivity by using Barnette and Gr\u00fcnbaum's construction sequence as certificate. The certificate can be easily verified in time O(|E|),\nas shown in [20]. This implies also a new, simple-to-implement and certifying test on 3connectivity in linear time and space that is path-based and neither relies on the algorithm\nof Hopcroft and Tarjan nor uses low-points.\nCertifying 3-edge-connectivity in linear time. We are not aware of any test for 3-edgeconnectivity that is certifying and runs in linear time. Galil and Italiano [10] show that testing\nk-edge-connectivity of a graph G can be reduced to test k-vertex-connectivity on a slightly\nmodified graph G0 , blowing up the number of vertices and edges only by a factor O(k). For\nk = 3, the reduction blows up each vertex v \u2208 V (G) to a wheel graph with as many spokes\nas v has neighbors. Constructing G0 and applying the certifying 3-vertex-connectivity test to\nG0 yields a certifying 3-edge-connectivity test in linear time and space. However, we have to\naugment the certificate by the mapping \u03c6 that maps each vertex of G to the vertices and edges\nbeing contained in the corresponding wheel graph in G0 . This ensures that the construction of\nG0 can be verified while preserving linear time and space.\n\n2\n\nConstruction Sequences\n\nLet G = (V, E) be a finite graph with n vertices and m edges. For k \u2265 1, a graph G is kconnected if n > k and deleting every set of k \u2212 1 vertices leaves a connected graph. A vertex\n(a pair of vertices) that leaves a disconnected graph upon deletion is called a cut vertex (a\nseparation pair). Let v \u2192G w denote a path P from vertex v to vertex w in G and let s(P ) := v\nand t(P ) := w. For a vertex v in G, let N (v) = {w | vw \u2208 E} denote its set of neighbors and\ndeg(v) its degree. Let \u03b4(G) be the minimum degree in G.\nLet Kn be the complete graph on n vertices and let Knm be the complete graph on n vertices\nwith m edges between each pair of vertices. For a rooted tree T and x \u2208 V (T ), let T (x) be the\nmaximal subtree of T rooted at x. We assume for convenience that the input graph G is simple\nfor the rest of the paper, although all results extend to multigraphs. A subdivision of a graph G\nreplaces each edge of G by a path of length at least one. Conversely, we want a notation to get\nback to the graph without subdivided edges. If deg(v) = 2 and |N (v) \\ {v}| = 2, let smoothing\nv delete v followed by adding an edge between its neighbors. If one of the conditions is violated,\nlet smoothing v not change the graph.\nRemoving an edge e = xy of a graph deletes e followed by smoothing x and y. An edge\nof G is called removable, if removing it results in a 3-connected graph. Iteratively removing\nremovable edges in a 3-connected graph G leads to a sequence of removals from G to K4 , the\nexistence of which characterizes 3-connected graphs when adding a side condition similar as in\nthe sequence of contractions. We describe the equivalent bottom-up construction of G due to\nBarnette and Gr\u00fcnbaum. The construction starts with K4 and applies iteratively one of the\nthree following operations, which are called BG-operations (see Figure 1):\n1. Add an edge xy (possibly a parallel edge).\n2. Subdivide an edge ab by a vertex x and add the edge xy for a vertex y \u2208\n/ {a, b}.\n3. Subdivide two non-parallel edges by vertices x and y, respectively, and add the edge xy.\nLet G4 , G5 , . . . , Gz with G4 = K4 and Gz = G be a construction sequence of G using BGoperations. As K4 is 3-connected and BG-operations preserve 3-connectivity, every Gl with\n4 < l \u2264 z is also 3-connected. We represent the construction sequence in a different, but\nequivalent way, as shown in [2, 20]: Each graph Gl corresponds to a unique Gl -subdivision Sl\n3\n\n\f(a)\nparallel\nedges allowed\n\n(b) y, a and b pairwise distinct\n\n(c) e and f neither identical\nnor parallel\n\nFigure 1: The three BG-operations.\nin G, which can be readily seen by iteratively deleting the removable edges in the top-down\nvariant. In this representation, the vertices of Gl correspond to the vertices in Sl of degree\nat least 3; we call the latter real vertices.We define the operations on Sl that correspond to\nBG-operations. Let Vreal (Sl ) be the set of real vertices in Sl . The links of Sl are the unique\npaths in Sl that contain real end vertices but no other real vertex. Let two links be parallel if\nthey share the same end vertices.\nDefinition 1. A BG-path for a subgraph Sl \u2282 G is a path P = x \u2192G y with the properties:\n1. Sl \u2229 P = {x, y}\n2. Every link of Sl that contains x and y, contains them as end vertices.\n3. If x and y are inner vertices of links Lx and Ly of Sl , respectively, and |Vreal (Sl )| \u2265 4,\nthen Lx and Ly are not parallel.\nIt is easy to see that every BG-path for Sl corresponds to a BG-operation on Gl and vice\nversa. The choice of the K4 -subdivision S4 is not crucial [20]: At the expense of having additional parallel edges in intermediate graphs Gl , there exists a construction sequence to G\nfrom each prescribed K4 -subdivision in G. This provides an efficient computational approach\nto construction sequences, since we can start with an arbitrary K4 -subdivision S4 in G. The\nrepresentation with subdivisions allows then to search the next BG-path in the neighborhood\nof the current subdivision in G. We summarize the results.\nTheorem 2. The following statements are equivalent:\nA simple graph G is 3-connected\n\n(1)\n\n\u21d4 \u2203 sequence of BG-operations from K4 to G (see [2, 25])\n\n(2)\n\n\u21d4 \u2203 sequence of BG-paths from a K4 -subdivision in G to G and \u03b4(G) \u2265 3 (see [2, 20])\n\n(3)\n\n\u21d4 \u2203 sequence of BG-paths from each K4 -subdivision in G to G and \u03b4(G) \u2265 3 (see [20]) (4)\n\u21d4 \u2203 sequence of removals from G to K4 on removable edges e = xy\nwith |N (x)| \u2265 3, |N (y)| \u2265 3 and |N (x) \u222a N (y)| \u2265 5 (see [20])\n\n(5)\n\n\u21d4 \u2203 sequence of contractions from G to K4 on edges e = xy with |N (x)| \u2265 3\nand |N (y)| \u2265 3 (see [24])\n\n(6)\n\nThe following Lemma allows to focus only on computing sequence 2.(3).\nLemma 3 ([20, Proof of Theorem 2 and Lemma 4.1]). There is an algorithm that transforms\na given sequence 2.(2), 2.(3) or 2.(5) to each of the sequences 2.(2)-2.(6) in linear time. If the\ntransformation yields one of the sequences 2.(2)-2.(5), the number of operations is preserved.\nThroughout the rest of the paper, a construction sequence will therefore refer to sequence 2.(3),\nunless stated otherwise. To construct such a sequence, we will use the following Lemma.\n4\n\n\fLemma 4 ([20]). Let G be a 3-connected graph and H \u2282 G with H being a subdivision of a\n3-connected graph. Then there is a BG-path for H in G. Moreover, every link of H of length\nat least 2 contains an inner vertex on which a BG-path for H starts.\nEvery contraction sequence 2.6 contains exactly n \u2212 4 contractions, implying that the K4 multigraph contains exactly m \u2212 n \u2212 2 parallel edges. The number of removals is also fixed.\nLemma 5. Every sequence 2.2-2.5 contains exactly m \u2212 n \u2212 2 operations, i. e., z = m \u2212 n + 2.\nProof. It suffices to show the claim for each sequence 2.2 with Lemma 3. Let a, b and c denote\nthe number of BG-operations in the sequence that create zero, one and two new vertices,\nrespectively. Then b + 2c = n \u2212 4 and a + 2b + 3c = m \u2212 6 hold, since K4 consists of four vertices\nand six edges. Subtracting the equations gives that a + b + c = m \u2212 n \u2212 2.\n\n3\n\nChain Decompositions\n\nLet G be a 3-connected graph. According to Lemma 4, it suffices to add iteratively BG-paths\nto an arbitrary K4 -subdivision in G to get a construction sequence. Note that we cannot\nmake wrong decisions when choosing a BG-path, since Lemma 4 can always be applied on\nthe new subdivision and therefore ensures a completion of the sequence. Instead of starting\nwith a K4 -subdivision, we will w. l. o. g. start with a K23 -subdivision S3 and find a BG-path for\nS3 that results in a K4 -subdivision. We first show how S3 is computed and then describe a\ndecomposition of G into special paths that allows us to find the BG-paths efficiently.\nA Depth First Search (DFS) is performed on G, assigning a Depth First Index (DFI) to\nevery vertex. Let T be the corresponding DFS-tree, r be the root of T and u be the vertex\nthat is visited second. Both, r and u, have exactly one child in T , as otherwise they would\nform a separation pair in G. For two vertices v and w in T , let v be a (proper) ancestor of\nw and w be a (proper) descendant of v if v \u2208 V (r \u2192T w) (and v 6= w). A backedge is an\nedge vw \u2208 E(G) \\ E(T ) oriented from v to w with v being an ancestor of w (note that this\ndiffers from standard notation). A backedge vw enters a subtree T 0 of a tree if v \u2208\n/ V (T 0 ) but\nw \u2208 V (T 0 ).\nTo compute S3 , we choose two backedges ra and rb and denote the least common ancestor\nof a and b in T with x. The paths x \u2192T r, ra \u222a a \u2192T x and rb \u222a b \u2192T x are the three\nsubdivided edges of S3 in G with real vertices r and x. Now, G is decomposed into special paths\n{C0 , C1 , . . . , Cm\u2212n+1 } =: C, called chains, whose edge sets partition E(G). The decomposition\nimposes a total order < on C with C0 < C1 < . . . < Cm\u2212n+1 that is identical to the order in\nwhich the chains were computed. We set C0 := x \u2192T r, C1 := ra \u222a a \u2192T x and C2 := rb \u222a b \u2192T\nx. The remaining chains are then computed by applying the following procedure subsequently\nfor each vertex v in increasing DFI-order: For every backedge vw not in a chain, we traverse\nthe path w \u2192T r until a vertex x is found that is already contained in a chain. The traversed\npath v \u2192G x including vw forms the new chain.\nNote that every chain Ci 6= C0 contains exactly one backedge and thus |C| = m \u2212 n + 2.\nAlso, s(Ci ) is always a proper ancestor of t(Ci ). Chains admit the following tree structure.\nDefinition 6. Let the parent of a chain Ci 6= C0 be the chain that contains the edge from t(Ci )\nto the parent of t(Ci ) in T .\nLemma 7. The parent relation defines a tree U with V (U ) = C and root C0 .\nProof. Let D0 6= C0 be a chain in C and let D1 , . . . , Dk be the sequence of chains containing\nthe edges of t(D0 ) \u2192T r in that order, omitting double occurrences. By definition of the parent\n5\n\n\frelation, each Di , 0 \u2264 i < k, has parent Di+1 . It follows with Dk = C0 that U is connected.\nMoreover, U is acyclic, as parent chains are always smaller in < than their children by definition\nof the decomposition.\n\n3.1\n\nClassifying Chains and Restrictions\n\nWe extend the chain decomposition to assign one of the types 1, 2a, 2b, 3a and 3b to each chain\nin C \\ {C0 }. The motivation for this classification is that chains of certain types are, under\nsome conditions, BG-paths and therefore allow to compute the next step of the construction\nsequence. The types are defined by Algorithm 1: E. g., a chain Ci with parent Ck is of type 1 if\nt(Ci ) \u2192T s(Ci ) \u2286 Ck and of type 2 if it is not of type 1 and s(Ci ) = t(Ck ) holds (see Figures 2\nand 5(b)). All chains are unmarked at the beginning of Algorithm 1. It is not difficult to show\nthat the decomposition and classification can be carried out in linear time. We omit a proof.\nAlgorithm 1 classify(Ci \u2208 C \\ {C0 }, DFS-tree T )\n1: Ck := parent(Ci )\n. the parent of Ci in U : Ck < Ci\n2: if t(Ci ) \u2192T s(Ci ) is contained in Ck then\n. type 1\n3:\nassign type 1 to Ci\n4: else if s(Ci ) = s(Ck ) then\n. type 2: Ck 6= C0 , t(Ci ) is inner vertex of Ck\n5:\nif Ci is a backedge then\n6:\nassign type 2a to Ci\n. type 2a\n7:\nelse\n8:\nassign type 2b to Ci ; mark Ci\n. type 2b\n9: else\n. type 3: s(Ci ) 6= s(Ck ), Ck 6= C0 , t(Ci ) is inner vertex of Ck\n10:\nif Ck is not marked then\n11:\nassign type 3a to Ci\n. type 3a\n12:\nelse\n. Ck is marked\n13:\nassign type 3b to Ci ; create a list Li = {Ci }; Cj := Ck\n. type 3b\n14:\nwhile Cj is marked do\n. Li is called a caterpillar\n15:\nunmark Cj ; append Cj to Li ; Cj := parent(Cj )\nLemma 8. Computing a chain decomposition of a 3-connected graph and classifying each chain\nwith Algorithm 1 takes running time O(n + m).\nDefinition 9. Let a subdivision Sl \u2286 G be upwards-closed if for each vertex in Sl the edge to\nits parent is in E(Sl ). Let Sl be modular if Sl is the union of chains.\nIn order to find BG-paths efficiently, we want to restrict every subdivision Sl to be upwardsclosed and modular. However, configurations exist where no BG-path for a subdivision Sl is a\nchain, e. g., the subdivision S3 = {C0 , C1 , C2 } in Figure 2. This violates the modularity of Sl+1\nand we have to weaken the restriction: We will allow intermediate subdivisions that are neither\nupwards-closed nor modular but demand in these cases that we can find a set of t BG-paths in\nadvance that restores these properties after t steps.\nWe impose the additional restriction that each link of Sl that consists only of tree edges has\nno parallel link, except C0 in S3 . This prevents BG-path candidates from violating property 1.3\ndue to the DFS-structure. We summarize the restrictions.\n(R1 ) For each upwards-closed and modular subdivision Sl , BG-paths are only added as single\nchains of type 1, 2a or 3a, with Sl+1 being upwards-closed and modular or as sets of\nt > 1 subsequent BG-paths constructing an upwards-closed modular subdivision Sl+t that\ndiffers from Sl in exactly t chains of types 2b and 3b.\n6\n\n\f(R2 ) For each upwards-closed and modular subdivision Sl , the links of Sl that consist only of\ntree edges of T have no parallel links, except C0 in S3 .\nWe refer to the current upwards-closed and modular subdivision in a\nconstruction sequence that is restricted by (R1 ) and (R2 ) as SlR . The existence of a restricted sequence is shown in Section 3.2. We show that chains\nof type 3a help to find BG-paths efficiently (proof omitted).\nLemma 10. Let Ci be a chain of type 3a and Ck the parent of Ci such\nthat Ck but not Ci is contained in SlR . Then Ci is a BG-path for SlR\nFigure 2: C1 and\npreserving (R1 ) and (R2 ).\nC2 are of type 1,\nC3 is of type 2b,\n3.2 Caterpillars and Existence of the Restricted Sequence\nC4 of type 2a, C5\nWhile chains of type 3a form BG-operations under the conditions of of type 3b and C6\nLemma 10, chains of types 1 and 2 in general do not. For every chain of type 3a.\nCi of type 3b, Algorithm 1 collects a list Li of chains that contains only Ci\nand chains of type 2b (see line 15). We call each list Li a caterpillar.\nDefinition 11. Let the parent of a caterpillar Lj be the parent of the chain in Lj that is minimal\nwith respect to <. Let a caterpillar Lj with parent Ck be bad for a subdivision Sl if s(Cj ) is\na descendant of t(Ck ) and s(Ck ) \u2192Ck s(Cj ) contains no inner real vertex (see Figure 3(a)).\nOtherwise, Lj is called a good caterpillar (see Figure 3(b)).\nCaterpillars bundle the single chains of type 2b, which\ncannot immediately be added as BG-paths. They also offer\na simple decomposition into successive BG-paths.\nLemma 12. Let Lj be a caterpillar that consists of t chains\nand has parent Ck . Let Ck but no chain in Lj be contained\nin SlR . If Lj is good, Lj can be efficiently decomposed into\nt successive BG-paths satisfying (R1 ) and (R2 ).\nProof. (sketch) Let y be the last vertex of the minimal chain\nin Lj and let Ch be the parent of Cj . We add either the path\nP := Cj \u222a(t(Cj ) \u2192T y), followed by Ci \\P for all chains Ci \u2208 (a) A bad cater- (b) A good caterpilLj \\{Cj } (see Figure 3(b)) or the path (Cj \u222aCh )\\((t(Cj ) \u2192T pillar Lj with lar Lj with parent\nCk .\ny) \\ {t(Cj )}), followed by t(Cj ) \u2192T y and Ci \\ (t(Cj ) \u2192T y) parent Ck .\nfor every remaining chain Ci \u2208 Lj \\ {Cj , Ch }.\nFigure 3: Kinds of caterpillars.\nDefinition 13. We define the equivalence relation \u223c on\nE(G) \\ E(Sl ) with e \u223c e for all e \u2208 E(G) \\ E(Sl ) and with e \u223c f for all e, f \u2208 E(G) \\ E(Sl ) if\nthere is a path e \u2192G f without an inner vertex in Sl . Let the segments of Sl be the subgraphs\nof G that are induced by the equivalence classes of \u223c. Let H \u2229 Sl be the attachment points of\nH.\nDefinition 14. For a chain Ci and a subdivision SlR , let Children12 (Ci ) be the set of children\nof Ci of types 1 and 2 that are not contained in SlR and let Type3 (Ci ) be the set of chains of\ntype 3 that start at a vertex in Ci and are not contained in SlR .\nThe following theorem is a key result of this paper and leads not only to an existence proof\nof the restricted construction sequence but also to an efficient algorithm for computing it.\n\n7\n\n\fTheorem 15. For a subdivision SlR , let Ci be a chain such that Children12 (Cj ) = Type3 (Cj ) =\n\u2205 holds for every proper ancestor Cj of Ci . Then all chains in Children12 (Ci ) \u222a Type3 (Ci ) and\ntheir proper ancestors that are not already contained in SlR can be successively added as BGpaths (possibly being part of caterpillars) such that (R1 ) and (R2 ) is preserved. Moreover, the\nchains in Type3 (Ci ) that are contained in segments in which the minimal chain is not contained\nin Children12 (Ci ) can be added at any point in time in arbitrary order (together with their proper\nancestors that are not contained in SlR ).\nThe precondition of Theorem 15 is met in every subdivision: For S3R , C0 is the desired\nchain and applying the Theorem on C0 allows to take the descendants of C0 in U in subsequent\nsubdivisions. This ensures the existence of the restricted construction sequence.\nCorollary 16. Let G be a 3-connected graph with a chain decomposition C = {C0 , . . . , Cm\u2212n+1 }.\nThen there is a construction sequence of G restricted by (R1 ) and (R2 ) that starts with\nS3R = {C0 \u222a C1 \u222a C2 }.\n\n4\n\nA Linear-Time Algorithm\n\nWith Lemma 8, a chain decomposition, a subdivision S3R and the classification of chains can be\ncomputed in time O(n+m). Theorem 15 provides an algorithmic method to find iteratively BGpaths building the restricted construction sequence: Iteratively for each chain Ci , 0 \u2264 i \u2264 m\u2212n,\nwe add all chains in Children12 (Ci )\u222aType3 (Ci ) (we say that Ci is processed). Note that Ci meets\nthe precondition of Theorem 15 and that Children12 (Ci ) and Type3 (Ci ) can be build in time\nO(|Ci | + |Children12 (Ci )| + |Type3 (Ci )|) by storing lists of type 3 chains at every vertex. We\npartition the chains in Type3 (Ci ) into the different segments of SlR containing them by storing\na pointer on each Cj \u2208 Type3 (Ci ) to the minimal chain D of the segment containing Cj . The\nchain D is computed by traversing T from t(Cj ) to the root until the next vertex is contained\nin SlR . The current vertex is then an inner vertex of D (each inner vertex has a pointer to\nits chain) and we mark each vertex of the traversed path with D. Further traversals get D by\nstopping at the first marker that points to a chain not in SlR . Since all traversed chains will be\nadded, the running time amortizes to a total of O(n + m).\nFirst, we add all chains in Type3 (Ci ) that are contained in segments in which the minimal\nchain is not contained in Children12 (Ci ) (this can be checked in constant time per chain).\nAccording to Theorem 15, the chains can be added in arbitrary order, as long as their proper\nancestors that are not in SlR are added before. We want to add the remaining chains in\nChildren12 (Ci ) \u222a Type3 (Ci ). However, Theorem 15 does not specify in which order the chains\nhave to be added, so we need to compute a valid order on them.\nLet Cj be a remaining chain in Type3 (Ci ) and let H be the segment containing it. Then the\nminimal chain D in H is of type 1 or 2, as it is contained in Children12 (Ci ). If D is of type 1\nor 2a, s(D), t(D), s(Cj ) and all other attachment points of H must be contained in Ci . The\nsame holds for the remaining case of D being of type 2b, as the type 3b-chain in the caterpillar\ncontaining D cannot start in a proper ancestor of Ci by assumption. Let the dependent path\nof H be the maximal path in Ci connecting two attachment points of H, e. g., for D being of\ntype 1 or 2a, the dependent path is just s(D) \u2192Ci t(D). We can compute all attachment points\nof H and therefore the dependent path of H efficiently, as the previous computation provides\nD and the set of chains H \u2229 Type3 (Ci ); we just have to add s(D) and t(D) to the start vertices\nof the latter chains.\nIf D is a chain of type 2a (thus, H = D) and t(D) is real, we can add D. Otherwise,\nrestriction (R2 ) implies that every segment H that has a dependent path P without inner real\nvertices does neither contain chains nor caterpillars forming BG-paths while preserving (R1 )\n8\n\n\fand (R2 ). Conversely, if P contains an inner real vertex, all chains in H \u2229 (Children12 (Ci ) \u222a\nType3 (Ci )) can be added: If D is of type 1, D does not violate (R2 ) and can be added and\nif D is of type 2b, the caterpillar containing D is good and can be added with Lemma 12.\nAs the minimal chain in H \\ {D} is not contained in Children12 (Ci ), the remaining chains in\nH \u2229 Type3 (Ci ), if exist, can be added as well using Theorem 15.\nFinding a valid order on the remaining chains\nin Children12 (Ci ) \u222a Type3 (Ci ) thus reduces to finding an order on their segments such that the dependent paths of the segments contain inner real\nvertices. Having this sequence would allow to add\nsubsequently H \u2229 (Children12 (Ci ) \u222a Type3 (Ci )) for\nevery segment H in this order. We map each H\nto a set I(H) of intervals in the range of the dependent path P of H: Let a1 , . . . , ak be the attachS\nment points of H and let I(H) := 1<j\u2264k {[a1 , aj ]}\u222a\nS\n1<j<k {[aj , ak ]} (see Figure 4). Additionally, we (a) The chain Ci (b) The intervals in I0 are\nmap the real vertices b1 , . . . , bk of Ci to the set of in- and the chains constructed from the real\nS\nS\nin\nType3 (Ci ) \u222a vertices in Ci .\ntervals I(Ci ) := 1<j<k {[b1 , bj ]} \u222a 1<j<k {[bj , bk ]}. Children (C\n12\ni ).\nThis construction is efficient and creates at most\n2 \u2217 (|Children12 (Ci )| + |Type3 (Ci )| + |Vreal (Ci )|) in- Figure 4: Mapping segments in C . Difi\ntervals for Ci , which amortizes to a total of O(n+m) ferent shades depict different segments.\nfor all chains.\nLet two intervals [a, b] and [c, d] overlap if a < c < b < d or c < a < d < b. Starting with\nI(Ci ), we find the next segment with an inner real vertex on its dependent path by finding a\nnext overlapping interval Cj and adding the whole segment that contains Cj . This reduction\nfinds the desired order: Clearly, an overlap induces an inner real vertex in the next interval and\ntherefore in the dependent path of the next segment. Conversely, for every segment H with an\ninner real vertex on its dependent path P , an interval can be found that overlaps with P , either\nin I(Ci ) if v was real at the beginning or in I(H 0 ) for a previously added segment H 0 (note that\nsegments having only the attachment points s(Ci ) and t(Ci ) cannot occur, as they contain no\nchain in Children12 (Ci )).\nA sequence of overlaps from I(Ci ) to every other created interval exists if and only if the\noverlap graph (i. e., the graph with intervals as vertices and edges between overlapping intervals)\nis connected. Simple sweep-line algorithms for constructing the connected components of the\noverlap graph are known [19] (Lemmas 4.1 and 4.2 suffice), run in time O(t) for t intervals and,\nthus, ensures the efficient computation of the reduction.\nTheorem 17. The construction sequences 2.(2), 2.(4), 2.(5) and 2.(6) of a 3-connected graph\ncan be computed in time O(n + m).\n\nA New Certifying 3-Connectivity Test. It remains to deal with the case when the input\ngraph G is not 3-connected. For simplicity, we assume G to be 2-connected, although the chain\ndecomposition can check this fact. If G is not 3-connected, the described algorithm fails to\nadd a BG-path due to Theorem 2 when processing some chain, say Ci . Therefore, after the\nprocessing phase for Ci , Children12 (Ci ) must still contain a chain Cj . Let H be the segment\ncontaining Cj and let H 0 \u2287 H be the set of segments that map to the connected component of\nthe interval overlap graph containing I(H). Then the union of dependent paths of the segments\nin H 0 is a path P \u2286 Ci and the two extremal attachment points on P of segments in H 0 build\n\n9\n\n\f(a) A 3-connected input\ngraph G with n = 18 and\nm = 34. Straight lines depict the edges of the DFStree T .\n\n(b) The decomposition of\nG into m \u2212 n + 2 = 18\nchains. Light solid chains\nare of type 1, dashed ones\nof type 2 and black solid\nones of type 3. The only\nchain of type 2a is C3 . The\nonly chains of type 3b are\nC14 and C16 , which create the caterpillars L14 =\n{C14 , C6 , C5 } and L16 =\n{C16 , C4 }, respectively.\n\n(c) The\nsubdivision\nS3R = {C0 , C1 , C2 } (thick\nedges).\nWe start with\nprocessing C0 .\nSince\nChildren12 (C0 ) = \u2205, we\ncan add all chains in\nType3 (C0 ) = {C7 , C8 , C9 }.\nThe first two have parents\nthat are already contained\nin S3R . We thus add one of\nthem as BG-path, say C7 .\n\n(d) The K4 -subdivision\nS4R . Its real vertices are\ndepicted in black. Note\nthat choosing C8 instead\nof C7 would have led also\nto a K4 -subdivision. After\nadding\nthe\nremaining\nchain C8 as BG-path, the\nparent of C9 is contained\nin S5R and can therefore\nbe added as well.\n\n(e) The subdivision S6R .\nWe process C1 next, but\nhave to continue to process\nC2 , as there is nothing to\nadd. According to Theorem 15, C3 , C10 , C11 , C12 ,\nC13 , C15 and the caterpillar L14 can be added.\nWe first add C11 , as its\nsegment does not contain\na chain in Children12 (C2 ).\nTo obtain the right order\nof the remaining chains, we\ngroup them by segments.\n\n(f) We map the segments\nto intervals. I(C2 ) is induced by the real vertices\nv3 , v5 and v1 . As L14 and\nC15 are in the same segment, they are mapped to\nthe same group of intervals. By overlapping intervals, we get the sequence\nof segments I(C2 ), I(C10 ),\nI(C12 ), I(C13 ), I(C3 ) and\nI(L14 \u222a C15 ). Note that\noverlapped intervals imply\nadding the whole segment.\n\nR\n(g) The subdivision S14\n.\nThe next non-trivial chain\nto process is C5 . The interval [v11 , v1 ] \u2282 I(L16 )\ncontains the inner real vertex v12 and overlaps with\n[v10 , v12 ] \u2282 I(C5 ). This\nimplies that L16 can be\nadded, forming the two\nBG-paths v11 \u2192G\\E(S15 )\nv1 and v12 \u2192T v17 .\n\nR\n(h) The subdivision S17\n.\nIt remains to process the\nchain C6 , where C17 is\nadded as the last BGpath of the construction sequence. This results in the\nR\nsubdivision S18\n, which is\nidentical to G.\n\nFigure 5: A running example of the algorithm.\n10\n\n\fa separation pair. This pair certifies that G is not 3-connected and can be computed in linear\ntime.\n\n11\n\n\fA\n\nOmitted Proofs\n\nWe give the omitted proofs and the preparatory lemmas that lead to them.\nLemma 18 (aka Lemma 8). Computing a chain decomposition of a 3-connected graph and\nclassifying each chain with Algorithm 1 takes running time O(n + m).\nProof. The DFS tree T can be obtained in time O(n + m). The subdivision S3 can be found\nin time linearly dependent on E(S3 ) by taking two arbitrary backedges ra and rb with r being\nthe root of T and finding the lowest common ancestor of a and b by traversing T upwards. The\ncomputation of each remaining chain Ci , i > 2, takes time linearly dependent on its length, too,\nwhich gives a running time of O(n + m) for the chain decomposition.\nIn order to obtain a fast classification in Algorithm 1, we store the following information on\neach chain Ci : A pointer to its parent Ck (for Ci 6= C0 ), pointers to s(Ci ) and t(Ci ) and the\ninformation whether Ci is a backedge. In addition, for each inner vertex of Ci a pointer to Ci\nis stored. That allows us to check vertices on being contained as inner vertices or end vertices\nin arbitrary chains in O(1). If Ck = C0 , we can check the condition on Ci being of type 1 in\nconstant time by testing whether s(Ci ) and t(Ci ) are contained in C0 . If Ck 6= C0 , we check in\nconstant time whether s(Ci ) and t(Ci ) are contained in Ck \\ {s(Ck )}. The condition for type 2\nneeds constant time as well. Every chain is marked at most once, therefore unmarked as most\nonce in line 15 of Algorithm 1, which gives a total running time of O(n + m).\nLemma 19. Let Sl be upwards-closed and modular. Then a BG-path P for Sl is a chain if and\nonly if Sl+1 is upwards-closed and modular.\nProof. If P is a chain, t(P ) is contained in Sl and Sl+1 must be upwards-closed and modular due\nto the DFS structure. If P is not a chain, we assume to the contrary that Sl+1 is upwards-closed\nand modular. Then P must be the union of t > 1 chains; let Ci be the first chain in P . Now P\ncannot start with t(Ci ), since s(Ci ) is in Sl and property 1.1 contradicts t > 1. Thus, P starts\nwith s(Ci ), which contradicts t > 1 as well, as Sl+1 is upwards-closed and a second chain in\nP would include another backedge in P at a vertex that is already incident to two DFS tree\nedges.\nLemma 19 shows that this restriction implies every BG-path to be a chain.\nLemma 20. Each path P in SlR having properties 1.1 and 1.2 is a BG-path. If P is additionally\na chain of type 2a or 3a, (R1 ) and (R2 ) are preserved.\nProof. For the first claim, assume to the contrary that P violates property 1.3. Then |Vreal (Sl )| \u2265\n4 must hold and Sl 6= S3 follows. Let R and Q be the parallel links of Sl that contain the end\nvertices of P as inner vertices, respectively. At least one of them, say R, contains a backedge,\nsince otherwise T would contain a cycle. Let Ci 6= C0 be the chain in Sl that contains R. Since\nCi contains exactly one backedge, s(Ci ) is an end vertex of R. If R \u2282 Ci , Q must contain a\nbackedge, as t(Ci ) is an inner real vertex of t(R) \u2192T s(R). In that case, all inner vertices of Q\nlie in a subtree of T that cannot be reached by P due to property 1.1 and Sl being upwardsclosed. Thus, R = Ci and with the same argument Q = t(Ci ) \u2192T s(Ci ) holds. With (R2 ), Sl\nmust be S3 and Q = C0 , which contradicts our assumption.\nFor the second claim, each chain Ci of type 2 or 3 has by definition an inner real vertex in\nt(Ci ) \u2192T s(Ci ) and therefore preserves (R2 ). If Ci is of type 2a or 3a, (R1 ) is preserved as well,\nas Sl+1 is upwards-closed and modular with Lemma 19.\nWe show that chains of type 3a help to find BG-paths efficiently (Lemma 10) as part of\nthe following Lemma.\n12\n\n\f(i) allowed\n\n(j)\nden\n\nforbid-\n\nFigure 5: The effect of restriction (R2 ) on the dashed BG-path.\n\nFigure 6: A chain Ci 6\u2286 Sl of type 3.\nLemma 21 (aka Lemma 10). Let Ck be the parent of a chain Ci 6= C0 .\n\u2013 If Ci is not of type 1, Ck 6= C0 and t(Ci ) is an inner vertex of Ck .\n\u2013 Let Ck but not Ci be contained in SlR . If Ci is either of type 1 with an inner real vertex\nin t(Ci ) \u2192T s(Ci ) or of type 3a, Ci is a BG-path for SlR preserving (R1 ) and (R2 ).\nProof. Assume to the contrary that Ci is not of type 1 and Ck = C0 . Because t(Ci ) is contained\nin C0 , s(Ci ) must be in C0 as well. But then Ci would be of type 1, since t(Ci ) \u2192T s(Ci ) \u2286 C0 .\nTherefore, if Ci is not of type 1, Ck 6= C0 holds and Ck must start with a backedge. Then the\ndefinition of the parent relation implies that t(Ci ) is an inner vertex of Ck .\nFor the second claim, let Ci first be of type 3a. Since Sl is upwards-closed, modular and\ncontains Ck , Ci satisfies the property 1.1 of BG-paths. In addition, s(Ci ) 6= s(Ck ) holds by\ndefinition and with Ck < Ci , s(Ci ) must be an inner vertex of the path t(Ck ) \u2192T s(Ck ) (see\nFigure 6). Therefore, the only chains Cj that contain s(Ci ) and t(Ci ) are different from C0 and\nfulfill Ci \u2229 Cj = {s(Ci ), t(Ci )} = {s(Cj ), t(Cj )}. This implies Ci having property 1.2. Using\nLemma 20, Ci is a BG-path for Sl that preserves (R1 ) and (R2 ).\nIf Ci is of type 1, property 1.1 follows from the same argument as before. Additionally, the\ninner real vertex in t(Ci ) \u2192T s(Ci ) prevents any link containing s(Ci ) and t(Ci ) from having\ns(Ci ) or t(Ci ) as an inner vertex and therefore ensures property 1.2. Lemma 20 implies that Ci\nis a BG-path for Sl and Ci must preserve (R1 ) and (R2 ), the latter due to the inner real vertex\nin t(Ci ) \u2192T s(Ci ).\nProposition 22. Every caterpillar Lj consists of exactly one chain of type 3b, namely the chain\nCj , and one or more chains of type 2b.\n13\n\n\fLemma 23. C \\ {C0 } is partitioned into single chains of types 1, 2a, 3a and the chains being\ncontained in caterpillars. Moreover, no chain is contained in two caterpillars.\nProof. With Proposition 22, it remains to show that every chain Ci of type 2b or 3b is contained\nin exactly one caterpillar. If Ci is of type 3b, Ci is part of the caterpillar Li (see Algorithm 1,\nline 13) and will not be assigned to a second caterpillar afterwards, as it is not marked. Otherwise, Ci is of type 2b and was therefore marked. We show that, after all chains in C have been\nclassified, Ci is not marked anymore. This forces Ci to be contained in exactly one caterpillar,\nas the only way to unmark chains is to assign them to a caterpillar (see Algorithm 1, line 15)\nand no chain is marked twice.\nLet Ck be the parent of Ci . Because Ci is of type 2b, s(Ci ) = s(Ck ) holds and Ci is not a\nbackedge, implying that the last edge e of Ci is in T . Let x be the end vertex of e different from\nt(Ci ). Using Lemma 21, Ck 6= C0 holds and t(Ci ) is an inner vertex of Ck . Then at least one\nbackedge vw with v \u2208\n/ {s(Ci ), t(Ci )} must enter T (x), since otherwise s(Ci ) and t(Ci ) would be\na separation pair of G. Let Cj be the minimal chain with respect to < that contains such a\nbackedge.\nAs Cj > Ci holds , the vertex v is an inner vertex of t(Ci ) \u2192T s(Ci ), implying that Cj is\nnot of type 2. In addition, Cj is not of type 1, since t(Cj ) \u2192T v contains edges from Ci and\nCk . At the time Cj is found in the chain decomposition, every chain that already ends at a\nvertex in T (x) starts at s(Ci ) and is therefore of type 2a or 2b. Since chains that are backedges\ncannot have children, the parent of Cj is marked and Cj is of type 3b. Moreover, every chain\ncorresponding to an inner vertex of the path Cj \u2192U Ci is marked. This concludes Ci to become\nunmarked due to line 15 of Algorithm 1.\nThe following gives the detailed proof of Lemma 12.\nLemma 24 (aka Lemma 12). Let Lj be a caterpillar that consists of t chains and has parent\nCk . Let Ck but no chain in Lj be contained in SlR . Then, if and only if Lj is good, the chains\nin Lj can be efficiently decomposed into t successive BG-paths satisfying (R1 ) and creating\nR , each of which satisfies (R ).\nsubdivisions Sl+1 , Sl+2 , . . . , Sl+t\u22121 , Sl+t\n2\nProof. Let Lj be good and let y be the last vertex of the minimal chain in Lj , thus y \u2208 V (Ck ).\nWe assume at first that s(Cj ) is a proper ancestor of t(Ck ) (see Figure 3(b)). Then the path\nP = Cj \u222a (t(Cj ) \u2192T y) fulfills properties 1.1 and 1.2 and is a BG-path for Sl with Lemma 20.\nAdding P preserves Sl to be upwards-closed but not modular. The restriction (R2 ) is also\npreserved, as t(Ck ) is real and, for Sl = S3 , Ck must be either C1 or C2 , implying that s(P )\nbecomes an inner real vertex of C0 . Successively, for each chain Ci of the t\u22121 chains in Li \\{Cj },\nwe now add Ci \\ P , which is a BG-path yielding an upwards-closed subdivision for analogue\nreasons.\nNow assume that s(Cj ) is a descendant of t(Ck ) (see Figure 3(a)). Then s(Cj ) \u2208 V (Ck )\nand since Lj is good, there is a real vertex a strictly between s(Cj ) and s(Ck ) in Ck . We first\nshow that t(Ck ) \u2192T s(Ck ) contains an inner real vertex as well. Assume the contrary. Then\nCk must be of type 1 and has been added before, contradicting restriction (R2 ) unless Sl = S3 .\nBut Sl must be different from S3 , since a exists, and it follows that t(Ck ) \u2192T s(Ck ) contains\nan inner real vertex b. Let Ch be the parent of Cj . Then (Cj \u222a Ch ) \\ ((t(Cj ) \u2192T y) \\ {t(Cj )}) is\na BG-path due to the real vertices a and b and we add it, although it neither preserves Sl+1 to\nbe upwards-closed nor modular. We next add t(Cj ) \u2192T y, which restores upwards-closedness.\nThe resulting subdivisions Sl+1 and Sl+2 both satisfy (R2 ), as b is real in Sl+1 and Sl+2 and y is\nreal in Sl+2 . We proceed with adding successively paths, namely for each chain Ci of the t \u2212 2\nremaining chains in Li \\ {Cj , Ch } the path Ci \\ (t(Cj ) \u2192T y). With the same line of argument,\nthese paths obtain upwards-closed subdivisions Sl+3 , . . . , Sl+t , each of which satisfies (R2 ).\n14\n\n\f(a) 25.1\n\n(b) 25.2\n\n(c) 25.3\n\nFigure 7: The three exceptions of Lemma 25. The black vertices in 25.1 and 25.3 can also be\nnon-real.\nIn both cases, Sl+t is modular, since Lj is a list of chains. Moreover, the t chosen BG-paths\npreserve (R1 ), as the chains in Lj are of types 2b and 3b only, t > 1 holds and Sl+t is upwardsclosed. All paths can be computed in time linearly dependent on the total number of edges in\nLj .\nFor the only if part, let P1 and P2 be the first two BG-paths in a decomposition of the chains\nin Lj ; these exist, since t > 1 holds in every caterpillar. Let Lj be bad, as otherwise the claim\nfollows. Then s(Cj ) \u2208 V (Ck ). We show that Lj cannot be bad, as Sl contains a real vertex in\nCk strictly between s(Cj ) and s(Ck ). Because of properties 1.1 and 1.2, P1 \u2229Sl = {s(Ck ), s(Cj )}\nmust hold and P1 is a link of Sl+1 being parallel to s(Cj ) \u2192Ck s(Ck ). Since only the chain of\ntype 3b in Lj starts at s(Cj ), both end vertices of P2 must be different from s(Cj ). Then, due\nto properties 1.1 and 1.2, P2 joins inner vertices of the parallel links P1 and s(Cj ) \u2192Ck s(Ck )\nin Sl+1 , contradicting property 1.3, as |Vreal (Sl+1 )| \u2265 4.\nLemma 25. Let Ci be a chain of type 3 such that s(Ci ) \u2208 V (SlR ), Ci 6\u2286 SlR and Ci is minimal\namong the chains of type 3 in its segment H. Let D1 > . . . > Dk be all ancestors of Ci in\nH with D1 = Ci and Dk being the minimal chain in H. Then all chains Dk , . . . , D1 can be\nsuccessively added as BG-paths preserving (R1 ) and (R2 ) (possibly being part of caterpillars),\nunless one of the following exceptions holds:\n1. Ci is of type 3a, k = 2, Dk is of type 1, s(Ci ) is an inner vertex of t(Dk ) \u2192T s(Dk ) and\nthere is no inner real vertex in t(Dk ) \u2192T s(Dk ) (Figure 7(a)),\n2. Ci is of type 3b, Dk is of type 2b and Li = {D1 , . . . , Dk } with Li being bad (Figure 7(b)),\n3. Ci is of type 3b, Li = {D1 , . . . , Dk\u22121 }, Dk is of type 1, s(Ci ) is an inner vertex of\nt(Dk ) \u2192T s(Dk ) and there is no inner real vertex in t(Dk ) \u2192T s(Dk ) (Figure 7(c)).\nProof. Let D \u2208 {D2 , . . . , Dk }. Then D is not of type 3 by assumption and not of type 2a,\nas chains of that type cannot have children. Assume that D is of type 2b and let Lj be the\ncaterpillar containing D due to Lemma 23. If Cj 6= Ci , Cj < Ci holds, as otherwise Cj would\n15\n\n\f(a) Cj cannot be contained in exceptions 25.1 and 25.3.\n\n(b) Cj cannot be contained in\nexception 25.2.\n\nFigure 8: After Ci was added, the next minimal chain Cj is in no exception.\nnot be the chain of type 3b in Lj . But then Cj contradicts the minimality of Ci , since Cj is\nnot contained in Sl and of type 3b. We conclude that every chain in {D2 , . . . , Dk } of type 2b is\ncontained in Li and forces Ci to be of type 3b. This is used in the following case distinction.\nLet Ci be of type 3a. If k = 1, Ci is a BG-path for Sl with Lemma 21 and the claim follows.\nOtherwise, k > 1 and all chains in {D2 , . . . , Dk } are of type 1. Then s(D2 ) is a proper ancestor\nof s(Ci ), since D2 < Ci and Ci is not of type 2. Moreover, s(Ci ) is a proper ancestor of t(D2 ),\nbecause otherwise H \u2229 Sl = {s(D2 ), t(D2 )} is a separation pair of G due to the minimality of\nCi . It follows that s(Ci ) is an inner vertex of t(D2 ) \u2192T s(D2 ). If k > 2, D3 must contain\nt(D2 ) \u2192T s(D2 ), because D2 is of type 1 and a child of D3 . Therefore, the edge e joining\ns(Ci ) with the parent of s(Ci ) in T is contained in D3 . But since Sl is upwards-closed, e is also\ncontained in Sl , contradicting that D3 6\u2286 Sl . Thus, k = 2. If t(D2 ) \u2192T s(D2 ) contains an inner\nreal vertex, D2 and Ci can be subsequently added as BG-paths with Lemma 21, otherwise 25.1\nis satisfied.\nLet Ci be of type 3b. Then all chains in {D2 , . . . , Dk } that are of type 2b must be contained\nin Li . Since every caterpillar Lj contains the parent of the chain Cj and since Sl contains no\nchain in Li due to (R1 ), k > 1 holds and D2 is of type 2b with D2 \u2208 Li . Let Dt with 1 < t \u2264 k\nbe the minimal chain in Li . If t = k and Li is good, all chains in Li can be decomposed to\nBG-paths according to Lemma 12. If t = k and Li is bad, 25.2 is satisfied. Only the case k > t\nremains. Then Dt+1 is of type 1 and, using the same arguments as in the case for type 3a, s(Ci )\nis an inner vertex of t(Dk ) \u2192T s(Dk ) and k = t + 1. If t(Dk ) \u2192T s(Dk ) contains an inner real\nvertex, Lemmas 21 and 12 imply that Dk and Li can be iteratively added as set of successive\nBG-paths, preserving (R1 ) and (R2 ). Otherwise, 25.3 is satisfied.\nWe extend Lemma 25 to non-minimal chains of type 3.\nLemma 26. Let the preconditions of Lemma 25 hold. If Ci is not contained in one of the\nexceptions 25.1-25.3 (as Ci ), the chains of type 3 in H that start in SlR and their ancestors in\nH can be successively added as BG-paths (in reversed order), preserving (R1 ) and (R2 ).\nProof. Using Lemma 25, we add the chains Ci , D2 , . . . , Dk in H as BG-paths. This partitions\nH into new segments; let H 0 \u2286 H \\ {Ci , D2 , . . . , Dk } be such a new segment. If H 0 does not\n16\n\n\fcontain chains of type 3 that start in Sl , the claim follows for such chains in H 0 . Otherwise,\nlet Cj be the minimal chain of type 3 in H 0 that starts in Sl and let Cj > D20 > . . . > Dk0\nbe its ancestors in H 0 . We show that Cj is not contained in one of the exceptions 25.1-25.3\nand can therefore be added as BG-path with Lemma 25, along with its proper ancestors in H 0 .\nFirst, assume to the contrary that Cj is contained in exception 25.1 or 25.3 (see Figure 8(a)).\nBecause Dk0 is a proper descendant of Dk and Dk0 is of type 1, s(Cj ) \u2208 V (Sl ) cannot be an\ninner vertex of t(Dk0 ) \u2192T s(Dk0 ), contradicting the assumption. Now assume to the contrary\nthat Cj is contained in exception 25.2 (see Figure 8(b)). Then Cj is of type 3b and part of a\nbad caterpillar Lj , whose parent D is not contained in H 0 . Because Lj contains only chains in\nH 0 , D must be a descendant of Dk and is therefore contained in H \\ H 0 . Since Lj is bad, s(Cj )\nis contained in Sl \u2229 D and it follows with s(Cj ) 6= s(D) that D must end in Sl at the vertex\ns(Cj ). As Dk is the only chain in H that ends in Sl , D = Dk must hold. But this contradicts\nLj being bad, as D contains the inner real vertex s(Dk\u22121 ). Thus, Cj and its ancestors in H 0\ncan be added, partitioning H 0 into smaller segments. Iterating the same argument for these\nsegments establishes the claim for all chains of type 3 in H that start in Sl .\nThe next lemma shows that the only chains of type 1 that cannot be added are either\nbackedges or are contained as Dk in exceptions 25.1-25.3.\nLemma 27. Let Cj be a chain in SlR and let Dk be a child of Cj that is of type 1 and not in SlR .\nIf Dk is not a backedge, there is a chain of type 3 in the segment containing Dk that starts in\nt(Dk ) \u2192T s(Dk ) \u2282 Cj . If Dk is neither a backedge nor contained (as Dk ) in the exceptions 25.1\nand 25.3, Dk can be added as BG-path.\nProof. Let H be the segment of Dk and assume that Dk is not a backedge. We first show that\nH contains a chain of type 3 that starts in t(Dk ) \u2192T s(Dk ). We can assume that Dk is not\ncontained in the exceptions 25.1 and 25.3, as then H would contain such a chain by definition.\nLet x be the last but one vertex in Dk . Since G is 3-connected, there is a minimal chain Ci\nentering T (x) such that s(Ci ) is an inner vertex of t(Dk ) \u2192T s(Dk ), as otherwise the inner\nvertices of Dk would be separated by {s(Dk ), t(Dk )}. By definition of the chain decomposition,\nCi must be of type 3a or 3b. Because Dk is not contained in exceptions 25.1 and 25.3 and H\ncannot contain exception 25.2, Lemma 25 can be applied on Ci , obtaining the last claim.\nHere we give the proof of the key theorem (Theorem 15) of the paper.\nTheorem 28 (aka Theorem 15). For a subdivision SlR , let Ci be a chain such that Children12 (Cj ) =\nType3 (Cj ) = \u2205 holds for every proper ancestor Cj of Ci . Then all chains in Children12 (Ci ) \u222a\nType3 (Ci ) and their proper ancestors that are not already contained in SlR can be successively\nadded as BG-paths (possibly being part of caterpillars) such that (R1 ) and (R2 ) is preserved.\nMoreover, the chains in Type3 (Ci ) that are contained in segments in which the minimal chain\nis not contained in Children12 (Ci ) can be added at any point in time in arbitrary order (together\nwith their proper ancestors that are not contained in SlR ).\nProof. By assumption, Ci is contained in Sl . Let D 6\u2286 Sl be a child of Ci . If Ci = C0 , D must be\nof type 1. Let Ci 6= C0 . Then D cannot be of type 3b, as otherwise it would be contained in Sl\ndue to (R1 ) and Ci \u2282 Sl . It is neither of type 3a, since in that case s(D) is contained in a proper\nancestor of Ci , implying D \u2282 Sl by assumption. We conclude that D is of type 1 or 2 and focus\non the cases where D can not be added. Let P be the path on which D depends on. If D is of\ntype 1, P does not contain an inner real vertex, as otherwise D can be added as BG-path due\nto Lemma 21. With Lemma 27, D must be either a backedge or be contained as the minimal\nchain in exception 25.1 or 25.3. If D is of type 2a, s(Ci ) is real and neither t(D) nor an inner\n17\n\n\fvertex in P can be real, since otherwise D can be added as BG-path, preserving (R1 ) and (R2 ).\nIf D is of type 2b, D is the minimal chain of a caterpillar La with parent Ci . According to\nLemma 12, La is bad and, thus, corresponds to exception 25.2. The following is a list of the\npossible cases for which a child D of Ci is not added.\n1. D is of type 1 without an inner real vertex in P and either a backedge or the minimal\nchain in exception 25.1 or 25.3\n2. Ci 6= C0 and D is of type 2a without a real vertex in P \\ {s(D)}\n3. Ci 6= C0 and D is of type 2b without an inner real vertex in P (D is the minimal chain in\nexception 25.2)\nWe iteratively add all chains D in X 0 \u222a \u0307 Y 0 that do not satisfy one of the above three\ncases 15.1-15.3 for D \u2208 X 0 and whose segments do not contain one of the exceptions 25.1-25.3\nfor D \u2208 Y 0 (the latter followed by adding the proper ancestors in the segment of D according\nto Lemma 26). Let X be the set of remaining chains in X 0 and let Y be the set of remaining\nchains in Y 0 . If X = \u2205, Y = \u2205 holds as well, as otherwise the minimal chain in the segment\ncontaining one of the exceptions 25.1-25.3 is a child of Ci , contradicting X = \u2205. This implies\nthe claim for X = \u2205.\nWe prove the theorem by showing that X = \u2205 must hold. Assume to the contrary that\nX 6= \u2205 and let St be the current subdivision (all segments will be dependent on St ). Then\nCi must contain a link L of length at least two, because the dependent path P in each of the\ncases 15.1-15.3 is in Ci and contains a non-real vertex due to the 3-connectivity and simpleness\nof G. According to Lemma 4, L contains an inner vertex v on which a BG-path B starts (not\nnecessarily being a chain and not necessarily preserving (R1 ) or (R2 )). Let e be the first edge\nof B. Then e is not contained in the segment of any x \u2208 X, as otherwise B would not have\nproperty 1.2, because v is non-real and all start vertices of the chains in the segment of x that\nare in St are contained in L. Thus, C(e) cannot be a child of Ci and it follows that s(C(e)) = v.\nIn particular, C(e) is not of type 1.\nThe segment of e cannot contain a chain of type 3 that starts in Ci , as it otherwise contains\na chain x \u2208 X of type 1 or 2b due to exceptions 25.1-25.3, contradicting the previous argument.\nIn particular, C(e) is not of type 3 and the only remaining case is that C(e) is of type 2.\nLet Ck be the maximal ancestor of C(e) that is not of type 2. Then s(Ck ) = v holds by\nconstruction of the chain decomposition and Ck must be contained in the segment of C(e) due\nto (R1 ), (R2 ) and v being non-real. Since the segment of e cannot contain a chain of type 3 that\nstarts in Ci , Ck must be of type 1. But then, as v is an inner vertex of L, Ck must be a child of\nCi , contradicting that e is not contained in the segment of any x \u2208 X. This is a contradiction\nto the existence of B and it follows that X = \u2205, which implies the claim.\n\nReferences\n[1] S. Albroscheit. Ein Algorithmus zur Konstruktion gegebener 3-zusammenh\u00e4ngender Graphen (in\nGerman). Diploma thesis, Freie Universit\u00e4t Berlin, 2006.\n[2] D. W. Barnette and B. Gr\u00fcnbaum. On Steinitz's theorem concerning convex 3-polytopes and on\nsome properties of 3-connected graphs. Many Facets of Graph Theory, Lecture Notes in Mathematics, 110:27\u201340, 1969.\n[3] V. Batagelj. Inductive classes of graphs. In Proceedings of the 6th Yugoslav Seminar on Graph\nTheory, pages 43\u201356, Dubrovnik, 1986.\n\n18\n\n\f[4] V. Batagelj. An improved inductive definition of two restricted classes of triangulations of the plane.\nIn Combinatorics and Graph Theory, Banach Center Publications, volume 25, pages 11\u201318. PWN\nWarsaw, 1989.\n[5] G. D. Battista and R. Tamassia. On-line graph algorithms with SPQR-trees. In Proceedings of\nthe 17th International Colloquium on Automata, Languages and Programming (ICALP'90), pages\n598\u2013611, 1990.\n[6] P. Bertolazzi, G. D. Battista, C. Mannino, and R. Tamassia. Optimal upward planarity testing of\nsingle-source digraphs. SIAM J. Comput., 27(1):132\u2013169, 1998.\n[7] M. Blum and S. Kannan. Designing programs that check their work. In Proceedings of the 21st\nAnnual ACM Symposium on Theory of Computing (STOC'89), pages 86\u201397, New York, 1989.\n[8] N. Chiba and T. Nishizeki. The Hamiltonian cycle problem is linear-time solvable for 4-connected\nplanar graphs. J. Algorithms, 10(2):187\u2013211, 1989.\n[9] A. Elmasry, K. Mehlhorn, and J. M. Schmidt. A linear-time certifying triconnnectivity algorithm for\nHamiltonian graphs, preprint available at http://www.mpi-inf.mpg.de/~mehlhorn/ftp/Hamilton.\npdf.\n[10] Z. Galil and G. F. Italiano. Reducing edge connectivity to vertex connectivity. SIGACT News,\n22(1):57\u201361, 1991.\n[11] M. R. Garey, D. S. Johnson, and R. E. Tarjan. The planar Hamiltonian circuit problem is NPcomplete. SIAM J. Comput., 5(4):704\u2013714, 1976.\n[12] C. Gutwenger, P. Mutzel, and R. Weiskircher. Inserting an edge into a planar graph. In Proceedings\nof the 12th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA'01), pages 246\u2013255,\n2001.\n[13] J. E. Hopcroft and R. E. Tarjan. Dividing a graph into triconnected components. SIAM J. Comput.,\n2(3):135\u2013158, 1973.\n[14] E. L. Johnson. A proof of the four-coloring of the edges of a regular three-degree graph. Technical\nreport, O. R. C. 63-28 (R. R.) Min. Report, Univ. of California, Operations Research Center, 1963.\n[15] D. Kratsch, R. M. McConnell, K. Mehlhorn, and J. P. Spinrad. Certifying algorithms for recognizing\ninterval graphs and permutation graphs. SIAM J. Comput., 36(2):326\u2013353, 2006. Preliminary\nversion in SODA 2003, pp. 158\u2013167.\n[16] K. Mehlhorn and S. N\u00e4her. From algorithms to working programs: On the use of program checking\nin LEDA. In Proceedings of the 23rd International Symposium on Mathematical Foundations of\nComputer Science (MFCS'98), pages 84\u201393, 1998.\n[17] K. Mehlhorn, S. N\u00e4her, M. Seel, R. Seidel, T. Schilz, S. Schirra, and C. Uhrig. Checking geometric\nprograms or verification of geometric structures. Comput. Geom. Theory Appl., 12(1-2):85\u2013103,\n1999.\n[18] P. Mutzel. The SPQR-tree data structure in graph drawing. In Proceedings of the 30th International\nColloquium on Automata, Languages and Programming (ICALP'03), pages 34\u201346, 2003.\n[19] S. Olariu and A. Y. Zomaya. A time- and cost-optimal algorithm for interlocking sets \u2013 With\napplications. IEEE Trans. Parallel Distrib. Syst., 7(10):1009\u20131025, 1996.\n[20] J. M. Schmidt. Construction sequences and certifying 3-connectedness. In Proceedings of the 27th\nInternational Symposium on Theoretical Aspects of Computer Science (STACS'10), Nancy, France,\npages 633\u2013644, 2010.\n[21] C. Thomassen. Kuratowski's theorem. Journal of Graph Theory, 5(3):225\u2013241, 1981.\n[22] C. Thomassen. Reflections on graph theory. Journal of Graph Theory, 10(3):309\u2013324, 2006.\n[23] W. T. Tutte. A theorem on planar graphs. Trans. Amer. Math. Soc., 82:99\u2013116, 1956.\n[24] W. T. Tutte. A theory of 3-connected graphs. Indag. Math., 23:441\u2013455, 1961.\n\n19\n\n\f[25] W. T. Tutte. Connectivity in graphs. In Mathematical Expositions, volume 15. University of Toronto\nPress, 1966.\n[26] K.-P. Vo. Finding triconnected components of graphs. Linear and Multilinear Algebra, 13:143\u2013165,\n1983.\n[27] K.-P. Vo. Segment graphs, depth-first cycle bases, 3-connectivity, and planarity of graphs. Linear\nand Multilinear Algebra, 13:119\u2013141, 1983.\n\n20\n\n\f"}