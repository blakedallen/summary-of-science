{"id": "http://arxiv.org/abs/1112.2245v1", "guidislink": true, "updated": "2011-12-10T03:42:28Z", "updated_parsed": [2011, 12, 10, 3, 42, 28, 5, 344, 0], "published": "2011-12-10T03:42:28Z", "published_parsed": [2011, 12, 10, 3, 42, 28, 5, 344, 0], "title": "Decryptable to Your Eyes: Visualization of Security Protocols at the\n  User Interface", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1112.0009%2C1112.0894%2C1112.3236%2C1112.0096%2C1112.2681%2C1112.2987%2C1112.0303%2C1112.5000%2C1112.3310%2C1112.0185%2C1112.0652%2C1112.1081%2C1112.4290%2C1112.3096%2C1112.0799%2C1112.3265%2C1112.4968%2C1112.4433%2C1112.5286%2C1112.5667%2C1112.1442%2C1112.4380%2C1112.3991%2C1112.5313%2C1112.0993%2C1112.1744%2C1112.4779%2C1112.2470%2C1112.3350%2C1112.0515%2C1112.2796%2C1112.2245%2C1112.2131%2C1112.6096%2C1112.0495%2C1112.3486%2C1112.4074%2C1112.2642%2C1112.2333%2C1112.2072%2C1112.0058%2C1112.5128%2C1112.2908%2C1112.1468%2C1112.0464%2C1112.3430%2C1112.5539%2C1112.2926%2C1112.5643%2C1112.2694%2C1112.4057%2C1112.1244%2C1112.6164%2C1112.3473%2C1112.2114%2C1112.5805%2C1112.2886%2C1112.4140%2C1112.4671%2C1112.2151%2C1112.5188%2C1112.5754%2C1112.1444%2C1112.2225%2C1112.3168%2C1112.5266%2C1112.4083%2C1112.2774%2C1112.3628%2C1112.4902%2C1112.5307%2C1112.5386%2C1112.5033%2C1112.1463%2C1112.5122%2C1112.3770%2C1112.3000%2C1112.2563%2C1112.2990%2C1112.1881%2C1112.0621%2C1112.4047%2C1112.4273%2C1112.6311%2C1112.2075%2C1112.4258%2C1112.0487%2C1112.1912%2C1112.5603%2C1112.2461%2C1112.3328%2C1112.4896%2C1112.5235%2C1112.2169%2C1112.4966%2C1112.5207%2C1112.3931%2C1112.0105%2C1112.1435%2C1112.5583%2C1112.5521&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Decryptable to Your Eyes: Visualization of Security Protocols at the\n  User Interface"}, "summary": "The design of authentication protocols, for online banking services in\nparticular and any service that is of sensitive nature in general, is quite\nchallenging. Indeed, enforcing security guarantees has overhead thus imposing\nadditional computation and design considerations that do not always meet\nusability and user requirements. On the other hand, relaxing assumptions and\nrigorous security design to improve the user experience can lead to security\nbreaches that can harm the users' trust in the system.\n  In this paper, we demonstrate how careful visualization design can enhance\nnot only the security but also the usability of the authentication process. To\nthat end, we propose a family of visualized authentication protocols, a\nvisualized transaction verification, and a \"decryptable to your eyes only\"\nprotocol. Through rigorous analysis, we verify that our protocols are immune to\nmany of the challenging authentication attacks applicable in the literature.\nFurthermore, using an extensive case study on a prototype of our protocols, we\nhighlight the potential of our approach for real-world deployment: we were able\nto achieve a high level of usability while satisfying stringent security\nrequirements.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1112.0009%2C1112.0894%2C1112.3236%2C1112.0096%2C1112.2681%2C1112.2987%2C1112.0303%2C1112.5000%2C1112.3310%2C1112.0185%2C1112.0652%2C1112.1081%2C1112.4290%2C1112.3096%2C1112.0799%2C1112.3265%2C1112.4968%2C1112.4433%2C1112.5286%2C1112.5667%2C1112.1442%2C1112.4380%2C1112.3991%2C1112.5313%2C1112.0993%2C1112.1744%2C1112.4779%2C1112.2470%2C1112.3350%2C1112.0515%2C1112.2796%2C1112.2245%2C1112.2131%2C1112.6096%2C1112.0495%2C1112.3486%2C1112.4074%2C1112.2642%2C1112.2333%2C1112.2072%2C1112.0058%2C1112.5128%2C1112.2908%2C1112.1468%2C1112.0464%2C1112.3430%2C1112.5539%2C1112.2926%2C1112.5643%2C1112.2694%2C1112.4057%2C1112.1244%2C1112.6164%2C1112.3473%2C1112.2114%2C1112.5805%2C1112.2886%2C1112.4140%2C1112.4671%2C1112.2151%2C1112.5188%2C1112.5754%2C1112.1444%2C1112.2225%2C1112.3168%2C1112.5266%2C1112.4083%2C1112.2774%2C1112.3628%2C1112.4902%2C1112.5307%2C1112.5386%2C1112.5033%2C1112.1463%2C1112.5122%2C1112.3770%2C1112.3000%2C1112.2563%2C1112.2990%2C1112.1881%2C1112.0621%2C1112.4047%2C1112.4273%2C1112.6311%2C1112.2075%2C1112.4258%2C1112.0487%2C1112.1912%2C1112.5603%2C1112.2461%2C1112.3328%2C1112.4896%2C1112.5235%2C1112.2169%2C1112.4966%2C1112.5207%2C1112.3931%2C1112.0105%2C1112.1435%2C1112.5583%2C1112.5521&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The design of authentication protocols, for online banking services in\nparticular and any service that is of sensitive nature in general, is quite\nchallenging. Indeed, enforcing security guarantees has overhead thus imposing\nadditional computation and design considerations that do not always meet\nusability and user requirements. On the other hand, relaxing assumptions and\nrigorous security design to improve the user experience can lead to security\nbreaches that can harm the users' trust in the system.\n  In this paper, we demonstrate how careful visualization design can enhance\nnot only the security but also the usability of the authentication process. To\nthat end, we propose a family of visualized authentication protocols, a\nvisualized transaction verification, and a \"decryptable to your eyes only\"\nprotocol. Through rigorous analysis, we verify that our protocols are immune to\nmany of the challenging authentication attacks applicable in the literature.\nFurthermore, using an extensive case study on a prototype of our protocols, we\nhighlight the potential of our approach for real-world deployment: we were able\nto achieve a high level of usability while satisfying stringent security\nrequirements."}, "authors": ["DaeHun Nyang", "Abedelaziz Mohaisen", "Taekyoung Kwon", "Brent Kang", "Angelos Stavrou"], "author_detail": {"name": "Angelos Stavrou"}, "author": "Angelos Stavrou", "arxiv_comment": "15 pages, 13 figures, 5 tables", "links": [{"href": "http://arxiv.org/abs/1112.2245v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1112.2245v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1112.2245v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1112.2245v1", "journal_reference": null, "doi": null, "fulltext": "arXiv:1112.2245v1 [cs.CR] 10 Dec 2011\n\nDecryptable to Your Eyes: Visualization of Security\nProtocols at the User Interface\nDaeHun Nyang\n\nAbedelaziz Mohaisen\u2217\n\nTaekyoung Kwon\n\nInha University\nIncheon, Korea\n\nUniversity of Minnesota\nMinneapolis, Minnesota 55455\n\nSejong University\nSeoul, Korea\n\nBrent Kang\n\nAngelos Stavrou\n\nGeorge Mason University\nFairfax, Virginia 22030\n\nGeorge Mason University\nFairfax, Virginia 22030\n\nABSTRACT\n\nstealing attacks and channel breaking attacks [20]. Credentials-\nsuch as users identifiers, passwords, and keys-can be stolen\nby an attacker when they are poorly managed. For example,\na poorly managed personal computer (PC) infected with a\nmalicious software (malware) is an easy target for credential attackers [45, 41]. On the other hand, channel breaking\nattacks-which allow for eavesdropping on communication\nbetween users and a financial institution-are another form\nof exploitation [22]. While classical channel breaking attacks can be prevented by a proper usage of security channel\nsuch as IPSec [14] and SSL (secure sockets layer) [38], recent channel breaking attacks are more challenging. Indeed,\n\"shoulder-surfing\" attacks-or those that utilize session hijacking, phishing and pharming, visual fraudulence, and key\nlogging- cannot be addressed by data encryption.\nChief among this class of attacks are keyloggers [19, 41,\n39]. A keylogger is software designed to capture all user's\nkeyboard strokes and make use of them to impersonate a user\nin financial transactions. For example, whenever a user types\nin her password in a bank's sign-in box, the keylogger intercepts the password. The threat of malware is pervasive\nand can be present both in personal computers and public\nkiosks. There are cases where it is necessary to perform financial transactions using a public computer. The biggest\nconcern is that a user's password is likely to be stolen. Even\nworse, keyloggers, often rootkitted, are hard to detect since\nthey will not show up in the task manager process list.\nTo mitigate the keylogger attack, a virtual keyboard or\nan onscreen keyboard with random keyboard arrangement\nhas been introduced. Rearranging alphabets randomly on\nthe keycaps can frustrate simple keyloggers. Unfortunately,\nthe keylogger software, which has the control over the entire PC, can easily capture every event and read the video\nbuffer to create a mapping between the clicks and the new\nalphabet. Another approach is to use the keyboard hooking\nprevention technique by perturbing the keyboard interrupt\nvector table [37]. However, this technique is not universal\nand can interfere with the operating system and native device drivers. Also, there is another avenue for event hooking\nbypassing this defense rendering it ineffective.\n\nThe design of authentication protocols, for online banking\nservices in particular and any service that is of sensitive nature in general, is quite challenging. Indeed, enforcing security guarantees has overhead thus imposing additional computation and design considerations that do not always meet\nusability and user requirements. On the other hand, relaxing assumptions and rigorous security design to improve the\nuser experience can lead to security breaches that can harm\nthe users' trust in the system.\nIn this paper, we demonstrate how careful visualization\ndesign can enhance not only the security but also the usability of the authentication process. To that end, we propose a family of visualized authentication protocols, a visualized transaction verification, and a \"decryptable to your\neyes only\" protocol. Through rigorous analysis, we verify\nthat our protocols are immune to many of the challenging\nauthentication attacks applicable in the literature. Furthermore, using an extensive case study on a prototype of our\nprotocols, we highlight the potential of our approach for\nreal-world deployment: we were able to achieve a high level\nof usability while satisfying stringent security requirements.\n\nCategories and Subject Descriptors\nC.2.0 [Computer Communication Networks]: General \u2013\nSecurity and Protection; C.4 [Performance of Systems]:\nDesign studies\n\nGeneral Terms\nSecurity, Design, Experimentation\n\nKeywords\nAuthentication, Augmented Reality, Spyware, Malicious code,\nKey Logger, Password, Smartphone\n\n1.\n\nINTRODUCTION\n\nThreats against the electronic and digital financial services\ncan be classified into two major classes of attacks: credential\n\u2217\n\nCorresponding author. E-mail: mohaisen@cs.umn.edu\n\n1\n\n\flimitations. The original contributions of this paper are as\nfollows:\n\nConsidering that the keylogger sees user's keystroke, this\nattack is quite similar to the shoulder-surfing attack. To prevent the shoulder-surfing attack, many graphical password\nschemes have been introduced [15, 18, 27], but many of\nthem are not usable in the sense that they are quite complicated for a person to utilize them. However, the usability is\nas important as the security, because users tend not to change\ntheir online transaction experience for higher security.\nIt is not enough to depend only on cryptographic techniques to prevent attacks which aim to deceive user's visual experience. Even if all necessary information is securely delivered to a user's computer, the attacker residing\non a user's computer can easily observe and alter the information and show a valid-looking yet deceiving information.\nHuman user's involvement in the security protocol is necessary sometimes to prevent this type of attacks, but human\nis not good at complicated calculations and does not have\na good memory to remember cryptographically-strong keys\nand signatures. Thus, the usability is an important factor in\ndesigning a human-involving protocol [22].\nOur direction to solving the problem is to introduce an\nintermediate device that bridges a human user and a terminal. Then, instead of the user directly invoking the regular\nauthentication protocol, he/she invokes a more sophisticated\nbut user-friendly protocol via the intermediate helping device. Every interaction between the user and an intermediate helping device is visualized using a Quick Response\n(QR) visual code. The goal is to avoid any memorization,\nperform any complex calculations, or even extensive typing.\nMore specifically, our approach visualizes the security process of authentication using a smartphone-aided augmented\nreality. The visual involvement of users in a security protocol boosts both the security of the protocol and is re-assuring\nto the user because he feels that he plays a role in the process. To securely implement visualized security protocols,\na smartphone with a camera is used. Instead of executing\nthe entire security protocol on the personal computer, part of\nsecurity protocol is moved to the smartphone. The user input is entered via the smartphone as are further interactions,\nwhen necessary. This visualization of some part of security\nprotocols enhances the security greatly and offers protection\nagainst hard-to-defend attacks such as malicious ware and\nshoulder surfing attack, while not degrading the usability.\n\n\u2022 Three protocols of authentication that utilize visualization by means of augmented reality to provide both\nhigh security and high usability. We show that these\nprotocols are secure under several real-world attacks,\nincluding keyloggers, malwares, and shoulder-surfer;\nthree attacks that are known to be challenging on authentication protocols.\n\u2022 A novel protocol for transaction verification paired with\na protocol for secure transaction processing. Both protocols offer advantages due to visualization both in terms\nof security and usability.\n\u2022 A prototype implementation in the form of an Android\napplication which demonstrates the usability of our protocols in real-world deployment settings.\nWe note that our protocols are generic and can be applied\nto many contexts of authentication. For example, a plausible scenario of deployment could be when considering the\nterminal in our system as an ATM (Automated Teller Machine), public PC, among others. Furthermore, our design\ndoes not require explicit channel between the bank and the\nsmartphone, which is desirable in some contexts; the smartphone can be replaced by any device with the needed functionality (see section 2 for more details).\n\n1.2 Organization\nThe rest of this paper is organized as follows. In section 2\nwe review the system, trust, and attacker model used in this\npaper. In section 3, we review three novel authentication\nprotocols. In section 4 we extended the presentation of these\nprotocols by discussing several implementation and design\nissues. In section 5 we analyze the security of our protocols under several potential attacks. In section 6 we report\nseveral experiments and user studies to support the usability\nof our protocols. In section 7 we review related work from\nthe literature. In section 8 we draw concluding remarks and\npoint out several future work directions.\n\n2. SYSTEM AND THREAT MODEL\nIn this section we describe the system and threat models\nsuitable to understand the work in the rest of this paper.\n\n1.1 Scope and contributions\n\n2.1 System Model\n\nIn this paper, we demonstrate how visualization can enhance not only the security but also the usability. We do\nso by proposing a family of visualized authentication protocols, visualized transaction verification, and a \"decryptable\nto your eyes only\" protocol. Through rigorous analysis, we\nshow that our protocols are immune to many of the challenging attacks applicable to other protocols in the literature.\nFurthermore, using an extensive case study on a prototype\nof our protocols, we highlight the potential of our protocols\nin real-world deployment meeting users shortcomings and\n\nOur system model consists of four different entities (or\nparticipants), which are a user, a smartphone, a user's terminal, and a server. The user is an ordinary human, limited by\nall human's limitations and shortcomings, including limited\ncapabilities of performing complex computations or remembering sophisticated cryptographic credentials. With a user's\nterminal such as a desktop computer or a laptop, the user\ncan log in a server of a financial institute (bank) for financial\ntransactions. After a successful login by proving possession\n2\n\n\fof valid credentials, the user can do financial transactions\nsuch as money transfer and bill payment. Also, the user\nhas a smartphone, the third system entity, which is equipped\nwith a camera, stores a public key certificate of the server for\ndigital signature verification. Also, the smartphone stores a\npublic/private key pair of the user, so if there is a channel\nof communication between the server and the smartphone,\na secure channel can be established. Finally, the server is\nthe last system entity, which belongs to the financial institute and performs back-end operations by interacting with\nthe user (terminal or smartphone) on behalf of the bank.\nAssuming a smartphone entity in our system is not a farfetched assumption, since most nowadays cell phones qualify (in terms of processing and imaging capabilities) to the\ndevice used in our work. In our system, we assume that\nthere is no direct channel between the server and the smartphone. Also, we note that in most of the protocols proposed\nin this paper, a smartphone does not use the communication\nchannel-unless otherwise is explicitly stated-so a smartphone can be replaced by any device with a camera and some\nproper processing power such as a camera and a portable\nmusic player with camera (iPod touch, or mobile gadget with\nthe aforementioned capabilities).\n\ning this assumption would provide certain security guarantees depending on the protocol. For example, the assumption in protocol 1 that uses two factors can be relaxed so as\nnot only the terminal but also smartphone is compromised\n(one of them at a time but not both together). However, for\nprotocols 2 and 3, we restrict this scenario so as the smartphone is always trusted and no malware nor keyloggers can\nbe installed on it. Notice that this assumption is in line with\nother assumptions made on the smartphone's trustworthiness\nwhen used in similar protocols to those presented in this paper [32, 31, 36].\nIn our protocols, we also assume several cryptographic\nprimitives. For example, in all protocols, we assume that\nusers have pairs of public/private keys used for message signing and verification. In protocol 1 we assume users have\npasswords used for their authentication. In protocol 2 we\nassume that the server has the capability of generating one\ntime pads, used for authentication. Notice that these assumptions are not far-fetched, since most banking services\nuse such cryptographic credentials. For example, with most\nbanking services, the use of digital certificates issued by the\nbank is very common. Furthermore, the use of such cryptographic credentials and maintaining them on a smartphone\ndoes not require any technical background at the user side,\nand is suited for wide variety of users. Further details on\nthese credentials and their use are explained along with the\nspecific protocol in this paper.\n\n2.2 Trust and Attacker Models\nFor the trusted entities in our system, we assume the following. First, we assume that the channel between the server\nand the user's terminal (or simply PC) is secured with an\nSSL connection, which is in fact a very realistic assumption\nin most settings of electronic banking systems. Second, we\nassume that the server is secured by any means and is immune to every attack by the attacker; hence the attacker's\nconcern is not breaking the server but attacking the user. Finally, with respect to the keylogger attack, we assume that\nthe keylogger always resides on the terminal. As for the attacker model, we assume a malicious attacker with high incentives of breaking the security of the system. We assume\nthat the attacker can do any or both of the following.\n\n2.3 Linear and Matrix Barcodes\n\nA barcode is an optical machine-readable representation\nof data, and it is widely used in our daily life since it is attached in every type of products for identification. In the\nnutshell, barcodes are mainly two types: linear barcodes\nand matrix (or two dimensional, also known as 2D) barcodes. While linear barcodes-shown in Figure 1(a)-have\na limited capacity, which depends on the coding technique\nused and can range from 10 to 22 characters, 2D barcodes-\nshown in Figure 1(b) and Figure 1(c)-have higher capac\u2022 The attacker has a full control over the terminal. Thus,\nity, which can be more than 7000 characters. For example, the QR (Quick Response) barcode [1]-a widely used\n\u2013 While residing in a user's terminal, the attacker\n2D barcode-can hold 7,089 numeric, 4,296 alphanumeric,\ncan capture user's credentials such as a password,\nand 2,953 binary characters [1], making it a very good higha private key, and OTP (one time pad) token string.\ncapacity candidate for storing plain and encrypted contents\n\u2013 The attacker can deceive a user by showing a genuinely- alike.\nlooking page that actually transfers money to the\nBoth linear and matrix barcodes are popular and have been\nattacker's account with the captured credentials\nwidely used in a lot of industries including, but not limthat she obtained from the compromised terminal.\nited to, automotive industries, manufacturing of electronic\n\u2013 Or, just after a user successfully gets authenticomponents, and bottling industries, among many others.\ncated with a valid credential, the attacker can hiThanks to their greater capacity, matrix barcodes are even\njack the authenticated session.\nproactively used for advertisement so that a user who has a\nsmartphone can easily scan them to get some detailed infor\u2022 The attacker is capable of creating a fake server which\nmation about advertised products. This model of advertisement-\nshe can use to launch phishing or pharming attacks.\nand other venues of using these barcodes in areas that are in\nFor the smartphone, we assume that it is always trusted\ntouch with users-created the need for barcode's scanners\nand immune to compromise. It is however noted that relaxdeveloped specifically for smartphones. Accordingly, this\n3\n\n\fled to the creation of many popular commercial and free\nbarcode scanners that are available for smartphones such\nas iPhone and Andriod phones alike. This includes RedLaser [3], BarcodeScanner [8], ShopSavvy [5], QR App [2],\namong others.\n\nAny signature scheme with provable security guarantees can\nbe used to serve the purpose of our system. For details on the\nnotion of signatures security see [16]. In particular, and for\nefficiency reasons, we recommend the short signature in [9].\n\n3.1 An Authentication Protocol with Password\nand Randomized Onscreen Keyboard\nOur first protocol, which is referred to as Protocol 1 in the\nrest of this paper, makes use of the a password shared between the server and the user, and a randomized onscreen\nkeyboard. A high-level event-driven code describing the\nprotocol is shown in Figure 2. A further detailed description is as follows.\n\n(a) Barcode (code 128)\n\n1. The user connects to the server and sends her ID.\n\n(b) QR barcode\n\n2. The server checks the received ID to retrieve the user's\npublic key (P KID ) from the database. The server prepares \u03c0, a random permutation of a keyboard arrangement, and encrypts it with the public key to obtain\nEKBD = EncrP KID (\u03c0). Then, it encodes the ciphertext with QR encoder to obtain QREKBD = QREnc(EkID (\u03c0)).\nThe server sends the result with a blank keyboard.\n\n(c) QR barcode\n\nFigure 1: Three different barcodes encoding the statement \"Virtual reality\". (a) is a linear barcode (code 128),\nand (b) and (c) are matrix barcodes (of the QR barcode\nstandard). While (b) encodes the plain text, (c) encodes\nan encrypted version using the AES-256 encryption algorithm in the cipher-block chaining (CBC) mode (note\nthis last code requires a password for decryption).\n\n3.\n\n3. In the user's browser, a QR barcode (QREKBD ) is displayed together with a blank keyboard. Because the\nonscreen keyboard does not have any alphabet on it,\nthe user cannot input her password. Now, the user executes her smartphone application which first decodes\nthe QR barcode by applying QRDec(QREKBD ) to get\nthe ciphertext (EKBD ). The ciphertext is then decrypted\nby the smartphone application with the private key of\nthe user to display (\u03c0 = DecrSKID (EKBD )) on the\nsmartphone's screen.\n\nSECURE TRANSACTIONS WITH AUGMENTED REALITY\n\nIn this section we describe thee different protocols for user\nauthentication with augmented reality. Before getting into\nthe details of these protocols, we review the notations of algorithms used in our system and these protocols as building\nblocks. Our system utilizes the following algorithms:\n\n4. When the user sees the blank keyboard with the QR\nbarcode through an app on the smartphone that has a\nprivate key or a shared secret, alphabets and numbers\nappear on the blank keyboard and the user can click the\nproper keycap for the password. User clicks his/her\npassword on the computer monitor while seeing the\nkeyboard layout through the smartphone.\n\n\u2022 Encrk (*): an encryption algorithm which takes a key k\nand a message M from set M and outputs a ciphertext\nC in the set C.\n\n5. Server checks whether the password is correct or not.\n\n\u2022 Decrk (*): a decryption algorithm which takes a ciphertext C in C and a key k, and outputs a plaintext (or\nmessage) M in the set M.\n\nMessage signing. For the generality of the purpose of this\nprotocol and the following protocols, and to prevent the terminal from misrepresenting the contents generated by the\nserver, one can establish the authenticity of the server and\nthe contents generated by it by adding the following verification process. When the server sends the random permutation\nto the user, it signs the permutation using the server's private key and the resulting signature is encoded in a QR code.\nBefore decrypting the contents, the user establishes the authenticity of the contents verifying the signature against the\nserver's public key. Both steps are performed using the Sign\nand Verf algorithms. Verification is performed by the smartphone so as to avoid any man-in-the-middle attack by the\nterminal.\n\n\u2022 Sign(*): a signature generation algorithm which takes\na private key SK and a message M from the set M,\nand outputs a signature \u03c3.\n\u2022 Verf(*): a signature verification algorithm which takes\na public key P K and a signed message (M, \u03c3), and\nreturns valid or invalid.\n\u2022 QREnc(*): a QR encoding algorithm which takes a\nstring S in S and outputs a QR barcode.\n\u2022 QRDec(*): a QR decoding algorithm which takes a QR\nbarcode and returns a string S in S.\n4\n\n\f01:\n02:\n03:\n04:\n05:\n06:\n07:\n08:\n09:\n10:\n11:\n12:\n13:\n14:\n15:\n16:\n17:\n18:\n19:\n20:\n21:\n22:\n23:\n24:\n25:\n\nuser::user.send(server, id)\nserver::__upon_id_arrival:\nif(server.verify(id) == true):\npkid = server.db.find(id)\npi = server.generate_random_kb()\nekbd = server.encrypt(pkid, pi)\nqrekbd = server.qrencode(ekbd)\nserver.send(user, qrekbd)\nterminal::__upon_qrekbd_arrival:\nterminal.view(qrekbd)\nterminal.view_blank_kb(pi)\nsmartphone::__upon_qrekbd_view:\nqrekbd = smartphone.capture(qrekbd)\nekbd = smartphone.qrdecode(qrekbd)\npi = smartphone.decrypt(skid, ekbd)\nsmartphone.view(pi)\nuser::__upon_pi_view:\npw = user.inputpassword(terminal)\nterminal::upon_pw_input:\nterminal.send(server, pw)\nserver::__upon_pw_arrival:\nif(server.verify(id, pw) == true):\nserver.authenticate(user)\nelse:\nserver.deny(user)\n\n01:\n02:\n03:\n04:\n05:\n06:\n07:\n08:\n09:\n10:\n11:\n12:\n13:\n14:\n15:\n16:\n17:\n18:\n19:\n20:\n21:\n22:\n23:\n24:\n25:\n\nFigure 2: Event-driven high-level description of the authentication protocol with password and a randomized\nonscreen blank keyboard (protocol 1).\n\nuser::user.send(server, id)\nserver::__upon_id_arrival:\nif(server.verify(id) == true):\npkid = server.db.find(id)\notp = server.generate_otp()\neotp = server.encrypt(pkid, otp)\nqreotp = server.qrencode(eotp)\nserver.send(user, qreotp)\nterminal::__upon_qreotp_arrival:\nterminal.view(qreotp)\nterminal.view_kb()\nsmartphone::__upon_qreotp_view:\nqreotp = smartphone.capture(qreotp)\neotp = smartphone.qrdecode(qreotp)\notp = smartphone.decrypt(skid, eotp)\nsmartphone.view(pi)\nuser::__upon_kb_view:\notp = user.inputotp(terminal)\nterminal::upon_otp_input:\nterminal.send(server, otp)\nserver::__upon_otp_arrival:\nif(server.verify(id, otp) == true):\nserver.authenticate(user)\nelse:\nserver.deny(user)\n\nFigure 3: Event-driven description of the authentication\nprotocol with one-time pad (OTP) tokens (protocol 2).\nterminal can easily receive the user's input from the smartphone via the QR barcode and forward it to the server. At\nterminal, a plugin that reads and decodes the QR barcode\nand sends it to the server is installed in a web browser. A\nhigh-level event-driven describing the protocol is shown in\nFigure 4. A further detailed description is as follows.\n\n3.2 Authentication With Random Strings\nIn this section we introduce an alternative protocol to that\nexplained in the previous section. The following protocol\n(referred to as Protocol 2 in the the rest of the paper) relies on a strong assumption; it makes use of a random string\nfor authentication. A high-level event-driven code describing the protocol is shown in Figure 3. A further detailed\ndescription is as follows.\n\n1. The user connects to the server and receives a login\nbox with a QR-encoded random nonce N .\n2. The user executes an application on the smartphone\nwhich reads the nonce N and prompts the user to input her ID and password (PW). After the user inputs\nher ID and password on the smartphone, the application will encrypt N , ID, the password, and the server's\nname with the server's public key (P KSrv ), where the\nencryption algorithm is IND-CCA2 secure. The resulting ciphertext (EncrP KSrv (N, ID, PW, Srv)) is then\nencoded to a QR barcode and displayed on the smartphone screen.\n\n1. The user connects to the server and sends her ID.\n2. Th server checks the ID to retrieve the user's public\nkey (P KID ) from the database. The server then picks\na fresh random string OT P and encrypts it with the\npublic key to obtain EOT P = EncrP KID (OT P ).\n3. In the user's browser, the QR barcode is displayed and\nthe page prompts the user to type in the string.\n4. The user decodes the QR barcode. Because the random\nstring is encrypted with user's public key (P KID ), the\nuser can read the OTP string only through her smartphone and type in the OT P with a physical keyboard.\n\n3. The user puts the QR barcode on the screen at the terminal's camera. The plugin reads and decodes the QR\nbarcode to extract the ciphertext of the encrypted credentials and nonce. The ciphertext is sent to server.\n\n5. The server checks the result and if it matches with what\nthe server has sent earlier, the user is authenticated.\nOtherwise, the user is denied.\n\n4. The server decrypts the ciphertext and checks the nonce,\nID and password and decided upon their validity whether\nthe user is authenticated or not.\n\n3.3 Authentication Using Visual Channel for\nSmartphone-to-Terminal Communication\n\nThe idea of using QR barcode on the phone's screen as\nan upload channel (from phone to terminal) can be used in\nmany other schemes [30]. Instead of using cellular network\nfor a phone to send the confirmation, we can use this QR\nbarcode-based channel from phone to a terminal.\nThe use of the visual channel to input encrypted credentials from the smartphone to the terminal has an interesting\n\nOur last protocol, referred to as protocol 3 in the rest of\nthe paper, takes advantage of the visual channel between the\nsmartphone and the terminal. In this protocol, we further\nassume that the terminal is provided with a camera, which\nis not a far-fetched assumption. Equipped with a camera, a\n5\n\n\f01:\n02:\n03:\n04:\n05:\n06:\n07:\n08:\n09:\n10:\n11:\n12:\n13:\n14:\n15:\n16:\n17:\n18:\n19:\n20:\n21:\n22:\n23:\n24:\n25:\n26:\n27:\n28:\n29:\n30:\n\nuser::user.connect(server)\nserver::__upon_user_connection:\nnonce = server.generate_nonce()\nqrnonce = server.qrencode(nonce)\nserver.send(user,qrnonce)\nterminal::__upon_qrnonce_arrival:\nterminal.view(qrnonce)\nsmartphone::__upon_qrnonce_view\nqrnonce = smartphone.capture(qrnonce)\nnonce = smartphone.qrdecode(qrnonce)\nsmartphone.view_loginbox()\nuser::__upon_loginbox_view:\n(id, pw) = user.input_credentials()\nsmartphone::__upon_credentials_input:\nencredentials = smartphone.encrypt(id, pw, nonce)\nqrencredentials = smartphone.qrencode(encredentials)\nsmaprtphone.view_qrenc(qrencredentials)\nterminal::__upon_qrenc_view:\nqrencredentials = terminal.capture(qrencredentials)\nencredentials = terminal.qrdecode(qrencredentials)\nterminal.send(server, encredentials)\nserver::__upon_encredentials_arrival:\n(id, pw, nonce) = server.decrypt(encredentials)\nif(server.valid(user, nonce) = true)\nif(server.check(id, pw) = true):\nauthenticate(user)\nelse:\ndeny(user)\nelse:\ndeny(user)\n\nFigure 4: Event-driven high-level description of the\nauthentication protocol with visual channel for userterminal communication (Protocol 3).\nsecurity implication when considered in context. As it is\nthe case with using e-banking on untrusted terminals (say,\nin public library) imagine that such terminal is infected with\na virus, or has a malware, which could be a keylogger that\nstores the credentials if the user is to input them directly on\nthe terminal. If the user is to use the login credentials directly on the terminal, it is obvious that these credentials\nwill be compromised. On the other hand, if these credentials are to be transferred using the visual channel between\nthe smartphone and the terminal, chances for logging these\ncredentials on the terminal by the keylogger are obsolete.\n\n4.\n\nsection 3, the smartphone application may send additional\ninformation on the user's transaction request that is signed\nby the smartphone's private signing key and/or encrypted\nwith the server's public key through cellular network. By\nadding this step, a server can be sure that the critical transaction request from the user's terminal is not altered.\n\n4.2 Transaction Verification\nVisual fraudulence, such as man-in-the-browser attack [25],\nphishing attack [13], and the pharming attack [25, 11], is an\nattack to show valid looking HTML pages, but to perform\nsome malicious behaviors either by malicious code in the\nHTML page or by making user visit malicious sites. The visual fraudulence is quite effective and critical if conducted\nin financial transaction scenarios. The nature of the visual\nfraudulent attack is to deceive people's view and thus it is not\neasy to devise an effective and useable method to prevent it.\nAlso, situations are worse in practical contexts noting that\nthe malicious ware performing the man-in-the-browser attack can be easily implemented in a form of a browser helper\nobject.\nAssume that a given user is visiting a banking server and is\nabout to transfer money to other account. Even if the user's\nterminal is infected with some malicious ware or the user is\nvisiting a phishing site, she cannot recognize it easily, because the HTML page that the user is watching is visually\nthe same as the genuine page. Even when a bank server asks\nthe user to input credentials such as a password, a one time\npassword generated from a hardware token, and a certificate\nbased signature to confirm the transaction, the user is willing\nto input her credentials as requested, and with the credential\ninformation the attacker is able to prepare a valid transfer\nrequest to her account. In this section, we show an effective\nand useable approach to defeat these visual fraudulence with\nthe aid of a smartphone. Similar in essence to the previous\ndiscussed protocols, our protocol for preventing the visual\nfraudulence consists of the following:\n\nDISCUSSION\n1. The user sends an HTML page to request money transfer, for instance. This page might include a receiver's\naccount number, the amount of money to be transferred,\nand the receiver's name, etc.\n\nSome of the technical issues in the three protocols that\nwe have introduced in the previous section call for further\ndiscussions and clarification. In this section, we elaborate on\nhow to handle several issues related to our protocols, such\nas session hijacking, transaction verification, and securing\ntransactions.\n\n4.1 Prevention of Session Hijacking\nEven with secure authentication, an attacker controlling\nentities in the system participating in the authentication process-\nthe terminal in particular-via a malware can hijack the authentication session just immediately after a user inputs her\ncorrect password or an OTP. To detect the session hijacking,\nthe smartphone-triggered by the user-may send transactionrelated information to the server via a side channel such as\nthe cellular network or the visual channel introduced in section 3.3. Just after running the password input procedure in\n6\n\n2. The server responds with confirmation HTML page\nalong with a QR code that includes transaction information and a digital signature of messages in the HTML\npage. The page might include a code to prompt a user\nto input credentials to confirm the order.\n3. The user reviews the HTML page received from the\nserver then-with an application on her smartphone-\nshe takes a snapshot of the QR barcode.\n4. The application on the smartphone decodes and verifies the digital signature over the attached message\nwith the server's public key. If the signature is valid, it\n\n\fwill show the message with a mark indicating the signature was verified. Otherwise, it will warn the user\nwith a mark indicating invalid signature. The mark\nmay be a background color (green on a valid signature\nand red on an invalid one) or simple warning words.\n\nincludes the use of RSA-2048, which is very infeasible to\nattack using the most efficient brute-force attack. This applies to both encryption and signature algorithms used in the\nprotocols.\nNotice that all public key cryptography in our protocols\n(except for signing and verification) can be replaced by symmetric key cryptography, which is far more efficient (despite\nthat computations in our protocols are marginal). Furthermore, such replacement of cryptographic techniques will not\naffect the security guarantees of our protocols if standard algorithms and key length are used-e.g. AES 192, which is\ninfeasible to brute-force. In our prototype, we use the latter\nsymmetric key cryptography for securing communication.\n\n5. The user checks if the message matches with the one\nin the HTML page and the signature is verified. If it is\nvalid and correctly verified, the user continues to confirm the transaction by inputting her credential.\n\n4.3 Securing Transactions\nFinancial transactions are usually secured by encrypting\nall transaction-related information during the transmission.\nIn many cases, the encrypted information should be decrypted\nat the terminal (user's PC, most likely, or a PC at public\nplace) to be shown to the user. However, under the assumption that there is a malware inside the terminal, the attacker\ndoes not need to break the cipher, but is enough to read the\ninformation after being correctly decrypted. The encrypted\nchannel is established just between the server and the user's\nterminal. To make transactions more secure, it is needed\nto extend the encrypted channel beyond the user's terminal. Accordingly, instead of decrypting the ciphertext at the\nuser's terminal, we will decrypt it at the smartphone. Steps\nof securing the transaction include the following:\n\n5.2 Keyloggers\nThe keylogger is a small piece of malicious software that\nlogs all keystrokes input by the user, which could potentially\ninclude authentication credentials, and forward them to the\nattacker. This type of malware is popular and widely reported in many contexts [45, 19, 41, 39, 21]. In our protocols, input is expected by the user, and in every protocol one\nor another type of input is required. Our protocols-while\ndesigned with the limitations and shortcoming of users in\nmind, and aim at easing the authentication process by means\nof visualization-are aimed explicitly at defending against\nthe keylogger attacks. Here, we further elaborate on the potential of using keyloggers as an attack and the way they\nimpact each of the three protocols. While we believe that\nhaving a keylogger installed on the smartphone is hard to\nachieve, we discuss when it is hypothetically possible and\nshow how this affects the security of our protocols. Narrowing the discussion to the case where keyloggers can be only\ninstalled on the terminal strengthens all of the arguments.\nProtocol 1. In the first protocol, a randomized blank keyboard is posted on the terminal whereas another keyboard\nwith the alphanumerics on it is posted on the smartphone.\nBecause the protocol does not require a user any keyboard\ninput on the smart phone side, the protocol is immune against\nthe keylogger attack. User just checks the keyboard layout\non the phone and there is not input from a user. Obviously,\nthe terminal might be compromised, but the keylogger will\nbe able to only capture what keystrokes are used on blank\nkeyboard. Thus, the keylogger will not be able to know\nwhich alphanumeric character is being used.\nProtocol 2. Authentication in this protocol is solely based\non a random string generated by the server. The random\nstring is encrypted by the public key of the user, and verified\nagainst her private key. The main objective of using OTP is\nthat it is for one time use. Accordingly, if the keylogger is\ninstalled on the terminal, the attacker obviously will be able\nto know the OTP but will not be able to reuse it for future\nauthentication. Alternatively, a keylogger installed on the\nsmartphone will not be able to log any credentials, since no\ncredentials are typed in. It is worth noting that the attacker\nmay try to block users from being authenticated and reuse\n\n1. The server prepares an HTML document that has encrypted data and their corresponding QR barcodes. The\nciphertext is encrypted with the user's public key.\n2. At the user's terminal, the document is shown but not\ndecrypted. The user executes an application on the\nsmartphone and sees through it the HTML page. The\napplication captures the QR barcodes in the HTML\ndocument and then decodes and decrypts them. On\nthe smartphone's screen, the HTML document with\ndecrypted information will be viewed.\nThe sensitive data might be transaction-related account numbers, balance, account holder's name, and ID, among others.\n\n5.\n\nSECURITY ANALYSIS\n\nIn this section we analyze the security of our scheme under several attack scenarios and show how these attacks are\ndefended. In particular, we consider brute-forcing attacks,\nkeyloggers, malicious ware, and shoulder surfing attacks.\n\n5.1 Key Space and Brute-Force Attacker\nIn our protocols, several stages include encryption of sensitive information such as credentials, which are of interest to the attacker (including the user ID, password, and\nnonce generated by the server). In our prototype, and system recommendations for wide use of our protocols, as well\nas the description provide above for the different protocols,\nwe consider public key cryptography. Furthermore, we suggest key length that provides good security guarantees. This\n7\n\n\fthe OTP immediately. In this case, mitigations explained in\nsection 4 can be used to remedy the attack.\nProtocol 3. In the third protocol, authentication is established based on credentials provided by the user on her smartphone. Accordingly, having a keylogger on the terminal will\nnot enable the attacker to obtain any credentials required for\nauthentication. On the other hand, if the keylogger is installed on the smartphone, a relatively far-fetched assumption, the keylogger will be able to log the password and user\nname. By themselves alone, however, both it is not sufficient\nfor the attacker to be authenticated since the successful authentication requires additionally knowing the user's private\nkey, which is necessary to obtain the nonce sent by the server\nand to compute the authentication response.\n\nTable 1: A comparison of the three protocols and their\nresistance to different attacks when the terminal and the\nsmartphone are under control of the attacker.\nAttack\n\nbrute-force\n\nkeyloggers\n\nmalware\n\nsurfer\n\nProtocol 1: Onscreen randomized keyboard\nSmartphone\nTerminal\n\n\u2714\n\u2714\n\n\u2714\n\u2714\n\n\u2714\n\u2714\n\n\u2714\n\u2714\n\n\u2716\n\u2714\n\n\u2714\n\u2714\n\nProtocol 2: OTP tokens\nSmartphone\nTerminal\n\n\u2714\n\u2714\n\n\u2714\n\u2714\n\nProtocol 3: Visual channels for authentication\n\n5.3 Malicious Software (malware)\n\nSmartphone\nTerminal\n\nThe term malware is generic, and is technically used to describe any type of code with malicious intentions, including\nkeyloggers. It is obvious that an attacker who successfully\ncompromised a smart phone that has a private key that is a\nwhole credential required to break the system in protocol 2\nand 3 will be always successful to break the systems except\nthe protocol 1 that requires both password and private key.\n\n\u2714\n\u2714\n\n\u2716\n\u2714\n\n\u2716\n\u2714\n\n\u2714\n\u2714\n\nIn the second protocol, OTP tokens are used for authentications. OTP tokens are one-time used, providing high entropy, and are human-unfriendly making them hard to remember and recall. Accordingly, a shoulder surfer would\nnot benefit from launching an attack by trying to observe\nwhat the user at the terminal is inputting. Last, in the third\nprotocol input is performed at the smartphone, and shoulder\nsurfing on the terminal will not benefit the attacker. Same as\nin the first protocol, the ability of successfully launching an\nattack by shoulder-surfing would require the attacker to be\nin very good proximity from the user, which would raise the\nuser's suspicions about the intentions of the attacker.\n\n5.4 Shoulder-Surfing Attacks\nThe shoulder surfing is a powerful attack in the context of\npassword-based authentication and human identification [44,\n22, 28]. In this attack, the attacker tries to know credentials,\nsuch as passwords or PINs (personal identification numbers)\nby stealthily looking over the shoulder of a user inputting\nthese credentials into the systems. These attacks are powerful and efficient in crowded places.\nIn our first protocol, observing the terminal or the smartphone keyboard layout (on the smartphone screen) alone would\nnot reveal the credentials of the user. Observing both at\nthe same time in a shoulder surfing attack, and mapping\nstroked keys on the terminal to those on the smartphone\nscreen would reveal the credentials of the user. However,\nbeing able to successfully launch this attack is a non-trivial\ntask, and requires the attacker to be in a position very close\nto the user, which would raise suspicions of the user.\nOne may argue that requiring user caution to the potential\nof the shoulder-surfing attack contradicts the usability arguments of our protocols we advocated in this paper. Especially, the opposing argument might sound appealing given\nthat an attacker might be equipped with vision-enhancing\ndevices, such as cameras, to improve chances of the attack.\nIn response, we argue two issues. First, to succeed in this\nattack, the attacker needs to have a good resolution-camera,\nand still be in proximity of the user, to capture passwords\nbeing used. Second, users who are aware that the terminal they are avoiding is potentially compromised would be\nhighly likely cautious for susceptible actions around them-\nsuch as that in the first issue above, which does not thwart\nthe usability arguments we claim for our protocols.\n\n5.5 Comparison\nTo sum up, we compare the three protocols and the way\nthey perform against several attacks. We consider the scenarios where the attacker has control over either the terminal\nor smartphone-see above. The comparison is in Table 1.\n\n6. IMPLEMENTATION AND USER STUDY\nWe developed a prototype of our protocols as an Android\napplication. The application can run on any smartphone with\nAndroid OS [17] (version 2.2 or later). Our application uses\nthe UTF-8 standard [6] for the keyboard encoding, AES-192\nencryption algorithm [23] (in the counter mode) for contents\nencryption, Base64 encoding [24] for byte-to-character encoding of encrypted contents, and uses the Google API for\ncreating and reading the QR barcodes. For that, we particularly use ZXing [7], an open source implementation for reading several standards of the 1D and 2D barcodes. Snapshots\nof the Android application, the terminal, and QR barcode in\nthe prototype that we developed are shown in Figure 5.\n\n6.1 Settings and Basic Characteristics\nIn all of our experiments in this paper we used a Samsung\n8\n\n\f(a) Terminal Keyboard\n\n(b) QR code\n\n(c) Smartphone Keyboard\n\nFigure 5: Snapshots of the prototype we developed to demonstrate our authentication protocols. Fig. (a). shows the\nblank keyboard posted at the terminal, where numerics are used to ease the process of input by the user. Fig. (b) shows\nthe QR barcode on the terminal as being captured and recognized by the smartphone application. Fig. (c) shows the\ndecoded randomized layout of the keyboard obtained from the QR barcode after decryption as viewed on smartphone.\nGalaxy U smartphone [4], which has an S5PC111 processor operating at 1GHz, 512 MB of RAM, a Gingerbread OS\n(Android OS 2.3), and a 5.0 Mega pixel camera with autofocus, geo-tagging, touch focus, and face and smile detection. To send encrypted data from the terminal to the smartphone conveniently, we adopted the QR barcode. However,\nthe camera on the phone is not error-free when it captures a\nQR barcode, we need to correct errors at the time of decoding. Fortunately, QR barcode has internal error correction\ncapability with Reed Solomon code. The rate of successful\ndecoding of QR barcodes is dependent upon multiple factors\nsuch as a QR barcode size, the resolution of a camera and the\nsmartphone screen. Thus, the amount of data needed to execute our protocol is crucial to its feasibility.\nIf we use alphanumeric passwords only, the total number of possible keys in the onscreen keyboard is 36. So,\nlog2 36! = 138 bit entropy is guaranteed which is high enough\nfor security. For the encoding of this permutation, we need\n36 \u00d7 log2 36 = 187 bits. But if we use alphanumeric encoding of QR code, we need to store 36 alphanumeric characters. Considering that one QR barcode can hold up to 2953\nbinary characters (bytes), it is feasible to encode the keyboard arrangement in a QR barcode. More specifically, QR\nbarcode version 2 with M level error correcting capability\ncan hold 36 alphanumerics. So, even a relatively small capacity QR barcode with moderate error correcting code is\napplicable. Accordingly, we can run our authentication protocols with a smartphone with a low-resolution camera and\nscreen. The rate of successful scanning and decoding of QR\nchallenges depends partly on the QR barcode size, and translates to higher screen time when failure happens.\nTo understand the impact the QR barcode size on the time\nrequired for decoding the message using our application, we\nrun the following experiment. Using the same QR barcode\nfor the same encoded data, we generate QR barcodes with\ndifferent sizes (in pixel). We use 8 sizes, as shown in Figure 6. In all measurements, we demonstrate that the response\ntime of the QR scanner is well less than 3 sec. Furthermore,\nfor the majority of the cases, we obtain a response mean time\naround 1.5 seconds, except when the QR barcode size is 100\n\n3500\n2500\n1500\n\nResponse time (millisecond)\n\npixel, which translates into an average of 1.75 seconds. This\nmeasurement demonstrates the feasibility of our protocol's\nutilization of the QR barcodes for input and visualization.\n\n100\n\n150\n\n200\n\n250\n\n300\n\n350\n\n400\n\n500\n\nDimension of the QR barcode (in pixel)\n\nFigure 6: Boxplot of the different measurements of the\nresponse time for different QR barcode size (in pixel, 20\nmeasurements for each case). Note that the boxplot represents the 5%, 95% maximum, mean, first and second\nquartiles of the time measurements. Notice the positive\nassociation between the time and the code size.\n\n6.2 User and Usability Study\nTo understand the usability aspects of our protocols, we\nperform a user study in several settings. We asked 20 different users to use our system. We limit ourselves to a fully\nfunctioning implementation of the first protocol. We note\nthat results reported in this study can be used as an upper\nbound on the performance of our protocols, since other protocols require less user intervention than the first protocol.\nWe compare this case of our functioning protocol to two\ncontrol groups (ground truth) of usage. The first case study\nconsiders the inputting method in typical devices using a\nqwerty keypad on the screen to correspond to the response\ntime of typical password inputting time (without using our\nprotocols or their security guarantees). The second case is\nthe control group where we use a randomized keyboard on\nthe terminal, which is already used as a security mechanism\n9\n\n\f(see section 1). Accordingly, in the second case users do\nnot need to map the randomized keyboard to a layout on the\nterminal-they rather directly use the one on the terminal. In\nboth cases, the user enters his password using mouse clicks.\nIn all experiments, we use two password lengths 4 and 8\ncharacters. Each user to use the password of his own choice.\nWe repeat the experiment with each user for 10 times. In the\nfollowing, we summarize the main results.\nCase study 1-Control group (a). In the first case study\n(referred to as normal experiment), we asked the 20 users\nof our system to input passwords of their own choice with\nthe different lengths (4 and 8 characters) on a qwerty keypad\nshown on the terminal . Input is done by mouse clicks. We\nmeasure the response time of each user in both cases. We\nrepeat the experiment for 10 times for each user. We do the\nmeasurements for all cases, including when passwords are\ntyped incorrectly. We find that the average success rate is\n97% with 4 characters passwords and 91% for 8 characters\npasswords. An empirical CDF of the time measurements\n(total of 200) is shown in Figure 7 (the left figure is for 4\ncharacters and the right figure is for the 8 characters case).\nWe find that the mean, min, max and median (in seconds)\nare 4.21, 2, 29, and 4 when using 4 characters passwords\nand 6.81, 2, 28, and 6 when using 8 characters.\nNormal 4 ECDF\n\u25cf\n\nRandomized 4 ECDF\n\n\u25cf\n\n5\n\n10\n\n15\n\n20\n\nTime (seconds)\n\n25\n\n30\n\n0\n\n10\n\n15\n\n20\n\n25\n\n0.8\n\nECDF\n\n0.4\n\n0.8\n0.4\n\nECDF\n\n\u25cf\n\n5\n\n\u25cf\n\u25cf\n\n0.0\n\n\u25cf\n\u25cf\n\n0.0\n\n\u25cf\n\n0.0\n\n0.0\n0\n\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\n10\n\n20\n\n30\n\n40\n\n\u25cf\n\u25cf\n\n10\n\n20\n\n30\n\n40\n\n50\n\nTime (seconds)\n\nCase study 3-Our protocol. In this experiment, we use\na fully functioning implementation of our first protocol to\ndemonstrate its usability aspects. We use the same settings\nas in the prior two experiments. In particular, the same sets\nof passwords with the previous control groups are used in\nthis experiment. In our protocol, at each time a simulated\nserver introduces a randomized keyboard to the user encoded\ninto a QR barcode and encrypted as explained in section 3.\nThe user is asked to input his password on the terminal's\nkeyboard using mouse clicks with the help of the keyboard\non the smartphone. Each user repeats that for 10 times, and\nat each time the server generates a new keyboard. We further\naccount for all processing and computations in our protocols\nby timing the overall login process. We measure the overall\nlogin time since the server introduces the randomized keyboard till the user logs in (or being rejected for password\nmismatch). Same as before, we measure the response time\neven when the login fails for password mismatch. For that,\nwe notice that the average achieved success rate with our\nprotocol for login is 98.5% for 4 characters passwords and\n96% for 8 characters passwords case. We notice that our\nsystem achieves a comparable success rate to that of both\ncontrol groups supporting its usability.\nSame as before, we plot an empirical CDF of the time\nmeasurements in Figure 9 (detailed statistics and subjects are\ninTable 2). The time measured in both figures includes the\ntotal time it takes for cryptographic operations, encoding,\ndecoding, communication (negligible), and user response.\nWe notice that our system is practical compared to the other\ncase studies, since the mean, minimum, maximum, and median times it takes (in seconds) are 20.745, 10, 53, and 19.5\nwith 4 characters password and 29.81, 15, 52, and 28 with\n8 characters (the mean \u00b11.38 sec for confidence interval of\n\n\u25cf\n\n\u25cf\u25cf\n\n\u25cf\n\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n\nFigure 8: Empirical CDF of the time it takes for inputting passwords of two different lengths. The total number of trials are 200 obtained from 20 users.\nThe keyboard used for input is the a randomized Android phone keyboard (same keyboard is rendered on the\nsmartphone and terminal).\n\n\u25cf\n\n\u25cf\n\nRandomized 8 ECDF\n\u25cf\n\n\u25cf\n\nTime (seconds)\n\n\u25cf\n\n\u25cf\n\n\u25cf\n\n\u25cf\n\u25cf\n\u25cf\n\u25cf\n\n0\n\n0.4\n\nECDF\n\n\u25cf\n\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\n\u25cf\u25cf \u25cf \u25cf\n\u25cf \u25cf\u25cf\u25cf \u25cf\n\u25cf\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\n\u25cf\n\nNormal 8 ECDF\n\u25cf\n\n\u25cf\n\n0.8\n\n\u25cf\u25cf\n\n\u25cf\n\n0.4\n\nECDF\n\n0.8\n\n\u25cf\n\n\u25cf\u25cf\n\u25cf\u25cf\n\nters case) of the time measurements. We find that the mean,\nmin, max, and median (in seconds) are 9.37, 3, 42, and 8 for\nlength 4 and 14.73, 6, 46, and 14 for length 8 passwords, respectively. We note that, at average, the time it takes to input\npasswords using this method is twice as much as when using\nthe qwerty keypad.\n\n30\n\nTime (seconds)\n\nFigure 7: Empirical CDF of the time it takes for inputting passwords of two different lengths. The total\nnumber of trials is 200 obtained from 20 users. The keyboard used for input is a qwerty keypad, which is the\ntypical Android phone keypad.\nCase study 2-Control group (b). In the second experiment (referred to as randomized experiment), we asked the\nsame set of users to use the same set of passwords that they\nused in the first experiment and experimented with randomized keyboards that are rendered on the terminal. We use\nthe same number of users and trials per user as in the previous case study. At each time, a random keyboard layout\nis generated, and the user is allowed to input his password\nto the system using mouse clicks. We note that this experiment resembles similar techniques used for defending keyloggers (see section 1). Same as in the previous experiment,\nwe measure the time it takes each user to input the password\nusing this method. We find that the average success rate is\n100% with 4 characters passwords and 94% with 8 characters passwords. We plot the empirical CDF in Figure 12 (the\nright side is for 4 characters and the left side is for 8 charac10\n\n\f95%). Compared to the two other case studies, which do\nnot provide the same security guarantees of our protocol, we\nfind that our protocol takes at average twice as much as the\nrandomized keyboard method and roughly four times (about\nfives times for passwords with length 4) as much as the normal method (case study 1) both passwords lengths.\n\n10\n\n20\n\n30\n\n\u25cf \u25cf\u25cf\u25cf\n\n0.4\n\nECDF\n\n0.8\n\n\u25cf \u25cf\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\n0.0\n\n0.4\n0.0\n\nECDF\n\n0.8\n\n\u25cf\u25cf \u25cf\u25cf\n\u25cf\u25cf\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\n\u25cf\n\u25cf\n\u25cf\u25cf\n\u25cf\u25cf\n\n40\n\n50\n\nTime (seconds)\n\ntication protocols that use graphical passwords like those reported in [42, 12, 43, 18] and attacks on them reported in [10,\n20, 15, 25, 18, 34]. To the best of our knowledge, our protocols are the first of their own types to use visualization for\nimproving security and usability of authentication protocols\nas per the way reported in this paper.\nA closely related work is \"Seeing-is-Believing\" (SiB) [31]\n(extended in [32]), which uses visual channels of 2D barcodes to resist man-in-the-middle attack in device pairing.\nThough we utilize similar tools by using the 2D barcodes for\ninformation representation, and the visual channel for communicating this information, our protocols are further more\ngeneric than those proposed in [31]. Our protocols are tailored to the problem settings in hand, e-banking, with a different trust and attack model than that used in [31]-which\nresults into different guarantees as explained earlier in this\npaper. To prevent against phishing, Parno et al. suggested\nthe use of trusted devices to perform mutual authentication\nand eliminate reliance on perfect user behavior [36].\nSlightly touched upon in this paper are keyloggers as potential attacks for credentials stealing, which are reported\nin [19, 21, 39], and other malware which are reported in [41,\n45]. In this paper we have shown that our protocols are secure even when one of the participants in the authentication\nprocess (the terminal or smartphone) is compromised.\n\n10\n\n20\n\n30\n\n40\n\n50\n\nTime (seconds)\n\n(a) 4 characters password\n\n(b) 8 characters password\n\nFigure 9: Empirical CDF of the time it takes for inputting passwords of two different lengths in our first\nprotocol. The total number of trials are 200 obtained\nfrom 20 users.\n\nTable 2: Results of the user study with our protocol. t(4)\nand t(8) are the average time (in seconds) for each user\n(row) to input a password of the given length. The keyboard on the smartphone is re-randomized at each time.\nt(4)\nsuccess\nt(8)\nsuccess\ngender (age)\n25.2\n27.6\n21.1\n18.5\n25.3\n14.8\n16.9\n16.8\n13.1\n24.6\n28.1\n23.0\n23.0\n20.0\n24.1\n24.0\n18.3\n16.9\n16.7\n16.9\n20.7\n\n7.\n\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n98.5%\n\n44.5\n37.6\n29.7\n24.9\n39.3\n23.6\n30.6\n23.6\n34.4\n39.9\n30.5\n31.4\n18.7\n26.5\n25.2\n26.7\n25.7\n35.0\n24.1\n25.9\n29.9\n\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u25e6\u25e6\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\n96%\n\n8. CONCLUSION & FUTURE DIRECTIONS\n\nmale (32)\nmale (31)\nmale (29)\nmale (30)\nmale (29)\nmale (27)\nmale (28)\nmale (30)\nmale (24)\nmale (29)\nmale (27)\nmale (29)\nmale (25)\nfemale (23)\nmale (29)\nmale (31)\nmale (29)\nmale (27)\nmale (30)\nmale (30)\n1:19 (28.7)\n\nIn this paper, we propose and analyze the use of userdriven visualization to improve security and user-friendliness\nof authentication protocols. Although tailored for e-banking,\nand high security environments, they can also be used in\nother contexts. Moreover, we have shown three realizations\nof protocols that not only improve the user experience but\nalso resist challenging attacks, such as the keylogger attack,\nthe shoulder-surfing attack, and the malware attacks. Our\nprotocols utilize simple technologies available in most outof-the-box smartphone devices. Furthermore, we developed\nAndroid application of a prototype of our protocol demonstrates its feasibility and potential in real-world deployment\nand operational settings for user authentication.\nOur work indeed opens the door for several other directions that we would like to investigate as a future work. First,\nwe plan to investigate the design of other protocols with\nmore stringent performance requirements using the same tools\nprovided in this work. In addition, we will study methods\nfor improving the security and user experience by means of\nvisualization in other contexts, but not limited to authentication. Finally, reporting on user studies that will benefit from\na wide deployment and acceptance of our protocols would\nbe a parallel future work to consider as well.\n\nRELATED WORK\n\n9. REFERENCES\n\nThere has been a large body of work on the problem of\nuser authentication in general [29, 35, 26, 33, 40], and in the\ncontext of e-banking as well. Of special interest are authen-\n\n[1] -. BS ISO/IEC 18004:2006. information technology.\nautomatic identification and data capture techniques.\nISO/IEC, 2006.\n11\n\n\f[2] -. Qr-app. http://qr-app.appspot.com/,\n2011.\n[3] -. RedLaser. http://redlaser.com/, July\n2011.\n[4] -. Samsung Galaxy U.\nhttp://tiny.cc/gxydt, 2011.\n[5] -. ShopSavvy. http://shopsavvy.mobi, 2011.\n[6] -. UTF8. http://www.utf8.com/, 2011.\n[7] -. ZXing.\nhttp://code.google.com/p/zxing/, 2011.\n[8] BahnTech. Barcode scanner.\nhttp://www.bahntech.com/iphone/, 2011.\n[9] D. Boneh and X. Boyen. Short signatures without\nrandom oracles. In Proc. of EUROCRYPT, pages\n56\u201373, 2004.\n[10] S. Chiasson, P. van Oorschot, and R. Biddle.\nGraphical password authentication using cued click\npoints. In Proc. of ESORICS, 2008.\n[11] S. Crites, F. Hsu, and H. Chen. Omash: enabling\nsecure web mashups via object abstractions. In Proc.\nof ACM CCS, pages 99\u2013108, 2008.\n[12] D. Davis, F. Monrose, and M. Reiter. On user choice\nin graphical password schemes. In Proc. of USENIX\nSecurity, 2004.\n[13] R. Dhamija and J. D. Tygar. The battle against\nphishing: Dynamic security skins. In Proc. of ACM\nSOUPS, pages 77\u201388, 2005.\n[14] N. Doraswamy and D. Harkins. IPSec: the new\nsecurity standard for the Internet, intranets, and\nvirtual private networks. Prentice Hall, 2003.\n[15] H. Gao, X. Guo, X. Chen, L. Wang, and X. Liu. Yagp:\nYet another graphical password strategy. In Proc. of\nACM ACSAC, pages 121\u2013129, 2008.\n[16] S. Goldwasser, S. Micali, and R. L. Rivest. A digital\nsignature scheme secure against adaptive\nchosen-message attacks. SIAM Journal, 1988.\n[17] Google. Android. http://www.android.com/,\n2011.\n[18] E. Hayashi, R. Dhamija, N. Christin, and A. Perrig.\nUse your illusion: secure authentication usable\nanywhere. In Proc. of ACM SOUPS, 2008.\n[19] C. Herley and D. Florencio. How to login from an\ninternet caf\u00e9 without worrying about keyloggers. In\nProc. of ACM SOUPS, 2006.\n[20] A. Hiltgen, T. Kramp, and T. Weigold. Secure internet\nbanking authentication. IEEE Security and Privacy,\n4:21\u201329, March 2006.\n[21] T. Holz, M. Engelberth, and F. Freiling. Learning\nmore about the underground economy: a case-study of\nkeyloggers and dropzones. In Proc. of ESORICS,\npages 1\u201318, 2009.\n[22] N. Hopper and M. Blum. Secure human identification\nprotocols. In Proc. of ASIACRYPT, 2001.\n[23] R. Housley. RFC3686: Using Advanced Encryption\nStandard (AES) counter mode with ipsec\n\n[24]\n\n[25]\n\n[26]\n\n[27]\n\n[28]\n\n[29]\n\n[30]\n\n[31]\n\n[32]\n\n[33]\n[34]\n\n[35]\n\n[36]\n\n[37]\n\n[38]\n[39]\n\n12\n\nencapsulating security payload (ESP).\nhttp://www.ietf.org/rfc/rfc3686.txt,\n2004.\nS. Josefsson. RFC 4648: the base16, base32, and\nbase64 data encodings.\nhttp://tools.ietf.org/html/rfc4648,\n2006.\nC. Karlof, U. Shankar, J. D. Tygar, and D. Wagner.\nDynamic pharming attacks and locked same-origin\npolicies. In Proc. of ACM CCS, pages 58\u201371, 2007.\nH. Krawczyk, M. Bellare, and R. Canetti. Hmac:\nKeyed-hashing for message authentication. RFC,\n1997.\nM. Kumar, T. Garfinkel, D. Boneh, and T. Winograd.\nReducing shoulder-surfing by using gaze-based\npassword entry. In Proc. of ACM SOUPS, pages\n13\u201319, 2007.\nM. Kumar, T. Garfinkel, D. Boneh, and T. Winograd.\nReducing shoulder-surfing by using gaze-based\npassword entry. In Proc. of ACM SOUPS, pages\n13\u201319, 2007.\nL. Lamport. Password authentication with insecure\ncommunication. Communications of the ACM,\n24(11):770\u2013772, 1981.\nJ. Lim. Defeat spyware with anti-screen capture\ntechnology using visual persistence. In Proc. of ACM\nSOUPS, pages 147\u2013148, 2007.\nJ. M. McCune, A. Perrig, and M. K. Reiter.\nSeeing-is-believing: Using camera phones for\nhuman-verifiable authentication. In Proc. of IEEE\nSymposium on Security and Privacy, pages 110\u2013124,\n2005.\nJ. M. McCune, A. Perrig, and M. K. Reiter.\nSeeing-is-believing: using camera phones for\nhuman-verifiable authentication. International Journal\nof Security and Networks, 4(1/2):43\u201356, 2009.\nM. Naor and B. Pinkas. Visual authentication and\nidentification. In Proc. of CRYPTO, 1997.\nM. Novoa, V. Ali, and M. Altendorf. Virtual user\nauthentication system and method. US Patent App.\n20,080/028,441, 2006.\nD. Otway and O. Rees. Efficient and timely mutual\nauthentication. ACM SIGOPS Operating Systems\nReview, 21(1):8\u201310, 1987.\nB. Parno, C. Kuo, and A. Perrig. Phoolproof phishing\nprevention. In Proc. of Financial Cryptography, pages\n1\u201319, 2006.\nR. Pemmaraju. Methods and apparatus for securing\nkeystrokes from being intercepted between the\nkeyboard and a browser. Patent 182,714.\nE. Rescorla. SSL and TLS: designing and building\nsecure systems. Addison-Wesley, 2001.\nA. Slowinska and H. Bos. Pointless tainting?:\nevaluating the practicality of pointer tainting. In Proc.\nof ACM EuroSys, pages 61\u201374, 2009.\n\n\f25\n20\n15\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\nV15\n\nV17\n\nV19\n\nV15\n\nV17\n\nV19\n\n25\n20\n15\n10\n5\n\nTime (in seconds)\n\n(a) 4 Characters\n\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\n(b) 8 Characters\n\nFigure 10: Boxplot of the different measurements of the\nusers response time when inputting different passwords\nwith length 4 and 8 characters with the case study 1.\nThe boxplot captures the maximum (top 95%), the minimum (lowest 5%), the median, the first and third quartiles (medians of the first and second halves of the population). Note the circles are outliers (more than 1.4 times\nthe maximum)\n\nAPPENDIX\nEXPERIMENTS\n\n30\n20\n10\n\nTime (in seconds)\n\n40\n\nHere we report on the case studies and the time measurements, so of which are reported in section 6. To characterize the time measurements, we use boxplots, which capture\nthe the 5%, 95% maximum, mean, first and second quartiles, and the outliers of measurements. Outliers are measurements that are 1.4 times the 95% maximum or 1.4 times\nthe 5% minimum.\nCase study 1. The boxplot of the raw time measures (per\nsubject) is shown in Figure 10(a) for 4 characters case and in\nFigure 10(b) for 8 characters case. More measurements, the\npasswords, and error rates are shown in Table 3.\nCase study 2. The boxplot of the raw time measures (per\nsubject) is shown in Figure 11(a) for 4 characters case and in\nFigure 11(b) for 8 characters case. More measurements, the\npasswords, and error rates are shown in Table 4.\nCase study 3. The boxplot of the raw time measures (per\nsubject) is shown in Figure 12(a) for 4 characters case and in\nFigure 12(b) for 8 characters case. More measurements, the\npasswords, and the raw error rates are shown in Table 5.\n\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\nV15\n\nV17\n\nV19\n\nV15\n\nV17\n\nV19\n\n40\n30\n20\n\nTime (in seconds)\n\n(a) 4 Characters\n\n10\n\nA.\n\n10\n5\n\nTime (in seconds)\n\n30\n\n[40] J. Steiner, C. Neuman, and J. Schiller. Kerberos: An\nauthentication service for open networks. In Proc. of\nUSENIX Annual Tech Conference, pages 191\u2013201,\n1988.\n[41] B. Stone-Gross, M. Cova, L. Cavallaro, B. Gilbert,\nM. Szydlowski, R. Kemmerer, C. Kruegel, and\nG. Vigna. Your botnet is my botnet: analysis of a\nbotnet takeover. In Proc. of ACM CCS, pages\n635\u2013647, 2009.\n[42] X. Suo, Y. Zhu, and G. Owen. Graphical passwords: A\nsurvey. IEEE Computer, 2005.\n[43] J. Thorpe and P. van Oorschot. Human-seeded attacks\nand exploiting hot-spots in graphical passwords. In\nProc. of USENIX Security, 2007.\n[44] G. Vizcaino. Method and apparatus for securing credit\ncard transactions. US Patent 5,317,636, 1994.\n[45] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.\nPanorama: capturing system-wide information flow\nfor malware detection and analysis. In Proc. of ACM\nCCS, 2007.\n\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\n(b) 8 Characters\n\nFigure 11: Boxplot of the different measurements of the\nusers response time when inputting different passwords\nwith length 4 and 8 characters with the case study 2.\n\n13\n\n\fTable 3: Results of the user study with qwerty keypad.\nThe time is the average time per 10 trials (in seconds)\nfor each user (row) to input the password. The keyboard\non the smartphone is re-randomized at each time. The\nsuccess is computed out of 10 trials per each user.\ntime\n\nsuccess\n\npwd (8)\n\ntime\n\nsuccess\n\nt4pw\ndata\ncode\nusa8\nhead\n1213\n1596\n4455\n2222\n1317\nbhnj\n1317\n712\naple\nsave\ncola\nasdf\n503\nu137\nuku0\n\n9.4\n4.2\n4.4\n6\n4.1\n4.6\n4.2\n2.5\n3\n2.9\n3.7\n3.4\n4.2\n4.8\n2.9\n2.7\n3.6\n4.2\n5.4\n4\n\n10\n9\n9\n10\n10\n10\n9\n10\n10\n9\n10\n9\n10\n10\n10\n10\n9\n9\n9\n10\n\naplegw2j\nkeywords\nasdfnews\nmicroarm\nnetworks\njjae1213\nmbc2356z\ndd4455ee\n78061622\nucsl1317\n1116baek\n12341317\n88061100\nhjh37267\n20110714\ncocacola\n19830325\nbabosmjk\ncoffee20\nterminal\n\n8.2\n7.2\n6.4\n10.4\n8.8\n6.4\n6.5\n3.8\n8.5\n6.1\n6.3\n5.4\n5.4\n6\n5.5\n5.2\n7.2\n7.3\n8.3\n7.3\n\n9\n9\n10\n8\n4\n10\n10\n10\n10\n8\n10\n7\n10\n9\n9\n10\n10\n9\n10\n10\n\nTable 4: Results of the user study with the randomized\nkeyboard. The time is the average time per 10 trials (in\nseconds) for each user (row) to input the password. The\nkeyboard on the smartphone is re-randomized at each\ntime. The success is computed out of 10 trials per each\nuser.\npwd (4) time success\npwd (8)\ntime success\nt4pw\ndata\ncode\nusa8\nhead\n1213\n1596\n4455\n2222\n1317\nbhnj\n1317\n712\naple\nsave\ncola\nasdf\n503\nu137\nuku0\n\n40\n30\n20\n10\n\nTime (in seconds)\n\n50\n\npwd (4)\n\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\nV15\n\nV17\n\nV19\n\nV15\n\nV17\n\nV19\n\n40\n30\n20\n\nTime (in seconds)\n\n50\n\n(a) 4 Characters\n\nV1\n\nV3\n\nV5\n\nV7\n\nV9\n\nV11\n\nV13\n\n(b) 8 Characters\n\nFigure 12: Boxplot of the different measurements of the\nusers response time when inputting different passwords\nwith length 4 and 8 characters in protocol's experiment.\n\n14\n\n13.9\n13\n10.1\n10.2\n13.3\n6.7\n6.6\n4.1\n5\n5.5\n10.1\n5.5\n6.1\n11.2\n10.1\n9.3\n23.4\n5.3\n9.4\n8.6\n\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n\naplegw2j\nkeywords\nasdfnews\nmicroarm\nnetworks\njjae1213\nmbc2356z\ndd4455ee\n78061622\nucsl1317\n1116baek\n12341317\n88061100\nhjh37267\n20110714\ncocacola\n19830325\nbabosmjk\ncoffee20\nterminal\n\n18.8\n18.9\n22.3\n13.2\n24\n10.8\n14.4\n9.4\n10.7\n15.1\n18.4\n8.6\n8.4\n11.4\n11.1\n16.1\n17.3\n16\n11.4\n18.3\n\n9\n9\n10\n10\n10\n9\n7\n10\n10\n10\n9\n9\n10\n10\n7\n10\n10\n10\n9\n10\n\n\fTable 5: Results of the user study with our protocol. The\ntime is the average time per 10 trials (in seconds) for each\nuser (row) to input the password. The keyboard on the\nsmartphone is re-randomized at each time. The success\nis computed out of 10 trials per each user.\npwd (4)\n\ntime\n\nsuccess\n\npwd (8)\n\ntime\n\nsuccess\n\nt4pw\ndata\ncode\nusa8\nhead\n1213\n1596\n4455\n2222\n1317\nbhnj\n1317\n712\naple\nsave\ncola\nasdf\n503\nu137\nuku0\n\n25.2\n27.6\n21.1\n18.5\n25.3\n14.8\n16.9\n16.8\n13.1\n24.6\n28.1\n23\n23\n20\n24.1\n24\n18.3\n16.9\n16.7\n16.9\n\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n9\n10\n10\n10\n10\n9\n9\n10\n10\n\naplegw2j\nkeywords\nasdfnews\nmicroarm\nnetworks\njjae1213\nmbc2356z\ndd4455ee\n78061622\nucsl1317\n1116baek\n12341317\n88061100\nhjh37267\n20110714\ncocacola\n19830325\nbabosmjk\ncoffee20\nterminal\n\n42.9\n37.6\n29.7\n24.9\n39.3\n23.6\n30.6\n23.6\n34.4\n39.9\n30.5\n31.4\n18.7\n26.5\n25.2\n26.7\n25.7\n35\n24.1\n25.9\n\n9\n10\n10\n10\n10\n9\n10\n10\n10\n10\n10\n10\n10\n10\n10\n8\n10\n8\n8\n10\n\n15\n\n\f"}