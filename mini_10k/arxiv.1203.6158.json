{"id": "http://arxiv.org/abs/1203.6158v1", "guidislink": true, "updated": "2012-03-28T05:06:14Z", "updated_parsed": [2012, 3, 28, 5, 6, 14, 2, 88, 0], "published": "2012-03-28T05:06:14Z", "published_parsed": [2012, 3, 28, 5, 6, 14, 2, 88, 0], "title": "Mendler-style Iso-(Co)inductive predicates: a strongly normalizing\n  approach", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.6302%2C1203.0503%2C1203.3005%2C1203.3016%2C1203.3510%2C1203.2970%2C1203.5277%2C1203.6363%2C1203.4315%2C1203.3621%2C1203.4502%2C1203.4914%2C1203.3708%2C1203.5143%2C1203.1925%2C1203.6350%2C1203.1483%2C1203.3612%2C1203.3073%2C1203.4964%2C1203.0197%2C1203.0811%2C1203.4617%2C1203.6403%2C1203.6104%2C1203.3201%2C1203.4877%2C1203.5904%2C1203.3781%2C1203.2303%2C1203.2056%2C1203.1738%2C1203.4705%2C1203.6513%2C1203.6893%2C1203.1769%2C1203.2031%2C1203.2022%2C1203.5339%2C1203.5342%2C1203.3632%2C1203.1909%2C1203.3589%2C1203.6825%2C1203.0611%2C1203.0533%2C1203.4842%2C1203.5546%2C1203.0712%2C1203.1640%2C1203.0443%2C1203.6158%2C1203.0670%2C1203.1163%2C1203.1643%2C1203.0746%2C1203.1434%2C1203.1768%2C1203.6125%2C1203.0995%2C1203.4052%2C1203.4865%2C1203.5949%2C1203.1922%2C1203.0540%2C1203.5505%2C1203.4668%2C1203.5133%2C1203.3720%2C1203.5481%2C1203.1220%2C1203.1869%2C1203.6514%2C1203.6414%2C1203.5093%2C1203.5182%2C1203.2378%2C1203.6286%2C1203.4999%2C1203.3603%2C1203.0860%2C1203.6417%2C1203.5549%2C1203.3172%2C1203.6264%2C1203.5876%2C1203.3560%2C1203.5394%2C1203.0278%2C1203.3239%2C1203.6474%2C1203.3923%2C1203.6559%2C1203.0289%2C1203.5204%2C1203.6890%2C1203.5221%2C1203.2596%2C1203.5393%2C1203.3865%2C1203.4295&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Mendler-style Iso-(Co)inductive predicates: a strongly normalizing\n  approach"}, "summary": "We present an extension of the second-order logic AF2 with iso-style\ninductive and coinductive definitions specifically designed to extract programs\nfrom proofs a la Krivine-Parigot by means of primitive (co)recursion\nprinciples. Our logic includes primitive constructors of least and greatest\nfixed points of predicate transformers, but contrary to the common approach, we\ndo not restrict ourselves to positive operators to ensure monotonicity, instead\nwe use the Mendler-style, motivated here by the concept of monotonization of an\narbitrary operator on a complete lattice. We prove an adequacy theorem with\nrespect to a realizability semantics based on saturated sets and\nsaturated-valued functions and as a consequence we obtain the strong\nnormalization property for the proof-term reduction, an important feature which\nis absent in previous related work.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.6302%2C1203.0503%2C1203.3005%2C1203.3016%2C1203.3510%2C1203.2970%2C1203.5277%2C1203.6363%2C1203.4315%2C1203.3621%2C1203.4502%2C1203.4914%2C1203.3708%2C1203.5143%2C1203.1925%2C1203.6350%2C1203.1483%2C1203.3612%2C1203.3073%2C1203.4964%2C1203.0197%2C1203.0811%2C1203.4617%2C1203.6403%2C1203.6104%2C1203.3201%2C1203.4877%2C1203.5904%2C1203.3781%2C1203.2303%2C1203.2056%2C1203.1738%2C1203.4705%2C1203.6513%2C1203.6893%2C1203.1769%2C1203.2031%2C1203.2022%2C1203.5339%2C1203.5342%2C1203.3632%2C1203.1909%2C1203.3589%2C1203.6825%2C1203.0611%2C1203.0533%2C1203.4842%2C1203.5546%2C1203.0712%2C1203.1640%2C1203.0443%2C1203.6158%2C1203.0670%2C1203.1163%2C1203.1643%2C1203.0746%2C1203.1434%2C1203.1768%2C1203.6125%2C1203.0995%2C1203.4052%2C1203.4865%2C1203.5949%2C1203.1922%2C1203.0540%2C1203.5505%2C1203.4668%2C1203.5133%2C1203.3720%2C1203.5481%2C1203.1220%2C1203.1869%2C1203.6514%2C1203.6414%2C1203.5093%2C1203.5182%2C1203.2378%2C1203.6286%2C1203.4999%2C1203.3603%2C1203.0860%2C1203.6417%2C1203.5549%2C1203.3172%2C1203.6264%2C1203.5876%2C1203.3560%2C1203.5394%2C1203.0278%2C1203.3239%2C1203.6474%2C1203.3923%2C1203.6559%2C1203.0289%2C1203.5204%2C1203.6890%2C1203.5221%2C1203.2596%2C1203.5393%2C1203.3865%2C1203.4295&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present an extension of the second-order logic AF2 with iso-style\ninductive and coinductive definitions specifically designed to extract programs\nfrom proofs a la Krivine-Parigot by means of primitive (co)recursion\nprinciples. Our logic includes primitive constructors of least and greatest\nfixed points of predicate transformers, but contrary to the common approach, we\ndo not restrict ourselves to positive operators to ensure monotonicity, instead\nwe use the Mendler-style, motivated here by the concept of monotonization of an\narbitrary operator on a complete lattice. We prove an adequacy theorem with\nrespect to a realizability semantics based on saturated sets and\nsaturated-valued functions and as a consequence we obtain the strong\nnormalization property for the proof-term reduction, an important feature which\nis absent in previous related work."}, "authors": ["Favio Ezequiel Miranda-Perea", "Lourdes del Carmen Gonz\u00e1lez-Huesca"], "author_detail": {"name": "Lourdes del Carmen Gonz\u00e1lez-Huesca"}, "author": "Lourdes del Carmen Gonz\u00e1lez-Huesca", "links": [{"title": "doi", "href": "http://dx.doi.org/10.4204/EPTCS.81.3", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1203.6158v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1203.6158v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "In Proceedings LSFA 2011, arXiv:1203.5423", "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.4.1, F.3.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1203.6158v1", "affiliation": "Facultad de Ciencias UNAM", "arxiv_url": "http://arxiv.org/abs/1203.6158v1", "journal_reference": "EPTCS 81, 2012, pp. 30-46", "doi": "10.4204/EPTCS.81.3", "fulltext": "Mendler-style Iso-(Co)inductive predicates: a strongly\nnormalizing approach \u2217\nFavio Ezequiel Miranda-Perea\nLourdes del Carmen Gonz\u00e1lez-Huesca\nDepartamento de Matem\u00e1ticas, Facultad de Ciencias UNAM\nCircuito Exterior S/N, Cd. Universitaria, 04510, M\u00e9xico D.F., M\u00e9xico\nfavio@ciencias.unam.mx\n\nluglzhuesca@ciencias.unam.mx\n\nWe present an extension of the second-order logic AF2 with iso-style inductive and coinductive\ndefinitions specifically designed to extract programs from proofs \u00e0 la Krivine-Parigot by means of\nprimitive (co)recursion principles. Our logic includes primitive constructors of least and greatest\nfixed points of predicate transformers, but contrary to the common approach, we do not restrict\nourselves to positive operators to ensure monotonicity, instead we use the Mendler-style, motivated\nhere by the concept of monotonization of an arbitrary operator on a complete lattice. We prove an\nadequacy theorem with respect to a realizability semantics based on SAT (saturated) sets and SATvalued functions and as a consequence we obtain the strong normalization property for the proof-term\nreduction, an important feature which is absent in previous related work.\nKeywords: Mendler-style, (co)inductive definitions, primitive (co)recursion, strong normalization,\nsaturated set, monotonization, second-order logic, programming with proofs.\n\n1\n\nIntroduction\n\nThe system AF2 for second-order intuitionistic logic introduced by Leivant and Krivine [5, 4], is one\nof the most fruitful systems obtained by the Curry-Howard correspondence. It types exactly the same\nterms as the system F of Girard and Reynolds and shares with it the properties of strong normalization\nand subject reduction. Its main improvement with respect to system F is that it allows the extraction of\nprograms via the programming-with-proofs paradigm of Krivine and Parigot. This method, originally\ndeveloped in [3] (see also [5]) ensures the correctness of programs (\u03bb -terms) extracted from proofs\nof termination statements of functions involving formal data types, that is, from proofs of totality. Well\nknown results ensure the extraction of programs for all functions whose termination is provable in second\norder Peano arithmetic. Nevertheless this result, satisfactory from the extensional point of view does\nnot suffice for an intensional view concerning programs. In AF2 we can get programs for all needed\nfunctions, but these do not have necessarily the intended behavior, see [13]. To solve this problem\nsome extensions of AF2 with least fixed points (TTR [14]) and also with greatest fixed points (AF2\u03bc\u03bd\n[15]) have been introduced. These features allow for the (co)inductive definition of predicates and are\nsuitable for programming with proofs. However the strong normalization is lost due to the use of a\nfixed-point combinator in the proof-term system, which encodes derivations with lambda terms. The\nsituation is that an iterative function f can be defined within AF2 and therefore its extracted program\nf \u0304 is automatically terminating, but the extracted program for a primitive recursive function employs\na fixed-point combinator in the extensions of AF2 and therefore its termination is not obvious at all.\n\u2217 This\n\nresearch is being supported by PAPIIT-UNAM projects IN117711 and IN108810.\n\nRonchi della Rocca, S., Pimentel, E. (Eds.): 6th Workshop on\nLogical and Semantic Frameworks with Applications 2011 (LSFA 2011).\nEPTCS 81, 2012, pp. 30\u201346, doi:10.4204/EPTCS.81.3\n\nc Miranda-Perea and Gonz\u00e1lez-Huesca\nThis work is licensed under the\nCreative Commons Attribution License.\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n31\n\nThis has lead to sophisticated methods to verify that these programs indeed terminate [6], even when\nthey fit into a well-known terminating recursion pattern captured in G\u00f6del's T for the case of natural\nnumbers and generalized to all (co)inductive types in [9, 7, 8], for example. The main contribution\nof this paper is the introduction of a new extension of AF2 with primitive (co)recursion over least and\ngreatest fixed points, called AF2M\u03bc\u03bd , that enjoys the strong normalization property. Instead of using a\nfixed-point combinator we use the Mendler-style approach of [8] but with two important differences: we\nuse a natural deduction approach, and we do not restrict ourselves to positive operators. This shows that\nsuch syntactical restriction is irrelevant to the strong normalization proof of the whole Mendler-system,\na feature first discovered by Matthes ([7], p.83) for the inductive fragment. Another contribution of\nour work is the use of the iso-style, meaning that a (co)inductive predicate and its folding/unfolding are\nnot considered equal but isomorphic. It is important to mention that previous extensions of AF2 with\n(co)inductive definitions deal only with equi-style predicates, but in our opinion the use of the iso-style\nis closer to the usual mechanisms of data type definition in functional programming languages. As a\nconsequence of our definition of saturated sets, the proof of the adequacy theorem of our logic does not\nemploy ordinal recursion. Moreover, the rules of our logic are specifically designed to derive statements\nof totality of functions involving (co)inductive predicates, that is, formulas of the form \u2200x.P(x) \u2192\nR( f (x)). The paper is organized as follows: in section 2 we review the required concepts of fixed-point\ntheory needed to motivate the definition of our logic, which is given in section 3, together with some\nexamples of its expressivity. Section 4 develops the constructions on saturated sets employed in section\n5 to define an intuitionistic semantics of the logic. Finally, we discuss related work in section 6 and\nprovide some closing remarks in section 7.\n\n2\n\nFixed-point theory\n\nd\nd\nIn this section we recall some tools of fixed-point theory involving a complete lattice hL , v, i, where\nis the infimum operator. Given a monotone operator \u03a6 : L \u2192 L the Knaster-Tarski theorem guarantees\nthe existence of the least (greatest) fixed-point of \u03a6, denoted lfp(\u03a6) or gfp(\u03a6), respectively.\nProposition 1 (Conventional\n(co)induction principles). Let \u03a6 : L \u2192 L be a monotone operator on a\nd\ncomplete lattice hL , v, i. The following holds for every M \u2208 L .\n\u25e6 Induction: if \u03a6(M) v M then lfp(\u03a6) v M.\nd \u0001\n\u25e6 Extended induction: if \u03a6 lfp(\u03a6) M v M then lfp(\u03a6) v M.\n\u25e6 Coinduction: if M v \u03a6(M) then M v gfp(\u03a6).\nF \u0001\n\u25e6 Extended coinduction 1 : if M v \u03a6 gfp(\u03a6) M then M v gfp(\u03a6).\n\nProof. Straightforward.\nThe following concepts of monotonization of an arbitrary operator are taken from [7].\nDefinition 1. Given an arbitrary operator \u03a6 : L \u2192 L , we define its upper monotonization \u03a6w : L \u2192\nF\nL and its lower monotonization \u03a6v : L \u2192 L as \u03a6w (M) = {\u03a6(X) | X v M} and \u03a6v (M) =\nd\n{\u03a6(X) | M v X}.\nThe properties and relationships between \u03a6 and its monotonizations are given in the following\nProposition 2. If \u03a6 : L \u2192 L is an arbitrary operator then \u03a6v and \u03a6w are monotone. Moreover,\n1 Recall\n\nthat in a complete lattice the supremum operator\n\nF\n\ncan be defined from the infimum operator\n\nd\n\n.\n\n\f32\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\u25e6 For any M \u2208 L , \u03a6v (M) v \u03a6(M) v \u03a6w (M).\n\u25e6 If \u03a6 is monotone then \u03a6v = \u03a6 = \u03a6w and if \u03a6v = \u03a6 or \u03a6 = \u03a6w then \u03a6 is monotone.\n\u25e6 \u03a6(lfp(\u03a6w )) v lfp(\u03a6w ) and gfp(\u03a6v ) v \u03a6(gfp(\u03a6v )).\n\nProof. Straightforward.\nNext we justify the Mendler-style (co)induction principles by means of the monotonizations. This\njustification is not present in the original work of Mendler ([8]). However, the inductive part is discussed\nin [7].\nProposition 3 (Mendler (Co)induction principles). The following holds for any \u03a6 : L \u2192L and M\u2208 L .\n\u0001\n\u25e6 Induction: if \u2200X X v M \u2192 \u03a6(X) v M then lfp(\u03a6w ) v M.\n\u0001\n\u25e6 Extended Induction: if \u2200X X v lfp(\u03a6w ) \u2192 X v M \u2192 \u03a6(X) v M then lfp(\u03a6w ) v M.\n\u0001\n\u25e6 Coinduction: if \u2200X M v X \u2192 M v \u03a6(X) then M v gfp(\u03a6v ).\n\u0001\n\u25e6 Extended Coinduction: if \u2200X gfp(\u03a6v ) v X \u2192 M v X \u2192 M v \u03a6(X) then M v gfp(\u03a6v ).\nProof. The conventional (co)induction principles for \u03a6v and \u03a6w yield the required principles. For\ndetails see [11].\n\n3\n\nThe Logic AF2M\u03bc\u03bd\n\nWe present now the logic AF2M\u03bc\u03bd , which is an extension of AF2 with Mendler-style (co)inductive definitions.\n\u25e6 Terms: the object terms are defined as usual from a signature \u03a3 including function symbols f of a\ngiven arity.\nt ::= x | f (t1 , . . . ,tn )\n\u25e6 Predicates: apart from the usual predicates (second-order variables or predicate symbols of a signature \u03a3) we have comprehension predicates, inductive predicate \u03bc(\u03a6) and coinductive predicates\n\u03bd(\u03a6).\nP ::= X | P | F | \u03bc(\u03a6) | \u03bd(\u03a6)\nhere F is a comprehension predicate of the form F =de f \u03bb~x.A, where A is a formula and its arity\nis the length of the vector of variables ~x, this predicate intends to represent the set {~t | A[~x :=~t ]}.\nOn the other hand, \u03a6 is an arbitrary predicate transformer, which is a closed expression of the\nform \u03a6 =de f \u03bb X.P, depending on a second-order variable X. Observe that we do not require any\nsyntactic restriction, like positivity, on the occurrences of X in P.\n\u25e6 Formulas: these are defined as usual\nA, B ::= P(t1 , . . . ,tn ) | A \u2192 B | \u2200xA | \u2200XA\n\u25e6 On equations: term equations are formulas which play an important role in the logic and are\ndefined as usual in second-order logic: the equation r = s stands for the formula \u2200X.X(r) \u2192 X(s).\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n33\n\nThe judgments of the logic are of the form \u0393 `E t : A where \u0393 = {x1 : A1 , . . . , xn : An } is a context\nof formulas annotated by proof-term variables, E = {r1 = s1 , . . . , rn = sn } is a context of equations, A\nis a formula and t is a proof-term, which is a lambda term not to be confused with an object term, for\neven when we use the same meta-variables for both, object and proof-terms, we consider them to be two\ncompletely separated syntactic categories. The derivation relation is inductively defined by means of the\nfollowing inference rules, where A[x := r] (A[X := P]) always denotes capture-avoiding substitution of\nfirst-order (second-order) variables by a term (predicate) in the formula A.\n\u25e6 Rules of AF2:\n\n\u0393, x : A ` x : A (Var)\n\n\u0393, x : A ` r : B\n(\u2192 I)\n\u0393 ` \u03bb xr : A \u2192 B\n\n\u0393`t :A x\u2208\n/ FV (\u0393)\n(\u2200I)\n\u0393 ` t : \u2200xA\n\u0393`t :A X \u2208\n/ FV (\u0393) 2\n(\u2200 I)\n\u0393 ` t : \u2200XA\n\n\u0393`r:A\u2192B \u0393`s:A\n(\u2192 E)\n\u0393 ` rs : B\n\u0393 ` t : \u2200xA\n(\u2200E)\n\u0393 ` t : A[x := r]\n\n\u0393 ` t : \u2200XA\n(\u22002 E)\n\u0393 ` t : A[X := P]\n\n\u0393 `E t : A[x := r] E B r = s\n(Eq)\n\u0393 `E t : A[x := s]\nHere E B r = s means a derivation of r = s from the set of equations E according to the following\nrules:\n\u2013 E B r = s, if r = s is a particular case of an equation in E. That is an equation of the form\nr1 [~x :=~t ] = r2 [~x :=~t ] or r2 [~x :=~t ] = r1 [~x :=~t ], where r1 = r2 \u2208 E and ~t are arbitrary terms.\n\u2013 r = s was obtained from E by reflexivity, transitivity or compatibility with functions, that is,\nby one of the following rules:\n\nEBr = r\n\nEBr = s EBs = t\nEBr = t\n\nE B r1 = s1 . . . E B rn = sn\nE B f (r1 , . . . , rn ) = f (s1 , . . . , sn )\n\n\u25e6 Rules involving (co)inductive definitions: these rules are specifically designed to construct (destruct) elements of an inductive (coinductive) predicate and to prove statements of totality of\nfunctions. Given two n-ary2 predicates P, R, and a vector ~g of n function symbols, the following notation will be used: P \u2286~g R is the formula \u2200~x.P(~x ) \u2192 R(~g(~x )), where, in general, a vector application of ~f =de f f1 , . . . , fn to ~t =de f t1 , . . . ,tn , denoted ~f (~t ), is defined as\n~f (~t ) =de f f1 (t1 ), . . . , fn (tn ). In particular P \u2286 R is the formula \u2200~x.P(~x) \u2192 R(~x) or even P \u2192 R,\nif the predicates have arity 0. Given a predicate transformer \u03a6 =de f \u03bb X.P and a predicate R, the\napplication of \u03a6 to R, is defined by \u03a6(R) =de f P[X := R], clearly \u03a6(R) is a predicate.\nThe following rules are motivated by the last part of proposition 2 and by proposition 3, for lattices of sets. It is important to observe that in each rule we employ \u03bc(\u03a6) or \u03bd(\u03a6) instead of the\nexpected \u03bc(\u03a6w ) or \u03bd(\u03a6v ). This choice will be justified by the semantics.\n2 We are mostly interested in predicates for data types, which means n = 1. However we present the system for any arity for\nthe sake of generality.\n\n\f34\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\u2013 Inductive construction and coinductive destruction: for any (co)inductive predicate \u03bc(\u03a6) or\n~ called the constructors\n\u03bd(\u03a6) of arity n, we assume a fixed set of n function symbols ~c or d,\nof \u03bc(\u03a6) or the destructors of \u03bd(\u03a6).\n\u0393 ` r : \u03a6(\u03bc(\u03a6))(~t )\n(\u03bcI)\n\u0393 ` in r : \u03bc(\u03a6)(~c(~t ) )\n\n\u0393 ` r : \u03bd(\u03a6)(~t )\n~ ~t ))\n\u0393 ` out r : \u03a6(\u03bd(\u03a6))(d(\n\n(\u03bdE)\n\nThese rules correspond to the last part of proposition 2, but observe that our (co)inductive\n~ Morepredicates are in iso-style, due to the presence of the constructors ~c (destructors d).\nover, the equi-style can be easily recovered by using as constructors/destructors the identity\nfunction symbol id while adding id(x) = x to the equational axioms.\n\u2013 Primitive recursion: this rule is modelled after the Mendler extended induction principle\ngiven by proposition 3. Here we regard a composition f \u25e6 c as a new function symbol defined by the equation ( f \u25e6 c)(x) = f (c(x)) and a composition of tuples ~f \u25e6~c as the tuple\nf1 \u25e6 c1 , . . . , fn \u25e6 cn .\n\u0001\n\u0393 ` s : \u2200X X \u2286 \u03bc(\u03a6) \u2192 X \u2286~f K \u2192 \u03a6(X) \u2286~f \u25e6~c K\n\u0393 ` r : \u03bc(\u03a6)(~t )\n(\u03bcE)\n\u0393 ` MRec s r : K (~f (~t ))\n\u2013 Primitive corecursion: the Mendler extended coinduction principle of proposition 3 inspires\nthe following rule. Observe that in both rules (recursion and corecursion), we can recover the\ncorresponding exact principle of proposition 3 by using the equi-style and by regarding f as\nthe identity function via the equation f (x) = x.\n\u0001\n\u0393 ` s : \u2200X \u03bd(\u03a6) \u2286 X \u2192 K \u2286~f X \u2192 K \u2286d\u25e6\n\u0393 ` r : K (~t )\n~ ~f \u03a6(X)\n(\u03bdI)\n\u0393 ` MCoRec s r : \u03bd(\u03a6)(~f (~t ))\n\u25e6 Operational semantics: To end the definition of our logic, we define the operational semantics of\nthe proof-term reduction, which is given by the one-step reduction relation t \u2192\u03b2 t 0 defined as the\nclosure of the following axioms under all term formers.\n(\u03bb xr)s \u2192\n7 \u03b2\nMRec s(int) \u2192\n7 \u03b2\nout(MCoRec s t) 7\u2192\u03b2\n\nr[x := s]\ns(\u03bb xx)(MRec s)t\ns(\u03bb xx)(MCoRec s)t\n\nHere and troughout the paper MRec s means \u03bb x. MRec s x and the same is true for MCoRec s.\n\u25e6 Derived rules: To simplify the presentation of examples we will employ the usual second-order\nencodings for conjunctions, disjunctions and existential formulas, which allow to obtain the following derived rules for judgements and operational semantics:\n\u0393`r:A \u0393`s:B\n(\u2227I)\n\u0393 ` hr, si : A \u2227 B\n\n\u0393 ` s : A\u2227B\n(\u2227EL )\n\u0393 ` fst s : A\n\n\u0393`r:A\n(\u2228IL )\n\u0393 ` inl r : A \u2228 B\n\n\u0393 ` s : A\u2227B\n(\u2227ER )\n\u0393 ` snd s : B\n\n\u0393`r:B\n(\u2228IR )\n\u0393 ` inr r : A \u2228 B\n\n\u0393 ` r : A \u2228 B \u0393, x : A ` s : C \u0393, y : B ` t : C\n(\u2228E)\n\u0393 ` case(r, x.s, y.t) : C\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n35\n\u0393 ` t : \u2203x.A \u0393, u : A ` r : B x \u2208\n/ FV (\u0393, B)\n\u0393 ` open(t, u.r) : B\n\n\u0393 ` t : A[x := r]\n\u0393 ` packt : \u2203x.A\nfsthr, si \u2192\n7 \u03b2\ncase(inl r, x.s, y.t) \u2192\n7 \u03b2\n\nr\ns[x := r]\n\nsndhr, si \u2192\n7 \u03b2\ncase(inr r, x.s, y.t) \u2192\n7 \u03b2\n\ns\nt[y := r]\n\nopen(packt, u.r) 7\u2192\u03b2 r[u := t]\nThe proof-reduction behaves well with respect to the derivation relation, as ensured by the following\nProposition 4 (Subject-reduction of AF2M\u03bc\u03bd ). If \u0393 `E t : A and t \u2192? t 0 then \u0393 `E t 0 : A.\nProof. The proof is not trivial since AF2M\u03bc\u03bd is formulated in Curry-style and it is analogous to the one\ndeveloped in [9] for a similar system.\n\n3.1\n\nOn (Co)Iteration\n\nIn fixed-point theory, (co)iteration can be easily derived from primitive (co)recursion. This is not the\ncase for conventional (co)induction principles in type theory like the ones developed in [9] (see section 4.5 of [7] for a deep discussion on this subject) and therefore (co)iterators must be defined apart\nfrom (co)recursors. For the Mendler-style, (co)iterators correspond to the (co)induction principles of\nproposition 3, and are again superfluous (as noticed also in [7]). Let us define MIt s r =de f MRec s0 r\nand MCoIt s r =de f MCoRec s0 r, where s0 =de f \u03bb .s and is a dummy variable. The following rules for\ninference and proof-reduction are derivable:\n\u25e6 Iteration\n\n\u25e6 Coiteration\n\n\u0001\n\u0393 ` s : \u2200X X \u2286~f K \u2192 \u03a6 X \u2286~f \u25e6~c K\n\u0393 ` r : \u03bc(\u03a6)(~t )\n(\u03bcE \u2212 )\n\u0393 ` MIt s r : K (~f (~t ))\n\u0393 ` s : \u2200X K \u2286~f X \u2192 K \u2286d\u25e6\n~ ~f \u03a6 X\n\n\u0001\n\n\u0393 ` MCoIt s r : \u03bd(\u03a6)(~f (~t ))\nMIt s(int) \u2192 s(MIt s)t\n\n\u0393 ` r : K (~t )\n\n(\u03bdI \u2212 )\n\nout(MCoIt s t) \u2192 s(MCoIt s)t\n\nWe will use both the (co)iteration and the primitive (co)recursion rules in the examples that we discuss\nnext.\n\n3.2\n\nExamples\n\nIn this section we develop some examples of (co)inductive predicates that show the expressivity of our\nlogic. Due to lack of space a deep discussion about the advantages and disadvantages of both the\niso-style and the equi-style is missing. Instead, we provide some examples that show some of such\n(dis)advantages. Every program (\u03bb -term) f presented here is extracted from a proof of totality for a\nfunction f involving (co)inductive predicates and specified by a set of equations in the logic. Moreover,\nthe reader can verify that in each case f is operationally correct.\nExample 1 (Iso-inductive ad-hoc Natural Numbers). Let h i =de f \u03bb x.x = ? where ? is a fixed constant,\nthis comprehension predicate is called unit predicate and represents a type with unique inhabitant ?. We\ndefine the predicate of natural numbers as N =de f \u03bc(\u03a6) where \u03a6 =de f \u03bb X.\u03bb x.hhi(x) \u2228 X(x), taking the\n\n\f36\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\nsuccessor function suc as constructor and suc(?) = 0 as equational axiom. Defining 0 =de f in(inl()),3\nand suc =de f \u03bb x. in(inr x) we can show that ` 0 : N(0) and ` suc : \u2200x.N(x) \u2192 N(suc x). We call this\nan ad-hoc definition, for zero is in the image of the successor and therefore our representation is not\ncompatible with Peano's axioms. This is an unpleasant feature which can be avoided at some cost (see\nexample 3). However, operationally, our definition is adequate. For instance, the sum and factorial are\nprogrammed as follows:\n\u25e6 Sum: from Esum = {sum n 0 = n, sum n (suc m) = suc (sum n m)} , we get `Esum sum : \u2200n.\u2200x.N(n) \u2192\nN(x) \u2192 N(sum n x), where sum =de f \u03bb n. MIt s and s =de f \u03bb y\u03bb z.case(z, u.n, v.suc(yv)). This program behaves correctly: sum n 0 \u2192? n and sum n (suc m) \u2192? suc(sum n m).\n\u25e6 Factorial: using the equations Efac = {fac 0 = 1, fac (suc n) = (suc n) \u2217 (fac n)}, we can derive\n`Efac fac : \u2200x.N(x) \u2192 N(fac x), where fac =de f MRec s and the step term s is defined as s =de f\n\u03bb y\u03bb z\u03bb w.case(w, u.1, v.suc(yv)\u2217(zv)).\nThe reader should convince herself that the naive definition of natural numbers coming from fixed\npoint theory, given by the predicate transformer \u03a6 =de f \u03bb X.\u03bb x.x = 0 \u2228 X(x), does not work. In the\nequi-inductive approach we cannot construct any number other than zero, and in the iso-inductive case\nwe cannot construct the zero. Another possibility is the one taken in [16], discussed next.\nExample 2 (Equi-inductive Natural Numbers). We define N =de f \u03bc(\u03a6) with the predicate transformer\n\u03a6 = \u03bb X.\u03bb x.Z(x) \u2228 X(p(x)) where Z =de f \u03bb x.x = 0 and p is a function symbol, whose intended meaning\nis the predecessor function. We have ` 0 : N(0) and ` p : \u2200x.N(p(x)) \u2192 N(x) where 0 =de f in(inl())\nand p =de f \u03bb x. in(inr x). In this case we have the following derivation: f0 : \u2200x.Z(x) \u2192 It(x), f p :\n\u2200x.It(p(x)) \u2192 It(x) ` MIt s : \u2200x.N(x) \u2192 It(x), where s =de f \u03bb x.\u03bb y.case(y, u. f0 (u), v. f p (xv)) and It(x) is\na predicate representing the fact that the image of a given function f on x was defined by iteration,. If we\nset g =de f MIt s then g 0 \u2192? f0 () and g (p n) \u2192? f p (g n). This example shows that our logic subsumes\nthe Mendler-style programming methodology of [16]. However, this approach does not correspond to\nthe idea of programming with proofs that we pursuit.\nOur final version of natural numbers shows the full use of the iso-inductive style and depends on the\ndisjoint union of predicates ] which is a predicate that can be defined under the presence of the Parigot's\nrestriction operator \u0016 (see [14]). This operator can be added to our logic without a problem and behaves as\na conjunction where the right formula is an equation without algorithmic content.4 Defining P ] R =de f\n\u03bb x.\u2203z.(P(z)\u0016x = lf z) \u2228 (R(z)\u0016x = rg z) we get that \u0393 ` r : P(t) implies \u0393 ` pack(inl r) : (P ] R)(lf t)\nor \u0393 ` pack(inr r) : (R ] P)(rgt). One important advantage of using this predicate together with our\niso-style is that we do not need to deal directly with existential formulas in definitions, and therefore\nthe following examples are closer to the data type definition mechanisms of functional programming\nlanguages.\nExample 3 (Iso-inductive Natural Numbers). The natural numbers are given now by the inductive definition N =de f \u03bc(\u03a6) where \u03a6 = \u03bb X.hhi ] X, and we use a generic constructor cnat, which yields the\nusual constructors by adopting the equational axioms 0 = cnat(lf ?) and suc x = cnat(rg x). These constructors are implemented by 0 =de f in(pack(inl())) and suc =de f \u03bb z. in(pack(inr z)). Let us present the\nextracted programs for sum, factorial and predecessor:\n\u25e6 Sum: from Esum = {sum n 0 = n, sum n (suc m) = suc(sum n m)}, we derive `Esum \u03bb n. MIt s :\n\u2200n.\u2200x.N(n) \u2192 N(x) \u2192 N(sum n x) where s =de f \u03bb y.\u03bb z.open(z, u.case(u, v.n, w.suc(yw))). Therefore we get sum =de f \u03bb n. MIt s.\n3 Sometimes\n4 That\n\nan equation is involved directly in a judgment and we agree to give it the void proof-term () as code.\nis, an equation that is not codified by a proof-term.\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n37\n\n\u25e6 Factorial: from Efac = {fac(0) = 1, fac(suc(n)) = suc(n) \u2217 fac(n)}, we derive `Efac MRec s :\n\u2200x.N(x) \u2192 N(fac x) where s =de f \u03bb y.\u03bb z.\u03bb w.open(w, u.case(u, u1 .1, u2 .suc(yu2 )?(zu2 ))). Therefore fac =de f MRec s is a correct program for the factorial.\n\u25e6 Predecessor: an efficient handling-error predecessor specified by Epred = {error = lf ?, pred 0 =\nerror, pred (suc n) = rg n}, is implemented by pred =de f MRec s, where the step function is s =de f\n\u03bb y.\u03bb z.\u03bb w.open(w, u.case(u, u1 . pack(inl()), u2 . pack(inr(yu2 ))), for we derive ` Epred MRec s :\n\u2200x.N(x) \u2192 (hhi ] N)(pred x).\nIn a similar way to the last example, we can define all usual inductive data types like finite lists or\ntrees (see [11, 9] for several related examples). We present next, coinductive predicates corresponding\nto the conatural numbers and the lazy data type of streams or strictly infinite lists. These examples show\nthat we can deal with infinite objects within a terminating system. It is important to observe that in the\nformer case the iso-style is more convenient, and for the latter the equi-style suffices.\nThe implementation of the predicate for the so-called conatural numbers, corresponding to the ordinal\n\u03c9 + 1, gives us the opportunity to show the use of corecursion to construct inhabitants of data types with\ninfinite objects, in this case the ordinal \u03c9. We observe that the implementation of conatural numbers, as\nwell as the implementations for natural numbers discussed above, do not correspond to Church numerals,\nas it happens in AF2. In particular the normal proof-term coding the fact that CoNat(\u03c9) holds does not\ninvolve an \"infinite\" Church numeral, which would be a non-terminating term, for \u03c9 is specified as a\nconatural number that equals its predecessor and will be constructed by means of corecursion.\nExample 4 (Iso-coinductive conatural numbers). The conatural numbers are defined by CoNat =de f\n\u03bd(\u03a6), where \u03a6 =de f \u03bb X.\u03bb x.hhi(x) \u2228 X(x), and taking the predecessor function pred as destructor with\nimplementation pred =de f out. Let us construct the conatural numbers by means of corecursion.\n\u25e6 Zero: let 0 be a constant, z be a unary function symbol and Ez = {pred(z(x)) = ?, 0 = z(?)}. If we\ndefine 0\u0304 =de f MCoRec s (), where s =de f \u03bb x\u03bb y.\u03bb u. inl u, then `Ez 0 : CoNat(0) and pred 0 \u2192? inl().\n\u25e6 Succesor: let suc be a unary function and Esuc = {pred(suc x) = x}. We have ` suc : \u2200x.CoNat(x)\u2192\nCoNat(suc(x)), where suc =de f MCoRec s and s =de f \u03bb x\u03bb y.\u03bb z. inr(xz). Moreover, the operational\nsemantics yields pred(suc n) \u2192? inr n.\n\u25e6 Omega: to define the infinite ordinal \u03c9, we use a unary function \u03c9 \u2020 and axioms E\u03c9 \u2020 = {\u03c9 =\n\u03c9 \u2020 (?), pred(\u03c9 \u2020 (x)) = \u03c9 \u2020 (x)}. Then we get ` \u03c9 \u2020 : \u2200x.hhi(x) \u2192 CoNat(\u03c9 \u2020 (x)). By defining \u03c9 =de f\n\u03c9 \u2020 () we get ` \u03c9 : CoNat(\u03c9). The needed proof-term is given by \u03c9 \u2020 =de f MCoRec s, where\ns =de f \u03bb x\u03bb y\u03bb z. inr(yz).\nOur last example of a coinductive predicate corresponds to streams or strictly infinite lists.\nExample 5 (Equi-coinductive Streams). The streams over a data type A are defined as SA =de f \u03bd(\u03a6)\nwhere \u03a6 =de f \u03bb X.\u03bb x.A(head(x))\u2227X(tail(x)), and the destructor d is the identity function. The programs\nfor the usual destructors are head =de f \u03bb x. fst(out x) and tail =de f \u03bb x. snd(out x), extracted from `\nhead : \u2200x.SA (x) \u2192 A(head x) and ` tail : \u2200x.SA (x) \u2192 SA (tail x). We present now some programs involving\nstreams:\n\u25e6 The function from, that generates the stream of natural numbers from a given one, is specified\nby Efrom = {head(from x) = x, tail(from x) = from(suc x)}. The reader can verify that `Efrom\nfrom : \u2200x.N(x) \u2192 SN (from x) where from =de f MCoIt s and s =de f \u03bb y\u03bb z.hz, y(suc z)i, and that\nhead(from x) \u2192? x and tail(from x) \u2192? from(suc x).\n\n\f38\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\u25e6 The constructor cons is defined by Econs = {head(cons x y) = x, tail(cons x y) = y} and requires\ncorecursion to be implemented. We get a program cons from the proof `Econs cons : \u2200x\u2200y.A(x) \u2192\nSA (y) \u2192 SA (cons x y) where cons =de f \u03bb x. MCoRec s and s =de f \u03bb f1 \u03bb f2 \u03bb w.hx, f1 wi.\n\u25e6 The function map on streams is specified by Emap = {head(map f `) = f (head `), tail(map f `)\n= map f (tail `)}. An extracted program from `Emap map : (\u2200x.A(x) \u2192 B( f (x))) \u2192 \u2200z.SA (z) \u2192\nSB (map f z) is map =de f \u03bb f . MCoIt s, where s =de f \u03bb y\u03bb z.h f (head x), y(tail x)i.\n\u25e6 A function similar to map but that requires corecursion in the implementation is maphd, which\napplies a given function only to the head of a stream. It is defined by Emaphd = {head(maphd f `) =\nf (head `), tail(maphd f `) = tail `}. We get the program `Emaphd maphd : (\u2200x.A(x) \u2192 A( f (x))) \u2192\n\u2200z.SA (z) \u2192 SA (maphd f z) where maphd =de f \u03bb f . MCoRec s and the step function s is defined by\n\u03bb y.\u03bb z.\u03bb w.h f (head x), tail xi.\nWe finish the section with a couple of examples involving binary predicates.\n\nExample 6 (Iso-inductive order in natural numbers). The following recursive definition of order for\nnatural numbers:\nn<m\nN(n)\n0 < suc n\nsuc n < suc m\nis implemented by the iso-inductive definition L = \u03bc(\u03a6) where the predicate transformer is \u03a6 =de f\n\u03bb X (2) .\u03bb x, y. (x = 0 \u2227 N(y)) \u2228 \u2203z.X(z, y) \u0016 (x = suc z), and the constructors are the identity and the successor functions ~c =de f Id, suc. The derivations ` \u03bb n. in(inlh(), ni) : \u2200n.N(n) \u2192 L(0, suc n) and `\n\u03bb w. in(inr(pack w)) : \u2200n\u2200m.L(n, m) \u2192 L(suc n, suc m) can be easily verified.\nExample 7 (Equi-coinductive observational equality for streams). Leibniz equality is not always adequate for reasoning about streams (see [15]), in some cases it is better to employ the observational\nequality. This equality relation is defined by the equi-coinductive binary predicate E =de f \u03bd(\u03a6) where\n\u03a6 =de f \u03bb X (2) .\u03bb x, y. head x = head y \u2227 X(tail x, tail y). It is immediate to verify that ` \u03bb x. fst(out x) :\n\u2200x\u2200y.E (x, y) \u2192 head x = head y and ` \u03bb x. snd(out x) : \u2200x.\u2200y.E (x, y) \u2192 E (tail x, tail y). Moreover, the\ncorecursion rule yields ` e : \u2200x\u2200y. head x = head y \u2192 E (tail x, tail y) \u2192 E (x, y), where the proof term\ne is given by e =de f \u03bb x\u03bb y. MCoRec s hx, yi and s =de f \u03bb w.\u03bb u.\u03bb v.hfst v, w(snd v)i. These proofs imply\nthat two streams are observationally equal if and only if their heads are equal and their tails are again\nobservationally equal.\n\n4\n\nSaturated Sets\n\nWe develop here all constructions on a complete lattice of so-called saturated sets needed to define the\nsemantics of the logic. It is important to emphasize that in this section a term is exclusively a \u03bb -term\nbelonging to the set \u039b = {t | t is a proof-term of AF2M\u03bc\u03bd }.\nDefinition 2. A term t is called an I-term if it was generated by an introduction rule, i.e., I-terms are\nterms of the following shapes: \u03bb xr, in r, MCoRec s r. Analogously E-terms are terms generated by an\nelimination rule, i.e. they are terms of the following shapes: rs, out r, MRec s r .\nObserve that any term is either a variable, an I-term or an E-term.\nInstead of reasoning with infinite reduction sequences we will work with an inductive definition of a\nset SN including all strongly normalizing terms. We discuss its definition now.\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n39\n\nDefinition 3. Evaluation contexts are defined by the following grammar:\n\u0002 \u0003\n\u0002 \u0003\n\u0002 \u0003\n\u0002 \u0003\nE \u2022 ::= \u2022 | E \u2022 s | out E \u2022 | MRec s E \u2022\nLet us observe that an evaluation context may be considered as an E-term with a unique placeholder \u2022.\nTherefore, evaluation contexts\n\u0002 \u0003 are sometimes called elimination contexts or multiple eliminations. In the\nfollowing,\nwe\nwill\nwrite\nE\nr \u0002for\u0003 the E-term obtained by substituting the placeholder \u2022 by the term r\n\u0002 \u0003\n\u0002 \u0003\nin E \u2022 . That is E r \u0002=\u0003de f E \u2022 [\u2022 := r] where the substitution is defined as if \u2022 were a term variable.\nA term of the form E x is called a neutral term. The notion of weak head reduction, denoted \u2192whd ,\nneeded to define the set SN is defined as follows:\nt \u2192\u03b2 t 0\n\u0002\u0003\n\u0002 \u0003\nE t \u2192whd E t 0\nThe final concept involved in the inductive definition of the set SN is the set ist(t) of immediate subterms of a given term t, defined as follows: ist(x) = \u2205, ist(\u03bb xr) = ist(in r) = ist(out r) = {r}, ist(rs) =\nist(MRec s r) = ist(MCoRec s r) = {s, r}. We will also need the set ist(E[\u2022]) of immediate subterms of\na given evaluation context which is defined as if E[\u2022] were a term.\nDefinition 4. The set SN is defined by means of the following inductive definition:\n(SN - VAR)\n\nx \u2208 SN\n\u0002 \u0003\n\u0002 \u0003\nE x \u2208 SN ist(E \u2022 ) \u2286 SN\n\u0002 \u0002 \u0003\n(SN - E)\nE 0 E x ] \u2208 SN\n\nt is an I-term ist(t) \u2286 SN\n(SN - I)\nt \u2208 SN\n\u0002 \u0003\n\u0002\u0003\n\u0002 \u0003\nE t 0 \u2208 SN E t \u2192whd E t 0\nprt(t) \u2286 SN\n\u0002\u0003\n(SN - W)\nE t \u2208 SN\n\nwhere for a redex t, prt(t) is the set of problematic subterms of t, which are the terms that might break\nthe strong normalization of t, even knowing that its reduct t 0 strongly normalizes. This set is defined as\nfollows: prt((\u03bb x.r)s) = {s}, prt(MRec s (in r)) = prt(out(MCoRec s r)) = \u2205.\nIt can be proved that the characterization SN of the set of strongly normalizing terms is sound, that\nis: if t \u2208 SN then there is no infinite reduction sequence t \u2192 t1 \u2192 t2 \u2192 . . . .\nNow we can define a concept of saturated set, modelled after the definition of SN.\nDefinition 5 (SAT-set). A set of terms M is saturated if and only if it consists only of terms in SN, it\ncontains all neutral terms of SN, and it is closed under weak head expansion of SN terms. This can\nelegantly be defined by the following rules:\nt \u2208M\n(SAT- SN)\nt \u2208 SN\nE[t 0 ] \u2208 M\n\nE[t] \u2192whd E[t 0 ]\nE[t] \u2208 M\n\nE[x] \u2208 SN\n(SAT- N)\nE[x] \u2208 M\nprt (t) \u2286 SN\n\n(SAT- W)\n\nIt is easy to see that SAT =de f {M | M is saturated} is closed under intersection. Therefore the\nT\ntriple hSAT, \u2286, i forms a complete lattice. The next concept will be fundamental for reasoning with\nsaturated sets.\nDefinition 6. Given a set of terms M, the set cl(M) :=\nsaturated closure or SAT-closure of M.\n\n{N \u2208 SAT | M \u2229 SN \u2286 N } is called the\n\nT\n\ncl(M) is the least saturated superset of M \u2229 SN. Observe that M \u2286 cl(M) if and only if M \u2286 SN.\n\n\f40\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\n4.1\n\nSaturated sets for the implication\n\nThe following construction is standard, we recall it here for the sake of self-containtment.\nDefinition 7. We define M \u21d2 N = cl({r \u2208 \u039b | \u2200s \u2208 M . rs \u2208 N }), so that \u21d2: SAT \u00d7 SAT \u2192 SAT is a\nbinary operation on saturated sets.\nProposition 5 (Soundness). Let M , N \u2208 SAT.\n1. If Sx (M , N ) = {t | \u2200s \u2208 M . t[x := s] \u2208 N } and t \u2208 Sx (M , N ) then \u03bb xt \u2208 M \u21d2 N .\n2. If r \u2208 M \u21d2 N and s \u2208 M then rs \u2208 N .\nProof. Straightforward. See for example [9].\n\n4.2\n\nSAT valued functions for coinductive predicates\n\nThe goal of this section is to develop the main technical contribution of our paper, to construct fixed\npoints of SAT-valued functions, which will be needed later for the semantics of coinductive predicates.\nFor the case of inductive predicates we point to our extended version [11]. The methodology is based\non the one developed in section 9.4 of [7] for inductive types. These constructions and their soundness\nproperties will play an essential role in the proof of the adequacy theorem for AF2M\u03bc\u03bd .\nLet us start by fixing a non-empty set M and by defining for all n \u2208 N, the set of SAT-valued n-ary\nfunctions SATn =de f {F | F : M n \u2192 SAT}, with SAT0 = SAT. The set SATn forms a complete lattice\nT\nhSATn , \u2286, i with the pointwise inherited definitions F \u2286 G \u21d4de f \u2200~x \u2208 M n .F(~x ) \u2286 G(~x ) and defining\nT\nT\nT\nfor any F \u2286 SATn , the function F : M n \u2192 SAT as ( F )(~x ) =de f F\u2208F F(~x ). Through this section\nwe fix a higher-order function \u03a6 : SATn \u2192 SATn , and tuples of functions ~d = d1 , . . . , dn ,~f = f1 , . . . , fn\nwith di , fi : M \u2192 M.\nLet us begin with the constructions for coinductive predicates. The idea is that given a coinductive\npredicate \u03bd(\u03a8), where the interpretation of the predicate transformer \u03a8 is the function \u03a6 : SATn \u2192 SATn ,\nits interpretation will be defined as the greatest fixed-point \u03bd(\u0398v ) of the lower monotonization of some\noperator \u0398 : SATn \u2192 SATn associated to the arbitrary function \u03a6.\nDefinition 8. We define E\u03bd : SATn \u2192 M n \u2192 P(\u039b) by E\u03bd (F)(~t ) =de f {r \u2208 SN | out r \u2208 \u03a6(F)(~d(~t ))}\nwhere F : M n \u2192 SAT and ~t \u2208 M n .\nLemma 1. Let \u0398E : SATn \u2192 SATn be defined as \u0398E (F)(~t ) =de f cl(E\u03bd (F)(~t )). Then, for any F \u2208\nSATn , E\u03bd (F) = \u0398E (F)\nProof. It suffices to show that for any ~t \u2208 M n , E\u03bd (F)(t) \u2208 SAT. See [11].\nThe post-fixed points of \u0398E are characterized as follows:\nLemma 2. F \u2286 \u0398E (F) \u21d4 \u2200~t \u2208 M n \u2200r \u2208 F(~t ). out r \u2208 \u03a6(F)(~d(~t )).\nProof. Straightforward.\nWe would like to obtain a greatest fixed-point of \u0398E , but as we do not assume that \u03a6 is monotone,\nwe cannot prove either that \u0398E is monotone. Therefore we cannot apply the Knaster-Tarski fixed-point\ntheorem to \u0398E to obtain a greatest fixed-point of \u0398E , which is what we need to interpret coinductive\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n41\n\npredicates. However, we can proceed by using an adequate version of its lower monotonization (see\ndefinition 1), E\u03bd\u2286 : SATn \u2192 M n \u2192 P(\u039b) defined by\nE\u03bd\u2286 (F)(~t ) =\n\n\\\n\n{E\u03bd (F 0 )(~t ) | F \u2286 F 0 }\n\nF 0 \u2208SATn\n\u2286\n~\nIt is easy to see that E\u03bd\u2286 is monotone. Therefore the operator \u0398\u2286\nE : SATn \u2192 SATn given by \u0398E (F)(t ) =de f\n\u2286\n\u2286\ncl(E\u03bd (F)(~t )) is also monotone and the function \u03bd(\u03a6) \u2208 SATn defined by \u03bd(\u03a6) =de f gfp(\u0398E ) exists due\nT\nto the completeness of the lattice hSATn , \u2286, i.\n\nProposition 6. \u03bd(\u03a6) is a post-fixed point of \u0398E .\n\u2286\nProof. By definition, \u03bd(\u03a6) is a post-fixed point of \u0398\u2286\nE , that is \u03bd(\u03a6) \u2286 \u0398E (\u03bd(\u03a6)). Moreover, it is\n\u2286\nstraightforward to show that \u0398E (\u03bd(\u03a6)) \u2286 \u0398E (\u03bd(\u03a6)), which yields \u03bd(\u03a6) \u2286 \u0398E (\u03bd(\u03a6)).\n\nNext, we define an operator \u0398I useful to prove the soundness of the inference rule for Mendler\ncorecursion.\nDefinition 9. Given \u03a6 : SATn \u2192 SATn and F \u2208 SATn we define I\u03bd : SATn \u2192 M n \u2192 P(\u039b) as follows:\nif ~s \u2208 M n and ~s 6=~f(~t ) then I\u03bd (F)(~s ) =de f \u2205, and\nn\nI\u03bd (F)(~f(~t )) =de f MCoRec s r H \u2208 SATn , r \u2208 H(~t),\n\u0011o\n\u0010\nT\ns \u2208 G\u2208SATn (F \u0016 G) \u21d2 (H \u0016~f G) \u21d2 H \u0016~d\u25e6~f \u03a6(G)\nwhere for any F, G \u2208 SATn and ~g a tuple of functions gi : M \u2192 M we define the SAT-set F \u0016~g G as\nT\nT\nfollows: F \u0016~g G =de f ~t\u2208Mn F(~t ) \u21d2 G(~g(~t )), in particular, F \u0016 G =de f ~t\u2208Mn F(~t ) \u21d2 G(~t ).\nFinally we define the function \u0398I : SATn \u2192 SATn as \u0398I (F)(~t ) =de f cl(I\u03bd (F)(~t )).\nLemma 3. For any F \u2208 SATn , I\u03bd (F) \u2286 \u0398I (F).\nProof. It suffices to show that for any ~s \u2208 M n , I\u03bd (F)(~s ) \u2286 SN. See [11].\nThe pre-fixed points of \u0398I are characterized as follows:\nLemma 4. Let F \u2208 SATn .\n\u0398I (F) \u2286 F \u21d4 \u2200~t \u2208 M n .\u2200H \u2208 \u0010SATn . \u2200r \u2208 H(~t ).\n\u2200s \u2208\n\nT\n\nG\u2208SATn\n\n\u0011\n(F \u0016 G) \u21d2 (H \u0016~f G) \u21d2 H \u0016~d\u25e6~f \u03a6(G) . MCoRec s r \u2208 F(~f(~t ))\n\nProof. Straightforward.\nTo show the soundness of Mendler corecursion we will use the following\nProposition 7. \u03bd(\u03a6) is a pre-fixed point of \u0398I .\nProof. We will proceed by extended conventional coinduction, as defined in proposition 1 .\n0\nLet J =de f \u03bd(\u03a6) and J0 =de f J \u222a \u0398I (J). We have to prove that \u0398I (J) \u2286 \u0398\u2286\nE (J ) and for this, it suffices\nto show that I\u03bd (J)(~s ) \u2286 E\u03bd\u2286 (J0 )(~s ) for all ~s \u2208 M n .\n~~\nIf ~s 6=~f(~t) then I\u03bd (J)(~s ) = \u2205 \u2286 E\u03bd\u2286 (J0 )(~s ). For the case ~s =~f(~t ) let us take MCoRec\n\u0001 s r \u2208 I\u03bd (J)(f(t))\nT\nwith r \u2208 H(~t), H \u2208 SATn and s \u2208 G\u2208SATn (J \u0016 G) \u21d2 (H \u0016~f G) \u21d2 H \u0016~d\u25e6~f \u03a6(G) . According to the\ndefinition of E\u03bd\u2286 (J0 )(~f(~t )) we have to prove that MCoRec s r \u2208 E\u03bd (J00 )(~f(~t )) for any J00 \u2208 SATn such\n\n\f42\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\nthat J0 \u2286 J00 . Let us observe that MCoRec s r \u2208 SN, for I\u03bd (J)(~f(~t )) \u2286 SN. Therefore, we only need\nto verify that out(MCoRec s r) \u2208 \u03a6(J0 )(~d(~f(~t ))). Since \u03a6(J0 )(~d(~f(~t ))) \u2208 SAT, it suffices to show that\ns(\u03bb xx)(MCoRec s)r \u2208 \u03a6(J0 )(~d(~f(~t ))).\nWe know that s \u2208 (J \u0016 J0 ) \u21d2 (H \u0016~f J0 ) \u21d2 (H \u0016~d\u25e6~f \u03a6(J0 )) and also that \u03bb xx \u2208 J \u0016 J0 , for J \u2286 J0 . Hence,\nby part 2 of proposition 5 , s(\u03bb xx) \u2208 H \u0016~f J0 \u21d2 H \u0016~d\u25e6~f \u03a6(J0 ).\nNext, we show that MCoRec s \u2208 H \u0016~f J0 . By part 1 of proposition 5 we only need to show that for all~t \u2208\nM n , MCoRec s x \u2208 Sx (H(~t ), J0 (~f(~t ))), which happens if and only if for all e \u2208 H(~t ), (MCoRec s x)[x :=\ne] \u2208 J0 (~f(~t )). Therefore we assume e \u2208 H(~t ) and need to prove that MCoRec s e \u2208 J0 (~f(~t )), but we have\nMCoRec s e \u2208 I\u03bd (J)(~f(~t )) and therefore, by lemma 3 , MCoRec s e \u2208 \u0398I (J)(~f(~t )), but as \u0398I (J)(~f(~t )) \u2286\nJ0 (~f(~t )) we have proven that MCoRec s \u2208 H \u0016f J0 . Using again the second part of proposition 5 , we\nconclude that s(\u03bb xx)(MCoRec s) \u2208 H \u0016~d\u25e6~f \u03a6(J0 ). Finally r \u2208 H(~t ) implies that s(\u03bb xx)(MCoRec s)r \u2208\n\u03a6(J0 )(~d(~f(~t ))).\nTo finish this section we summarize the soundness properties of the (co)inductive constructions on\nSAT-valued functions.\nProposition 8 (Soundness of the (co)inductive constructions). Let \u03a6 : SATn \u2192 SATn ,~c,~d,~f be tuples of\nfunctions ci , di , fi : M \u2192 M, 1 \u2264 i \u2264 n, and ~t \u2208 M n . Then\n1. If r \u2208 \u03a6(\u03bc(\u03a6))(~t ) then in r \u2208 \u03bc(\u03a6)(~c(~t )).\n2. If r \u2208 \u03bc(\u03a6)(~t ), H \u2208 SATn and s \u2208\nMRec s r \u2208 H(~f(~t )).\n\n\u0011\n\u0010\nH\nthen\nH)\n\u21d2\n\u03a6(G)\n\u0016\n(G\n\u0016\n\u03bc(\u03a6))\n\u21d2\n(G\n\u0016\n~\n~\nG\u2208SATn\nf\u25e6~c\nf\n\nT\n\n3. If r \u2208 \u03bd(\u03a6)(~t ) then out r \u2208 \u03a6(\u03bd(\u03a6))(~d(~t )).\n\u0011\n\u0010\nT\n4. If r \u2208 H(~t ), H \u2208 SATn , and s \u2208 G\u2208SATn (\u03bd(\u03a6) \u0016 G) \u21d2 (H \u0016~f G) \u21d2 H \u0016~d\u25e6~f \u03a6(G) then\nMCoRec s r \u2208 \u03bd(\u03a6)(~f(~t )).\nProof. Part 3 is consequence of proposition 6 and lemma 2 . For part 4 we just use proposition 7 and\nlemma 4 . For the inductive cases we refer to [11] .\nWe are now ready to define an intuitionistic semantics for our logic.\n\n5\n\nSemantics for AF2M\u03bc\u03bd\n\nWe present here a realizability semantics for AF2M\u03bc\u03bd where an object-term will be interpreted as an\nelement of a universe set M, a formula as a SAT-set and a predicate as a SAT-valued function in SATn .\nDefinition 10. A model for a second-order language L is a pair M = hM, I i where M is a non-empty\nset and I is an interpretation function for L such that I ( f ) : M n \u2192 M, for every n-ary function symbol\nf \u2208 L and I (P) : M n \u2192 SAT, for every n-ary predicate symbol P \u2208 L.\nFrom now on we fix a model M = hM, I i.\nDefinition 11. A state or variable assignment is a function \u03c3 : Var \u2192 M \u222a SATn such that \u03c3 (x) \u2208 M and\n\u03c3 (X (n) ) \u2208 SATn . Given m \u2208 M or G \u2208 SATn , the modified assignments \u03c3 [x/m] and \u03c3 [X/G] are defined\nas usual.\nNext, we recursively define the interpretation of terms, predicates and formulas.\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n43\n\nDefinition 12. Given a variable assignment \u03c3 , we define the interpretation function I\u03c3 , such that\nI\u03c3 (r) \u2208 M, I\u03c3 (P) \u2208 SATn and I\u03c3 (A) \u2208 SAT, as follows:\n\u25e6 Term interpretation\n\u2013 I\u03c3 (x) = \u03c3 (x)\n\u2013 I\u03c3 ( f (t1 , . . . ,tn )) = I ( f )(I\u03c3 (t1 ), . . . , I\u03c3 (tn ))\n\u25e6 Predicate interpretation:\n\u2013 Predicate variables: I\u03c3 (X) = \u03c3 (X)\n\u2013 Predicate symbols: I\u03c3 (P) = I (P)\n\u2013 Comprehension predicates: if F =de f \u03bb~xA, we define I\u03c3 (F ) = GF where GF : M n \u2192 SAT\nis given by GF (~m ) = I\u03c3 [~x/~m ] (A), for all ~m \u2208 M n .\n\u2013 Predicate transformers: if \u03a6 =de f \u03bb X.P, where w.l.o.g., P =de f \u03bb~x.A, we define I\u03c3 (\u03a6) :\nSATn \u2192 SATn by I\u03c3 (\u03a6)(F)(~m ) = I\u03c3 [X/F,~x/~m ] (A), for all ~m \u2208 M n .\nThis way, it can be proved that for any predicate R, we have I\u03c3 (\u03a6(R)) = I\u03c3 (\u03a6)(I\u03c3 (R)).\n\u2013 (Co)inductive predicates:\n\u2217 I\u03c3 (\u03bc(\u03a6)) = \u03bc(I\u03c3 (\u03a6))\n\u2217 I\u03c3 (\u03bd(\u03a6)) = \u03bd(I\u03c3 (\u03a6))\nwhere of course, the operators \u03bc and \u03bd on the right-hand side of the equalities refer to the\nconstructions on SAT-valued functions developed in section 4 .\n\u25e6 Formula interpretation:\n\u0001\n\u0001\n\u2013 I\u03c3 P(t1 , . . . ,tn ) = I\u03c3 (P) I\u03c3 (t1 ), . . . , I\u03c3 (tn )\n\u2013 I\u03c3 (A \u2192 B) = I\u03c3 (A) \u21d2 I\u03c3 (B)\nT\n\u2013 I\u03c3 (\u2200xA) = {I\u03c3 [x/m] (A) | m \u2208 M }\nT\n\u2013 I\u03c3 (\u2200XA) = {I\u03c3 [X/G] (A) | G \u2208 SATn }\nWe observe that as equations are a special case of a second-order universal formula, there is no need\nto give a specific semantics for them. However we are only interested in models that satisfy a set of\nequations in the following sense.\nDefinition 13. Let M = hM, I i be a model and \u03c3 be a state. We say that the interpretation I\u03c3 satisfies\nthe equation r = s if and only if I\u03c3 (r) = I\u03c3 (s). Moreover if E is a set of equations, we say that I\u03c3\nsatisfies E if and only if I\u03c3 satisfies every equation in E.\nNow we can prove the main theorem of this paper.\nTheorem 1 (Adequacy or soundness). Let M = hM, I i be a model such that the interpretation I\u03c3\nsatisfies the set of equations E. If \u0393 `E t : A, with \u0393 = {x1 : A1 , . . . , xn : An } and for all 1 \u2264 i \u2264 n, ri \u2208\nI\u03c3 (Ai ) then t[~x :=~r ] \u2208 I\u03c3 (A).\nProof. Induction on \u0393 `E t : A. We discuss the case for the rule\n\u0001 (\u03bdI), for the remaining rules see [11].\n~\nWe need to show that (MCoRec s r)[~x :=~r] \u2208 I\u03c3 \u03bd(\u03a6)( f (~t )) . That is, (MCoRec s[~\n\u0010x :=~r] r[~x :=~r]) \u2208\n\u03bd(I\u03c3 (\u03a6))(~j), where ~j = I\u03c3 ( f1 (t1 )), . . . , I\u03c3 ( fn (tn )). The I.H. yields s[~x :=~r] \u2208 I\u03c3 \u2200X \u03bd(\u03a6) \u2286 X \u2192\n\u0001\u0011\nK \u2286~f X \u2192 K \u2286d\u25e6\n\u03a6(X)\n. From this and by defining \u03a60 = I\u03c3 (\u03a6), ~f = I\u03c3 ( f1 ), . . . , I\u03c3 ( fn ), ~d =\n~ ~f\n\u0010\nT\nI\u03c3 (d1 ), . . . , I\u03c3 (dn ) and H = I\u03c3 (K ) it is easy to verify that s[~x :=~r] \u2208 G\u2208SATn (\u03bd(\u03a60 ) \u0016 G) \u21d2 (H \u0016~f\n\u0011\nG) \u21d2 (H \u0016~d\u25e6~f \u03a60 (G)) . Moreover we also have r[~x :=~r] \u2208 H(~l), where ~l = I\u03c3 (t1 ), . . . , I\u03c3 (tn ), by I.H.\nTherefore we can apply part 4 of proposition 8 to conclude that MCoRec s[~x :=~r] r[~x :=~r] \u2208 \u03bd(\u03a60 ))(~f(~l )),\nwhich is equivalent to (MCoRec s r)[~x :=~r] \u2208 I\u03c3 (\u03bd(\u03a6)(~f (~t ))).\n\n\f44\n\n5.1\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\nStrong normalization\n\nThe strong normalization property for the logic AF2M\u03bc\u03bd can be proved by adapting the proof of AF2\nwhich embeds this logic into its propositional fragment, system F (see [4]). However, our semantics\nof saturated sets allows for an easy proof of strong normalization which is a direct consequence of the\nadequacy theorem. Let us start by building a model and an interpretation that satisfies a given set of\nequations E as required by the adequacy theorem.\nDefinition 14. Given a judgement \u2206 =de f \u0393 `E t : A we define a model M\u2206 = hM, I i as follows:\n\u25e6 Let \u2248E be the binary relation on terms given by r = s \u21d4de f E B r = s. It is easy to prove that \u2248E\nis an equivalence relation.\n\u25e6 The universe of M\u2206 is the set M = TermL / \u2248E , of the equivalence classes [t] of the relation \u2248E .\n\u25e6 The interpretation function I is defined as follows:\n\u2013 f I : M n \u2192 M, f I ([t1 ], . . . , [tn ]) =de f [ f (t1 , . . . ,tn )]\n\u2013 PI : M n \u2192 SAT, PI ([t1 ], . . . , [tn ]) =de f cl({s \u2208 \u039b | \u0393 `E s : P(t1 , . . . ,tn )})\nIt is easy to see that the interpretation function is well-defined and therefore M\u2206 is a model.\nThe next lemma shows that in M\u2206 term interpretation is given by a specific substitution.\n\u0002\n\u0003\nLemma 5. Let \u03c3 be a state and r \u2208 TermL such that Var(r) =~x. If \u03c3 (xi ) = [si ] then I\u03c3 (r) = r[~x :=~s ] .\nProof. Induction on r.\nWe can now define an interpretation that satisfies a given set of equations E.\nLemma 6. For any judgement \u2206 =de f \u0393 `E t : A there is a state \u03c3 of M\u2206 such that the interpretation I\u03c3\nsatisfies E.\nProof. We define the state \u03c3 of M\u2206 , as follows:\n\u25e6 For any first-order variable x, \u03c3 (x) = [x].\n\u25e6 For any second-order variable X, \u03c3 (X) = G, where\nG([t1 ], . . . , [tn ]) =de f cl({s \u2208 \u039b | \u0393 `E s : X(t1 , . . . ,tn )}).\nIt is easy to verify that the state is well-defined. Moreover I\u03c3 satisfies E, for if r = s \u2208 E then r \u2248E s\nand therefore [r]\nif Var(r) =\n= ~y, then by definition of \u03c3 and by lemma 5 we\n\u0002 = [s]. But,\n\u0003\n\u0002 ~x and Var(s)\n\u0003\nhave I\u03c3 (r) = r[~x :=~x] = [r] = [s] = s[~y :=~y] = I\u03c3 (s).\nThe strong normalization of AF2M\u03bc\u03bd is now easily gained from lemma 6 and the adequacy theorem.\nTheorem 2 (Strong normalization of AF2M\u03bc\u03bd ). If \u0393 `E t : A then t is strongly normalizing\nProof. Assume \u2206 is the judgement \u0393 `E t : A, with \u0393 = {x1 : A1 , . . . , xk : Ak }. By lemma 6 the set of\nequations E is satisfied by an interpretation I\u03c3 in the model M\u2206 . Moreover, we have xi \u2208 I\u03c3 (Ai ),\nfor I\u03c3 (Ai ) is a SAT-set and every SAT-set contains all variables. Therefore the adequacy theorem\nyields t = t[~x := ~x ] \u2208 I\u03c3 (A). Finally, as I\u03c3 (A) \u2286 SN, we get t \u2208 SN which implies that t strongly\nnormalizes.\n\n\fMiranda-Perea and Gonz\u00e1lez-Huesca\n\n6\n\n45\n\nRelated Work\n\nNowadays, there are several lines of research concerning fixed-point logics in computer science. In relation to our work we can mention for instance [12] which presents a sequent calculus for positive equi(co)inductive equational definitions and which handles conventional (co)iteration only. In this paper the\nequality relation is primitive and corresponds to unification with respect to \u03b2 \u03b7-reduction. Moreover,\nthe cut-elimination property holds only after restricting the coinductive rules. Recently [2] develops an\nextension of the linear logic MALL and a focused proof system for it where the mechanism of conventional equi-(co)inductive definitions is similar to ours. In this weak normalizable logic, which only\nhandles (co)iteration, all predicate operators are assumed to be monotone, proofs of functoriality are\ngiven for positive definitions and the treatment of equality originates from logic programming. Finally\nwe mention the work of [1] which is closer to ours and presents two strongly normalizing propositional\nlogics (type systems) with Mendler-style positive equi-(co)inductive types whose semantics of so-called\nguarded saturated sets makes heavy use of transfinite ordinal recursion, which obliges to restrict the\n(co)iteration rules by means of a kind system that distinguishes between guarded and unguarded types.\nOn the other hand this feature allows for a definition of a system of sized types that encompasses primitive (co)recursion and course of value recursion.\n\n7\n\nClosing remarks\n\nWe have presented the logic AF2M\u03bc\u03bd , an extension of the second order logic AF2 with Mendler-style\nprimitive (co)recursion over least and greatest fixed points of predicate transformers. To our knowledge,\nthis is the first such extension that includes Mendler-style (co)inductive predicates while keeping the\nstrong normalization property. Thus, the programs extracted from the termination statements of functions are guaranteed to terminate, independently of the syntactical shape of the proof and therefore the\nparticular methodologies to show termination, like the one in [6] are not needed. Based on the concept of\nmonotonization of an operator we have developed a realizability semantics of SAT-sets and SAT-valued\nfunctions for (co)inductive predicates that does not employ the usual positivity restriction. This was first\nachieved in [7] for essentially the propositional inductive fragment of our logic. Furthermore, our adequacy theorem does not require any ordinal recursion in contrast to the work in [14, 15]. The iso-style of\nour (co)inductive definitions allows to define data types in a similar way to the definition mechanisms of\nfunctional programming by using a generic constructor (destructor), a feature that can be easily enhaced\nto use several specific constructors by means of clausular definitions (see [10]), a mechanism which also\nallows not to use neither existential nor restricted formulas. By means of examples, we have shown the\nsuitability of the logic to extract programs from proofs. However, the concept of formal data type and\nother semantical foundations of the program extraction method, like the issue of equality for coinductive\ndata types, as well as the development of more sophisticated case studies, are work in progress.\n\nAcknowledgements\nWe are thankful to the anonymous referees for the helpful comments regarding the contents of this paper,\nin particular for the gentle hint to include the conatural numbers as an example. We also gratefully\nacknowledge Martha Elena Buschbeck Alvarado for improving the English manuscript.\n\n\f46\n\nMendler-style Iso-(Co)inductive predicates: a strongly normalizing approach\n\nReferences\n[1] A. Abel (2007): Mixed Inductive/Coinductive Types and Strong Normalization, LNCS 4087, Springer,\npp. 286-301, doi:10.1007/978-3-540-76637-7 19\n[2] D. Baelde (2011): Least and Greatest Fixed Points in Linear Logic. Accepted for publication at the\nACM Transactions on Computational Logic, http://arxiv.org/abs/0910.3383v4\n[3] J.L. Krivine & M. Parigot (1990): Programming with Proofs. In Journal of Information Processing\nand Cybernetics EIK (Formerly Elektronische Informationsverarbeitung und Kybernetik) 26(3), pp.\n149-167.\n[4] J.L. Krivine (1993): Lambda-Calculus, Types and Models. Ellis Horwood Series in Computers and\ntheir Applications. Ellis Horwood, Masson.\n[5] D. Leivant (1983): Reasoning about Functional Programs and Complexity Classes associated with\nType Disciplines.. In Proceedings of 24th Annual Symposium on Foundations of Computer Science,\nIEEE Computer Science Press, pp.460-469, doi:10.1109/SFCS.1983.50\n[6] P. Manoury & M. Simonot (1994): Automatizing termination proofs of recursively defined functions..\nTheoretical Computer Science 135, pp. 319-343, doi:10.1016/0304-3975(94)00021-2\n[7] R. Matthes (1999): Extensions of System F by Iteration and Primitive Recursion on Monotone Inductive Types. Dissertation Universit\u00e4t M\u00fcnchen, http://www.irit.fr/~Ralph.Matthes/\ndissertation/matthesdiss.pdf\n[8] N.P. Mendler (1987): Recursive Types and Type Constraints in Second-Order Lambda Calculus. In\nProceedings of the 2nd Annual Symposium on Logic in Computer Science, Ithaca N.Y. IEEE Computer\nSociety Press, pp. 30-36.\n[9] F.E. Miranda-Perea (2009): Two Extensions of System F with (Co)iteration and Primitive (Co)recursion Principles. Theoretical Informatics and Applications 43(4), pp. 703\u2013766,\ndoi:10.1051/ita/2009015\n[10] F. E. Miranda-Perea (2005): Realizability for Monotone and Clausular (Co)inductive Definitions.\nElectronic Notes in Theoretical Computer Science 123. pp. 179-193, doi:10.1016/j.entcs.2004.04.048\n[11] F.E. Miranda-Perea & L. C. Gonz\u00e1lez-Huesca (2012): Mendler-style Iso-(Co)inductive predicates: a\nstrongly normalizing approach (Extended Version). Technical report, Facultad de Ciencias UNAM.\nAvailable upon request.\n[12] A. Momigliano & A. Tiu (2003): Induction and Co-induction in Sequent Calculus. LNCS 3085,\nSpringer, pp. 293-308, doi:10.1007/978-3-540-24849-1 19\n[13] M. Parigot (1989): On the Representation of Data in Lambda-Calculus. LNCS 440, doi:10.1007/3540-52753-2 47\n[14] M. Parigot (1992): Recursive programming with proofs. Theoretical Computer Science 94, pp. 335356, doi:10.1016/0304-3975(92)90042-E\n[15] C. Raffalli (1993): Data Types, Infinity and Equality in System AF2. LNCS 832, Springer, pp. 280294, doi:10.1007/BFb0049337\n[16] T. Uustalu (1998): Natural deduction for intuitionistic least and greatest fixedpoint logics, with an\napplication to program construction (PhD thesis). Dissertation TRITA-IT AVH 98:03, Dept. of Teleinformatics, Royal Inst of Technology (KTH), Stockholm.\n[17] T. Uustalu & V. Vene (2002): Least and greatest fixed-points in intuitionistic natural deduction.\nTheoretical Computer Science 272, pp. 315-339, doi:10.1016/S0304-3975(00)00355-8\n\n\f"}