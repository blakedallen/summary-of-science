{"id": "http://arxiv.org/abs/1102.0885v2", "guidislink": true, "updated": "2011-02-09T09:12:27Z", "updated_parsed": [2011, 2, 9, 9, 12, 27, 2, 40, 0], "published": "2011-02-04T11:43:33Z", "published_parsed": [2011, 2, 4, 11, 43, 33, 4, 35, 0], "title": "Cryptographic Protocols under Quantum Attacks", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1102.3909%2C1102.0763%2C1102.3174%2C1102.4274%2C1102.4449%2C1102.5697%2C1102.4453%2C1102.2442%2C1102.5428%2C1102.2878%2C1102.4065%2C1102.1555%2C1102.5322%2C1102.4354%2C1102.2931%2C1102.2678%2C1102.1520%2C1102.5469%2C1102.0869%2C1102.0885%2C1102.5239%2C1102.3256%2C1102.5667%2C1102.1336%2C1102.1872%2C1102.2351%2C1102.5109%2C1102.3339%2C1102.5272%2C1102.2363%2C1102.3305%2C1102.5604%2C1102.2126%2C1102.1612%2C1102.4439%2C1102.0022%2C1102.5540%2C1102.0590%2C1102.0464%2C1102.4571%2C1102.4564%2C1102.3259%2C1102.2435%2C1102.2322%2C1102.0426%2C1102.0045%2C1102.4972%2C1102.1735%2C1102.0639%2C1102.1521%2C1102.2928%2C1102.4046%2C1102.3255%2C1102.1671%2C1102.3196%2C1102.4136%2C1102.5499%2C1102.2234%2C1102.0981%2C1102.5008%2C1102.2533%2C1102.3989%2C1102.5069%2C1102.4759%2C1102.2334%2C1102.1537%2C1102.5328%2C1102.5549%2C1102.4229%2C1102.4911%2C1102.0936%2C1102.1867%2C1102.0355%2C1102.2993%2C1102.4450%2C1102.3474%2C1102.5435%2C1102.1070%2C1102.1647%2C1102.1851%2C1102.0086%2C1102.2831%2C1102.2750%2C1102.0124%2C1102.4299%2C1102.2018%2C1102.4295%2C1102.3107%2C1102.2797%2C1102.1153%2C1102.2088%2C1102.3424%2C1102.4870%2C1102.1835%2C1102.4593%2C1102.0906%2C1102.1703%2C1102.1284%2C1102.4641%2C1102.5393%2C1102.0631&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Cryptographic Protocols under Quantum Attacks"}, "summary": "The realm of this thesis is cryptographic protocol theory in the quantum\nworld. We study the security of quantum and classical protocols against\nadversaries that are assumed to exploit quantum effects to their advantage.\nSecurity in the quantum world means that quantum computation does not\njeopardize the assumption, underlying the protocol construction. But moreover,\nwe encounter additional setbacks in the security proofs, which are mostly due\nto the fact that some well-known classical proof techniques are forbidden by\ncertain properties of a quantum environment. Interestingly, we can exploit some\nof the very same properties to the benefit of quantum cryptography. Thus, this\nwork lies right at the heart of the conflict between highly potential effects\nbut likewise rather demanding conditions in the quantum world.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1102.3909%2C1102.0763%2C1102.3174%2C1102.4274%2C1102.4449%2C1102.5697%2C1102.4453%2C1102.2442%2C1102.5428%2C1102.2878%2C1102.4065%2C1102.1555%2C1102.5322%2C1102.4354%2C1102.2931%2C1102.2678%2C1102.1520%2C1102.5469%2C1102.0869%2C1102.0885%2C1102.5239%2C1102.3256%2C1102.5667%2C1102.1336%2C1102.1872%2C1102.2351%2C1102.5109%2C1102.3339%2C1102.5272%2C1102.2363%2C1102.3305%2C1102.5604%2C1102.2126%2C1102.1612%2C1102.4439%2C1102.0022%2C1102.5540%2C1102.0590%2C1102.0464%2C1102.4571%2C1102.4564%2C1102.3259%2C1102.2435%2C1102.2322%2C1102.0426%2C1102.0045%2C1102.4972%2C1102.1735%2C1102.0639%2C1102.1521%2C1102.2928%2C1102.4046%2C1102.3255%2C1102.1671%2C1102.3196%2C1102.4136%2C1102.5499%2C1102.2234%2C1102.0981%2C1102.5008%2C1102.2533%2C1102.3989%2C1102.5069%2C1102.4759%2C1102.2334%2C1102.1537%2C1102.5328%2C1102.5549%2C1102.4229%2C1102.4911%2C1102.0936%2C1102.1867%2C1102.0355%2C1102.2993%2C1102.4450%2C1102.3474%2C1102.5435%2C1102.1070%2C1102.1647%2C1102.1851%2C1102.0086%2C1102.2831%2C1102.2750%2C1102.0124%2C1102.4299%2C1102.2018%2C1102.4295%2C1102.3107%2C1102.2797%2C1102.1153%2C1102.2088%2C1102.3424%2C1102.4870%2C1102.1835%2C1102.4593%2C1102.0906%2C1102.1703%2C1102.1284%2C1102.4641%2C1102.5393%2C1102.0631&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The realm of this thesis is cryptographic protocol theory in the quantum\nworld. We study the security of quantum and classical protocols against\nadversaries that are assumed to exploit quantum effects to their advantage.\nSecurity in the quantum world means that quantum computation does not\njeopardize the assumption, underlying the protocol construction. But moreover,\nwe encounter additional setbacks in the security proofs, which are mostly due\nto the fact that some well-known classical proof techniques are forbidden by\ncertain properties of a quantum environment. Interestingly, we can exploit some\nof the very same properties to the benefit of quantum cryptography. Thus, this\nwork lies right at the heart of the conflict between highly potential effects\nbut likewise rather demanding conditions in the quantum world."}, "authors": ["Carolin Lunemann"], "author_detail": {"name": "Carolin Lunemann"}, "author": "Carolin Lunemann", "arxiv_comment": "PhD Thesis, Aarhus University, Denmark, 146 pages; v2: updated bib\n  entry", "links": [{"href": "http://arxiv.org/abs/1102.0885v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1102.0885v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1102.0885v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1102.0885v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:1102.0885v2 [quant-ph] 9 Feb 2011\n\nCryptographic Protocols under Quantum Attacks\nCarolin Lunemann\n\nPhD Dissertation\n\nDepartment of Computer Science\nAarhus University\nDenmark\n\n\f\fCryptographic Protocols under Quantum Attacks\n\nA Dissertation\nPresented to the Faculty of Science\nof Aarhus University\nin Partial Fulfillment of the Requirements for the\nPhD Degree\n\nby\nCarolin Lunemann\nAugust 31, 2010\n\n\f\fAbstract\nThe realm of this thesis is cryptographic protocol theory in the quantum world. We study the\nsecurity of quantum and classical protocols against adversaries that are assumed to exploit\nquantum effects to their advantage. Security in the quantum world means that quantum\ncomputation does not jeopardize the assumption, underlying the protocol construction. But\nmoreover, we encounter additional setbacks in the security proofs, which are mostly due to\nthe fact that some well-known classical proof techniques are forbidden by certain properties\nof a quantum environment. Interestingly, we can exploit some of the very same properties to\nthe benefit of quantum cryptography. Thus, this work lies right at the heart of the conflict\nbetween highly potential effects but likewise rather demanding conditions in the quantum\nworld.\n\n\f\fAcknowledgments\nThanks to all the people, I met on the way of my PhD education, for introducing me to new\nways of thinking, inspiring me by fascinating ideas, and helping me in so many other ways.\nThanks to all the people that stayed with me on this way without questioning these very\nsame aspects. To mention just a few . . .\n. . . special thanks to my supervisors Ivan Damg\u00e5rd-who taught me so much about\ncryptography-and Louis Salvail-who taught me so much about quantum-and often vice\nversa. Thanks to my co-authors Christian Schaffner, Jesper Buus Nielsen, and Serge Fehr\nfor their support throughout my PhD studies and for teaching me many fascinating details.\n. . . thanks to Prof. Claude Cr\u00e9peau from McGill University in Montr\u00e9al and Prof. Stefan\nWolf from ETH Z\u00fcrich as well as Prof. Susanne B\u00f8dker from Aarhus University for agreeing\nto constitute the evaluation committee for my PhD thesis.\n. . . thanks for proof-reading some parts of the thesis to Chris, Dorthe, and Jesper as well\nas for valuable comments to Claude and Louis.\n. . . thanks to the Crypto-Group with all its members that left, stayed or newly arrived.\nThis environment is a great place to do research in (while drinking espresso and eating cake),\nand many non-research activities (like launching julefrokost, fridaybaring, dancing danske\nfolkedanse, and often absurd discussions about everything under the sun) are unforgettable.\nThanks to the always helpful staff at the department, especially to Dorthe, Ellen, and Hanne.\n. . . thanks to Aarhus University for enabling me to travel around the world, and in that\nrespect also to IACR, Universit\u00e9 de Montr\u00e9al, INTRIQ, and Princeton University. Furthermore, my studies were supported by the MOBISEQ research project, which is funded by Det\nStrategiske Forskningsr\u00e5ds Programkomite for Nanovidenskab og -teknologi, Bioteknologi og\nIT (NABIIT). Many thanks also to Institut Mittag-Leffler of the Royal Swedish Academy\nof Sciences for providing time, grant, and space to think-as well as to prepare the defense\nand to revise the thesis. Thanks to Prof. Mary Beth Ruskai for pointing to the quantum\ninformation program at the institute.\n. . . thanks to Prof. Christoph Kreitz from the University of Potsdam for sparking my\ninterest in crypto in the first place.\n. . . and thanks to my family and many friends for their support, often from the distance.\nGrazie a Claudio, with whom I went through all phases of ever-changing three years of PhD\nstudies. Vielen Dank an MaPa, Steffi, und Dande, whose support and (blind) acceptance\nwas most helpful during my education. And last but not least, mange tak til Jesper.\nCarolin Lunemann\n\u00c5rhus, August 31, 2010\n\n\f\fContents\nAbstract\n\nv\n\nAcknowledgments\n\nvii\n\n1 Introduction\n1.1 On Cryptography . . . . . . . . . . . . . . . . . . . . .\n1.2 On the Quantum World . . . . . . . . . . . . . . . . .\n1.3 Contributions . . . . . . . . . . . . . . . . . . . . . . .\n1.3.1 The Importance of Mixed Commitments . . . .\n1.3.2 Improving the Security of Quantum Protocols .\n1.3.3 Classical Coin-Flipping in the Quantum World\n1.3.4 Applications . . . . . . . . . . . . . . . . . . .\n\nI\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n\nSetting The Stage\n\n2 Cryptographic Toolbox\n2.1 Players . . . . . . . . . . . . . . . . . . . . .\n2.2 Security Flavors, Assumptions, and Models\n2.3 Worlds . . . . . . . . . . . . . . . . . . . . .\n2.4 Primitives . . . . . . . . . . . . . . . . . . .\n2.4.1 Commitments . . . . . . . . . . . . .\n2.4.2 Oblivious Transfer . . . . . . . . . .\n2.4.3 Password-Based Identification . . . .\n2.4.4 Coin-Flipping . . . . . . . . . . . . .\n2.4.5 Zero-Knowledge . . . . . . . . . . .\n2.4.6 Secure Secret Sharing . . . . . . . .\n\n1\n1\n2\n5\n5\n6\n8\n9\n\n11\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n13\n13\n14\n16\n17\n17\n19\n19\n20\n21\n24\n\n3 Quantum Tools\n3.1 Postulates and Terminology . . . . . . . . . . . . . . .\n3.2 Distance, Distinguishability, and Dependence . . . . .\n3.3 Entropies . . . . . . . . . . . . . . . . . . . . . . . . .\n3.4 Information Reconciliation and Privacy Amplification\n3.5 Rewinding . . . . . . . . . . . . . . . . . . . . . . . . .\n3.5.1 Problems with General Rewinding . . . . . . .\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n25\n25\n29\n33\n35\n36\n36\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n\f3.6\n\nII\n\n3.5.2 Quantum Rewinding . . . . . .\nDefinition of Security . . . . . . . . . .\n3.6.1 Correctness . . . . . . . . . . .\n3.6.2 Information-Theoretic Security\n3.6.3 Computational Security . . . .\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n37\n40\n41\n41\n43\n\nQuantum Cryptography\n\n47\n\n4 Introduction\n4.1 Mixed Commitments . . . . . .\n4.1.1 Motivation . . . . . . .\n4.1.2 Idea . . . . . . . . . . .\n4.1.3 Instantiations . . . . . .\n4.1.4 Extended Construction\n\n.\n.\n.\n.\n.\n\n49\n49\n49\n50\n51\n52\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n53\n53\n54\n54\n55\n57\n59\n64\n65\n65\n65\n66\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n69\n69\n69\n70\n73\n73\n74\n77\n77\n79\n81\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n5 Improved Security for Quantum Protocols\n5.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . .\n5.2 Introducing Commit&Open . . . . . . . . . . . . . . . .\n5.2.1 Initial situation . . . . . . . . . . . . . . . . . .\n5.2.2 Security against Benign Bob . . . . . . . . . .\n5.2.3 From Benign to Computational Security . . . .\n5.2.4 Proof of Bounds on Entropy and Memory Size\n5.3 In the Presence of Noise . . . . . . . . . . . . . . . . .\n5.4 Bounded-Quantum-Storage Security . . . . . . . . . .\n5.5 Composability . . . . . . . . . . . . . . . . . . . . . .\n5.5.1 Sequential Composition . . . . . . . . . . . . .\n5.5.2 General Composition . . . . . . . . . . . . . . .\n6 Applications\n6.1 Oblivious Transfer . . . . . . . . . . . . . . .\n6.1.1 Motivation and Related Work . . . . .\n6.1.2 The Protocol . . . . . . . . . . . . . .\n6.2 Password-Based Identification . . . . . . . . .\n6.2.1 Motivation and Related Work . . . . .\n6.2.2 The Protocol . . . . . . . . . . . . . .\n6.3 Man-in-the-Middle Security for Identification\n6.3.1 Motivation . . . . . . . . . . . . . . .\n6.3.2 The Set-Up . . . . . . . . . . . . . . .\n6.3.3 The Protocol . . . . . . . . . . . . . .\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n\fIII\n\nCryptography in the Quantum World\n\n85\n\n7 Introduction\n7.1 Regular Bit Commitment . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7.2 Extended Construction for Mixed Commitments . . . . . . . . . . . . . . . .\n7.3 Trapdoor Opening for Mixed Commitments . . . . . . . . . . . . . . . . . . .\n8 Quantum-Secure Coin-Flipping\n8.1 Motivation and Related Work .\n8.2 The Protocol . . . . . . . . . .\n8.3 Composability . . . . . . . . .\n8.3.1 Sequential Composition\n8.3.2 General Composition . .\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n9 Amplification Framework for Strong Coins\n9.1 Motivation . . . . . . . . . . . . . . . . . . . . .\n9.2 Security Notions . . . . . . . . . . . . . . . . . .\n9.3 Amplification Theorems . . . . . . . . . . . . . .\n9.3.1 From Short Outcomes to Long Outcomes\n9.3.2 From (force, uncont) to (force, random)\n9.3.3 From (force, random) to (force, force) .\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n\n87\n87\n89\n89\n\n.\n.\n.\n.\n.\n\n95\n. 95\n. 96\n. 100\n. 100\n. 101\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n\n103\n103\n104\n107\n107\n107\n109\n\n10 Applications\n10.1 Interactive Quantum Zero-Knowledge . . . . . . .\n10.1.1 Motivation and Related Work . . . . . . . .\n10.1.2 Formal Definition of Zero-Knowledge Proofs\n10.1.3 The Transformation . . . . . . . . . . . . .\n10.2 Zero-Knowledge Proof of Knowledge . . . . . . . .\n10.2.1 Motivation and Related Work . . . . . . . .\n10.2.2 Simulatable Witness Encodings of N P . . .\n10.2.3 The Protocol . . . . . . . . . . . . . . . . .\n10.3 Generation of Commitment Keys . . . . . . . . . .\n10.3.1 Motivation . . . . . . . . . . . . . . . . . .\n10.3.2 The Generation . . . . . . . . . . . . . . . .\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\n113\n113\n113\n114\n115\n118\n118\n119\n120\n124\n124\n124\n\nBibliography\n\n127\n\n\f\f1\nchapter\n\nIntroduction\n1.1\n\nOn Cryptography\nThe multiple human needs and desires that demand privacy among two or more people\nin the midst of social life must inevitably lead to cryptology wherever men thrive\nand wherever they write.\n- David Kahn\n\nCryptography is the art of secret writing (from Greek \u03ba\u03c1\u03c5\u03c0\u03c4 o\u03c2 and \u03b3\u03c1\u03b1\u03c6\u03c9) and may be\nconsidered almost as old as writing itself. Cryptography played a crucial role throughout the\nhistory of any society that depended on information, from the Greek Scytale and the Roman\nCaesar cipher, over the Vigen\u00e8re cipher, electromechanical rotor machines and encryption\nstandards, to forming the backbone of electronic infrastructures in modern life (see e.g. [Sin00]\nfor a historic survey of cryptography).\nThe first cryptographic methods are known as secret-key cryptography, based on one\nsecret key shared between the communicating parties and used both for encryption and\ndecryption. Already apparent from this description derives its main problem, which lies in\nthe logistics of distributing the key securely: Prior to any secret communication, the involved\nparties must be in possession of the same secret key. Nevertheless, secret-key cryptography\nwas in use for thousands of years, adjusting its complexity to ever-increasing developments\nin technique and technology.\nPublic-key cryptography was the technological revolution, solving the key distribution\nproblem. The idea was independently discovered by Diffie and Hellman in [DH76] with\nRivest, Shamir, and Adleman, providing the first implementation [RSA78], and slightly\nearlier but in secrecy, by Ellis, followed by Cocks' and Williamson's practical application\n(e.g. [Coc08]). Public-key cryptography is based on a pair of keys for each communicating\nparty, namely a public key for encryption and a corresponding secret key for decryption,\nwhere it must hold that it is computationally infeasible (in polynomial time) of deriving the\nsecret key from the public one. Then, we require a family of trapdoor one-way functions\ndefining the encryption and decryption procedure. Informally, that means that encryption\nis a one-way operation, which is efficiently computable, given the public key, whereas the\ndecryption function is hard to compute, unless the trapdoor is known, i.e. the secret key.\nThus, the public key can be published without compromising security, and hence, public-key\ncryptography does not suffer from key distribution problems. Due to that and to the fact that\nthe technique additionally allows for digital signatures that are verifiable with the public key\n\n\f2\n\nCHAPTER 1. INTRODUCTION\nand yet unforgeable without the secret key, the concept of public-key cryptography is highly\nused and required in the age of the Internet and the proliferation of electronic communication\nsystems.\nNew potential in cryptography emerged with quantum cryptography, starting with Wiesner's groundbreaking paper [Wie83]1 , suggesting that \"quantum mechanics allows us novel\nforms of coding without analogue [in classical physics]\" (p. 78). His approach of conjugate coding did not only lay the foundations of the new cryptographic technique but also\nsuggested a system for sending \"two mutually exclusive messages\" (p. 83), which is today known as the powerful primitive of oblivious transfer. It took several years (and the\nCaribbean sea) to establish quantum cryptography as a scientific discipline, accomplished by\nBennett and Brassard, mainly by the BB84-protocol for quantum key distribution (QKD)\nin [BB84] after preceding work such as [BBBW82, BB83], culminating in the first practical\nrealizations [BB89, BBB+ 92]. An alternative QKD scheme was independently proposed by\nEkert in [Eke91], based on a different approach using quantum entanglement. Since then,\nQKD was further researched, both on a theoretical and an experimental level. Today, conjugate BB84-coding also forms the basis for various more general quantum cryptographic tasks\nother than key distribution.\nModern cryptography concerns, besides the secrecy and authenticity of communication,\nalso the security of various other task. For instance, theoretical research in the sub-field of\ncryptographic protocol theory covers cryptographic primitives with fundamental properties\nfor secure multi-party computation. Each primitive can be seen as a building block that\nimplements some basic functionality. Composition of such primitives within outer protocols\nyield applications that implement a specific task securely over a distance.\n\n1.2\n\nOn the Quantum World\nAnyone who is not shocked by quantum theory has not understood it.\n- Niels Bohr\n\nIn the quantum world, we consider the behavior of systems at the smallest scale, which\ncannot be explained nor described by classical physics. A quantum 2 is the smallest unit of\na physical entity, and the fundamental concept in quantum information theory is a quantum bit, or short, a qubit. Quantum information theory was established at the beginning\nof the last century, but has been subject to different interpretations ever since-both scientific and philosophical. This thesis is divided into two subareas of quantum information\ntheory, constituting the following two main parts, Part II and Part III (Part I is dedicated\nto preliminaries).\nPart II is in the realm of quantum cryptography, where-informally speaking-the transmission of qubits followed by some classical post-processing is employed to accomplish a\ncryptographic task. The security is mainly derived by the special properties of the qubits\nduring and after transmission, and therewith, directly from physical laws.\n1\n2\n\nThe paper was written in the early 1970ies but rejected and only published retroactively in 1983.\nquantus (Latin) - how much\n\n\f1.2. ON THE QUANTUM WORLD\nPart III on cryptography in a quantum world refers to the study of cryptography with\ncompletely classical messages exchange, but where the environment around is quantum.\nIn other words, the security of the classical schemes must withstand powerful quantum\ncomputing capabilities.\nWe now present-in brief and on a (counter-)intuitive level-the aspects unique to the\nquantum world, which are relevant in the context of this work. Interestingly, these quantum\nfeatures can be exploited to the benefit of quantum cryptography. However, the very same\nproperties impose intriguingly new challenges in classical cryptography. In other words,\n\"what quantum mechanics takes away with one hand, it gives back with the other\" [NC00,\np. 582]. And so, this work lies right at the heart of the conflict between highly potential\neffects, but likewise rather demanding conditions.\nInformation gain vs. disturbance. This aspect might be argued to constitute the\nmost outstanding advantage of quantum cryptography over the classical world, and forms\n\"the engine that powers quantum cryptography\" [Fuc96, p. 1]. In the classical case, a bit can\nsimply be read in transmission, and the information gain solely depends on the security of the\nrespective encryption used. In quantum cryptography, information is typically encoded in\ntwo complementary types of photon polarization or, in other words, a qubit is prepared in one\nout of two conjugate bases with orthogonal basis states. To gain information about such an\nunknown qubit, it must be observed, but observing in the quantum world means measuring.\nMeasuring, or more precisely distinguishing between two non-orthogonal quantum states, is\ndestructive and therewith any measurement disturbes the system. This is explained in the\nHeisenberg uncertainty principle, which states that certain pairs of quantum properties are\ncomplementary in that measuring one of them necessarily disturbs the other.\nConsequently, eavesdropping on a qubit transmission disturbs the system, and can therefore be noticed in a statistically detectable way. Moreover, the quantitative trade-off between\ninformation gain and disturbance is useful not only against an external adversary, but it is\nalso a main ingredient when proving security against a dishonest player. This fact is inherent in the basic security aspects of all our quantum two-party protocols, discussed later in\nPart II.\nAn unknown quantum state cannot be copied. This fact-unheard of in the case\nof classical data-is formalized in the no-cloning theorem [WZ82]. The peculiar property\nconstitutes another major security feature in quantum communications and underlies all\nour quantum protocols in Part II. However, it also sets severe restriction in the theory of\nquantum computing. This becomes apparent in Part III, where the commonly used classical\nproof technique rewinding, which is also shortly discussed below, requires to copy certain\ndata, and so has to be carefully reviewed in the quantum world.\nQuantum memory is limited. A more practical issue concerns the limitation of the\namount of qubits that can be stored and then retrieved undisturbed. This may be seen as\na snapshot of current state of the art. However, ongoing research strongly suggest that it\nis-and will be-much easier to transmit and measure qubits than it is to store them for a\nnon-negligible time.\n\n3\n\n\f4\n\nCHAPTER 1. INTRODUCTION\nWe will make use of this given fact in our quantum protocols in Chapter 6, which are designed such that dishonest parties would need large quantum memory to attack successfully-\na security property that classical protocols cannot achieve. Yet, we do not exclusively rely on\nthis condition only, but investigate a wider diversification of security that is not threatened\nby potential breakthroughs in developing quantum storage.\nQuantum rewinding is tricky. As already indicated, this statement is a key aspect\nin Part III, and originates from most of the above mentioned properties \"all wrapped up\ntogether\". Rewinding is a very powerful technique in simulation-based proofs against a\nclassical dishonest party: We can prove security against a cheating player by showing that\na run of a protocol between him and the honest player can be efficiently simulated without\ninteracting with the honest player, but with a simulator instead. A simulator is a machine\nwhich does not know the secrets of the honest party but yet it sends messages like the honest\nplayer would do but with more freedom, e.g. in how and when to generate these. Then to\nconclude the proof, we have to show that the running time of the simulation as well as the\ndistribution of the conversation are according to expectations. A simulator basically prepares\na valid conversation and tries it on the dishonest party. Now, in case this party does not\nsend the expected reply, we need the possibility to rewind him.3\nUnfortunately, rewinding as a proof technique can generally not be directly applied in\nthe quantum world, i.e., if the dishonest machine is a quantum computer. First, we cannot\ntrivially copy and store an intermediate state of a quantum system, and second, quantum\nmeasurements are in general irreversible. In order to produce a classical transcript, the simulator would have to partially measure the quantum system without copying it beforehand,\nbut then it would become impossible to reconstruct all information necessary for correct\nrewinding.\nDue to these difficulties, no simple and straightforward security proof for the quantum case was known. However, Watrous recently showed that in a limited setting an efficient quantum simulation, relying on the newly introduced quantum rewinding theorem\n(see [Wat09] and Section 3.5.2), is possible. We will discuss this aspect in more detail in\nChapters 8 and 9: We will show that the quantum rewinding argument can also be applied\nto classical non-constant round coin-flipping in the quantum world, and propose a framework\nto weaken certain assumptions on the coin, in quest for a quantum-secure constant round\nprotocol.\nSpooky actions at a distance. This famous naming by Einstein4 describes the phenomenon of entanglement. Informally, two qubits are called entangled, if their state can only\nbe described with reference to each other. This has the effect that a measurement on one\nparticle has an instantaneous impact on the other one-despite any distance separating the\nqubits spatially.\nEntanglement is definitely a unique resource to the quantum world only. In the words of\n3\n\nMore precisely, we model the player-similar to the simulator-as a machine, and thus, we can just set\nback this machine to an earlier status, i.e., erase parts of the memory and start a new conversation. In that\nsense, rewinding can be thought of as, for instance, rebooting a computer after it crashed.\n4\n\"Spooky actions at a distance\" was put down originally as \"spukhafte Fernwirkung\" in [Ein71].\n\n\f1.3. CONTRIBUTIONS\nSchr\u00f6dinger, entanglement is not \"one but rather the characteristic trait of quantum mechanics, the one that enforces its entire departure from classical lines of thought\" [Sch35, p. 555].\nBesides constituting a disturbing aspect-intuitively and philosophically, entanglement opens\nup for interesting applications such as quantum teleportation [BBC+ 93] and superdense coding [BW92], as well as for various aspects in quantum cryptography and computing. We\nwill use entanglement as a thought experiment in our quantum protocols when analyzing an\nequivalent purified EPR-version 5 (Chapter 5).\n\n1.3\n\nContributions\n\nThis dissertation is based on research done during the three years of my PhD studies at the\nDepartment of Computer Science, Aarhus University, Denmark. Part of the research was\nconducted while visiting Universit\u00e9 de Montr\u00e9al, Qu\u00e9bec, Canada. The realm of this work is\nquantum cryptography and classical cryptography in the quantum world. More specifically,\nthe thesis covers aspects of (quantum) cryptographic protocol theory, based on cryptographic\nprimitives. The main results are outlined in the following sections and pictorially represented\nin Figure 1.1.\n\n1.3.1\n\nThe Importance of Mixed Commitments\n\nClassical mixed (or dual-mode) commitments are of great significance for most constructions\ndiscussed in this work. Here, we explain the challenges that the quantum world imposes on\ncommitments in general and summarize the results of [DFL+ 09, DL09, LN10] in that aspect.\nSecurity for classical constructions in the quantum world means that quantum computation does not jeopardize the underlying mathematical assumption that guarantees the security, for instance, in the context of commitments, the hiding and binding property. However,\nwe encounter even more setbacks in the context of actually proving such constructions secure\nin an outer protocol, which, in regard of this work with its main focus on simulation-based\nsecurity, are mostly due to the strong restrictions on rewinding in the quantum world.\nThe first difficulty in any attempt to rewind the adversary regards the fact that the\nreduction from the computational security of an outer protocol to the computationally binding\nproperty of a commitment does not simply translate from the classical to the quantum\nworld. Computational binding means that if a dishonest party can open a commitment\nto two different values, then the computational assumption does not hold. In the classical\ncase, a simulator simulates a run of the outer protocol with the committer, such that the\nlatter outputs a valid commitment at some point during the execution. Later in the protocol\nhe must then provide a correct opening. The simulator has the possibility to rewind the\nplayer to any step in the protocol execution, e.g. to a point after the commitment was\nsent. Then it can repeat the simulation of the outer protocol, which can now be adapted\nto the simulator's knowledge of the committed value. If the dishonest committer opened\n5\nAn EPR-pair denotes a pair of entangled qubits. The name (ironically) originates from the paper [EPR35]\nby Einstein, Podolsky, and Rosen, in which they criticized quantum mechanics as an incomplete theory-due\nto entanglement.\n\n5\n\n\f6\n\nCHAPTER 1. INTRODUCTION\nthe same commitment to a different value than previously, he could break the underlying\nassumption guaranteeing computational binding. In other words, two valid openings of the\nsame commitment imply the inversion of the underlying one-way function, which concludes\nthe proof. Such a technique, however, is impossible to justify in the quantum world, since\nwe cannot trivially copy and store an intermediate state, and measurements are in general\nirreversible. In order to succeed, the simulator would have to partially measure the quantum\nsystem without copying it beforehand to obtain the first transcript, but then it would become\nimpossible to reconstruct all information necessary for correct rewinding.\nThe second challenge we encounter is to prove an outer protocol with an embedded\ncomputationally hiding commitment secure. Generally speaking, in a classical simulation of\nthe outer protocol, the simulator aims e.g. at hitting an ideal outcome to a function of which\nit then commits. Then, if the reply from the possibly dishonest counterpart matches this\nprepared function such that both sides conclude on the ideal value as their result and the\ntranscript is indistinguishable from a real run of the protocol, the simulation was successful.\nOtherwise, the simulator rewinds the dishonest player completely and repeats the simulation.\nWe show a natural and direct translation of this scenario to the quantum world in Chapter 8,\nwhere we use a technique that allows quantum rewinding in this very setting when using bit\ncommitments (see Section 1.3.3). In case of string commitments however, we cannot rewind\nthe other player in poly-time to hit the guess, since that guess consists of a bit-string. A\npossible solutions for simulating against a classical adversary is to let him commit to his\nmessage before the simulator commits. Then the player's message can be extracted and the\nsimulation can be matched accordingly. This technique, however, is again doomed to fail in\nthe quantum realm, since it reduces to the previous case where the simulator cannot preserve\nthe other party's intermediate status as required during such a simulation.\nWe will circumvent both of the above aspects by introducing mixed commitment schemes\nin our protocols. Generally speaking, the notion of mixed commitments requires some trapdoor information, given to the simulator in the ideal world. Depending on the instantiation,\nthe trapdoor provides the possibility for extraction of information out of the commitments\nor for equivocability when opening the commitments. This allows us to circumvent the necessity of rewinding in the proof, while achieving high security in the real protocol. The idea of\nmixed commitment schemes is described in more detail in Section 4.1.2 and a quantum-secure\ninstantiation is proposed in Section 4.1.3. Various extensions are then discussed to match\nthe construction to respective requirements in different outer protocols (Sections 4.1.4, 7.2,\nand 7.3).\n\n1.3.2\n\nImproving the Security of Quantum Protocols\n\nThe following results are joint work with Damg\u00e5rd, Fehr, Salvail, and Schaffner [DFL+ 09]\nand will be addressed in detail in Chapter 5.\nWe propose a general compiler for improving the security of a large class of two-party\nquantum protocols, implementing different cryptographic tasks and running between mutually distrusting players Alice and Bob. Our main result states that if the original protocol\nis secure against a so-called benign Bob, who is only required to treat the qubits \"almost\nhonestly\" but can deviate arbitrarily afterwards, then the compiled protocol is secure against\n\n\f1.3. CONTRIBUTIONS\na computationally bounded quantum Bob. The unconditional security against Alice is preserved during compilation and it requires only a constant increase of transmitted qubits and\nclassical messages.\nThe consequences of such a compiler are twofold. First, the basic assumption in designing\nnew protocols for any two-party functionality is reduced to the relatively weak assumption\non benignity. On the other hand, the proofs for already existing protocols within the specific\nclass typically go through under the assumption (at least after some minor adaptions). And\nsecond, security in the bounded-quantum-storage model implies benign security. Therefore,\nby compilation of such protocols, we can achieve hybrid security, which means that the\nadversary now needs both large quantum memory and large quantum computing power to\nbreak these new protocols.\nIn more detail, the protocols we consider here start with a qubit transmission from Alice\nto Bob, where each qubit is encoded in one of two conjugate bases. This implies that,\nwhenever Bob measures in the complementary basis, he obtains a random outcome. The\nsecond part of the protocol consist of arbitrary classical messages and local computations,\ndepending on the task at hand but typically relying on the fact that a dishonest Bob has\nhigh uncertainty about a crucial piece of information.\nThe basic technique to construct the compiler was already suggested in the first quantum\noblivious transfer protocol [CK88]. We want to force Bob to measure by asking him to\ncommit (using a classical scheme) to all his basis choices and measurement results, and\nthen require him to open some of them later. While classical intuition suggests that the\ncommitments should force Bob to measure (almost) all the qubits, it was previously very\nunclear what exactly it would achieve in the quantum world. To our best knowledge, it was\nnever formally proven that the classical intuition also holds for a quantum Bob. We now give\na full characterization of the commit&open approach in general quantum settings, namely\nthat it forces Bob to be benign.\nWe propose a formal definition for benignity, which might be of independent interest. A\nbenign Bob is characterized by the following two conditions, which must be satisfied after the\nqubit transmission. First, his quantum storage is very small, and second, there exists a basisstring such that the uncertainty about Alice's encoded bit is essentially one bit whenever\nthe encoding basis does not match the basis indicated in that string. These two conditions\nimply that a successfully passed opening of his commitments for a random test subset puts\nBob in a situation, which is close to a scenario in which he measured as supposed to: His\nquantum memory is essentially of size zero, and furthermore, measuring the untested qubits\nin a basis complementary to the one Bob (claims to have) used, leads to a result with large\nuncertainty. The bounds on Bob's uncertainty and his quantum memory are proven for an\nideal state that is negligible close to the real state. For the ideal state, we can then show that\nthe remaining subsystem after the test is a superposition of states with relative Hamming\ndistance upper bounded by the test estimate.\nTo conclude the proof, we assume that the original protocol implements some ideal functionality with statistical security against benign Bob. Then we show that the compiled\nprotocol with the commitments also implements that functionality but now with security\nagainst any computationally bounded (quantum) Bob. To preserve the unconditional security of the original protocol, we require an unconditionally hiding commitment scheme. Since\n\n7\n\n\f8\n\nCHAPTER 1. INTRODUCTION\nthe common reduction from the computational security of the protocol to the computational\nbinding property of a commitment would require rewinding, we use a mixed dual-mode\ncommitment, which allows us to avoid rewinding Bob in this step (see also Section 1.3.1).\nWe generalize our result to noisy quantum communication and show that the compilation\ndoes not render sequential composability insecure. We then extend the underlying commitment scheme for a more general composability guarantee and obtain that any compiled\nprotocol computationally quantum-UC-emulates its corresponding ideal functionality.\n\n1.3.3\n\nClassical Coin-Flipping in the Quantum World\n\nThe result on quantum-secure single coin-flipping is based on [DL09], co-authored with\nDamg\u00e5rd, and will be fully discussed in Chapter 8. The proposed amplification framework\nfor obtaining strong coin-strings from weak initial assumption on the coins is joint work with\nNielsen [LN10] and will be addressed in more detail in Chapter 9.\nWe first investigate the standard coin-flipping protocol with classical messages exchange\nbut where the adversary is assumed to be capable of quantum computing. The output\nof the protocol is a uniformly random unbiased bit, and the construction does not require\nany set-up assumptions. Therewith, the communicating parties can interactively generate\ntrue randomness from scratch in the quantum world. Our result constitutes the most direct\nquantum analogue of the classical security proof by using a recent result of Watrous [Wat09]\nthat allows for quantum rewinding in this restricted setting and when flipping a single coin.\nThe full potential of coin-flipping lies in the possibility of flipping a string of coins instead\nof a bit, such that the parties can interactively generate a common random string from\nscratch. Therewith, it is possible, for instance, to implement the theoretical assumption of\nthe common-reference-string-model, which then implies that various interesting applications\ncan be realized in a simple manner without any set-up assumptions.\nWe show that with our definitions, the single coin-flipping protocol composes sequentially.\nAdditionally, we sketch an extended construction of the underlying commitment scheme, allowing for efficient simulation on both sides, with which we achieve more general composition\nguarantees. Both compositions, however, are not fully satisfactory. Sequential coin-flipping\nallows for implementations without set-up assumptions but leads to a non-constant round\napplication. In contrast, parallel composition achieves much better efficiency with constant\nround complexity but requires some set-up assumptions in our proposed construction here.\nUnfortunately, we do not know how to extend Watrous quantum rewinding to the case of\nbit-strings, while keeping the running time of the simulator polynomial. The proof technique in the purely classical setting is impossible to apply in the quantum world (see also\nSection 1.3.1). Other techniques to achieve constant round coin-flipping are not known to\ndate.\nOur framework in Chapter 9 can be understood as a step towards constant round coinflipping. We first investigate different security degrees of a string of coins. We then propose\nprotocol constructions that allow us to amplify the respective degrees of security such that\nweaker coins are converted into very strong ones. The final result constitutes an amplification\ntowards a coin-flipping protocol with long outcomes, which is fully poly-time simulatable on\nboth sides against quantum adversaries. The protocol can be implemented with quantum-\n\n\f1.3. CONTRIBUTIONS\ncomputational security in the plain model without any set-up assumptions. It only assumes\nmixed commitment schemes, which we know how to construct with quantum security, and\nno other assumptions are put forward. With this solution, we still have to compose the single\ncoin-flip as sketched above sequentially to obtain long outcomes, but we achieve coins with\nstronger security.\nOur method of amplifying the security strength of coins also applies to potential constant\nround coin-flipping. If the underlying weak protocol already produces string outcomes and\nis constant round, then the resulting strong protocol is also constant round, and we consider\nit a contribution in itself to define the weakest security notion for any potential candidate\nthat allows to amplify to the final strong protocol using a constant round reduction.\n\n1.3.4\n\nApplications\n\nWe consider our applications in both parts of the thesis (Chapters 6 and 10) well suited as\nexamples for the respective precedent main results, since they all have some special properties. Depending on the context they are proposed in, they appeared in [DFL+ 09,DL09,LN10].\nThe first quantum protocol in Section 6.1 implements oblivious transfer (OT), which\nconstitutes a highly relevant cryptographic primitive that is complete for general two-party\ncomputation. Interestingly, the idea behind this primitive was introduced in the context of\nquantum cryptography, namely, in the pioneering paper of Wiesner [Wie83] that also paved\nthe way for quantum cryptography by introducing the concept of conjugate coding. The very\nnature of conjugate coding implies oblivious transfer, and with that, it can be understood\nas a natural quantum primitive.\nClassical and quantum OT cannot be implemented without any additional restrictions.\nHowever, in contrast to classical OT, quantum OT reduces to classical commitment. The\nidea of using a classical commitment within quantum protocols was already suggested in the\nfirst quantum oblivious transfer protocol [CK88] and its follow-up work in [BBCS91]. Various\npartial results followed, such as assuming a perfect ideal commitment [Yao95, May96, Unr10]\nor a (theoretical) quantum string commitment [CDMS04]. Based on the analysis of our\ncompilation (sketched in Section 1.3.2), we can now rather simply apply our compiler to (a\nvariant of) the original quantum OT-protocol, and therewith, give a complete proof for a\nconcrete commitment scheme.\nIn a rather straightforward way, oblivious transfer as a building block easily extends to\npassword-based identification, which is needed for any authenticated set-up. The quantum\nidentification scheme in Section 6.2 allows for identification by solely proving the knowledge\nof a secret password without actually announcing it in clear. Furthermore, it has some\nspecial properties, which indicates its utility value in practice. First, the only option without\nbeing in possession of the password is to guess it, which implies that the same password\nmay be safely reused for a long time. Second, the scheme tolerates a possibly non-uniform\npassword, which translates to a realistic assumption of user-memorizable passwords. And\nlast, a typical setting for identification is not necessarily required to run over large distances to\nbe considered useful, and as such, it can actually be implemented with existing technology.\nNaturally, an identification scheme, secure under diversified assumptions and against any\nexternal adversary, is an important step towards an actual implementation.\n\n9\n\n\f10\n\nCHAPTER 1. INTRODUCTION\nThe classical generation of commitment keys in Section 10.3 nicely combines the above\napplications with the results on quantum-secure coin-flipping, fulfilling the requirement on\nour mixed commitment construction. By running a coin-flipping protocol as an initial step\nin the quantum protocols above, the communicating players can interactively generate their\ncommitment keys for compilation. This allows us to avoid the common-reference-stringmodel and yields implementations of entire protocols in the quantum world without any\nset-up assumptions.\nThe two application in the context of zero-knowledge are interesting in that the interactive generation of coins at the beginning or during outer protocols allows for quantum-secure\nrealizations of classical schemes from scratch. First in Section 10.1, we show a simple transformation from non-interactive zero-knowledge to interactive quantum zero-knowledge. Then\nin Section 10.2, we propose a quantum-secure zero-knowledge proof of knowledge, which relies\nnot only on initial randomness but also on enforceable randomness and is based on a witness\nencoding scheme providing a certain degree of extractability, defined for the quantum context\nto resemble special soundness of classical schemes. Both zero-knowledge constructions nicely\nhighlight that the realization of coin-flipping as a stand-alone tool allows for using it rather\nfreely in various contexts.\n\nCoin-Flipping\n[DL09]\n\nIQZK\n\nStrong Coin-Flipping\n[LN10]\n\nConstant-Round\nCoin-Flipping\n[open]\nCryptography in the Quantum World\n\nImproved Security\n\nQuantum Cryptography\n[DFLSS09]\nHybrid Security\n\nQZKPoK\n...\n[DL09,LN10]\n\n...\n\nOT\n\nID\n\nFigure 1.1: Picture of the Thesis.\n\n\fPart I\n\nSetting The Stage\n\n\f\f2\nchapter\n\nCryptographic Toolbox\nIn this work, we are interested in classical and quantum cryptographic two-party protocols,\ni.e., our focus lies on enabling two players to accomplish a specific task securely by communicating over a distance. In a perfect world of gentlemen, we could, of course, just communicate\nover a distance without using cryptographic security precautions. In an ideal world, we can\nsimply assume a \"black-box\" that solves what we want while not leaking anything of importance. However, we operate in the real world. This means that we do not only have to take\nvarious dishonest players into account when implementing our protocols, but also that we\nhave to work within a restricted framework of given conditions and existing resources.1\nIn the following sections we formalize this intuitive description in cryptographic terms.\nThe chapter is not intended to provide a full introduction to cryptographic protocol theory,\nbut rather to give a brief but complete overview of notation, tools, conditions, and settings\nwe will use, and to fix terminology that may vary in standard literature. In short, we are\nsetting the stage for the results in this thesis.\n\n2.1\n\nPlayers\n\nOur main characters are Alice and Bob, who are subject to different roles and cheating\ncapabilities. The correctness of our two-party protocols is ensured, if they implement the\ntask at hand in the desired way. This scenario only concerns honest parties Alice and Bob,\nwho may have different roles, such as sender, receiver, committer, verifier, user and server,\ndepending on the respective functionality to be carried out. An honest player is denoted\nby P.\nSecurity is shown by investigating the case where one of the parties is dishonest. More\nprecisely, a dishonest party P0 can try, for instance, to bias the outcome of the protocol or\nto succeed illegitimately.\nBetween these two extremes, there are various nuances of cheating. For instance, the common notion of semi-honest describes an \"honest-but-curious\" player who is curious enough in\ntrying to gain additional information while following the protocol honestly. We will in Chapters 5 and 6 use another intermediate notion that captures benignly dishonest behavior in\nquantum protocols. The protocols consist of a quantum transmission phase and some classical post-processing. A benign receiver of qubits is assumed to treat these \"almost honestly\",\n1\n\nNote that, throughout this work, we will use the terms ideal world and real world also in the more formal\ncontext of the so-called two-world paradigm (see Section 2.3) for simulation-based proofs.\n\n\f14\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\nwhich means he immediately measures most of the qubits upon reception in the specified\nbases. Afterwards during the classical post-processing, he can deviate arbitrarily. Thus, in\nsome sense, he wants to cheat but is incapable of mastering the quantum information in any\nother way than simply measuring it. We will define this newly introduced notion in greater\ndetail later on, as it forms the foundation of our improved quantum protocols.\nA very different external adversary is the so-called man-in-the-middle Eve (denoted by E),\nwho tries to eavesdrop on the classical and quantum communication between Alice and Bob,\nwith the intention to break the protocol-or at least gain some information-without being\ndetected. Quantum cryptography provides its protocols with automatic intrusion detection,\ndue to the fact that here any kind of intrusion will inevitably disturb the system. However,\nwe have to thoroughly implement the testing of qubits for interference as well as investigate\nthe potential information leakage of the classical communication.\n\n2.2\n\nSecurity Flavors, Assumptions, and Models\n\nThe purpose and objective of theoretical cryptography is to design protocols with the highest\nsecurity possible under any condition, this means without any restriction on adversarial\nresources such as computing power and memory size. However, this unconditional security is\nextremely hard to obtain for both players simultaneously in the classical and in the quantum\nworld. In fact, some tasks are proven to be impossible to achieve with unconditional security\nfor both players. The most well-known example thereof might be the impossibility results on\nunconditionally secure classical and quantum bit commitment (proven in the quantum case\nby [May97, LC97]). Furthermore, for two distrusting parties, the only applications actually\nproven to be unconditionally secure regarding confidentiality are Vernam's symmetric onetime pad encryption [Ver26, Sha49] as well as quantum key distribution [BB84, SP00].\nThus, the level of security has to be lowered for implementing other functionalities, and\nwe have to achieve a reasonable balance between realistic assumptions under consideration of\ncurrent and future technology-as weak as possible-and yet meaningful security-as strong\nas possible. For that purpose, we specify cryptographic models to capture various notions of\nsecurity and to impose realistic restrictions on the adversary. To mention just a few, such\nmodels consider limited computing power, limited memory size [Mau92,DFSS05], a common\nresource with special properties (e.g. initially shared randomness), noisy storage [WST08] or\nrestricted quantum measurement (e.g. a limited set of measurements [KMP04] or a limited\nset of qubits to be measured at the same time [Sal98]).\nComputational Security. Restricting the adversarial classical computing power and\ntime is currently the most applied model in practical public-key cryptography. Thus, it\nis known as the plain model , achieving computational security based on classical hardness\nassumptions that some problems are computationally infeasible to solve in polynomial time2 .\nUsually, security is shown by reducing the security of the actual scheme to that of a wellknown mathematical problem. However, the hardness of such complexity assumptions is\n2\nAn algorithm is poly-time, if its running time is upper bounded by a polynomial in the size of its input,\ni.e. O(nc ). In more detail, there exist constants c > 1 and n0 such that poly(n) \u2264 nc for all n > n0 . As\nsynonyms, we often use feasible or efficient.\n\n\f2.2. SECURITY FLAVORS, ASSUMPTIONS, AND MODELS\nunproven.\nIt should also not go unnoted that with the emergence of quantum computers which, due\nto their speed-up in running time, have great potential to solve several of the basic assumptions in polynomial time, security of various crypto-systems would fold. To give examples,\nShor showed algorithms for efficiently factoring large integers [Sho97], which would jeopardize the RSA assumption, and for the related problem of computing discrete logarithms\nunderlying e.g. the ElGamal encryption system. Grover's algorithm for conducting a search\nthrough some unstructured search space shows a quadratic speed-up over classical computation. This, for instance, also affects the time of performing exhaustive search over the set of\npossible keys, used in symmetric crypto-systems (e.g. DES). Of course, these algorithms only\nyield profitable results, if large-scale quantum computers can be built. Interestingly, the very\nquantum effects that makes them so powerful, also makes them so difficult to control-so\nfar.\nQuantum-Computational Security. Recently, the new sub-field of so-called post-quantum cryptography has emerged within public-key cryptography.3 There, the focus lies on\nresearching assumptions which are believed to be hard even on a quantum computer, and\nthus, on achieving quantum-computational security. Post-quantum crypto-schemes include,\nfor instance, the McEliece crypto-system based on a coding-theoretic problem [McE78] and\nlattice-based crypto-systems (e.g. [Ajt96,Reg05]). The latter provide, besides good efficiency\nwhen en- and decoding, the merit that breaking the security of such protocols implies to\nsolve a hard lattice problem in the worst case. However, we should stress also in this context\nthat this hardness is again assumed; formal proofs are still to come. In this work, we will\nuse lattice-based crypto-systems for implementing mixed commitment schemes, secure in the\nquantum world (Chapters 5 and 9).\nQuantum Security. In contrast to security through mathematical hardness assumptions\nin classical cryptography, the security in quantum cryptography is based on quantum mechanical laws. Proofs for physical limitations are not by reduction as for computational\nlimitations but in information-theoretic terms. That means that in such models, an adversary does not learn any information, except with at most negligible probability.4\nBounded-Quantum-Storage Model. In the quantum cryptographic setting, one such\nphysical limitation is formalized in the bounded-quantum-storage model (BQSM), proposed\nin [DFSS05]. The intuitive idea behind the model is that the most sensitive information is\nencoded in qubits that are transmitted in the first phase of the protocol. Then, at some\nlater point, typically an announcement of the encoding bases follows to complete the task\nat hand. Now, under the assumption that an adversary's quantum memory size is limited,\nhe cannot store all of the qubits but has to measure some fraction. Thus, by converting\n3\n\nThe common classification might be slightly confusing, in that the notion \"post-quantum\" relates to the\ntime after the successful development of large-scale quantum computers as opposed to quantum cryptography.\n4\nNegligible in n means that any function of n is smaller than the inverse of any polynomial, provided n is\nsufficiently large, i.e., for all constants c there exists a constant nc such that negl (n) \u2264 n\u2212c for all n > nc .\n\n15\n\n\f16\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\nquantum information into classical information without complete knowledge of the right\nbases, information gets irreversibly destroyed.\nThe protocols in this model achieve unconditional protection against cheating by one of\nthe players, while if the other is corrupted, the protocols are secure under the sole assumption\nthat his quantum storage is of limited size, namely of size at most a constant fraction of\nthe qubits sent. Such a bound can also be applied to an external eavesdropper's quantum\nmemory by slightly extending the respective original protocol. The underlying motivation\nfor the BQSM is the fact that transmission and measurement of qubits is well within reach of\ncurrent technology. Storing quantum information however requires keeping the qubit state\nstable under controlled conditions for a non-negligible time, which still constitutes a major\ntechnological challenge, and an attack would require large quantum storage with a long\nlifetime. In contrast, honest parties, following the protocol, do not need quantum memory\nat all. Furthermore, neither honest nor dishonest parties are bounded with respect to their\nclassical storage or computing power. We want to stress that the impossibility results against\nthe bounded-classical-storage model (see e.g. [Mau90, Mau92, CCM98, DM04]) do not hold\nin the quantum setting.5 Hence, the BQSM is realistic for fundamental physical reasons and\npotentially useful in practice.\nMany two-party applications investigated in the BQSM (like identification) are not necessarily required to run over large distances to be considered useful. Thus, such protocols\ncan actually be implemented with existing devices, and many applications have been proven\nBQSM-secure [DFSS05, DFSS07, Sch07]. We will work in this model in Chapter 6, where it\nconstitutes one of the security layers in our quantum protocols.\nCommon-Reference-String-Model. Another useful model, which we will consider, is\nthe common-reference-string-model (CRS-model). In this model, as the name suggests, the\nparties are provided with a classical common public string before communication, taken\nfrom some fixed distribution that only depends on the security parameter. For efficiency\nand composability, we will often assume the model to allow for techniques, which require an\ninitially shared random string. However, we consider a random string \"in the sky\" a set-up,\nwhich is only theoretically useful. To meet more practical demands, we suggest in Chapter 8\na quantum-secure implementation of the CRS-model \"from scratch\".\n\n2.3\n\nWorlds\n\nClassical vs. Quantum World. We are interested in cryptography in the quantum\nworld, covering both quantum and classical cryptographic protocol theory, which is evident\nin the separation of the thesis in the two main parts, Part II on quantum cryptography and\nPart III on classical cryptography in the quantum world. Thus, throughout this work, we\nconsider quantum potential-achieving very high security in the first case but also imposing\nnew demands in the latter. In contrast, the (pure) classical world of cryptography does\ntraditionally not assume adversarial quantum effects. However, we emphasize our very strong\n5\nThe bounded-classical-storage model ensures security as long as the adversary's memory size is at most\nquadratic in the memory size of the honest players. A favorably larger gap between the storage assumptions\non honest and dishonest parties was shown to be impossible [DM04].\n\n\f2.4. PRIMITIVES\nrequirement also for all classical protocols and proofs to be quantum-computationally secure,\nwhich implies both the exclusive use of post-quantum crypto-schemes, and the avoidance or\ncarefully adaption of classical proof techniques.\nIdeal vs. Real World. For the definition of security, we work in two different worlds,\nwhich are captured in the two-world paradigm of simulation-based proofs. The basic idea of\nthe paradigm is to first specify the ideal functionality F that models the intended behavior\nof the protocol, or in other words, the properties we would have in an ideal world. The ideal\nfunctionality can be thought of as a trusted third party or simply a black-box that gets private\ninputs from the players, accomplishes a specific task without leaking any information, and\nthen outputs the result to the respective player. Honest and dishonest players in the ideal\nworld are modeled by probabilistic poly-time machines, denoted by P\u0302 and P\u03020 , respectively.\nThe real world captures the actual protocol \u03a0, consisting of message exchange between the\nparties and local computations. Recall that real-world players are indicated by honest P and\ndishonest P0 .\nNow, the input-output behavior of F defines the required input-output behavior of \u03a0.\nIntuitively, if the executions are indistinguishable, security of the protocol in real life follows. In other words, a dishonest real-world player P0 that attacks protocol \u03a0 cannot achieve\n(significantly) more than an ideal-world adversary P\u03020 , attacking the corresponding ideal functionality F. We will make this aspect more formal in Section 3.6.\n\n2.4\n\nPrimitives\n\nIn the following, we will describe those two-party cryptographic primitives, along with some\nknown facts about them, that are relevant in the context of this work. Primitives are fundamental problems that are later used as basic building blocks in larger outer protocols.\nDiscussed on their own, primitives might seem to be somewhat limited but still constitute\nintriguing thought experiments. For clarification, an identification scheme, as discussed in\nSection 2.4.3, may commonly not count as a primitive per se, although it may well constitute a building block in a larger outer protocol. Our prime purpose for introducing it in the\ncontext of primitives, however, is the close relation to oblivious transfer in its construction.\n\n2.4.1\n\nCommitments\n\nCommitment schemes constitute a very important building block within cryptographic protocols. In fact, all our protocols proposed here implementing a wide range of cryptographic\ntasks, make use of various types of commitment schemes, which may indicate the significance\nof the construction. Commitments can be realized with classical schemes or through quantum communication. Here, we will only discuss and construct commitments from classical\ncrypto schemes, but with a strong requirement of quantum-computational security.\nIntuitively, a commitment scheme allows a player to commit to a value while keeping it\nhidden (hiding property), yet preserving the possibility to reveal the value fixed at commitment time later during the so-called opening phase (binding property). More formally, a basic\ncommitment scheme commit (m, r) takes a message m and some random variable r as input.\n\n17\n\n\f18\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\nDepending on the respective scheme, the message m can be a single bit (bit commitment) or\na bit sequence (string commitment). The length of the randomness r is polynomial in the\nsecurity parameter. It is also possible to construct a so-called keyed commitment schemes of\nthe form commit K (m, r) , which takes key K as additional input. The most common way of\nopening commitment commit (m, r) to reveal the committed message m when time is ripe,\nis to send values m and r in plain, so that the receiver of the commitment can check its\nvalidity. In Chapter 9, we will change this way of opening a commitment, due to the special\nrequirements of the particular construction there.\nThe hiding property is formalized by the non-existence of a distinguisher able to distinguish with non-negligible advantage between two commitments, i.e., we have indistinguishability between two commitments with commit (m1 , r1 ) \u2248 commit (m2 , r2 ) . The binding\nproperty is fulfilled, if it is infeasible for a forger to open a commitment to more than one\nvalid value, i.e., we have commit (m1 , r1 ) 6= commit (m2 , r2 ) for m1 6= m2 . Each property,\nhiding and binding, can be satisfied unconditionally or subject to a complexity assumption.\nThe ideal case of unconditionally secure commitments, i.e. unconditionally hiding and unconditionally binding at the same time, is impossible. Consequently, we have to decide on one\nof the two flavors of commitment schemes, namely unconditionally hiding and computationally binding or unconditionally binding and computationally hiding.6 For completeness, it is\nworth noting that the same applies in quantum cryptography [May97, LC97], where perfect\ncommitments can only be achieved when assuming some restrictions on the adversary, for\ninstance, the BQSM-model [DFSS05, DFR+ 07].\nIn the context of oblivious transfer (OT; see Section 2.4.2), we know that a classical\ncommitment does not imply classical OT without any additional requirement (such as key\nagreement). In contrast, a classical commitment implies quantum OT, which is all the more\ninteresting as OT is complete for secure two-party computation. This implication in the\nquantum case was realized in [CK88] and proven partially in [Yao95, May96, CDMS04]. We\nwill give the first full proof in Section 6.1.\nCommitments are equivalent to one-way functions, i.e., a function f : {0, 1}\u2217 \u2192 {0, 1}\u2217\nfor which it is easy to compute f (x), given x. But given only y = f (x) where x is random, it is computationally infeasible in poly-time to compute any element in f \u22121 (y). Thus,\nfrom an appropriate one-way function, secure against quantum adversaries, we can construct\nquantum-secure commitment schemes (e.g. [Nao91]). Bit commitments, in turn, imply a\nquantum-secure coin-flip, which we will show in Chapter 8. Naturally, the hiding, respectively binding, property holds with unconditional security in the classical and the quantum\nsetting, if the distinguisher, respectively the forger, is unrestricted with respect to his (quantum) computational power. Recall that in case of a poly-time bounded classical distinguisher,\nrespectively forger, the commitment is computationally hiding, respectively binding. The\ncomputationally hiding property translates to the quantum world by simply allowing the\ndistinguisher to be quantum. However, the case of a quantum forger cannot be handled in\nsuch a straightforward manner, since the commonly used classical proof technique relies on\nrewinding the possibly dishonest committer, which is in general prohibited by the laws of\nquantum mechanics.\n6\n\nNote that certain applications-beyond the scope of this work-have computational security simultaneously for both properties hiding and binding.\n\n\f2.4. PRIMITIVES\nAnother restriction on rewinding occurs when committing to a string instead of a single\nbit. Solutions for proving string commitments secure are known for the classical case, but\nthey cannot be adapted to the quantum world. Thus, solutions for quantum-secure constant\nround coin-flipping are yet to come (see Chapter 9 and also Section 2.4.4).\n\n2.4.2\n\nOblivious Transfer\n\nAs already indicated, another highly relevant primitive in cryptography is oblivious transfer,\ncommonly abbreviated by OT. Interestingly, the basic idea for OT was first proposed by\nWiesner in the context of quantum cryptography, where he suggests conjugate coding as \"a\nmeans for transmitting two messages either but not both of which may be received\" [Wie83,\np. 79]. OT as a cryptographic concept was then introduced by Rabin (Rabin\u2013OT in [Rab81])\nand Even, Goldreich, and Lempel (1\u20132 OT in [EGL85]). OT is a complete cryptographic\nprimitive, i.e., it is sufficient for secure two-party computation [Kil88], meaning that secure\n1-2 OT allows for implementing any cryptographic two-party functionality.\nIn this work, we are mainly interested in 1\u20132 OT ` , i.e. one[message]-out-of-two[messages]\noblivious transfer, with message length `. In an 1\u20132 OT ` protocol, the sender sends two `-bit\nstrings s0 and s1 to the receiver. The receiver can choose which string to receive, i.e. sc\naccording to his choice bit c, but does not learn anything about the other message s1\u2212c . At\nthe same time, the sender does not learn c, i.e., he does not learn which string the other\nparty has chosen.\nAs in the classical case, quantum OT cannot be implemented without any additional restrictions, such as bounded quantum memory in the BQSM [DFSS05,DFR+ 07]. However, in\ncontrast to classical OT, quantum OT reduces to classical commitment, as already discussed\nbefore (more in Section 6.1).\nRand\u2013OT is a randomized variation of general 1\u20132 OT and essentially coincides, except that\nthe sender does not input the two messages himself, rather they are generated uniformly at\nrandom during the protocol (and then output to the sender). For completeness, we note\nthat Rabin\u2013OT is another slightly varied but equivalent version of 1\u20132 OT , where the sender\ntransmits a message s with probability 1/2. However, he remains oblivious about whether\nor not the receiver actually got s. Thus, Rabin\u2013OT can be seen as a secure erasure channel.\nWe conclude this introduction by mentioning two natural generalizations of 1\u20132 OT . First,\n1\u2013n OT allows the receiver to obtain exactly one element out of a set of n elements. This\napplication is similar to private information retrieval in database settings but constitutes a\nstronger notion than the latter, as it additionally requires that the user is oblivious to all\nother items (as in database privacy). An even further generalization is m\u2013n OT , in which\nthe receiver can choose a subset of m elements out of the entire set of size n. Interestingly,\n1\u2013n OT underlies the construction of a quantum identification scheme in [DFSS05], which\nexemplifies the significance of the primitive. More details on this transformation are given\nin Section 2.4.3.\n\n2.4.3\n\nPassword-Based Identification\n\nA password-based identification scheme (ID, in short) allows a user to identify himself to\na server by proving his knowledge of a previously agreed secret password. In addition, we\n\n19\n\n\f20\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\nwill put forward the following security requirement: Any party that is not in possession of\nthe valid password can (essentially) not succeed by any other means but trying to guess.\nThis means that a user without password-or in other words, a user who pretends to be\nsomeone else-cannot delude the server with a probability that exceeds the probability of\nguessing the respective password. Similarly, the server can only guess a user's password\nand then learn whether the guess is correct or not-but no information beyond that. This\nin particular implies that the same password may be safely reused in further runs of the\nprotocol. Furthermore, our aim is to develop a scheme that tolerates a possibly non-uniform\npassword, or in short, a realistic user-memorizable password (such as a PIN code) without\njeopardizing security.\nFor reasons of their significance in any authenticated set-up, a wide range of classical\nand quantum ID-schemes can be found in the literature (see Section 6.2). Here, we will\nhowever focus on the quantum identification scheme, proposed in [DFSS05] and proven secure\nagainst any dishonest server with bounded quantum storage. Interestingly, in the context of\nprimitives, it is constructed out of an extension of a randomized 1\u20132 OT ` to a randomized\n1\u2013n OT ` . We will briefly sketch the intuitive idea here: Recall that such a 1\u2013n OT ` supplies the\nuser with n random `-bit strings but yields only one of the strings on the server's side. Such a\nscheme can then be used for the purpose of identification, when the server \"chooses\" the one\nspecific string indexed by the password, and the user proves which of the n strings obtained\nis the one with indices matching the password. Note that this last step of comparison must\nbe secured by another cryptographic technique such as a hash-function and the strings must\nhave large Hamming distance, which is not covered by the OT application itself. However,\nby the nature of secure OT, a dishonest user does not gain any information on the server's\nchoice and thus, does not know which string is the one getting accepted. A dishonest server\ncan likewise not do better than guessing a choice, and so the string he later receives from the\nuser is most probably random to him and hence, contains no information on the password.\nWe want to stress again that for simplicity, we skip many subtle but important details of the\nfinal ID-scheme as well as the means regarding better efficiency. More details are given in\nSection 6.2, where we propose an extension of the scheme towards higher and more diverse\nsecurity.\n\n2.4.4\n\nCoin-Flipping\n\nTrue randomness is a crucial ingredient in cryptographic applications. Therefore, coinflipping (or coin-tossing) is yet another essential primitive in this work. Secure coin-flipping\nallows two parties to agree on a uniformly random bit in a fair way, which means that neither\nparty can influence the value of the coin to his advantage. Intuition suggest that this should\nbe easily obtainable for an actual coin-toss if the parties met, flipped a coin together and\nsimply looked at the outcome. Now, we want to achieve a similar fairness even when the parties are communicating over a distance. This problem was first formalized in cryptographic\nterms by Blum as coin-flipping by telephone [Blu81].\nAn ideal coin-flip can be modeled as follows: Each player inputs a bit of his choice,\nindependently of each other, and the box then outputs the exclusive disjunction of the two\nbits as the coin. When implementing the primitive however, we must consider that one party\nmust make a first move during communication, and therefore the other one may choose his\n\n\f2.4. PRIMITIVES\nbit accordingly. The most straightforward way to achieve fairness also over a distance is by\nbit commitments as follows. The first player chooses a random bit x1 and commits to it, the\nother one then sends his bit x2 in plain, then the commitment is opened, and the resulting\ncoin is x1 \u2295 x2 . Thus, bit commitment implies secure coin-flipping, since the first player is\nbound to his bit, but can still keep it hidden until the second player makes his move.\nSecure implementations for coin-flipping have been proposed also by means of quantum\ncommunication. For instance, solutions for a strong coin-flip with a potential, optimal coin\nbias of approx. 0.2 and for the weaker notation with arbitrary small bias. Note that in the\nquantum literature, \"strong\" or \"weak\" indicates weather the dishonest party cannot bias\nthe coin more than specified or the dishonest party can influence the coin entirely towards one\noutcome but only by the specified bias towards the other value, respectively (see e.g. [Weh08]\nfor an overview). We want to stress that throughout this work, we use the (intuitive) literal\ninterpretation of a \"weak\" and \"strong\" coin, indicating its degrees of security.\nWe are interested in the standard coin-flipping protocol with classical messages exchange,\nbut where the adversary is assumed to be capable of quantum computing. Even when\nbasing the embedded commitment on a computational assumption that withstands quantum\nattacks, the security proof of the entire coin-flipping and its integration into other applications\ncould previously not be naturally translated from the classical to the quantum world. We\nwill propose a solution based on Watrous' quantum rewinding in Chapter 8. Certainly, the\ndesirable protocol would be constant round, meaning that a string of coins can be flipped in a\nconstant number of rounds, instead of having the number of rounds depending on the number\nof coins. Towards this aim, we present a framework that transforms weaker demands on the\ncoins into very strong properties, with the final result of a fully simulatable coin-flipping\nprotocol, secure against poly-sized quantum adversaries, which can be implemented in the\nplain model from scratch (see Chapter 9). On a side note, implementing constant round\ncoin-flipping is an open problem in the quantum setting. Interestingly, the first quantum\napplication, namely quantum key distribution (QKD), enables two parties to produce a secret\nrandom bit-string (which is then used as a key in symmetric crypto-systems). However,\nby assumption on its purpose, the QKD-setting does not have to hold against an internal\ndishonest party. The requirements for secure coin-flipping are much stronger in this sense,\nand it turns out that in a typically QKD-protocol, the key could theoretically always be\nbiased by one of the parties.\nWe conclude here by stressing the importance of truly random, fair coins for cryptographic purposes. Namely, by producing a string of coins, the communicating parties can\ninteractively generate a common random string from scratch. The generation can then\nbe integrated into other (classical or quantum) cryptographic protocols that work In the\ncommon-reference-string-model. This way, various interesting applications can be implemented entirely in a simple manner without any set-up assumptions. We will discuss some\nexamples thereof in Chapter 10.\n\n2.4.5\n\nZero-Knowledge\n\nInformally, a zero-knowledge (ZK) proof system is \"both convincing and yet yield nothing\nbeyond the validity of the assertion\" [Gol10][p. 1]. Thus, only this one bit of knowledge\nis communicated from prover to verifier. Such building blocks are typically used in outer\n\n21\n\n\f22\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\ncryptographic protocols for enforcing that potentially dishonest players behave according to\nthe protocol specification, namely, they are required to prove in zero-knowledge the correctness of a secret-based action without leaking the secret. As examples, we want to mention\nzero-knowledge proofs for Graph Isomorphism and Graph 3-Coloring, proven secure in the\nclassical and quantum setting by [GMW91] and [Wat09], respectively. For a survey about\nzero-knowledge, we refer e.g. to [Gol01, Gol02, Gol10].\nOn a very intuitive level, such proof systems typically proceed in several rounds of a\nprotocol. In each round, the prover must answer a challenge from the verifier which he does\nnot know beforehand. In order to be able to answer all challenges in all rounds, the prover\nmust know whatever he claims. We differentiate between proofs and proofs of knowledge.\nThe respective definitions are given by two properties, which vary and are informally stated\nbelow. Loosely speaking, the distinction between proofs and proofs of knowledge is drawn\nin the content of the assertion: In a proof the prover claims the existence of an object. In\ncontrast, in a proof of knowledge, he claims knowledge of an object. We stress that a proof\nof existence cannot be modeled via an ideal functionality in the natural way, whereas a proof\nof knowledge can. The third property of zero-knowledge does not differ in both systems.\nZero-Knowledge Proofs. Informally, a zero-knowledge proof for set L on common\ninput x yields no other knowledge than the validity of membership x \u2208 L, which holds if\nthe following three requirements are satisfied. First, if the statement is true, i.e. x \u2208 L,\nan honest verifier will be convinced of this fact by an honest prover, and thus accept the\nproof (completeness). This holds with overwhelming probability. Second, if the statement\nis false, i.e. x \u2208\n/ L, a dishonest prover cannot convince an honest verifier of the contrary,\nexcept with low probability (soundness). And last, if the statement is true, a dishonest\nverifier learns nothing beyond this fact (zero-knowledge). The latter is shown by formally\narguing that, given only the statement, a simulator can (by itself) produce a transcript that\nis indistinguishable from a real interaction between honest prover and dishonest verifier. The\ndegree of indistinguishability then specifies the flavor of zero-knowledge. Note also that the\nfirst two properties are general aspects of interactive proof systems. However, in this context,\nthey are defined in probabilistic terms, and we require the completeness and the soundness\nerror to be negligible, at least after sufficient (sequential) repetitions.\nThe notion of (interactive) zero-knowledge first appeared in [GMR85] by Goldwasser et\nal. Then in [GMW86], it was shown that ZK proofs exist for any N P-language under the\nassumption that commitments exist, which in turn is implied in the existence of one-way\nfunctions [Nao91, HILL99].7 Blum et al. showed that the interaction between prover and\nverifier in any ZK proof can be replaced by sharing a short common reference string available\nto all parties from the start of the protocol [BFM88]. Note that a reference string is a\nweaker requirement than interaction. The requirement for non-interactive zero-knowledge\nis simpler than for general zero-knowledge, since all information is communicated monodirectional from prover to verifier. The verifier does not influence the distribution in the\n7\n\nAs in standard literature, N P (non-deterministic polynomial time) refers to the set of all decision problems, where the \"yes\"-instances can be recognized in polynomial time by a non-deterministic Turing machine.\nThe class P (deterministic polynomial time) contains all decision problems which can be solved by a deterministic Turing machine in polynomial time. Note that every set in P has a trivial zero-knowledge proof in\nwhich the verifier proves membership by himself.\n\n\f2.4. PRIMITIVES\nreal world. Thus, in the ideal world, we require a simulator that only produces output that\nis indistinguishable from the real distribution of the output. We will use such a generic\nconstruction in Section 10.1, where we show a simple transformation from non-interactive\nzero-knowledge to interactive zero-knowledge in the quantum world.\n\nZero-Knowledge Proofs of Knowledge. Intuitively, a zero-knowledge proof of knowledge for relation R with common instance x and prover's private witness w yields no other\nknowledge to the verifier than the validity of (x, w) \u2208 R. Especially, it holds that witness\nw is not leaked. This is formulated by the following three requirements. First, if the prover\nfollows the protocol and knows w, such that (x, w) \u2208 R, he will always convince the verifier.\nNote that this holds with probability 1, or in other words, completeness is defined deterministically rather than probabilistically. Second, if the (possibly dishonest) prover can with\nwhatever strategy convince the verifier to accept, then he knows w. This holds, except with\nprobability determined by the knowledge error, which again must be negligible in the length\nof the challenge (special soundness). Note here that in the context of machines, we interpret\nknowledge via behavior. In more detail, to define knowledge, we specify a knowledge extractor for which it holds that if the extractor can extract w from the prover, for instance, by\nsimulating two accepting conversations via rewinding, we say that the prover knows w. This\nidea prevents the prover to output the knowledge itself, and therewith, the last requirement,\ni.e. the property of zero-knowledge, capturing that a dishonest verifier learns (essentially)\nnothing, remains unchanged from the description above.\nThe concept of proofs of knowledge was first introduced also in [GMR85] and formulated\nin greater detail in [BG92]. We will propose a quantum-secure zero-knowledge proof of\nknowledge based on simulatable witness encoding in Section 10.2.\n\n\u03a3-protocols. A \u03a3-protocol is a special case of the above, in that it is an honest-verifier\nzero-knowledge proof of knowledge. Such a protocol is of three-move-form, starting with the\nprover's message a\u03a3 , followed by the verifier's challenge c\u03a3 , and concluded with the prover's\nresponse z\u03a3 . Its name originates from this form, as the \"\u03a3\" visualizes first the common\ninput x, and then the flow of communication (from top to bottom). The flavor of honestverifier zero-knowledge (HVZK), although weaker than general zero-knowledge, still allows\nfor useful building blocks, which would be impossible to implement with a stronger notion in\ncertain settings. As the name suggests, it captures a scenario in which, instead of covering\nany feasible verifier strategy, the verifier behaves honest (or rather honest-but-curious), and\nmaintains and outputs a transcript of the entire interaction.\nBy its nature of being a proof of knowledge, special soundness holds for a \u03a3-protocol,\nand therewith, that from two accepting conversations with different challenges a w can be\nextracted such that (x, w) \u2208 R. We will use an honest-verifier simulator as a\u0001 black-box in\nSections 4.1.4 and 7.2 to receive, on input x, a valid conversation a\u03a3 , c\u03a3 , z\u03a3 . Intuitively,\nthe purpose of using \u03a3-protocols then lies in the fact that only one valid conversation could\nhave been produced unequivocally without knowing the witness.\n\n23\n\n\f24\n\nCHAPTER 2. CRYPTOGRAPHIC TOOLBOX\n\n2.4.6\n\nSecure Secret Sharing\n\nSecure secret sharing refers-as the name suggests-to a method for distributing one secret\nin several shares amongst the players. The secret can only be reconstructed by combining\na sufficient number of shares (threshold), but any individual share or any number of shares\nbelow the threshold does not contain any useful information on its own.\nClassical secret sharing schemes were introduced independently in [Sha79] and [Bla79],\nand quantum secret sharing was first proposed in [HBB99, CGL99]. Classical secret sharing\nis an extremely powerful primitive and is widely used in multi-party computation. We will\nuse secret sharing as a building block for equipping our mixed commitments with trapdoor\nopenings (Section 7.3). This extended construction will then constitute one essential step in\nbootstrapping fully simulatable coin-flipping from weak coin-flipping (Chapter 9).\n\n\f3\nchapter\n\nQuantum Tools\nQuantum refers to a discrete unit of a physical quantity at the smallest scale, for which\nquantum mechanics constitutes the underlying mathematical framework. For the main part\nof this thesis, we will work with abstract mathematical objects, as our focus lies on theory,\nas opposed to realizing, for instance, a qubit as an actual physical system such as a \"light\nquantum\", encoded by polarization of a photon.\nIn this chapter, we give an overview of the aspects of quantum mechanics, essential for\nthis work. The connection between the mathematical description and physical reality is best\nreflected in the postulates of quantum mechanics, which are covered in Section 3.1. This\nsection is also intended to fix the terminology we will use later on. Next, we will describe\ndistance measures (Section 3.2) and uncertainty measures (Section 3.3). Then we will discuss\nthe concept of information reconciliation and privacy amplification (Section 3.4) as well as the\nproblems of rewinding in general quantum systems and the technique of quantum rewinding\n(Section 3.5). Finally in Section 3.6, we will introduce the definitions of security, which\nunderlie all our following main results.\n\n3.1\n\nPostulates and Terminology\n\nWe now briefly introduce the field of quantum mechanics on the basis of its postulates, capturing quantum-physical events and processes in mathematical formalisms. We will closely\nfollow the descriptions given in [NC00] and refer thereto for more details.\nDescription of an isolated system. A general d-dimensional quantum state, where\nd \u2208 N, is described mathematically by a positive semi-definite density matrix \u03c1 defined in\nthe complex Hilbert space of dimension d, i.e., a complete inner product space denoted by\nHd . The standard notation to write a pure quantum state is represented in Dirac's bra-ket\nnotation by a vector as |\u03a8i \u2208 Hd , and is given, for complex coefficients \u03b1i \u2208 C, as\n|\u03a8i =\n\nd\u22121\nX\n\n\u03b1i |ii .\n\n(3.1)\n\ni=0\n\nThe orthonormal basis is denoted by the set {|0i, . . . , |d \u2212 1i}, i.e. the linearly independent\nspanning set of mutually orthogonal unit vectors. The form of a pure state as given in\nEq. (3.1) as linear combinations nicely reflects an interference phenomenon unique to the\nquantum world, namely the superposition of basis states. Informally speaking, it highlights\n\n\f26\n\nCHAPTER 3. QUANTUM TOOLS\nthe fact that a quantum particle is in all possible basis states at once. And thus, a complete\ndescription of such a particle must include the description of every possible state as well as\n2 for each respective |ii. By\nthe probability of the particle being in that state, given by |\u03b1i |P\nthe normalization condition, the total sum of probabilities, i.e. i |\u03b1i |2 , equals 1.\nA mixed quantum state is a statistical ensemble of pure states {\u03bbi , |ii}, where again {|ii}i\nforms a basis, and can be represented as density matrix by\nX\n\u03c1=\n\u03bbi |iihi| ,\n(3.2)\ni\n\nwith eigenvalues \u03bbi and eigenstates |ii. Again, it holds that the system isP\nin state |ii with\nprobability \u03bbi , where \u03bbi \u2265 0 and, by the normalization condition, we have i \u03bbi = 1.\nMore specifically, a qubit is a two-dimensional pure quantum state living in H2 . The\ncomputational basis (also called + -basis, standard basis, canonical basis, or rectilinear basis)\nis defined by the pair {|0i, |1i}, where\n\u0012 \u0013\n\u0012 \u0013\n1\n0\n|0i =\nand |1i =\n.\n(3.3)\n0\n1\nThe pair {|+i, |\u2212i} denotes the diagonal basis (also named the \u00d7-basis or Hadamard basis),\nwhere\n\u221a\n|+i = (|0i + |1i)/ 2 and\n(3.4)\n\u221a\n|\u2212i = (|0i \u2212 |1i)/ 2 .\n(3.5)\nAnother common denotation is {|0i+ , |1i+ } for the computational basis and {|0i\u00d7 , |1i\u00d7 }\nfor the diagonal basis. We use {+, \u00d7} as shorthand to refer to the set of these two most\ncommonly used conjugate bases.\nEvolution in a closed system. The dynamics that apply in a closed systems as described above are captured in the description of a unitary transform U. U is unitary, if it holds\nthat U\u2020 U = I. Unitary operations preserve inner products between vectors, which yields their\nmore intuitive expression in outer product representation as follows. Define |outi i = U|ini i\nto be the transformation from \"input\" basis {|ini i}i into \"output\" basis {|outi i}i . Then,\nX\nU=\n|outi ihini | .\n(3.6)\ni\n\nFrom the requirement of unitarity, it is evident that such a transformation must be reversible.\nThat means that undoing operation U on |ini corresponds to applying its inverse U\u2020 on |outi\nand recreates |ini.\nFor completeness we note that, although part of this postulate, we will not consider the\nrefined version of time evolution, defined by the Schr\u00f6dinger equation.\nIn the more specific case of single qubits, the transformation from the computational\nbasis to the diagonal basis, and vice versa, is obtained by applying the Hadamard operation\nH, where\n\u0012\n\u0013\n1\n1\n1\nH= \u221a\n,\n(3.7)\n2 1 \u22121\n\n\f3.1. POSTULATES AND TERMINOLOGY\n\n27\n\nand note that H = H\u2020 . The two-dimensional Identity operator I is represented by matrix\n\u0012\n\u0013\n1 0\nI=\n,\n(3.8)\n0 1\nother important operations are described by the Pauli matrices\n\u0012\n\u0013\n\u0012\n\u0013\n0 1\n1\n0\n\u03c3X =\nand \u03c3Z =\n.\n1 0\n0 \u22121\n\n(3.9)\n\nOperator \u03c3X describes a bit-flip. Matrix \u03c3Z defines a phase-flip operation, adding a phase\nfactor of -1 for non-zero entries, and otherwise leaving the bit invariant. For completeness,\nwe also explicitly state\n\u0012\n\u0013\n0 \u2212i\n\u03c3Y =\n,\n(3.10)\ni\n0\nbut note that \u03c3Y = i\u03c3X \u03c3Z .\nThe controlled-NOT operation CNOT is a combination of I and \u03c3X and is defined for two\ninput qubits as\n\uf8eb\n\uf8f6\n1 0 0 0\n\uf8ec 0 1 0 0 \uf8f7\n\uf8f7\nCNOT = \uf8ec\n(3.11)\n\uf8ed 0 0 0 1 \uf8f8.\n0 0 1 0\nThus, if the control qubit is 1, CNOT flips the target qubit. Otherwise, I is applied to the\ntarget qubit. Or in other words, the value of the second output qubit corresponds to the\nclassical exclusive disjunction (XOR).\nQuantum measurements. To extract information of a quantum system, it must be measured. The following descriptions of measurements illustrate the irreversible nature of quantum measurements in general, and therewith, the disturbance caused by observation. In\nother words, some information about a state before measurement is lost after measurement.\nThis fact stands in sharp contrast to the reversible transformations within a closed system\nas described previously.\nQuantum measurements are described by a collection of measurement operators M =\n{Mm }m , where m denotes the measurement outcome. The probability Pr [m] to obtain outcome m when measuring state |\u03c8i with M is given by\nPr [m] = h\u03c8|M\u2020 m Mm |\u03c8i ,\n\n(3.12)\n\nP\nP\nwith completeness equation m M\u2020 m Mm = I, or equivalent, m h\u03c8|M\u2020 m Mm |\u03c8i = 1. Conditioned on having obtained m, the post-measurement state must be renormalized to\nMm |\u03c8i\n\u03c1m = q\n.\n\u2020\nh\u03c8|Mm Mm |\u03c8i\n\n(3.13)\n\nWe also want to stress that quantum measurements do not necessarily commute, that means\nthat different measurement orders may yield different measurement outcomes.\n\n\f28\n\nCHAPTER 3. QUANTUM TOOLS\nIf all operators Mm are orthogonal\nprojectors, denoted by Pm = M\u2020m Mm , we call the meaP\nsurement projective and M = m mPm its observable. The respective probability and postmeasurement state are then given by\nPr [m] = h\u03c8|Pm |\u03c8i\n\n(3.14)\n\nP |\u03c8i\npm\n,\nPr [m]\n\n(3.15)\n\nand\n\nMeasuring in basis {|mi}m means to apply a projective measurement defined by projectors\nPm = |mihm|.\nWhen only specifying mappings Em = M\u2020m Mm , we obtain an expression in the positive\noperator-valued measure formalism (POVM), similar to Eq. (3.12), namely,\nPr [m] = tr(Em \u03c1) ,\n\n(3.16)\n\nP\nwhere E = {Em }m is the POVM, denoting the set of Hermitian operators such that m Em =\nI and Em \u2265 0. This formalism is simpler than the general expressions in Eqs. (3.12)\nand (3.13), but sufficient for many purposes, as it yields simple measurement statistics.\nIt also becomes evident here that for a complete description of measuring the observable of\na quantum system, the formulation of a quantum system must include uncertainty in that\nthe probability for all possible outcomes must be encoded in it.\nAgain more specifically, measuring a single qubit in the computational or diagonal basis\nmeans applying the measurement described by projectors |0ih0| and |1ih1| or projectors |+ih+|\nand |\u2212ih\u2212|, respectively. We want to point out a very important consequence of using such\nconjugate bases (also called mutually unbiased bases). Measuring a qubit, prepared in one\nof two conjugate bases, is equivalent to distinguishing between two non-orthogonal quantum\nstates. Non-orthogonal states however cannot be distinguished (with arbitrary precision),\nwhich can be derived from the above formalisms. Thus, any measurement must destroy\ninformation and therewith disturb the system-except, of course, a measurement of a basis\nstate in its own basis. In other words, a state with fixed measurement outcome in one basis\nimplies maximal uncertainty about the measurement outcome in the other basis.\nComposite systems. The joint state of a multipartite system in H2\u2297n\nn is given by the tensor\nproduct |\u03a8i1 \u2297 * * * \u2297 |\u03a8in . For simplicity, we consider a bipartite joint state \u03c1AB \u2208 HA \u2297 HB\nshared between Alice and Bob, i.e.,\nX\nX\n\u03c1AB = |\u03a8iA |\u03a8iB =\n\u03b1i |iiA\n\u03b2j |jiB ,\n(3.17)\ni\n\nj\n\nwith orthonormal bases {|iiA }i for HA and {|jiB }j for HB . The form of the state in Eq. (3.17)\nindicates a product state, which is separable, since it can be decomposed into two definite\npure states.\nFor string x = (x1 , . . . , xn ) \u2208 {0, 1}n , encoded in bases \u03b8 = (\u03b81 , . . . , \u03b8n ) \u2208 {+, \u00d7}n , we\nwrite |xi\u03b8 = |x1 i\u03b81 \u2297 * * * \u2297 |xn i\u03b8n . For S \u2286 {1, . . . , n} of size s, we define x|S \u2208 {0, 1}s and\n\n\f3.2. DISTANCE, DISTINGUISHABILITY, AND DEPENDENCE\n\n29\n\n\u03b8|S \u2208 {+, \u00d7}s to be the restrictions (xi )i\u2208S and (\u03b8i )i\u2208S , respectively. If all qubits are encoded\nin the same basis \u03b8 \u2208 [+, \u00d7], then |xi\u03b8 = |x1 . . . xn i\u03b8 .\nIn contrast to the product states of Eq. (3.17), we can also have pure composite systems\nin some entangled states of the form\n\u03c1AB =\n\nX\n\n\u03b3ij |iiA |jiB\n\n(3.18)\n\ni,j\n\nwith \u03b3ij 6= \u03b1i \u03b2j . Entangled components mean that they can only be described with reference\nto each other. Special cases thereof are the maximally entangled EPR-pairs (or Bell states):\n|\u03a6i00\n|\u03a6i11\n|\u03a6i01\n|\u03a6i10\n\n\u221a\n= (|00i + |11i)/\u221a2 ,\n= (|00i \u2212 |11i)/\u221a2 ,\n= (|01i + |10i)/\u221a2 , and\n= (|01i \u2212 |10i)/ 2 .\n\n(3.19)\n\nImportant for cryptographic purposes are the following observations. First, as Eq. (3.18)\nindicates, upon observing one of the two particles, entangled in one single state, the system\nwill collapse, and thus, the other particle will at least partially be determined-even though\nthe particles may be spatially separated. On a side note, the outcome of the first measurement\nis random, and therewith the state, to which the composite system collapses into, is so as\nwell. Hence, information (i.e. a non-random message) cannot be transmitted faster than\nthe speed of light by \u221a\nshared entanglement. \u221aSecond, entanglement is basis-independent, e.g.\n|\u03a6i00 = (|00i + |11i)/ 2 = (|++i + |\u2212\u2212i)/ 2 . And last, if an entangled state \u03c1AB is pure,\nthen it cannot be entangled with any other state, for instance, one in Eve's hands, so it\nholds that \u03c1ABE = \u03c1AB \u2297 \u03c1E . Thus, under the assumption of it being pure, entanglement is\nmonogamic.\nSubsystems of a composite system can be described by\u0001the reduced density operator computed by the partial trace. Let \u03c1AB = |a1 iha2 | \u2297 |b1 ihb2 | and assume that only subsystem\nA is accessible. Then, we have\ntrB (\u03c1AB ) = hb2 |b1 i |a1 iha2 | .\n\n(3.20)\n\nTrivially, when tracing system B out of a product state, we have \u03c1AB = trB (\u03c1A \u2297 \u03c1B ) = \u03c1A .\nHowever, the reduced density operator in an entangled EPR-pair is a complete mixture with\ntrace distance 1/2 (see next Section 3.2). Thus interestingly, the joint state of two entangled\nqubits is pure and can be completely determined, yet its subsystems alone are completely\nmixed.\n\n3.2\n\nDistance, Distinguishability, and Dependence\n\nWe will need various measures to determine the distance between classical and quantum\nstates. Distance measures possess an important operational meaning in the context of distinguishability between two systems.\n\n\f30\n\nCHAPTER 3. QUANTUM TOOLS\nDistance. For classical information, the distance between two binary strings of equal\nlength can be measured by means of the Hamming distance dH , which is the number of\npositions at which the strings differ, or more formally, for strings x, y \u2208 {0, 1}n , we have\ndH (x, y) := |{i : xi 6= yi }| .\n\n(3.21)\n\nWe will also need the relative Hamming distance\nrH (x, y) :=\n\ndH (x, y)\n.\nn\n\n(3.22)\n\nFor completeness, we note that the Hamming weight wH is the Hamming distance to x from\nthe all-zero string (of same length), i.e. wH (x) := |{i : xi = 1}|.\nIn the classical world, the statistical or variational distance between two classical probability distributions P and Q over the same finite set X with events E \u2286 X is determined\nby\n\u0001\n1X\n\u03b4 P, Q :=\n|P (x) \u2212 Q(x)| = max |P (E) \u2212 Q(E)| .\n(3.23)\nE\n2\nx\u2208X\n\nA measure of proximity is given by the fidelity\nXp\n\u0001\nF P, Q :=\nP (x)Q(x) .\n\n(3.24)\n\nx\u2208X\n\nThe classical notions of distance and fidelity can be generalized to the distance and\nproximity of two quantum states \u03c1 and \u03c3. The quantum analogue to the classical distance\nin Eq. (3.23) is the trace distance, given as\n\u0001\n\u0001\n1\n\u03b4 \u03c1, \u03c3 := tr |\u03c1 \u2212 \u03c3| ,\n2\n\n(3.25)\n\n\u221a\nwhere |A| = A\u2020 A is the trace norm of any operator A. The notion of fidelity translates to\nquantum fidelity by\nq\n\u0001\n\u221a \u221a\nF \u03c1, \u03c3 := tr\n\u03c1 \u03c3 \u03c1.\n(3.26)\nThe relation between classical variational distance and quantum trace distance can be made\nmore explicit by\n\u0001\n\u0001\n\u03b4 \u03c1, \u03c3 = max \u03b4 E(\u03c1), E(\u03c3) ,\n(3.27)\nE\n\nwhere the maximum is taken over all POVMs E, and \u03c1, \u03c3 indicate the probability distributions\nobtained when measuring \u03c1 or\nP\u03c3 using E. Moreover,\nP it is worth pinpointing that, for mixtures\nof pure quantum states \u03c1 = i \u03bbi |iihi| and \u03c3 = i \u03b3i |iihi| with same orthonormal basis {|ii}i\nbut potentially different eigenstates \u03bbi and \u03b3i , the quantum measure naturally reduces to\nthe classical one between the eigenvalue distributions \u03bb = {\u03bbi }i and \u03b3 = {\u03b3i }i by\n\u03b4(\u03c1, \u03c3) =\n\n1 X\n1X\n1\ntr |\u03c1 \u2212 \u03c3| =\n(\u03bbi \u2212 \u03b3i )|iihi| =\n|\u03bbi \u2212 \u03b3i | = \u03b4(\u03bb, \u03b3) .\n2\n2\n2\ni\n\ni\n\n(3.28)\n\n\f3.2. DISTANCE, DISTINGUISHABILITY, AND DEPENDENCE\nA similar reduction can be obtained for the fidelity.\nTrace distance and quantum fidelity are, in general, equivalent concepts-but with partly\ndifferent characteristics and properties, so we will use one or the other, depending on the\nrespective context (see [FvdG99] or [NC00] for a more detailed discussion). However, they\nare closely related in that we have\n\u0001\n\u0001 q\n\u00012\n1 \u2212 F \u03c1, \u03c3 \u2264 \u03b4 \u03c1, \u03c3 \u2264 1 \u2212 F \u03c1, \u03c3 .\n(3.29)\nFor pure states \u03c1 = |\u03c8ih\u03c8| and \u03c3 = |\u03c6ih\u03c6|, expressions (3.25) and (3.26) simplify to\n\u0001\n\u0001 p\n(3.30)\n\u03b4 \u03c1, \u03c3 = 1 \u2212 |h\u03c8|\u03c6i|2 and F \u03b4, \u03c3 = |h\u03c8|\u03c6i| ,\nwhere the latter can be seen as transition probability. Furthermore, the fidelity measure for\na pure state \u03c1 = |\u03c8ih\u03c8| and an arbitrary quantum state \u03c3 is given by\n\u0001 p\nF \u03c1, \u03c3 = h\u03c8|\u03c3|\u03c8i ,\n(3.31)\nand shows that the square root of the overlap between the states determines the fidelity.\nDistinguishability. The importance of both quantum measures is due to their operational meaning of distinguishability. The fidelity \u0001can be seen as an \"upside down\" trace\ndistance in that the limits 0 and 1 in 0 \u2264 F \u03c1, \u03c3 \u2264 1 meaning perfectly distinguishable\n\u0001\nand perfectly indistinguishable, respectively. In contrast, the trace distance\n0 \u2264 \u03b4 \u03c1, \u03c3 \u2264 1\n\u0001\nincreases\n\u0001 for decreasing indistinguishability, such that we get \u03b4 \u03c1, \u03c3 = 0 for \u03c1 = \u03c3 and\n\u03b4 \u03c1, \u03c3 = 1 for \u03c1 orthogonal to \u03c3.\nComing back to Eq. (3.27) in this context, it is worth noting that the POVM E that\nachieves the maximum is the optimal POVM for distinguishing \u03c1 and \u03c3. Furthermore,\nwe want to single out two important\nof the trace distance. First, we\n\u0001 properties by means\n\u0001\nhave unitary invariance with \u03b4 \u03c1, \u03c3 = \u03b4 U\u03c1U\u2020 , U\u03c3U\u2020 , meaning that the distance between\nthe states does not change when a unitary operation U is applied to both of them. And\nsecond, any trace-preserving quantum\n\u0001 operation\n\u0001 T is contractive (monotonicity under quantum operations) with \u03b4 T(\u03c1), T(\u03c3) \u2264 \u03b4 \u03c1, \u03c3 . Informally, no physical process can achieve\nan increased distance, or in other words, no modification on the states can help to better distinguish two states.\nAn important\nspecial case relating the partial trace shows that\n\u0001\n\u0001\n\u03b4 trB (\u03c1AB ), trB (\u03c3AB ) \u2264 \u03b4 \u03c1AB , \u03c3AB , which again informally states that two systems are\nat least as hard to distinguish when only a part of them is accessible.\nTwo families of probability distributions {Pn }n\u2208N and {Qn }n\u2208N are called perfectly inp\ndistinguishable, denoted by P \u2248 Q, if their output distributions on each input are identical,\nnamely Pn = Qn for all n \u2208 N. In other words, an unbounded adversary cannot distinguish\nthe outcomes, which holds with probability 1. Relaxing this condition defines\nstatistical indis\u0001\ns\ntinguishability (P \u2248 Q), which holds if the statistical distance \u03b4 Pn , Qn is negligible (in the\nlength of the input). This covers the setting, in which an unbounded adversary\ncannot dis\u0001\ntinguish the outcomes, except with negligible probability. For \u03b4 Pn , Qn \u2264 \u03b5, and therewith,\nindistinguishability except with probability \u03b5, we also call the distributions \u03b5-close. Thus,\nperfect and statistical indistinguishability are defined in the information-theoretic sense and\nwe call the resulting security flavor unconditional.\n\n31\n\n\f32\n\nCHAPTER 3. QUANTUM TOOLS\nIn the computational setting, we require that the two distributions cannot be distinguished by any computationally efficient procedure. More formally, let\nPr [A(P (x)) = 1 | x \u2190 P ] denote the probability that an algorithm A is successful in that\nit outputs \"P\", if the input x comes from P , and analogue for Q. To claim computational\nc\nindistinguishability between P and Q, denoted by P \u2248 Q, for any probabilistic poly-time\nalgorithm A, it must hold that the (distinguishing) advantage adv, i.e.,\nadv(A) = | Pr [A(Pn ) = 1] \u2212 Pr [A(Qn ) = 1] | ,\nq\n\nis negligible in the length of the input. Quantum-computational indistinguishability (P \u2248 Q)\nis defined similarly for the case of a quantum algorithm A. In other words, (quantum)\ncomputational security holds with overwhelming probability against a poly-time (quantum)\nadversary.\nConsider a quantum algorithm consisting of a uniform family {Cn }n\u2208N of quantum circuits, which is said to run in polynomial time, if the number of gates of Cn is polynomial\nin n. Then, two families of quantum states {\u03c1n }n\u2208N and {\u03c3n }n\u2208N are called perfectly indis\u0001\np\ntinguishable with \u03c1 \u2248 \u03c3, if \u03b4 \u03c1n , \u03c3n = 0 in the case of unrestricted running time. We have\n\u0001\ns\nstatistical indistinguishability with \u03c1 \u2248 \u03c3, if \u03b4 \u03c1n , \u03c3n \u2264 \u03b5, for \u03b5 negligible in n, and without\nany restriction on the running time. Again, for \u03b4(\u03c1, \u03c3) \u2264 \u03b5, we call the quantum states\n\u03b5-close-or indistinguishable, except with probability \u03b5. Then, to prove sufficient closeness\nbetween an ideal system and the real state, we require \u03b5 to be negligible (in the security\nq\nparameter). Last, we have quantum-computationally indistinguishable, denoted by \u03c1 \u2248 \u03c3,\nif any polynomial-time quantum algorithm has negligible advantage \u03b5 of distinguishing \u03c1n\nfrom \u03c3n .\nDependence. We will often use upper case letters for random variables (for proofs) that\ndescribe respective values (in the actual protocol). Let PX denote the probability distribution\nof a classical random variable X \u2208 X over finite set X .\nLet\nX\n\u03c1X =\nPX (x)|xihx|\n(3.32)\nx\u2208X\n\ndenote the quantum representation of the classical random variable X. Let \u03c1xE denote a state\nin register E, depending on value x \u2208 X of random variable X over X with distribution PX .\nThen, from the view of an observer, who holds register E but does not know X, the system\nis in state\nX\n\u03c1E =\nPX (x)\u03c1xE ,\n(3.33)\nx\u2208X\n\nwhere \u03c1E depends on X in the sense that E is in state \u03c1xE exactly iff X = x.\nIndependence in a bipartite joint state with classical and quantum parts can be expressed\nas\nX\n\u03c1XE =\nPX (x)|xihx| \u2297 \u03c1xE .\n(3.34)\nx\u2208X\n\n\f3.3. ENTROPIES\n\n33\n\nP\nSuch a state is formally called a cq-state. Note that naturally, \u03c1E = trX (\u03c1XE ) = x PX (x)\u03c1xE ,\nand that the notation can be extended to states depending on more classical variables, i.e.\nccq-states, cccq-states etc. Full independence of classical and quantum parts within one state\nis given iff \u03c1xE = \u03c1E for any x and therewith \u03c1XE = \u03c1X \u2297 \u03c1E . This means in particular that\nno information on X is gained by observing only \u03c1E . However, full independence is often\ntoo strong a requirement. For our purposes, it suffices that the real state is close to the ideal\nsituation.\nLast in this context, we want to express that a random variable X is independent of\na quantum state \u03c1E when given a random variable Y . Independence in this case means\nthat, when given Y , the state E gives no additional information on X. Yet another way to\nunderstand conditional independence is that E is obtained from X and Y by solely processing\nY . Formally, adopting the notion introduced in [DFSS07], we require that \u03c1XY E equals\n\u03c1X\u2194Y \u2194E , where the latter is defined as\nX\n\u03c1X\u2194Y \u2194E :=\nPXY (x, y)|xihx| \u2297 |yihy| \u2297 \u03c1yE ,\n(3.35)\nx,y\n\nwhere \u03c1yE =\nall x and y.\n\n3.3\n\nx,y\nx PX|Y (x|y)\u03c1E .\n\nP\n\ny\nIn other words, \u03c1XY E = \u03c1X\u2194Y \u2194E precisely if \u03c1x,y\nE = \u03c1E for\n\nEntropies\n\nEntropies are useful measures of \"information, choice and uncertainty\". We will give a brief\nrecap here, only covering the concepts most important in the context of this work. For a\ngeneral introduction we refer to e.g. [NC00, Ren05, Sch07] for more details and proofs.\nThe Shannon entropy [Sha48]\n!\nX\nX\nH(X) := \u2212 log\nPX (x) = \u2212\npx log px\n(3.36)\nx\n\nx\n\napplies to a classical probability distribution PX over X with probabilities px , and as such\nquantifies the information gain on average after learning X, or complementary, the average\nuncertainty before learning X.1 The binary version thereof, namely the binary entropy\nfunction, is defined for the case of two possibilities as\n\u0001\nh(\u03bc) := \u2212 \u03bc log(\u03bc) + (1 \u2212 \u03bc) log (1 \u2212 \u03bc)\n(3.37)\nwith 0 \u2264 \u03bc \u2264 12 . We will use that, given the ball of all n-bit strings at Hamming distance at\nmost \u03bcn from x, denoted as B\u03bcn (x), we have that |B\u03bcn (x)| \u2264 2h(\u03bc)n .\nFor a cryptographic scenario with not necessarily independent repetitions, its generalization is given by the R\u00e9nyi entropy [R\u00e9n61] of order \u03b1 as\n!\nX\n1\nPX (x)\u03b1\n(3.38)\nH\u03b1 (X) =\nlog\n1\u2212\u03b1\nx\u2208X\n\n1\n\nNote that the logarithmic base is 2 for a result in bits.\n\n\f34\n\nCHAPTER 3. QUANTUM TOOLS\nfor \u03b1 \u2265 0. Note that the Shannon entropy is the special case for limit \u03b1 \u2192 1.\nThe joint entropy of a pair of random variables (X0 , X1 ) measures the total uncertainty\nabout the pair and is naturally defined as\n!\nX\nH(X0 X1 ) = \u2212 log\nPX0 X1 (x0 , x1 ) .\n(3.39)\nx0 ,x1\n\nAssume now that X1 is learned, and therewith, H(X1 ) bits of information about (X0 , X1 ).\nThen, the remaining uncertainty of X0 , conditioned on knowing X1 , is given by the conditional entropy\nH(X0 |X1 ) := H(X0 X1 ) \u2212 H(X1 ) .\n\n(3.40)\n\nR\u00e9nyi entropies can also be defined for the quantum world, i.e., where a density matrix\n\u03c1 replaces the probability distribution, and we have\nH\u03b1 (\u03c1) :=\n\n\u0001\n1\nlog tr(\u03c1\u03b1 ) ,\n1\u2212\u03b1\n\n(3.41)\n\nfor \u03b1 \u2208 [0, \u221e]. The von Neumann entropy is then given by\nH(\u03c1) := \u2212 tr(\u03c1 log \u03c1) ,\n\n(3.42)\n\nwhich corresponds to the Shannon entropy\nP when measuring quantum state \u03c1X in basis\n{|xihx|}, or in other words H(\u03c1) = \u2212 x \u03bbx log \u03bbx , where \u03bbx are the eigenvalues of \u03c1X .\nThus, it naturally holds that H\u03b1 (\u03c1X ) = H\u03b1 (X), whenever classical variable X is encoded in\nquantum state \u03c1X .\nA special entropy measure is obtained when taking the limit \u03b1 \u2192 \u221e, namely the minentropy. The notion of min-entropy is used in the context of randomness extraction and\nprivacy amplification in the presence of a dishonest receiver or an eavesdropper on the transmission (see Section 3.4). Intuitively, the (classical) min-entropy is determined by the highest\npeak in a distribution, and therewith, describes the maximum amount of potentially leaked\ninformation, which in turn formalizes security for cryptographic applications in the worst\ncase. In other words, the min-entropy measures the probability of an adversary's best guess\nabout an unknown value.\nDefinition 3.1 (Min-Entropy) Let X be a random variable over alphabet X with probability distribution PX . The min-entropy of X is defined as\n\u0001\nH\u221e (X) = \u2212 log max PX (x) .\nx\n\nAnother important special case is the max-entropy with values for \u03b1 approaching zero.\nIts definition captures a R\u00e9nyi entropy, in which all possible events are considered equally,\nregardless of their probabilities. Its operational meaning lies in information reconciliation\n(see also Section 3.4).\nDefinition 3.2 (Max-Entropy) The max-entropy of a density matrix \u03c1 is defined as\n\u0001\nH0 (\u03c1) = log rank(\u03c1) .\n\n\f3.4. INFORMATION RECONCILIATION AND PRIVACY AMPLIFICATION 35\nFor completeness, we note that another notion of R\u00e9nyi entropies with a (non-negative)\nsmoothing parameter \u000f was introduced in [Ren05, RW05]. Intuitively, it holds that for two\nrandom variables X0 and X1 with almost the same probability distribution (e.g. X0 = X1\nwith high probability), the difference between H\u03b1\u000f (X0 ) and H\u03b1\u000f (X1 ) is small. However, in\nthis work we will only use the \"un-smoothed\" R\u00e9nyi entropies as discussed above.\nLast, we conclude with the following lemma, which we will need in the context of oblivious\ntransfer. Informally, it states that if the joint entropy of two random variables X0 and X1 is\nlarge, then at least one of them has half of the original entropy-in a randomized sense.\nLemma 3.1 (Min-Entropy-Splitting Lemma [Wul07, DFR+ 07]) Let X0 , X1 be random variables with H\u221e (X0 X1 ) \u2265 \u03b1. Then, there exists a binary random variable K \u2208 {0, 1}\nsuch that H\u221e (X1\u2212K K) \u2265 \u03b1/2.\n\n3.4\n\nInformation Reconciliation and Privacy Amplification\n\nErrors and eavesdropping affect the communication in our quantum protocols such that\nthe honest parties might end up with bit-strings of measurement outcomes that differ or\nhave leaked in some positions. Countermeasures were proposed already in the first practical\nimplementation of QKD [BBB+ 92]. The honest parties first reconcile their shared data by\npublic discussion to obtain consistent strings. Note that this process has to be accomplished\nwithout revealing more information than absolutely necessary to an adversary eavesdropping\non the public (classical) channel. The simplest procedure involves a test on a subset of all\nshared (qu)bits to compute the error rate, i.e., the relative number of all positions with\ndifferent outcomes. In that case, these publicly announced bits must later be discarded,\nwhich in turn means that more qubits have to be sent at the beginning of the protocol.\nAccording to the error rate in the testset, error correction must be applied to the untested\nremaining set. Since the transmission of qubits is very efficient in practice and good error\ncorrection techniques are known, we will use this simple technique in our quantum protocols.\nAfter successful reconciliation, the honest parties are in possession of identical bit-strings.\nTo turn these strings into completely secure ones, privacy amplification [BBR88] can be\napplied, which intuitively distills a shorter but (essentially) private shared string. More\nconcretely, privacy amplification employs two-universal hashing (see Definition 3.3) to transform a partially secret string into a highly secure \"hashed down\" string, about which any\nadversary only has negligible information and which looks essentially random to him. Note\nthat two-universal hashing also works against quantum adversaries, i.e., in the case when\nthe attacker holds quantum information about the initial string [KMR05, RK05, Ren05]. In\nfact, it is essentially the only efficient way to perform privacy amplification against quantum\nadversaries.\nDefinition 3.3 (Two-Universal Hashing) A class F : {0, 1}n \u2192 {0, 1}` of hashing functions is called two-universal, if for any pair x, y \u2208 {0, 1}n with x 6= y, and F uniformly\nchosen from F, it holds that\n1\nPr [F (x) = F (y)] \u2264 ` .\n2\n\n\f36\n\nCHAPTER 3. QUANTUM TOOLS\nIn the slightly stronger notion of strongly two-universal hash-functions, we require the random\nvariables F (x) and F (y) to be independent and uniformly distributed over {0, 1}` .\nP Let classical Xx be correlated with classical part U and quantum part E, i.e., \u03c1XU E =\nx\u2208{0,1}n PX (x)\u03c1U E . Let F be a hash-function chosen uniformly from F. After applying F\nto X, we obtain the cccq-state \u03c1F (X)F U E of form\n\u03c1F (X)F U E =\n\nX\n\nX\n\nf \u2208F\n\nz\u2208{0,1}`\n\n|zihz| \u2297 |f ihf | \u2297\n\nX\n\nPX (x)\u03c1xU E .\n\n(3.43)\n\nx\u2208f \u22121 (z)\n\nThe basic theorem for privacy amplification in the quantum world was introduced in [RK05]\nand [Ren05], and confined in [Sch07]. Here, we give the version from [Sch07, Corollary 2.25]\nbut in its un-smoothed form and tailored to our context.\nTheorem 3.1 (Privacy Amplification) Let \u03c1XU E be a ccq-state with classical X distributed over {0, 1}n , classical U in the finite domain U, and quantum state \u03c1E . U and \u03c1E\nmay depend on X. Let F be the random and independent choice of a member of a universal-2\nclass of hash-functions F : {0, 1}n \u2192 {0, 1}` . Then,\n\u0001 1 \u2212 1 H\u221e (X|U )\u2212H0 (\u03c1E )\u2212`\u0001\n1\n\u03b4 \u03c1F (X)F U E , 2` 1 \u2297 \u03c1F U E \u2264 2 2\n.\n2\nNote that if the rightmost term of the theorem is negligible, then we are in a situation where\nF (X) is essentially uniform and independent of F and E.\n\n3.5\n\nRewinding\n\nWe require for classical schemes in the quantum world that quantum computation does not\njeopardize the underlying mathematical assumption that guarantees the security. But we\nencounter even more setbacks in the context of actually proving a cryptographic protocol\nsecure in a quantum environment, which in the realm of this work are mostly due to the\nstrong restrictions on general rewinding-a common proof technique for showing the security\nof different protocols in the computational setting.\n\n3.5.1\n\nProblems with General Rewinding\n\nRecall that in the context of simulation-based security, we prove security against a cheating\nplayer by showing that a run of a protocol between him and the honest player can be efficiently\nsimulated without interacting with the honest player but with a simulator instead. Basically,\nsuch a simulator prepares a valid conversation and tries it on the dishonest party. In case this\nparty does not send the expected replies, a classical simulator rewinds the machine of the\ncorrupted player to an earlier status and repeats the simulation. Note that if the dishonest\nparty sends an invalid reply, the simulation is aborted. To conclude the proof, we then show\nthat the running time of the simulation as well as the distribution of the conversation are\naccording to expectations.\nSuch a technique, however, is impossible to justify in the quantum world. Generally\nspeaking, the simulator had to partially measure the quantum system without copying it\n\n\f3.5. REWINDING\nbeforehand to obtain the protocol transcript. But then it would become impossible to reconstruct all information necessary for correct rewinding. The problem of rewinding in general\nquantum systems was originally observed in [Gra97], detailed discussions can also be found\ne.g. in [DFS04,Wat09]. In the context of this work, there are two relevant rewinding settings.\nThe first setting applies to simulations intended to collect several transcripts of conversations. An example thereof is the classical simulation for protocols with embedded computationally binding commitments. Recall that computational binding means that if a dishonest\nparty can open a commitment to two different values, then the computational assumption\ndoes not hold. In a classical simulation, the simulator simulates a run of the outer protocol\nwith the committer, such that the latter outputs a valid commitment and later provides a\ncorrect opening. Now, the simulator has the possibility to rewind the player to a point after\nthe commitment was sent and repeat the simulation, which can be adapted to the simulator's\nknowledge of the committed value. The event of obtaining a different opening for the same\ncommitment in this second run implies the inversion of the underlying one-way function,\nwhich is assumed to be infeasible. In such a simulation, the simulator must store the previous transcript before rewinding. Another example of this setting occurs when proving special\nsoundness in a proof of knowledge. There, a classical simulator simulates a run of a protocol\nagainst a dishonest prover. It then keeps a transcript of the simulation and rewinds him.\nFrom two accepting conversations, the simulator can extract the prover's witness. Again,\nthe simulator must store transcripts of the communication before rewinding.\nThe second setting requires the simulator to rewind the dishonest player to the beginning\nof a protocol, if the reply from the dishonest party does not match the prepared outcome of\nthe protocol such that both sides conclude on the ideal values as their result. This setting\napplies, for instance, when proving an outer protocol with an embedded computationally hiding commitment secure. Fortunately, if such a simulation complies with a restricted setting,\nthe newly introduced quantum rewinding lemmas of [Wat09] can be applied. Therewith,\nrewinding is possible in a restricted quantum setting. We will discuss this technique in more\ndetail in the following section, but in short, it requires a one bit reply from the dishonest\nparty (e.g. a bit reply to a previous bit commitment), the simulation circuit must be unitary,\nand in case of rewinding, we do not intend to keep intermediate transcripts nor collect all\npossible results (see Section 3.5.2). Unfortunately, we do not know how to translate this\ntechnique to a multi-bit reply, while keeping the running time of the simulator polynomially\nbounded. In that case, the classical simulation would again reduce to the first setting above,\nin which the simulator must store previous transcripts, namely a previous message from the\ndishonest party that commits him to his multi-bit reply beforehand.\n\n3.5.2\n\nQuantum Rewinding\n\nRecall that we consider the second setting of the previous section. In a classical simulation\nagainst dishonest Bob, a poly-time simulator guesses, for instance, a valid reply b0 of dishonest\nBob and prepares the protocol transcript according to it. When the simulator finally receives\nBob's actual reply b, it checks if the values coincide (b = b0 ), i.e., if its guess was correct and\ntherewith, if the simulation was successful. If that is not the case, the simulator rewinds\nBob and repeats the simulation until b = b0 . No previous information has to be stored nor\ncollected.\n\n37\n\n\f38\n\nCHAPTER 3. QUANTUM TOOLS\nRecently, Watrous proposed a quantum analogue of such a simulator with the potential\nof rewinding, and proved therefore, that quantum zero-knowledge is possible in an unrestricted model. We will sketch the most important aspects of his construction here but refer\nto [Wat09] for further details and proofs. More specifically, Watrous proved how to construct a quantum zero-knowledge proof system for Graph Isomorphism and introduced two\nso-called quantum rewinding lemmas; one for an exact setting and one that holds for slightly\nweaker assumptions and therewith covers a scenario with perturbations. The investigated\nprotocol proceeds as a \u03a3-protocol, i.e., a protocol in three-move form, where the verifier flips\na single coin in the second step and sends this challenge to the prover. Thus, the setting\napplies to the case where the reply b from above is a single bit. This will also be the case\nfor our simulation in Chapter 8, and therefore, we can use Watrous' result in a black-box\nmanner. Unfortunately, we do not know how to translate his technique to a multi-bit reply,\nwhile keeping the running time of the simulator polynomially bounded.\nThe quantum rewinding procedure\n\u0001 is implemented by a general quantum circuit R, which\nreceives Bob's input registers W, X , where W contains any n-qubit auxiliary input |\u03c8i and\nX is a working register, initialized to the all-zero state of size k. As a first step, R applies a\nunitary quantum circuit Q to all registers to simulate the conversations, obtaining as output\na multi-qubit register Y and a single-qubit register G. Register G contains the outcome of\nthe CNOT-operation on the dishonest party's bit b (as control) and the simulator's guess b0 .\nThus, by measuring this register in the computational basis, the simulator can determine\nwhether the simulation was successful.\n\u0001\n\u0001\nIn more detail, the transformation from W, X to G, Y by applying Q can be written\nas\nE\np\n\u221a\nQ|\u03c8iW 0k\n= p|0iG |\u03c6good (\u03c8)iY + 1 \u2212 p|1iG |\u03c6bad (\u03c8)iY ,\nX\n\nwhere 0 < p < 1 and |\u03c6good (\u03c8)i denotes the state, we want the system to be in for a successful\nsimulation. The qubit in register G is then measured with respect to the standard basis,\nwhich indicates success or failure of the simulation. A successful execution (where b = b0 )\nresults in outcome 0 with probability p. In that case, R outputs Y . A measurement outcome\n1 indicates b 6= b0 , and hence, implies an unsuccessful simulation. In that case, R quantumly\nrewinds the system by applying the reverse circuit Q\u2020 , and then a phase-flip transformation\n(on register X) before another iteration of Q is applied, i.e.,\n\u0012 \u0010\n\u0013\nED \u0011\nQ 2 I \u2297 0k 0k \u2212 I Q\u2020 |1iG |\u03c6bad (\u03c8)iY\np\n= 2 p(1 \u2212 p)|0iG |\u03c6good (\u03c8)iY + (1 \u2212 2p)|1iG |\u03c6bad (\u03c8)iY .\nThus, after this rewinding, the amplitudes of the \"good\" and the \"bad\" states are increased\nand decreased, respectively. Thus, a measurement of register G in the computational basis\nwill result in outcome 0 with higher probability 4p(1 \u2212 p). Note that for the special case\nwhere p equals 1/2 and is independent of |\u03c8i, the simulation terminates after at most one\nrewinding.\nWatrous' ideal quantum rewinding lemma (without perturbations) then states the following: Under the condition that the probability p of a successful simulation is non-negligible\n\n\f3.5. REWINDING\n\n39\n\nand independent of any auxiliary input, R is poly-time and its output \u03c1(\u03c8) has square-fidelity\nclose to 1 with state |\u03c6good (\u03c8)i of a successful simulation, i.e.,\nh\u03c6good (\u03c8)|\u03c1(\u03c8)|\u03c6good (\u03c8)i \u2265 1 \u2212 \u03b5 ,\nwith error bound \u03b5 > 0.\nHowever, we cannot apply the exact version of Watrous' rewinding lemma in our simulation in Chapter 8, since we simulate against a dishonest party with an underlying commitment\nthat only provides quantum-computational hiding against this party. Therefore, we can only\nclaim that the party's input is close to independent from the probability p. In other words,\nwe must allow for small perturbations in the quantum rewinding procedure and the slightly\nweaker notion of Watrous' quantum rewinding lemma, as stated below, applies.\nLemma 3.2 (Quantum Rewinding Lemma with small perturbations [Wat09]) Let\nQ be the unitary (n, k)-quantum circuit and let R be the general quantum circuit describing\nthe quantum rewinding procedure. Let p0 , q \u2208 (0, 1) and \u03b5 \u2208 (0, 21 ) be real numbers such that\n1. |p \u2212 q| < \u03b5\n2. p0 (1 \u2212 p0 ) \u2264 q(1 \u2212 q), and\n3. p0 \u2264 p\nfor all n-qubit states |\u03c8i. Then there exists R of size\n\u0012\nO\n\nlog(1/\u03b5)size(Q)\np0 (1 \u2212 p0 )\n\n\u0013\n\nsuch that, for every n-qubit state |\u03c8i, the output \u03c1(\u03c8) of R satisfies\nh\u03c6good (\u03c8)|\u03c1(\u03c8)|\u03c6good (\u03c8)i \u2265 1 \u2212 \u03b50\n2\n\n(1/\u03b5)\nwhere \u03b50 = 16\u03b5 plog\n2 (1\u2212p )2 .\n0\n\n0\n\nIntuitively, Requirement (1.) allows for small perturbation between the actual probability\np and the ideal probability q. Thus, \u03b5 can be understood as the advantage of the dishonest\nparty. It follows that if \u03b5 is negligible, we can argue that p is close to q and therefore,\nclose to independent of the auxiliary input. Probability p0 in Requirement (3.) denotes the\nlower bound on the actual probability, for which the procedure guarantees correctness and\nterminates in poly-time. Instead of using p in circuit R, we use p0 . Furthermore, Q is\nreplaced by U with U = V Q. Lemma 3.2 reflects these replacements.\na very intuitive\nP2On\nn\nlevel, the general input state |\u03c8i is analyzed in more detail, i.e. |\u03c8i = i=1 \u03b1i |\u03c8i i leading to\nn\n\n|\u03c6good (\u03c8)i =\n\n2\nX\ni=1\n\ns\n\u03b1i\n\np(\u03c8i )\n|\u03c6good (\u03c8i )i ,\np(\u03c8)\n\n\f40\n\nCHAPTER 3. QUANTUM TOOLS\nand similar for |\u03c6bad (\u03c8)i. This more detailed description allows that in any position, the\nprobability is only near-independent of the input. The slight variations must then be addressed by an operator V , such that U = V Q is close to Q but satisfies the exact case of\nrewinding. In other words, applying U on the perturbed input state gives the ideal outcome\nE\np\n\u221a\nU |\u03c8iW 0k\n= q|0iG |\u03b4good (\u03c8)iY + 1 \u2212 q|1iG |\u03b4bad (\u03c8)iY .\nX\n\nTransformation V can therewith be understood as a correction. The bound in Requirement (2.) follows from proof details which will not be addressed here. Finally, note that the\nbounds are not necessarily tight. Important for our proof is, however, that all operations can\nbe performed by polynomial-size circuits, and thus, the simulator has polynomial size (in\nthe worst case). Furthermore, for negligible \u03b5, it follows that the \"closeness\" of output \u03c1(\u03c8)\nwith good state |\u03c6good (\u03c8)i is slightly reduced, but quantum rewinding remains possible and\nthe output \u03c1(\u03c8) of R has still square-fidelity close to 1 with state |\u03c6good (\u03c8)i of a successful\nsimulation.\n\n3.6\n\nDefinition of Security\n\nWe will now define security for our two-party protocols, along the lines informally described\nin Section 2.2. To this end, we will work in the framework put forward by Fehr and Schaffner\nin [FS09]. There, they propose general definitions for correctness and security for any quantum protocol that implements a classical non-reactive two-party functionality, meaning that\nin- and output must be classical. We stress that the framework also allows functionalities\nwhich behave differently in case of a dishonest player. They then show that such a quantum\nprotocol, complying with the framework, composes sequentially in a classical environment,\nor in other words, within an outer classical protocol. Their security definitions are phrased\nin simple information-theoretic conditions, depending on the functionality, which implies\nstrong simulation-based security. For the sake of simplicity, the framework does not assume\nadditional entities such as e.g. an environment, without of course compromising correctness\nin the given setting.\nThroughout this work, we are interested in quantum and classical protocols that implement classical functionalities. As already mentioned, such primitives are often used as\nbuilding blocks in more complicated classical (multi-party) protocols which implement more\nadvanced tasks. Therefore, it can be justified in Part II to restrict the focus to such quantum\nprotocols that run in a classical environment and have classical in- and outputs. Furthermore,\nalthough the framework was originally proposed for quantum protocols that compose in a\nclassical environment, we adapt it here for classical protocols against quantum attacks, composing equally well when imposing the suggesting restriction regarding the in- and outputs.\nThus, we will use it also in Part III for defining security of our classical protocols.\nAlthough various other security and composition frameworks have been proposed (such\nas [BM04, Unr04, Unr10, WW08]), we consider the security level achieved in this framework\nas a reasonable balance between weak demands and yet meaningful security. Furthermore,\nits structure is as simple and clear as possible and compliance with the definitions gives us\nsequential composition. Towards a general composition, we must, of course, extend the basic\nprotocols as shown in Sections 5.5 and 8.3.\n\n\f3.6. DEFINITION OF SECURITY\nWe will now introduce the framework more formally for a general functionality. We will\nuse information-theoretic definitions in our notions of unconditional security as investigated\nin [FS09]. In addition, we will also show that computational security can be defined similarly,\nalthough with some modifications.\n\n3.6.1\n\nCorrectness\n\nA protocol \u03a0 consists of an infinite family of interactive quantum circuits for players Alice\nand Bob, indexed by the security parameter. For instance, in our quantum protocols this\nsecurity parameter m corresponds to the number of qubits transmitted in the first phase.\nHowever, to ease notation, we often leave the dependence on the security parameter implicit.\nSince we assume the common input state \u03c1U V to be classical, i.e.,\nX\n\u03c1U V =\nPU V (u, v)|uihu| \u2297 |vihv| ,\nu,v\n\nfor some probability distribution PU V , we understand U, V as random input variables. The\nsame holds for the classical output state \u03c1XY with output X, Y . The input-output behavior\nof the protocol is uniquely determined by PXY |U V , and we write \u03a0(U, V ) = (X, Y ). Then,\na classical non-reactive two-party ideal functionality F is given by a conditional probability\ndistribution PF (U,V )|U V with F(U, V ) denoting the ideal-world execution, where the players\nforward their inputs U, V to F and output whatever they obtain from F. The definition of\ncorrectness of a protocol is now straightforward.\nDefinition 3.4 (Correctness) A protocol \u03a0(U, V ) = (X, Y ) correctly implements an ideal\nclassical functionality F, if for every distribution of the input values U and V , the resulting\ncommon output satisfies\ns\n(U, V, X, Y ) \u2248 (U, V, F(U, V )) .\n\n3.6.2\n\nInformation-Theoretic Security\n\nWe define information-theoretic security based on [FS09, Proposition 4.3]. Note that in the\nfollowing, we simplify the joint output representation (compared to [FS09]) in that we denote\nthe output in the real world by out\u03a0\nA,B (which is equivalent to \u03a0A,B \u03c1U V ), and the output in\nF\nthe ideal world by out\u00c2,B\u0302 (equivalent to (F\u00c2,B\u0302 )\u03c1U V ).\nRecall that U denotes honest Alice's classical input, and let Z and V 0 denote dishonest\nBob's classical and quantum information. Then, any input state \u03c1U ZV 0 is restricted to be of\nform\nX\n\u03c1U \u2194Z\u2194V 0 =\nPU Z (u, z)|uihu| \u2297 |zihz| \u2297 \u03c1zV 0 ,\nu,z\n\n\u03c1u,z\nV0 .\n\nwhere it holds here that \u03c1zV 0 =\nThis implies that Bob's quantum part V 0 is correlated\nwith Alice's part only via his classical Z.\nDefinition 3.5 (Unconditional security against dishonest Bob) A protocol \u03a0 implements an ideal classical functionality F unconditionally securely against dishonest Bob, if for\nany real-world adversary B0 , there exists an ideal-world adversary B\u03020 such that, for any input\n\n41\n\n\f42\n\nCHAPTER 3. QUANTUM TOOLS\n\nFunctionality F\u00c2,B\u03020\n\nProtocol \u03a0A,B0\nU\n\nZ\n\n\u0007\n\nV'\n\n?\n\nU\n\n\u0004\n\n\u0001\n\u0001\n? \u0001\n\n\u0007\n\n\u001b\n\n\u00c21\n\n-\n\n\u0004\n\nU\n\nV\n\nB\u030201\n\n@\nR\n@\n\n\u001b\n\nV'\n\n\u0001\n\u0001\n? \u0001\n\n?\n\nB0\n\nA\n\nZ\n\nF\n\n`\n`\n`\n\nX\n\u00c22\n\nV,Z\nY\n\n@\nR\n@\n\n? ?\nB\u030202\n\n\u0006\n\n\u0005\n\nA\n?\nX\n\n\u0006\n\nA\nU\n? A\nZ\n\n?\nY'\n\nX\n\n\u0005\n\nA\nA\n? AU\nZ\n\nY'\n\nFigure 3.1: Real World vs. Ideal World [Sch10].\nstate with \u03c1U ZV 0 = \u03c1U \u2194Z\u2194V 0 , it holds that the outputs in the real and the ideal world are\nstatistically indistinguishable, i.e.,\ns\n\nF\nout\u03a0\nA,B0 \u2248 out\u00c2,B\u03020 .\n\nFor completeness, we state these output states explicitly, i.e.,\nF\nout\u03a0\nA,B0 = \u03c1U XZY 0 and out\u00c2,B\u03020 = \u03c1U X\u2194Z\u2194Y 0 ,\n\nwhich shows that Bob's possibilities in the ideal world are limited. He can produce some\nclassical input V for F from his quantum input state V 0 , and then he can obtain a quantum\nstate Y 0 by locally processing V and possibly F's classical reply Y . This description is also\ndepicted in Figure 3.1.\nAnalogously, we can define unconditional security for honest Bob against dishonest Alice.\nIn this case, we assume a classical Z and a quantum state U 0 as dishonest Alice's input and\na classical input V of honest Bob.\nDefinition 3.6 (Unconditional security against dishonest Alice) A protocol \u03a0 implements an ideal classical functionality F unconditionally securely against dishonest Alice,\nif for any real-world adversary A0 , there exists an ideal-world adversary \u00c20 such that, for any\ninput state with \u03c1U 0 ZV = \u03c1U 0 \u2194Z\u2194V , it holds that the outputs in the real and the ideal world\nare statistically indistinguishable, i.e.,\ns\n\nF\nout\u03a0\nA0 ,B \u2248 out\u00c20 ,B\u0302 .\n\nNote that in the definitions above, we do not require the running time of ideal-world\nadversaries to be polynomial whenever the real-life adversaries run in polynomial time. This\nway of defining unconditional security can lead to the (unwanted) effect that unconditional\n\n\f3.6. DEFINITION OF SECURITY\nsecurity does not necessarily imply computational security. However, as mentioned before,\nby extending our basic constructions we can achieve efficient ideal-life adversaries.\nIntuitively, the composition theorem below states that if quantum protocols \u03c01 * * * \u03c0`\nsecurely implement ideal functionalities F1 * * * F` , then a protocol \u03a3\u03c01 ***\u03c0` is essentially as\nsecure as a classical hybrid protocol \u03a3F1 ***F` with sequential calls to F1 * * * F` . Note that\nfor the hybrid protocol to be classical, we mean that it has classical in- and output (for\nthe honest players), but also that all communication between the parties is classical.2 The\nabove facts imply that such protocols compose sequentially. Below, we state (a simplified\nvariant of) the theorem in [FS09]. We omit its proof here but note that it proceeds along\nsimilar lines as the proof of Theorem 3.3, translating sequential composition to the case of\ncomputational security.\nTheorem 3.2 (Composition Theorem I [FS09]) Let \u03a3F1 ***F` be a classical hybrid protocol which makes at most k calls to F1 * * * F` , and for every i \u2208 {1, . . . , `}, let protocol \u03c0i be\nan \u03b5-secure implementation of Fi against A and B. Then the output of \u03a3\u03c01 ***\u03c0` is at distance\nat most O(k\u03b5) to the output produced by \u03a3F1 ***F` .\nWe want to explicitly state here that if the hybrid protocol is secure, then so is the reallife protocol, and as such it could itself be use as a sub-protocol in yet another classical outer\nprotocol.\nCorollary 3.1 If \u03a3F1 ***F` is a \u03b4-secure implementation of G against A and B, and if \u03c0i is\nan \u03b5-secure implementation of Fi against A and B for every i \u2208 {1, . . . , `}, then \u03a3\u03c01 ***\u03c0` is a\nO(\u03b4 + \u03b5)-secure implementation of G.\n\n3.6.3\n\nComputational Security\n\nOne can define security against a computationally bounded dishonest Bob in the CRS-model\nanalogously to information-theoretic security, with the two differences that the input given to\nthe parties has to be sampled by an efficient quantum algorithm and that the output states\nof Definition 3.5 should be computationally indistinguishable. Recall that in the CRS-model,\nall participants in the real world have access to a classical public common reference string \u03c9,\nwhich is chosen before any interaction starts, according to a distribution only depending on\nthe security parameter. On the other hand, the participants in the ideal-world execution\nF\u00c2,B\u0302 , interacting only with the ideal functionality, do not make use of string \u03c9. Hence,\nan ideal-world adversary B\u03020 that operates by simulating a real-world adversary B0 is free to\nchoose \u03c9 in any way he wishes.\nIn order to define computational security against a dishonest Bob in the CRS-model, we\nconsider a polynomial-size quantum circuit, called input sampler, which takes as input the\nsecurity parameter and the common reference string \u03c9 (chosen according to its distribution)\nand which produces the input state \u03c1U ZV 0 . Again, U , Z, and V 0 denote Alice's classical, Bob's\n2\n\nWe want to stress that a hybrid protocol is a protocol that makes sequential calls to ideal functionalities.\nThis term should not be confused with the notion of hybrid security in Chapter 5, which refers to quantum\nprotocols providing twofold security in case of an adversary who is either bounded in quantum storage or\nbounded in quantum-computational power.\n\n43\n\n\f44\n\nCHAPTER 3. QUANTUM TOOLS\nclassical, and Bob's quantum information, respectively, and we require from the input sampler\nthat \u03c1U ZV 0 = \u03c1U \u2194Z\u2194V 0 . In the following, we let Bpoly be the family of all polynomial-time\nstrategies for dishonest Bob.\nDefinition 3.7 (Computational security against dishonest Bob) A protocol \u03a0 implements an ideal classical functionality F computationally securely against dishonest Bob,\nif for any real-world adversary B0 \u2208 Bpoly , who has access to the common reference string\n\u03c9, there exists an ideal-world adversary B\u03020 \u2208 Bpoly , not using \u03c9, such that, for any efficient\ninput sampler as described above, it holds that the outputs in the real and the ideal world are\nquantum-computationally indistinguishable, i.e.,\nq\n\nF\nout\u03a0\nA,B0 \u2248 out\u00c2,B\u03020 .\n\nProtocols fulfilling the definition above provide sequential composition in a naturally\nweaker but otherwise similar notion as unconditionally secure protocols. We can therefore\nadapt the original composition theorem to the case of computational security. For completeness, we will include its proof as given in [DFL+ 09].\nConsider a dishonest B0 and the common state \u03c1Uj Vj0 at any point during the execution of\nthe hybrid protocol when a call to functionality Fi is made. The requirement for the oracle\nprotocol to be classical is now expressed in that there exists a classical Zj -to be understood\nas consisting of B\u03020 's classical communication with \u00c2 and with the Fi0 's up to this point-\nsuch that given Zj , Bob's quantum state Vj0 is not entangled with Alice' classical input and\nauxiliary information: \u03c1Uj Zj Vj0 = \u03c1Uj \u2194Zj \u2194Vj0 . Furthermore, we require that we may assume\nZj to be part of Vj0 in the sense that for any B\u03020 there exists B\u030200 such that Zj is part of Vj0 .\nThis definition is motivated by the observation that if Bob can communicate only classically\nwith Alice, then he can entangle his quantum state with information on Alice's side only by\nmeans of the classical communication.\nWe also consider the protocol we obtain by replacing the ideal functionalities by quantum\ntwo-party sub-protocols \u03c01 * * * \u03c0` with classical in- and outputs for the honest parties, i.e.,\nwhenever \u03a3F1 ***F` instructs \u00c2 and B\u0302 to execute Fi , they instead execute \u03c0i and take the\nresulting outputs. We then write \u03a3\u03c01 ***\u03c0` for the real quantum protocol we obtain this way.\nRecall that we require from the input sampler that \u03c1U ZV 0 = \u03c1U \u2194Z\u2194V 0 , i.e., that V 0\nis correlated with Alice's part only via the classical Z. When considering classical hybrid\nprotocols \u03a3\u03c01 ***\u03c0` in the real world, where the calls are replaced with quantum protocols\nusing a common reference string, it is important that every real protocol \u03c0i uses a separate\ninstance (or part) of the common reference string which we denote by \u03c9i .\nTheorem 3.3 (Composition Theorem II) Let \u03a3F1 ***F` be a classical two-party hybrid\nprotocol which makes at most k = poly(n) calls to the functionalities, and for every i \u2208\n{1, . . . , `}, let protocol \u03c0i be a computationally secure implementation of Fi against Bpoly .\nThen, for every real-world adversary B0 \u2208 Bpoly who accesses the common reference string\n\u03c9 = \u03c91 , . . . , \u03c9k there exists an ideal-world adversary B\u03020 \u2208 Bpoly who does not use \u03c9 such that\nfor every efficient input sampler, it holds that the outputs in the real and the ideal world are\nquantum-computationally indistinguishable, i.e.,\n\u03c01 ***\u03c0`\n\n\u03a3\noutA,B\n0\n\nq\n\nF1 ***F`\n\n\u2248 out\u03a3\n\u00c2,B\u03020\n\n.\n\n\f3.6. DEFINITION OF SECURITY\n\n45\n\nNote that we do not specify what it means for the hybrid protocol to be secure. In fact,\nTheorem 3.3 guarantees that whatever the hybrid protocol achieves, an indistinguishable\noutput is produced by the real-life protocol with the functionality calls replaced by protocols.\nOf course, if the hybrid protocol is secure in the sense of Definition 3.7, then so is the real-life\nprotocol.\nCorollary 3.2 If \u03a3F1 ***F` is a computationally secure implementation of G against Bpoly ,\nand if \u03c0i is a computationally secure implementation of Fi against Bpoly for every i \u2208\n{1, . . . , `}, then \u03a3\u03c01 ***\u03c0` with at most k = poly(n) oracle calls is a computationally secure\nimplementation of G against Bpoly .\nProof.\nWe prove the claim in Theorem 3.3 by induction on k. If no calls are made, we can set\nB\u03020 := B0 and the claim holds trivially. Consider now a protocol \u03a3F1 ***F` with at most k > 0\noracle calls. For simplicity, we assume that the number of oracle calls equals k, otherwise we\ninstruct the players to make some \"dummy calls\". Let \u03c1Uk Zk Vk0 be the common state right\nbefore the k-th, and thus, last call to one of the sub-protocols \u03c01 , . . . , \u03c0` in the execution of\nthe real protocol \u03a3\u03c01 ,...,\u03c0` . To simplify notation in the rest of the proof, we omit the index\nk and write \u03c1\u016a Z\u0304 V\u0304 0 instead (see Figure 3.2). We know from the induction hypothesis for\nk \u2212 1 that there exists an ideal-world adversary B\u03020 \u2208 Bpoly not using the common reference\nq\nstring such that \u03c1\u016a Z\u0304 V\u0304 0 \u2248 \u03c3\u016a Z\u0304 V\u0304 0 where \u03c3\u016a Z\u0304 V\u0304 0 is the common state right before the k-th\ncall to a functionality in the execution of the hybrid protocol \u03a3F1 ***F` with input \u03c1U ZV 0 . As\ndescribed, \u016a and Z\u0304, V\u0304 0 are to be understood as follows. \u016a denotes A's (respectively \u00c2's)\ninput to the sub-protocol (respectively functionality) that is to be called next. Z\u0304 collects the\nclassical communication dictated by \u03a3F1 ...,F` as well as B\u03020 's classical inputs to and outputs\nfrom the previous calls and V\u0304 0 denotes the dishonest player's current quantum state. Note\nthat the existence of Z\u0304 is guaranteed by our formalization of classical hybrid protocols and\n\u03c3\u016a Z\u0304 V\u0304 0 = \u03c3\u016a \u2194Z\u0304\u2194V\u0304 0 .\nLet \u03c9i be the common reference string used in protocol \u03c0i . For simplicity, we assume\nthat the index i, which determines the sub-protocol \u03c0i (or functionality Fi ) to be called next,\nis fixed and we just write \u03c0 and F for \u03c0i and Fi , respectively.\nIt follows from Definition 3.7 of computational security that there exists B\u03020 \u2208 Bpoly\n(independent of the input state) not using \u03c9i such that the corresponding output states\n\u03c3X\u0304 Z\u0304 \u0232 0 and \u03c4X\u0304 Z\u0304 \u0232 0 produced by F\u00c2,B\u03020 (as prescribed by the oracle protocol) and \u03c0A,B0 run on\nthe state \u03c3\u016a Z\u0304 V\u0304 0 = \u03c3\u016a \u2194Z\u0304\u2194V\u0304 0 are quantum-computationally indistinguishable.\nThe induction step is then completed with\n\u03c0\n\nq\n\nq\n\nF\n\n\u03a3\nout\u03a3\nA,B0 = \u03c1X\u0304 Z\u0304 \u0232 0 = (\u03c0A,B0 ) \u03c1\u016a Z\u0304 V\u0304 0 \u2248 (\u03c0A,B0 ) \u03c3\u016a Z\u0304 V\u0304 0 = \u03c3X\u0304 Z\u0304 \u0232 0 \u2248 \u03c4X\u0304 Z\u0304 \u0232 0 = out\u00c2,B\u03020 ,\n\nwhere (\u03c0A,B0 ) \u03c1X should be understood as running protocol \u03c0A,B0 with input \u03c1X .\nNote that the strategy of B\u03020 does not depend on the state \u03c3\u016a Z\u0304 V\u0304 0 , and hence, the overall\nideal-world adversary B\u03020 does not depend on the input state either. Furthermore, the concatenation of two polynomially bounded players is polynomially bounded, i.e. B\u03020 \u2208 Bpoly .\n\u0004\n\n\f1 ***\u03c0`\n\u03a3\u03c0AB\n0\n\n1 ***F`\n\u03a3F\n\u00c2B\u03020\n\n-\n\n-\n\n\u001b\n\u001b\n\u001b\n\n-\n\nF i0\n\n\u2248\n\u001b\n\u001b\n\n-\n\n\u03c1\u016a Z\u0304 V\u0304 0\n\n\u03c0i\n\u001b\n\n-\n\nF i0\n\n\u03c0 i0\n\n-\n\n\u03c1X\u0304 Z\u0304 \u0232 0\n\n\u03c3\u016a Z\u0304 V\u0304 0\n\n\u03c0i\n\u001b\n\n\u001b\n\u001b\n\n-\n\n-\n\n-\n\nFi\n\n\u2248\n\u03c3X\u0304 Z\u0304 \u0232 0\n\nFigure 3.2: Steps of the Composability Proof\n\n\u03c4X\u0304 Z\u0304 \u0232 0\n\n\fPart II\n\nQuantum Cryptography\n\n\f\f4\nchapter\n\nIntroduction\nIn this part of the thesis, we present our research in quantum cryptography, which offers\na secure alternative to some conventional cryptographic schemes that are rendered insecure\nby the potential emerge of large-scale quantum-computing. We also want to mention an actual implementation of quantum protocols within the research project MOBISEQ (\"Mobile\nQuantum Security\"), which is a joint project of the cryptology group from the computer\nscience department and the iNano center at the physics department, both at Aarhus University. The main goal of MOBISEQ is the development of technology for secure quantum\ncommunication that can compete with conventional methods on practicality, velocity and\nsecurity and that can be integrated into existing infrastructures. However, at the time of\nwriting, the implementation is still \"under construction\".\nIn the next sections, we will introduce the concept of mixed (classical) commitment\nschemes, since they are an important underlying construction in our quantum protocols.\nIn Chapter 5, we discuss our main result on improving the security of quantum protocols\nvia a commit&open step, based on these mixed commitments. We first introduce the setting\nand then propose a general compiler therein. We further show that the construction remains\nsecure in the case of noisy communication. We then proceed with combining the compilation\ntechnique with the bounded-quantum-storage model. Last, we show sequential composability\nand further use the extended commitment construction, discussed in Section 4.1.4, towards\na more general composition.\nIn Chapter 6, we discuss that the compiler can be applied to known protocols and show\ntwo example applications, with the result of achieving hybrid-secure protocols.\n\n4.1\n\nMixed Commitments\n\nCommitments were introduced on an intuitive level in Section 2.4.1 and capture the process\nof a party being committed to his message by the binding characteristic without immediately\nrevealing it to the other party due to the hiding aspect.\n\n4.1.1\n\nMotivation\n\nOur compiler construction in the following chapters requires a classical yet quantum-secure\ncommitment from B to A. Since we aim at preserving the unconditional security against\nA in the outer quantum protocols, the commitment can only be quantum-computationally\nbinding. As described in Section 3.5, the standard reduction from the computational security\n\n\f50\n\nCHAPTER 4. INTRODUCTION\nof the protocol to the computational binding property of the commitment would require\nrewinding B0 , which is not possible in the assumed protocol scenario.\nTherefore, we construct keyed commitment schemes, which are special in that they are\nmixed commitments or dual-mode commitments.1 Generally speaking, the notion of mixed\ncommitments requires some trapdoor information, related to the common reference string\nand given to the simulator in the ideal world. This trapdoor provides the possibility for\nextracting information out of the commitments, which finally allows us to circumvent the\nnecessity of rewinding B0 . We will discuss this in detail in Section 4.1.2. Additionally, we\nrequire that the basic mathematical assumption, which guarantees the hiding and binding\nproperties of the commitments, withstands quantum attacks. We will propose an actual\ninstantiation in Section 4.1.3.\n\n4.1.2\n\nIdea\n\nRecall that a keyed bit or string commitment C = commit pk (m, r) takes as input a message m and some randomness r of size polynomial in the security parameter, as well as a\npublic key pk. The message m can be a single bit b for the implementation of bit commitments or, in order to achieve string commitments, a bit-string m = b0 , . . . , bs . In order to\nopen the commitment, message m and random variable r are sent in plain and the receiver\ntherewith checks the correctness\nof C. Hiding is\u0001typically formalized by the requirement\n\u0001\npk, commit pk (m1 , r1 ) \u2248 pk, commit pk (m2 , r2 ) with different flavors of indistinguishability, while binding prohibits that there exist C, m1 , r1 , m2 , r2 , such that m1 6= m2 , but\ncommit pk (m1 , r1 ) = C = commit pk (m2 , r2 ) .\nWe construct our commitments in the CRS-model such that they provide dual modes\ndepending on the public key. In more detail, let commitK = (commit, GH , GB , xtr) denote a\n(keyed) mixed commitment scheme. The commitment key pk is generated by one of the\ntwo possible key-generation algorithms, GH or GB . Generator GB takes as input the security\nparameter \u03ba and generates a key pair (pk, sk) \u2190 GB , where pk \u2208 {0, 1}\u03ba is a public key and\nsk is the corresponding secret key. xtr is a poly-time extraction algorithm that takes sk\nand C as input and produces m as output, i.e., xtrsk (C) = xtrsk (commit pk (m, r) ) = m,\nwhich must hold for all pairs (pk, sk) generated by GB and for all values m, r. In other\nwords, the secret key sk allows to efficiently extract m from C, and as such the commitment\nis unconditionally binding. We often denote this type of key therefore by pkB. For a key\npk \u2190 GH , the commitment scheme is unconditionally hiding (and we often refer to this type\nas pkH). Furthermore, we need the unconditionally binding key pkB and the unconditionally\nhiding key pkH to be computationally indistinguishable even against quantum attacks, i.e.,\nq\npkB \u2248 pkH.\nWe want to stress that we can even weaken the assumption on the hiding key in that we\nmerely require that there exists a public-key encryption scheme where a random public key\nlooks pseudo-random to poly-time quantum circuits. Thus, commit does not require actual\nunconditionally hiding keys, but we can use uniformly random strings from {0, 1}\u03ba as such.\n1\n\nThe notions are interchangeable. The term of mixed commitments was introduced in [DN02].\nIn [DFL+ 09], the name dual-mode commitments was used to relate to the notion of a dual-mode cryptosystem [PVW08], which is similar in spirit, but slightly more involved. Last we want to mention that our\nschemes are similar to the commitment schemes used in [DFS04] but with extensions.\n\n\f4.1. MIXED COMMITMENTS\nThis is feasible in our proposed construction, sketched below, and still provides unconditional\nhiding, except with negligible probability. This fact also ensures that most keys of a specific\ndomain are in that sense unconditionally hiding keys.\nFinally, to avoid rewinding we use the following proof method: In the real-world protocol,\nB uses the unconditionally hiding key pkH to maintain unconditional security against any\nunbounded A. To argue security against a computationally bounded B0 , an informationtheoretic argument involving the simulator B\u03020 is given to prove that B0 cannot cheat with\nthe unconditionally binding key pkB. Security in real life then follows from the quantumcomputational indistinguishability of pkH and pkB.\n\n4.1.3\n\nInstantiations\n\nAs a candidate for instantiating our commitment construction, we propose the lattice-based\npublic-key encryption scheme of Regev [Reg05]. The crypto-system is based on the (conjectured) hardness of the learning with error (LWE) problem, which can be reduced from\nworst-case hardness of the approximation of the shortest vector problem (in its decision\nversion). Thus, breaking Regev's crypto-system implies an efficient algorithm for approximating the lattice problem in the worst-case, which is assumed to be hard even with quantum\ncomputing power.\nIn more detail, the crypto-system uses dimension n as security parameter and is parametrized by two integers m and p, where p is a prime bounded by n2 \u2264 p \u2264 2n2 , and a\nprobability distribution on Zp . A regular public key (in Zm\u00d7n\n) for Regev's scheme is proven\np\nto be quantum-computationally indistinguishable from the case where a public key is chosen\nfrom the uniform distribution, and therewith, independently from a secret key. In this case,\nthe ciphertext carries essentially no information about the message [Reg05, Lemma 5.4]. This\nproof of semantic security for Regev's crypto-system is in fact the property we require for\nour commitment, as the public key of a regular key pair can be used as the unconditionally\nbinding commitment key pkB in the ideal-world simulation. Then, for the real protocol, an\nunconditionally hiding commitment key pkH can simply be constructed by uniformly choosing\nnumbers in Zn\u00d7m\n. Both public keys will be of size \u00d5(n2 ), and the encryption process involves\np\nonly modular additions, which makes its use simple and efficient.2\nFor simplicity and efficiency, we use a common reference string, which allows us to use\nRegev's scheme in a simple way and, since it is relatively efficient, we get a protocol that\nis potentially practical. More specifically, in the CRS-model we assume the key pkB for the\ncommitment scheme, generated by GB , to be contained in the common reference string. We\nwant to stress however that we show in Part III, Section 10.3, how to avoid the CRS-model at\nthe cost of a non-constant round construction, where we let the parties generate a common\nreference string jointly by coin-flipping.\nFor the compiler construction here, we will use Regev's original version, as we require\nbit commitments. However, a multi-bit variant of Regev's scheme is given in the full version\nof [PVW08]. All requirements as described above are maintained in this more efficient\nvariant, which improves the performance of Regev's scheme by essentially a factor of n, e.g.,\nthe scheme can encrypt n bits using \u00d5(n) bits. We use later in Part III, Chapter 9, that\n2\n\nThe notation \u00d5(*) is similar to the asymptotic Landau notation O(*) but ignores logarithmic factors.\n\n51\n\n\f52\n\nCHAPTER 4. INTRODUCTION\nthis implies that we can flip a \u03bb-bit string using O(\u03bb) bits of communication when \u03bb is large\nenough. We also rely on this multi-bit version for our extended commitment construction,\nwhich we will describe in the next Section 4.1.4 and then use in Section 5.5.2, where we show\nhow to achieve efficient simulation also against a dishonest A0 .\n\n4.1.4\n\nExtended Construction\n\nTo achieve efficient simulation against both players, i.e. additional efficient simulation also\nagainst A0 (in Section 5.5.2), we need to extend our commitments by yet another trapdoor,\nwhich provides the commitment with equivocability. Intuitively, this means that we now\nenable the simulator in the ideal world that it can construct commitments equivocally such\nthat it can open them later to different bits. As we still need in addition the properties of\nthe mixed commitment scheme of Section 4.1.2 in its multi-bit variant, we will build the new\nscheme around it, such that its trapdoor can still be used for extraction.\nThe new extension is based on the idea of UC-commitments [CF01] and requires a \u03a3protocol for a (quantumly) hard relation R = {(x, w)}, i.e. an honest-verifier perfect zeroknowledge proof of knowledge with\n\u0001 instance x and witness w (see also Section 2.4.5). Conversations are of form a\u03a3 , c\u03a3 , z\u03a3 , where the prover sends a\u03a3 , the verifier challenges him with\nbit c\u03a3 , and the prover replies with z\u03a3 . For practical candidates of R, see e.g. [DFS04]. By\nspecial soundness,\nit holds \u0001that from two accepting conversations with different challenges,\n\u0001\ni.e. a\u03a3 , 0, z\u03a30 and a\u03a3 , 1, z\u03a31 , the simulator can extract w such that (x, w) \u2208 R.\nIn real life, the common reference string consists of commitment key pkH and instance\nx. To commit to a bit b, the committer\nB first runs the honest-verifier simulator\u0001 to get,\n\u0001\n\u03a3\n\u03a3\non input x, a conversation a , b, z . Then, he commits by sending a\u03a3 , C0 , C1 , where\n0\nCb = commit pkH (z\u03a3 b , rb ) and C1\u2212b = commit pkH (0z , r1\u2212b ) with randomness rb , r1\u2212b and\nz 0 = |z\u03a3 |. To open a \u0001commitment, B reveals b and opens Cb by sending z\u03a3 b , r. The receiver\nchecks that a\u03a3 , b, z\u03a3 is a valid conversation and that Cb was correctly opened. Assuming\nthat the \u03a3-protocol is honest-verifier perfect zero-knowledge and pkH provides unconditional\nhiding, the new commitment construction is again unconditionally hiding.\nIn the ideal world, we assume that the simulator (simulating against A0 ) knows w such\nthat (x, w)\n\u0001 \u2208 R (and public\n\u0001 key pkH). Therewith, it can compute two valid conversations\na\u03a3 , 0, z\u03a3 0 and a\u03a3 , 1, z\u03a3 1 and set C0 = commit pkH (z\u03a3 0 , r0 ) and C1 = commit pkH (z\u03a3 1 , r1 ) .\nThis enables to open both ways, assuming the knowledge of the trapdoor w.\nWe maintain extraction, since in the respective simulation against B0 , the public key is\nchosen in a different but indistinguishable way, namely as (x, pkB), where pkB is the binding\ncommitment key, generated together with sk. Now, given a commitment (a, C0 , C1 ), the\nsimulator can decrypt C0 , C1 to determine which of them contains a valid reply z\u03a3 b of the\n\u03a3-protocol. The only way this could fail is in the case where both C0 and C1 contain valid\nreplies, which would imply that the committer B0 could compute a valid w. For a polynomialtime bounded committer and a (quantumly) hard relation R, however, this can occur only\nwith negligible probability.\n\n\f5\nchapter\n\nImproved Security for\nQuantum Protocols\nHere, we propose a general compiler for improving the security of two-party quantum protocols, implementing different cryptographic tasks and running between mutually distrusting\nplayers Alice and Bob. The compiler extends security against an \"almost honest\" adversary\nby security against an arbitrary computationally bounded (quantum) adversary. Furthermore, we can achieve hybrid security such that certain protocols can only be broken by an\nadversary who has large quantum memory and large computing power. The results in this\nchapter are joint work with Damg\u00e5rd, Fehr, Salvail and Schaffner, and appeared in [DFL+ 09].\n\n5.1\n\nMotivation\n\nOur proposed compiler applies to a large class of quantum protocols, namely to so-called\nBB84-type protocols that follow a particular but very typical construction design for quantum\ncommunication. Our main result states that if the original protocol is secure against a socalled benign Bob who is only required to treat the qubits \"almost honestly\" but can deviate\narbitrarily afterwards, then the compiled protocol is secure against a computationally bounded\nquantum Bob. The unconditional security against Alice that BB84-type protocols usually\nachieve is preserved during compilation and it requires only a constant increase of transmitted\nqubits and classical messages.\nIn other words, with our compiler, one can build a protocol for any two-party functionality\nby designing a protocol that only has to be secure if Bob is benign, which is a relatively weak\nassumption. On the other hand, many protocols following the BB84-type pattern (at least\nafter some minor changes) have been proposed, e.g. for Oblivious Transfer, Commitment, and\nPassword-Based Identification [CK88, DFSS08, DFR+ 07, DFSS07]. Typically, their proofs go\nthrough under our assumption. For instance, our compiler can easily be applied to existing\nquantum protocols implementing ID and OT, which we will show as example applications in\nChapter 6.\nIn more detail, the compiler incorporates the mixed commitment scheme, discussed in\nSection 4.1, into the basic protocols with Bob as committer. Recall that we need such\na mixed commitment to preserve the unconditional security against Alice that BB84-type\nprotocols typically achieve but cannot apply the typical reduction from the computational\nsecurity of the protocol to the computational binding property of the commitment, due to\n\n\f54\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\nthe restrictions on rewinding in the quantum world (see Section 3.5). The idea of introducing a (plain) commitment in quantum protocols has already been sketched in other works,\nfor instance, in [CK88, BBCS91]. Furthermore, there are partial results, investigating this\nscenario, e.g. [Yao95, CDMS04, May96]. We will go into more details of preceding work in\nSection 6.1.\nPreviously, it was very unclear what exactly such a Commit&Open-step would achieve in\nthe quantum world. The intuition is clearly that if Bob passes the test, he must have measured most of his qubits, also in the remaining untested subset. But-to our best knowledge-\nit was never formally proven that the classical intuition also holds for a quantum Bob. We\nnow give a full characterization of Commit&Open in our quantum setting, namely that it\nforces Bob to be benign, for which we propose a formal definition and which might be of\nindependent interest. These aspects are covered in Section 5.2. In this context, we want\nto mention the follow-up work in [BF10]. They phrase the Commit&Open-approach more\nclearly as the quantum version of classical sampling, and additionally, investigate sampling\nin quantum settings more generally.\nIn Section 5.3, we generalize our result to noisy quantum communication. Furthermore,\nsecurity in the bounded-quantum-storage model that assumes the adversary's quantum storage to be of limited size, implies benign security. Therefore by compilation of such protocols, we can achieve hybrid security, which means that the adversary now needs both large\nquantum memory and large quantum computing power to break these new protocols. The\npreservation of BQSM-security allows us to get security properties that classical protocols\ncannot achieve, if the assumption on the limited quantum memory holds-which definitely\nis the case with current state-of-the-art (Section 5.4). However, if the assumption should fail\nand the adversary could perfectly store all qubits sent, the known protocols can be easily\nbroken. Thus, by applying our compiler, we obtain another security layer that equips such\nprotocols with additional quantum-computational security. Last, we sketch that the compiled protocols in their basic form remain sequentially composable. Moreover, by using the\nextended commitment construction of Section 4.1.4, we achieve efficient simulations on both\nsides, and therewith, a more general composition. This result is discussed in Section 5.5.\n\n5.2\n\nIntroducing Commit&Open\n\nWe now discuss our compiler construction in detail, starting from describing the form of\nBB84-type protocols and formalizing our notion of benignity. Then, we show the transformation from benign security towards computational security and conclude with its proof.\n\n5.2.1\n\nInitial situation\n\nWe consider quantum two-party protocols that follow a particular but very typical construction design. These protocols consist of two phases, called preparation and post-processing\nphase. We call such a protocol a BB84-type protocol, as they have the same structure and\nthe same encoding scheme as the first (complete) quantum protocol by Bennett and Brassard\nin 1984 for quantum key distribution [BB84]. However, we want to stress again that we are\ninterested in protocols for cryptographic tasks other than key distribution, and therewith,\n\n\f5.2. INTRODUCING COMMIT&OPEN\n\nProtocol \u03a0\nPreparation:\nA chooses x \u2208R {0, 1}n and \u03b8 \u2208R {+, \u00d7}n and sends |xi\u03b8 to B, and B chooses\n\u03b8\u0302 \u2208R {0, 1}n and obtains x\u0302 \u2208 {0, 1}n by measuring |xi\u03b8 in bases \u03b8\u0302.\nPost-processing:\nArbitrary classical communication and classical local computations.\n\nFigure 5.1: The Generic BB84-type Quantum Protocol \u03a0.\nwe also consider the case of dishonest players. A generic BB84-type protocol \u03a0 is specified\nin Figure 5.1.\nIn the preparation phase, Alice transmits n random BB84-qubits to Bob. More specifically, Alice chooses a random bit string x = x1 , ..., xn and a random basis-string \u03b8 = \u03b81 , ..., \u03b8n\nfrom a set of two conjugate bases, encodes her qubits accordingly, i.e., xi is encoded in the\nstate of the ith particle using basis \u03b8i , and sends them to Bob. Bob chooses a basis-string\n\u03b8\u0302 = \u03b8\u03021 , .., \u03b8\u0302n and measures the ith particle in basis \u03b8\u0302i . If Bob plays honestly, he learns xi\nwhenever the bases match, i.e. \u03b8\u0302i = \u03b8i . Otherwise, he gets a random independent result.\nThe second phase of the protocol, the post-processing, consist of arbitrary classical messages\nand local computations, depending on the task at hand.\nHowever, the fact that all BB84-type protocols have in common is that the classical\npost-processing typically relies on Bob's subsets of correct and random outcomes, or in\nother words, on the fact that a dishonest Bob has high uncertainty about a crucial piece of\ninformation. Thus, BB84-type protocols-in their basic form-may be broken by a dishonest\nBob, who does not measure the qubits immediately. This is due to the fact that Alice typically\nreveals \u03b8 at a later stage so that Bob knows the correct subset. However, a dishonest Bob\ncould measure all stored qubits in matching bases \u03b8\u0302 = \u03b8, and thus, learn more information\nthan he was supposed to.\nThis aspect is captured in our definition of security against a benign Bob, or more precisely\na \"benignly dishonest\" Bob, who treats the qubits \"almost honestly\" in the preparation phase\nbut can deviate arbitrarily otherwise. Note that, in contrast to Bob's situation, BB84-type\nprotocols typically achieve unconditional security against cheating by Alice in their default\nform. On a very intuitive level, it should now be evident that we want to enforce Bob's\nmeasurement upon qubit reception before any further announcement by Alice. In the next\nsection, we will make this definition more formal.\n\n5.2.2\n\nSecurity against Benign Bob\n\nThe following security definition captures information-theoretic security against a benign\nBob. Recall that such a dishonest Bob is benign in that, in the preparation phase, he does\nnot deviate (too much) from what he is supposed to do. In the post-processing phase, though,\nhe may be arbitrarily dishonest.\nTo make this description formal, we fix an arbitrary choice of \u03b8 and an arbitrary value\n\n55\n\n\f56\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\nfor the classical information, z, which Bob may obtain as a result of the preparation phase\n(i.e. z = (\u03b8\u0302, x\u0302) in case Bob is actually honest). Let X denote the random variable describing\nthe bit-string x, where we understand the distribution PX of X to be conditioned on the\nfixed choices for \u03b8 and z. Furthermore, let \u03c1E be the state of Bob's quantum register E\nafter the preparation phase. Note that, still with fixed \u03b8 and z, \u03c1E is of the form \u03c1E =\nP\nx\nx\nx PX (x)\u03c1E , where \u03c1E is the state of Bob's quantum register in case X takes on the value\nx\nx. In general, the \u03c1E may be\n\u0001 mixed, but we can think of them as being reduced pure states\nx ih\u03c8 x | for a suitable register R and pure states |\u03c8 x i. We then call\nwith \u03c1xE = trR |\u03c8P\nER\nER\nER\nx ih\u03c8 x | a point-wise purification (with respect to X) of \u03c1 .\nthe state \u03c1ER = x PX (x)|\u03c8ER\nE\nER\nObviously, in case Bob is honest, Xi is fully random whenever \u03b8i 6= \u03b8\u0302i , and we have\n\u0001\n\u0001\nH\u221e X|I X|I \u0304 = x|I \u0304 = dH \u03b8|I , \u03b8\u0302|I ,\nfor every I \u2286 {1, . . . , n} and every x|I , where I \u0304 denotes the complementary set. In that case,\nBob does not store any non-trivial quantum state so that R is \"empty\" and\nH0 (\u03c1ER ) = H0 (\u03c1E ) = 0 .\nA benign Bob B0 is now specified to behave close-to-honestly in the preparation phase\nin that, after the preparation, he produces an auxiliary output \u03b8\u0302. Given this output, we are\nin a certain sense close to the ideal situation\nwhere Bob really measured in basis \u03b8\u0302 as far\n\u0001\nas the values of H\u221e X|I X|I \u0304 = x|I \u0304 and H0 (\u03c1ER ) are concerned.1 Informally speaking,\nthe following definition states (under Point (1.)) that there exists a string \u03b8\u0302 of B0 's measurement bases, such that the uncertainty about A's bit xi is essentially 1 whenever \u03b8i 6= \u03b8\u02c6i .\nFurthermore, B0 's quantum storage is small.\nDefinition 5.1 (Unconditional security for Alice against benign Bob) A BB84-type\nquantum protocol \u03a0 securely implements F against a \u03b2-benign B0 for some parameter \u03b2 \u2265 0,\nif it securely implements F according to Definition 3.5, with the following two modifications:\n1. The quantification is over all B0 with the following property: After the preparation phase\nB0 either aborts, or else produces an auxiliary output \u03b8\u0302 \u2208 {+, \u00d7}n . Moreover, the joint\nstate of A and B0 after \u03b8\u0302 has been output is statistically indistinguishable from a state\nfor which it holds that, for any fixed values for \u03b8, \u03b8\u0302 and z, for any subset I \u2286 {1, . . . , n},\nand for any x|I \u0304,\n\u0001\n\u0001\nH\u221e X|I X|I \u0304 = x|I \u0304 \u2265 dH \u03b8|I , \u03b8\u0302|I \u2212 \u03b2n\n\nand\n\n\u0001\nH0 \u03c1ER \u2264 \u03b2n ,\n\n(5.1)\n\nwhere \u03c1ER is a point-wise purification of \u03c1E with respect to X.\n2. B\u03020 's running time is polynomial in the running time of B0 .\n1\n\nThe reason why we consider the point-wise purification of \u03c1E is to prevent Bob from artificially blowing\nup H0 (\u03c1ER ) by locally generating a large mixture or storing an unrelated mixed input state.\n\n\f5.2. INTRODUCING COMMIT&OPEN\n\nProtocol C \u03b1 (\u03a0) :\nPreparation:\nA chooses x \u2208R {0, 1}m and \u03b8 \u2208R {+, \u00d7}m and sends |xi\u03b8 to B. Then, B chooses\n\u03b8\u0302 \u2208R {0, 1}m and obtains x\u0302 \u2208 {0, 1}m by measuring |xi\u03b8 in bases \u03b8\u0302.\nVerification:\n1. B commits to \u03b8\u0302 and x\u0302 position-wise by ci := commit ((\u03b8\u0302i , x\u0302i ), ri ) with randomness ri for i = 1, . . . , m. He sends the commitments to A.\n2. A sends a random test subset T \u2282 {1, . . . , m} of size \u03b1m. B opens ci for all\ni \u2208 T . A checks that the openings are correct and that xi = x\u0302i whenever\n\u03b8i = \u03b8\u0302i . If all tests are passed, A accepts. Otherwise, she rejects and aborts.\n3. The tested positions are discarded by both parties: A and B restrict x and \u03b8,\nrespectively \u03b8\u0302 and x\u0302, to i \u2208 T\u0304 .\nPost-processing:\nAs in \u03a0 (with x, \u03b8, x\u0302 and \u03b8\u0302 restricted to positions i \u2208 T\u0304 ).\n\nFigure 5.2: The Compiled Protocol C \u03b1 (\u03a0).\n\n5.2.3\n\nFrom Benign to Computational Security\n\nWe now show a generic compiler which transforms any BB84-type protocol into a new quantum protocol for the same task. The compiler achieves that, if the original protocol is unconditionally secure against dishonest Alice and unconditionally secure against benign Bob,\nthen the compiled protocol remains to be unconditionally secure against dishonest Alice but\nis now computationally secure against an arbitrary dishonest Bob.\nThe idea behind the construction of the compiler is to incorporate a commitment scheme\nand force Bob to behave benignly by means of the Commit&Open-procedure. More precisely,\nwe let Bob classically and position-wise commit to all his measurement bases and outcomes.\nThen Alice chooses a random test-subset of size \u03b1m and checks by Bob's openings that\nthe bits coincide whenever the bases match. If the test is passed, the post-processing is\nconducted on the remaining unopened positions. Otherwise, Alice aborts. Figure 5.2 shows\nthe compilation of an arbitrary BB84-type protocol \u03a0. The quantum communication is\nincreased from n to m = n/(1 \u2212 \u03b1) qubits, where 0 < \u03b1 < 1 is an additional parameter\nthat can be arbitrarily chosen, and the compiled protocol requires three more rounds of\ninteraction.\nAlthough apparently simple-intuition clearly suggests that if Bob passes the measurement test, he must have measured most of his qubits, also in the remaining untested subset-\nthis Commit&Open approach is not trivial to rigorously prove for a quantum Bob. Moreover,\nin order to preserve unconditional security against dishonest Alice, the commitment scheme\nneeds to be unconditionally hiding, and so can be at best quantum-computationally binding.\nFor a plain commitment scheme however, the common reduction from computational security of the protocol C \u03b1 (\u03a0) to the computational binding property of a commitment scheme\n\n57\n\n\f58\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\nwould require rewinding, but we do not know of any technique for our protocol structure\n(see also Section 3.5 for an elaborated discussion).\nTherefore, we use our mixed dual-mode commitment construction commit from Section 4.1 that allows use to circumvent the necessity of rewinding. Recall that commit is a\nkeyed dual-mode commitment scheme with unconditionally hiding key pkH, generated by\nGH , and unconditionally binding key pkB, generated by GB along with a secret key sk that\nq\nallows to efficiently extract m from commit pkB (m, r) . Furthermore, we have that pkH \u2248 pkB.\nFor simplicity and efficiency, we consider the CRS-model, and we assume the key pkB for\nthe commitment scheme, generated according to GB , to be contained in the common reference string. We discuss in Section 10.3.2 how to avoid the CRS-model, at the cost of\na non-constant round construction where the parties generate a common reference string\njointly by coin-flipping. Such an approach allows us to implement the entire application\nwithout any set-up assumptions. With our dual-mode commitment scheme, we arrive at the\nfollowing theorem, capturing the compilation of any protocol from benign security towards\ncomputational security.\nTheorem 5.1 (Compiler) Let \u03a0 be a BB84-type protocol, unconditionally secure against\ndishonest Alice and against \u03b2-benign Bob for some constant \u03b2 \u2265 0. Consider the compiled\nprotocol C \u03b1 (\u03a0) for arbitrary \u03b1 > 0, where the commitment scheme is instantiated by a dualmode commitment scheme. Then, C \u03b1 (\u03a0) is unconditionally secure against dishonest Alice\nand quantum-computationally secure against dishonest Bob in the CRS-model.\n\u03b1 (\u03a0) for the compiled protocol C \u03b1 (\u03a0) to stress that key\nProof. We sometimes write CpkH\npkH, produced by GH , is used for the dual-mode commitment scheme. Analogously, we write\n\u03b1 (\u03a0) when key pkB, produced by G , is used instead.\nCpkB\nB\nCorrectness is trivially checked. In order to show unconditional security against A0 , first\nnote that the unconditionally hiding property of the commitment ensures that A0 does not\nlearn any additional information. Furthermore, as the ideal-world adversary \u00c20 is not required\nto be poly-time bounded, according to Definition 3.6, \u00c20 can break the binding property of\nthe commitment scheme, and thereby, perfectly simulate the behavior of honest B towards\nA0 attacking C \u03b1 (\u03a0). The issue of efficiency of the ideal-life adversaries will be addressed in\nSection 5.5.\nAs for computational security against dishonest Bob, according to Definition 3.7, we\nneed to prove that for every real-world adversary B0 \u2208 Bpoly attacking C \u03b1 (\u03a0), there exists a\nsuitable ideal-world adversary B\u03020 \u2208 Bpoly attacking F such that\nC \u03b1 (\u03a0)\n\nq\n\noutA,B0 \u2248 outF\n.\n\u00c2,B\u03020\n\n(5.2)\n\nFirst, note that by the computational indistinguishability of pkH and pkB,\nC \u03b1 (\u03a0)\n\nC \u03b1 (\u03a0)\n\npkH\noutA,B0 = outA,B\n0\n\nq\n\nC \u03b1 (\u03a0)\n\npkB\n\u2248 outA,B\n0\n\n.\n\n(5.3)\n\nThen, we construct an adversary B0\u25e6 \u2208 Bpoly who attacks the unconditional security against\nbenign Bob of protocol \u03a0, and which satisfies\nC \u03b1 (\u03a0)\n\npkB\noutA,B\n0\n\n= out\u03a0\nA\u25e6 ,B0\u25e6 ,\n\n(5.4)\n\n\f5.2. INTRODUCING COMMIT&OPEN\n\n59\n\nA\nA\u25e6\n\nC \u03b1 (\u03a0)\n\u00c3\n\n\u03a0\n\nB0\n\nB0\u25e6\n\nFigure 5.3: Constructing an attacker B0\u25e6 against \u03a0 from an attacker B0 against C \u03b1 (\u03a0).\nwhere A\u25e6 honestly executes \u03a0. We define B0\u25e6 in the following way. Consider the execution of\nC \u03b1 (\u03a0) between A and B0 . We split entity A into two players A\u25e6 and \u00c3, where we think of \u00c3\nas being placed in between A\u25e6 and B0 . The splitted entities of this proof are also depicted in\nFigure 5.3. A\u25e6 plays honest A's part of \u03a0. \u00c3 can be understood as completing Commit&Open.\nMore specifically, \u00c3 acts as follows. It receives n qubits from A\u25e6 and produces \u03b1n/(1 \u2212 \u03b1)\nrandom BB84-qubits of its own. Then, it interleaves the produced qubits randomly with\nthe received qubits and sends the resulting m = n/(1 \u2212 \u03b1) qubits to B0 . \u00c3 then completes\nthe verification step of C \u03b1 (\u03a0) with B0 , asking him to have the commitments opened which\ncorrespond to \u00c3's produced qubits. If this results in accept, \u00c3 lets A\u25e6 finish the protocol\nwith B0 . Note that pair (A\u25e6 , \u00c3) does exactly the same as A.\nHowever, we can also move the actions of \u00c3 to B0 's side, and define B0\u25e6 as follows. B0\u25e6\nsamples (pkB, sk) according to GB and executes \u03a0 with A by locally running \u00c3 and B0 , using pkB as commitment key. If \u00c3 accepts the verification, then B0\u25e6 outputs \u03b8\u0302 \u2208 {0, 1}n (as\nrequired from a benign Bob), obtained by decrypting the unopened commitments with the\nhelp of sk. Otherwise, B0\u25e6 aborts at this point. It is now clear that Eq. (5.4) holds. Exactly\nthe same computation takes place in both \"experiments\", the only difference being that they\nare executed partly by different entities.\nThe last step is to show that, for some B\u03020 ,\ns\n\nF\nout\u03a0\nA\u25e6 ,B0\u25e6 \u2248 out\u00c2,B\u03020 .\n\n(5.5)\n\nEq. (5.5) actually claims that \u00c20 and B\u03020 successfully simulate A\u25e6 and B0\u25e6 executing \u03a0. This\nfollows by assumption of benign security of \u03a0, if we can show that B0\u25e6 is \u03b2-benign, according to\nDefinition 5.1, for any \u03b2 \u2265 0. We show this in the following subsection, or more precisely, we\nprove that the joint state of A\u25e6 , B0\u25e6 after the preparation phase is statistically indistinguishable\nfrom a state \u03c1Ideal which satisfies the bounds in Eq. (5.1) of Definition 5.1. We conclude the\ncurrent proof by claiming that Theorem 5.1 follows from Eqs. (5.3) \u2013 (5.5) together.\n\u0004\n\n5.2.4\n\nProof of Bounds on Entropy and Memory Size\n\n\u03b1 (\u03a0)\nRecall that A\u25e6 executing \u03a0 with B0\u25e6 can equivalently be thought of as A executing CpkB\nwith B0 (Figure 5.3). Furthermore, a joint state of A, B0 is clearly also a joint state of A\u25e6 , B0\u25e6 .\nTo show the existence of \u03c1Ideal for A\u25e6 , B0\u25e6 as promised above, it therefore suffices to show such\n\n\f60\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\n\n\u03b1 (\u03a0) :\nProtocol EPR-CpkB\n\nPreparation:\nA prepares m EPR-pairs\n\n\u221a1 (|00i + |11i)\n2\n\nand sends the second qubit in each pair to\n\nB, while keeping the other qubits in register A = A1 * * * Am . B chooses \u03b8\u0302 \u2208R {0, 1}m\nand obtains x\u0302 \u2208 {0, 1}m by measuring the received qubits in bases \u03b8\u0302.\nVerification:\n1. B commits to \u03b8\u0302 and x\u0302 position-wise by ci := commit ((\u03b8\u0302i , x\u0302i ), ri ) with randomness ri for i = 1, . . . , m. He sends the commitments to A.\n2. A sends a random test subset T \u2282 {1, . . . , m} of size \u03b1m. B opens ci for all\ni \u2208 T . A chooses \u03b8 \u2208R {+, \u00d7}m , measures registers Ai with i \u2208 T in basis\n\u03b8\u0302i to obtain xi , and checks that the openings are correct and that xi = x\u0302i\nwhenever \u03b8i = \u03b8\u0302i for i \u2208 T . If all tests are passed, A accepts. Otherwise,, she\nrejects and aborts.\n3. A measures the remaining registers in basis \u03b8|T\u0304 to obtain x|T\u0304 . The tested\npositions are discarded by both parties: A and B restrict x and \u03b8, respectively\n\u03b8\u0302 and x\u0302, to i \u2208 T\u0304 .\nPost-processing:\nAs in \u03a0 (with x, \u03b8, x\u0302 and \u03b8\u0302 restricted to positions i \u2208 T\u0304 ).\n\n\u03b1 (\u03a0).\nFigure 5.4: The EPR-version of CpkB\n\n\u03b1 (\u03a0) with honest\na state for A, B0 . In other words, we need to show that the execution of CpkB\nA and arbitrarily dishonest B0 -after verification-will be close to a state where Eq. (5.1)\nholds.\nTo show this closeness,\n\u221a we consider an equivalent EPR-version, where Alice creates m\nEPR-pairs (|00i + |11i)/ 2, sends one qubit in each pair to Bob, and keeps the others in\nregister A. Then, Alice can measures her qubits only when needed, namely, she measures\nthe qubits within T in Step (2.) of the verification phase, and the remaining qubits at the\nend of the verification phase. With respect to the information Alice and Bob obtain, this\n\u03b1 (\u03a0) based on single qubits, since the\nEPR-version is identical to the original protocol CpkB\nonly difference is the point in time when Alice obtains certain information.\nWe can further modify the procedure without affecting Eq. (5.1) as follows. Instead of\nmeasuring her qubits in T in her basis \u03b8|T , Alice measures them in Bob's basis \u03b8\u0302|T . However,\nshe still verifies only whether xi = x\u0302i for those i \u2208 T with \u03b8i = \u03b8\u0302i . Because the positions i \u2208 T\nwith \u03b8i 6= \u03b8\u0302i are not used in the protocol at all, this change has no effect. As the commitment\nscheme is unconditionally binding, if key pkB is used, Bob's basis \u03b8\u0302 is well defined by his\ncommitments (although hard to compute), even if Bob is dishonest. The resulting scheme is\ngiven in Figure 5.4.\n\u03b1 (\u03a0) in Figure 5.4 with an honest A and a dishonest\nWe consider an execution of EPR-CpkB\nB0 , and we fix \u03b8\u0302 and x\u0302, determined by B0 's commitments. Let |\u03c6AE i \u2208 HA \u2297 HE be the state\n\n\f5.2. INTRODUCING COMMIT&OPEN\n\n61\n\nof the joint system right before Step (2.) of the verification phase. Since we are anyways\ninterested in the point-wise purification of B0 's state, we may indeed assume this state to be\npure. If it is not pure, we purify it and carry the purifying register R along with E.\nClearly, if B0 had honestly done his measurements then, for some |\u03c6E i \u2208 HE ,\n|\u03c6AE i = |x\u0302i\u03b8\u0302 \u2297 |\u03c6E i .\nIn this case, the quantum memory E would be empty, i.e.,\nH0 (|\u03c6E ih\u03c6E |) = 0 ,\nand the uncertainty about X, obtained when measuring A|T\u0304 in basis \u03b8|T\u0304 would be maximal\nin the sense that it would be exactly one bit in each position with non-matching bases, i.e.,\nH\u221e (X) = dH (\u03b8|T\u0304 , \u03b8\u0302|T\u0304 ) .\nWe now show that the verification phase enforces these properties for an arbitrary dishonest B0 , at least approximately in the sense of Eq. (5.1). Recall that T \u2282 {1, . . . , m} is\nrandom subject to |T | = \u03b1m. Furthermore, for fixed \u03b8\u0302 but randomly chosen \u03b8, the subset\nT 0 = {i \u2208 T : \u03b8i = \u03b8\u0302i } is a random subset (of arbitrary size) of T . Let the random variable\nTest describe the choice of test = (T, T 0 ) as specified above, and consider the state \u03c1TestAE ,\nconsisting of the classical Test and the quantum state |\u03c6AE i with\n\u03c1TestAE = \u03c1Test \u2297 |\u03c6AE ih\u03c6AE | =\n\nX\n\nPTest (test)|testihtest| \u2297 |\u03c6AE ih\u03c6AE | .\n\ntest\n\nRecall that rH (*, *) denotes the relative Hamming distance between two strings (see\nEq. (3.22)). The following lemma shows that, we are in state \u03c1TestAE close to an \"ideal\nstate\" \u03c1\u0303TestAE , capturing a situation , where for any choice of T and T 0 and for any outcome\nx|T when measuring A|T in basis \u03b8\u0302|T , the relative error rH (x|T 0 , x\u0302|T 0 ) (the test estimate)\ngives an upper bound (which holds with probability 1) on the relative error rH (x|T\u0304 , x\u0302|T\u0304 ) one\nwould obtain by measuring the remaining subsystems Ai with i \u2208 T\u0304 in basis \u03b8\u0302i .\nLemma 5.1 For any \u03b5 > 0, x\u0302 \u2208 {0, 1}m and \u03b8\u0302 \u2208 {+, \u00d7}m , the state \u03c1TestAE is negligibly\nclose (in m) to a state\n\u03c1\u0303TestAE =\n\nX\n\ntest\nPTest (test)|testihtest| \u2297 \u03c6\u0303test\nAE \u03c6\u0303AE ,\n\ntest\n\nwhere for any test = (T, T 0 ), we have\n\u03c6\u0303test\nAE =\n\nX\n\nx\n\u03b1xtest |xi\u03b8\u0302 |\u03c8E\ni,\n\nx\u2208Btest\nx\nfor Btest = {x \u2208 {0, 1}m | rH (x|T\u0304 , x\u0302|T\u0304 ) \u2264 rH (x|T 0 , x\u0302|T 0 ) + \u03b5} and arbitrary coefficients \u03b1test\n\u2208\nC.\n\n\f62\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\nWe want to point out that the \"ideal state\" |\u03c6\u0303test\nAE i in the remaining subsystem after the\ntest is a superposition of states with relative Hamming distance upper bounded by the test\nestimate (plus a small error \u03b5). This is the case, since we sum over all x restricted to the set\nx i depends on x, which means,\nspecifying exactly that, and also note that B0 's subsystem |\u03c8E\ninformally speaking, only such states survive. Yet in other words, we are indeed left with a\nsuperposition over all strings that have relative Hamming distance \u03b5-close to the estimate of\nthe test.\nProof. For any test, we let |\u03c6\u0303test\nAE i be the renormalized projection of |\u03c6AE i into the subspace\ntest\u22a5 i be the renormalized projection of |\u03c6\nspan{|xi\u03b8\u0302 | x \u2208 Btest }\u2297HE and we let |\u03c6\u0303AE\nAE i into the\ntest\n\u22a5\ntest\u22a5\northogonal complement, such that |\u03c6AE i = \u03b5test |\u03c6\u0303AE i + \u03b5test |\u03c6\u0303AE i with \u03b5test = h\u03c6\u0303test\nAE |\u03c6AE i\ntest\u22a5 |\u03c6\ntest i is of the form as required in the statement\nand \u03b5\u22a5\n=\nh\n\u03c6\u0303\ni.\nBy\nconstruction,\n|\n\u03c6\u0303\nAE\ntest\nAE\nAE\nof the lemma. A basic property of the trace norm of pure states leads to\np\n\u0001 q\ntest\n2 =\n\u03c6\n|\n1 \u2212 |\u03b5test |2 = |\u03b5\u22a5\n= 1 \u2212 | \u03c6\u0303test\n\u03b4 |\u03c6AE ih\u03c6AE |, \u03c6\u0303test\nAE\ntest | .\nAE \u03c6\u0303AE\nAE\nThis last term corresponds to the square root of the probability, when given test, to observe\na string x 6\u2208 Btest when measuring subsystem A of |\u03c6AE i in basis \u03b8\u0302. Furthermore, using\nelementary properties of the trace norm with Jensen's inequality2 gives\n\u0013\n\u0012X\n\u0001 2\n\u00012\ntest\ntest\n\u03b4 \u03c1TestAE , \u03c1\u0303TestAE =\nPTest (test) \u03b4 |\u03c6AE ih\u03c6AE |, \u03c6\u0303AE \u03c6\u0303AE\ntest\n\n=\n\n\u0012X\n\n\u00132\n\nPTest (test) |\u03b5\u22a5\ntest |\n\ntest\n\n\u2264\n\nX\n\n2\nPTest (test) |\u03b5\u22a5\ntest | ,\n\ntest\n\nwhere the last term is the probability to observe a string x 6\u2208 Btest when choosing test\naccording to PTest and measuring subsystem A of |\u03c6AE i in basis \u03b8\u0302. This situation, though, is\na classical sampling problem, for which it is well known that for any measurement outcome\nx, the probability (over the choice of test) that x 6\u2208 Btest is negligible in m (see e.g. [Hoe63]).\nThus, it follows that state \u03c1TestAE is negligibly close (in m) to state \u03c1\u0303TestAE .\n\u0004\nNext, we need a preliminary lemma, stating that a pure state can be written as a \"small\nsuperposition\" of basis vectors.\nP\nLemma 5.2 Let |\u03c6AE i \u2208 HA \u2297 HE be a state of the form |\u03c6AE i = i\u2208J \u03b1i |ii|\u03c6iE i, where\n{|ii}i\u2208I is a basis of HA and J \u2286 I. Then, the following holds.\nP\n1. Let \u03c1\u0303AE = i\u2208J |\u03b1i |2 |iihi| \u2297 |\u03c6iE ih\u03c6iE |, and let W , and W\u0303 , be the outcome of measuring\nA of |\u03c6AE i, respectively of \u03c1\u0303AE , in some basis {|wi}w\u2208W . Then,\nH\u221e (W ) \u2265 H\u221e (W\u0303 ) \u2212 log |J| .\n2. The reduced density matrix \u03c1E = trA (|\u03c6AE ih\u03c6AE |) has max-entropy\nH0 (\u03c1E ) \u2264 log |J| .\n2\n\nIn this context, we use Jensen's inequality with f\nfunction f .\n\nP\n\ni\n\n\u0001 P\npi xi \u2264 i pi f (xi ), for positive pi and real convex\n\n\f5.2. INTRODUCING COMMIT&OPEN\n\n63\n\nNote that when using Renner's definition for conditional min-entropy of [Ren05] under\nPoint (1.), one can actually show that H\u221e (W |E) \u2265 H\u221e (W\u0303 |E) \u2212 log |J|.\nProof. For Point (1.), we may understand \u03c1\u0303AE as being in state |ii|\u03c6iE i with probability\n|\u03b1i |2 , so that we easily see that\nPW\u0303 (w) =\n\nX\n\n|\u03b1i |2 |hw|ii|2 =\n\ni\u2208J\n\n\u2265\n\n\u03b1i hw|ii *\n\ni\u2208J\n\nX\n\n|\u03b1i |2 |hw|ii|2 *\n\ni\u2208J\n2\n\nX\n\nX\n\n1\n= hw|\n|J|\n\n12 *\n\ni\u2208J\n2\n\nX\n\n\u03b1i |ii *\n\ni\u2208J\n\n1\n|J|\n\n1\n1\n= PW (w) *\n,\n|J|\n|J|\n\nwhere the inequality is Cauchy-Schwartz3 . The claim P\nfollows (with Definition 3.1).\nFor Point (2.), note that \u03c1E = trA (|\u03c6AE ih\u03c6AE |) = i\u2208J |\u03b1i |2 |\u03c6iE ih\u03c6iE |. The claim follows\nimmediately from the sub-additivity of the rank, i.e.,\nX\nX\nrank(\u03c1E ) \u2264\nrank(|\u03b1i |2 \u03c6iE \u03c6iE ) \u2264\n1 = |J| ,\ni\u2208J\n\nwhere we use that all |\u03c6iE ih\u03c6iE | have rank (at most) 1.\n\ni\u2208J\n\n\u0004\n\nNow, combining the fact that it holds for the binary entropy h that {y \u2208 {0, 1}n | dH (y, \u0177) \u2264\n\u03bcn} \u2264 2h(\u03bc)n for any \u0177 \u2208 {0, 1}n and 0 \u2264 \u03bc \u2264 21 with Lemma 5.2 on \"small superpositions\nof product states\", we can conclude the following corollary.\nCorollary 5.1 Let \u03c1\u0303TestAE be of the form as in Lemma 5.1 (for given \u03b5, x\u0302 and \u03b8\u0302). For any\nfixed test = (T, T 0 ) and for any fixed x|T \u2208 {0, 1}\u03b1m with err := rH (x|T 0 , x\u0302|T 0 ) \u2264 21 , let |\u03c8AE i\nbe the state to which |\u03c6\u0303test\nAE i collapses when, for every i \u2208 T , subsystem Ai is measured in\nbasis \u03b8\u0302i and xi is observed, where we understand A in |\u03c8AE i to be restricted to the registers\nAi with i \u2208 T\u0304 . Finally, let \u03c3E = trA (|\u03c8AE ih\u03c8AE |) and let the random variable X describe the\noutcome when measuring the remaining n = (1\u2212\u03b1)m subsystems of A in basis \u03b8|T\u0304 \u2208 {+, \u00d7}n .\nThen, for any subset I \u2286 {1, . . . , n} and any x|I ,4\n\u0001\n\u0001\nH\u221e X|I X|I \u0304 = x|I \u0304 \u2265 dH \u03b8|I , \u03b8\u0302|I \u2212 h(err + \u03b5)n\nand\n\u0001\nH0 \u03c3E \u2264 h(err + \u03b5)n .\nThus, the number of errors between the measured x|T 0 and the given x\u0302|T 0 gives us a bound\non the min-entropy of the outcome, when measuring the remaining subsystems of A, and on\nthe max-entropy of the state of subsystem E.\nof \u03c1\u0303TestAE , for any\nProof. To simplify notation, we write \u03b8 = \u03b8|T\u0304 and \u03b8\u0302 = \u03b8\u0302|T\u0304 . By definition\nP\ny\nfixed values of \u03b5, x\u0302 and \u03b8\u0302, the state |\u03c8AE i is of the form |\u03c8AE i = y\u2208Y \u03b1y |yi\u03b8\u0302 \u2297 |\u03c8E\ni, where\n3\n\nP\nP\nIn this context, we use the inequality phrased as i |xi |2 |yi |2 \u2265 | i xi yi |2\nBelow, \u03b8|I (and similarly \u03b8\u0302|I ) should be understood as first restricting the m-bit vector \u03b8 to T\u0304 , and then\nrestricting the resulting n-bit vector \u03b8|T\u0304 to I: \u03b8|I := (\u03b8|T\u0304 )|I .\n4\n\n\f64\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\nY = {y \u2208 {0, 1}n : dH (y, x\u0302|T\u0304 ) \u2264 (err + \u03b5)n}.\nx\u0302|T\u0304 ) = dH (y, x\u0302|T\u0304 )/n.\nP Recall here that rH (y,\ny\ny\nConsider the corresponding mixture \u03c3\u0303AE = y\u2208Y |\u03b1y |2 |yi\u03b8\u0302 hy|\u03b8\u0302 \u2297 |\u03c8E\nih\u03c8E\n| and define X\u0303 as\nthe random variable for the outcome when measuring register A of \u03c3\u0303AE in basis \u03b8. Note that\nH\u221e (X\u0303) \u2265 dH (\u03b8, \u03b8\u0302), since any state |yi\u03b8\u0302 , when measured in basis \u03b8, produces a random bit\nfor every position i with \u03b8 6= \u03b8\u0302 (see also the definition of the min-entropy (Definition 3.1)\nand note that there exist 2dH (\u03b8,\u03b8\u0302) possible outcomes). Lemma 5.2 allows us to conclude that\nH0 (\u03c3E ) \u2264 log |Y| \u2264 log 2h(err+\u03b5)n = h(err + \u03b5)n ,\nand similarly,\nH\u221e (X) \u2265 H\u221e (X\u0303) \u2212 log |Y| \u2265 dH (\u03b8, \u03b8\u0302) \u2212 h(err + \u03b5)n .\nThis proves the claim for I = {1, . . . , n}. For arbitrary I \u2282 {1, . . . , n} and x|I , we can\nconsider the pure state, obtained by measuring the registers Ai with i 6\u2208 I in basis \u03b8i , when\nx|I \u0304 is observed. This state is still a superposition of at most |Y| vectors and thus we can\napply the exact same reasoning to obtain Eq. (5.1).\n\u0004\nThe initial claim to be shown now follows by combining Lemma 5.1 and Corollary 5.1.\nIndeed, the ideal state \u03c1Ideal we promised, for which (5.1) holds, is produced by putting A\nand B0 in state \u03c1\u0303T estAE , defined in Lemma 5.1, and then running Steps (2.) and (3.) of the\nverification phase. This state is negligibly close to the real state, since by Lemma 5.1, we\nwere negligibly close to the real state before these operations. Corollary 5.1 ensures that the\nbounds for benign Bob as stated in the definition of benignity in Eq. (5.1) are satisfied.\n\n5.3\n\nIn the Presence of Noise\n\nIn the description of the compiler and in its analysis in the previous section, we assume the\nquantum communication to be noise-free. Indeed, in the case of transmission errors, honest\nAlice is likely to reject an execution with honest Bob. However, it is straightforward to\ngeneralize the result to noisy quantum communication as follows.\nIn Step (2.) in the verification phase of C \u03b1 (\u03a0), Alice rejects and aborts if the relative\nnumber of errors between xi and x\u0302i for i \u2208 T with \u03b8i = \u03b8\u0302i exceeds the error probability \u03c6,\ninduced by the noise in the quantum communication, by some small \u03b50 > 0. By Hoeffding's\ninequality [Hoe63], this guarantees that honest Alice does not reject honest Bob, except with\nexponentially small probability. Furthermore, proving the security of this \"noise-resistant\"\ncompiler goes along the exact same lines as for the original compiler. The only difference is\nthat when applying Corollary 5.1, the parameter err has to be chosen as err = \u03c6 + \u03b50 , such\nthat the bounds in Eq. (5.1) hold for\n\u03b2 = h(err + \u03b5) = h(\u03c6 + \u03b50 + \u03b5) .\nThus, the claim of our compiler-theorem (Theorem 5.1) holds for any \u03b2-benign Bob with\n\u03b2 > h(\u03c6) (by choosing \u03b5, \u03b50 > 0 small enough).\n\n\f5.4. BOUNDED-QUANTUM-STORAGE SECURITY\n\n5.4\n\nBounded-Quantum-Storage Security\n\nIn this section we show that our compiler preserves security in the bounded-quantum-storage\nmodel. Recall that in the BQSM, one of the players, in our case it is Bob, is assumed\nbe able to store only a limited number of qubits beyond a certain point in the protocol.\nBQSM-secure OT- and ID-protocols are known [DFSS07], but can be efficiently broken, if\nthe memory bound does not hold. Therefore, we show here that applying the compiler\nproduces protocols with better security, namely the adversary needs large quantum storage\nand large computing power to succeed. In Chapter 6, we will then discuss the compiled\nprotocols with hybrid security in more detail.\nConsider a BB84-type protocol \u03a0. For a constant 0 < \u03b3 < 1, let B\u03b3bqsm (\u03a0) be the set\nof dishonest players B0 that store only \u03b3n qubits after a certain point in \u03a0, where n is the\nnumber of qubits sent initially. Protocol \u03a0 is said to be unconditionally secure against such\na \u03b3-BQSM Bob, if it satisfies Definition 3.5 with the restriction that the quantification is\nover all dishonest B0 \u2208 B\u03b3bqsm (\u03a0).\nTheorem 5.2 If protocol \u03a0 is unconditionally secure against \u03b3-BQSM Bob, then the compiled protocol C \u03b1 (\u03a0) is unconditionally secure against \u03b3(1\u2212\u03b1)-BQSM Bob, where 0 < \u03b1 < 1.\nProof. The proof proceeds as the proof for our compiler-theorem (Theorem 5.1). We have a\ndishonest B0 that attacks C \u03b1 (\u03a0), and we construct a B0\u25e6 that attacks the original protocol \u03a0.\nThe only difference here is that we let B0\u25e6 generate the common reference string \"correctly\"\nas pkH sampled according to GH .\nC \u03b1 (\u03a0)\n0\nIt follows by construction of B0\u25e6 that outA,B0 = out\u03a0\nA\u25e6 ,B0\u25e6 . Furthermore, since B\u25e6 requires\n0\nthe same amount of quantum storage as B but communicates an \u03b1-fraction fewer qubits, it\n\u03b3(1\u2212\u03b1)\nfollows that B0\u25e6 \u2208 B\u03b3bqsm (\u03a0), if B0 \u2208 Bbqsm (C \u03b1 (\u03a0)). Thus, it follows that there exists B\u03020\ns\nF\n\u0004\nsuch that out\u03a0\nA\u25e6 ,B0\u25e6 \u2248 out\u00c2,B\u03020 . This proves the claim.\n\n5.5\n\nComposability\n\nSeveral composition frameworks for the quantum setting have been proposed, for instance,\nsequential composability in a classical environment [FS09], sequential composability in a\nquantum environment but restricted to the BQSM [WW08], or attempts of generalizing the\nuniversal classical composability framework (UC in [Can01]) to universal quantum composability [BM04,Unr04,Unr10]. Here, we will briefly investigate our protocols in the particular\ncomposition frameworks, we consider most appropriate for our setting.\n\n5.5.1\n\nSequential Composition\n\nAll our definition for correctness and security of our two-party quantum protocols comply\nwith the composition framework of [FS09] as described in detail in Section 3.6. In particular,\nwe will show in the next chapter that all of our quantum protocols \u03c0 securely implements\ntheir corresponding ideal functionality F. Thus, according to the Composition Theorems 3.2\nand 3.3, we arrive at a situation where an outer protocol \u03a3\u03c01 ***\u03c0` , composed of possibly\n\n65\n\n\f66\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\ndifferent inner sub-protocols \u03c0i , is essentially as secure as any hybrid protocol \u03a3F1 ***F` with\nsequential calls to the corresponding ideal functionalities Fi . Sequential composition in a\nclassical environment follows immediately.\n\n5.5.2\n\nGeneral Composition\n\nOur strong simulation-based security approach is clearly closely related to the concept of\nuniversal composability, but our definitions do not imply UC-security. The definitions of\nunconditional security leading to sequential composability do not require the running time of\nideal-world adversaries to be polynomial whenever the real-life adversaries run in polynomial\ntime. Fortunately, by extending our basic commitment construction, we can achieve efficient\nideal-life adversaries. Therewith, we get efficient simulation on both sides without rewinding\nany dishonest player.\nNote that it might still be the case that our compilation preserves efficiency of the simulator, namely if protocol \u03a0 is secure against dishonest A0 with efficient simulator \u00c20 , then\nso is C \u03b1 (\u03a0). Although this would be desirable, it does not seem to be the case for our basic\nconstruction for the following reason. In order to show such a result, we would need to\nsimulate the pre-processing phase against dishonest A0 efficiently and without measuring the\nqubits that are not opened during pre-processing. Then after preparation and verification,\nwe could give the remaining qubits to \u00c20 to simulate the rest of the protocol as specified\npreviously. However, the whole point of the pre-processing is to ensure that a real Bob\nmeasures all qubits, unless he can break the binding property of the commitments. Thus,\nthe only way to resolve this situation is to give the simulator some trapdoor with which it\ncan make commitments and open them any way it wants, or in other words, to equip the\nsimulator with the possibility of equivocate its commitments.\nWith such a equivocability trapdoor, the simulation of the verification phase is straightforward. \u00c20 just waits until A0 reveals the test subset, measures the qubits in the test subset,\nand opens the commitments according to the measurement results. Then, \u00c20 simulates the\nprotocol with the remaining unopened qubits. Our basic commitment construction, introduced in Section 4.1, does not provide such an equivocability trapdoor. However, we can\nextend the scheme as discussed in Section 4.1.4 by first extending our mixed commitment to\nthe multi-bit crypto-system of [PVW08] and then combining it with an HVZK-\u03a3-protocol\nconstruction for some quantumly hard N P-relation R. As previously shown, equivocability\nemerges in this construction with the simulator's knowledge of a valid witness w such that\n(x, w) \u2208 R. In that case, the simulator can compute two accepting conversations for the\n\u03a3-protocol, and therewith, answer both challenges. The extension preserves the different\nbut indistinguishable dual-modes of the underlying commitment scheme such that the committed bit can still be extracted by a simulator B\u03020 , decrypting both commitments C0 , C1 to\ndetermine, which contains a valid reply in the \u03a3-protocol.\nIn [Unr10] a special case of our generic construction, namely the quantum oblivious\ntransfer protocol of Section 6.1 is related to the quantum-UC context. It is shown that the\nprotocol statistically quantum-UC-emulates its ideal functionality in the case of corrupted\nAlice and corrupted Bob, if it is instantiated with an ideal commitment functionality. Furthermore, it is established that security as specified in [FS09] implies quantum-UC-security\n\n\f5.5. COMPOSABILITY\nin the case of our OT-protocol.5 Last, the OT-protocol in its randomized version and when\ninstantiated by an unconditionally binding commitment scheme implements its corresponding ideal functionality with statistical security in the case of corrupted Bob. Even though\nfor the last result the protocol is based on an actual commitment, the case considers only a\ndishonest Bob, and by using an unconditionally binding scheme in the real world, we would\nloose unconditional security against dishonest Alice.\nHowever, by combining our extended construction as described above with the results\nof Section 4.1.4 and with [Unr10, Theorem 20], we get the following stronger result that\napplies to our generic compiler construction: Let \u03a0 be a BB84-type protocol as specified in\nTheorem 5.1 and let C \u03b1 (\u03a0) be its compilation, instantiated with an extended mixed commitment construction in the CRS-model as described above. Then, C \u03b1 (\u03a0) computationally\nquantum-UC-emulates its corresponding ideal functionality F for both dishonest players.\n\n5\n\nThe security we achieve here is called quantum stand-alone security in [Unr10], but we prefer to describe\nthe statements in the terms used throughout this work.\n\n67\n\n\f68\n\nCHAPTER 5. IMPROVED SECURITY FOR QUANTUM PROTOCOLS\n\n\f6\nchapter\n\nApplications\nOur compiler, discussed in the previous chapter, can be easily applied to known protocols.\nHere, we show two example applications, namely oblivious transfer and password-based identification. Since the original protocols are BQSM-secure, we also obtain hybrid security by\ncompilation. These results appeared in [DFL+ 09]. We then show that the compiled identification protocol is secure against man-in-the-middle attacks, which was sketch in [DFL+ 09]\nbut formal proofs were omitted.\n\n6.1\n\nOblivious Transfer\n\nOblivious transfer, as introduced in Section 2.4.2, constitutes a highly relevant cryptographic\nprimitive, which is complete for general two-party computation and reduces to classical\ncommitment in its quantum variant. As a building block it can be securely used in outer\nquantum or classical protocols and extends, for instance, to quantum identification.\n\n6.1.1\n\nMotivation and Related Work\n\nAs mentioned already, the idea of introducing a Commit&Open-step to improve the security of quantum protocols was suggested in the first quantum OT protocol of Cr\u00e9peau\nand Kilian [CK88], which-in its original form-proposes a protocol for Rabin\u2013OT, and in\nthe practical follow-up work of Bennett, Brassard, Cr\u00e9peau and Skubiszewska [BBCS91],\nimplementing 1\u20132 OT 1 . The Commit&Open approach is sketched as a \"conceptually easy\nfix\" [BBCS91, p. 14] in a situation where a dishonest Bob has large quantum storage.\nVarious partial results for OT in that context followed. For instance, in [Yao95] such a\nconstruction is proven secure against any receiver in the case of noiseless communication.\nTo make the proof work, however, an ideal black-box commitment scheme is assumed. This\napproach was then generalized for noisy channels and perfect string commitments in [May96].\nAnother approach in the computational setting was taken in [CDMS04]. There it was shown\nthat a computationally binding quantum string commitment would enforce an apparent\ncollapse of Bob's quantum information, which in turn would imply secure OT. The paper\nconcludes with the open question of how to construct an actual commitment scheme as\nrequired to get an applicable protocol.\nBased on our analysis of Section 5.4, we can now rather simply apply our compiler to (a\nvariant of) the protocol in [BBCS91], and therewith, give a complete proof for a concrete\nunconditionally hiding commitment scheme.\n\n\f70\n\nCHAPTER 6. APPLICATIONS\n\nFunctionality FOT :\nUpon receiving s0 and s1 from Alice and k from Bob, FOT outputs sk to Bob.\nFigure 6.1: The Ideal Functionality for String OT.\nProtocol 1-2 QOT` :\nPreparation:\nA chooses x \u2208R {0, 1}n and \u03b8 \u2208R {+, \u00d7}n and sends |xi\u03b8 to B. B chooses \u03b8\u0302 \u2208R\n{0, 1}n and obtains x\u0302 \u2208 {0, 1}n by measuring |xi\u03b8 in bases \u03b8\u0302.\nPost-processing:\n1. A sends \u03b8 to B.\n2. B partitions all positions 1 \u2264 i \u2264 n in two subsets according to his choice\nbit k \u2208 {0, 1}: the \"good\" subset Ik := {i : \u03b8i = \u03b8\u0302i } and the \"bad\" subset\nI1\u2212k := {i : \u03b8i 6= \u03b8\u0302i }. B sends (I0 , I1 ) in this order.\n3. A sends descriptions of f0 , f1 \u2208R F together with m0 := s0 \u2295 f0 (x|I0 ) and\nm1 := s1 \u2295 f1 (x|I1 ).\n4. B computes sk = mk \u2295 fk (x\u0302|Ik ).\n\nFigure 6.2: Basic Protocol for String OT.\n\n6.1.2\n\nThe Protocol\n\nThe variant we consider here achieves 1\u20132 OT ` . Recall that in such a protocol, the sender A\nsends two `-bit strings s0 and s1 to the receiver B. B can select a string to receive, sk , but\nhe does not learn anything about s1\u2212k . Finally, A does not learn B's choice bit k. The ideal\noblivious transfer functionality FOT is shown in Figure 6.1.\nOur protocol is almost identical to 1\u20132 OT 1 introduced in [BBCS91], but instead of using parity values to mask the bits in the last protocol message, we follow the approach\nof [DFR+ 07]. Their BQSM-secure protocol RAND 1-2 QOT` for the randomized version uses\nhash-functions that allow for transferring an `-bit string instead of a bit as final message.\nLet F denote a suitable family of two-universal hash-functions with range {0, 1}n \u2192\n{0, 1}` as specified in Definition 3.3. Note that if the input to the function is smaller than n,\nwe can pad it with zeros without decreasing its entropy. We further assume that ` = b\u03bbnc\nfor some constant \u03bb > 0. Then, after the modifications described above, we obtain the basic\n1-2 QOT` protocol, depicted in Figure 6.2.\nProposition 6.1 Protocol 1-2 QOT` satisfies correctness and achieves unconditional security\nagainst dishonest Alice, according to Definitions 3.4 and 3.6, respectively.\nProof. Correctness for honest players is obvious: B selects one string to receive, which\nis masked by the hashed bit-string of outcomes, measured in the matching basis. In the\n\n\f6.1. OBLIVIOUS TRANSFER\n\n71\n\npositions with non-matching bases, he does not know the outcomes, and therewith he does\nnot learn anything about s1\u2212k . Finally, A does not learn which is the \"good\" subset, and\nhence, which is B's choice k.\nSecurity against dishonest Alice is derived in a straightforward way from RAND 1-2 QOT`\nof [DFR+ 07] as follows. Note that in RAND 1-2 QOT` , the receiver measures all his qubits in\none basis, depending on his choice bit k, i.e. \u03b8 \u2208 [0, 1]k . As described previously in Chapter 5,\nour compiler requires measurement in random bases \u03b8 \u2208R {0, 1}n . Otherwise, the opened\nand tested positions during Commit&Open would obviously leak k.\nDue to the non-interactivity in RAND 1-2 QOT` , A0 cannot learn B's choice bit k, so the\nprotocol is perfectly receiver-secure. More formally, the proof compares the real output to\nan ideal output, which is obtained by letting A0 run the protocol with an unbounded receiver\nwho measures his qubits in A0 's bases \u03b8, samples independent K from the correct distribution,\nand sets SK correspondingly. The only difference between the two executions is the point\nin time and the choice of bases, in which positions i \u2208 I1\u2212k is measured. However, these\nparameters do not influence the output states, once K is fixed.\nNow, the preparation phase combined with Step (2.) of the post-processing in 1-2 QOT`\nis equivalent to B measuring all qubits in the basis, dictated by K. Thus, the same analysis\ncan be applied to 1-2 QOT` , achieving unconditional security against A0 .\n\u0004\nTheorem 6.1 Protocol 1-2 QOT` is unconditionally secure against \u03b2-benign Bob for any \u03b2 <\n1\n\u03bb\n8 \u2212 2.\nProof. For any given benign Bob B0 , we construct B\u03020 the following way: B\u03020 runs locally\na copy of B0 and simulates an execution by running \u00c2 up to but not including Step (3.).\nSince B0 is benign, B\u03020 obtains \u03b8\u0302 after the preparation phase. When the simulation of \u00c2\nreaches the point just after the announcement of f0 and f1 in Step (3.), B\u03020 finds k 0 such\nthat dH (\u03b8\u0302|Ik0 , \u03b8|Ik0 ) is minimum for k 0 \u2208 {0, 1}. B\u03020 then calls FOT with input k 0 and obtains\noutput sk0 . B\u03020 sets m0k0 = sk0 \u2295 fk0 (x|Ik0 ) and m01\u2212k0 \u2208R {0, 1}` before sending (m0 , m1 ) to\nB0 . Finally, B\u03020 outputs whatever B0 outputs.\nWe now argue that the state output by B\u03020 is statistically close to the state output by\n0\nB when executing 1-2 QOT` with the real A. The only difference is that, while B\u03020 outputs\nm01\u2212k0 \u2208R {0, 1}` , B0 outputs m1\u2212k0 = s1\u2212k0 \u2295 f1\u2212k0 (x|I1\u2212k0 ). Thus, we simply have to show\nthat m1\u2212k0 is statistically indistinguishable from uniform in the view of B0 .\nNote that, since \u03b8 and \u03b8\u0302 are independent and \u03b8 is a uniform n-bit string, we have that\nfor any \u000f > 0,\n(1 \u2212 \u000f)n\ndH (\u03b8, \u03b8\u0302) >\n,\n2\nexcept with negligible probability. We can now claim that with overwhelming probability\ndH (\u03b8|I1\u2212k0 , \u03b8\u0302|I1\u2212k0 ) \u2265\n\n(1 \u2212 \u000f)n\n.\n4\n\nNow, since B0 is \u03b2-benign, we get with Definition 5.1 that\n\u0001 (1 \u2212 \u000f)n\n\u2212 \u03b2n and H0 (\u03c1E ) \u2264 \u03b2n .\nH\u221e X|I1\u2212k0 X|Ik0 = x|Ik0 \u2265\n4\n\n\f72\n\nCHAPTER 6. APPLICATIONS\n\nProtocol C \u03b1 (1-2 QOT` ) :\nPreparation:\nA chooses x \u2208R {0, 1}m and \u03b8 \u2208R {+, \u00d7}m and sends |xi\u03b8 to B. B chooses \u03b8\u0302 \u2208R\n{0, 1}m and obtains x\u0302 \u2208 {0, 1}m by measuring |xi\u03b8 in bases \u03b8\u0302.\nVerification:\n1. B sends ci := commitpkH ((\u03b8\u0302i , x\u0302i ), ri ) with randomness ri for all i = 1, . . . , m.\n2. A sends random T \u2282 {1, . . . , m} with |T | = \u03b1m. B opens ci \u2200 i \u2208 T , and A\nchecks that the openings were correct and that xi = x\u0302i whenever \u03b8i = \u03b8\u0302i . If\nall tests are passed, A accepts. Otherwise, she rejects and aborts.\n3. A and B restrict x, \u03b8 and x\u0302, \u03b8\u0302, respectively, to the remaining n positions i \u2208 T\u0304 .\nPost-processing:\n1. A sends \u03b8 to B.\n2. B partitions all positions 1 \u2264 i \u2264 n in two subsets according his choice bit\nk \u2208 {0, 1}: the \"good\" subset Ik := {i : \u03b8i = \u03b8\u0302i } and the \"bad\" subset\nI1\u2212k := {i : \u03b8i 6= \u03b8\u0302i }. B sends (I0 , I1 ) in this order.\n3. A sends descriptions of f0 , f1 \u2208R F together with m0 := s0 \u2295 f0 (x|I0 ) and\nm1 := s1 \u2295 f1 (x|I1 ).\n4. B computes sk = mk \u2295 fk (x\u0302|Ik ).\n\nFigure 6.3: Improved Protocol for String OT.\nIt follows from privacy amplification (Theorem 3.1) that f1\u2212k0 (x|I1\u2212k0 ) is statistically indistinguishable from uniform for B0 , provided that\n1\n`\n< \u2212 2\u03b2 \u2212 \u000f0\nn\n4\nfor any \u000f0 > 0. Finally, by the properties of exclusive-OR, we can now also conclude that\nm1\u2212k0 is statistically close to uniform. Solving the last inequality for \u03b2, we obtain\n\u03b2<\nand Theorem 6.1 follows.\n\n1 \u03bb \u000f0\n\u2212 \u2212 ,\n8 2\n2\n\u0004\n\nInformally, the next Corollary 6.1 states that, when compiling the basic protocol 1-2 QOT` ,\nwe obtain an improved protocol C \u03b1 (1-2 QOT` ) with hybrid security, such that a dishonest Bob\nis required to have large quantum computing power and large quantum storage to succeed.\nFor completeness, C \u03b1 (1-2 QOT` ) is given explicitly in Figure 6.3.\nCorollary 6.1 If \u03bb < 14 , then protocol C \u03b1 (1-2 QOT` ) is computationally secure against dishonest Bob and unconditionally secure against \u03b3(1\u2212\u03b1)-BQSM Bob with \u03b3 < 41 \u2212 2\u03bb. Correctness and unconditional security against dishonest Alice is maintained during compilation.\n\n\f6.2. PASSWORD-BASED IDENTIFICATION\nProof. The corollary is obtained by the following steps: First, we sketch that the analysis of protocol RAND 1-2 QOT` in [DFR+ 07] can be almost analogously applied to 1-2 QOT` .\nThen, we combine this result with our BQSM-theorem (Theorem 5.2). And finally, we apply\nTheorem 6.1 with our compiler-theorem (Theorem 5.1). Note that, by definition, all these\ntransformations do not touch correctness nor unconditional security against A0 .\nIn more detail, the main difference from RAND 1-2 QOT` to 1-2 QOT` is that B measures all\nhis qubits in the basis corresponding to his choice bit k, i.e. \u03b8 \u2208 [0, 1]k . Since we require\nthese measurements to be in random bases \u03b8 \u2208R {0, 1}n , we loose the non-interactivity and\nmust include the additional message (I0 , I1 ) from B to A in Step (2.), so that A obtains\nthe same partitions. However, the partitions are send in fixed order and do not allow to\nconclude on the \"good\" subset Ik . No other message is sent by B. Furthermore, recall that\nin randomized OT, A does not input the two messages s0 , s1 herself by masking them with\nthe hashed output of the measurement outcomes. Instead, only these hash-values, generated\nuniformly at random during the protocol, are output. However, due to the characteristic of\nexclusive-OR, the security properties in this aspect do not change.\nThus, 1-2 QOT` inherits the BQSM-security of RAND 1-2 QOT` , and we can claim that\n1-2 QOT` is unconditionally secure against \u03b3-BQSM Bob for all \u03b3 strictly smaller than 14 \u2212 2\u03bb.\nThen, by Theorem 5.2, we obtain unconditional security for C \u03b1 (1-2 QOT` ) against \u03b3(1\u2212\u03b1)BQSM Bob.\nLast, we know from Theorem 6.1 that 1-2 QOT` is unconditionally secure against a \u03b2benign Bob for \u03b2 < 18 \u2212 \u03bb2 . It follows with Theorem 5.1 that Commit&Open, instantiated by our\ndual-mode commitment scheme, leads to quantum-computational security for C \u03b1 (1-2 QOT` )\nagainst any B0 .\n\u0004\n\n6.2\n\nPassword-Based Identification\n\nPassword-based identification is introduced in Section 2.4.3, where we also describe a construction from randomized 1\u2013n OT ` , and the therewith inherited OT-security aspects. Secure\nidentification is highly significant in any authenticated set-up of outer protocols, and may\nprovide re-usability of the initial user-memorizable passwords, if cleverly implemented.\n\n6.2.1\n\nMotivation and Related Work\n\nThere exist various approaches for classical and quantum identification, based on different\ntechniques, e.g. on zero-knowledge [FS86,FFS87], on password-based key-agreement [KOY01],\nand on quantum memory restrictions [DFSS07]. Here, we will subject the quantum identification scheme of [DFSS07], denoted in the following by BQSM\u2013QID, to our compiler technique,\nyielding more diverse security assumptions. BQSM\u2013QID was proven to be unconditionally secure against arbitrary dishonest Alice and against quantum-memory-bounded dishonest Bob\nby using quantum-information-theoretic security definitions. In [FS09] it was then shown that\nthese security definitions imply simulation-based security as considered here, with respect to\nthe functionality FID given in Figure 6.4. Actually, the definition and proof from [DFSS07]\nguarantee security only for a slightly weaker functionality, which gives some unfair advantage to dishonest Alice in case she guesses the password correctly. However, as discussed\n\n73\n\n\f74\n\nCHAPTER 6. APPLICATIONS\n\nFunctionality FID :\nUpon receiving wA , wB \u2208 W from Alice and Bob, respectively, FID outputs the bit\n?\ny := (wA =\nwB ) to Bob. In case Alice is dishonest, she may choose wA = \u22a5 (where \u22a5 6\u2208 W),\nand (for any choice of wA ) the bit y is also output to Alice.\nFigure 6.4: The Ideal Functionality for Password-Based Identification.\nin [FS09], the protocol from [DFSS07] does implement functionality FID .\n\n6.2.2\n\nThe Protocol\n\nRecall that we require from an identification scheme that a user A succeeds in identifying\nherself to a server B, if she knows an initial, secret password w. Additionally, a dishonest\nuser A0 should not succeed with higher probability than at a guess, and similarly, a dishonest\nserver B0 should be only able to guess A's password without learning anything beyond the\n(in)correctness of his guess. These last requirements provide re-usability of the password. To\nachieve security under realistic assumptions, we further want to allow memorizable passwords\nwith low entropy.\nLet W be the set of possible keys, not necessarily large in size, with w \u2208 W denoting\nthe initially shared password. For clarity, we will often use wA and wB to indicate A's and\nB's input to the protocol, and only accept if wA = wB , which implies equality to w. Let\nc : W \u2192 {+, \u00d7}n be the encoding function of a binary code of length n with |W| codewords\nand minimal distance d. Families of codes as required for our subsequent results, correcting\na constant fraction of errors efficiently and with constant information rate are indeed known\n[SS96]. And finally, let F and G denote suitable families of (strongly) two-universal hashfunctions, as specified in Definition 3.3, with range F : {0, 1}n \u2192 {0, 1}` and G : W \u2192 {0, 1}` ,\nrespectively. Again we stress that we can pad the input to the functions with zero, if it is\nsmaller than expected.\nWe cannot directly apply our compiler to the original BQSM\u2013QID, since it is not a BB84type protocol. Similar to RAND 1-2 QOT` described in the previous Section 6.1, B does not\nmeasure the qubits in a random basis but in a basis-string c determined by his password\nwB \u2208 W by c = c(wB ). After A's basis announcement, both players compute set Iw = {i :\n\u03b8i = c(w)i } with the positions on which they base the last steps of the post-processing.\nWe briefly sketch now the transformation from BQSM\u2013QID into a BB84-type protocol,\nwithout affecting security and without loosing efficiency. The first step is naturally to let\nB measure in random basis \u03b8\u0302 \u2208R {+, \u00d7}n . The most straightforward next step would be\nto include a new message from B to A during post-processing, in which B announces IB =\n{i : \u03b8\u0302i = c(w)i }. Then, A sends \u03b8 and the remaining post-processing could be conducted\non Iw = {i \u2208 IB : \u03b8i = \u03b8\u0302i }. Note, however, that this solution here is less efficient than in\nthe original protocol, since only approx. 1/4 of all measurement outcomes could be used. So\ninstead, we let Bob apply a random shift \u03ba to the code, which B announces to A in the postprocessing phase, namely \u03b8\u0302 = c(w)\u2295\u03ba with \u03ba \u2208 {+, \u00d7}n and + \u2261 0 and \u00d7 \u2261 1 for computing\nthe \u2295-operation. Then, we define c0 (w) := c(w)\u2295\u03ba. Finally, after A's announcements of \u03b8 the\n\n\f6.2. PASSWORD-BASED IDENTIFICATION\n\nProtocol QID :\nPreparation:\nA chooses x \u2208R {0, 1}n and \u03b8 \u2208R {+, \u00d7}n and sends |xi\u03b8 to B. B chooses \u03b8\u0302 \u2208R\n{0, 1}n and obtains x\u0302 \u2208 {0, 1}n by measuring |xi\u03b8 in bases \u03b8\u0302.\nPost-processing:\n1. B computes a string \u03ba \u2208 {+, \u00d7}n such that \u03b8\u0302 = c(w) \u2295 \u03ba, where we think of\n+ as 0 and \u00d7 as 1 so that \u2295 makes sense. He sends \u03ba to A and we define\nc0 (w) := c(w) \u2295 \u03ba.\n2. A sends \u03b8 and f \u2208R F to B. Both compute Iw := {i : \u03b8i = c0 (w)i }.\n3. B sends g \u2208R G.\n4. A sends z := f (x|Iw ) \u2295 g(w) to B.\n5. B accepts if and only if z = f (x\u0302|Iw ) \u2295 g(w).\n\nFigure 6.5: Basic Protocol for Password-Based Identification\nprotocol is completed with the shifted code, i.e., based on positions in Iw := {i : \u03b8 = c0 (w)i }.\nThis has the effect that the post-processing is actually based on positions i with \u03b8i = \u03b8\u0302i ,\nand thus, on approx. 1/2 of all qubits as in protocol BQSM\u2013QID. Our resulting protocol QID\nis described in Figure 6.5. We show in the following proofs that the modification does not\naffect security as given in [DFSS07] (and [FS09]).\nProposition 6.2 Protocol QID satisfies correctness and achieves unconditional security against\ndishonest Alice, according to Definitions 3.4 and 3.6, respectively.\nProof. Correctness for honest players is obvious: If both A and B know w, i.e. wA = wB ,\nthey can compute c(w) and c0 (w). Following the last steps as supposed to, they conclude\nwith f (x|Iw ) \u2295 g(wA ) = f (x\u0302|Iw ) \u2295 g(wB ).\nSecurity against dishonest A0 is derived in a straightforward way from BQSM\u2013QID as follows.\nRecall that in BQSM\u2013QID, B measures all his qubits in one basis, depending on c = c(w). In\nQID, the preparation phase combined with Step (1.) of the post-processing, where B sends\n\u03ba, can be seen as an equivalent situation from the view of A0 . The important positions are\nnow defined by c0 (w), which is however only deducible if c(w) is known in addition, since\notherwise, \u03ba looks completely random. All subsequent steps are exactly as in BQSM\u2013QID,\nand thus, the same analysis can be applied to QID. In the following, we will sketch the\nintuitive idea thereof. A0 runs the protocol with a memory-unbounded server who measures\nhis qubits in A0 's bases \u03b8 and therefore obtains x. He then computes sj = f (x|Ij ) \u2295 g(j) for\nall codewords j = 1, . . . , |W|, where sw would be expected from A0 for an accepting run of\nthe protocol. By the strongly universal-two property of g, all sj are pairwise independent,\nand thus, it follows that all sj 's are distinct, except with some negligible probability. Assume\nthat the accepting message is one of the sj 's for a random variable w0 , i.e. z = sw0 . A0 will\nonly succeed, if w0 = w, and A0 does not learn anything beyond that. A further analysis\n\n75\n\n\f76\n\nCHAPTER 6. APPLICATIONS\nof A0 's state before the final accept/reject-message shows its independence from w, given w0\nand conditioned on w0 6= w and on the pairwise distinction of all sj 's. And finally, for A0 's\nstate after the final message it is shown that the event of all distinct sj 's is independent of\nw and w0 . Statistical security against A0 follows.\n\u0004\nTheorem 6.2 If c : W \u2192 {+, \u00d7}n has minimal distance d \u2265 \u03b4n and is polynomial-time\ndecodeable, then protocol QID is unconditionally secure against \u03b2-benign Bob for any \u03b2 < 4\u03b4 .\nProof. For any given benign Bob B0 , we construct B\u03020 as follows. B\u03020 runs locally a copy of B0\nand simulates Alice's actions by running A faithfully except for the following modifications.\nAfter the preparation phase, B\u03020 gets \u03b8\u0302 and \u03ba from B0 . It then computes w0 \u2208 W such that\nc(w0 ) has minimal Hamming distance to \u03b8\u0302 \u2295\u03ba. Note that this can be done in polynomial-time\nby assumption on the code. Then, B\u03020 submits w0 as input wB to FID and receives output\ny \u2208 {0, 1}. If y = 1, then B\u03020 faithfully completes A's simulation using w0 as w. Otherwise, B\u03020\ncompletes the simulation by using a random z 0 instead of z. In the end, B\u03020 outputs whatever\nB0 outputs.\nWe need to show that the state output by B\u03020 (respectively B0 ) above is statistically close\nto the state output by B0 when executing QID with real A. For simpler notation, we use w for\nhonest Alice's input wA . Note that if w0 = w, then the simulation of A is perfect and thus\nthe two states are equal. If w0 6= w then the simulation is not perfect, as the real A would use\nz = f (x|Iw ) \u2295 g(w) instead of random z 0 . It thus suffices to argue that f (x|Iw ) is statistically\nclose to random and independent of the view of B0 for any fixed w 6= w0 . Note that this is\nalso what had to be proven in [DFSS07], but under a different assumption, namely that B0\nhas bounded quantum memory, rather than that he is benign. Nevertheless, we can recycle\npart of the proof.\nRecall from the definition of a benign Bob that the common state after the preparation\nphase is statistically close to a state for which it is guaranteed that H\u221e (X|I ) \u2265 dH (\u03b8|I , \u03b8\u0302|I )\u2212\n\u03b2n for any I \u2286 {1, . . . , n}, and H0 (\u03c1E ) \u2264 \u03b2n. By the closeness of these two states, switching\nfrom the real state of the protocol to the ideal state satisfying these bounds, has only a\nnegligible effect on the state output by B\u03020 . Thus, we may assume these bounds to hold.\nRecall that \u03b8\u0302 \u2295 \u03ba is at Hamming distance at most d/2 from c(w0 ). Since the distance\nfrom here to the (distinct) codeword c(w) is greater than d, we see that \u03b8\u0302 \u2295 \u03ba is at least d/2\naway from c(w). It follows that c0 (w) = c(w) \u2295 \u03ba has Hamming distance at least d/2 from\n\u03b8\u0302. Furthermore, for arbitrary \u03b5 > 0 and except with negligible probability, the Hamming\ndistance between \u03b8|Iw = c0 (w)|Iw and \u03b8\u0302|Iw is at least d/4 \u2212 \u03b5n. Therefore, we can conclude\nthat\nH\u221e (X|Iw ) \u2265 d/4 \u2212 \u03b5n \u2212 \u03b2n and H0 (\u03c1E ) \u2264 \u03b2n .\nWe require H\u221e (X|Iw ) \u2212 H0 (\u03c1E ) \u2212 ` to be positive and linear in n, which is the case here for\nparameters\n\u03b2n \u2264 d/8 \u2212 (\u03b5/2) n \u2212 `/2 .\nWe conclude by privacy amplification that f (x|Iw ) and therewith z are close to random and\nindependent of E, conditioned on w 6= w. This concludes the proof.\n\u0004\n\n\f6.3. MAN-IN-THE-MIDDLE SECURITY FOR IDENTIFICATION\nThe next corollary informally states that, when applying our compiler to the basic protocol QID, we obtain a hybrid-secure protocol C \u03b1 (1-2 QOT` ). Thus, any dishonest Bob needs\nlarge quantum computing power and large quantum storage to launch a successful attack.\nFor completeness, we again give C \u03b1 (QID) explicitly in Figure 6.6.\nCorollary 6.2 If |W| \u2264 2\u03bdn , and if c : W \u2192 {+, \u00d7}n has minimal distance d \u2265 \u03b4n for\n\u03b4 > 0 and is polynomial-time decodeable, then protocol C \u03b1 (QID) is computationally secure\nagainst dishonest Bob and unconditionally secure against \u03b3(1 \u2212 \u03b1)-BQSM Bob with \u03b3 <\n\u03b4\n4 \u2212 \u03bd. Correctness and unconditional security against dishonest Alice is maintained during\ncompilation.\nProof. We can show hybrid security by first adapting and connecting the results of [DFSS07]\nwith our BQSM-Theorem 5.2, and then combining Theorem 6.2 with our compiler theorem\n(Theorem 5.1). All definitions preserve correctness and unconditional security against A0 .\nIn more detail, the main difference from BQSM\u2013QID of [DFSS07] to QID is that B measures\nall his qubits in the bases corresponding to c = c(wB ). Then after A's basis announcement,\nboth players base the remaining post-processing on Iw = {i : \u03b8i = c(w)i }. In QID instead, B\nmeasures in random bases, computes \u03b8\u0302 = c(w)\u2295\u03ba, and announces \u03ba to A. Then after A's basis\nannouncements, the protocol is completed based on positions in Iw := {i : \u03b8 = c0 (w)i } with\nc0 (w) := c(w) \u2295 \u03ba. Note that both situations however are equivalent. First, the important\npositions are those i where \u03b8i = \u03b8\u0302i in both cases. And second, \u03ba looks completely random\nand is of no value without the knowledge of c(w).\nThus, QID inherits the BQSM-security of BQSM\u2013QID, and we can claim that QID is unconditionally secure against \u03b3-BQSM Bob for all \u03b3 < 4\u03b4 \u2212 \u03bd. From Theorem 5.2 unconditional\nsecurity of C \u03b1 (1-2 QOT` ) against \u03b3(1 \u2212 \u03b1)-BQSM Bob follows. QID is guaranteed by Theorem 6.2 to achieve unconditional security against a \u03b2-benign Bob for \u03b2 < 4\u03b4 and it follows\nwith Theorem 5.1 that Commit&Open, instantiated by our dual-mode commitment scheme,\nyields quantum-computational security for C \u03b1 (QID) against any B0 .\n\u0004\n\n6.3\n\nMan-in-the-Middle Security for Identification\n\nIn a man-in-the-middle attack, we assume an external adversary who attacks an execution of\nthe protocol with honest communicating parties, while having full control over the classical\nand the quantum communication.\n\n6.3.1\n\nMotivation\n\nThe compiled quantum protocols from Sections 6.1 and 6.2 protect against (arbitrary) dishonest Alice and against (computationally or quantum-storage bounded) dishonest Bob.\nHowever, in particular in the context of identification, it is also important to protect against\na man-in-the-middle attacker Eve (E). Both, QID and C \u03b1 (QID), are insecure in this model.\nEve might measure one of the transmitted qubits, say, in the +-basis, and this way learn\n\n77\n\n\f78\n\nCHAPTER 6. APPLICATIONS\n\nProtocol C \u03b1 (QID) :\nPreparation:\nA chooses x \u2208R {0, 1}n and \u03b8 \u2208R {+, \u00d7}n and sends |xi\u03b8 to B. B chooses \u03b8\u0302 \u2208R\n{0, 1}n and obtains x\u0302 \u2208 {0, 1}n by measuring |xi\u03b8 in bases \u03b8\u0302.\nVerification:\n1. B sends ci := commitpkH ((\u03b8\u0302i , x\u0302i ), ri ) with randomness ri for all i = 1, . . . , m.\n2. A sends random T \u2282 {1, . . . , m} with |T | = \u03b1m. B opens ci \u2200 i \u2208 T , and A\nchecks that the openings were correct and that xi = x\u0302i whenever \u03b8i = \u03b8\u0302i . If\nall tests are passed, A accepts. Otherwise, she rejects and aborts.\n3. A and B restrict x, \u03b8 and x\u0302, \u03b8\u0302, respectively, to the remaining n positions i \u2208 T\u0304 .\nPost-processing:\n1. B computes a string \u03ba \u2208 {+, \u00d7}n such that \u03b8\u0302 = c(w) \u2295 \u03ba, where we think of\n+ as 0 and \u00d7 as 1 so that \u2295 makes sense. He sends \u03ba to A and we define\nc0 (w) := c(w) \u2295 \u03ba.\n2. A sends \u03b8 and f \u2208R F to B. Both compute Iw := {i : \u03b8i = c0 (w)i }.\n3. B sends g \u2208R G.\n4. A sends z := f (x|Iw ) \u2295 g(w) to B.\n5. B accepts if and only if z = f (x\u0302|Iw ) \u2295 g(w).\n\nFigure 6.6: Improved Protocol for Password-Based Identification\n\n\f6.3. MAN-IN-THE-MIDDLE SECURITY FOR IDENTIFICATION\ninformation on the basis \u03b8\u0302i used by B, and thus on the password w, simply by observing if\nB accepts or rejects in the end.1\nIn [DFSS07] it was shown how to enhance BQSM\u2013QID in order to obtain security (in\nthe bounded-quantum-storage model) against man-in-the-middle attacks. The very same\ntechniques can also be used to obtain hybrid security against man-in-the-middle attacks for\nC \u03b1 (QID). The techniques from [DFSS07] consist of the following two add-on's to the original\nprotocol.\n1. A test on a random subset of qubits in order to detect disturbance of the quantum\ncommunication.\n2. Authentication of the classical communication.\nFirst note that C \u03b1 (QID) already does such a check as required in Point (1.), namely in the\nverification phase, so this is already taken care of here. Point (2.) requires that Alice and\nBob, in addition to the password, share a high-entropy key k that could be stored, e.g. on a\nsmart-card. This key will be used for a so-called extractor MAC. Besides being a MAC, i.e.\na message authentication code, such a construction has the additional property that it also\nacts as an extractor. This means that if the message to be authenticated has high enough\nmin-entropy, then the key-tag pair is close to randomly and independently distributed. As\na consequence, the tag gives away (nearly) no information on k, and thus, k can be re-used\nin the next execution of the protocol.2 For further details, we refer to [DFSS07, DKRS06].\nMore specifically, in order to obtain hybrid security against man-in-the-middle attacks\nfor C \u03b1 (QID), A will, in her last move of the protocol, use the extractor MAC to compute\nan authentication tag on all the classical messages exchanged plus the string x|Iw . This,\ntogether with the test of a random subset, prevents Eve from interfering with the (classical\nand quantum) communication without being detected, and security against Eve essentially\nfollows from the security against impersonation attacks. Note that including the x|Iw into\nthe authenticated message guarantees the necessary min-entropy, and as such the re-usability\nof the key k.\nWe emphasize that the protocol is still secure against impersonation attacks (i.e. dishonest\nAlice or Bob), even if the adversary knows k, but with slightly weaker parameters due to\nthe \"entropy-loss\" within x|Iw , caused by the additional information for authentication and\nprivate error correction that is now available.\n\n6.3.2\n\nThe Set-Up\n\nIn addition to the previous setting in Section 6.2, we now have the following assumptions.\nLet M AC \u2217 : K \u00d7 M \u2192 {0, 1}` be the extractor MAC with arbitrary key space K, message\nspace M and error probability 2\u2212` . Its extractor property guarantees that for any message\nM and quantum state E (which may depend on M ), the tag T = M AC \u2217 (K, M ) of M is such\nthat \u03c1T KE is 2\u2212(H\u221e (M )\u2212H0 (\u03c1E )\u2212`)/2 -close to 21` I \u2297 \u03c1K \u2297 \u03c1E . Recall that c : W \u2192 {+, \u00d7}n\n1\n\nNote that this attack does not immediately apply to the scheme sketched in the previous section, but\nsimilar, however more sophisticated, attacks may still apply.\n2\nThis is in sharp contrast to the standard way of authenticating the classical communication, where the\nauthentication key can only be used a bounded number of times.\n\n79\n\n\f80\n\nCHAPTER 6. APPLICATIONS\n\nFunctionality FID+ :\nThe ideal functionality FID+ receives pairs of strings (wA , kA ) and (wB , kB ) from honest\nAlice and Bob, and a string wE from Eve, where wA , wB \u2208 W and k \u2208 K. If wE = wA ,\nthen FID+ sends (correct, kA ) to Eve. Otherwise, FID+ sends incorrect. Last, Eve is\n?\nasked to input an \"override bit\" d, and FID+ outputs the bit (wA =\nwB ) \u2227 d to Bob and\nto Eve.\nFigure 6.7: The Ideal Functionality with Man-in-the-Middle Security.\nis the encoding function of a binary code with minimal distance d, and we have strongly\nuniversal-2 classes of hash-functions F : {0, 1}n \u2192 {0, 1}` and G : W \u2192 {0, 1}` .\nIn order to do error correction, let {synj }j\u2208J be the family of syndrome functions3 , corresponding to a family C = {Cj }j\u2208J of linear error correcting codes of size n0 = n/2, where\nn = (1 \u2212 \u03b1)m. We require the property that any Cj allows to efficiently correct a \u03c600 -fraction\nof errors for some constant \u03c600 > 0. For a random j \u2208 J , the syndrome of a string with t\n1\nbits of min-entropy is 2\u2212 4 (t\u22122q) -close to uniform given j and any quantum state with maxentropy at most q. We refer to [DS05, DFSS07, FS08] for the existence of such families and\nexample constructions. Protocol C \u03b1 (QID+ ) can tolerate a noisy quantum communication up\nto any error rate \u03c6 < \u03c600 . We stress that for security against man-in-the-middle attacks, error\ncorrection with \u03c600 > 0 needs to be done even if we assume perfect quantum communication\n(with \u03c6 = 0), as should become clear from the analysis of the protocol given below. Finally,\nwe let \u03c60 be a constant such that \u03c6 < \u03c60 < \u03c600 .\nThe ideal functionality FID+ is given in Figure 6.7. The following definition captures\nunconditional security against a man-in-the-middle attacker, where E gets classical W 0 and\nquantum state E as input and both honest players A and B get classical input W and K.\nThe joint state is then of the form\n\u03c1KW W 0 E|W 0 6=W = \u03c1K \u2297 \u03c1W \u2194W 0 \u2194E|W 0 6=W .\nNote that we require that the adversary's quantum register E is correlated with the honest\nplayers' parts only via her classical input W 0 , conditioned on W 6= W 0 .\nDefinition 6.1 (Unconditional security against a Man-in-the-middle) A protocol\n\u03a0 implements an ideal classical functionality F unconditionally securely against a man-inthe-middle attacker, if for any real-world adversary E, there exists an ideal-world adversary\n\u00ca, such that, for any input state as specified above, it holds that the outputs in the real and\nthe ideal world are statistically indistinguishable, i.e.,\ns\n\nF\nout\u03a0\nA,B,E \u2248 out\u00c2,B\u0302,\u00ca .\n\n3\nNote that we have the following convention: For a bit string y of arbitrary length, synj (y) is to be\n\u0001\nunderstood as synj (y0 * * * 0) with enough padded zeros if its bit length is smaller than n0 , and as synj (y 0 ), y 00 ,\n0\n0\n00\n0\nwhere y consist of the first n and y of the remaining bits of y, if its bit length is bigger than n .\n\n\f6.3. MAN-IN-THE-MIDDLE SECURITY FOR IDENTIFICATION\nComputational security against a man-in-the-middle is defined as follows. For a given\nvalue of the security parameter m, the common reference string \u03c9 is chosen at first. The\npolynomial-size input sampler takes as input m and \u03c9 and samples an input state of the\nform\n\u03c1WA KA WB KB ZE = \u03c1WA KA WB KB \u2194Z\u2194E ,\nwhere honest Alice gets as input password WA , honest Bob gets WB , and Eve's quantum\nregister E is correlated with the honest player's part only via her classical input Z. In\naddition to their passwords WA , WB , the honest players are given high-entropy keys KA , KB .\nWe restrict the input sampler to choose KA uniformly at random from K and guarantee that\nKA = KB whenever WA = WB .\nDefinition 6.2 (Computational Security against a Man-in-the-middle) A protocol\n\u03a0 implements an ideal classical functionality F computationally securely against a man-inthe-middle attacker, if for any poly-time real-world adversary E who has access to the common\nreference string \u03c9, there exists a poly-time ideal-world adversary \u00ca, not using \u03c9, such that\nfor any input sampler as described above, it holds that the outputs in the real and the ideal\nworld are quantum-computationally indistinguishable, i.e.,\nq\n\nF\nout\u03a0\nA,B,E \u2248 out\u00c2,B\u0302,\u00ca .\n\n6.3.3\n\nThe Protocol\n\nThe extended and compiled protocol C \u03b1 (QID+ ) is depicted in Figure 6.8. Corollary 6.3 states\nhybrid security against man-in-the-middle attacks, such that a computationally or quantumstorage bounded Eve can do no better than trying to guess the password. If the guess is\nincorrect, she learns (essentially) nothing.\nCorollary 6.3 Assume that |W| \u2264 2\u03bdn and that c : W \u2192 {+, \u00d7}n has minimal distance d \u2265\n\u03b4n for \u03b4 > 0 and is polynomial-time decodeable. Then, protocol C \u03b1 (QID+ ) is computationally\nsecure against Eve with \u03b2 < 6\u03b4 , and unconditionally secure against \u03b3(1\u2212\u03b1)-BQSM Eve with\n\u03b3 < 2\u03b4 \u2212 \u03bd \u2212 2`.\nWe split the proof of Corollary 6.3 into two parts. First, we show computational security\nin Proposition 6.3, and second, we show unconditional security in the bounded-quantumstorage model in Proposition 6.4.\nProposition 6.3 Let c : W \u2192 {+, \u00d7}n have minimal distance d \u2265 \u03b4n and be polynomialtime decodeable. Then, C \u03b1 (QID+ ) is computationally secure against Eve with \u03b2 < 6\u03b4 , according\nto Definition 6.2.\nProof. We start with the real-life execution of C \u03b1 (QID+ ) with honest A and B with respective inputs (wA , kA ) and (wB , kB ), and a man-in-the-middle attacker E. We then modify it\nstep by step without (essentially) changing the common output state, such that in the end\nwe have a simulation of the protocol as required.\nFirst, we change the action of B in that we assume that B learns in the final step of\nC \u03b1 (QID+ ) \"by magic\" whether one of the classical messages communicated was modified by\n\n81\n\n\f82\n\nCHAPTER 6. APPLICATIONS\n\nProtocol C \u03b1 (QID+ )\nPreparation:\nA chooses x \u2208R {0, 1}m and \u03b8 \u2208R {+, \u00d7}m and sends |xi\u03b8 to B. B chooses \u03b8\u0302 \u2208R\n{0, 1}m and obtains x\u0302 \u2208 {0, 1}m by measuring |xi\u03b8 in bases \u03b8\u0302.\nVerification:\n1. B sends ci := commit pkH ((\u03b8\u0302i , x\u0302i ), ri ) with randomness ri for i = 1, . . . , m.\n2. A sends random T \u2282 {1, . . . , m} with |T | = \u03b1m. B opens ci \u2200 i \u2208 T , and A\nchecks that the openings were correct and that xi = x\u0302i whenever \u03b8i = \u03b8\u0302i . A\naccepts, if this is the case for all but a \u03c60 -fraction of the tested bits. Otherwise,\nshe rejects and aborts.\n3. A and B restrict x, \u03b8 and \u03b8\u0302, x\u0302,respectively, to the remaining n positions i \u2208 T\u0304 .\nPost-processing:\n1. B computes a string \u03ba \u2208 {+, \u00d7}n such that \u03b8\u0302 = c(w) \u2295 \u03ba. He sends \u03ba to A\nand we define c0 (w) := c(w) \u2295 \u03ba.\n2. A sends \u03b8, f \u2208R F, j \u2208R J , and syn = synj (x|Iw ), where Iw := {i : \u03b8i =\nc0 (w)i }.\n3. B sends g \u2208R G.\n4. A sends z := f (x|Iw ) \u2295 g(w) to B. Additionally, she sends the authentication tag of all previously transmitted classical information, i.e. tag \u2217 :=\nM ACk\u2217 (\u03b8, j, syn, f, g, z, \u03ba, T, test, x|Iw ) with test = {(ci , x\u0302i , \u03b8\u0302i , ri )}i\u2208T .\n5. B uses syn to correct the errors within x\u0302|Iw , and he accepts if and only if tag \u2217\nverifies correctly and z = f (x\u0302|Iw ) \u2295 g(w).\n\nFigure 6.8: Extended and Compiled Protocol for Password-Based Identification.\n\n\f6.3. MAN-IN-THE-MIDDLE SECURITY FOR IDENTIFICATION\nE and whether wA = wB or not. He accepts the execution if none of the messages was\nmodified, if wA = wB , and if z verifies correctly. This changes the outcome of the protocol\nonly by a negligible amount. Indeed, if wA = wB , the restriction on the input sampler\nguarantees that kA = kB and the claim follows from the security of the MAC. If wA 6= wB ,\nthen B rejects anyway in both versions, except with negligible probability.\nNext, we further change the action of B in that B accepts the execution in the final step\nof C \u03b1 (QID+ ) if none of the messages was modified and if wA = wB (without verifying z). We\nargue that this modification does not change the common output state, up to a negligible\namount. Note that by Lemma 5.1, we may replace the real state consisting of the qubits\nobtained by A and the choice of T and T 0 = {i \u2208 T : \u03b8i = \u03b8\u0302i } by a negligibly close ideal state\n(with the same T and T 0 ) such that the error rate within T 0 , i.e. the fraction of i \u2208 T 0 with\nxi 6= x\u0302i , gives an exact upper bound on the error rate outside of T . Thus, it follows that if\nA does not reject during verification, then B will recover the correct string x|Iw in the final\nstep (except with negligible probability) and correctly verify z if and only if wA = wB .\nThe next modification is that B runs the modified protocol with some \"dummy input\"\ninstead of his real input wB , but he still accepts only if wA equals his real input wB and\nno transmitted message was modified by E. Since B does not reveal any information on his\ninput before the last step, this modification does not change the common output state at all.\nWe write B\u2217 for this modified B.\nAs last modification, we choose an unconditionally binding key pkB as reference string,\ntogether with the decryption key sk. The new common output state is computationally\nindistinguishable from the previous one by assumption on the commitment keys.\nNow, this modified protocol can be simulated by an ideal-life adversary \u00ca via the following two arguments.\n(1) \u00ca can simulate A as B\u03020 does in the proof of security against dishonest Bob (see Theorem 6.2) by sampling unconditionally binding key pkB, such that \u00ca also knows the decryption\nkey sk, extracting wB from B's commitments, and inquiring the ideal functionality FID+ .\nIn more detail, upon receiving \u03ba from B, \u00ca attempts to decode the string \u03b8\u0302 \u2295 \u03ba. If this is\nsuccessful (a codeword at distance at most d/2 is returned), it computes the password w0\nsuch that c(w0 ) is the decoded codeword. If decoding fails, \u00ca chooses an arbitrary w0 . It then\nsends w0 to FID+ .\nIf the functionality replies by (correct, kA ), then \u00ca completes the simulation by following\nthe protocol with inputs w0 = wA and kA . In that case, the simulation is perfect and the\nfinal outputs are equal.\nIn case the extracted password w0 does not match wA , \u00ca follows the protocol but uses\n0\nrandom values syn0 , tag \u2217 and z 0 . Note that the real A would use z = f (x|IwA ) \u2295 g(wA )\ninstead of random z 0 . Thus, we have to argue that f (x|IwA ) is statistically close to random\nand independent of the view of E (for any fixed w0 ). Recall that the common state after the\nverification phase is statistically close to a state for which it is guaranteed that H\u221e (X|I ) \u2265\ndH (\u03b8|I , \u03b8\u0302|I ) \u2212 \u03b2n for any I \u2286 {1, . . . , n}, and H0 (\u03c1E ) \u2264 \u03b2n. Hence, switching between these\ntwo states has only a negligible effect on the final output, and thus we may assume these\nbounds also to hold here. By the way w0 was chosen, it is guaranteed that \u03b8\u0302 \u2295\u03ba has Hamming\ndistance at most d/2 from c(w0 ), which is at distance greater than d from c(w). Thus, the\n\n83\n\n\f84\n\nCHAPTER 6. APPLICATIONS\nHamming distance between \u03b8\u0302 \u2295 \u03ba and c(w) is at least d/2, except with negligible probability.\nThe same holds if decoding fails, since \u03b8\u0302 \u2295 \u03ba is at least d/2 away from any codeword and\nc(w)\u2295\u03ba has distance at least d/2 from \u03b8\u0302. It follows that the Hamming distance between \u03b8|IwA\nand \u03b8\u0302|IwB is at least (d/4\u2212\u03b5)n. Therefore, we can conclude that H\u221e (X|IwA ) \u2265 d/4\u2212\u03b5n\u2212\u03b2n.\nFinally, note that by the property of the code family as described previously, it follows\nthat if H\u221e (X|IwA ) > 2H0 (\u03c1E ) with a linear gap, then syn is close to uniformly distributed\nfrom E's point of view. Then, from the extractor property of M AC \u2217 , it follows that tag \u2217 is\nessentially random and independent of k, f, test, T, w, w0 , \u03b8 and E, conditioned on w 6= w0 .\nAnd further, privacy amplification guarantees that f (x|IwA ) is uniformly distributed and\nthus z is close to random and independent of E (conditioned on wA 6= w0 ). Now, given the\ntwo `-bit strings tag \u2217 and z, the bound on the min-entropy is slightly reduced by 2`.\n(2) \u00ca can also simulate modified B\u2217 up to before the final step, as B\u2217 uses a \"dummy input\". If\nsimulated A rejects in the verification, or E has modified one of the communicated messages,\nthen \u00ca sends \"override bit\" d = 0 to the ideal functionality. Otherwise, it sends d = 1\nand therewith learns, whether wA = wB or not. In both cases, \u00ca can easily complete the\nsimulation for B\u2217 . The claim follows.\n\u0004\nProposition 6.4 If |W| \u2264 2\u03bdn , then protocol C \u03b1 (QID+ ) is unconditionally secure against\n\u03b3(1\u2212\u03b1)-BQSM Eve with \u03b3 < 2\u03b4 \u2212 \u03bd \u2212 2`, according to Definition 6.1.\nProof. Here, we can reason similarly to the proof in [DFSS07] against a man-in-the-middle.\nBy the security of the MAC, E cannot modify any classical message without being detected (and the extractor property guarantees re-usability). Therefore, one can show security\nagainst E up to the point before B announces whether to accept the protocol execution or\nnot.\nIn order to show security even after B has announced his decision, one can make the\nfollowing case distinction. If E modifies the quantum communication in such a way that she\nonly introduces a few errors in the test set, then she also only introduced a few errors in the\nremaining positions, except with small probability. Those positions will be corrected by the\nerror correction, and thus, B accepts-independent of what w is. In the other case, namely\nif E modifies the quantum communication in such a way that she introduces many errors in\nthe test set, then A rejects already early in the protocol-independent of what w is. Hence,\nthis case distinction does not depend on w. It follows that B's announcement of whether he\naccepts or rejects gives away no information on w.\nLet w0 denote E's guess on the password. Then, if w0 6= w, xI|w has d/4 \u2212 \u03bd bits of\nentropy, given w, w0 and \u03b8. Furthermore, given tag \u2217 and f (x|Iw ), the min-entropy is reduced\nby 2`. By the properties of the code family and the privacy amplification property of M AC \u2217\nand the hash-function, we get that syn as well as tag \u2217 and f are essentially random and\nindependent, conditioned on w 6= w0 , for \u03b3 < d/4 \u2212 \u03bd \u2212 2`.\n\u0004\n\n\fPart III\n\nCryptography in the Quantum\nWorld\n\n\f\f7\nchapter\n\nIntroduction\nIn this part of the thesis, we want to investigate classical cryptography in the quantum world,\nwhich means that we consider the security of classical protocols subject to quantum attacks.\nThis scenario is of practical importance and independent of any progress towards large-scale\nquantum computing. In the following sections, we introduce various commitment schemes\nand extended variants thereof, which we will use as underlying constructions of the protocols\nin the subsequent chapters.\nIn Chapter 8, we show that a quantum-secure bit commitment, as discussed in Section 7.1,\nimplies a quantum-secure single coin-flip. Then, we will use the mixed commitments, described in Part II, Section 4.1, together with a variation of its extended construction (described in Section 7.2) to equip the underlying commitment construction with extraction and\nequivocability such that we achieve an efficiently simulatable and more general composable\nsingle coin-flip.\nIn Chapter 9, we propose a framework for the quantum-secure amplification of the security\ndegree of coins, where we rely on the mixed commitments of Section 4.1. One step towards a\nfully simulatable coin-flipping protocol, however, requires an extended construction allowing\nfor an untypical way of opening a commitment in that, instead of sending the plaintext, we\ndo a trapdoor opening (Section 7.3).\nIn Chapter 10, we show different example applications, where the interactive generation\nof coins at the beginning or during outer protocols results in implementations without set-up\nassumptions and allows for quantum-secure realizations of classical schemes.\n\n7.1\n\nRegular Bit Commitment\n\nIn Chapter 8, we will show a natural and direct translation of standard coin-flipping to\nthe quantum world. Recall from Section 2.4.1 that commitments imply coin-flipping. More\nspecifically, we require an unconditionally binding and quantum-computationally hiding bit\ncommitment scheme from A to B that takes a bit and some randomness r of length ` as input,\ni.e. commit : {0, 1} \u00d7 {0, 1}` \u2192 {0, 1}\u2217 . As discussed, the unconditionally binding property\nis fulfilled, if it is impossible for any forger F\u0303 to open one commitment to both 0 and 1,\ni.e. to compute r, r0 such that commit (0, r) = commit (1, r0 ) . Quantum-computationally\nhiding is ensured, if no quantum distinguisher D\u0303 can distinguish between commit (0, r) and\ncommit (1, r0 ) for random r, r0 with non-negligible advantage. Note that we will use this\nsimple notation for the commitments in the following sections. For a specific scheme, the\nprecise notation has to be naturally adapted.\n\n\f88\n\nCHAPTER 7. INTRODUCTION\nFor an actual instantiation we can use, for instance, Naor's commitment based on a\npseudorandom generator [Nao91]. A pseudorandom generator is a function that maps a\nshort, randomly chosen seed to a long pseudorandom sequence, which is computationally\nindistinguishable from a truly random string for any polynomial-time bounded adversary.\nInformally speaking, pseudorandomness ensures unpredictability of the next bit in the sequence after learning the previous one. There are two main arguments for commitments\nbased on pseudorandomness. First, this construction does not require any initially shared\ninformation between the players. This aspect is of particular importance, when we later\npropose sequential coin-flipping for actually implementing the CRS-model assumption, and\ntherewith, implementing other functionalities from scratch without any set-up assumptions.\nThe second reason relates to our claim of quantum security. Given any one-way function,\npseudorandom generators can be constructed, where its security parameter is defined by the\nlength of the seeding key. A brute-force search through the key space would find all seeds,\nand thus, all pseudorandom sequences could be computed. Now, under the assumption of a\nquantum-secure one-way function, Grover's optimal quantum search algorithm provides only\nquadratic speed-up for brute-searching. More efficient attacks are not known, and therewith,\nwe claim that for any poly-time bounded quantum adversary, we achieve quantum-secure\nschemes.\nMore formally [Nao91], let f (n) denote a function with f (n) > n. Then, G : {0, 1}n \u2192\n{0, 1}f (n) defines a pseudorandom generator, if for all polynomial-time (quantum) distinguisher D\u0303, it holds that\n|P r[D\u0303(y) = 1] \u2212 P r[D\u0303(G(s)) = 1]| \u2264 \u03b5 ,\nwhere y \u2208R {0, 1}f (n) , s \u2208R {0, 1}n , and \u03b5 is negligible in the security parameter n. A bit\ncommitment scheme using pseudorandomness is now constructed as follows. Let a be the\nbit to which Alice wants to commit, and let Gi (s) denote the ith bit of the pseudorandom\nsequence on seed s. To ensure the binding property, the receiver Bob sends a random vector\nRB = (r1 , . . . , r3n ) where ri \u2208R {0, 1} for 1 \u2264 i \u2264 3n. Alice selects s \u2208R {0, 1}n and sends\n0 ), where\nthe vector RA = (r10 , . . . , r3n\n(\nGi (s)\nif ri = 0\n0\nri =\nGi (s) \u2295 a if ri = 1 .\nTo open the commitment, Alice sends s and Bob then verifies that for all i, ri0 = Gi (s) for\nri = 0 and ri0 = Gi (s) \u2295 a for ri = 1.\nAssuming that a dishonest receiver is polynomial-time bounded, he cannot learn anything\nabout a. Otherwise, he could be used to construct a distinguisher D\u0303 between pseudorandom and truly random outputs. This also holds in the quantum world, since the reduction\ndoes not require rewinding. It follows that any quantum-computationally bounded receiver\ncan only guess a with probability essentially 1/2, so the commitment scheme is quantumcomputationally hiding.\nFor any (unbounded) dishonest committer, opening a commitment to both values 0 and\n1, requires a seed pair (s1 , s2 ), such that sequences G3n (s1 ) and G3n (s2 ) agree for all i where\nri = 0 and disagree for all i where ri = 1, i.e. ri = Gi (s1 ) \u2295 Gi (s2 ) for exactly one RB chosen\n\n\f7.2. EXTENDED CONSTRUCTION FOR MIXED COMMITMENTS\nby the other player. The probability for the existence of such a pair is at most 22n /23n = 2\u2212n .\nIt follows that the committer can reveal only one possible a, except with probability less than\n2\u2212n , which satisfies statistical binding.\n\n7.2\n\nExtended Construction for Mixed Commitments\n\nWe will, also in the context of a single coin-flip, need an extended construction, which is\nsimilar to the extension of Section 4.1.4 but adapted to the case of an underlying commitment from A to B with flavors unconditionally binding and quantum-computationally hiding.\nWe again aim at providing the respective simulator with a trapdoor for either extraction to\nefficiently simulate in case of A0 or equivocability to avoid rewinding B0 . As in Section 4.1.4,\nwe require\u0001 a \u03a3-protocol for a (quantumly) hard relation R = {(x, w)} with conversations\na\u03a3 , c\u03a3 , z\u03a3 . Furthermore, we will also use the keyed dual-mode commitment scheme described in Section 4.1.2, based on the multi-bit version of [PVW08] with keys pkH and pkB,\nq\nwhere it holds that pkH \u2248 pkB.\nIn the real protocol, the common reference string consists of commitment key pkB and an\nq\ninstance x0 for which it holds that @ w0 such that (x0 , w0 ) \u2208 R, where we assume that x \u2248 x\u00010 .\nTo commit to bit a, A runs the honest-verifier simulator to get a conversation a\u03a3 , a, z\u03a3 .\nShe then sends a\u03a3 and two commitments C0 , C1 to B, where Ca = commit pkB (z\u03a3 , ra ) and\u0001\n0\nC1\u2212a = commit pkB (0z , r1\u2212a ) with randomness ra , r1\u2212a and z 0 = |z\u03a3 |. Then,\na, (z\u03a3 , ra )\n\u0001\n\u03a3\n\u03a3\nis send to open the relevant commitment Ca , and B checks that a , a, z is an accepting conversation. Assuming that the \u03a3-protocol is honest-verifier zero-knowledge and pkB\nleads to unconditionally binding commitments, the new commitment construction is again\nunconditionally binding.\nDuring simulation, \u00c20 chooses a pkB such that it knows the matching decryption key sk.\nThen, it can extract A0 's choice bit a by decrypting both C0 and C1 and checking which\ncontains a valid z\u03a3 . Again, not both C0 and C1 can contain a valid reply, since otherwise, A0\nwould know a w0 such that (x0 , w0 ) \u2208 R. In order to simulate in case of B0 , B\u03020 chooses pkH\nand x. Hence, the commitment is unconditionally hiding in this simulation. Furthermore,\nit can be equivocated, since now \u2203 w with (x, w) \u2208 R and therefore, C0 , C1 can both be\ncomputed with valid replies, i.e. C0 = commit pkH (z\u03a3 0 , r0 ) and C1 = commit pkH (z\u03a3 1 , r1 ) .\nQuantum-computational security against B0 follows from the indistinguishability of the keys\npkB and pkH and the indistinguishability of the instances x and x0 , and efficiency of both\nsimulations is ensured, due to extraction and equivocability.\n\n7.3\n\nTrapdoor Opening for Mixed Commitments\n\nThe typical notion of mixed commitment schemes is stronger than we require for our basic\nconstruction of mixed commitments, namely, it postulates trapdoors for both extraction and\nequivocability. As previously discussed, it suffices in our basic construction to only rely on\nan extraction trapdoor. This aspect is very convenient, since it allows us to weaken the\nassumption on its underlying construction, i.e., we can build it from a public-key cryptosystem with regular keys pk and sk as binding commitment key and extraction key, and\nrequire only an indistinguishable hiding key, generated as a random string in the key space.\n\n89\n\n\f90\n\nCHAPTER 7. INTRODUCTION\nThis, in turn, offers the possibility of generating the hiding key solely by a precedent interactive coin-flipping procedure without any set-up assumptions. For a more advanced usage of\ncommitments as in our strong coin-flipping notion in Chapter 9, however, we have (in some\nsense) the requirement of equivocability. We want to maintain the interactive generation of\nthe key at any rate, which means that we do not have enough control of its generation and\neven less control to equip it with a trapdoor (as done in Sections 4.1.4 and 7.2).\nWe therefore develop a special notion of trapdoor opening, where the ability to do a\ntrapdoor opening is not associated to a special knowledge of the hiding key, but is rather\ndone by cheating in the opening phase. Specifically, we do the opening not by sending the\nplaintext and the randomness, committed to in the first phase but instead by sending only\nthe plaintext and then doing an interactive proof that this plaintext is indeed what was\ncommitted to. The ability to do trapdoor openings will then be associated with being able\nto control the challenge in the interactive proof. We will get this control by using a weak\ncoin-flipping protocol as sub-protocol. This will be one of the essential steps in bootstrapping\nfully simulatable strong coin-flipping from weak coin-flipping.\nAs before, we denote the mixed string commitment scheme of Section 4.1 by commitpk .\nLet \u03ba be the security parameter defining the key space {0, 1}\u03ba and let \u03c3 be the secondary\nsecurity parameter controlling the soundness error in the interactive proof, which we want to\nbe negligible in \u03c3 when commitpk is unconditionally binding. We equate the plaintext space\n{0, 1}` of commitpk with the Galois field F = F2\u03ba . The new extended commitment scheme,\nequipped with the possibility to do trapdoor openings, is denoted by COMMITpk . We assume\nits plaintext space to be F\u03c3 and denote by sss a secret sharing scheme over F.\nGiven message m = (m1 , . . . , m\u03c3 ) \u2208 F\u03c3 and randomizer s = (s1 , . . . , s\u03c3 ) \u2208 F\u03c3 , let fm,s (X)\ndenote the unique polynomial of degree 2\u03c3 \u2212 1, for which fm,s (\u2212i + 1) = mi for i = 1, . . . , \u03c3\nand fm,s (i) = si for i = 1, . . . , \u03c3. Furthermore, we \"fill up\" positions i = \u03c3 + 1, . . . , \u03a3, where\n\u03a3 = 4\u03c3, by letting si = fm,s (i). The shares are now s = (s1 , . . . , s\u03a3 ). The new commitment\nscheme COMMITpk is described in Figure 7.1.\nWe stress two simple facts about this scheme. First, for any message m \u2208 F\u03c3 and any\nsubset S \u2282 {1, . . . , \u03a3} of size |S| = \u03c3, the shares s|S are uniformly random in F\u03c3 , when\nS is chosen uniformly at random in F\u03c3 and independent of m. This aspect is trivial for\nS = {1, . . . , \u03c3}, as we defined it that way, and it extends to the other subsets using Lagrange\ninterpolation. And second, if m1 , m2 \u2208 F\u03c3 are two distinct messages, then sss(m1 ; s1 )\nand sss(m2 ; s2 ) have Hamming distance at least \u03a3 \u2212 2\u03c3. Again, this follows by Lagrange\ninterpolation, since the polynomial fm1 ,s1 (X) has degree at most 2\u03c3 \u2212 1, and hence, can be\ncomputed from any 2\u03c3 shares si using Lagrange interpolation. The same holds for fm2 ,s2 (X).\nThus, if 2\u03c3 shares are the same, then fm1 ,s1 (X) and fm2 ,s2 (X) are the same, which implies\nthat the messages m1 = fm1 ,s1 (\u2212\u03c3 + 1), . . . , fm1 ,s1 (0) and m2 = fm2 ,s2 (\u2212\u03c3 + 1), . . . , fm2 ,s2 (0)\nare the same.\nFirst note that if the underlying commitment commitpk is unconditionally hiding, then\nso is COMMITpk . In the following, we investigate the extraction property of COMMITpk , under\nthe assumption that we work in\u0001 the unconditionally binding mode of commitpk . Given any\ncommitment M = M1 , . . . , M\u03a3 , we extract\n\u0001\nxtrsk (M1 ), . . . , xtrsk (M\u03a3 ) = (s1 , . . . , s\u03a3 ) = s .\nAssume s0 = (s01 , . . . , s0\u03a3 ) is the consistent sharing closest to s. That means that s0 is the\n\n\f7.3. TRAPDOOR OPENING FOR MIXED COMMITMENTS\n\nCommitment Scheme COMMITpk :\nCommitment Phase:\n1. Let message m \u2208 F\u03c3 be the message to get committed to. The committer samples uniformly random s \u2208 F\u03c3 and computes the shares sss(m; s) =\n(s1 , . . . , s\u03a3 ), where si \u2208 F.\n\u0001\n\u0001\n2. He computes COMMIT pk m, (s, r) = M1 , . . . , M\u03a3 . In more detail, for i =\n1, . . . , \u03a3, the committer computes Mi = commit pk (si , ri ) with shares s =\n(s1 , . . . , s\u03a3 ) and randomness r = (r1 , . . . , r\u03a3 ).\n3. The committer sends (M1 , . . . , M\u03a3 ).\nOpening Phase:\n1. The committer sends the shares s = (s1 , . . . , s\u03a3 ) to the receiver.\n2. If the shares are not consistent with a polynomial of degree at most 2\u03c3 \u2212 1,\nthe receiver aborts. Otherwise, he picks a uniformly random subset S \u2282\n{1, . . . , \u03a3} of size |S| = \u03c3 and sends S to the committer.\n3. The committer sends r|S .\n4. The receiver verifies that Mi = commit pk (si , ri ) for all i \u2208 S. If the test fails,\nhe aborts. Otherwise, he computes the message m \u2208 F\u03c3 consistent with s.\n\nFigure 7.1: The Commitment Scheme COMMITpk .\n\n91\n\n\f92\n\nCHAPTER 7. INTRODUCTION\nvector which is consistent with a polynomial fm0 ,s0 (X) of degree at most 2\u03c3 \u2212 1 and which at\nthe same time differs from s in the fewest positions. Note that we can find s0 in poly-time\nwhen using a Reed Solomon code, which has efficient minimal distance decoding. We then\ninterpolate this polynomial fm0 ,s0 (X), let m0 = fm0 ,s0 (\u2212\u03c3 + 1), . . . , fm0 ,s0 (0), and define m0 to\nbe the message committed to by COMMITpk . Any other sharing s00 = (s001 , . . . , s00\u03a3 ) must have\nHamming distance at least 2\u03c3 to s0 . Now, since s is closer to s0 than to any other consistent\nsharing, it must, in particular, be closer to s0 then to s00 . This implies that s is at distance\nat least \u03c3 to s00 .\nWe will use this observation for proving soundness of the opening phase. To determine\n0\nthe soundness error, assume that COMMITpk does not open to\n\u0001 the shares s consistent with s.\nAs observed, this implies that xtrsk (M1 ), . . . , xtrsk (M\u03a3 ) has Hamming distance at least\n\u03c3 to s0 . However, when commitpk is unconditionally binding, all Mi can only be opened to\nxtrsk (Mi ). From the above two facts, we have that there are at least \u03c3 values i \u2208 {1, . . . , \u03a3}\nsuch that the receiver cannot open Mi to si for i \u2208 S. Since \u03a3 = 4\u03c3, these \u03c3 bad indices\n(bad for a dishonest sender) account for a fraction of 14 of all points in {1, . . . , \u03a3}. Thus, the\nprobability that none of the \u03c3 points in S is a bad index is at most ( 43 )\u03c3 , which is negligible.\nLemma 7.1 follows.\nLemma 7.1 If pk is unconditionally binding, \u0001then the probability that an unbounded cheating\ncommitter can open M = COMMIT pk m, (s, r) to a plaintext different from xtrsk (M ) is at\nmost ( 43 )\u03c3 , assuming that the challenge S is picked uniformly at random and independent of\nM.\nIn the context of simulation, we will use the challenge S as the simulators trapdoor,\nallowing him to equivocally open his commitments. In such a simulation, the ideal-world\nadversary \u015c can-by means discussed later-enforce a specific challenge, i.e., it is guaranteed\nthat this will be the challenge in the opening phase. Thus, for simplicity, we assume here\nthat it simply gets a fixed challenge S as input. The simulation is described in Figure 7.2.\nLemma 7.2 follows via a hybrid argument, which relies on the quantum-computational indistinguishability in switching unconditionally binding and unconditionally hiding commitment\nkeys. We omit a proof here but refer to Chapter 9, where the construction will be explicitly\nproven within its outer construction.\nLemma 7.2 If m\u0303 = m, then the transcript of the protocol is identical to that of an honest\ncommitment to m, followed by an honest opening phase to m, and run with a uniformly\nrandom challenge S.\nIf m\u0303 6= m, then the transcript of the protocol is quantum-computationally indistinguishable\nto that of an honest commitment to m\u0303, followed by an honest opening phase to m\u0303, and run\nwith a uniformly random challenge S.\n\n\fSimulating COMMITpk with Trapdoor S:\n1. \u015c gets as input a uniformly random subset S \u2282 {1, . . . , \u03a3} of size \u03c3 and an initial\nmessage m \u2208 F\u03c3 .\n\u0001\n2. \u015c commits honestly to m \u2208 F\u03c3 by M = COMMIT sk m, (s, r) , as specified in the\ncommitment phase.\n3. \u015c is given an alternative message m\u0303 \u2208 F\u03c3 , i.e., the aim is opening M to m\u0303.\n4. \u015c lets s|S be the \u03c3 messages committed to by M |S . Then it interpolates the unique\npolynomial fm\u0303,s of degree at most 2\u03c3 \u2212 1 for which fm\u0303,s (i) = si for i \u2208 S and for\nwhich fm\u0303,s (\u2212i + 1) = m\u0303i for i = 1, . . . , \u03c3. Note that this is possible, as we have ex-\u0001\nactly 2\u03c3 points which restrict our choice of fm\u0303,s . \u015c sends s = fm\u0303,s (1), . . . , fm\u0303,s (\u03a3)\nto the receiver.\n5. The receiver sends the challenge S.\n6. For all i \u2208 S, the sender opens Mi to fm\u0303,s (i). This is possible, since fm\u0303,s (i) = si is\nexactly the message committed to by Mi when i \u2208 S.\n\nFigure 7.2: The Ideal-World Simulation of COMMITpk .\n\n\f\f8\nchapter\n\nQuantum-Secure Coin-Flipping\nCoin-flipping is introduced in Section 2.4.4 and allows two parties to agree on a uniformly\nrandom bit in a fair way. Security for both parties follows, if neither party can influence the\nvalue of the coin to his advantage. Thus, it enables the parties to interactively generate true\nrandomness from scratch. The chapter is based on parts of [DL09].\n\n8.1\n\nMotivation and Related Work\n\nWe are interested in the standard coin-flipping protocol [Blu81] with classical message exchange but we here assume that the adversary is capable of quantum computing. As already\nmentioned, bit commitment implies a secure coin-flipping, but even when basing the embedded commitment on a computational assumption that withstands quantum attacks, the\nsecurity proof of the entire coin-flipping (and its integration into other applications) could\npreviously not be translated from the classical to the quantum world.\nTypically, security against a classical adversary is argued in such a context by rewinding\nthe adversary in a simulation. Recall that, in general, rewinding as a proof technique cannot\nbe directly applied in the quantum world. Based on a recent result of Watrous [Wat09],\nwhich originally allowed to prove unconditionally that quantum zero-knowledge of certain\ninteractive proofs is possible and that the classical definitions can be translated into the\nquantum world, we show the most natural and direct quantum analogue of the classical\nsecurity proof for standard coin-flipping.\nWe want to mention an alternative approach, which was independently investigated but\nnever published [Smi09]. They propose a classical protocol for zero-knowledge proofs of\nknowledge secure against quantum adversaries. The protocol consists of a commitment\nphase and two zero-knowledge proofs. Instead of opening the commitment, the committer\nclaims the value of the committed coins and gives the first zero-knowledge proof that the\nclaim is correct. To simulate this zero-knowledge proof, Watrous' technique is used. Note\nthat this approach allows for flipping a string of coins in the commitments, and thus, arrives\nat a coin-flipping protocol with round complexity independent of the length of the flipped\nstring at first. However, the required zero-knowledge proof has round complexity depending\non the security parameter, i.e. how many proofs must be completed to achieve a negligible\nsoundness error. Finally, the coin-string is used as key to encode the witness and the second\nzero-knowledge proof is given that this statement is actually true. As encryption scheme,\nthey suggest a scheme with similar properties as in our mixed commitment constructions-\nbut at least to our best knowledge, the question of its actual secure implementation was left\n\n\f96\n\nCHAPTER 8. QUANTUM-SECURE COIN-FLIPPING\n\nProtocol COIN:\n1. A chooses a \u2208R {0, 1} and computes commit (a, r) . She sends commit (a, r) to B.\n2. B chooses b \u2208R {0, 1} and sends b to A.\n3. A sends open (a, r) and B checks if the opening is valid.\n4. Both compute coin = a \u2295 b.\n\nFigure 8.1: The Coin-Flipping Protocol.\nFunctionality FCOIN :\nUpon receiving requests start from Alice and Bob, FCOIN outputs uniformly random\ncoin to Alice. It then waits to receive Alice's second input > or \u22a5 and outputs coin or\n\u22a5 to Bob, respectively.\nFigure 8.2: The Ideal Functionality for a Coin-Flip.\nopen.\nWe stress that we aim at establishing coin-flipping as a stand-alone tool that can be used\nin several contexts and different generic constructions. Some example applications thereof\nare discussed in Chapter 10, including an independently proposed zero-knowledge proof of\nknowledge. In order to include coin-flipping securely in other applications, we conclude this\nchapter by proving the basic construction secure under sequential composition and propose\nan extended construction for general composability.\n\n8.2\n\nThe Protocol\n\nThe standard coin-flipping protocol COIN is shown in Figure 8.1, allowing players A and\nB to interactively generate a random and fair coin in one execution without any set-up\nrequirements. As underlying commitment scheme, we use the unconditionally binding and\nquantum-computationally hiding scheme described in Section 7.1 with security parameter n.\nWe will use its simpler notation here, namely commit (a, r) with input a \u2208 {0, 1}, randomness\nr \u2208 ` and output in {0, 1}\u2217 . To indicate the opening phase, where A sends a and r, we will\nwrite open (a, r) . The corresponding ideal coin-flipping functionality FCOIN is depicted in\nFigure 8.2. Note that dishonest A0 may refuse to open commit (a, r) in the real world after\nlearning B's input. For this case, FCOIN allows her a second input \u22a5, modeling the abort of\nthe protocol.\nProposition 8.1 Protocol COIN satisfies correctness, according to Definition 3.4.\nCorrectness is obvious by inspection of the protocol: If both players are honest, they\nindependently choose random bits a and b. These bits are then combined via exclusive\ndisjunction, resulting in a uniformly random coin.\n\n\f8.2. THE PROTOCOL\n\nSimulation \u00c20 :\n1. Upon receiving commit (a, r) from A0 , \u00c20 sends start and then > to FCOIN as first\nand second input, respectively, and receives a uniformly random coin.\n2. \u00c20 computes a and r from commit (a, r) .\n3. \u00c20 computes b = coin \u2295 a and sends b to A0 .\n4. \u00c20 waits to receive A0 's last message and outputs whatever A0 outputs.\n\nFigure 8.3: The Ideal-World Simulation against dishonest Alice.\nTheorem 8.1 Protocol COIN is unconditionally secure against any unbounded dishonest Alice according to Definition 3.6, provided that the underlying commitment scheme is unconditionally binding.\nProof. We construct an ideal-world adversary \u00c20 , such that the real output of the protocol\nis statistically indistinguishable from the ideal output produced by \u00c20 , FCOIN and A0 . The\nideal-world simulation is depicted in Figure 8.3.\nFirst note that a, r and commit (a, r) are chosen and computed as in the real protocol.\nFrom the statistically binding property of the commitment scheme, it follows that A0 's choice\nbit a is uniquely determined from commit (a, r) = c, since for any c, there exists at most\none pair (a, r) such that c = commit (a, r) , except with probability negligible in the security\nparameter n. Hence in the real world, A0 is unconditionally bound to her bit before she learns\nB's choice bit, which means a is independent of b. Therefore in Step (2.), the simulator can\ncorrectly (but not necessarily efficiently) compute a (and r). Note that, in the case of\nunconditional security, we do not have to require the simulation to be efficient. However,\nwe show in Section 8.3.2 how to extend the underlying commitment in order to extract A0 's\ninputs. This extraction requires a extraction trapdoor and yields an efficient simulation in\nthe CRS-model. Finally, due to the properties of XOR, A0 cannot tell the difference between\nthe random b computed from the ideal, random coin in the simulation in Step (3.) and the\nrandomly chosen b of the real world. It follows that the simulated output is statistically\nindistinguishable from the output in the real protocol.\n\u0004\nTo prove security against any dishonest quantum-computationally bounded B0 , we will\nfollow the lines of argument as in Section 3.6.3, in particular Definition 3.7, with slight\nmodifications. More specifically, we do not require a common reference string, so we can\nomit this part of the definition. Thus, we show that there exists an ideal-world simulation\nB\u03020 with output quantum-computationally indistinguishable from the output of the protocol\nin the real world. For the ideal world, we consider the poly-size input sampler, which takes\nas input only the security parameter and produces a valid input state \u03c1U ZV 0 = \u03c1U \u2194Z\u2194V 0 as\nspecified in Section 3.6.3.\nIn a simulation against a classical adversary, a classical poly-time simulator would work\nas follows. It inquires coin from FCOIN , chooses random a and r, and computes b0 = coin \u2295 a\n\n97\n\n\f98\n\nCHAPTER 8. QUANTUM-SECURE COIN-FLIPPING\nas well as commit (a, r) . It then sends commit (a, r) to B0 and receives B0 's choice bit b.\nIf b = b0 , the simulation was successful. Otherwise, the simulator rewinds B0 and repeats\nthe simulation. For a security proof against any quantum adversary, we construct a polytime quantum simulator proceeding similarly to its classical analogue. However, it requires\nquantum registers as work space and relies on Watrous' quantum rewinding lemma (see\nLemma 3.2). Recall from Section 3.5.2 that Watrous constructs the quantum simulator\nfor a \u03a3-protocol, i.e. a protocol in three-move form, where the verifier flips a single coin\nin the second step and sends this challenge to the prover. Since these are the essential\naspects also in our protocol COIN, we can apply Watrous' quantum rewinding technique\n(with slight modifications) as a black-box to our protocol. We also follow his notation and\nline of argument here. For a more detailed description and proofs, we refer to [Wat09] and\nSection 3.5.2.\nTheorem 8.2 For p0 \u2265 41 , protocol COIN is quantum-computationally secure against any\npoly-time bounded dishonest Bob (according to Definition 3.7 but with the modification described above), provided that the underlying commitment scheme is quantum-computationally\nhiding.\nProof. Let |\u03c8i denote B0 's n-qubit auxiliary input. Let W denote B0 's auxiliary input\nregister, containing |\u03c8i. Let V and B denote B0 's work space, where V is an arbitrary\npolynomial-size register and B is a single qubit register. A's classical messages are considered\nin the following as being stored in quantum registers A1 and A2 . In addition, the quantum\nsimulator uses registers R, containing all possible choices of a classical simulator, and G,\nrepresenting its guess b0 on B0 's message b in the second step. Finally, let X denote a working\nregister of size k, which is initialized to the state |0k\u0303 i and corresponds to the collection of all\nregisters as described above except W .\nThe quantum rewinding procedure is implemented by a general quantum circuit Rcoin\nwith input (W, X, B0 , coin). As a first step, it applies a unitary (n, k)-quantum circuit Q\nto (W, X) to simulate the conversation, obtaining registers (G, Y ). Then, a test takes place\nto observe whether the simulation was successful. In that case, Rcoin outputs the resulting\nquantum register. Otherwise, it quantumly rewinds by applying the reverse circuit Q\u2020 on\n(G, Y ) to retrieve (W, X) and then a phase-flip transformation on X before another iteration\nof Q is applied. Note that Rcoin is essentially the same circuit as R described in [Wat09]\n(and Section 3.5.2), but in our application it depends on the value of a given coin, i.e., we\napply R0 or R1 for coin = 0 or coin = 1, respectively.\nIn more detail, Q transforms (W, X) to (G, Y ) by the following unitary operations:\n(1.) It constructs a superposition over all possible random choices of values in the real\nprotocol, i.e.,\nE\n1 X\n\u2217\n\u221a\n|a, riR |commit (a, r) iA1 b0 = coin \u2295 a G |open (a, r) iA2 |0iB 0k\n|\u03c8iW ,\nV\n2`+1 a,r\n\u0001\nwhere k \u2217 < k. Note that the state of registers A1 , G, A2 corresponds to a uniform\ndistribution of possible transcripts of the interaction between the players.\n\n\f8.2. THE PROTOCOL\n\n99\n\n(2.) For each possible commit\u0001(a, r) , it simulates B0 's possible actions by applying a unitary\noperator to W, V, B, A1 with register A1 as control, i.e.,\nE\nE\n1 X\n\u221a\n,\n|a, riR |commit (a, r) iA1 b0 G |open (a, r) iA2 |biB \u03c6\u0303\n\u03c8\u0303\nV\nW\n2`+1 a,r\nwhere \u03c6\u0303 and \u03c8\u0303 describe modified quantum states. Note that register B now includes\nB0 's reply b.\n\u0001\n(3.) Finally, a CNOT-operation is applied to pair B, G with B as control to check whether\nthe simulator's guess of B0 's choice was correct. The result of the CNOT-operation is\nstored in register G.\nE\nE\n1 X\n\u221a\n|a, riR |commit (a, r) iA1 b0 \u2295 b G |open (a, r) iA2 |biB \u03c6\u0303\n.\n\u03c8\u0303\nV\nW\n2`+1 a,r\nNote that the qubit in register G gives the information about success or failure of the simulated run, and the other registers are combined in the residual n + k \u2212 1-qubit register\nY.\nSince the commitment scheme in the protocol is only quantum-computationally hiding,\nwe must allow for small perturbations in the quantum rewinding procedure, according to\nLemma 3.2 : Bound \u03b5 indicates B0 's advantage over a random guess on the committed value\nwith q = 1/2 (and therefore, his advantage to bias the outcome), due to his computing power,\ni.e. \u03b5 = |p \u2212 1/2|. From the hiding property of the commitment scheme, it follows that \u03b5\nis negligible in the security parameter n. Thus, we can argue that probability p is close to\nindependent of the auxiliary input. As a lower bound on the success probability, we chose\np0 \u2265 1/4, which matches our setting.\nThus, we have circuit Q as described above and our setting achieves the given bounds.\nLemma 3.2 applies. We can now construct an ideal-world quantum simulator B\u03020 (see Figure 8.4), interacting with B0 and the ideal functionality FCOIN and executing Watrous' quantum rewinding algorithm. We then compare the output states of the real process and the\nideal process. In case of indistinguishable outputs, quantum-computational security against\nB0 follows.\nFirst note that the superposition constructed as described above in circuit Q in Step (1.)\ncorresponds to all possible random choices of values in the real protocol. Furthermore,\nthe circuit models any possible strategy of quantum B0 in Step (2.), depending on control\nregister |commit (a, r) iA1 . The CNOT-operation on (B, G) in Step (3.), followed by a standard\nmeasurement of G, indicate whether the guess b0 on B0 's choice b was correct. If that was\nnot the case (i.e. b 6= b0 and measurement result 1), the system gets quantumly rewound by\napplying reverse transformations (3)-(1), followed by a phase-flip operation. The procedure\nis repeated until the measurement outcome is 0 and hence b = b0 . Watrous' technique then\nguarantees that, for negligible advantage \u03b5 and a lower bound p0 \u2265 41 , \u03b50 is negligible. Thus,\nthe final output of the simulation is close to the \"good\" state of a successful simulation.\nMore specifically, the output \u03c1(\u03c8) of Rcoin has square-fidelity close to 1 with state |\u03c6good (\u03c8)i\nof a successful simulation, i.e.\nh\u03c6good (\u03c8)|\u03c1(\u03c8)|\u03c6good (\u03c8)i \u2265 1 \u2212 \u03b50 ,\n\n\f100\n\nCHAPTER 8. QUANTUM-SECURE COIN-FLIPPING\n\nSimulation B\u03020 :\n1. B\u03020 gets B0 's auxiliary quantum input W and working registers X.\n2. B\u03020 sends start and then > to FCOIN . It receives a uniformly random coin.\n3. Depending on the value of coin, B\u03020 applies the corresponding circuit Rcoin with\ninput W, X, B0 and coin.\n4. B\u03020 receives output register Y with |\u03c6good (\u03c8)i and \"measures\nthe conversation\" to\n\u0001\nretrieve the corresponding commit (a, r) , b, open (a, r) . It outputs whatever B0\noutputs.\n\nFigure 8.4: The Ideal-World Simulation against dishonest Bob.\nwhere \u03b50 = 16 \u03b5 log2 (1/\u03b5)/(p20 (1\u2212p0 )2 ). Last, note that all operations in Q (and therewith in\nRcoin ) can be performed by polynomial-size circuits, and thus, the simulator has polynomial\nsize (in the worst case). It follows that the output of the ideal simulation is indistinguishable\nfrom the output in the real world for any quantum-computationally bounded B0 .\n\u0004\n\n8.3\n\nComposability\n\nAs already discussed in the previous part, there are several composition frameworks proposed\nfor the quantum setting, but for sequential composition we will argue along the lines of our\nsecurity framework (Section 8.3.1). In Section 8.3.2, we will use an extend commitment\nconstruction to achieve a more general composability in the CRS-model. Note that only\nsequential composition allows us to do coin-flipping from scratch.\n\n8.3.1\n\nSequential Composition\n\nRecall that we prove correctness and security for our single coin-flip according to the security\nframework as described in Section 3.6, with the one modification that we do not assume\na common reference string in the simulation against a dishonest Bob (see Theorem 8.2).\nHowever, we can still apply the Composition Theorems I and II (Theorems 3.2 and 3.3),\nwhere we also omit the reference string in the latter. We will state the composition result\nexplicitly here.\nCOIN and F = F\nF1 ***F` be a classical two-party\nCorollary 8.1 Let \u03c0i = \u03a0A,B\ni\nCOIN , and let \u03a3\nhybrid protocol which makes at most ` = poly(n) calls to the functionalities. Then, for every\ni \u2208 {1, . . . , `}, each protocol \u03c0i is a statistically secure implementation of Fi against A and\na computationally secure implementation of Fi against Bpoly .\nIt holds that there exists an ideal-world adversary \u00c20 \u2208 A such that\n\u03c01 ***\u03c0`\n\n\u03a3\noutA\n0 ,B\n\ns\n\nF1 ***F`\n\n\u2248 out\u03a3\n\u00c20 ,B0\n\n,\n\n\f8.3. COMPOSABILITY\n\n101\n\nFunctionality F`\u2212COIN :\n1. Upon receiving requests start from both Alice and Bob, F`\u2212COIN outputs uniformly\nrandom h \u2208R {0, 1}` to Alice.\n2. It then waits to receive her second input > or \u22a5 and outputs h or \u22a5 to Bob,\nrespectively.\n\nFigure 8.5: The Ideal Functionality for Sequential `-bit Coin-Flipping.\nand an ideal-world adversary B\u03020 \u2208 Bpoly such that for every efficient input sampler, we have\n\u03c01 ***\u03c0`\n\nout\u03a3\nA,B0\n\nq\n\nF1 ***F`\n\n\u2248 out\u03a3\n\u00c2,B\u03020\n\n.\n\nThe ideal functionality for sequential coin-flipping, i.e. F`\u2212COIN = \u03a3F1 ***F` , is depicted in\nFigure 8.5. Note that F`\u2212COIN is in fact derived from composing the functionality FCOIN of\na single coin-flip sequentially but interpreted more directly, e.g. it does not output the bits\none after another but as a string, and thus, does not output the precedent coins in case of\nan intermediate abort.\n\n8.3.2\n\nGeneral Composition\n\nFor our coin-flipping protocol without set-up, we cannot claim universal composability. We\ndo not require (nor obtain) an efficient simulator in case of unconditional security against\ndishonest Alice and furthermore, we allow rewinding in case of dishonest Bob. These two\naspects contradict the universal composability framework.\nEfficient simulation requires some trapdoor information in the commitment construction,\nwhich is available only to a simulator, so that it is able to extract dishonest Alice's choice bit\nefficiently. Therefore, we have to extend the commitment scheme by including an extraction\ntrapdoor. To circumvent the necessity of rewinding dishonest Bob, we further extend the\nscheme with respect to equivocability, i.e., the simulator can now construct a valid commitment, which can later be opened to both bit values as desired. Note that with such\nrequirements, the CRS-model seems unavoidable.\nAn appropriate extended construction is proposed in Section 7.2. The real-world key\nconsists of commitment key pkB and (invalid) instance x0 . During simulation against A0 , \u00c20\nchooses pkB with matching decryption key sk and therefore, it can extract A0 's choice bit a\nby decrypting both commitments C0 and C1 . In both worlds, the commitment is unconditionally binding. During simulation against B0 , B\u03020 chooses commitment key pkH and (valid)\ninstance x. Hence, the commitment is unconditionally hiding and can be equivocated by\nusing w to compute two valid replies in the underlying \u03a3-protocol. Quantum-computational\nsecurity in real life follows from the indistinguishability of the keys pkB and pkH and the\nindistinguishability of the instances x and x0 , and efficiency of both simulations is ensured\ndue to extraction and equivocability.\nAgain, by combining our extended construction in the CRS-model providing efficient\nsimulations on both sides with the results of Section 7.2 and [Unr10, Theorem 20], we get\n\n\f102\n\nCHAPTER 8. QUANTUM-SECURE COIN-FLIPPING\nCOIN computationally quantum-UC-emulates its corresponding ideal\nthe following result that \u03a0A,B\nfunctionality FCOIN for both dishonest players. In the next Chapter 9, we will show another\nmethod of achieving fully simulatability in the plain model without any set-up assumption,\nwhen both players are poly-time bounded.\n\n\f9\nchapter\n\nAmplification Framework for\nStrong Coins\nHere, we present a framework that amplifies weak security requirements on coins into very\nstrong properties, with the final result of a quantum-secure and fully simulatable coin-flipping\nprotocol, which can be implemented in the plain model from scratch. The results in this\nchapter are joint work with Nielsen [LN10].\n\n9.1\n\nMotivation\n\nCoin-Flipping of a single coin is in itself an intriguing and prolific primitive in cryptographic\nprotocol theory. Its full potential is tapped in the possibility of flipping a string of coins, which\nopens up for various applications and implementations without any set-up assumptions. We\nwill later in Chapter 10 discuss some examples thereof.\nIn this chapter, we first investigate the different degrees of security that a string of\ncoins can acquire. Then, we propose and prove constructions that allow us to amplify the\nrespective degrees of security such that weaker coins are converted into very strong ones in\na straightforward way.1 Our method only assumes mixed commitment schemes, which we\nknow how to construct with quantum security, no other assumptions are put forward. Our\nfinal result is a coin-flipping protocol, which is fully simulatable in polynomial time, even\nagainst poly-sized quantum adversaries on both sides, and which can be implemented with\nquantum-computational security in the plain model from scratch.\nOur method of amplifying the security of coin-flipping also applies to potential constant\nround coin-flipping. Such a strong and efficient construction would require a basic quantumsecure coin-flip protocol with long outcomes (in constant round), and poly-time simulatability\non one side. Its construction, however, is still a fascinating open problem in the quantum\nworld.\n1\nFor the sake of clarity, we note that we use the (intuitive) literal interpretation of \"weak\" and \"strong\"\ncoins related to their degrees of security, which differs from their definitions in the quantum literature (see\nalso Section 2.4.4).\n\n\f104\n\nCHAPTER 9. AMPLIFICATION FRAMEWORK FOR STRONG COINS\n\n9.2\n\nSecurity Notions\n\n\u03bb\u2212COIN\nWe denote a generic protocol with a \u03bb-bit coin-string as output by \u03a0A,B\n, corresponding to\nan ideal functionality F\u03bb\u2212COIN . Recall that the outcome of such a protocol is c \u2208 {0, 1}\u03bb \u222a{\u22a5},\ni.e., either an \u03bb-bit string or an error message.2 We will use several security parameters,\nindicating the length of coin-strings for different purposes. The length of a coin-flip yielding\na key and a challenge are denoted by \u03ba and \u03c3, respectively, and the length of a final coin-flip\nis indicated by `, i.e., we allow that \u03bb is a function of the respective parameter, e.g. \u03bb(\u03ba),\nbut we write \u03ba instead.\nThroughout this chapter, we restrict both players Alice and Bob to the families Apoly and\nBpoly of classical polynomial-time strategies, i.e. for the honest case, we require A, \u00c2 \u2208 Apoly\nand B, B\u0302 \u2208 Bpoly , as well as for possibly quantum dishonest entities, we demand A0 , \u00c20 \u2208 Apoly\nand B0 , B\u03020 \u2208 Bpoly . We want to stress here that, in contrast to previous chapters, both\nplayers are poly-time bounded. This means, in particular, that the ideal functionality is\ndefined symmetric such that always the respective dishonest party has an option to abort.\nFor clarity, we will explicitly show the ideal functionalities in the case of both players being\nhonest (Figure 9.1) and in the case of dishonest Alice and honest Bob (Figure 9.2). The\nlatter then also applies to honest Alice and dishonest Bob by simply switching sides and\nnames.\n\nFunctionality F\u03bb\u2212COIN with honest players:\nUpon receiving requests start from both Alice and Bob, F\u03bb\u2212COIN outputs uniformly\nrandom h \u2208R {0, 1}\u03bb to Alice and Bob.\nFigure 9.1: The Ideal Functionality for \u03bb-bit Coin-Flipping (without Corruption).\n\nFunctionality F\u03bb\u2212COIN with dishonest Alice:\n1. Upon receiving requests start from both Alice and Bob, F\u03bb\u2212COIN outputs uniformly random h \u2208R {0, 1}\u03bb to Alice.\n2. It then waits to receive her second input > or \u22a5 and outputs h or \u22a5 to Bob,\nrespectively.\n\nFigure 9.2: The Ideal Functionality for \u03bb-bit Coin-Flipping (with Corruption).\nRecall that the joint output representation of a protocol execution is denoted by out\u03a0\nA,B\n\u03bb\u2212COIN\nwith \u03a0 = \u03a0A,B\nand given here for the case of honest players. The same notation with\nF = F\u03bb\u2212COIN and \u00c2, B\u0302 applies in the ideal world as outF\n, where the players invoke the\n\u00c2,B\u0302\nideal functionality F\u03bb\u2212COIN and output whatever they obtain from it. We need an additional\n2\n\nWe want to stress that throughout the chapter, a reference to any coin-flip is understood as one run of\ncoin-flipping with a coin-string outcome.\n\n\f9.2. SECURITY NOTIONS\n\n105\n\nnotation here, describing the outcome of a protocol run between e.g. honest A and B, namely\n\u03bb\u2212COIN\nc \u2190 \u03a0A,B\n.\nWe will define three flavors of security for coin-flipping protocols, namely uncontrollable\n(uncont), random and enforceable (force). The two sides can have different flavors. Then, if\n\u03bb\u2212COIN\na protocol \u03a0A,B\nis, for instance, enforceable against Alice and random against Bob, we\n(force,random)\nwrite \u03c0\n, and similarly for the eight other combinations of security. Note that\nfor simplicity of notation, we will then omit the indexed name as well as the length of the\ncoin, as they are clear from the context. Similar to the ideal functionality for the case of\ndishonest Alice, we define all three flavors for Alice's side only, as the definitions for Bob are\nanalogue. The flavors are defined along the lines of the security framework introduced in\nSection 3.6 but with adaptions to reflect the particular context here. Recall that U 0 , Z, and\nV denote dishonest Alice's quantum and classical input, and honest Bob's classical input,\nrespectively. Note that an honest player's input is empty but models the invocation start.\nAny input state \u03c1U 0 ZV is restricted to \u03c1U 0 ZV = \u03c1U 0 \u2194Z\u2194V , such that Alice's quantum and\nBob's classical part are only correlated via Alice's classical Z. We assume again a poly-size\ninput sampler, which takes as input the security parameter, and then produces a valid input\nstate \u03c1U 0 ZV = \u03c1U 0 \u2194Z\u2194V (and analogous \u03c1U ZV 0 in case of dishonest Bob).\nWe stress that we require for all three security flavors and for all c \u2208 {0, 1}\u03bb that\n\u03bb\u2212COIN\n] = 2\u2212\u03bb ,\nPr [c \u2190 \u03a0A,B\n\nwhich implies that when both parties are honest, then the coin is unbiased. Below we only\ndefine the extra properties required for each of the three flavors.\nWe call a coin-flip uncontrollable against Alice, if she cannot force the coin to hit some\nnegligible subset, except with negligible probability.\nDefinition 9.1 (Uncontrollability against dishonest Alice) We say that the protocol\n\u03bb\u2212COIN\nimplements an uncontrollable coin-flip against dishonest Alice, if it holds for any\n\u03a0A,B\npoly-sized adversary A0 \u2208 Apoly with inputs as specified above and all negligible subsets Q \u2282\n{0, 1}\u03bb that the probability\nPr [c \u2190 \u03a0A\u03bb\u2212COIN\n: c \u2208 Q] \u2208 negl (\u03ba) .\n0 ,B\nNote that we denote by Q \u2282 {0, 1}\u03bb a family of subsets {Q(\u03ba) \u2282 {0, 1}\u03bb(\u03ba) }\u03ba\u2208N for security\nparameter \u03ba. Then we call Q negligible, if |Q(\u03ba)|2\u2212\u03bb(\u03ba) is negligible in \u03ba. In other words, we\ncall a subset negligible if it contains a negligible fraction of the elements in the set in which\nit lives.\nWe call a coin-flip random against Alice, if she cannot enforce a non-uniformly random\noutput string in {0, 1}\u03bb , except by making the protocol fail on some chosen runs. That means\nshe can at most lower the probability of certain output strings compared to the uniform case.\n\u03bb\u2212COIN\nDefinition 9.2 (Randomness against dishonest Alice) We say that protocol \u03a0A,B\nimplements a random coin-flip against dishonest Alice, if it holds for any poly-sized adversary A0 \u2208 Apoly with inputs as specified above that there exists an event E such that\n\n\f106\n\nCHAPTER 9. AMPLIFICATION FRAMEWORK FOR STRONG COINS\nPr [E] \u2208 negl (\u03ba) and for all x \u2208 {0, 1}\u03bb it holds that\nPr [c \u2190 \u03a0A\u03bb\u2212COIN\n: c = x | \u0112] \u2264 2\u2212\u03bb .\n0 ,B\nIt is obvious that if a coin-flip is random against Alice, then it is also an uncontrollable coinflip against her. We will later discuss a generic transformation going in the other direction\nfrom uncontrollable to random coin-flipping.\nWe call a coin-flip enforceable against Alice, if it is possible, given a uniformly random c,\nto simulate a run of the protocol hitting exactly the outcome c, though we still allow that\nthe corrupted party forces abort on some outcomes.\n\u03bb\u2212COIN\nDefinition 9.3 (Enforceability against dishonest Alice) We call a protocol \u03a0A,B\nenforceable against dishonest Alice, if it implements the ideal functionality F\u03bb\u2212COIN against\nher.\n\nIn more detail, that means that for any poly-sized adversary A0 \u2208 Apoly , there exists an\nideal-world adversary \u00c20 \u2208 Apoly that simulates the protocol with A0 as follows. \u00c20 requests\noutput h \u2208 {0, 1}\u03bb from F\u03bb\u2212COIN . Then it simulates a run of the coin-flipping protocol with\nA0 and tries to enforced output h. If \u00c20 succeeds, it inputs > as A0 's second input to F\u03bb\u2212COIN .\nIn that case, F\u03bb\u2212COIN outputs h. Otherwise, \u00c20 inputs \u22a5 to F\u03bb\u2212COIN as second input and\nF\u03bb\u2212COIN outputs \u22a5. The simulation is such that the ideal output is quantum-computationally\nindistinguishable from the output of an actual run of the protocol, i.e.,\nq\n\nF\nout\u03a0\nA0 ,B \u2248 out\u00c20 ,B\u0302 ,\n\nwhere \u03a0 = \u03a0A\u03bb\u2212COIN\nand F = F\u03bb\u2212COIN .\n0 ,B\nNote that an enforceable coin-flip is not necessarily a random coin-flip, as it is allowed\nthat the outcome of an enforceable coin-flip is only quantum-computationally indistinguishable from uniformly random, whereas a random coin-flip is required to produce truly random\noutcomes on the non-aborting runs.\nWe defined an enforceable coin-flip against dishonest Alice to be a coin-flip, simulatable\non her side and implementing the corresponding ideal functionality against her. The same\nresult with switched sides also holds for any poly-time bounded Bob. Thus, we obtain a\ncoin-flip protocol, for which we can simulate both sides in polynomial time. Corollary 9.1\nfollows.\n\u03bb\u2212COIN\nCorollary 9.1 Let \u03a0A,B\nbe an enforceable coin-flip against both parties Alice and Bob\n\u03bb\u2212COIN\nwith A \u2208 Apoly and B \u2208 Bpoly , i.e. \u03a0A,B\n= \u03c0 (force,force) . Then \u03c0 (force,force) is a fully\npoly-time simulatable coin-flipping protocol for the ideal functionality F\u03bb\u2212COIN with quantumcomputational indistinguishability between the real and the ideal output.\n\nCombining the part regarding simulatability in Corollary 8.1, where we again omit the\ncommon reference string, in contrast to the original Composition Theorem II (Theorem 3.3),\nwith the results of Corollary 9.1, we can show that each protocol \u03c0 (force,force) is a computationally secure implementation of F\u03bb\u2212COIN against both Apoly and Bpoly .\nCorollary 9.2 Protocol \u03c0 (force,force) composes sequentially.\n\n\f9.3. AMPLIFICATION THEOREMS\n\n9.3\n\nAmplification Theorems\n\nWe now propose and prove theorems, which allow us to amplify the security strength of\ncoins. Ultimately, we aim at constructing a strong coin-flipping protocol \u03c0 (force,force) with\noutcomes of any polynomial length ` in \u03bb from any weaker coin-flip protocol, i.e., either\nfrom a protocol \u03c0 (force,random) producing one-bit outcomes (Section 9.3.1), or from a protocol\n\u03c0 (force,uncont) giving outcomes of length \u03ba, as described in Section 9.3.2. In both cases, the\nfirst step towards \u03c0 (force,force) is to build a protocol \u03c0 (force,random) with outcomes of length\n`.\nWe want to stress that if the underlying protocol already produces `-bit outcomes and\nis constant round, then the resulting protocol \u03c0 (force,force) will also be constant round. If\nwe start from a protocol only producing constant-sized outcomes, then \u03c0 (force,force) will use\nO(`) times the number of rounds used by the underlying scheme.\nWe note here that we do not know of any candidate protocol with flavor (force, uncont)\nbut not (force, random). However, we consider it as a contribution in itself to find the weakest security notion for coin-flipping that allows to amplify to the final strong (force, force)\nnotion using a constant round reduction.\n\n9.3.1\n\nFrom Short Outcomes to Long Outcomes\n\nTo obtain long coin-flip outcomes, we can repeat a given protocol \u03c0 (force,random) with one-bit\noutcomes ` times in sequence to get a protocol \u03c0 (force,random) with `-bit outcomes. A candidate\nfor \u03c0 (force,random) with one-bit outcomes is the protocol of Chapter 8, which is-in terms of\nthis context-enforceable against one side in poly-time and random on the other side, with\nempty event E according to Definition 9.2, and the randomness guarantee even withstanding\nan unbounded adversary. The protocol was argued to be sequentially composable according\nto Corollary 8.1.\nNote that this protocol is previously described and proven as \u03c0 (random,force) . However,\ndue to the symmetric coin-flip definitions here and the restriction of entities to families of\nclassical polynomial-time strategies, we can easily switch sides between A and B.\n\n9.3.2\n\nFrom (force, uncont) to (force, random)\n\nAssume that we are given a protocol \u03c0 (force,uncont) , that only guarantees that Bob cannot\nforce the coin to hit a negligible subset (except with negligible probability). We now amplify\nthe security on Bob's side from uncontrollable to random and therewith obtain a protocol\n\u03c0 (force,random) , in which Bob cannot enforce a non-uniformly random output string, except\nby letting the protocol fail on some occasions. The stronger protocol \u03c0 (force,random) is given\nin Figure 9.3. The underlying commitment commit denotes the commitment algorithm of\nthe keyed mixed string commitment scheme as described in Section 4.1. Recall that commit\ndoes not require actual unconditionally hiding keys, but rather it suffices to use uniformly\nrandom strings from {0, 1}\u03ba , which unconditionally hide the plaintext, except with negligible\nprobability. The possibility of using random strings ensures that most keys of the given\ndomain are in that sense unconditionally hiding keys.\nProposition 9.1 Protocol \u03c0 (force,random) satisfies correctness, according to Definition 3.4.\n\n107\n\n\f108\n\nCHAPTER 9. AMPLIFICATION FRAMEWORK FOR STRONG COINS\n\nProtocol \u03c0 (force,random) :\n1. A and B run \u03c0 (force,uncont) to produce a public key pk \u2208 {0, 1}\u03ba .\n2. A samples a \u2208R {0, 1}` , commits to it with A = commit pk (a, r) and randomizer\nr \u2208R {0, 1}` , and sends A to B.\n3. B samples b \u2208R {0, 1}` and sends b to A.\n4. A opens A towards B.\n5. The outcome is c = a \u2295 b.\n\nFigure 9.3: Amplification from (force, uncont) to (force, random).\nCorrectness is obvious by inspection of the protocol. If both players are honest, they\nindependently choose random strings a and b. The result of these strings combined by the\nXOR-operation gives a uniformly random coin c of length `.\nTheorem 9.1 If \u03c0 (force,uncont) is enforceable against Alice and uncontrollable against Bob,\nthen protocol \u03c0 (force,random) is enforceable against Alice and random for Bob.\nProof (Enforceability against Alice). In case of corrupted A0 , \u00c20 samples (pk, sk) \u2190 GB\nas input. It then requests a uniformly random value h from F`\u2212COIN . It runs \u03c0 (force,uncont)\nwith A0 , in which \u00c20 enforces the outcome pk in the first step. When A0 sends commitment\nA, \u00c20 uses sk to decrypt A to learn the unique string a that A can be opened to. \u00c20\ncomputes b = h \u2295 a and sends b to A0 . If A0 opens commitment A correctly, then the result\nis c = a \u2295 b = a \u2295 (h \u2295 a) = h as desired. In case she does not open correctly, \u00c20 aborts with\nresult \u22a5. Otherwise, \u00c20 outputs whatever A0 outputs.\nSince h is uniformly random and independent of A and a, it follows that b = h \u2295 a is\nuniformly random and independent of A, exactly as in the protocol. Therefore, the transcript\nof the simulation has the same distribution as the real protocol, except that pk is uniform\nin X and not in {0, 1}\u03ba . This is, however, quantum-computationally indistinguishable, as\notherwise, A0 could distinguish random access to samples from X from random access to\nsamples from {0, 1}\u03ba . The formal proof proceeds through a series of hybrids as described in\nfull detail in the proof for Theorem 9.2 in the next Section 9.3.3.\nThe above two facts, that first we hit h when we do not abort, and second that the transcript of the simulation is quantum-computationally indistinguishable from the real protocol,\nshow that the resulting protocol is enforceable against Alice and simulatable on Alice's side\nfor functionality F`\u2212COIN , according to Definition 9.3 combined with Theorem 9.3.\n\u0004\nProof (Randomness against Bob). For any B0 , pk is uncontrollable, i.e. pk \u2208 {0, 1}\u03ba \\\nX , except with negligible probability, as X is negligible in {0, 1}\u03ba . This, in particular, means\nthat the commitment A is perfectly hiding the value a. Therefore, a is uniformly random and\nindependent of b, and thus, h = a \u2295 b is uniformly random. This proves that the resulting\ncoin-flip is random against Bob, according to Definition 9.2.\n\u0004\n\n\f9.3. AMPLIFICATION THEOREMS\n\nProtocol \u03c0 (force,force) :\n1. A and B run \u03c0 (force,random) to produce a random public key pk \u2208 {0, 1}\u03ba .\n\u0001\n2. A computes and sends commitments COMMIT pk a, (s, r) = (A1 , . . . , A\u03a3 ) to B. In\nmore detail, A samples uniformly random a, s \u2208 F\u03c3 . She then computes sss(a; s) =\n(a1 , . . . , a\u03a3 ) and Ai = commit pk (ai , ri ) for all i = 1, . . . , \u03a3.\n3. B samples uniformly random b \u2208 {0, 1}` and sends b to A.\n4. A sends secret shares (a1 , . . . , a\u03a3 ) to B. If (a1 , . . . , a\u03a3 ) is not consistent with a\npolynomial of degree at most (2\u03c3 \u2212 1), B aborts.\n5. A and B run \u03c0 (random,force) to produce a challenge S \u2282 {1, . . . , \u03a3} of length |S| = \u03c3.\n6. A sends r|S to B.\n7. B checks if Ai = commit pk (ai , ri ) for all i \u2208 S. If that is the case, B computes\nmessage a \u2208 F\u03c3 consistent with (a1 , . . . , a\u03a3 ) and the outcome of the protocol is\nc = a \u2295 b. Otherwise, B aborts and the outcome is c = \u22a5 .\n\nFigure 9.4: Amplification from (force, random) to (force, force).\n\n9.3.3\n\nFrom (force, random) to (force, force)\n\nWe now show how to obtain a coin-flipping protocol, which is enforceable against both\nparties. Then, we can also claim by Corollary 9.1 that this protocol is a strong coin-flipping\nprotocol, poly-time simulatable on both sides for the natural ideal functionality F`\u2212COIN . The\nprotocol \u03c0 (force,force) is described in Figure 9.4.\nNote that the final protocol makes two calls to a subprotocol with random flavor on\none side and enforceability on the other side, but where the sides are interchanged for each\ninstance, i.e. \u03c0 (force,random) and \u03c0 (random,force) . That means that we switch the players' roles\nas well as the direction of the messages. Furthermore, note that we use here the possibility\nof trapdoor openings in our extended commitment construction COMMIT, based on secret\nsharing and mixed commitments, as described in detail in Section 7.3.\nProposition 9.2 Protocol \u03c0 (force,force) satisfies correctness, according to Definition 3.4.\nAgain, correctness can be trivially checked, first by observing that honest players independently input uniformly random strings a and b, and second by verifying that these strings\ncombined by XOR result in a uniformly random coin c of length `.\nTheorem 9.2 If \u03c0 (force,random) is enforceable against Alice and random against Bob, then\nprotocol \u03c0 (force,force) is enforceable against both Alice and Bob.\nProof (Enforceability against Alice). If A0 is corrupted, \u00c20 samples (pk, sk) \u2190 GB as\ninput and enforces \u03c0 (force,random) in the first step to hit the outcome pk. It then requests\n\n109\n\n\f110\n\nCHAPTER 9. AMPLIFICATION FRAMEWORK FOR STRONG COINS\n0\nvalue h from F`\u2212COIN\n. When A0 sends commitments\nsk to extract a0\n\u0001\n\u0001 0 (A1 , . . . , A\u03a3 ), \u00c2 uses\n0\n0\n0\nwith a1 , . . . , a\u03a3 = xtrsk (A1 ), . . . , xtrsk (A\u03a3 ) . \u00c2 then sets b = h \u2295 a , and sends b to A0 .\nThen \u00c20 finishes the protocol honestly. In the following, we will prove that the transcript is\nquantum-computationally indistinguishable from the real protocol and that if c 6= \u22a5, then\nc = h, except with negligible probability.\nFirst, we show indistinguishability. The proof proceeds via a hybrid argument.3 Let D 0\ndenote the distribution of the output of the simulation as described. We now change the\nsimulation such that, instead of sending b = h \u2295 a0 , we simply choose a uniformly random\nb \u2208 {0, 1}` and then output the corresponding h = a0 \u2295 b. Let D 1 denote the distribution of\nthe output of the simulation after this change. Since h is uniformly random and independent\nof a0 in the first case, it follows that then b = h \u2295 a0 is uniformly random. Therefore, the\nchange to choose a uniformly random b in the second case actually does not change the\ndistribution at all, and it follows that D 0 = D 1 .\nBy sending a uniformly random b, we are in a situation where we do not need the\ndecryption key sk to produce D 1 , as we no longer need to know a0 . So we can now make\nthe further change that, instead of forcing \u03c0 (force,random) to produce a random public key\npk \u2208 X , we force it to hit a random public key pk \u2208 {0, 1}\u03ba . This produces a distribution\nD 2 of the output of the simulation. Since D 1 and D 2 only differ in the key we enforce\n\u03c0 (force,random) to hit and the simulation is quantum poly-time, there exists a poly-sized circuit\nQ, such that Q(U(X )) = D 1 and Q(U({0, 1}\u03ba )) = D 2 , where U(X ) and U({0, 1}\u03ba ) denote\nthe uniform distribution on X and the uniform distribution on {0, 1}\u03ba , respectively. As\nU(X ) and U({0, 1}\u03ba ) are quantum-computationally indistinguishable, and Q is poly-sized,\nit follows that Q(U(X )) and Q(U({0, 1}\u03ba )) are quantum-computationally indistinguishable,\nq\nand therewith, D 1 \u2248 D 2 .\nA last change to the simulation is applied by running \u03c0 (force,random) honestly instead\nof enforcing a uniformly random pk \u2208 {0, 1}\u03ba . Let D 3 denote the distribution obtained\nafter this change. As given in Definition 9.3, real runs of \u03c0 (force,random) and runs enforcing\na uniformly random value are quantum-computationally indistinguishable. Using a similar\nargument as above, where Q is the part of the protocol following the run of \u03c0 (force,random) ,\nq\nq\nwe get that D 2 \u2248 D 3 . Finally by transitivity, it follows that D 0 \u2248 D 3 . The observation\nthat D 0 is the distribution of the simulation and D 3 is the actual distribution of the real\nprotocol concludes the first part of the proof.\nWe now argue the second part, i.e., if c 6= \u22a5, then c = h, except with negligible probability. This follows by arguing soundness of the commitment scheme COMMIT, according\nto Lemma 7.1. Recall that, if pk \u2208 X , then the probability that A0 can open any A to a\nplaintext different from xtrsk (A) is at most ( 34 )\u03c3 when S is picked uniformly at random\nand independent of A. The requirement on S is however guaranteed (except with negligible\nprobability) by the random flavor of the underlying protocol \u03c0 (random,force) producing S. This\nconcludes the proof of enforceability against Alice, as given in Definition 9.3.\n\u0004\n3\n\nBriefly, a hybrid argument is a proof technique to show that two (extreme) distributions are computationally indistinguishable via proceeding through several (adjacent) hybrid distributions. If all adjacent\ndistributions are pairwise computationally indistinguishability, it follows by transitivity that the two end\npoints are so as well. We want to point out that we are not subject to any restrictions in how to obtain the\nhybrid distributions as long as we maintain indistinguishability.\n\n\f9.3. AMPLIFICATION THEOREMS\n\nSimulation B\u03020 for \u03c0 (force,force) :\n1. B\u03020 requests h from F`\u2212COIN and runs \u03c0 (force,random) honestly with B0 to produce a\nuniformly random public key pk \u2208 {0, 1}\u03ba .\n\u0001\n2. B\u03020 computes COMMIT pk a0 , (s, r) = (A1 , . . . , A\u03a3 ) for uniformly random a0 , s \u2208 F\u03c3\nand sends (A1 , . . . , A\u03a3 ) to B0 .\n3. B\u03020 receives b from B0 .\n4. B\u03020 computes a = b \u2295 h. It then picks a uniformly random subset S \u2282 {1, . . . , \u03a3}\nwith |S| = \u03c3, and lets a0 |S be the \u03c3 messages committed to by A|S . Then, it\ninterpolates the unique polynomial f of degree at most (2\u03c3 \u2212 1) for which f (i) = a0i\nfor i \u2208 S and for which f (\u2212i + 1) = ai for i \u2208 {1, . . . , \u03a3} \\ S. Finally, it sends\n(f (1), . . . , f (\u03a3)) to B0 .\n5. During the run of \u03c0 (random,force) , B\u03020 enforces the challenge S.\n6. B\u03020 sends r|S to B0 .\n7. B\u03020 outputs whatever B0 outputs.\nFigure 9.5: Simulation for Bob's force in \u03c0 (force,force) .\nProof (Enforceability against Bob).\nTo prove enforceability against corrupted B0 ,\n0\nwe construct a simulator B\u0302 as shown in Figure 9.5. It is straightforward to verify that the\nsimulation always ensures that c = h, if B0 does not abort. However, we must explicitly argue\nthat the simulation is quantum-computationally indistinguishable from the real protocol.\nIndistinguishability follows by first arguing that the probability for pk \u2208\n/ {0, 1}\u03ba \\ X\n\u03ba\nis negligible. This follows from X being negligible in {0, 1} and pk produced with flavor\nrandom against B0 by \u03c0 (force,random) being uniformly random in {0, 1}\u03ba , except with negligible\nprobability.\nSecond, we have to show that if pk \u2208 {0, 1}\u03ba \\ X , then the simulation is quantumcomputationally close to the real protocol. This can be shown via the following hybrid\nargument. Let D 0 be the distribution of the output of the simulation and let D 1 be the\ndistribution of the output of the simulation where we send all a0i for all i = {1, . . . , \u03a3} at\nthe end of Step (4.). Since commitments by commit pk\u0001 (*, *) are unconditionally hiding in\ncase of pk \u2208 {0, 1}\u03ba \\ X , commitments by COMMIT pk *, * are unconditionally hiding as well.\nFurthermore, both a0 and\n\u0001 a are uniformly random, so\u0001 we obtain statistical closeness between\n(a0 , COMMIT pk a0 , (s, r) ) and (a, COMMIT pk a0 , (s, r) ). Note further that distributions D\u0001 0\nand D 1 can be produced by a poly-sized circuit applied to either (a0 , COMMIT pk a0 , (s, r) )\n\u0001\nq\nor (a, COMMIT pk a0 , (s, r) , it holds that D 0 \u2248 D 1 .\nNow, let D 2 be the distribution obtained by not simulating the opening via the trapdoor,\nbut instead doing it honestly to the value committed to, i.e. (a0 , r). We still use the challenge\nS from the forced run of \u03c0 (random,force) though. However, for uniformly random challenges,\n\n111\n\n\f112\n\nCHAPTER 9. AMPLIFICATION FRAMEWORK FOR STRONG COINS\nreal runs are quantum-computationally indistinguishable from simulated runs, and we get\nq\nD 1 \u2248 D 2.\nNext, let D 3 be the distribution of the output of the simulation where we run \u03c0 (random,force)\nhonestly instead of enforcing outcome S. We then use the honestly produced S 0 in the proof\nin Step (6.) instead of the enforced S. We can do this, as we modified the process leading\nto D 2 towards an honest opening without any trapdoor, so we no longer need to enforce a\nparticular challenge. Under the assumption that \u03c0 (random,force) is enforceable against B0 , and\nobserving that real runs are quantum-computationally indistinguishable from runs enforcing\nq\nuniformly random outcomes, we obtain D 2 \u2248 D 3 .\nq\nFinally, we get by transitivity that D 0 \u2248 D 3 and conclude the proof by observing that\nafter our changes, the process producing D 3 is the real protocol. This concludes the proof\nof enforceability against Bob, according to Definition 9.3 with switched sides.\n\u0004\n\n\f10\nchapter\n\nApplications\nCoin-flipping as a stand-alone tool allows us to use it rather freely in several contexts. Shared\nrandomness is a crucial ingredient in many cryptographic implementations. Applications in\nthe common-reference-string-model, that assumes a random public string before communication, achieve great efficiency and composability, and many protocols have been proposed\nin the model. In this chapter, we will discuss example applications that rely on shared randomness. Two applications relate to the context of zero-knowledge. First, we show a simple\ntransformation from non-interactive zero-knowledge to interactive quantum zero-knowledge.\nThis result appeared in [DL09]. Then, we propose a quantum-secure zero-knowledge proof of\nknowledge, which is interesting also in that the construction relies not only on initial randomness but also on enforceable randomness as discussed in Chapter 9. This construction is part\nof the results in [LN10]. Last, we discuss the interactive generation of a common reference\nstring for the proposed lattice-based instantiation of the compiler construction, proposed in\nChapter 5 and applied in Chapter 6. This result appeared in [DFL+ 09] and [DL09].\n\n10.1\n\nInteractive Quantum Zero-Knowledge\n\nZero-knowledge proofs, as described in Section 2.4.5, are an important building block for\nlarger cryptographic protocols, capturing the definition of convincing the verifier of the validity of a statement with no information beyond that.\n\n10.1.1\n\nMotivation and Related Work\n\nAs in the classical case, where ZK protocols exist if one-way functions exist, quantum\nzero-knowledge (QZK) is possible under the assumption that quantum one-way functions\nexist. In [Kob03], Kobayashi showed that a common reference string or shared entanglement is necessary for non-interactive quantum zero-knowledge. Interactive quantum zeroknowledge protocols in restricted settings were proposed by Watrous in the honest-verifier\nsetting [Wat02] and by Damg\u00e5rd et al. in the CRS-model [DFS04], where the latter introduced the first \u03a3-protocols for QZK withstanding even active quantum attacks. In [Wat09],\nWatrous then proved that several interactive protocols are zero-knowledge against general\nquantum attacks.\nIt has also been shown that any honest-verifier zero-knowledge protocol can be made\nzero-knowledge against any classical and quantum verifier [HKSZ08]. In more detail, they\nshowed how to transform a \u03a3-protocol with stage-by-stage honest-verifier zero-knowledge\n\n\f114\n\nCHAPTER 10. APPLICATIONS\ninto a new \u03a3-protocol that is zero-knowledge against all verifiers. Special bit commitment\nschemes are proposed to limit the number of rounds, and each round is viewed as a stage\nin which an honest-verifier simulator is assumed. Then, by using a technique of [DGW94],\neach stage can be converted to obtain zero-knowledge against any classical verifier. Finally,\nWatrous' quantum rewinding lemma is applied in each stage to prove zero-knowledge also\nagainst any quantum verifier. We now show a simple transformation from non-interactive\n(quantum) zero-knowledge to interactive quantum zero-knowledge by combining the coin-flip\nprotocol with any non-interactive ZK protocol. Note that a non-interactive zero-knowledge\nproof system can be trivially turned into an interactive honest-verifier zero-knowledge proof\nsystem by just letting the verifier choose the reference string, and therefore, this consequence\nof our result also follows from [HKSZ08]. However, our proof is much simpler and the coinflipping is not restricted to a specific zero-knowledge construction. In addition, we obtain the\ncorollary that if there exist mixed commitments, then we can achieve interactive quantum\nzero-knowledge against any poly-sized quantum adversary without any set-up assumptions.\n\n10.1.2\n\nFormal Definition of Zero-Knowledge Proofs\n\nIn Section 2.4.5, we gave an intuitive introduction to zero-knowledge proof systems. Here,\nwe make this description formal. Recall that a zero-knowledge proof for set L on common\ninput x yields no other knowledge than the validity of membership x \u2208 L. An interactive\nproof system must fulfill completeness and soundness, as given in Definitions 10.1 and 10.2,\nand is quantum zero-knowledge (IQZK), if in addition Definition 10.3 holds. Note that in\nthe following, we let A be the prover and let B denote the verifier.\nDefinition 10.1 (Completeness) If x \u2208 L, the probability that (A, B) rejects x is negligible\nin the length of x.\nDefinition 10.2 (Soundness) If x \u2208\n/ L, then for any unbounded prover A0 , the probability\n0\nthat (A , B) accepts x is negligible in the length of x.\nDefinition 10.3 (Zero-Knowledge) An interactive proof system (A, B0 ) for language L\nis quantum zero-knowledge, if for any quantum verifier B0 , there exists a simulator \u015c with\noutput quantum-computationally indistinguishable from the real output, i.e.,\nq\n\n\u03c0(x,\u03c9)\n\nout\u015c \u2248 outA,B0 ,\non common input x \u2208 L and arbitrary additional (quantum) input to B0 .\nAccording to [BFM88], the interaction between prover and verifier can be replaced by a\ncommon reference string. Then, there is only a single message sent from prover to verifier,\nwho makes the final decision weather to accept or not. More precisely, both parties A and B\nget common input x. A common reference string \u03c9 of size \u03ba allows the prover A, who knows\na witness w, to give a non-interactive zero-knowledge proof \u03c0(\u03c9, x) to a (possibly quantum)\nverifier, poly-time bounded in \u03ba. For simplicity, we consider the proof of a single theorem of\nsize smaller than n (and n \u2264 \u03ba, i.e. L\u03ba = {x \u2208 L | |x| \u2264 \u03ba}. The extension to a more general\n\n\f10.1. INTERACTIVE QUANTUM ZERO-KNOWLEDGE\nnotion is rather straightforward (see [BFM88] for details).\nCompleteness and soundness hold as defined above, but we explicitly state the definitions\nas given in [BFM88] and adapted to our context.\nDefinition 10.4 (Completeness in NIZK) There exists a constant c > 0 such that for\nall x \u2208 L\u03ba , the acceptance probability is overwhelming, i.e.,\nc\n\nPrcomplete = Pr [\u03c9 \u2190 {0, 1}n , \u03c0(x, \u03c9) \u2190 A(\u03c9, x, w) : B(\u03c9, x, \u03c0(x, \u03c9)) = 1] > 1 \u2212 \u03b5\nwhere \u03b5 is negligible in n (and \u03ba).\nDefinition 10.5 (Soundness in NIZK) There exists a constant c > 0 such that for all\nx\u2208\n/ L\u03ba and for all provers A0 , the acceptance probability is negligible, i.e.,\nc\n\nPrsound = Pr [\u03c9 \u2190 {0, 1}n , \u03c0(x, \u03c9) \u2190 A0 (\u03c9, x) : B(\u03c9, x, \u03c0(x, \u03c9)) = 1] \u2264 \u03b50\nwhere \u03b50 is negligible in n (and \u03ba).\nThe non-interactive zero-knowledge requirement is simpler than for general zero-knowledge\nfor the following reason. Since all information is communicated mono-directional from prover\nto verifier in the protocol, the verifier does not influence the distribution in the real world.\nThus, in the ideal world, we require a simulator that only outputs pairs that are (quantum) computationally indistinguishable from the distribution of pairs (\u03c9, \u03c0(x, \u03c9)) in the real\nworld, where \u03c0 is generated with uniformly chosen \u03c9 and random x.1 In other words, we\ncan eliminate the quantification over all B0 in the zero-knowledge definition.\nDefinition 10.6 (Non-Interactive Zero-Knowledge) There exist a constant c > 0 and\na simulator \u015c with output quantum-computationally indistinguishable from the real output,\ni.e.,\nq\n\u03c0(x,\u03c9)\nout\u015c(x) \u2248 outA,B0 ,\nc\n\nwhere out\u015c(x) = {\u03c9 \u2190 {0, 1}|x| , \u03c0(x, \u03c9) \u2190 A(x, \u03c9) : (\u03c9, \u03c0(x, \u03c9))}.\n\n10.1.3\n\nThe Transformation\n\nWe obtain a generic transformation of non-interactive zero-knowledge into interactive quantum zero-knowledge as follows. In each invocation, protocol COIN generates a truly random\ncoin even in the case of a malicious quantum B0 . A string of such coins, obtained by sequential composition as described in Section 8.3.1 by the ideal functionality in Figure 8.5, is then\nused as reference string in any (NIZK)-subprotocol with properties as defined previously.\nThe final protocol IQZK is shown in Figure 10.3. To prove that it is an interactive quantum zero-knowledge protocol, we first construct an intermediate protocol IQZKF\u03ba\u2212COIN (see\nFigure 10.1) that runs with the ideal functionality F\u03ba\u2212COIN . Then we prove that IQZKF\u03ba\u2212COIN\nsatisfies completeness, soundness and zero-knowledge according to Definitions 10.1 - 10.3.\n\u03ba\u2212COIN\nTo complete the proof, the calls to F\u03ba\u2212COIN are replaced with actual invocations of \u03a0A,B\n,\nand we arrive at IQZK.\n1\n\nIndistinguishability, in turn, implies that the proof construction withstands quantum-computationally\nbounded verifiers.\n\n115\n\n\f116\n\nCHAPTER 10. APPLICATIONS\n\nprotocol IQZKF\u03ba\u2212COIN :\n(COIN)\n1. A and B invoke F\u03ba\u2212COIN . If A aborts by sending \u22a5 as second input, B aborts the\nprotocol. Otherwise, A and B set \u03c9 = h.\n(NIZK)\n2. A sends \u03c0(x, \u03c9) to B. B checks the proof and accepts or rejects accordingly.\n\nFigure 10.1: Intermediate Protocol for IQZK.\nClaim 10.1 Protocol IQZKF\u03ba\u2212COIN satisfies completeness, according to Definition 10.1.\nProof. From the ideal functionality F\u03ba\u2212COIN it follows that \u03c9 is uniformly random. Then by\nDefinition 10.4 of any (NIZK)-subprotocol, we know that, for x \u2208 L\u03ba , B accepts, except with\nnegligible probability (in the length of x. Thus, completeness for the IQZKF\u03ba\u2212COIN follows. \u0004\nClaim 10.2 Protocol IQZKF\u03ba\u2212COIN satisfies soundness, according to Definition 10.2.\nProof. Assume that x \u2208\n/ L\u03ba . Any dishonest A0 might stop IQZKF\u03ba\u2212COIN at any point during\nexecution. For example, she can block the output in Step (1.) or she can refuse to send a\nproof \u03c0 in (NIZK). Furthermore, A0 can use an invalid \u03c9 (or x) for \u03c0. In all of these cases, B\nwill abort without even checking the proof.\nTherefore, A0 's best strategy is to \"play the entire game\", i.e. to execute IQZKF\u03ba\u2212COIN\nwithout making obvious cheats. A0 can only convince B in the (NIZK)-subprotocol of a \u03c0 for\nany given (i.e. normally generated) \u03c9 with a probability that is negligible in the length of x\n(see Definition 10.5). Therefore, the probability that A0 can convince B in the full IQZKF\u03ba\u2212COIN\nin case of x \u2208\n/ L\u03ba is also negligible and its soundness follows.\n\u0004\nClaim 10.3 Protocol IQZKF\u03ba\u2212COIN is an interactive zero-knowledge proof, according to Definition 10.3.\nProof. We construct a simulator \u015cIQZKF\u03ba\u2212COIN , interacting with dishonest B0 and a simulator\n\u015cNIZK . As given in Definition 10.6, such a simulator generates, on input x \u2208 L, a randomly\nlooking \u03c9 together with a valid proof \u03c0 for x (without knowing witness w). \u015cIQZKF\u03ba\u2212COIN ,\ndescribed in Figure 10.2, receives a random string \u03c9\u0303 from \u015cNIZK , which now replaces the\ncoin-string h produced by F\u03ba\u2212COIN in protocol IQZKF\u03ba\u2212COIN . By assumption on \u015cNIZK , this\nis quantum-computationally indistinguishable for B0 . Thus, the simulated proof \u03c0(\u03c9, x) is\nindistinguishable from a real proof, which proves that the IQZKF\u03ba\u2212COIN is zero-knowledge. \u0004\nIt would be natural to think that IQZK could be proven secure simply by showing that\nIQZKF\u03ba\u2212COIN implements some appropriate functionality and then use a composition theorem\n\n\f10.1. INTERACTIVE QUANTUM ZERO-KNOWLEDGE\n\nSimulation \u015cIQZKF\u03ba\u2212COIN :\n1. \u015cIQZKF\u03ba\u2212COIN gets input x and invokes \u015cNIZK with x to receives \u03c0(\u03c9, x).\n2. Let \u03c9 = h. \u015cIQZKF\u03ba\u2212COIN sends h to B0 .\n3. \u015cIQZKF\u03ba\u2212COIN sends \u03c0(\u03c9, x) to B0 and outputs whatever B0 outputs.\n\nFigure 10.2: The Simulation of the Intermediate Protocol for IQZK.\nprotocol IQZK:\n\u03ba\u2212COIN\n(COIN) A and B run \u03a0A,B\nand set \u03c9 = h.\n\n(NIZK) A sends \u03c0(\u03c9, x) to B. B checks the proof and accepts or rejects accordingly.\n\nFigure 10.3: Interactive Quantum Zero-Knowledge.\nfrom Section 3.6. Recall, however, that a zero-knowledge protocol-which is not necessarily\na proof of knowledge-cannot be modeled by a functionality in a natural way. Instead, we\nprove the standard properties of a zero-knowledge proof system explicitly and therewith the\nfollowing Theorem 10.1.\nTheorem 10.1 (Interactive Quantum Zero-Knowledge) Protocol IQZK is an interactive proof system, satisfying completeness and soundness. Since, for any quantum verifier\nB0 , there exists a simulator \u015cIQZK with output quantum-computationally indistinguishable from\nthe real output, we additionally achieve quantum zero-knowledge.\nProof. From the analysis of protocol COIN, its sequential composability, and the indistinguishability from the ideal functionality F\u03ba\u2212COIN , it follows that if both players are honest\n\u03c9 is a random common reference string of size \u03ba and the acceptance probability of the\n(NIZK)-subprotocol as given previously holds. Completeness of IQZK follows.\nTo show soundness, we again only consider the case where A0 executes the entire protocol\nwithout making obvious cheats, since otherwise, B immediately aborts. Assume that A0 could\ncheat in IQZK, i.e., B would accept an invalid proof with non-negligible probability. Then we\ncould combine A0 with simulator \u00c20 of protocol COIN (Figure 8.3) to show that IQZKF\u03ba\u2212COIN\nwas not sound. This, however, is inconsistent with the previously given soundness argument\nin the proof of Claim 10.2, and thus proves by contradiction that IQZK is sound.\nTo further prove that the interactive proof system is also quantum zero-knowledge, we\ncompose a simulator \u015cIQZK of simulator \u015cIQZKF\u03ba\u2212COIN (Figure 10.2) and simulator B\u03020 of protocol\nCOIN (Figure 8.4). In more detail, \u015cIQZK gets classical input x as well as quantum input W\nand X. It then receives a valid proof \u03c0 and a random string \u03c9 from \u015cNIZK . \u03c9 is split into\ncoin1 . . . coink . For each coini , it will then invoke B\u03020 to simulate one coin-flip execution with\n\n117\n\n\f118\n\nCHAPTER 10. APPLICATIONS\ncoin = coini as result. In other words, whenever B\u03020 asks FCOIN to output a bit (Step (2.),\nFigure 8.4), it instead receives this coini . We see that the transcript of the simulation is\nindistinguishable from the transcript of the protocol IQZK for any quantum-computationally\nbounded B0 . This concludes the proof.\n\u0004\nWe conclude this section by the corollary, immediately following from the previous proof\nand stating that quantum-secure commitments, as defined in Section 7.1, imply interactive\nquantum zero-knowledge.\nCorollary 10.1 If there exist quantum-secure commitment schemes, then we can obtain\ninteractive quantum zero-knowledge against any quantum adversary P0 \u2208 Ppoly without any\nset-up assumptions.\n\n10.2\n\nZero-Knowledge Proof of Knowledge\n\nA zero-knowledge proof of knowledge is a special case of zero-knowledge proof systems,\nintroduced in Section 2.4.5. Here, we propose a quantum-secure construction based on\nwitness encoding, which we define in the context of simulation.\n\n10.2.1\n\nMotivation and Related Work\n\nRecall that the purpose of a zero-knowledge proof of knowledge is to verify in classical\npoly-time in the length of the instance, whether w is a valid witness for instance x in\nrelation R, i.e. (x, w) \u2208 R. We call R an N P-relation, as the language L(R) = {x \u2208\n{0, 1}\u2217 | \u2203 w s.t. (x, w) \u2208 R} is seen to be an N P-language. Interestingly, such a zeroknowledge proof of knowledge, in contrast to zero-knowledge proofs, can be modeled by an\nideal functionality.\nOur protocol is based on a witness encoding scheme, providing a certain degree of extractability and simulatability, defined in Section 10.2.2. We want to stress that the extractability requirement resembles special soundness in proof systems, which are secure in\nthe classical world and typically come along with a knowledge error negligible in the length\nof the challenge. We have to reformulate this aspect in stronger terms in the quantum world,\nsince special soundness seems to be impossible to use in the quantum realm, due to the\nrestrictions within rewinding. However, we obtain a similar result also with knowledge error\nnegligible in the length of the challenge.\nFurthermore, our construction requires a mixed bit commitment (see Section 4.1) and\ntwo calls to the coin-flip protocol \u03c0 (force,force) , described in Figure 9.4, Chapter 9, which is\npoly-time simulatable for both sides even against quantum adversaries. Since this protocol\nonly assumes mixed commitments as well, we get the corollary that if there exists a mixed\ncommitment scheme, then we can construct a classical zero-knowledge proof of knowledge\nagainst any poly-sized quantum adversary. This is of particular interest, as the problems of\nrewinding in the quantum realm complicate implementing proofs of knowledge from scratch.\nAs already mentioned in Chapter 8, the unpublished approach of [Smi09] suggest another\nsolution for this concept. Instead of composing the coin-string from single coins, they use a\n\n\f10.2. ZERO-KNOWLEDGE PROOF OF KNOWLEDGE\nstring commitment with special opening and compose the subsequent zero-knowledge proof.\nThe coin-string is used as key to encode the witness and the second zero-knowledge proof is\ngiven to prove it.\n\n10.2.2\n\nSimulatable Witness Encodings of N P\n\nWe first specify a simulatable encoding scheme for binary relation R \u2282 {0, 1}\u2217 \u00d7{0, 1}\u2217 , which\nconsists of five classical poly-time algorithms (E, D, S, J, \u00ca). Then, we define completeness,\nextractability and simulatability for such a scheme in terms of the requirements of our zeroknowledge proof of knowledge.\nLet E : R \u00d7 {0, 1}m \u2192 {0, 1}n denote an encoder, such that for each (x, w) \u2208 R, the\nn-bit output e \u2190 E(x, w, r0 ) is a random encoding of w, with randomness r0 \u2208 {0, 1}m and\npolynomials m(|x|) and n(|x|). The corresponding decoder D : {0, 1}\u2217 \u00d7 {0, 1}n \u2192 {0, 1}\u2217\ntakes as input an instance x \u2208 {0, 1}\u2217 and an encoding e \u2208 {0, 1}n and outputs w \u2190 D(x, e)\nwith w \u2208 {0, 1}\u2217 .\nNext, let S denote a selector with input s \u2208 {0, 1}\u03c3 (with polynomial \u03c3(|x|)) specifying\na challenge, and output S(s) defining a poly-sized subset of {1, . . . , n} corresponding to\nchallenge s. We will use S(s) to select which bits of an encoding e to reveal to the verifier.\nFor simplicity, we use es to denote the collection of bits e|S(s) .\nWe denote with J the judgment that checks a potential encoding e by inspecting only\nbits es . In more detail, J takes as input instance x \u2208 {0, 1}\u2217 , challenge s \u2208 {0, 1}\u03c3 and the\n|S(s)| bits es , and outputs a judgment j \u2190 J(x, s, es ) with j \u2208 {abort, success}.\nFinally, the simulator is called \u00ca. It takes as input instance x \u2208 {0, 1}\u2217 and challenge\ns \u2208 {0, 1}\u03c3 and outputs a random collection of bits t|S(s) \u2190 \u00ca(x, s). Again for simplicity, we\nlet t|S(s) = ts . Then, if this set has the same distribution as bits of an encoding e in positions\nS(s), the bits needed for the judgment to check an encoding e can be simulated given just\ninstance x (see Definition 10.9).\nDefinition 10.7 (Completeness) If an encoding e \u2190 E(x, w, r) is generated correctly,\nthen success \u2190 J(x, s, es ) for all s \u2208R {0, 1}\u03c3 .\nWe will call an encoding e admissible for x, if there exist two distinct challenges s, s0 \u2208\n{0, 1}\u03c3 for which success \u2190 J(x, s, es ) and success \u2190 J(x, s0 , es0 ).\n\u0001\nDefinition 10.8 (Extractability) If an encoding e is admissible for x, then x, D(x, e) \u2208\nR.\nWe want to stress that extractability is similarly defined to the special soundness property\nof a classical \u03a3-protocol, which allows to extract w from two accepting conversations with\ndifferent challenges. Such a requirement would generally be inapplicable in the quantum\nsetting, as the usual rewinding technique is problematic and in particular in the context here,\nwe cannot measure two accepting conversations during rewinding in the quantum world.\nTherefore, we define the stronger requirement that if there exist two distinct answerable\nchallenges for one encoding e, then w can be extracted given only e. This condition works\nnicely in the quantum world, since we can obtain e without rewinding, as we will show in\nour quantum-secure proof construction.\n\n119\n\n\f120\n\nCHAPTER 10. APPLICATIONS\n\nFunctionality FZKPK(R) :\n1. On input (x, w) from Alice, FZKPK(R) sets j = success if (x, w) \u2208 R. Otherwise, it\nsets j = abort.\n2. FZKPK(R) outputs (x, j) to Alice and Bob.\n\nFigure 10.4: The Ideal Functionality for a Zero-Knowledge Proof of Knowledge.\nDefinition 10.9 (Simulatability) For all (x, w) \u2208 R and all s \u2208R {0, 1}\u03c3 , the distribution\nof e \u2190 E(x, w, r0 ) restricted to positions S(s) is identical to the distribution of ts \u2190 \u00ca(x, s),\ni.e.,\nD(es ) = D(ts ) .\nThere are several commit&open proofs for N P. One can, for instance, start from the\ncommit&open protocol for circuit satisfiability, where the bits of the randomized circuit\ncommitted to by the sender is easy to see as a simulatable encoding of a witness being\na consistent evaluation of the circuit to output 1. The challenge in the protocol is one\nbit e and the prover replies by showing either the bits corresponding to some positions\nS 0 (0) or positions S 0 (1). The details can be found in [BCC88]. This gives us a simulatable\nwitness encoding for any N P-relation R with \u03c3 = 1, using a reduction from N P to circuit\nsimulatability. By repeating it \u03c3 times in parallel we get a simulatable witness encoding for\nany \u03c3. For i = 1, . . . , \u03c3, compute an encoding ei of w and let e = (e1 , . . . , e\u03c3 ). Then for\ns \u2208 {0, 1}\u03c3 , let S(s) specify that the bits S 0 (si ) should be shown in ei and check these bits.\nNote, in particular, that if two distinct s and s0 passes this judgment, then there exists i such\nthat si 6= s0i , so ei passes the judgment for both si = 0 and si = 1, which by the properties\nof the protocol for circuit satisfiability allows to compute a witness w for x from ei . One can\nfind w from e simply by trying to decode each ej for j = 1, . . . , \u03c3 and check if (x, wj ) \u2208 R.\n\n10.2.3\n\nThe Protocol\n\nWe now construct a quantum-secure zero-knowledge proof of knowledge from prover A to verifier B. Recall that we are interested in the N P-language L(R) = {x \u2208 {0, 1}\u2217 | \u2203 w s.t. (x, w) \u2208\nR}, where A has input x and w, and both A and B receive positive or negative judgment of\nthe validity of the proof as output. We assume in the following that on input (x, w) \u2208\n/ R,\nhonest A aborts. The final protocol ZKPK(R) is describe in Figure 10.5.\nAs already mentioned, unlike zero-knowledge proofs, proofs of knowledge can be modeled\nby an ideal functionality, given as FZKPK(R) in Figure 10.4. FZKPK(R) can be thought of as a\nchannel which only allows to send messages in the language L(R). It models zero-knowledge,\nas it only leaks instance x and judgment j but not witness w. Furthermore, it models a\nproof of knowledge, since Alice has to know and input a valid witness w to obtain output\nj = success.\nProtocol ZKPK(R) is based on our fully simulatable coin-flip protocol \u03c0 (force,force) , which\nwe analyze here in the hybrid model by invoking the ideal functionality of sequential coin-\n\n\f10.2. ZERO-KNOWLEDGE PROOF OF KNOWLEDGE\n\n121\n\nProtocol ZKPK(R) :\n1. A and B invoke F\u03ba\u2212COIN to get a commitment key pk \u2208 {0, 1}\u03ba .\n2. A samples e \u2190 E(x, w, r0 ) with randomness r0 \u2208 {0, 1}m and commits positionwise to all ei \u0001for i = 1, . . . , n, by computing random commitments Ei =\nCOMMIT pk ei , ri with randomness r \u2208 {0, 1}n . She sends x and all Ei to B.\n3. A and B invoke F\u03c3\u2212COIN to flip a challenge s \u2208R {0, 1}\u03c3 .\n4. A opens her commitments to all es .\n5. If any opening is incorrect, B outputs abort. Otherwise, he outputs j \u2190 J(x, s, es )\nwith j \u2208 {success, abort}.\n\nFigure 10.5: Zero-Knowledge Proof of Knowledge.\nflipping twice (but with different output lengths). Note that in the hybrid model, a simulator\ncan enforce a particular outcome to hit also when invoking the ideal coin-flipping functionality. We can then use Definition 9.3 to replace the ideal functionality by the actual protocol\n\u03c0 (force,force) .\nOne call to the ideal functionality F\u03ba\u2212COIN with output length \u03ba is required to instantiate a\nmixed bit commitment scheme COMMIT as discussed in Section 7.3. Recall that it is therewith\npossible to sample an unconditionally binding key pk \u2208 {0, 1}\u03ba along with an extraction key\nsk. Since such keys are quantum-computationally indistinguishable from random values in\n{0, 1}\u03ba , the latter serves us as unconditionally hiding instantiations of COMMIT. The second\ncall to the functionality F\u03c3\u2212COIN produces \u03c3-bit challenges for a simulatable witness encoding\nscheme with (E, D, S, J, \u00ca) as specified in the previous Section 10.2.2.\nTheorem 10.2 (Zero-Knowledge Proof of Knowledge) For any simulatable witness encoding scheme (E, D, S, J, \u00ca), satisfying completeness, extractability, and simulatability according to Definitions 10.7 - 10.9, and for negligible knowledge error 2\u2212\u03c3 , protocol ZKPK(R)\nis a zero-knowledge proof of knowledge and securely implements FZKPK(R) .\nCompleteness is obvious. A honest party A, following the protocol with (x, w) \u2208 R and\nany valid encoding e, will be able to open all commitments in the positions specified by any\nchallenge s. Honest Bob then outputs J(x, s, es ) = success.\nProof (Security against dishonest Alice). To prove security in case of corrupted A0 ,\nwe construct a simulator \u00c20 that simulates a run of the actual protocol with A0 and FZKPK(R) .\nThe proof is then twofold. First, we show indistinguishability between the distributions\nof simulation and protocol. And second, we verify that the extractability property of the\nunderlying witness encoding scheme (see Definition 10.8) implies a negligible knowledge error.\nNote that if A0 sends abort at any point during the protocol, \u00c20 sends some input (x0 , w0 ) \u2208\n/R\nto FZKPK(R) to obtain output (x, j) with j = abort, and the simulation halts. Otherwise, the\nsimulation proceeds as shown in Figure 10.6.\n\n\f122\n\nCHAPTER 10. APPLICATIONS\n\nSimulation \u00c20 for ZKPK(R) :\n1. \u00c20 samples a random key pk along with the extraction key sk. Then it enforces pk\nas output from F\u03ba\u2212COIN\n2. When \u00c20 receives x and\n(xtrsk (E1 ), . . . , xtrsk (En )).\n\n(E1 , . . . , En )\n\nfrom\n\nA0 ,\n\nit\n\nextracts\n\ne\n\n=\n\n3. \u00c20 completes the simulation by following the protocol honestly.\nIf any opening of\n\u0001\n0\n0\n0\nA is incorrect, \u00c2 aborts. Otherwise, \u00c2 inputs x, D(x, e) to FZKPK(R) and receives\n(x, j) back. \u00c20 outputs the final state of A0 as output in the simulation.\n\nFigure 10.6: Simulation against dishonest Alice.\nNote that the only difference between the real protocol and the simulation is that \u00c20 uses\na random public key pk sampled along with an extraction key sk, instead of a uniformly\nrandom pk \u2208 {0, 1}\u03ba . It then enforces F\u03ba\u2212COIN to hit pk. However, by assumption on the\ncommitment keys and by the properties of the ideal coin-flipping functionality, the transcripts\nof simulation and protocol remain quantum-computationally indistinguishable under these\nchanges.\nNext, we analyze the output in more detail. It is clear that whenever honest B would\noutput abort in the actual protocol, also \u00c20 aborts, namely, if A0 does deviate in the last steps\nof protocol and simulation, respectively. Furthermore, \u00c20 accepts if and only if (x, D(x, e)) \u2208\nR or in other words, the judgment of the functionality is positive, denoted by jF = success.\nIt is therefore only left to prove that the case of jF = abort but jJ = success is\nnegligible, where the later denotes the judgment of algorithm J(x, s, es ) as in the protocol.\nIn that case, we have (x, D(x, e)) \u2208\n/ R. This means that w is not extractable from D(x, e),\nwhich in turn implies that (xtrsk (E1 ), . . . , xtrsk (En )) = e is not admissible. Thus, there are\nno two distinct challenges s and s0 , in which A0 could correctly open her commitment to e. It\nfollows by contradiction that there exists at most one challenge s which A0 can answer. We\nproduce s \u2208 {0, 1}\u03c3 uniformly at random, from which we obtain an acceptance probability\nof at most 2\u2212\u03c3 . Thus, we conclude the proof with negligible knowledge error, as desired.\n\u0004\nProof (Security against dishonest Bob). To prove security in case of corrupted B0 ,\nwe construct simulator B\u03020 as shown in Figure 10.7. Our aim is to verify that this simulation\nis quantum-computationally indistinguishable from the real protocol. The key aspect will\nbe the simulatability guarantee of the underlying witness encoding scheme, according to\nDefinition 10.9.\nThe proof proceeds via a hybrid argument. Let D 0 be the distribution of the simulation\nas described in Figure 10.7. Let D 1 be the distribution obtained from the simulation but\nwith the following change: We inspect FZKPK(R) to get a valid witness w for instance x, and\nlet e \u2190 E(x, w, r0 ) be the corresponding encoding. Note that this is possible as a thought\nexperiment for any adjacent distribution in a hybrid argument. From e we then use bits es\n\n\f10.2. ZERO-KNOWLEDGE PROOF OF KNOWLEDGE\n\nSimulation B\u03020 for ZKPK(R) :\n1. B\u03020 invokes F\u03ba\u2212COIN to receive a uniformly random pk.\n2. B\u03020 samples a uniformly random challenge s \u2208 {0, 1}\u03c3 and computes ts \u2190 \u00ca(x, s).\nB\u03020 then computes commitments Ei as follows: For\n\u0001 all i \u2208 S(s), it commits to the\npreviously sampled ts via Ei = COMMIT pk ti , ri . For all other positions i \u2208 S\u0304\n(where S\u0304 = {1, . . . , n} \\ S(s)),\nit commits to randomly chosen values t0i \u2208R {0, 1},\n\u0001\n0\ni.e. Ei = COMMIT pk ti , ri . It sends x and all Ei to B0 .\n3. B\u03020 forces F\u03c3\u2212COIN to hit s.\n4. B\u03020 opens Ei to ti for all i \u2208 S(s), i.e. to all ts .\n5. B\u03020 outputs whatever B0 outputs.\n\nFigure 10.7: Simulation against dishonest Bob.\nfor the same S(s) as previously, instead of bits ts sampled by \u00ca(x, s). All other steps are\nsimulated as before. By the simulatability of the encoding scheme (Definition 10.9), it holds\nthat the bits ts in D 0 and the bits es in D 1 have the same distribution. Thus, we obtain\nD 0 = D 1.\nWe further change the simulation in that we compute the bits in all positions i \u2208 S\u0304 by ei\nof the encoding e defined in the previous step. Again, all other steps of the simulation remain\nunchanged. Let D 2 denote the new distribution. The only difference now is that for i \u2208 S\u0304,\nthe commitments Ei are to the bits ei of a valid e and not to uniformly random bits t0i . This,\nhowever, is quantum-computationally indistinguishable to B0 for pk \u2208R {0, 1}\u03ba , as COMMIT is\nquantum-computationally hiding towards B0 . Note that pk is guaranteed to be random by\nan honest call to F\u03ba\u2212COIN and recall that we do not have to open the commitments in these\nq\npositions. Hence, we get that D 1 \u2248 D 2 .\nNote that after the two changes, leading to distributions D 1 and D 2 , the commitment\nstep and its opening now proceed as in the actual protocol, namely, we commit to the bits\nof e \u2190 E(x, e, r0 ) and open the subset corresponding to S(s). The remaining difference\nto the real protocol is the enforcement of challenge s, whereas s is chosen randomly in\nthe protocol. Now, let D 3 be the distribution of the modified simulation, in which we\nimplement this additional change of invoking F\u03c3\u2212COIN honestly and then open honestly to\nthe resulting s. Note that both processes, i.e., first choosing a random s and then enforcing\nit from F\u03c3\u2212COIN , or invoking F\u03c3\u2212COIN honestly and receiving a random s, result in a uniformly\nrandom distribution on the output of F\u03c3\u2212COIN . Thus, we obtain D 2 = D 3 .\nq\nBy transitivity, we conclude that D 0 \u2248 D 3 , and therewith, that the simulation is\nquantum-computationally indistinguishable from the actual protocol.\n\u0004\nWe conclude this section by the corollary that follows straightforward from the above\n\n123\n\n\f124\n\nCHAPTER 10. APPLICATIONS\nconstruction and proof and states that mixed commitments, as defined in Section 7.3, imply\nclassical zero-knowledge proofs of knowledge against any poly-sized quantum adversary.\nCorollary 10.2 If there exist mixed commitment schemes, then we can construct a classical\nzero-knowledge proof of knowledge against any quantum adversary P0 \u2208 Ppoly without any\nset-up assumptions.\n\n10.3\n\nGeneration of Commitment Keys\n\nHere, we briefly describe the initial generation of a common reference string for the proposed\nlattice-based instantiation of the generic compiler, introduced in Chapter 5, according to the\nspecific requirements of its underlying mixed commitment scheme, discussed in Section 4.1.\n\n10.3.1\n\nMotivation\n\nThe compiler is constructed in the CRS-model to achieve high efficiency. We now aim at\ncircumventing the CRS-assumption to achieve the potential of allowing the implementation of\ncomplete protocols in the quantum world without any set-up assumptions. More specifically,\nwe integrate the generation of a common reference string from scratch based on our quantumsecure coin-flipping, which will then be used during compilation as commitment key. We want\nto stress, however, that implementing the entire process comes at the cost of a non-constant\nround construction, added to otherwise very efficient protocols under the CRS-assumption.\n\n10.3.2\n\nThe Generation\n\nRecall that the argument for computational security in Section 5.2 proceeds along the following lines. After the preparation phase B commits to all his measurement bases and outcomes.\nThe keyed dual-mode commitment scheme has the special properties that the key can be\ngenerated by one of two possible key-generation algorithms GH or GB . Depending on the\nkey in use, the scheme provides both flavors of security. Namely, with key pkH generated\nby GH , respectively pkB produced by GB , the commitment scheme is unconditionally hiding respectively unconditionally binding. Furthermore, the commitment is secure against a\nq\nquantum adversary and it holds that pkH \u2248 pkB. In the real-world protocol, B uses the unconditionally hiding key pkH to maintain unconditional security against any unbounded A0 .\nTo argue security against a computationally bounded B0 , an information-theoretic argument\ninvolving the simulator B\u03020 is given (in the proof of Theorem 5.1) to prove that B0 cannot\ncheat with the unconditionally binding key pkB. Security in real life then follows from the\nquantum-computational indistinguishability of pkH and pkB.\nWe want to repeat that we can even weaken the assumption on the hiding key in that\nwe do in fact not require an actual unconditionally hiding key, if the public-key encryption\nscheme guarantees that a random public key looks pseudo-random to poly-time quantum\ncircuits. As discussed in Section 4.1, the lattice-based crypto-system of Regev [Reg05],\nwhich is considered to withstand quantum attacks, is a good candidate to construct such a\ndual-mode commitment scheme. The public key of a regular key pair can be used as the\nunconditionally binding key pkB0 in our commitment scheme for the ideal-world simulation,\n\n\f10.3. GENERATION OF COMMITMENT KEYS\nand for the real protocol, an unconditionally hiding commitment key pkH0 can simply be\nconstructed by uniformly choosing numbers in the same domain.\nThe idea is now the following. Let k denote the length of a regular key pkB0 . We add\n(at least) k executions of our protocol COIN as a first step to the compiler-construction to\ngenerate a uniformly random sequence coin1 . . . coink . These k random bits produce a pkH0\nas sampled by GH , except with negligible probability. Hence, in the real world, Bob can use\nkey coin1 . . . coink = pkH0 for committing with ci = commit pkH0 (\u03b8\u0302i , x\u0302i ), ri ) on all positions\ni. Since an ideal-world adversary B\u03020 is free to choose any key, it can generate (pkB0 , sk0 ),\ni.e., a regular public key together with a secret key according to Regev's crypto-system. For\nthe security proof, write pkB0 = coin1 . . . coink . In the simulation, B\u03020compile (as described\nin the proof of Theorem 5.1) first invokes B\u03020coin (Figure 8.4) for each coinj to simulate one\ncoin-flip with coinj as result. Whenever B\u03020coin asks FCOIN to output a bit, it instead receives\nthis coini . Then B\u03020compile has the possibility to decrypt dishonest B0 's commitments ci =\ncommit pkB0 ((\u03b8\u0302i , x\u0302i ), ri ) during simulation, which binds B0 unconditionally to his committed\nmeasurement bases and outcomes. Finally, since we proved in the analysis of protocol COIN\nthat pkH0 is a uniformly random string, Regev's proof of semantic security applies, namely\nthat a random public key, chosen independently from a secret key, is indistinguishable to\na regular key and that such encodings carry essentially no information about the message.\nq\nThus, we obtain pkH0 \u2248 pkB0 and quantum-computational security in real life follows.\n\n125\n\n\f\fBibliography\n[Ajt96]\n\nMikl\u00f3s Ajtai. Generating hard instances of lattice problems. In 28th Annual\nACM Symposium on the Theory of Computing (STOC), pages 99\u2013108, 1996.\n\n[BB83]\n\nCharles H. Bennett and Gilles Brassard. Quantum cryptography and its application to provably secure key expansion, public-key distribution, and coin-tossing.\nIn IEEE International Symposium on Information Theory (ISIT), page 91, 1983.\n\n[BB84]\n\nCharles H. Bennett and Gilles Brassard. Quantum cryptography: Public key\ndistribution and coin tossing. In IEEE International Conference on Computers,\nSystems, and Signal Processing, pages 175\u2013179, 1984.\n\n[BB89]\n\nCharles H. Bennett and Gilles Brassard. The dawn of a new era for quantum\ncryptography: The experimental prototype is working. SIGACT News, 20(4):78\u2013\n82, 1989.\n\n[BBB+ 92] Charles H. Bennett, Fran\u00e7ois Bessette, Gilles Brassard, Louis Salvail, and John\nSmolin. Experimental quantum cryptography. Journal of Cryptology, 5(1):3\u201328,\n1992.\n[BBBW82] Charles H. Bennett, Gilles Brassard, Seth Breidbart, and Stephen Wiesner.\nQuantum cryptography, or unforgeable subway tokens. In Advances in Cryptology: Proceedings of CRYPTO 82, pages 267\u2013275. Plenum Press, 1982.\n[BBC+ 93] Charles H. Bennett, Gilles Brassard, Claude Cr\u00e9peau, Richard Jozsa, Asher\nPeres, and William K. Wootters. Teleporting an unknown quantum state via\ndual classical and Einstein-Podolsky-Rosen channels. Physical Review Letters,\n70(13):1895\u20131899, 1993.\n[BBCS91] Charles H. Bennett, Gilles Brassard, Claude Cr\u00e9peau, and Marie-H\u00e9l\u00e8ne Skubiszewska. Practical quantum oblivious transfer. In Advances in Cryptology-\nCRYPTO '91, volume 576 of Lecture Notes in Computer Science, pages 351\u2013366.\nSpringer, 1991.\n[BBR88]\n\nCharles H. Bennett, Gilles Brassard, and Jean-Marc Robert. Privacy amplification by public discussion. SIAM J. Comput., 17(2):210\u2013229, 1988.\n\n[BCC88]\n\nGilles Brassard, David Chaum, and Claude Cr\u00e9peau. Minimum disclosure proofs\nof knowledge. Journal of Compututer and System Sciences, 37(2):156\u2013189, 1988.\n\n\f128\n\nBIBLIOGRAPHY\n[BF10]\n\nNiek J. Bouman and Serge Fehr. Sampling in a quantum population, and applications. In Advances in Cryptology-CRYPTO '10, volume 6223 of Lecture\nNotes in Computer Science, pages 724\u2013741. Springer, 2010.\n\n[BFM88]\n\nManuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge\nand its applications (extended abstract). 20th Annual ACM Symposium on Theory of Computing (STOC), pages 103\u2013112, 1988.\n\n[BG92]\n\nMihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Advances\nin Cryptology-CRYPTO '92, volume 740 of Lecture Notes in Computer Science,\npages 390\u2013420. Springer, 1992.\n\n[Bla79]\n\nG. R. Blakely. Safeguarding cryptographic keys. Proceedings of the National\nComputer Conference, 48:313\u2013317, 1979.\n\n[Blu81]\n\nManuel Blum. Coin flipping by telephone. In Advances in Cryptology: A Report\non CRYPTO '81, pages 11\u201315. U.C. Santa Barbara, Dept. of Elec. and Computer\nEng., ECE Report No 82-04, 1981.\n\n[BM04]\n\nMichael Ben-Or and Dominic Mayers. General security definition and composability for quantum and classical protocols, 2004. Available at arxiv:\nquant-ph/0409062v2.\n\n[BW92]\n\nCharles H. Bennett and Stephen Wiesner. Communication via one- and twoparticle operators on Einstein-Podolsky-Rosen states. Physical Review Letters,\n69(20):2881\u20132884, May 1992.\n\n[Can01]\n\nRan Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd Annual IEEE Symposium on Foundations of Computer Science (FOCS), pages 136\u2013145, 2001.\n\n[CCM98]\n\nChristian Cachin, Claude Cr\u00e9peau, and Julien Marcil. Oblivious transfer with a\nmemory-bounded receiver. In 39th Annual IEEE Symposium on Foundations of\nComputer Science (FOCS), pages 493\u2013502, 1998.\n\n[CDMS04] Claude Cr\u00e9peau, Paul Dumais, Dominic Mayers, and Louis Salvail. Computational collapse of quantum state with application to oblivious transfer. In Theory\nof Cryptography Conference (TCC), volume 2951 of Lecture Notes in Computer\nScience. Springer, 2004.\n[CF01]\n\nRan Canetti and Marc Fischlin. Universally composable commitments. In Advances in Cryptology-CRYPTO '01, volume 2139 of Lecture Notes in Computer\nScience, pages 19\u201340. Springer, 2001.\n\n[CGL99]\n\nRichard Cleve, Daniel Gottesman, and Hoi-Kwong Lo. How to share a quantum\nsecret. Physical Review Letters, 83(3):648\u2013651, July 1999.\n\n[CK88]\n\nClaude Cr\u00e9peau and Joe Kilian. Achieving oblivious transfer using weakened\nsecurity assumptions. In 29th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pages 42\u201353, 1988.\n\n\fBIBLIOGRAPHY\n[Coc08]\n\nClifford Cocks. The growth and development of public key cryptography. Invited\ntalk at Eurocrypt 2008, 2008.\n\n[DFL+ 09] Ivan B. Damg\u00e5rd, Serge Fehr, Carolin Lunemann, Louis Salvail, and Christian Schaffner. Improving the security of quantum protocols via commit-andopen. In Advances in Cryptology-CRYPTO '09, volume 5677 of Lecture Notes\nin Computer Science, pages 408\u2013427. Springer, 2009. Full version available at\narXiv:0902.3918v4[quant-ph].\n[DFR+ 07] Ivan B. Damg\u00e5rd, Serge Fehr, Renato Renner, Louis Salvail, and Christian\nSchaffner. A tight high-order entropic quantum uncertainty relation with applications. In Advances in Cryptology-CRYPTO '07, volume 4622 of Lecture\nNotes in Computer Science, pages 360\u2013378. Springer, 2007.\n[DFS04]\n\nIvan B. Damg\u00e5rd, Serge Fehr, and Louis Salvail. Zero-knowledge proofs and\nstring commitments withstanding quantum attacks. In Advances in Cryptology-\nCRYPTO '04, volume 3152 of Lecture Notes in Computer Science, pages 254\u2013\n272. Springer, 2004.\n\n[DFSS05]\n\nIvan B. Damg\u00e5rd, Serge Fehr, Louis Salvail, and Christian Schaffner. Cryptography in the bounded-quantum-storage model. In 46th Annual IEEE Symposium\non Foundations of Computer Science (FOCS), pages 449\u2013458, 2005.\n\n[DFSS07]\n\nIvan B. Damg\u00e5rd, Serge Fehr, Louis Salvail, and Christian Schaffner. Secure\nidentification and QKD in the bounded-quantum-storage model. In Advances in\nCryptology-CRYPTO '07, volume 4622 of Lecture Notes in Computer Science,\npages 342\u2013359. Springer, 2007.\n\n[DFSS08]\n\nIvan B. Damg\u00e5rd, Serge Fehr, Louis Salvail, and Christian Schaffner. Cryptography in the bounded-quantum-storage model. SIAM Journal on Computing,\n37(6):1865\u20131890, 2008.\n\n[DGW94]\n\nIvan B. Damg\u00e5rd, Oded Goldreich, and Avi Wigderson. Hashing functions\ncan simplify zero-knowledge protocol design (too). Technical Report RS-94-39,\nBRICS, Department of Computer Science, Aarhus University, Denmark, 1994.\n\n[DH76]\n\nWhitfield Diffie and Martin E. Hellman. New directions in cryptography. IEEE\nTransactions on Information Theory, 22(6):644\u2013654, November 1976.\n\n[DKRS06] Yevgeniy Dodis, Jonathan Katz, Leonid Reyzin, and Adam Smith. Robust fuzzy\nextractors and authenticated key agreement from close secrets. In Advances in\nCryptology-CRYPTO '06, volume 4117 of Lecture Notes in Computer Science,\npages 232\u2013250. Springer, 2006.\n[DL09]\n\nIvan B. Damg\u00e5rd and Carolin Lunemann. Quantum-secure coin-flipping and\napplications. In Advances in Cryptology-ASIACRYPT '09, volume 5912 of\nLecture Notes in Computer Science, pages 52\u201369. Springer, 2009.\n\n129\n\n\f130\n\nBIBLIOGRAPHY\n[DM04]\n\nStefan Dziembowski and Ueli M. Maurer. On generating the initial key in the\nbounded-storage model. In Advances in Cryptology-EUROCRYPT '04, volume\n3027 of Lecture Notes in Computer Science, pages 126\u2013137. Springer, 2004.\n\n[DN02]\n\nIvan B. Damg\u00e5rd and Jesper B. Nielsen. Perfect hiding and perfect binding\nuniversally composable commitment schemes with constant expansion factor. In\nAdvances in Cryptology-CRYPTO '02, volume 2442 of Lecture Notes in Computer Science, pages 581\u2013596. Springer, 2002.\n\n[DS05]\n\nYevgeniy Dodis and Adam Smith. Correcting errors without leaking partial\ninformation. In 37th Annual ACM Symposium on Theory of Computing (STOC),\npages 654\u2013663, 2005.\n\n[EGL85]\n\nShimon Even, Oded Goldreich, and Abraham Lempel. A randomized protocol\nfor signing contracts. Communications of the ACM, 28(6):637\u2013647, 1985.\n\n[Ein71]\n\nAlbert Einstein. The Born-Einstein Letters; Correspondence between Albert Einstein and Max and Hedwig Born from 1916 to 1955. Walker, 1971.\n\n[Eke91]\n\nArtur K. Ekert. Quantum cryptography based on Bell's theorem. Physical Review\nLetter, 67(6):661\u2013663, August 1991.\n\n[EPR35]\n\nAlbert Einstein, Boris Podolsky, and Nathan Rosen. Can quantum-mechanical\ndescription of physical reality be considered complete?\nPhysical Review,\n47(10):777\u2013780, 1935.\n\n[FFS87]\n\nUriel Feige, Amos Fiat, and Adi Shamir. Zero knowledge proofs of identity. In\n19th Annual ACM Symposium on Theory of Computing (STOC), pages 210\u2013217,\n1987.\n\n[FS86]\n\nAmos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Advances in Cryptology-CRYPTO '86,\nvolume 263 of Lecture Notes in Computer Science, pages 186\u2013194. Springer,\n1986.\n\n[FS08]\n\nSerge Fehr and Christian Schaffner. Randomness extraction via delta-biased\nmasking in the presence of a quantum attacker. In Theory of Cryptography\nConference (TCC), volume 4948 of Lecture Notes in Computer Science, pages\n465\u2013481. Springer, 2008.\n\n[FS09]\n\nSerge Fehr and Christian Schaffner. Composing quantum protocols in a classical\nenvironment. In Theory of Cryptography Conference (TCC), volume 5444 of\nLecture Notes in Computer Science, pages 350\u2013367. Springer, 2009.\n\n[Fuc96]\n\nChristopher A. Fuchs. Information gain vs. state disturbance in quantum theory.\nAvailable at arXiv:quant-ph/9611010v1, 1996.\n\n[FvdG99]\n\nChristopher A. Fuchs and Jeroen van de Graaf. Cryptographic distinguishability\nmeasures for quantum-mechanical states. IEEE Transactions on Information\nTheory, 45(4):1216\u20131227, 1999.\n\n\fBIBLIOGRAPHY\n[GMR85]\n\nShafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity\nof interactive proof-systems (extended abstract). In 17th Annual ACM Symposium on Theory of Computing (STOC), pages 291\u2013304, 1985.\n\n[GMW86] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to prove all npstatements in zero-knowledge, and a methodology of cryptographic protocol design. In Advances in Cryptology-CRYPTO '86, volume 263 of Lecture Notes in\nComputer Science, pages 171\u2013185. Springer, 1986.\n[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing\nbut their validity for all languages in NP have zero-knowledge proof systems.\nJournal of the ACM, 38(3):691\u2013729, 1991.\n[Gol01]\n\nOded Goldreich. Foundations of Cryptography, volume I: Basic Tools. Cambridge\nUniversity Press, 2001.\n\n[Gol02]\n\nOded Goldreich. Zero-knowledge twenty years after its invention. Available at\nhttp://www.wisdom.weizmann.ac.il/~oded/papers.html, 2002.\n\n[Gol10]\n\nOded Goldreich. A short tutorial of zero-knowledge. Available at http://www.\nwisdom.weizmann.ac.il/~oded/zk-tut02.html, 2010.\n\n[Gra97]\n\nJeroen van de Graaf. Towards a formal definition of security for quantum protocols. PhD thesis, Universit\u00e9 de Montr\u00e9al (Canada), 1997.\n\n[HBB99]\n\nMark Hillery, Vladimir Bu\u017eek, and Andr\u00e9 Berthiaume. Quantum secret sharing.\nPhysical Review A, 3:1829\u20131834, 1999.\n\n[HILL99]\n\nJohan H\u00e5stad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. SIAM Journal on Computing,\n28(4), 1999.\n\n[HKSZ08] Sean Hallgren, Alexandra Kolla, Pranab Sen, and Shengyu Zhang. Making classical honest verifier zero knowledge protocols secure against quantum attacks.\nIn 35th International Colloquium on Automata, Languages and Programming\n(ICALP), volume 5126 of Lecture Notes in Computer Science, pages 592\u2013603.\nSpringer, 2008.\n[Hoe63]\n\nWassily Hoeffding. Probability inequalities for sums of bounded random variables. Journal of the American Statistical Association, 58(301):13\u201330, March\n1963.\n\n[Kil88]\n\nJoe Kilian. Founding cryptography on oblivious transfer. 20th Annual ACM\nSymposium on Theory of Computing (STOC), pages 20\u201331, 1988.\n\n[KMP04]\n\nAlexei Kitaev, Dominic Mayers, and John Preskill. Superselection rules and\nquantum protocols. Physical Review A, 69(5), 2004.\n\n[KMR05]\n\nRobert K\u00f6nig, Ueli M. Maurer, and Renato Renner. On the power of quantum\nmemory. IEEE Transaction on Information Theory, 51(7):2391\u20132401, 2005.\n\n131\n\n\f132\n\nBIBLIOGRAPHY\n[Kob03]\n\nHirotada Kobayashi. Non-interactive quantum perfect and statistical zeroknowledge. In ISAAC, pages 178\u2013188, 2003.\n\n[KOY01]\n\nJonathan Katz, Rafail Ostrovsky, and Moti Yung.\nEfficient passwordauthenticated key exchange using human-memorable passwords. In Advances\nin Cryptology-EUROCRYPT '01, volume 2045 of Lecture Notes in Computer\nScience, pages 473\u2013492. Springer, 2001.\n\n[LC97]\n\nHoi-Kwong Lo and H. F. Chau. Is quantum bit commitment really possible?\nPhysical Review Letters, 78(17):3410\u20133413, 1997.\n\n[LN10]\n\nCarolin Lunemann and Jesper B. Nielsen. Fully simulatable quantum-secure\ncoin-flipping and applications. In Submission. Available at eprint.iacr.org/\n2011/065, 2010.\n\n[Mau90]\n\nUeli M. Maurer. A provably-secure strongly-randomized cipher. In Advances\nin Cryptology-EUROCRYPT '90, volume 473 of Lecture Notes in Computer\nScience, pages 361\u2013373. Springer, 1990.\n\n[Mau92]\n\nUeli M. Maurer. Conditionally-perfect secrecy and a provably-secure randomized\ncipher. Journal of Cryptology, 5(1):53\u201366, 1992. Preliminary version: [Mau90].\n\n[May96]\n\nDominic Mayers. Quantum key distribution and string oblivious transfer in noisy\nchannels. In Advances in Cryptology-CRYPTO '96, volume 1109 of Lecture\nNotes in Computer Science, pages 343\u2013357. Springer, 1996.\n\n[May97]\n\nDominic Mayers. Unconditionally secure quantum bit commitment is impossible.\nPhysical Review Letters, 78(17):3414\u20133417, 1997.\n\n[McE78]\n\nRobert J. McEliece. A public-key cryptosystem based on algebraic coding theory.\nDSN Progress Report 42-44, pages 114\u2013116, 1978.\n\n[Nao91]\n\nMoni Naor. Bit commitment using pseudorandomness. Journal of Cryptology,\n4(2):151\u2013158, 1991.\n\n[NC00]\n\nMichael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum\nInformation. Cambridge university press, 2000.\n\n[PVW08]\n\nChris Peikert, Vinod Vaikuntanathan, and Brent Waters. A framework for\nefficient and composable oblivious transfer. In Advances in Cryptology-\nCRYPTO '08, volume 5157 of Lecture Notes in Computer Science, pages 554\u2013\n571. Springer, 2008. Full version available at eprint.iacr.org/2007/348.pdf.\n\n[Rab81]\n\nMichael O. Rabin. How to exchange secrets by oblivious transfer. Technical\nreport, Harvard Aiken Computation Lab, 1981.\n\n[Reg05]\n\nOded Regev. On lattices, learning with errors, random linear codes, and cryptography. In 37th Annual ACM Symposium on Theory of Computing (STOC),\npages 84\u201393, 2005.\n\n\fBIBLIOGRAPHY\n[R\u00e9n61]\n\nAlfr\u00e9d R\u00e9nyi. On measures of entropy and information. In Proceedings of the 4th\nBerkeley Symposium Mathematical Statistics and Probability, volume 1, pages\n547\u2013561. University of California Press, 1961.\n\n[Ren05]\n\nRenato Renner. Security of Quantum Key Distribution. PhD thesis, ETH Z\u00fcrich\n(Switzerland), September 2005. Available at arxiv:quant-ph/0512258.\n\n[RK05]\n\nRenato Renner and Robert K\u00f6nig. Universally composable privacy amplification\nagainst quantum adversaries. In Theory of Cryptography Conference (TCC),\nvolume 3378 of Lecture Notes in Computer Science, pages 407\u2013425. Springer,\n2005.\n\n[RSA78]\n\nRonald L. Rivest, Adi Shamir, and Len Adleman. A method for obtaining digital\nsignatures and public-key cryptosystems. Commun. ACM, 21(2):120\u2013126, 1978.\n\n[RW05]\n\nRenato Renner and Stefan Wolf. Simple and tight bounds for information reconciliation and privacy amplification. In Advances in Cryptology-\nASIACRYPT 2005, volume 3788 of Lecture Notes in Computer Science, pages\n199\u2013216. Springer, 2005.\n\n[Sal98]\n\nLouis Salvail. Quantum bit commitment from a physical assumption. In Advances in Cryptology-CRYPTO '98, volume 1462 of Lecture Notes in Computer\nScience, pages 338\u2013353. Springer, 1998.\n\n[Sch35]\n\nErwin Schr\u00f6dinger. Discussion of probability relations between separated systems. Proceedings of the Cambridge Philosophical Society, 31:555\u2013563, 1935.\n\n[Sch07]\n\nChristian Schaffner. Cryptography in the Bounded-Quantum-Storage Model. PhD\nthesis, Aarhus University (Denmark), February 2007. Available at arXiv:0709.\n0289v1[quant-ph].\n\n[Sch10]\n\nChristian Schaffner. Personal communication, 2010.\n\n[Sha48]\n\nClaude E. Shannon. A mathematical theory of communication. Bell System\nTechnical Journal, 27:379\u2013423,623\u2013656, 1948.\n\n[Sha49]\n\nClaude E. Shannon. Communication theory of security systems. Bell System\nTechnical Journal, 1949.\n\n[Sha79]\n\nAdi Shamir. How to share a secret. Communications of the ACM, 22(11):612\u2013\n613, November 1979.\n\n[Sho97]\n\nPeter W. Shor. Polynomial-time algorithms for prime factorization and discrete\nlogarithms on a quantum computer. SIAM Journal on Computing, 26(5):1484\u2013\n1509, 1997.\n\n[Sin00]\n\nSimon Singh. The Code Book: The Secret History of Codes and Code-breaking.\nFourth Estate, 1st edition, 2000.\n\n[Smi09]\n\nAdam Smith. Personal communication, 2009.\n\n133\n\n\f134\n\nBIBLIOGRAPHY\n[SP00]\n\nPeter W. Shor and John Preskill. Simple proof of security of the BB84 quantum\nkey distribution protocol. Physical Review Letters, 85(2):441\u2013444, July 2000.\n\n[SS96]\n\nMichael Sipser and Daniel A. Spielman. Expander codes. IEEE Transactions on\nInformation Theory, 42(6):1710\u20131722, 1996.\n\n[Unr04]\n\nDominique Unruh. Simulatable security for quantum protocols. Available at\narxiv:quant-ph/0409125, 2004.\n\n[Unr10]\n\nDominique Unruh. Universally composable quantum multi-party computation.\nIn Advances in Cryptology-EUROCRYPT '10, volume 6110 of Lecture Notes in\nComputer Science, pages 486\u2013505. Springer, 2010.\n\n[Ver26]\n\nGilbert S. Vernam. Cipher printing telegraph systems for secret wire and radio telegraphic communications. Journal of the American Institute of Electrical\nEngineers, 55:109\u2013115, 1926.\n\n[Wat02]\n\nJohn Watrous. Limits on the power of quantum statistical zero-knowledge. In\n43rd Annual IEEE Symposium on Foundations of Computer Science (FOCS),\npages 459\u2013468, 2002.\n\n[Wat09]\n\nJohn Watrous. Zero-knowledge against quantum attacks. In SIAM Journal on\nComputing, volume 39.1, pages 25\u201358, 2009. Preliminary version in 38th Annual\nACM Symposium on Theory of Computing (STOC), pages 296\u2013305, 2006.\n\n[Weh08]\n\nStephanie Wehner. Cryptography in a Quantum World. PhD thesis, University\nof Amsterdam (The Netherlands), February 2008. Available at http://www.\ncomp.nus.edu.sg/~wehner/doc/phdthesis.pdf.\n\n[Wie83]\n\nStephen Wiesner. Conjugate coding. SIGACT News, 15(1):78\u201388, 1983. Original\nmanuscript written circa 1970.\n\n[WST08]\n\nStephanie Wehner, Christian Schaffner, and Barbara M. Terhal. Cryptography\nfrom noisy storage. Physical Review Letters, 100(22):220502, 2008.\n\n[Wul07]\n\nJ\u00fcrg Wullschleger.\nOblivious-Transfer amplification.\nIn Advances in\nCryptology-EUROCRYPT '07, volume 4515 of Lecture Notes in Computer Science. Springer, 2007.\n\n[WW08]\n\nStephanie Wehner and J\u00fcrg Wullschleger. Composable security in the boundedquantum-storage model. In Automata, Languages and Programming, 35th International Colloquium, ICALP 2008, volume 5126 of Lecture Notes in Computer\nScience, pages 604\u2013615. Springer, 2008.\n\n[WZ82]\n\nWilliam K. Wootters and Wojciech H. Zurek. A single quantum cannot be cloned.\nNature, 299:802\u2013803, October 1982.\n\n[Yao95]\n\nAndrew C. Yao. Security of quantum protocols against coherent measurements.\nIn 27th Annual ACM Symposium on the Theory of Computing (STOC), pages\n67\u201375, 1995.\n\n\f"}