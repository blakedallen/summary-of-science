{"id": "http://arxiv.org/abs/cs/0609070v2", "guidislink": true, "updated": "2006-09-12T20:10:44Z", "updated_parsed": [2006, 9, 12, 20, 10, 44, 1, 255, 0], "published": "2006-09-12T19:49:55Z", "published_parsed": [2006, 9, 12, 19, 49, 55, 1, 255, 0], "title": "Exploring Computer Science Concepts with a Ready-made Computer Game\n  Framework", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0609130%2Ccs%2F0609021%2Ccs%2F0609056%2Ccs%2F0609166%2Ccs%2F0609088%2Ccs%2F0609103%2Ccs%2F0609162%2Ccs%2F0609126%2Ccs%2F0609070%2Ccs%2F0609167%2Ccs%2F0609031%2Ccs%2F0609054%2Ccs%2F0609105%2Ccs%2F0609165%2Ccs%2F0609002%2Ccs%2F0609049%2Ccs%2F0609164%2Ccs%2F0609067%2Ccs%2F0609080%2Ccs%2F0609076%2Ccs%2F0609158%2Ccs%2F0609039%2Ccs%2F0609009%2Ccs%2F0609136%2Ccs%2F0609008%2Ccs%2F0609069%2Ccs%2F0609041%2Ccs%2F0609149%2Ccs%2F0609122%2Ccs%2F0609097%2Ccs%2F0609139%2Ccs%2F0609007%2Ccs%2F0609037%2Ccs%2F0609124%2Ccs%2F0609053%2Ccs%2F0609116%2Ccs%2F0609141%2Ccs%2F0609029%2Ccs%2F0609001%2Ccs%2F0609140%2Ccs%2F0609028%2Ccs%2F0609163%2Ccs%2F0609159%2Ccs%2F0609134%2Ccs%2F0609035%2Ccs%2F0609017%2Ccs%2F0609022%2Ccs%2F0609061%2Ccs%2F0609016%2Ccs%2F0609077%2Ccs%2F0609047%2Ccs%2F0609094%2Ccs%2F0609074%2Ccs%2F0609108%2Ccs%2F0609086%2Ccs%2F0609102%2Ccs%2F0609084%2Ccs%2F0609052%2Ccs%2F0609095%2Ccs%2F0609125%2Ccs%2F0609065%2Ccs%2F0609082%2Ccs%2F0609051%2Ccs%2F0609112%2Ccs%2F0609046%2Ccs%2F0609010%2Ccs%2F0609093%2Ccs%2F0609045%2Ccs%2F0609120%2Ccs%2F0609104%2Ccs%2F0609115%2Ccs%2F0609150%2Ccs%2F0609129%2Ccs%2F0609018%2Ccs%2F0609092%2Ccs%2F0609033%2Ccs%2F0609146%2Ccs%2F0609087%2Ccs%2F0609106%2Ccs%2F0609160%2Ccs%2F0609138%2Ccs%2F0307008%2Ccs%2F0307041%2Ccs%2F0307035%2Ccs%2F0307048%2Ccs%2F0307003%2Ccs%2F0307034%2Ccs%2F0307021%2Ccs%2F0307010%2Ccs%2F0307073%2Ccs%2F0307072%2Ccs%2F0307062%2Ccs%2F0307004%2Ccs%2F0307054%2Ccs%2F0307018%2Ccs%2F0307006%2Ccs%2F0307064%2Ccs%2F0307066%2Ccs%2F0307031%2Ccs%2F0307001%2Ccs%2F0307027&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Exploring Computer Science Concepts with a Ready-made Computer Game\n  Framework"}, "summary": "Leveraging the prevailing interest in computer games among college students,\nboth for entertainment and as a possible career path, is a major reason for the\nincreasing prevalence of computer game design courses in computer science\ncurricula. Because implementing a computer game requires strong programming\nskills, game design courses are most often restricted to more advanced computer\nscience students. This paper reports on a ready-made game design and\nexperimentation framework, implemented in Java, that makes game programming\nmore widely accessible. This framework, called Labyrinth, enables students at\nall programming skill levels to participate in computer game design. We\ndescribe the architecture of the framework, and discuss programming projects\nsuitable for a wide variety of computer science courses, from capstone to\nnon-major.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0609130%2Ccs%2F0609021%2Ccs%2F0609056%2Ccs%2F0609166%2Ccs%2F0609088%2Ccs%2F0609103%2Ccs%2F0609162%2Ccs%2F0609126%2Ccs%2F0609070%2Ccs%2F0609167%2Ccs%2F0609031%2Ccs%2F0609054%2Ccs%2F0609105%2Ccs%2F0609165%2Ccs%2F0609002%2Ccs%2F0609049%2Ccs%2F0609164%2Ccs%2F0609067%2Ccs%2F0609080%2Ccs%2F0609076%2Ccs%2F0609158%2Ccs%2F0609039%2Ccs%2F0609009%2Ccs%2F0609136%2Ccs%2F0609008%2Ccs%2F0609069%2Ccs%2F0609041%2Ccs%2F0609149%2Ccs%2F0609122%2Ccs%2F0609097%2Ccs%2F0609139%2Ccs%2F0609007%2Ccs%2F0609037%2Ccs%2F0609124%2Ccs%2F0609053%2Ccs%2F0609116%2Ccs%2F0609141%2Ccs%2F0609029%2Ccs%2F0609001%2Ccs%2F0609140%2Ccs%2F0609028%2Ccs%2F0609163%2Ccs%2F0609159%2Ccs%2F0609134%2Ccs%2F0609035%2Ccs%2F0609017%2Ccs%2F0609022%2Ccs%2F0609061%2Ccs%2F0609016%2Ccs%2F0609077%2Ccs%2F0609047%2Ccs%2F0609094%2Ccs%2F0609074%2Ccs%2F0609108%2Ccs%2F0609086%2Ccs%2F0609102%2Ccs%2F0609084%2Ccs%2F0609052%2Ccs%2F0609095%2Ccs%2F0609125%2Ccs%2F0609065%2Ccs%2F0609082%2Ccs%2F0609051%2Ccs%2F0609112%2Ccs%2F0609046%2Ccs%2F0609010%2Ccs%2F0609093%2Ccs%2F0609045%2Ccs%2F0609120%2Ccs%2F0609104%2Ccs%2F0609115%2Ccs%2F0609150%2Ccs%2F0609129%2Ccs%2F0609018%2Ccs%2F0609092%2Ccs%2F0609033%2Ccs%2F0609146%2Ccs%2F0609087%2Ccs%2F0609106%2Ccs%2F0609160%2Ccs%2F0609138%2Ccs%2F0307008%2Ccs%2F0307041%2Ccs%2F0307035%2Ccs%2F0307048%2Ccs%2F0307003%2Ccs%2F0307034%2Ccs%2F0307021%2Ccs%2F0307010%2Ccs%2F0307073%2Ccs%2F0307072%2Ccs%2F0307062%2Ccs%2F0307004%2Ccs%2F0307054%2Ccs%2F0307018%2Ccs%2F0307006%2Ccs%2F0307064%2Ccs%2F0307066%2Ccs%2F0307031%2Ccs%2F0307001%2Ccs%2F0307027&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Leveraging the prevailing interest in computer games among college students,\nboth for entertainment and as a possible career path, is a major reason for the\nincreasing prevalence of computer game design courses in computer science\ncurricula. Because implementing a computer game requires strong programming\nskills, game design courses are most often restricted to more advanced computer\nscience students. This paper reports on a ready-made game design and\nexperimentation framework, implemented in Java, that makes game programming\nmore widely accessible. This framework, called Labyrinth, enables students at\nall programming skill levels to participate in computer game design. We\ndescribe the architecture of the framework, and discuss programming projects\nsuitable for a wide variety of computer science courses, from capstone to\nnon-major."}, "authors": ["Joseph Distasio", "Thomas P. Way"], "author_detail": {"name": "Thomas P. Way"}, "author": "Thomas P. Way", "arxiv_comment": "5 pages, 3 figures", "links": [{"href": "http://arxiv.org/abs/cs/0609070v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0609070v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.OH", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.OH", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "K.3.1; I.2.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0609070v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0609070v2", "journal_reference": null, "doi": null, "fulltext": "Exploring Computer Science Concepts with a\nReady-made Computer Game Framework\nJoseph Distasio and Thomas P. Way\nApplied Computing Technology Laboratory\nDepartment of Computing Sciences\nVillanova University\nVillanova, PA 19085\n\njoseph.distasio@villanova.edu\nthomas.way@villanova.edu\nlearning curve and development of an entire game is a significant\nand time-consuming undertaking. The very popular Gamelet\ntoolkit [4] is such a framework that is ideal for experienced\nprogrammers, but is overwhelming for inexperienced\nprogrammers. The interactive 3-D graphics software called\nALICE [1] provides a fun and engaging first experience in\nprogramming for students at all levels, but using it for game\nprogramming requires significant time and experience.\n\nABSTRACT\nLeveraging the prevailing interest in computer games among\ncollege students, both for entertainment and as a possible career\npath, is a major reason for the increasing prevalence of computer\ngame design courses in computer science curricula. Because\nimplementing a computer game requires strong programming\nskills, game design courses are most often restricted to more\nadvanced computer science students. This paper reports on a\nready-made game design and experimentation framework,\nimplemented in Java, that makes game programming more widely\naccessible. This framework, called Labyrinth, enables students at\nall programming skill levels to participate in computer game\ndesign. We describe the architecture of the framework, and\ndiscuss programming projects suitable for a wide variety of\ncomputer science courses, from capstone to non-major.\n\nThe goal of the research reported in this paper is the development\nof a flexible, easy-to-use and compelling computer game\ndevelopment framework for use by all levels of computer science\nstudents, both majors and non-majors. The Labyrinth Game\nDesign and Experimentation Platform is a framework\nimplemented in Java that enables instructors to expose students to\nvery specific aspects of computer game design within the context\nof topics covered in specific computer science courses. The game\ntakes place in an underground world where a torch-carrying hero\ncharacter is chased by a fire-breathing monster through a maze of\ntunnels. The hero attempts to navigate the maze, lit only by the\nlimited light from the torch, and escape before being devoured by\nthe growling monster. The framework enables a student to apply\nthe ideas from computer science classes to customize this arcadestyle game, which is in the genre of Pac-Man, using a level of\ncomputer programming suited to his or her ability.\n\nKeywords\nComputer science education, game programming, artificial\nintelligence, computer graphics, user interface design.\n\n1. INTRODUCTION\nThere is widespread and undeniable interest in computer games\non the part of computer science students, and among college\nstudents in general [7]. Computer gaming is an enormously\nsuccessful industry, responsible for pushing innovation in\ncomputing and providing careers for many computer science\ngraduates. Responding to the demand, the inclusion of computer\ngame programming courses has become more commonplace\ninternationally in college curricula [2,5,6], and evidence suggests\nthat such courses boost student enrollment and retention in\ncomputer science programs [8].\n\nThis work is an extension of a student programming project\noriginally developed as a part of a large-team \"company\"\napproach to a Software Engineering course [10]. The idea was\nexplored further in a subsequent capstone Senior Projects course,\nand developed independently beyond that into its current\nframework as part of collaborative student-faculty research at the\nApplied Computing Technology Laboratory (ACT Lab) [11] at\nVillanova University. That such a project can evolve from a class\nproject to a distributable educational programming package, and\ncan engage the attention and excitement of both student and\nfaculty alike for two years, have been pleasant and welcome\ndiscoveries.\n\nWhen computer game programming is taught, it is frequently in\nupper level or capstone courses [6,8]. The reason for delaying the\nuse of computer gaming courses is because it requires some\nprogramming and conceptual sophistication on the part of\nstudents. Successful game programming requires familiarity with\nuser interface design, data structures, object-oriented design,\nalgorithms, software engineering, graphics, artificial intelligence,\nand plausibly just about any other topic common to a computer\nscience curriculum. Thus, it is no accident that computer game\ncourses more frequently appear later in a student's studies. Even\nhighly motivated students who attempt to download open-source\nor commercial game development frameworks from any one of\nmany online resources [3], quickly realize that there is a steep\n\n2. LABYRINTH ARCHITECTURE\nThe architecture of Labyrinth is modular to enable easy\ncustomization of individual components or features of the game\nwithout extensive additional programming. Following good\nobject-oriented design practices and software engineering\nconventions [9], each module handles a distinct aspect of the\ngame's functionality. This modularization isolates code specific\nto each game component in a clear and well-documented Java\n\n1\n\n\fsuch as replacing the image of the monster with an image of a\ndinosaur, or the sound of echoing footsteps with footsteps in\npuddles of water. Projects involving this module would be of use\nin an introductory programming course to demonstrate the use\nproperty files and the importance of using variables for easy\nmodification and readability.\n\nAPI. When a student programmer wishes to explore a new idea in\na certain aspect of the game, modifications are limited to the\nspecific module that implements that functionality. Figure 1\nillustrates the modular architecture of Labyrinth.\nLabyrinthGUI\n\nGamePanel module\n\nProperties File\n\nThe GamePanel module is comprised of a collection of smaller,\nrelated sub-modules. This module controls the overall game play\nof the game, including all of the specific features that are handled\nby the CreateMaze and various Difficulty sub-modules described\nbelow.\n\nGamePanel\n\nInstructionsPanel\nGameOverPanel\nFinishedGamePanel\nFinishedLevelPanel\n\nCreateMaze sub-module\n\nOpeningSplashPanal\n\nDifficulty\nmodules\n\ncreateMaze\n\nMoving\nmonster\nmodules\n\nThe CreateMaze sub-module dynamically generates the maze\nthrough which the game is played. Each maze is generated\nrandomly, and with a very low probability that a player will ever\nbe presented with a maze they have seen before. This sub-module\nwould be of particular interest to an algorithm design class,\noffering students the opportunity to create an algorithm and\nimplement it inside a working game.\nAdditionally, the\nimplemented CreateMaze algorithm is based on a common depth\nfirst search algorithm, providing students with a good starting\npoint.\n\nMovement\nListener\n\nFigure 1. Labyrinth architecture.\nThe Labyrinth framework, including all source code and\nprogrammer's guide, is available for download from the ACT Lab\nweb site [11]. The programmer's guide explains the architecture\nand programmer interface in greater detail than is possible here.\nInstructions are provided for rewriting modules, replacing\nmodules, compiling, running, and changing the game's graphical\nelements, with detailed and easy-to-follow examples to assist\ninstructors and students. The guide also points out some online\nresources that could be of some help to those learning how to\nprogram their own game, or seeking to make more significant\nmodifications to Labyrinth.\n\nDifficulty sub-modules\nThe group of Difficulty sub-modules handles changing the level\nof challenge associated with game play.\nDifficulty is\nimplemented as an area of visibility, a circular area of the maze\nthat is illuminated by the hero's torch (Figure 2). There are four\nsub-modules in this group, one for each of the four difficulty\nsettings: Super Easy, Easy, Medium and Difficult. Projects\nrelated to this module would be applicable in an introductory\nprogramming course, since the impact the game play is noticeable\nwith very small modifications to the code.\n\n2.1 Modules\nThe Labyrinth framework consists of a number of individual and\ndisjoint modules, each of which isolate a specific feature or\nfunction of the game. These modules are:\nLabyrinthGUI module\nThe first module is the LabyrinthGUI. This module is responsible\nfor settings related to the look and feel of the game, including the\nGraphical User Interface (GUI) and menus. It defines the general\nappearance of the overall game screen. This module would be of\nparticular interest to a project or course in graphic design or user\ninterface design, where the students learn to use code to create\nimages on the screen.\nScreen modules\nThe next modules deal with the layout of specific screens. These\nmodules\nare\nthe\nInstructionsPanel,\nGameOverPanel,\nFinishedGamePanel,\nFinishedLevelPanel,\nand\nOpeningSplashPanel. Each of these modules is responsible for\nthe layout of their respective screens, and would also be of\ninterest to graphic and user interface design students.\nPropertiesFile module\nThe PropertiesFile module handles mapping external resources,\nsuch as pictures and sounds, to the internal code. This module\nallows programmers to easily replace one resource with another,\n\nFigure 2. Game play at medium difficulty level.\n\n2\n\n\fTo demonstrate the ease with which module functionality can be\nmodified, the following example is given from the commonly and\neasily overridden SetEasyDifficulty sub-module. In order to\nreplace or extend the functionality, the original code is first\nexamined. Here is the original code from the sub-module for\nsetting the easiest level of game play difficulty:\n\nMonster movement modules\nThe monster movement modules deal with various aspects of the\nbehavior of the monster. This set of modules is in charge of\nchoosing a direction for the monster, choosing an image for the\nmonster, moving the monster, checking if the character can hear\nthe monster, and checking if the character has been caught by the\nmonster. Each of these tasks is implemented in its own module,\nwith the entire set collaborating to control all aspects of the\nmonster's movement. The logic implemented in these modules is\nthe principle \"brain\" behind the game, enabling the monster to\nchase the hero character through the maze (Figure 3). These\nmodules would be suited to projects in an artificial intelligence\nclass, providing opportunities to implement a variety of concepts\nfrom game theory.\n\npublic void setEasyDifficulty()\n{\nmonster_speed = monster_speed_easy;\nmonster_timer.setDelay(monster_speed);\nsearchlight = searchlight_easy;\n}\nIf, for example, game play in the new version of the game was\nfound to be too easy at the easiest level, and a new level of\ndifficulty was added, the modified code would look like this:\npublic void setEasyDifficulty()\n{\n//monster_speed = monster_speed_easy;\nmonster_speed = monster_speed_less_easy;\nmonster_timer.setDelay(monster_speed);\n//searchlight = searchlight_easy;\nsearchlight = searchlight_less_easy;\n}\nReplacing the graphical images used in the game, such as the hero\nand monster characters, can be done quite simply as well. In\norder to replace the images used, the user must first create new\nimages by using a graphics drawing program. Once the new\nimages have been made, the user edits the text-based properties\nfile, replacing the file paths of the old images with those of the\nnew images. Once the properties file is resaved, the game will\naccess the new images instead of the old ones.\n\nFigure 3. Game play showing approach of monster. (close up)\n\nMovementListener module\nThe MovementListener module is responsible for character\nmovement in response to player keystrokes. It maps the arrow\nkeys to movement and direction on the game playing screen.\nProjects related to this module demonstrate fundamental use of\nlisteners in Java, which would provide suitable material for an\nintroductory programming or user interface design course.\n\nModifying the GUI of the game must be done through the code\nmodification, which requires some familiarity with Java AWT\nand Swing programming. The code for the GUI is located in the\nLabyrinthGUI module. The student can change the overall GUI\nlook and feel, menu layout and functionality by modifying a small\namount of AWT or Swing code. Changes to the GUI of\nindividual game play and settings screens is similarly\naccomplished by making code modifications in one of the Screen\nmodules.\n\n2.2 Modifying Modules\nThe process of implementing a customized version of one of the\ngame modules is straightforward, and is explained extensively in\nthe bundled programmer's guide. The first step involves a code\nreview to gain an understanding of the functionality provided by\nthe module. Because modules range in size from a few lines to a\nfew hundred lines of code, there is a module appropriate to any\nlevel of learning. Once the module interface is understood, the\nsecond step is to reimplement, or modify, the module to provide\nthe desired new capability, taking care to continue to provide the\nsame basic functionality. Code modification can either be done\ndirectly on the original module source code (i.e., commenting out\nthe original code), or sub classing the module, overriding methods\nwhere needed. The third and final step is to recompile and test\nthe new module.\n\nThere are a variety of tools that work quite well for modification\nof modules. Among the more commonly used tools are Microsoft\nPaint (microsoft.com) for editing images, or any of a large\nnumber of commercial or freely available and downloadable\nimage editing tools such as PaintShopPro (jasc.com) or GIMP\n(gimp.org). For source code editing, basic text editors (i.e.,\nNotepad or Wordpad) can be used, as well as freely downloadable\nJava programming software such as Eclipse (eclipse.org) or\nJCreator (jcreator.com).\nLabyrinth was programmed using\nJCreator, and a JCreator project is distributed with the source\ncode.\n\n3\n\n\fdevelopment of an entire game system. This targeted approach to\nsoftware engineering can expose students to common, real-world\nchallenges such as supporting and modifying OPC (Other\nPeople's Code), designing new functionality that must mesh\nerrorlessly with an existing system, and collaborating with others\nin making a variety of cooperating modifications to such an\nexisting system.\n\nDue to the computational requirements of the game graphics and\nmovement, it is recommended that the processor speed be at least\n1GHz with 256MB of RAM, so that the game can run smoothly.\n\n3. CLASSROOM APPLICATIONS\nLabyrinth is designed to be used in just about any computer\nscience course to motivate learning exercises in many topics.\nThis section describes a variety of applications for which\nLabyrinth is designed, with example uses of the framework within\na typical sampling of computer science courses.\n\n3.5 Theory of Computation\nLabyrinth is suitable for use within a theory of computation\ncourse by providing concrete examples of the theoretical and\nlogical concepts learned in class. Game playing theory tends to\nincorporate a significant amount of logic and theory in its design\nand implementation, and Labyrinth contains many opportunities\nto examine and experiment with these concepts in an engaging\nand hands-on way.\n\n3.1 Artificial Intelligence\nThe monster that roams the maze in the game is an autonomous\nentity, controlled solely by the game program. Thus, the monster\nexhibits a degree of artificial intelligence, albeit rather limited. A\nclass could learn and experiment with artificial intelligence by\nreplacing the modules that deal with the monster's movement.\nThere is ample opportunity for exploring more sophisticated\napproaches to the monster's \"intelligence,\" such as improving\nhow it navigates the maze, identifies dead-ends in the maze,\ntracks the movement of the hero, and remembers where it has\nbeen.\n\n3.6 Databases\nFor students being exposed to the concept of databases for the\nfirst time, Labyrinth provides a simple introduction through the\nuse of its PropertiesFile module. The flat text file used by the\nmodule and the implementation of the module can be used to\nillustrate basic ideas of databases in an easily accessible way, and\nas a foundation for subsequent database topics. For more\nadvanced students, game playing statistics and scoring history\ndata could be incorporated into new game functionality.\n\n3.2 Algorithms\nThe majority of the modules in Labyrinth use very basic\nalgorithms to implement the desired functionality.\nSince\nalgorithm classes usually include coverage of applicable\nalgorithms, Labyrinth could be use as a framework for engaging,\nhands-on experimentation with the theoretical topics covered in\nclass. Students also could be challenged to design and implement\ntheir own algorithmic solutions within an appropriate module.\nThe source code that is provided can be used to demonstrate\npractical application of algorithms discussed in class without\nadditional implementation. For example, the CreateMaze module\nthat is included illustrates a depth first search algorithm while\ngenerating a new maze in a straightforward and concrete way.\n\n3.7 Computer Game Design\nObviously, a course in computer game design will expose\nstudents to a variety of theories, techniques and approaches.\nLabyrinth can be used as an open-source base upon which a more\nsophisticated game could be built, or individual functionality can\nbe examined and re-used in brand new games. Quite often the\ngoals of a computer game design course require students to\nimplement a \"new\" game, so the strength of Labyrinth may be in\nproviding less experienced students with a concrete example of a\nJava-based game that could reasonably be implemented in a\nsingle semester, given a solid effort. Alternately, Labyrinth could\nbe used to illustrate game programming techniques, to learn about\nboth good and bad approaches, as there are certain to be examples\nof both in this (or any other) computer game program.\n\n3.3 Data Structures\nThe Labyrinth game makes use of many different types of data\nstructures, including some suited specifically to game play. With\nthe data structures component of a course, Labyrinth could be\nused to motivate students to explore practical uses of data\nstructures and to illustrate the importance of careful data structure\ndesign. The framework also enables a study of the more\nadvanced data structures required in a real-world application of\nthe sort that may be outside the scope of a textbook that focuses\non fundamental issues. Practical experience in designing and\nimplementing data structures can be motivated by the fun and\nimmediate feedback provided by game programming.\n\n3.8 Java Programming\nBecause Labyrinth is implemented purely in Java, it provides an\nengaging starting point for exploration of any level of Java\nprogramming. Examination of the code can provide clear\nexamples of how interactivity can be accomplished in a user\ninterface, how threads can be used to enable concurrency, and a\nwide variety of examples drawn from the range of problems a\nJava programmer must solve. Labyrinth can provide a good,\nrunning start for a larger-scale project in a more advanced course,\nor opportunities for an introductory level Java course to get fun\nand immediate feedback using minimal programming.\n\n3.4 Software Engineering\nBecause the process of software development can require more\ntime and effort than are available in a single semester, software\nengineering courses wrestle with providing enough activelearning opportunities to appreciate the many process-oriented\nconcepts covered in class. The Labyrinth framework could be\nused to enable focused software engineering exercise, enabling\nstudents to design and implement specific modules or extensions\nto the existing framework rather than undertaking the complete\n\n3.9 Introductory Computer Science\nIntroductory computer science courses for the general student\npopulation (i.e., CS0 courses) provide challenges to the instructor\nwhen programming projects are desired. Because many students\nmay have never written a computer program, and may never do so\n4\n\n\fprovides a useful teaching tool for holding the interest of all levels\nof students.\n\nagain, finding simple projects that can motivate students is\ndifficult. Labyrinth can provide a gentle introduction to Java at\nan introductory level by offering the interactivity of a computer\ngame with the immediate feedback that comes with changing a\nsmall part. The scope of Labyrinth was purposely kept reasonable\nso that a student with limited programming experience could still\nunderstand it. Although the framework is advanced as a whole,\nmany of the modules are simple by design, offering small project\npossibilities for introductory level computer science students.\n\nIt has always been our hope that the Labyrinth framework would\nenable any college student interested in game design to try their\nhand at this very popular computer science discipline. Future\nplans for this research include deployment in a variety of projects\nwithin computer science classes (subject to agreeable colleagues),\ncreation of a \"project notebook\" that will be a collection of actual\nand proposed programming projects suitable for a variety of\ncourses, and continued refinement of the game including the\nincorporation of feedback from interested instructors and students.\n\n3.10 Interdisciplinary Courses\nOne of our major goals with designing Labyrinth, and with\nkeeping the overall architecture straightforward and easily\nunderstandable, was to foster interdisciplinary education. In an\ninterdisciplinary computer game design course, students from\nmany majors and with a variety of backgrounds could collaborate\non the design of the game. Since most college students have\nexperience with computer games, most will have creative ideas\nabout the design of a game. However, since most will not have\nthe technical expertise to implement their ideas, an\ninterdisciplinary approach must include some students who do\nhave programming experience. Game design teams could work\nmuch as they do at commercial game design companies. For\nexample, English and Communications majors could create plot\nand story-line, Art and Design students could create graphics and\nan overall look-and-feel, Business majors could analyze the game\ndesign and provide input on the marketability of the idea, and\nComputer Science students could provide the technical know-how\nto implement the game itself. Of course, all team members would\nbenefit from being exposed to both the creative team approach\nand to the computer science needed to make the creative ideas\ninto a concrete finished product. Although such a course could be\ndifficult to design and manage, we believe that there is enough\ndepth in a variety of game design aspects to provide any student\nwith a valuable and significant degree of learning.\n\n5. REFERENCES\n[1] ALICE interactive 3-D graphics programming software,\ndownloadable at: http://www.alice.org, 2005.\n[2] K. Becker. Teaching with games: the minesweeper and\nasteroids experience. The Journal of Computing in Small\nColleges, 17(2):23-33, 2001.\n[3] GameDev.net, online resource for computer game\ndevelopers. Web site accessed at: http://www.gamedev.net,\nAug. 2005.\n[4] Gamelet toolkit, downloadable game development software\nat: http://java.internet.com/gamelet, 2005.\n[5] M. Gumhold and M. Weber. Motivating CS students with\ngame programming. 6th International Conference on New\nEducational Environments (ICNEE), Neuchatel, Switzerland.\n2004.\n[6] R. M. Jones. Design and implementation of computer\ngames: a captone course for undergraduate computer science\neducation. SIGCSE Technical Symposium on Computer\nScience Education, pp. 260-264. ACM Press, 2000.\n[7] S. Jones. Let the game begin-gaming technology and\nentertainment among college students. 2003. Retrieved\nAug. 2005 from http://www.pewinternet.org.\n\n4. CONCLUSIONS & FUTURE WORK\n\n[8] I. Parberry, T. Roden and M. B. Kazemzadeh. Experience\nwith an industry-driven capstone course on game\nprogramming. ACM SIGCSE Bulletin, 37(1):91-95, 2005.\n\nIt is possible to include elements of computer game programming\nin just about any computer science course. Introductory level\nprogramming can be taught by leading students through minor\nmodifications to existing, simple and well-organized Java code.\nMore advanced students can reimplement entire modules and\nincorporate new features or better algorithms. Interdisciplinary\ncourses can foster team-based learning, drawing from each\nstudent's area of expertise to design a customized game. Projects\nsimilar to the development of Labyrinth can make excellent\nsoftware engineering or capstone projects, and can lead to\ncontinued learning beyond the end of formal coursework.\nLabyrinth already has been used to create humorous and fun\nversions, although these games have so far been restricted to a\nmaze-running, arcade-style format. Nevertheless, the framework\n\n[9] I. Somerville. Software Engineering. Addison-Wesley, 7th\nedition, 2004.\n[10] T. Way. A company-based framework for a software\nengineering course. SIGCSE Technical Symposium on\nComputer Science Education, pp. 132-136. ACM Press,\n2005.\n[11] Web site for Applied Computing Technology Laboratory at\nVillanova University, http://actlab.csc.villanova.edu, 2005.\n\n5\n\n\f"}