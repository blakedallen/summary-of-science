{"id": "http://arxiv.org/abs/cs/0605090v4", "guidislink": true, "updated": "2015-10-28T06:58:04Z", "updated_parsed": [2015, 10, 28, 6, 58, 4, 2, 301, 0], "published": "2006-05-20T05:43:55Z", "published_parsed": [2006, 5, 20, 5, 43, 55, 5, 140, 0], "title": "Mathematica: A System of Computer Programs", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0605077%2Ccs%2F0605098%2Ccs%2F0605133%2Ccs%2F0605144%2Ccs%2F0605073%2Ccs%2F0605116%2Ccs%2F0605129%2Ccs%2F0605140%2Ccs%2F0605135%2Ccs%2F0605056%2Ccs%2F0605143%2Ccs%2F0605035%2Ccs%2F0605136%2Ccs%2F0605075%2Ccs%2F0605037%2Ccs%2F0605105%2Ccs%2F0605121%2Ccs%2F0605087%2Ccs%2F0605079%2Ccs%2F0605120%2Ccs%2F0605005%2Ccs%2F0605132%2Ccs%2F0605104%2Ccs%2F0605038%2Ccs%2F0605011%2Ccs%2F0605068%2Ccs%2F0605130%2Ccs%2F0605106%2Ccs%2F0605060%2Ccs%2F0605062%2Ccs%2F0605114%2Ccs%2F0605127%2Ccs%2F0605123%2Ccs%2F0605008%2Ccs%2F0605128%2Ccs%2F0605111%2Ccs%2F0605036%2Ccs%2F0605103%2Ccs%2F0605013%2Ccs%2F0605085%2Ccs%2F0605045%2Ccs%2F0605099%2Ccs%2F0605134%2Ccs%2F0605032%2Ccs%2F0605029%2Ccs%2F0605074%2Ccs%2F0605026%2Ccs%2F0605054%2Ccs%2F0605113%2Ccs%2F0605024%2Ccs%2F0605027%2Ccs%2F0605047%2Ccs%2F0605019%2Ccs%2F0605086%2Ccs%2F0605025%2Ccs%2F0605040%2Ccs%2F0605007%2Ccs%2F0605028%2Ccs%2F0605030%2Ccs%2F0605082%2Ccs%2F0605053%2Ccs%2F0605090%2Ccs%2F0605004%2Ccs%2F0605094%2Ccs%2F0605095%2Ccs%2F0605084%2Ccs%2F0605012%2Ccs%2F0605100%2Ccs%2F0605081%2Ccs%2F0605022%2Ccs%2F0605052%2Ccs%2F0605069%2Ccs%2F0605110%2Ccs%2F0605057%2Ccs%2F0605088%2Ccs%2F0605109%2Ccs%2F0605145%2Ccs%2F0605102%2Ccs%2F0605112%2Ccs%2F0605009%2Ccs%2F0605023%2Ccs%2F0605078%2Ccs%2F0605059%2Ccs%2F0605101%2Ccs%2F0605126%2Ccs%2F0605016%2Ccs%2F0605010%2Ccs%2F0605071%2Ccs%2F0605117%2Ccs%2F0605137%2Ccs%2F0605051%2Ccs%2F0605108%2Ccs%2F0605091%2Ccs%2F0605018%2Ccs%2F0605142%2Ccs%2F0605119%2Ccs%2F0605006%2Ccs%2F0605003%2Ccs%2F0605141%2Ccs%2F0605034%2Ccs%2F0605080&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Mathematica: A System of Computer Programs"}, "summary": "Starting from the basic level of mathematica here we illustrate how to use a\nmathematica notebook and write a program in the notebook. Next, we investigate\nelaborately the way of linking of external programs with mathematica, so-called\nthe mathlink operation. Using this technique we can run very tedious jobs quite\nefficiently, and the operations become extremely fast. Sometimes it is quite\ndesirable to run jobs in background of a computer which can take considerable\namount of time to finish, and this allows us to do work on other tasks, while\nkeeping the jobs running. The way of running jobs, written in a mathematica\nnotebook, in background is quite different from the conventional methods i.e.,\nthe techniques for the programs written in other languages like C, C++, F77,\nF90, F95, etc. To illustrate it, in the present article we study how to create\na mathematica batch-file from a mathematica notebook and run it in the\nbackground. Finally, we explore the most significant issue of this article.\nHere we describe the basic ideas for parallelizing a mathematica program by\nsharing its independent parts into all other remote computers available in the\nnetwork. Doing the parallelization, we can perform large computational\noperations within a very short period of time, and therefore, the efficiency of\nthe numerical works can be achieved. Parallel computation supports any version\nof mathematica and it also works significantly well even if different versions\nof mathematica are installed in different computers. All the operations studied\nin this article run under any supported operating system like Unix, Windows,\nMacintosh, etc. For the sake of our illustrations, here we concentrate all the\ndiscussions only for the Unix based operating system.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0605077%2Ccs%2F0605098%2Ccs%2F0605133%2Ccs%2F0605144%2Ccs%2F0605073%2Ccs%2F0605116%2Ccs%2F0605129%2Ccs%2F0605140%2Ccs%2F0605135%2Ccs%2F0605056%2Ccs%2F0605143%2Ccs%2F0605035%2Ccs%2F0605136%2Ccs%2F0605075%2Ccs%2F0605037%2Ccs%2F0605105%2Ccs%2F0605121%2Ccs%2F0605087%2Ccs%2F0605079%2Ccs%2F0605120%2Ccs%2F0605005%2Ccs%2F0605132%2Ccs%2F0605104%2Ccs%2F0605038%2Ccs%2F0605011%2Ccs%2F0605068%2Ccs%2F0605130%2Ccs%2F0605106%2Ccs%2F0605060%2Ccs%2F0605062%2Ccs%2F0605114%2Ccs%2F0605127%2Ccs%2F0605123%2Ccs%2F0605008%2Ccs%2F0605128%2Ccs%2F0605111%2Ccs%2F0605036%2Ccs%2F0605103%2Ccs%2F0605013%2Ccs%2F0605085%2Ccs%2F0605045%2Ccs%2F0605099%2Ccs%2F0605134%2Ccs%2F0605032%2Ccs%2F0605029%2Ccs%2F0605074%2Ccs%2F0605026%2Ccs%2F0605054%2Ccs%2F0605113%2Ccs%2F0605024%2Ccs%2F0605027%2Ccs%2F0605047%2Ccs%2F0605019%2Ccs%2F0605086%2Ccs%2F0605025%2Ccs%2F0605040%2Ccs%2F0605007%2Ccs%2F0605028%2Ccs%2F0605030%2Ccs%2F0605082%2Ccs%2F0605053%2Ccs%2F0605090%2Ccs%2F0605004%2Ccs%2F0605094%2Ccs%2F0605095%2Ccs%2F0605084%2Ccs%2F0605012%2Ccs%2F0605100%2Ccs%2F0605081%2Ccs%2F0605022%2Ccs%2F0605052%2Ccs%2F0605069%2Ccs%2F0605110%2Ccs%2F0605057%2Ccs%2F0605088%2Ccs%2F0605109%2Ccs%2F0605145%2Ccs%2F0605102%2Ccs%2F0605112%2Ccs%2F0605009%2Ccs%2F0605023%2Ccs%2F0605078%2Ccs%2F0605059%2Ccs%2F0605101%2Ccs%2F0605126%2Ccs%2F0605016%2Ccs%2F0605010%2Ccs%2F0605071%2Ccs%2F0605117%2Ccs%2F0605137%2Ccs%2F0605051%2Ccs%2F0605108%2Ccs%2F0605091%2Ccs%2F0605018%2Ccs%2F0605142%2Ccs%2F0605119%2Ccs%2F0605006%2Ccs%2F0605003%2Ccs%2F0605141%2Ccs%2F0605034%2Ccs%2F0605080&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Starting from the basic level of mathematica here we illustrate how to use a\nmathematica notebook and write a program in the notebook. Next, we investigate\nelaborately the way of linking of external programs with mathematica, so-called\nthe mathlink operation. Using this technique we can run very tedious jobs quite\nefficiently, and the operations become extremely fast. Sometimes it is quite\ndesirable to run jobs in background of a computer which can take considerable\namount of time to finish, and this allows us to do work on other tasks, while\nkeeping the jobs running. The way of running jobs, written in a mathematica\nnotebook, in background is quite different from the conventional methods i.e.,\nthe techniques for the programs written in other languages like C, C++, F77,\nF90, F95, etc. To illustrate it, in the present article we study how to create\na mathematica batch-file from a mathematica notebook and run it in the\nbackground. Finally, we explore the most significant issue of this article.\nHere we describe the basic ideas for parallelizing a mathematica program by\nsharing its independent parts into all other remote computers available in the\nnetwork. Doing the parallelization, we can perform large computational\noperations within a very short period of time, and therefore, the efficiency of\nthe numerical works can be achieved. Parallel computation supports any version\nof mathematica and it also works significantly well even if different versions\nof mathematica are installed in different computers. All the operations studied\nin this article run under any supported operating system like Unix, Windows,\nMacintosh, etc. For the sake of our illustrations, here we concentrate all the\ndiscussions only for the Unix based operating system."}, "authors": ["Santanu K. Maiti"], "author_detail": {"name": "Santanu K. Maiti"}, "author": "Santanu K. Maiti", "arxiv_comment": "17 pages, 4 figures. arXiv admin note: substantial text overlap with\n  arXiv:cs/0603005, arXiv:cs/0604088", "links": [{"href": "http://arxiv.org/abs/cs/0605090v4", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0605090v4", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.MS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.MS", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0605090v4", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0605090v4", "journal_reference": null, "doi": null, "fulltext": "Mathematica: A System of Computer\nPrograms\nSantanu K. Maiti\u2217\n\narXiv:cs/0605090v4 [cs.MS] 28 Oct 2015\n\nPhysics and Applied Mathematics Unit, Indian Statistical Institute, 203 Barrackpore Trunk\nRoad, Kolkata-700 108, India\n\u2217\n\nE-mail:santanu.maiti@isical.ac.in\n\nAbstract\nMathematica is a powerful application package for doing mathematics and is used almost in\nall branches of science. It has widespread applications ranging from quantum computation,\nstatistical analysis, number theory, zoology, astronomy, and many more. Mathematica gives a\nrich set of programming extensions to its end-user language, and it permits us to write programs in procedural, functional, or logic (rule-based) style, or a mixture of all three. For tasks\nrequiring interfaces to the external environment, mathematica provides mathlink, which allows\nus to communicate mathematica programs with external programs written in C, C++, F77,\nF90, F95, Java, or other languages. It has also extensive capabilities for editing graphics,\nequations, text, etc. Starting from the basic level of mathematica here we illustrate how to\nuse a mathematica notebook and write a program in the notebook. Following with this, we\nalso describe very briefly about the importance of the local and global variables those are used\nin writing programs in mathematica. Next, we investigate elaborately the way of linking of\nexternal programs with mathematica, so-called the mathlink operation. Using this technique\nwe can run very tedious jobs quite efficiently, and the operations become extremely fast. Sometimes it is quite desirable to run jobs in background of a computer which can take considerable\namount of time to finish, and this allows us to do work on other tasks, while keeping the jobs\nrunning. The way of running jobs, written in a mathematica notebook, in background is quite\ndifferent from the conventional methods i.e., the techniques for the programs written in other\nlanguages like C, C++, F77, F90, F95, etc. To illustrate it, in the present article we study\nhow to create a mathematica batch-file from a mathematica notebook and run it in the background. Finally, we explore the most significant issue of this article. Here we describe the basic\nideas for parallelizing a mathematica program by sharing its independent parts into all other\nremote computers available in the network. Doing the parallelization, we can perform large\ncomputational operations within a very short period of time, and therefore, the efficiency of the\nnumerical works can be achieved. Parallel computation supports any version of mathematica\nand it also works significantly well even if different versions of mathematica are installed in\ndifferent computers. All the operations studied in this article run under any supported operating system like Unix, Windows, Macintosh, etc. For the sake of our illustrations, here we\nconcentrate all the discussions only for the Unix based operating system.\n\n\f1\n\nIntroduction\n\nMathematica, a system of computer programs, is a high-level computing environment including\ncomputer algebra, graphics and programming. Mathematica is specially suitable for mathematics, since it incorporates symbolic manipulation and automates many mathematical operations.\nThe key intellectual aspect of Mathematica is the invention of a new kind of symbolic computation language that can manipulate the very wide range of objects needed to achieve the generality required for technical computing by using a very small number of basic primitives. Just a\nsingle line sometimes makes a meaningful program in mathematica\u2013the syntax, documents and\nmethodology used for input and output remaining as they are for immediate calculations. It\nsupports every type of operation\u2013be they data, functions, graphics, programs, or even complete\ndocuments\u2013to be represented in a single, uniform way as a symbolic expression. This unification has many practical benefits to broadening the scope of applicability of each function. The\nraw algorithmic power of mathematica is magnified and its utility extended. Mathematica is\nnow emerging as an important tool in many branches of computing, and today it stands as the\nworld's best system for general computation.\nMathematica has widespread applications in different fields and is often used for research,\nloading and analyzing data, giving technical presentations and seminars etc. Mathematica is\nextraordinary well-rounded. It is suitable for both numeric and symbolic work, and it has\nremarkable word-processing capabilities as well. Mathematicians can search for a working\nmodel, do intensive calculation, and write a dissertation on the project (including complex\ngraphics) \u2013 all from within mathematica. It is mathematica's complete consistency in design at\nevery stage that gives it this multilevel capability and helps advanced usage evolve naturally.\n\n2\n\nStart with Mathematica\n\nWe generally use mathematica through documents called notebooks. To start a mathematica\nnotebook in Unix we write 'mathematica &' from a command line and then press the 'Enter'\nkey from the key-board. A typical notebook consists of cells that may contain graphics, texts,\nprograms or calculations. Now to exit from a mathematica notebook we first go to the command\n'File' and then press 'Quit' from the menu bar of the notebook. Without using a notebook one\ncan also use mathematica by typing the command 'math' from a command line and all the jobs\ncan also be done as well. To exit from mathematica for this particular case, we should write\neither 'Exit' or 'Quit' and then press the 'Enter' key. Thus one can run mathematica by using\nany one of the above two ways, but the most general way to do the interactive calculations in\nmathematica is the use of mathematica through notebook documents.\n\n2.1\n\nUse of a Mathematica Notebook\n\nIn a notebook, a job is performed in a particular cell and for different jobs we use different cells.\nOne can also use a single cell for all the operations, but it is quite easy if different operations are\nperformed in separate cells. A cell is automatically created when we begin to write anything in\nthe notebook. After writing proper operation/operations, it is needed to run the jobs. For this\npurpose, we press the key 'Shift' and holding this key, we then press 'Enter' from the key-board.\n\n\fThe results for the inputs are evaluated and they are available immediately underneath in a\nseparate cell, so-called the output cell.\nIn mathematica we can do all kind of mathematical operations like numerical computation,\nalgebric computation, matrix manipulation, different types of graphics etc., and all these things\nare clearly described by several examples in key mathematica book of Wolfram Research [1].\nSo in this article we shall not give any such example further. Now to do large numerical\ncomputations, it is needed to write a complete program. For this purpose, here we describe\nsomething about the way of writing a complete program in a mathematica notebook.\n\n2.2\n\nWay of Writing a Program in Mathematica\n\nIn mathematica, we can write a program efficiently compared to any other existing languages.\nAs illustrative example, here we mention a very simple program which is: the generation of a\nlist of two random numbers and the creation of a 2D plot from these numbers.\nThe program is:\nsample[times\u2212 ]:=Block[{local variables},\nnumbers=Table[{Random[], Random[]}, {i, 1, times}];\nfigure=ListPlot[numbers, PlotJoined\u2192True, AxesLabel\u2192{xlabel, ylabel}]]\nThis is the complete program for the generation of a list of two random numbers and the\ncreation of a 2D plot from these numbers. This program is written in a single cell. After\nthe end of this program we run it by using the command 'SHIFT' + 'ENTER', and then the\nmathematica does the proper operations and executes the result in an output cell.\nNow to understand this program, it is necessary to describe the meaning of the different\ncommands used in this program. To start a program it is necessary to specify a name for\nthe particular program. In this case, we specify 'sample' as a program name, for the sake of\nsimplicity. One can also use any other name in place of 'sample', since this is a dummy name.\nIf there is any running variable, like 'times' (a dummy variable) in this particular case, then\nit has to be given within the bracket '[ ]'. After that the symbol '\u2212 ' is used, which indicates\nthe variable as a functional variable. This is similar to define a functional variable, like f [x]\nas f [x\u2212 ] in mathematica. Now all the mathematical commands those are used for calculating\nthe job are inserted within 'Block[. . .]'. This is the central part of the program. This portion\ni.e., 'Block[. . .]' is connected with 'sample[times\u2212 ]' by the symbols ':='. The symbol ':' has an\nimportant role, and therefore it has to be taken into account properly. Inside the 'Block' the\n'local variables' for the program are declared within the bracket '{ }'. There may also exist\nanother type of variables called 'global variables'. Later in this article, we will focus about\nthese two different types of variables in detail. Now the rest part of the program differs from\nprogram to program depending on the nature of the particular operations. In this program, first\nwe construct a list of two random numbers. In mathematica, a random number is generated\nsimply by using the command 'Random[]'. Therefore, a list of two such random numbers can\nbe done very easily if we construct a table, which is performed by the command 'Table' as\ngiven in the program. The integer i runs from 1 to 'times', where the value of 'times' can be\nput anything. So if we write 'sample[10]', here 'times = 10', then i runs from 1 to 10 and if\n\n\fylable\n1.0\n\n0.6\n\n0.2\nxlabel\n0.2\n\n0.6\n\n1.0\n\nFigure 1: A 2D plot for a set of two random numbers.\nwe take 'sample[30]', where 'times = 30', then i goes from 1 to 30. Now it becomes quite user\nfriendly if we mention different variable names for the different mathematical operations which\nare not exactly identical with any built in function available in mathematica like 'Random',\n'Table', 'Plot', etc. In this program we use the variable names 'numbers' and 'figure' for the\ntwo different operations. At the end of each mathematical operation, except the last operation\nwhich gives the final output of a program, we put the symbol ';'. This is also very crucial. Here\nwe use the symbol ';' at the end of the second line only, but not in the last operation since\nthis is the final output of this program. The command 'ListPlot' plots the list of data points\nwhere the command 'PlotJoined\u2192True' connects the lines between the data points. Finally,\nthe command 'AxesLabel' in this line is an option for the graphics functions to specify the\nlabels in the axes.\nThe output for this program is shown in Fig. 1, which appears in a separate cell just below the\ninput cell of the program. So now we can easily write and compile a program in mathematica.\n2.2.1\n\nCharacterization of Local and Global Variables\n\nThe local and global variables in mathematica play an important role, and therefore care should\nbe taken about these two types of variables when we write a program in mathematica. We have\nalready mentioned about the local variables in the previous section that these variables are\nintroduced only inside the bracket '{ }' at the beginning of the 'Block[ ]'. In such a case, the\nvalues of these parameters are only defined within the cell where we write a particular program.\nOutside this cell, they are undefined and therefore, we may also use these same parameters for\nwriting other programs without any trouble.\nOn the other hand, the global variables are those which are not used within the bracket\n'{ }' of a program. For such a case, these variables are assigned throughout the notebook for\nall cells. Thus if we declare any value for a such parameter, then it will read this particular\nvalue whenever we use it in any program. Accordingly, it may cause a difficulty if we use the\nsame variable in another program by mistake. So we should take care about these two types\nof variables. To make it clear, here we illustrate the behavior of these two different kinds of\n\n\fvariables by giving proper examples.\nsample[times\u2212 ]:=Block[{t = 2.3, p = \u22121.5},\nnumbers=Table[{Random[], Random[]}, {i, 1, times}];\nfigure=ListPlot[numbers, PlotJoined\u2192True, AxesLabel\u2192{xlabel, ylabel}]]\nLet us consider the above program which is written in a particular cell in the mathematica\nnotebook. In this program, we introduce two local variables t = 2.3 and p = \u22121.5. Both these\ntwo variables are given inside the bracket '{ }'. Now if we check the values outside the cell\nthen the output will be simply t and p for these two variables. So these are the local variables\nand one can safely use these parameters again in other programs.\nsample[times\u2212 ]:=Block[{t = 2.3, p = \u22121.5},\nq = 3.5;\nnumbers=Table[{Random[], Random[]}, {i, 1, times}];\nfigure=ListPlot[numbers, PlotJoined\u2192True, AxesLabel\u2192{xlabel, ylabel}]]\nNow we refer to this program where we introduce an extra line for another variable q = 3.5\ncompared to the previous program of this section. Once we run this program, the value of\nq will be assigned for any cell of the notebook. Therefore, in this case q becomes the global\nvariable, and if one uses it further in other program then the value of this parameter q will be\nassigned as 3.5. Hence a mismatch will occur, and thus we should be very careful about these\ntwo different types of parameters.\n\n3\n\nWay to Link External Programs in Mathematica by\nProper Math-Link Commands\n\nThis section illustrates an important part of this article which deals with the way of linking of an\nexternal program with mathematica through proper mathlink commands. The mechanism for\nthe linking of external program written in C with mathematica has already been established [2].\nBut this will not work if one tries to link an external program written in other languages like\nF77, F90, F95, etc., with mathematica. This motivates us to find a way of linking an external\nprogram written either in any one of these later languages (F77, F90, F95) with mathematica.\nHere we illustrate it for the FORTRAN-90 source files [3, 4] only, but this mechanism will also\nwork significantly for the other Fortran source files as well.\n\n3.1\n\nMathlink for XL Fortran-90 Source Files\n\nIn order to understand the basic mechanism for linking an external program with mathematica,\nlet us begin by giving a simple example. Here we set the program as follows:\n1. Construct two square matrices in mathematica.\n2. Take the product of these two matrices by using an external program written in F90.\n\n\f3. Calculate the eigenvalues of the product matrix in mathematica.\n\nThe whole operations can be pictorially represented in Fig. 2.\n\nMathematica\nNotebook\n\nMathlink\n\nExternal\nProgram\n\nMathlink\n\nFigure 2: Schematic representation of mathlink operations.\nThe operations 1 and 3 are performed in mathematica, while the operation 2 is evaluated by\nthe external program. The transformations of the datas from the mathematica notebook to\nthe external program are done by using some proper commands, so-called mathlink operation.\nTo complete this particular job (operations 1-3), we need two programs. One is written in\nmathematica for the operations 1 and 3, while the other program is written in F90 for the\noperation 2. Now we describe all these steps one by one. Let us first concentrate on the\nexternal program, given below, where the multiplication of the two square matrices (operation\n2) is performed. The first line of the program corresponds to the command line where the\nsymbol '!' is used to make a statement as a command statement. The next line provides a\nspecific name of the program which is described by the command 'program multiplication'.\nThis actually starts the program, and accordingly, the program is ended by the command 'end\nprogram multiplication'. In F90, we can allocate and deallocate array variables in the programs\nwhich help us a lot to save memory and are very essential to run many jobs simultaneously.\nHere we use three array variables 'a, b and c' for the three different matrices whose dimensions\nare allocated by the order of the matrix 'n'. Finally, the product of the two matrices 'a' and 'b'\nis determined by the command 'matmul(a,b)' and the datas are stored in the matrix 'c'. This\nis the full program for the matrix multiplication of any two square matrices of order 'n'.\n! A program for matrix multiplication of two square matrices\nprogram multiplication\nimplicit double precision (a-h,o-z)\ndouble precision, allocatable :: a(:,:),b(:,:),c(:,:)\nread * , n !(the order of the matrix)\nallocate (a(n,n),b(n,n),c(n,n))\nread * , ((a(i,j),j=1,n),i=1,n) ; read * , ((b(i,j),j=1,n),i=1,n)\n! Calculation of matrix multiplication :\nc=matmul(a,b)\nprint'(1(1x,f10.6))',((c(i,j),j=1,n),i=1,n)\nend program multiplication\n\n\f3.1.1\n\nCompilation and Optimization of XL Fortran-90 Source Files\n\nAfter writing a program, first we need to compile it to check whether there is any syntax error\nor not to proceed for further operations. Several commands are accessible for the compilation\nand optimization of a program. The commands generally used to compile a F90 source file are:\nxlf90, xlf90\u2212 r, xlf90\u2212 r7, etc. Thus we can use anyone of these to compile this program, but\ndifferent commands optimize a program in different ways which solely depends on the nature\nof the particular program. The simplest way for the compilation of a program is,\nxlf90 filename.f\nWith this operation, an 'executable file' named 'a.out' is created, by default, in the present\nworking directory (pwd). But if one uses several programs simultaneously then it would be\nmuch better to specify different names of different 'executable files' for separate programs. To\ndo this we use the prescription,\nxlf90 filename.f -o filename\nUnder this process, the 'executive file' named as 'filename' is created. Thus we can create proper\n'executive files' for different jobs and all the jobs can be performed simultaneously without any\ndifficulty.\nFor our illustrative purposes, below we mention some other optimization techniques for the\nFortran source files.\n\u2022 -o : Optimizes code generated by the compiler.\n\u2022 -o0 : Performs no optimizations. (It is the same as -qnoopt.)\n\u2022 -o2 : Optimizes code (this is the same as -O).\n\u2022 -o3 : Performs the -O level optimizations and performs additional optimizations that are\nmemory or compile time intensive.\n\u2022 -o4 : Aggressively optimizes the source program, trading off additional compile time for\npotential improvements in the generated code. This option implies the following options:\n-qarch=auto -qtune=auto -qcache=auto -qhot -qipa.\n\u2022 -o5 : Same as -O4, but also implies the -qipa=level=2 option.\n\nFrom these operations, we can make some flavors about the compilation and optimization\ntechnique for a Fortran source file. For a detailed description of each operation, we refer to the\nXL Fortran User's Guide [5].\n\n\f3.1.2\n\nLink of XL Fortran-90 Program with Mathematica\n\nThis is the heart of this article. Below we set the mathematica program for the operations 1\nand 3, incorporating the operation 2 by using the proper mathlink commands, and illustrate\nall the steps properly (Fig. 2).\nLet us suppose the external program, for the operation 2, is written in the directory '/allibmusers/santanu/files/test'. Generally we are habituated to see the working directory as\n'/user/santanu/...' or '/home/santanu/...' or '/allusers/santanu/...', etc. So it can be anything\nlike these. Thus knowing the directory where the external program is written, we enter into\nthat particular directory and compile the external program properly to create an 'executive\nfile' for further operations. For this particular case, we create the 'executive file' named as\n'mat' which is used in the 13-th line of the following mathematica program. Now the external\nprogram is ready for the operation, and we enter into the directory where we will run the job\nin the mathematica notebook for the operations 1 and 3.\nSitting in the directory where the mathematica notebook is open, we need to connect the\nproper directory where the 'executive file' for the external program exists. The name of the\npwd can be checked directly from the mathematica notebook by using the command 'Directory[]'. Suppose the pwd is '/allibmusers/santanu/math'. Now If this pwd is different from\nthe directory where the file 'mat' exists, then we make a link to that particular directory\nthrough the command 'SetDirectory'. Below we give an example to connect the directory\n'/allibmusers/santanu/files/test', where the file 'mat' exists.\nSetDirectory[\"/allibmusers/santanu/files/test\"]\n\nFor this operation, the total path must be used within the double quotes \" \". Using the\ncommand 'ResetDirectory[]', we can come back to the initial directory. Thus we can connect\nand disconnect any directory with the pwd from the mathematica notebook, and able to link\nexternal programs with mathematica very easily.\nsample[ns\u2212 ]:=Block[{t = 0, s = 0,vacuum1= {},vacuum2= {}},\nSetDirectory[\"/allibmusers/santanu/files/test\"];\nDo[Do[a1 = If[i == j, t, 1.213];\na2 = AppendTo[vacuum1, a1], {j, 1, ns}], {i, 1, ns}];\nmat1 = Partition[a2, ns];\nDo[Do[a3 = If[k == l, s, 2.079];\na4 = AppendTo[vacuum2, a3], {l, 1, ns}], {k, 1, ns}];\nmat2 = Partition[a4, ns];\nmat3 = Partition[Flatten[{{mat1}, {mat2}}], ns];\nmatrixorder = {ns};\noutput = Insert[mat3, matrixorder, 1];\nExport[\"mat3.dat\", output];\nmatrix = Partition[ Flatten[ReadList[\"!mat<mat3.dat\", Number,\nRecordLists\u2192 True]], ns];\nresults = Eigenvalues[matrix]]\n\n\fIn the above program, the variables 't' and 's' are the local variables, and we have already\ndiscussed about these variables in the previous section. 'vacuum1={}' and 'vacuum2={}' are\nthe two empty lists where the datas are stored for each operation of the two 'DO' loops given\nin the program to make the lists 'a2' and 'a4' respectively. The 'Partition' command makes\nthe partition of a list. The parameter 'ns' gives the order of the two square matrices. By using\nthe command 'Export' we send the file 'mat3.dat' which is treated as the input file for the external program kept in the directory '/allibmusers/santanu/files/test'. To perform the matrix\nmultiplication by using the external program and get back the product matrix in the mathematica notebook we use the operation: ReadList[\"!mat<mat3.dat\", Number, RecordLists\u2192True].\nHere the command 'ReadLeast' is used to read the objects from a file and the commands\n'Number' and 'RecordLists\u2192True' are the options of the command 'ReadList'. Finally, the\neigenvalues of the matrix in the mathematica notebook are determined by using the command\n'Eigenvalues'.\n3.1.3\n\nLink of other XL Fortran Programs with Mathematica\n\nNow we can also use the mathlink operations for other programs written either in F77 or\nF95 by the above mechanisms. For these programs, we should use proper commands for the\ncompilations and optimizations. As representative example, here we mention some of the\ncommands for the compilation of these XL Fortran source files those are: xlf, f77, fort77, xlf\u2212 r,\nxlf\u2212 r7, xlf95, xlf95\u2212 r and xlf95\u2212 r7.\nSo now we can able to use mathlink commands for any type of Fortran program.\n\n4\n\nWay to Create a Mathematica Batch-file and Run it\nin Background\n\nIn the above section (Sec. 3), we have studied in detail how to start mathematica, write\nprograms in mathematica and the way of linking of external programs with a mathematica\nnotebook by using proper mathlink commands. Now it may be quite desirable to run jobs in\nbackground which take much time to finish, and to do other works in separate windows, keeping\nthe jobs running. This motivates us to explore the basic mechanisms for running mathematica\nprograms in background. It can be done by creating proper mathematica batch-file which we\nwill describe here elaborately.\nIn order to understand the complete process, let us start by giving a very simple example of\na mathematica program. We set the program as follows:\nThe generation of a list of two random numbers, a 2D plot from these set of random numbers\nand then the creation of an 'EPS' file for this 2D plot.\nFor this program, first we need to make a list of two random numbers and then construct a 2D\nplot using this set of random numbers. Finally, we make an 'EPS' file for this plot. Here, we are\nmainly interested to run this complete job in background. Before doing this job in background,\nlet us now describe the different mathematical operations with proper commands which are to\nbe done in a mathematica notebook for this particular operation.\n\n\fThe program for the generation of a set of two random numbers and a 2D plot from these\nnumbers is as follows:\nsample[times\u2212 ]:=Block[{local variables},\nnumbers=Table[{Random[], Random[]}, {i, 1, times}];\nfig=ListPlot[numbers, PlotJoined\u2192True, AxesLabel\u2192{xlabel, ylabel}]]\nTo get the output of this program, we run it by entering some value for the variable 'times',\nlike 'sample[100]' or 'sample[200]' etc. Then the mathematica does the proper operations and\nylable\n1.0\n\n0.6\n\n0.2\nxlabel\n0.2\n\n0.6\n\n1.0\n\nFigure 3: A 2D plot for a set of two random numbers.\nexecutes the result in an output cell. The output of the 2D plot is shown in Fig. 3.\nNow to create an 'EPS' file for this 2D plot we use the following operation:\nExport[\"filename.eps\", fig, \"EPS\"]\nIn this above expression, the name 'fig' is used to call the graphics file, and the 'eps' file is\nsaved by the name 'filename.eps' in the present working directory.\nThus we are now clear about all the mathematical operations those are to be done in a\nmathematica notebook for the above mentioned program. So now we make our attention for\nrunning this program in background.\nIn order to run this program in background, first we need to create a batch-file which is\na text file from these mathematica input commands those are written in different cells of a\nmathematica notebook. For this purpose, we go through these steps:\n(a) Select the cells from the mathematica notebook, and then follow the direction by clicking\non Cell \u2192 Cell Properties \u2192 Initialization Cell from the menu bar to initialize the cells.\n(b) To generate the batch-file, follow the direction by clicking on File \u2192 Save As Special. . .\n\u2192 Package Format from the menu bar.\n\n\fThen a dialog box appears for specifying the file name and the location of the mathematica\ninput file. Here we use the input file for the operation of the mathematica job.\nAfter these steps, let us suppose, we generate a batch-file named as 'santanu.m' for the\nabove mathematica program. Generally the batch-files for this purpose are specified by using\nthe extension '.m' i.e., like the name as 'filename.m'. To run this batch-file 'santanu.m' in\nbackground, we use the following prescription:\nnohup time math < santanu.m > santanu.out &\nThe file name 'santanu.out' is the output file, where all the outputs for the different operations\nare available. To get both the input and output lines of the mathematica notebook, it is\nnecessary to use the following command in the first line of the notebook.\nAppendTo[$Echo, \"stdout\"]\nAt the end of all these steps, we get the output file 'santanu.out' and the graphics file\n'filename.eps' in 'EPS' format in the present working directory where the batch-file 'santanu.m'\nis run in the background.\n\n5\n\nParallel Evaluation of Mathematica Programs\n\nParallelization is a form of computation in which one can perform many operations simultaneously. Parallel computation uses multiple processing elements simultaneously to finish a\nparticular job. This is accomplished by breaking the job into independent parts so that each\nprocessing element can execute its part of the algorithm simultaneously with the others. The\nprocessing elements can be diverse and include resources such as a single computer with multiple processors, several networked computers, specialized hardware, or any combination of the\nabove.\nIn this section, we narrate the basic mechanisms for parallelizing a mathematica program by\nrunning its independent parts in several computers available in the network. Since all the basic\nmathematical operations are performed quite nicely in any version of mathematica, it does not\nmatter even if different versions of mathematica are installed in different computers those are\nrequired for the parallel computing.\n\n5.1\n\nHow to Open Mathematica Slaves in Local Computer ?\n\nIn parallel computation, different segments of a job are computed simultaneously. These operations can be performed either in a local computer or in remote computers available in the\nnetwork. Separate operations are exhibited in separate mathematica slaves. In order to emphasize the basic mechanisms, let us now describe the way of starting a mathematica slave in\na local computer. To do this, first we load the following package in a mathematica notebook.\nNeeds[\"Parallel`Parallel`\"]\nTo enable optional features, then we load the package,\n\n\fNeeds[\"Parallel`Commands`\"]\nNow we can open a mathematica slave in the local computer by using the command,\nLaunchSlave[\"localhost\", \"math -noinit -mathlink\"]\nUsing this command, several mathematica slaves can be started from the master slave. Now it\nbecomes much more significant if we specify the names of different slaves so that independent\nparts of a job can be shared into different slaves appropriately. For our illustrations, below we\ngive some examples how different slaves can be started with specific names.\nlink1=LaunchSlave[\"localhost\", \"math -noinit -mathlink\"]\nlink2=LaunchSlave[\"localhost\", \"math -noinit -mathlink\"]\nlink3=LaunchSlave[\"localhost\", \"math -noinit -mathlink\"]\nHere link1, link2 and link3 correspond to the three different slaves. The details of these slaves\ncan be available by using the following command,\nTableForm[RemoteEvaluate[{$ProcessorID, $MachineName, $SystemID,\n$ProcessID, $Version}], TableHeadings\u2192{None,{\"ID\", \"host\", \"OS\",\n\"process\", \"Mathematica Version\"}}]\nThe output of the above command becomes (as an example),\nID\nhost\n1 tcmpibm\n\nOS\nAIX-Power64\n\nprocess\n463002\n\n2\n\ntcmpibm\n\nAIX-Power64\n\n299056\n\n3\n\ntcmpibm\n\nAIX-Power64\n\n385182\n\nVersion\n5.0 for IBM AIX Power (64 bit)\n(November 26, 2003)\n5.0 for IBM AIX Power (64 bit)\n(November 26, 2003)\n5.0 for IBM AIX Power (64 bit)\n(November 26, 2003)\n\nThe results shown in this table are for the above three slaves named as link1, link2 and link3\nrespectively, where all these slaves are opened from the local computer named as 'tcmpibm'\n(say). To get the information about the total number of slaves those are opened, we use the\ncommand,\nLength[$Slaves]\nFor this case, the total number of slaves becomes 3.\n\n5.2\n\nHow to Open Mathematica Slaves in Remote Computers Available in Network ?\n\nTo start a slave in remote computer, the command 'ssh' is used which offers secure cryptographic\nauthentication and encryption of the communication between the local and remote computer.\n\n\fBefore starting a slave in a remote computer, it is necessary to check whether 'ssh' is properly\nconfigured or not, and this can be done by using the prescription,\nssh remotehost math\nFor example, if we want to connect a remote computer named as 'tcmpxeon', we should follow\nthe command as,\nssh tcmpxeon math\nSince 'ssh' connection for a remote computer is password protected, it is needed to insert proper\npassword, and if 'ssh' is configured correctly, the above operation shows the command 'In[1]:='.\nOnce 'ssh' works correctly, a mathematica slave can be opened in a remote computer through\nthis command,\nLaunchSlave[\"remotehost\", \"ssh -e none `1` math -mathlink\"]\nFor our illustrative purposes, below we describe how different slaves with proper names can be\nstarted in different remote computers.\nlink1=LaunchSlave[\"tcmpxeon.saha.ac.in\",\nlink2=LaunchSlave[\"tcmp441d.saha.ac.in\",\nlink3=LaunchSlave[\"tcmpxeon.saha.ac.in\",\nlink4=LaunchSlave[\"tcmp441d.saha.ac.in\",\n\n\"ssh\n\"ssh\n\"ssh\n\"ssh\n\n-e none\n-e none\n-e none\n-e none\n\n`1` math\n`1` math\n`1` math\n`1` math\n\n-mathlink\"]\n-mathlink\"]\n-mathlink\"]\n-mathlink\"]\n\nHere link1, link2, link3 and link4 are the four different slaves, where the link1 and link3 are\nopened in a remote computer named as 'tcmpxeon' (say), while the other two slaves are started\nin another one remote computer named as 'tcmp441d' (say). Using this prescription, several\nmathematica slaves can be started in different remote computers available in the network. The\ndetails of the above four slaves can be expressed in the tabular form as,\nID\nhost\n1 tcmpxeon\n2 tcmp441d\n3 tcmpxeon\n4 tcmp441d\n\nOS\nLinux\nLinux\nLinux\nLinux\n\nprocess\n5137\n11323\n5221\n11368\n\n5.0\n5.0\n5.0\n5.0\n\nfor\nfor\nfor\nfor\n\nVersion\nLinux (November\nLinux (November\nLinux (November\nLinux (November\n\n18,\n18,\n18,\n18,\n\n2003)\n2003)\n2003)\n2003)\n\nThus we are now able to start mathematica slaves in local computer as well as in remote\ncomputers available in the network, and with this above background, we can describe the\nmechanisms for parallelizing a mathematica program.\n\n5.3\n\nParallelizing of Mathematica Programs by using Remote Computers Available in Network\n\nIn order to understand the basic mechanisms of parallelizing a mathematica program, let us\nbegin with a very simple problem. We set the problem as follows:\n\n\fProblem: Construct a square matrix of any order in a local computer and two other square\nmatrices of the same order with the previous one in two different remote computers. From the\nlocal computer, read these two matrices those are constructed in the two remote computers.\nFinally, take the product of these three matrices and calculate the eigenvalues of the product\nmatrix in the local computer.\nTo solve this problem we proceed through these steps in a mathematica notebook.\nStep-1 : For the sake of simplicity, let us first define the names of the three different computers\nthose are needed to solve this problem. The local computer is named as 'tcmpibm', while\nthe names of the other two remote computers are as 'tcmpxeon' and 'tcmp441d' respectively.\nOpening a mathematica notebook in the local computer, let us first load the package for\nparallelization, and to get the optional features, we load another one package as mentioned\nearlier in Section 2. Then we start two mathematica slaves named as 'link1' and 'link2' in the\ntwo remote computers 'tcmpxeon' and 'tcmp441d' respectively by using the proper commands\nas discussed in Section 3.\nStep-2 : Next we make ready three programs for the three separate square matrices of same\norder in the local computer. Out of which one program will run in the local computer, while\nthe rest two will run in the two remote computers. These three programs are as follows.\n\nI.\n\nsample1[ns\u2212 ]:=Block[{esi= 0, t = 1.2, p = 2.1,vacuum1={}},\nDo[Do[a1=If[i==j,esi,0];\na2=If[i < j && Abs[i \u2212 j]== 1, t, 0];\na3=If[i > j && Abs[i \u2212 j]== 1, p, 0];\na4=a1+a2+a3;\na5 = AppendTo[vacuum1,a4], {j, 1, ns}], {i, 1, ns}];\na6 = Partition[a5, ns]]\n\nII.\n\nsample2[ns\u2212 ]:=Block[{esi= 0, q = 2.6, r = 1.8,vacuum2={}},\nDo[Do[a1=If[i==j,esi,0];\na2=If[i < j && Abs[i \u2212 j]== 1, q, 0];\na3=If[i > j && Abs[i \u2212 j]== 1, r, 0];\na4=a1+a2+a3;\na5 = AppendTo[vacuum2,a4], {j, 1, ns}], {i, 1, ns}];\na6 = Partition[a5, ns]]\n\nIII.\n\nsample3[ns\u2212 ]:=Block[{esi= 0, u = 2, v = 3,vacuum3={}},\nDo[Do[a1=If[i==j,esi,0];\na2=If[i < j && Abs[i \u2212 j]== 1, u, 0];\na3=If[i > j && Abs[i \u2212 j]== 1, v, 0];\na4=a1+a2+a3;\na5 = AppendTo[vacuum3,a4], {j, 1, ns}], {i, 1, ns}];\na6 = Partition[a5, ns]]\n\n\fSince we are quite familiar about the way of writing mathematica programs [1], we do not\ndescribe here the meaning of the different symbols used in the above three programs further.\nThus by using these programs, we can construct three separate square matrices of order 'ns'.\nStep-3 : We are quite at the end of our complete operation. For the sake of simplicity, we assume\nthat, the program-I is evaluated in the local computer, while the program-II and programIII are evaluated in the two remote computers respectively. All these three programs run\nsimultaneously in three different computers. To understand the basic mechanisms, let us follow\nthe program.\nsample4[ns\u2212 ]:=Block[{},\nExportEnvironment[\"Global`\"];\nmat1 = sample1[ns];\nRemoteEvaluate[Export[\"data1.dat\", sample2[ns]], link1];\nRemoteEvaluate[Export[\"data2.dat\", sample3[ns]], link2];\nmat2 = RemoteEvaluate[ReadList[\"data1.dat\", Number, RecordLists\u2192 True],\nlink1];\nmat3 = RemoteEvaluate[ReadList[\"data2.dat\", Number, RecordLists\u2192 True],\nlink2];\nmat4 = mat1.mat2.mat3;\nChop[Eigenvalues[mat4]]]\nThis is the final program. When it runs in the local computer, one matrix called as 'mat1'\nDaughter slave in\nremote computer\ntcmpxeon\n\nDaughter slave in\nremote computer\ntcmp441d\n\nMaster slave in\nlocal computer\ntcmpibm\n\nFigure 4: Schematic representation of parallelization.\nis evaluated in the local computer (3rd line of the program), and the other two matrices are\ndetermined in the remote computers by using the operations given in the 4th and 5th lines of the\nprogram respectively. The 2nd line of the program gives the command for the transformations of\nall the symbols and definitions to the remote computers. After the completion of the operations\nin remote computers, we call back these two matrices in the local computer by using the\ncommand 'ReadList', and store them in 'mat2' and 'mat3' respectively. Finally, we take the\n\n\fproduct of these three matrices and calculate the eigenvalues of the product matrix in the local\ncomputer by using the rest operations of the above program.\nThe whole operations can be pictorially represented in Fig. 4.\nAt the end of all the operations, we close all the mathematica slaves by using the following\ncommand.\nCloseSlaves[ ]\n\nConcluding Remarks\nIn summary, the basic operations presented in this communication may be quite helpful for\nthe beginners. Starting from the basic level, in Section 2, we have explored how to start\nmathematica, open a mathematica notebook, write a program in mathematica, etc. Following\nwith this, we have also described the utilities of the local and global variables those are used\nfor writing programs in mathematica.\nLater, in Section 3, we have illustrated the basic mechanisms for the linking of external\nprograms with mathematica notebook. This mathlink operation is an important part of this\narticle, and it is extremely crucial for doing large numerical computations. Here we have concentrated the mathlink operation mainly for the XL Fortran 90 source files. But this operation\ncan also be used for any other Fortran source file. In this section, we have also illustrated very\nbriefly about the optimization techniques for the Fortran source files which may help us to run\nvery complicated jobs quite efficiently.\nIn Section 4, we have addressed in detail how to set up a mathematica batch-file from a\nmathematica notebook and run it in the background of a computer. Several programs are there\nwhich can take a considerable amount of time to run. Some may take few days or even few\nweeks to complete their analysis. For this reason, it may be desirable to place such jobs in the\nbackground. This is a way of running a program that allows one to continue working on other\ntasks (or even log out) while still keeping the program running. Furthermore, backgrounded\njobs are not dependent on our session remaining open, so even if our computer crashes, the job\nwill continue uninterrupted.\nAt the end, in Section 5, we have explored the basic mechanisms for parallelizing a mathematica program by running its independent parts in remote computers available in the network.\nBy using this parallelization technique, one can enhance the efficiency of the numerical works,\nand it helps us to perform all the mathematical operations within a very short period of time.\nThroughout the article, we have focused all the basic operations for the Unix based operating\nsystem only. But all these operations also work very well in any other supported operating\nsystem like Windows, Macintosh, etc.\n\nAcknowledgment\nI acknowledge with deep sense of gratitude the illuminating comments and suggestions I have\nreceived from Prof. Sachindra Nath Karmakar during the preparation of this article.\n\n\fReferences\n[1] Stephen Wolfram. Mathematica-5.0.\n[2] Roman E. Maeder. About Parallel Computing Toolkit. A Wolfram Research Application\nPackage.\n[3] I. M. Smith. Programming in Fortran 90 : A First Course for Engineers and Scientists.\nUniversity of Manchester, UK.\n[4] Martin Counihan. Fortran 90. University of Southampton.\n[5] IBM. XL Fortran for AIX : User's Guide.\n\n\f"}