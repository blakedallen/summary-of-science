{"id": "http://arxiv.org/abs/1203.3866v2", "guidislink": true, "updated": "2013-01-08T11:25:49Z", "updated_parsed": [2013, 1, 8, 11, 25, 49, 1, 8, 0], "published": "2012-03-17T14:33:37Z", "published_parsed": [2012, 3, 17, 14, 33, 37, 5, 77, 0], "title": "Computational Security Analysis of the UMTS and LTE Authentication and\n  Key Agreement Protocols", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.3339%2C1203.5755%2C1203.0618%2C1203.2192%2C1203.6319%2C1203.1441%2C1203.5366%2C1203.0726%2C1203.2036%2C1203.0914%2C1203.5763%2C1203.3192%2C1203.4988%2C1203.5526%2C1203.6018%2C1203.0869%2C1203.6424%2C1203.0345%2C1203.5251%2C1203.2581%2C1203.5631%2C1203.4220%2C1203.3238%2C1203.5302%2C1203.6208%2C1203.6897%2C1203.3933%2C1203.1898%2C1203.3866%2C1203.4210%2C1203.0225%2C1203.4575%2C1203.2815%2C1203.5866%2C1203.4455%2C1203.0701%2C1203.6234%2C1203.3523%2C1203.0998%2C1203.5950%2C1203.2580%2C1203.3944%2C1203.6013%2C1203.5809%2C1203.5794%2C1203.0082%2C1203.6384%2C1203.3293%2C1203.6337%2C1203.4868%2C1203.6207%2C1203.1920%2C1203.5033%2C1203.5510%2C1203.2541%2C1203.4693%2C1203.3780%2C1203.3105%2C1203.6026%2C1203.0142%2C1203.5301%2C1203.6038%2C1203.6418%2C1203.0383%2C1203.0242%2C1203.4400%2C1203.0396%2C1203.4981%2C1203.6881%2C1203.4282%2C1203.3637%2C1203.3414%2C1203.2821%2C1203.5959%2C1203.3693%2C1203.2652%2C1203.5134%2C1203.4333%2C1203.3535%2C1203.4894%2C1203.1683%2C1203.3376%2C1203.5728%2C1203.6322%2C1203.6531%2C1203.0243%2C1203.4800%2C1203.2205%2C1203.2813%2C1203.0752%2C1203.3885%2C1203.2776%2C1203.0263%2C1203.3717%2C1203.3884%2C1203.6454%2C1203.2945%2C1203.3592%2C1203.4604%2C1203.0975%2C1203.3607&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Computational Security Analysis of the UMTS and LTE Authentication and\n  Key Agreement Protocols"}, "summary": "We present a computational security analysis of the Authentication and Key\nAgreement (AKA) protocols for both Long-Term Evolution (LTE) and Universal\nMobile Telecommunications System (UMTS). This work constitutes the first\nsecurity analysis of LTE AKA to date and the first computationally sound\nanalysis of UMTS AKA. Our work is the first formal analysis to consider\nmessages that are sent in the core network, where we take into account details\nof the carrying protocol (i.e., MAP or Diameter) and of the mechanism for\nsecure transport (i.e., MAPsec/TCAPsec or IPsec ESP). Moreover, we report on a\ndeficiency in the protocol specifications of UMTS AKA and LTE AKA and the\nspecifications of the core network security (called network domain security),\nwhich may enable efficient attacks. The vulnerability allows an inside attacker\nnot only to impersonate an honest protocol participant during a run of the\nprotocol but also to subsequently use wireless services on his behalf. UMTS AKA\nrun over MAP with MAPsec seems vulnerable in the most straight-forward\napplication of the attack. On the other hand, our analysis shows that UMTS and\nLTE AKA over Diameter/IPsec and UMTS AKA over MAP/TCAPsec (with sufficiently\nlong session identifiers) computationally satisfy intended authentication\nproperties as well as some key secrecy properties, assuming that the used\nprimitives meet standard cryptographic assumptions.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1203.3339%2C1203.5755%2C1203.0618%2C1203.2192%2C1203.6319%2C1203.1441%2C1203.5366%2C1203.0726%2C1203.2036%2C1203.0914%2C1203.5763%2C1203.3192%2C1203.4988%2C1203.5526%2C1203.6018%2C1203.0869%2C1203.6424%2C1203.0345%2C1203.5251%2C1203.2581%2C1203.5631%2C1203.4220%2C1203.3238%2C1203.5302%2C1203.6208%2C1203.6897%2C1203.3933%2C1203.1898%2C1203.3866%2C1203.4210%2C1203.0225%2C1203.4575%2C1203.2815%2C1203.5866%2C1203.4455%2C1203.0701%2C1203.6234%2C1203.3523%2C1203.0998%2C1203.5950%2C1203.2580%2C1203.3944%2C1203.6013%2C1203.5809%2C1203.5794%2C1203.0082%2C1203.6384%2C1203.3293%2C1203.6337%2C1203.4868%2C1203.6207%2C1203.1920%2C1203.5033%2C1203.5510%2C1203.2541%2C1203.4693%2C1203.3780%2C1203.3105%2C1203.6026%2C1203.0142%2C1203.5301%2C1203.6038%2C1203.6418%2C1203.0383%2C1203.0242%2C1203.4400%2C1203.0396%2C1203.4981%2C1203.6881%2C1203.4282%2C1203.3637%2C1203.3414%2C1203.2821%2C1203.5959%2C1203.3693%2C1203.2652%2C1203.5134%2C1203.4333%2C1203.3535%2C1203.4894%2C1203.1683%2C1203.3376%2C1203.5728%2C1203.6322%2C1203.6531%2C1203.0243%2C1203.4800%2C1203.2205%2C1203.2813%2C1203.0752%2C1203.3885%2C1203.2776%2C1203.0263%2C1203.3717%2C1203.3884%2C1203.6454%2C1203.2945%2C1203.3592%2C1203.4604%2C1203.0975%2C1203.3607&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a computational security analysis of the Authentication and Key\nAgreement (AKA) protocols for both Long-Term Evolution (LTE) and Universal\nMobile Telecommunications System (UMTS). This work constitutes the first\nsecurity analysis of LTE AKA to date and the first computationally sound\nanalysis of UMTS AKA. Our work is the first formal analysis to consider\nmessages that are sent in the core network, where we take into account details\nof the carrying protocol (i.e., MAP or Diameter) and of the mechanism for\nsecure transport (i.e., MAPsec/TCAPsec or IPsec ESP). Moreover, we report on a\ndeficiency in the protocol specifications of UMTS AKA and LTE AKA and the\nspecifications of the core network security (called network domain security),\nwhich may enable efficient attacks. The vulnerability allows an inside attacker\nnot only to impersonate an honest protocol participant during a run of the\nprotocol but also to subsequently use wireless services on his behalf. UMTS AKA\nrun over MAP with MAPsec seems vulnerable in the most straight-forward\napplication of the attack. On the other hand, our analysis shows that UMTS and\nLTE AKA over Diameter/IPsec and UMTS AKA over MAP/TCAPsec (with sufficiently\nlong session identifiers) computationally satisfy intended authentication\nproperties as well as some key secrecy properties, assuming that the used\nprimitives meet standard cryptographic assumptions."}, "authors": ["Joe-Kai Tsay", "Stig Mj\u00f8lsnes"], "author_detail": {"name": "Stig Mj\u00f8lsnes"}, "author": "Stig Mj\u00f8lsnes", "links": [{"href": "http://arxiv.org/abs/1203.3866v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1203.3866v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CR", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1203.3866v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1203.3866v2", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "Computational Security Analysis of the UMTS and LTE\nAuthentication and Key Agreement Protocols\nJoe-Kai Tsay and Stig F. Mj\u00f8lsnes\n\narXiv:1203.3866v2 [cs.CR] 8 Jan 2013\n\nDepartment of Telematics\nNorwegian University of Sciences and Technology, NTNU\n{joe.k.tsay,sfm@item.ntnu.no}\n\nAbstract. One of the forerunners and main candidates for the fourth generation (4G)\ngeneration mobile communication system is commonly known under the name Long-Term\nEvolution (LTE) and its standard is produced and maintained by the international 3rd\nGeneration Partnership Program (3GPP) consortium. The LTE Authentication and Key\nAgreement (AKA) protocol design is based on the Universal Mobile Telecommunications\nSystem (UMTS) AKA protocol, which is widely used today for third generation (3G) wireless\nnetworks, and which itself is the successor of the Subscriber Identity Authentication (SIA)\nprotocol of the Global System for Mobile Communication (GSM). With the persistent spread\nof these mobile network systems, their authentication protocols have become some of the\nmost widely used security protocols today. We present a computational security analysis of\nboth the LTE AKA and the UMTS AKA. This work constitutes the first security analysis\nof LTE AKA to date and the first computationally sound analysis of UMTS AKA. Our\nwork is the first formal analysis to consider messages that are sent in the core network,\nwhere we take into account details of the carrying protocol (i.e., MAP or Diameter) and\nof the mechanism for secure transport (i.e., MAPsec/TCAPsec or IPsec ESP). Moreover,\nwe report on a deficiency in the protocol specifications of UMTS AKA and LTE AKA and\nthe specifications of the core network security (called network domain security), which may\nenable efficient attacks. The vulnerability can be exploited by both an outside and an inside\nattacker who can violate entity authentication properties. It allows an inside attacker not\nonly to impersonate an honest protocol participant during a run of the protocol but also to\nsubsequently use wireless services on his behalf. UMTS AKA run over MAP with MAPsec\nseems vulnerable in the most straight-forward application of the attack. On the other hand,\nour analysis shows that UMTS and LTE AKA over Diameter/IPsec and UMTS AKA over\nMAP/TCAPsec (with sufficiently long session identifiers) computationally satisfy intended\nauthentication properties as well as some key secrecy properties, assuming that the used\nprimitives meet standard cryptographic assumptions.\n\nKeywords: Mobile Communication Systems, LTE, EPS, 4G, UMTS, 3G, GSM, 2G, Cryptographic Protocols, Authentication, Key Agreement, Vulnerability, Attack\n\n1\n\nIntroduction\n\nThese are exciting times in the development of mobile networks. The GSM and UMTS mobile\nnetworks are a worldwide success with now about 6 billion supscriptions [40], and still growing.\nThe pace of innovation in mobile terminal hardware and software is amazing, where touch screen\nand online packet switched internet access have become a consumer standard. New mobile systems\nare rolled out, which include the 3GPP recent developments named 'Long Term Evolution' (LTE)\nand 'System Architecture Evolution' (SAE). The new system is called 'Evolved Packet System\n(EPS), emphasizing the all-IP packet switching design throughout the system unto the user's\nmobile terminal. Although EPS is the proper technical term for this new 3GPP mobile system\ngeneration of SAE/LTE, we will keep with the most well-known name LTE. There is a multitude\nof security issues in such large networked systems. Here we will focus on the mobile terminal access\nsecurity by means of an authentication and key agreement protocol (AKA) that is structured very\n\n\fsimilar in UMTS and LTE. The technical problem we are addressing is to find out whether the\nUMTS AKA and LTE AKA are secure with respect to the Computational Model, i.e. the security\nmodel that is used in Modern Cryptography [35,36]. This work constitutes the first computational\nanalysis of both UMTS AKA and LTE AKA. While there exist formal analyses of UMTS AKA in\nthe Symbolic Model of security (also called the Dolev-Yao model and inspired by [34]), it is in fact\nthe first security analysis of LTE AKA to date. While there exist already formal security proofs\nfor UMTS AKA in the symbolic model, this work provides the first security proofs for LTE AKA\nto date. Although the design of LTE AKA is based on UMTS AKA, its security can a priori not be\ndeduced from the security properties of UMTS AKA as, for instance, the LTE AKA protocol has\nbeen designed to offer stronger authentication guarantees. Furthermore, our proofs are the first\nthat cover the AKA1 messages sent within the core networks, where we take into account security\ndetails of the protocols over which the UMTS and LTE AKA protocol messages are transported.\nNamely, our proofs examine security properties of the UMTS and LTE AKA protocol for the\nscenario with the strongest protection described in the UMTS and LTE specifications: within the\ncore network, the AKA messages are carried over the Mobile Application Part (MAP) protocol [2]\nor the Diameter protocol [3,37] and are additionally protected via MAPsec [5] or TCAPsec [6]\n(which is the descendant of MAPsec) or IPsec ESP [7]. We note that there are scenarios where the\n3GPP specifications [7,5,6] allow network operators to use their proprietary solutions for protecting\ncore network messages or where the AKA protocols can be executed without any confidentiality\nprotection. Proprietary solutions can generally not be verified unless explicit details are given2 .\nAnd in the case that no confidentiality protection is used in the core network, the exchanged session\nkeys are exposed and can be eavesdropped, and so there are no meaningful security properties to\nprove.\nDesigning security protocols has proven to be a very error-prone task. There exist many examples of security protocols that were believed to be secure, usually with respect to the symbolic or\nthe computational model of security, but that were later shown to be flawed (often in its logical\nstructure) [47,48,52,29]. Especially ensuring the security of a protocol under concurrent executions\nof multiple protocol sessions (runs) is a challenging task in analyzing security protocols by hand.\nTherefore, considerable effort has been directed towards the development of tools that can analyze\nsecurity protocols in an automatic fashion. There are already several tools that are able to analyze\nsecurity protocols with respect to the symbolic model. In particular secrecy and authentication\nproperties, even of complex protocols, can be shown with a high degree of automation. But also\nother properties, e.g. privacy and verifiability properties of electronic voting protocols, can be\nhandled by such symbolic provers [32,15,18,22,49]. While attacks found against protocols within\nthe symbolic model, where cryptographic primitives are perfectly secure, immediately translate to\nattacks in the computational model, it is not clear what the successful verification of a protocol\nin the symbolic model signifies when the security of the protocol is considered in the more finegrained computational model where an adversary may attack a protocol via the used primitives.\nIn order to take advantage of the existing effective tools that work in the symbolic model but,\nat the same time, obtain the stronger security guarantees of the computational model, a line of\nresearch focuses on so-called Computationally Sound frameworks, e.g. [16,28,33,31,30]. However,\ncurrently such frameworks lack the tool support yet which would allow proofs without a lot of user\ninteraction. In recent years, an alternative direction has been taken by building tools that prove\nthe security of protocols or cryptographic primitives directly in the computational model [25,17].\nOne such solution, CryptoVerif, has previously been applied to obtain mechanized security proofs\nin the computational model of complex real-world protocols such as Kerberos [26] or TLS [21].\nWe also conduct our analysis of UMTS AKA and LTE AKA with CryptoVerif. Our results are\ntwofold: On the one hand, we discover a previously undetected vulnerability in the specifications\nof both UMTS AKA and LTE AKA and the specifications of the core network security [7,5,6].\n1\n2\n\nWe sometimes write only AKA when we talk about both UMTS AKA and LTE AKA\nWe do not have any knowledge about proprietary solutions (and their specifics) for protecting core\nnetwork AKA messages that deviate from the strongest protection described in the specifications. (and\nconsidered in this work)\n\n2\n\n\fDue to an identity misbinding of the authentication vectors an attacker can execute a parallel\nsession attack.3 The vulnerability found could be exploited by both outside and inside attackers\nin order to break authentication of a user to a serving network. Furthermore, inside attackers may\nimpersonate an honest user and use wireless services on his behalf without the user being present\non the network at that time. We reported the vulnerability to the 3GPP in Spring 2012 and have\nsince been waiting for any reply. In practice, UMTS AKA over MAP/MAPsec is flawed as the\nsession identifiers (called TCAP transaction identifier ) are not protected. And the attack may\nalso be effective against both UMTS AKA and LTE AKA over intra-domain, depending on the\nproprietary security solutions in place.\nOn the other hand, our analysis shows that UMTS and LTE AKA run over Diameter/IPsec\nEPS and UMTS over MAP/TCAPsec are computationally secure: Under standard assumptions\non the cryptographic primitives, e.g., including IND-CPA secure symmetric encryption and WUFCMA secure integrity protection, and under the additional assumption that the session identifier\nused in the carrying protocols (MAP or Diameter) are unique with overwhelming probability, we\nuse CryptoVerif to prove intended authentication properties and secrecy properties for the session\nkeys that are exchanged with the AKAs.\nRelated Work Annex B of the 3GPP technical report TR33.902 (2001) [1] documents a formal analysis of the UMTS AKA protocol using a BAN logic variant, i.e., a symbolic and not\ncomputational analysis. The analysis verifies authentication and secrecy properties under the assumption that the home network acts as a trusted third party. The flaw that we present here is\nnot detected in [1] because strong assumptions (called prerequisites on SN's side) are used which\nalready eliminate the weakness in the protocol and the network domain security.\nThe GSM Subscriber Identity Authentication protocol does not provide for the authentication\nof the access network, which obviously creates a problem with detecting false base stations. The\ninteroperability of the GSM and UMTS systems perpetuates this attack possibility, reported in [50].\nOur analysis is not directed to the problems of interoperability between LTE/UMTS/GSM.\n[54] formally analyze the security UMTS and GSM roaming protocols using the tool ProVerif [22]\nwith respect to the symbolic security model. Again, they use strong assumptions on the core network communication between serving networks and home networks (namely, they use private\nchannels), which cause them to overlook the vulnerability we discover.\nA redirection attack on the UMTS AKA is reported in [55], which exploits the observation that\nthe user is not able to authenticate the identity of the serving network because this is not included\nin the authentication vector provided by the home network. The new LTE AKA specification that\nwe analyze is designed to fix this weakness and implicitly authenticate the serving network to the\nuser.\nA recent paper focuses on the unlinkability and anonymity properties of the protocol [14].\nThey also use the ProVerif tool for a symbolic analysis, and the paper describes an attack that\nenables the adversary to distinguish a known user from any other. This is done by replaying\ncaptured messages from the known user and use the different error messages that are returned.\nThe analysis models the UMTS AKA as a simplified two-party protocol between a user and the\ncore network. However, by reducing UMTS AKA to a two-party protocol, the weakness uncovered\nin the present work is stamped out.\nOur work is also relevant for RFC 4187 [39] that specifies an Extensible Authentication Protocol\nMethod for 3rd Generation Authentication and Key Agreement (EAP-AKA) based on UMTS\nAKA, which is compatible with [38]. In particular, close attention needs to be paid in case the\ncommunication between EAP authenticator and authentication server should be secured. We note\nthat the authors of [39] explicitly state that the IETF has not validated the security claims.\nStructure of this work In Section 2, we will give an overview of the Mobile Network architecture\nand give a description of the UMTS AKA and LTE AKA protocols. In Section 3, we describe the\n3\n\nWe note that the attack is also relevant for the cases where the protocol messages of the GSM Subscriber\nIdentity Authentication [12,11] are meant to be protected within the core network (cf. Appendix B).\n\n3\n\n\fvulnerability we found on both on the specifications of UMTS and LTE AKA and its consequences.\nIn Section 4, we present our computational security proofs of UMTS and LTE AKA using the tool\nCryptoVerif. Finally, we conclude with Section 5.\n\n2\n\nThe UMTS and LTE Authentication and Key Agreement Protocols\n\n2.1\n\nOverview of the Mobile Network Architecture\n\nFor both UMTS and LTE the basic network architectures are very similar. In comparison to\nUMTS, the network elements used for LTE are upgraded and mostly renamed. However, they\nfulfill the analogous tasks in both cases. In order to avoid unnecessary confusion over terminology,\nwe give a unified description of the network architectures of UMTS and LTE at the level of\ndetail necessary for understanding our analysis presented below. Basically, the mobile network\narchitecture comprises three parts, that is, the user's mobile equipment U , the Radio Access\nNetwork (RAN), and the Core Network (CN). The user equipment consists of the mobile equipment\nand a tamper-resistant chip card, the Universal Subscriber Identity Module (USIM). The USIM\nis issued by a mobile operator to a subscriber and contains the International Mobile Subscriber\nIdentity (IMSI), the permanent key of the subscription shared between subscriber and operator,\nand the cryptographic algorithms for the authentication protocol. In the following, we will use\nthe terms user, subscriber and user equipment interchangeably. Each mobile operator runs an\nAuthentication Center (AuC ) server within its core network that contains the security related\ninformation of all the subscribers of the operator and generates temporary security credentials to\nbe used by a user and a core network to establish authentication guarantees and set up session\nkeys. The core network is divided into a serving network S and a home network H, where the latter\ncontains and maintains the AuC and the serving network is responsible for the communication to\nthe user equipment through the radio access network.\nThe serving network and the home network do not necessarily belong to the same security\ndomain, i.e., they may be controlled by different mobile operators. A subscriber U1 of a mobile\noperator OP 1 with home network H1 may roam into the domain of mobile operator OP 2 's radio\naccess network maintained by serving network S2 . If OP 1 has a roaming agreement with OP 2 ,\nthen U1 will be able to access the mobile network through S2 's radio access network. In this\ncase, the connections between S2 and H1 are called inter-domain connections. In comparison, the\nconnections within a core network controlled by a single mobile operator, i.e., between Si and Hi ,\nfor i \u2208 {1, 2}, are called intra-domain connections.\n2.2\n\nUMTS & LTE AKA\n\nFigure 1 shows the message sequence diagram description of the authentication and key agreement\nprotocol in a unified way for UMTS and LTE on a similar level of detail as depicted in [4,9]. The\nprotocol is executed between user U , visited serving network S and U 's home network H. U and\nH share the long-term key K and a set of algorithms f1 , . . . , f4 and, in the case of LTE, also a\nkey derivation function KDF . The functions f1 , f2 are so called message authentication functions,\nand f3 , f4 are so called key generating functions 4 . Moreover, U maintains a counter SQN U and\nH a counter SQN H for U .\nA protocol run starts with S sending a user id request and U responding with its IMSI 5 . Next\nfollows the authentication data transfer, in which S sends an authentication data request to H,\nthat consists of U 's IMSI and S's identifier SNid , and H answers with an authentication data\nresponse. H chooses a fresh nonce RAND and computes, with the key K and its sequence number\nSQN H , the so-called message authentication code MAC , the expected response XRES , the cipher\n4\n\n5\n\nWe choose to do without the anonymity key, i.e. f5 \u2261 0, which is an option in the specifications. We\nalso omit the AMF constant.\nIn fact, U may alternatively respond with a temporary mobile subscriber identity (TMSI), which\nreduces but does not fully avoid the use of the IMSI .\n\n4\n\n\fU\n\nS\n\nH\n\nIMSI , K\n\nSNid\n\n{IMSI i , Ki }i\n\nuser id request\nuser id response\nIMSI\n\nauth data request\nIMSI , SNid\nnew nonce RAND\nMAC \u2190 f1,K (SQN H k RAND)\nXRES \u2190 f2,K (RAND )\nCK \u2190 f3,K (RAND )\nIK \u2190 f4,K (RAND )\nAUTN \u2190 SQN H k MAC\ngenerate key Skey\n\nuser auth request\nRAND, AUTN\n\nauth data response\nRAND, AUTN , XRES , Skey\n\n?\nMAC = f1,K (SQN H k RAND)\ncheck(SQN U , SQN H )\nRES \u2190 f2,K (RAND )\ncompute key Skey\n\nuser auth response\nRES\n?\nRES = XRES\n\nFig. 1. The UMTS/LTE Authentication and Key Agreement Protocol. The session key in UMTS is Skey \u2190\nCK k IK , and in LTE it is Skey := KASME \u2190 KDF (SQN H k CK k IK k SNid).\n\nkey CK , the integrity key IK , and the authentication token AUTN as depicted in Figure 1, where\nk denotes concatenation. The main difference between the UMTS AKA and LTE AKA is the\nsession key Skey. In LTE AKA, the session key is computed over the identifier of S. There is\nthe option that H sends S multiple authentication vectors (RAND i , AUTN i , XRES i , Skey i ) for\ni = 1, . . . , n at once in order to reduce the traffic between S and H.\nIn the user authentication request, S forwards only RAND and AUTN to U . From the received\nRAND, AUTN , the user U extracts SQN H , computes the expected message authentication code\nXMAC and compares it to MAC contained in AUTN . If they are equal then U performs a check\non the sequence numbers SQN H and SQN U 6 . If either of this two checks fail, then U sends some\nerror messages to S (in fact, the error messages may be different, therefore allowing the linkability\nattack of [14]). Otherwise U computes the response RES and sends it to S. User U can compute\nthe session key Skey from RAND and K. Finally, S compares the response received from U with\nthe expected response received from H; if they are equal then the UMTS/LTE AKA run was\nsuccessfully completed.\nIntuitively, the UMTS/LTE AKA establishes the session key Skey between U and S, therefore,\nSkey must satisfy some secrecy property. Furthermore, the protocol aims to authenticate U to\nS. Both properties require S to trust H to provide a correct authentication data response. The\nsequence numbers allow to detect possible replays of authentication tokens. The UMTS/LTE AKA\nprotocol, as depicted in Figure 1, does not offer authentication of S to U . This known weakness\nhas been described in [55]. User U may at most know that H generated the received nonce and\nauthentication token for some service network.\nFollowing the UMTS/LTE AKA, serving network S and user U need to negotiate the cryptographic algorithms (security mode) used to protect subsequent wireless communication between\n6\n\nChecking and increasing the sequence numbers can be done in different ways\n\n5\n\n\fS and U . Note that these algorithms are, in particular for inter-domain connections, not predetermined. The messages of this negotiation are protected by (keys derived from) Skey. This is\nespecially relevant for the case of LTE, where Skey is generated over S's identifier SNid . In LTE,\nby receiving the NAS security mode command directly following the user authentication response\nof the AKA, U should be able to authenticate S, as this message constitutes a key confirmation\nof the session key KASME . According to [9], the NAS security mode command sent from S to U\nhas following form:\nS \u2212\u2192 U : eKSI , UE security capabil ., ciph. algo, int . algo, NAS -MAC\nwhere NAS-MAC is a message authentication code under a key derived from KASME over the rest\nof the message, which consists of non-secret components7 . We denote by LTE AKA+1 the LTE\nAKA protocol together with this NAS security mode command message.\n\n3\n\nA Vulnerability in UMTS & LTE AKA\n\nHere we present a weakness found in the authentication protocol specifications of both UMTS\nand LTE AKA with the help of the tool CryptoVerif [23]. Although CryptoVerif has semantics\nin the computational model, the flaw in the protocols is of symbolic nature. Unlike other provers\nthat work in the symbolic model, CryptoVerif does not output attack traces; instead we found\nthe attack by interpreting the last game in a sequence of game transformations performed by\nCryptoVerif. It is the same flaw that is present in the specifications of both UMTS AKA and LTE\nAKA. Although UMTS AKA has previously been formally analyzed [14,1], none of the previous\nanalyses have detected this flaw. How GSM SIA is affected by the flaw is discussed in Appendix B.\n3.1\n\nCommunication Security Between S and H\n\nAs given in Figure 1, the communication in the core network, i.e., between S and H, is not\nprotected even though it can involve long-distance signalling, e.g., over IP networks. However it\nis obvious that the communication between S and H should be protected in some way against a\nnetwork attacker, otherwise the exchanged session key(s) are sent in the clear. The specifications\nof the security architectures of UMTS and LTE in [9] and [4], which specify the AKA protocols,\nmention little about the security protection of the authentication data transfer. For instance,\nthe AKA protocols are given in [9] and [4] at essentially the same level of detail as in Figure 1.\nHowever, for UMTS and LTE, the Network Domain Security (NDS) specifications detail the\nprotection of core network communication: [7,8] specify the protection of IP-based communication\nbetween network elements. In addition, for UMTS, the communication between S and H can\nalso be carried out on the global SS7 network and its protection is then specified in [6,5]. In all\ncases, the specifications distinguish between inter-domain communication, where communicating\nparties are not controlled by the same mobile operator, and intra-domain communication, where\nthe communicating parties are controlled by the same mobile operator.\nFor inter-domain connections over IP-based networks, [7,8] mandate the protection of the communication between network elements using IPsec with Encapsulating Security Payload (ESP)\nmode. For inter-domain connections over SS7 networks, the specification [6] mandates the protection using Transaction Capabilities Application Part security (TCAPsec), which is the successor\nfor Mobile Application Part security (MAPsec) [5]. According to the specifications [5,6,7], IPsec\nESP, MAPsec and TCAPsec should all provide\n\u2013 data integrity\n\u2013 data origin authentication\n\u2013 anti-replay protection\n7\n\neKSI is the key identifier for KASME , UE security capabil are the security capabilities that UE had\nsent to S before running the AKA, ciph. algo are the algorithms chosen by the serving network for\nencryption, int. algo are the algorithms chosen by the serving network for integrity protection\n\n6\n\n\f\u2013 confidentiality (optional)\nFor the case of IPsec ESP, [7] also lists as security guarantee\n\u2013 limited protection against traffic flow analysis when confidentiality is applied.\nFor intra-domain connections over IP-based networks or SS7 networks, however, [7,8,6,5] state\nthat the protection of communication is regarded as an internal issue of each domain operator. In\nparticular, utilizing MAPsec, TCAPsec or IPsec ESP for intra-domain communication between S\nand H is optional, even though the communication may involve long distance signaling. Instead it\nis the decision of the operator what kind of protection of the core network communication he/she\nwants in the network domain and which (proprietary) solutions he/she may deploy to achieve that\nprotection.\n3.2\n\nSession-mixup Attack against the Authentication Data Response\n\nFor our attacks on the UMTS and LTE AKA we consider, as usual, an adversary who is in full\ncontrol of the messages sent between instances of the roles of user U , serving network S, and\nhome network H. In particular, the adversary can control all incoming and outgoing messages of a\nserving network S. We assume that the home network H acts as a trusted third party. We assume\nthat the messages sent between S and H are encrypted and then integrity protected through a\nmessage authentication code under long-term keys shared between S and H(notice that support\nfor pre-shared keys is required in [5,6,7]), while not making any distinction between intra- or interdomain connections. The encrypt-then-mac scheme is indeed the principle used by IPsec, MAPsec,\nand TACAPsec. Neglecting momentarily the details and differences of the carrying protocols, we\nconsider the scenario in which two user equipments U and U \u2032 are running concurrent sessions\nwith the same serving network S. Notice that when S sends an authentication data request to H\nfor authentication parameters of U , the authentication data response by H to S is bound to U\nas it includes message components that are generated under the long-term key shared between H\nand U . However, S cannot verify for which user equipment the received randomness and session\nkey were generated for, as S does not know the key shared between the user equipments and H.\nWe present two alternative scenarios in which an attacker may take advantage of this.\nAn Inside Attack In this scenario we consider an attacker A who is a subscriber U of H. The\nmessage flow of this attack is depicted in Figure 2, where we omit the user identity request by S\n(cf. Figure 1). Say U \u2032 is another subscriber of H who is honest. If A knows the IMSI \u2032 of U \u2032 , which\nA can learn either by listening on the network or by deploying a device called imsi catcher, then\nA can execute the attack that is depicted in Figure 2 without U \u2032 even being present. In this case,\nA does not need to be able to intercept messages sent over the base stations. The attacker sends\nout two user identity responses: IMSI \u2032 and his own subscriber identity IMSI . Then S will run two\nconcurrent AKA sessions, one for U and one for U \u2032 , and sends two authentication data requests\nto H. When H sends the authentication data responses for S and U , then adversary A redirects\nthis message such that it is mistaken by S as the response by H for S and U \u2032 while he blocks the\nauthentication data response that H generated for S and U \u2032 . Notice that this session mixup can\nbe created by the attacker without breaking any cryptographic primitive and does generally not\nviolate the specifications. Next the attacker redirects the messages sent by S intended for U \u2032 to\nU . So U correctly receives the user authentication request containing message components that\nwere generated by H for U (and S). Therefore, attacker A, who is registered as U , can generate\nthe correct response and relay it to to S such that S believes that the response was generated\nby U \u2032 . The other session that S opened for U \u2032 is halted by A; it cannot be completed because A\ndoes not know the keys that U \u2032 shares with H. Anyhow, A can impersonate U \u2032 to S, therefore,\nbreaking entity authentication. Furthermore, the attacker and S share a session key; it was in fact\ngenerated by H for U and S. At the same time, S believes that this session key was generated by\nH for S and U \u2032 . Therefore, the attacker is able to execute subsequent communication steps and\n7\n\n\fA\nA\n\nregistered\nas U\n\nS\n\nH\n\nstart session\nwith U\n\nsession for\nU &S\nA\n\nknowing\nIMSI of U \u2032\n\nstart session\nwith U \u2032\nstop\nfinish session\nwith U\n\nsession for\nU\u2032 & S\n\nFig. 2. Message flow of an inside attack against UMTS and LTE AKA (not showing the user id request).\nThe attacker impersonates honest user U \u2032 to S and shares the session key(s) with S, without U \u2032 being\ninvolved.\n\nuse the derived keys to use the wireless service provided by S on behalf of U \u2032 . 8 S will bill H for\nthe service that attacker A received on U \u2032 behalf, and H will bill U \u2032 . Furthermore, an attacker\ncan falsely cause U \u2032 to appear physically present within a certain network cell\nAn Outside Attack In this attack scenario the attacker A does not need to be a subscriber\nhimself. The message flow of this attack is depicted in Figure 3, where we omit the user identity\nrequest by S (cf. Figure 1). Assume that U and U \u2032 are subscribers of H and both execute an\nAKA run with S at the same time. First adversary A correctly forwards the user identity response\nmessage by U , respectively by U \u2032 , to S and also forwards the authentication data requests by S\nto H. At this point S has started two AKA sessions, one for U and one for U \u2032 . When H sends\nthe authentication data responses for U and U \u2032 , adversary A swaps these messages such that the\nauthentication data response for S and U is mistaken by S as the response by H for S and U \u2032 , i.e.\nit is accepted by S's session for U \u2032 . And A does the analogous with the response by H for S and\nU \u2032 . Again, this session mixup can be created by the attacker without breaking any cryptographic\nprimitive and does generally not violate the specifications. Next the attacker redirects the messages\nsent by S intended for U \u2032 to U and vice versa. So U correctly receives the user authentication\nrequest containing message components that were generated by H for U and S (and the analogous\nholds for U \u2032 ). Therefore, under the assumption that the tests on the sequence numbers pass, U and\nU \u2032 do not notice the attack and send out the correct user authentication responses to S. Finally,\nA relays the response by U to S such that S believes that the message came from U \u2032 , and does\nanalogous to the response by U \u2032 .\nEntity authentication of user equipment to S is clearly violated. At the end of the run, S\nbelieves that it successfully completed a run with U while it was in fact U \u2032 that participated in\nthat run with S. Likewise, while S believes that it completed a run of the protocol with U \u2032 , it was\nin fact U who participated in that run with S. Furthermore, while S believes that it is sharing a\nsession key Skey with U , it is in fact sharing the session key Skey with U \u2032 . Analogously, while S\n8\n\nThe attack is not fended off by the use of TMSIs. And the attacker's job is simplified in practice if\nmultiple authentication vectors are sent at once.\n\n8\n\n\fA\nU\n\nS\n\nH\n\nstart session\nwith U\n\nfinish session\nwith U \u2032\n\nsession for\nU &S\n\nU\u2032\nstart session\nwith U \u2032\n\nfinish session\nwith U\n\nsession for\nU\u2032 & S\n\nFig. 3. Example of a message flow of an outside attack against UMTS and LTE AKA (not showing the\nuser id request), where U is authenticated to S as U \u2032 and U \u2032 as U .\n\nbelieves that it is sharing a session key Skey \u2032 with U \u2032 , it is in fact sharing the session key Skey \u2032\nwith U . Therefore, the attacker A may continue swapping the subsequent communication between\nU and S and the one between U \u2032 and S, which are both protected by (keys derived from) the\nexchanged session key. In the case that U and U \u2032 are not corrupted, the attacker cannot learn the\nprotected data that is transmitted (assuming the cryptographic primitives are sufficiently secure).\nHowever, neither S or U or U \u2032 notices that U is authenticated to S as U \u2032 and U \u2032 as U .\nAs a consequence, U uses wireless service at the cost of U \u2032 and vice versa. Furthermore, an\nattacker can falsely cause U and U \u2032 to appear physically present within certain network cells.\n3.3\n\nFeasibility of Real-World Attacks\n\nIn this section we consider the relevant details of the carrying protocols within the core network\nand discuss the feasibility of the attack presented in the previous section. The AKA messages are\ncarried through the core network either by the Diameter protocol (for IP-based networks) or by the\nMAP protocol (for SS7 networks). Both carrying protocols make use of session identifier that allow\nnetwork operators to match authentication data responses with the corresponding authentication\ndata requests. The session identifier are called Session-Id in the Diameter specifications [37] and\nTransaction ID in the specifications of TCAP [41,42,43,44,45], which are referenced in the 3GPP\nMAP specification [2]. TCAP is run underneath MAP and used to handle concurrent dialogues\nfor MAP.\nThe session-mixup attack of the previous section on the AKAs (with IPsec ESP, MAPsec\nmode2 or TCAPsec mode2) is due to either a misbinding of the authentication data response\nand the intended user equipment or a misbinding of the authentication data response and the\ncorresponding authentication data request. As session identifiers bind the authentication data\nresponse and the corresponding request, the the use of such session identifiers in the carrying\nprotocols could prevent the session mixup attack if the used session identifiers are unique and\nintegrity protected.\nIn the following we consider the feasibility of the attack in the cases where the protection of\nthe core network communication follows the network domain security specifications [5,6,7]. We\n9\n\n\fstress that network domain operators are free to implement proprietary protection mechanisms\nfor intra-domain connections.9\nUMTS AKA over MAP and MAPsec When UMTS AKA is run over MAP and protected by\nMAPsec [5] then the session identifiers, i.e., the TCAP transaction identifiers, are not protected\nby MAPsec and can be manipulated by an attacker. Hence, the session mixup attacks should work\nin practice. We note that we have not implemented the attacks yet.\n\nUMTS AKA over MAP and TCAPsec When UMTS AKA is run over MAP and protected\nby TCAPsec [6] then the TCAP transaction identifiers are integrity protected and can generally\nnot be manipulated by an attacker. However, the Transaction ID of TCAP, as specified in [43],\nmay not be unique. It can be a counter of variable length from one to four octets. In particular,\nimplementations of UMTS AKA over MAP with TCAP that use only one or two octet long\nTransaction IDs may indeed be vulnerable to the session mixup attack in practice, as a wraparound of the Transaction ID counter could be forced by an attacker by starting a few thousand\nsessions. The attacker can then execute the session mixup attack for sessions with equal session\nidentifiers. As the Transaction ID is a counter, the attacker may be able to predict which sessions\neventually use the same Transaction IDs. We note that we are not aware of any real world systems\nthat are vulnerable (due to too short session identifier). On the other hand, if the TCAP transaction\nidentifier is long enough such that a wrap-around may not be feasible, then the TCAP transaction\nidentifiers could be regarded as unique (in practice), and a session mixup would then not be feasible\nas will be shown in Section 4.\nUMTS and LTE AKA over Diameter and IPsec When UMTS and LTE AKA are run over\nDiameter [37] and protected by IPsec EPS then the session identifiers are also integrity protected\nand can generally not be manipulated by an attacker. In terms of practical security parameters, the\nSession-ID of Diameter is specified in [37] to be a 64 bits long counter and is, therefore, practically\nunique. Again, the security proofs in Section 4 suggest that a session mixup is not feasible.\nWith the use of unique session identifier and authenticated encryption within the core network,\nthe UMTS and LTE AKA protocols are more accurately described by Figure 4 than by Figure 1.\nIn particular, the serving network S in Figure 4 generates a fresh nonce SSID that is included in an\nauthentication data request. The nonce SSID serves as a unique session identifier and is expected to\nbe included in the corresponding authentication data response. Furthermore, the communication\nbetween S and H is protected by authenticated encryption under a key that S and H share.\n\n4\n\nMechanized Analysis of the UMTS & LTE AKA\n\nIn this section, we first give an overview of the tool CryptoVerif that we used to analyze the\nAKA protocols and to find the flaw presented in Section 3. Then we discuss the cryptographic\nassumptions and modeling decisions we made. And finally we present the results we obtained.\nNotation. A function f : N \u2212\u2192 R\u22650 is negligible, if for every positive polynomial p there exists\nan integer N0 such that for all integers n > N0 it is f (n) < 1/p(n). A function g : N \u2212\u2192 R\u22650 is\noverwhelming if 1 \u2212 g is a negligible function. Two sequences {X\u03b7 }\u03b7\u2208N and {Y\u03b7 }\u03b7\u2208N are computationally indistinguishable if for every polynomial-time algorithm D, it holds that | Pr[D(Xn , 1n ) =\n1] \u2212 Pr[D(Yn , 1n ) = 1]| is a negligible function in n.\n9\n\nWe believe that intra-domain connections constitute the majority of connections made in the real world.\n\n10\n\n\fU\n\nS\n\nH\n\nIMSI , K\n\nSNid\n\n{IMSI i , Ki }i\n\nuser id request\nuser id response\nIMSI\nnew nonce SSID\n\nauth data request\n{{SSID , IMSI , SNid}}Ksh\nnew nonce RAND\nMAC \u2190 f1,K (SQN H k RAND)\nXRES \u2190 f2,K (RAND )\nCK \u2190 f3,K (RAND )\nIK \u2190 f4,K (RAND )\nAUTN \u2190 SQN H k MAC\ngenerate key Skey\n\nauth data response\n{{SSID , RAND, AUTN ,\nXRES , Skey }}Ksh\ncheck SSID\n\nuser auth request\nRAND, AUTN\n?\nMAC = f1,K (SQN H k RAND)\ncheck(SQN U , SQN H )\nRES \u2190 f2,K (RAND )\ncompute key Skey\n\nuser auth response\nRES\n?\nRES = XRES\n\nFig. 4. The UMTS/LTE Authentication and Key Agreement Protocol with unique session IDs and authenticated encryption in core network. The session key in UMTS is Skey \u2190 CK k IK , and in LTE it is\nSkey := KASME \u2190 KDF (SQN H k CK k IK k SNid). {{.}}Ksh denotes authenticated encryption.\n\n4.1\n\nCryptoVerif Basics\n\nThe prover CryptoVerif [25,23,24,27] can directly prove security properties of cryptographic protocols in the computational model. Protocols are formalized in CryptoVerif using a probabilistic\npolynomial-time process calculus which is inspired by the pi-calculus and the calculi introduced\nin [46] and [51]. In this calculus, terms have a computational semantics, i.e. messages are bitstrings\nand cryptographic primitives are functions operating on bitstrings, where the lengths of bitstrings\nare polynomial in a security parameter \u03b7.\nWhen analyzing protocols, CryptoVerif follows the idea of [53], i.e. the process calculus represents games, and CryptoVerif proofs are sequences of such games Q0 , Q1 , . . . , Qn , where the initial\ngame Q0 formalizes the protocol for which one wants to prove certain security properties. In a\nproof sequence, two consecutive games Qj and Qj+1 are observationally equivalent, meaning that\nthey are computationally indistinguishable for the adversary. CryptoVerif transforms one game\ninto another by applying, e.g. the security definition of a cryptographic primitive or by applying\nsyntactic transformations. For instance, if the protocol in game Q0 uses a symmetric encryption\nscheme that is IND-CPA secure then CryptoVerif may transform game Qi to Qi+1 by essentially\nreplacing every occurrences of an encryption of a plaintext m under a non-corrupted key with\nencryptions of bitstrings of zero of the same length as m. Therefore, all security definitions of\ncryptographic primitives have to be formalized as pairs of indistinguishable oracles.\n11\n\n\fIn the last game in a proof sequence the desired security properties should be obvious, i.e.\nCryptoVerif uses syntactic criteria to determine whether a security property is satisfied. Given a\nsecurity parameter \u03b7, CryptoVerif proofs are valid for a number of protocol sessions polynomial in\n\u03b7, in the presence of an active adversary. For protocols, CryptoVerif can prove secrecy properties\nand correspondence assertions, which can be used to formalize authentication properties.\nCryptoVerif operates in two modes: a fully automatic and an interactive mode. The interactive\nmode requires a CryptoVerif user to input commands that indicate the main game transformations\nthe tool should perform and the order in which they should be applied. CryptoVerif is sound with\nrespect to the security properties it shows in a proof, but properties it cannot prove are not\nnecessarily invalid. Occasionally, one needs to conclude a proof manually by inspecting the last\ngame that one obtained using either the fully automatic or the interactive mode of CryptoVerif.\nA more detailed description of CryptoVerif and its process calculus is given in [25].\nCryptoVerif Language In CryptoVerif, a term M that represent computations on bitstrings\ncan be constructed according to the following grammar:\nM ::=\ni\nx[M1 , . . . , Mm ]\nf (M1 , . . . , Mm )\n\nterm\nreplication index\nvariable access\nfunction application,\n\nwhere replication index i is used to distinguish several copies of a replicated process , and the\nvariable access x[M1 , . . . , Mm ] returns the value of x for the indices M1 , . . . , Mm .\nThere are two kinds of processes in the calculus: input processes and output processes. These\ncan be generated according to the grammar depicted in Figure 5.\nQ ::=\n0\nQ | Q\u2032\n!i\u2264N Q\nnewChannel c; Q\n \u0303 : T1 , . . . , xk [i]\n \u0303 : Tk ); P\nc[M1 , . . . , Ml ](x1 [i]\nP ::=\nc[M1 , . . . , Ml ]hM1\u2032 , . . . , Mk\u2032 i; Q\nnew x[i1 , . . . , im ] : T ; P\nlet x[i1 , . . . , im ] : T = M in P\nif defined(M1 , . . . , Ml ) \u2227 M then P else P \u2032\nL\nfind ( m\nj=1 uj1 [\u0129] \u2264 nj1 , . . . , ujmj [\u0129] \u2264 njmj\nsuchthat defined(Mj1 , . . . , Mjlj ) \u2227 Mj then Pj )\nelse P \u2032\nevent e(M1 , . . . , Mm ); P\n\ninput process\nnil\nparallel composition\nreplication N times\nchannel restriction\ninput\noutput process\noutput\nrandom number\nassignment\nconditional\n\narray lookup\nevent,\n\nFig. 5. Syntax of CryptoVerif's process calculus\n\nThe nil process does nothing, Q | Q\u2032 represents parallel execution of Q and Q\u2032 , the process\n!\nQ represents parallel execution of N copies of Q, which are indexed by i, and newChannel c; Q\ncreates a new private channel and executes Q. When process c[M1 , . . . , Ml ]hN1 , . . . , Nk i; Q, e.g.\n \u0303 :\nrepresenting a message being sent over the network, is executed then an input c[M1\u2032 , . . . , Ml\u2032 ](x1 [i]\n \u0303 : Tk ); P (where T represents types used in the calculus) is searched that is ready\nT1 , . . . , xk [i]\nto receive the sent message, i.e. the instantiations of the Mi\u2032 should be equal to the bitstring\nrepresentation of the Mi \u2013 if none exists then the process is blocked, if there are several then\ni\u2264N\n\n12\n\n\fone is chosen at uniform random, and then for j = 1, . . . , k, each Nj is essentially stored in\nxj [i]. Afterwards P is executed and input process Q becomes one of the available input processes. The process new x[i1 , . . . , im ] : T ; P chooses uniformly at random a number in the set of\nbitstrings corresponding to T (e.g. a set of random seeds needed for probabilistic encryption),\nlet x[i1 , . . . , im ] : T = M in P stores the bitstring instantiation of M , which must be of type\nT , in x[i1 , . . . , im ] and proceeds with P . The process if defined(M1 , . . . , Ml ) \u2227 M then P else P \u2032\nexecutes P if M1 , . . . , Ml have been defined and the interpretation\nLm of M (e.g., an equality test\non bitstrings) holds, otherwise it executes P \u2032 . The process find ( j=1 uj1 [\u0129] \u2264 nj1 , . . . , ujmj [\u0129] \u2264\nnjmj suchthat defined(Mj1 , . . . , Mjlj ) \u2227 Mj then Pj ) else P \u2032 , where \u0129 is a tuple i1 , . . . , im\u2032 , tries\nto find a branch of the execution indexed by 1 \u2264 j \u2264 m such that there exist indices uj1 [\u0129] \u2264\nnj1 , . . . , ujmj [\u0129] \u2264 njlj for which Mj1 , . . . , Mjlj have been defined and the computational interpretation of Mj holds, and in that case the process continues by executing Pj , otherwise it executes\nP \u2032 . The process event e(M1 , . . . , Mm ); P executes the event e(M1 , . . . , Mm ), then executes P . Executing an event does not change the state of the system, but events are used in the specification\nof authentication properties.\nAs an example, we formalize in CryptoVerif the process of the user equipment in the case of\nLTE AKA. Additional formalizations of processes for LTE AKA and LTE AKA+1 can be found\nin the Appendix A. Note that we do not model the first message by the serving network in Figure\nQU = !iU \u2264NU c1 [iU ](hostS : sn);\nc2 [iU ]hU, hostS i;\nc11 [iC ](RAND \u2032\u2032 : nonce, = SQN , MAC \u2032\u2032 : prpcblocksize );\nlet MAC \u2032\u2032\u2032 = prpcenc(concat8 (const 1 , SQN , RAND), prpKuh) in\nif MAC \u2032\u2032\u2032 = MAC \u2032\u2032 then\nlet RES \u2032\u2032 = prpcenc(concat9 (const 2 , RAND), prpKuh) in\nlet CK \u2032\u2032 = prpcenc(concat9 (const 3 , RAND), prpKuh) in\nlet IK \u2032\u2032 = prpcenc(concat9 (const 4 , RAND), prpKuh) in\n\u2032\u2032\nlet KASME\n= prf(prfKuh, concat3 (SQN , CK \u2032\u2032 , IK \u2032\u2032 , hostS ))\nevent partAuthU (RAND \u2032\u2032 , RES \u2032\u2032 );\nc12 [iU ]hRES \u2032\u2032 i;\ncfinish [iU ]();\nif hostS = S then\n(\n\u2032\u2032\nevent endAuthU 2(hostS , RAND \u2032\u2032 , KASME\n);\n\u2032\u2032\nlet keyU : mkeyseed = KASME\n)\n\u2032\u2032\ni.\nelse cend 1 [iU ]hKASME\nFig. 6. CryptoVerif formalization of user equipment actions in LTE AKA\n\n1, i.e. the user id request. First process QU obtains the name of the S to interact in an AKA run\nwith, then QU sends his own name (representing his IMSI) and the name S of a serving network\nout. When QU receives a nonce RAND \u2032\u2032 , the sequence number SQN equal to his own, and MAC \u2032\u2032\nthat is of type prpcblocksize , i.e. in the range of the PRP block cipher prpcenc (see Section 4.2\nfor the cryptographic assumptions made), then QU re-computes and checks the MAC \u2032\u2032 using the\nlong-term key prpKuh shared with trusted third party H and a public constant const 1 . Afterwards\nQU computes RES \u2032\u2032 , CK \u2032\u2032 and IK \u2032\u2032 , where QU uses the same key prpKuh but different constants\nconst 2 , const 3 , const 4 . The patterns concat8 and concat9 are used to wrap messages of different\nformats so that they can be taken as the first argument of the PRP encryption function. Then QU\n\u2032\u2032\ncomputes the session key KASME\nwith a pseudorandom function and a key for that purpose that\nit shares with H. Before QU sends out RES \u2032\u2032 , it records some of the messages seen in this run in\nthe event partAuthU , which should then correspond to messages recorded in events of the process\nfor honest S in order to obtain authentication guarantees. Finally, if QU indeed communicated\n13\n\n\f\u2032\u2032\nwith S then records the name S in the event endAuthU2 and stores KASME\nin keyU , but if hostS\nwas not honest S (but the adversary) then QU simply publishes the key.\n\nAuthentication and Secrecy using CryptoVerif Authentication in CryptoVerif is modeled by\ncorrespondence properties [24]. Events e(M1 , . . . , Mm ) are used in order to record that a certain\nprogram point has been reached, with certain values of M1 , . . . , Mm , and the correspondence\nproperties are properties of the form \"if some event has been executed, then some other events\nalso have been executed, with overwhelming probability\".\nVk\nA process Q satisfies the correspondence event(e(M1 , . . . , Mm )) \u21d2 i=1 event(ei (Mi1 , . . . ,\nMimi )) if and only if, with overwhelming probability, for all values of the variables in\nM1 , . . . , Mm , if the event e(M1 , . . . , Mm ) has been executed, then the events ei (Mi1 , . . . ,\nMimi ) for i \u2264 k have also been executed for some values of the variables of Mij (i \u2264 k,\nj \u2264 mi ) not in M1 , . . . , Mm .\nNote that CryptoVerif can also show stronger, injective correspondence, where for event(e(M1 ,\nVk\n. . . , Mm )) \u21d2 i=1 event(ei (Mi1 , . . . , Mimi )) the executions of the events ei (Mi1 , . . . , Mimi ) are\ndistinct. However, we are not interested in injective correspondences for UMTS and LTE AKA, as\nthey simply do not hold given our modeling of the protocol where there is little replay protection.\nThe formal definitions of correspondences in CryptoVerif can be found in [24].\nA variable is considered secret when the adversary has no information on it, that is, the\nadversary cannot distinguish it from a random number.\nA process Q preserves the one-session secrecy of x when, with overwhelming probability,\nthe adversary interacting with Q cannot distinguish any element of the array x from a\nuniformly distributed random number by a single test query. The test query returns either\nthe desired element of x or a freshly generated random number, and the adversary has to\ndistinguish between these two situations.\nNote that this notion of secrecy corresponds to the standard notion of key indistinguishability;\nbut it does not guarantee that the random numbers in x are independent. CryptoVerif can show\na stronger notion of secrecy, in which the adversary can perform several test queries, and which\ntherefore corresponds to the \"real-or-random\" definition of security [13]. However, this stronger\nnotion is not satisfied by UMTS and LTE AKA the way we model them. In particular, as replays\nare not immediately rejected by the protocols in our model, an adversary can force several protocol\nsessions to agree on the same key; if the adversary is allowed to perform several test queries then\nhe can distinguish a challenge key with overwhelming probability. The formal definitions of secrecy\nin CryptoVerif can be found in [25].\n4.2\n\nCryptographic Assumptions\n\nAs CryptoVerif operates with computational semantics, we need to specify the assumptions we\nmake for the cryptographic primitives used in UMTS and LTE AKA. The algorithms for f1 , . . . , f4\n(see Figure 1) are not mandated by the 3GPP's specifications, but can be chosen freely by the\nhome network operator. Indeed f1 , . . . , f4 are only needed in the USIM of the user equipment,\nand in the AuC server in the home network but are not used by the serving network S. These\nfunctions are rather vaguely described in [9]: f1 and f2 are 'message authentication functions'\nand f3 , f4 , f5 are 'key generating functions'. However, 3GPP specifies the sample algorithms set\nMILENAGE [10]. Motivated by MILENAGE, we assume that the f1 , . . . , f4 are all based on a\nsingle pseudo-random permutation block cipher10 . Notice that we assume that no anonymity key\nis used, i.e. f5 \u2261 0, which is an option in [9,4]. As in MILENAGE, all fi in the same run will use\n10\n\nin CryptoVerif the PRP block cipher is actually modeled rather like a PRF; this is justified by the\nPRF/PRP switching lemma, e.g. [20]\n\n14\n\n\fthe same long-term key (shared between U and H) in our model but each fi also takes as input a\nconstant ci . We further assume that each S shares with H a long-term symmetric encryption key\nand a long-term message authentication key; which corresponds to the requirement that IPsec and\nMAPsec must support pre-shared keys and also to our assumption that IPsec and MAPsec security\nassociations are static. Moreover, we assume that these keys are used to protect the connection\nbetween a S and H through an encrypt-then-mac scheme, where the encryption is IND-CPA secure\nand the message authentication code is WUF-CMA secure (this implies INT-PTXT [19]). There\nis no ordering on terms by size and no arithmetics in CryptoVerif, so we cannot implement any\nchecks on the sequence number SQN as intended by AKA; in our model the sequence number is\na constant and the user only checks for equality. In particular, that means that the protocol in\nour model lacks replay-attack protection. In addition, in the case of LTE AKA, we assume that\nthe key derivation function is a pseudo-random function which outputs a key seed to generate a\nmessage authentication key. This key seed is then used to generate the session key KASME . This\nway of indirectly generating KASME is due to the fact that in cryptography, security definitions\nfor a message authentication code (but also for encryption schemes etc.) only hold for keys that\nare created by the accompanying key generation algorithm. All cryptographic primitives that we\nuse are already modeled and ready-to-use in CryptoVerif.\n4.3\n\nResults\n\nIn this section, we present results that we have obtained with CryptoVerif (version 1.16) when\nanalyzing the UMTS and LTE AKA as depicted in Figure 4 under the cryptographic assumption\nstated in Section 4.2. In all the results below we assume that the home network H is a trusted\nthird party which always acts honestly. Excerpts of the CryptoVerif scripts used for the analysis\nof LTE AKA and LTE AKA+1 (as defined in Section 2.2) are given by Figure 6 and by Figures 7\n\u2013 13, which can be found in the appendix A. The corresponding input scripts for UMTS AKA are\neasily derivable from the presented scripts for LTE AKA; the main difference lies in the session\nkey (cf. Figure 1), i.e. for UMTS AKA, the process for H does not generate KASME and instead\nof KASME the pair of keys (CK , IK ) is used in the sent messages and events.11\nResults for UMTS AKA For UMTS we can prove the following.\nTheorem 1 (Authentication of core network to User Equipment). In the UMTS AKA,\nif there is an instance of\n\u2013 an honest user U receiving a value RAND \u2032\u2032 as nonce in a user authentication request and\ngenerates with it and the key shared with home network H a response RES \u2032\u2032\nthen, with overwhelming probability, there is an instance of\n\u2013 the home network H completing a run of the UMTS AKA for serving network S and user U\n\u2013 in which H generated a nonce RAND and an expected response XRES , where RAND equals\nRAND \u2032\u2032 and XRES equals RES \u2032\u2032 .\nIntuitively, this theorem implies that if a users completes a run of the UMTS AKA protocol then\nthe users can be certain that the received nonce was generated by the trusted home network\n(although this does not give the user any guarantee that the serving network it communicates\nwith is acting honestly).\nTheorem 2 (Entity Authentication of User Equipment to Serving Network). In the\nUMTS AKA, if there is an instance of\n\u2013 an honest serving network S completing a run of the UMTS AKA with honest user equipment\nU and home network H\n11\n\nPlease contact the authors of this work directly to obtain the full CryptoVerif input scripts for UMTS\nAKA, LTE AKA or LTE AKA+1.\n\n15\n\n\f\u2013 in which S received a value RAND \u2032 as nonce and a value XRES \u2032 as expected response from\nH in a authentication data response\n\u2013 and in which S received a value RES \u2032 that equals XRES \u2032 in a user authentication response\nthen, with overwhelming probability, there is an instance of\n\u2013 H completing a data authentication transfer with S\n\u2013 in which H generated a nonce RAND and an expected response XRES for the use between S\nand U , where RAND \u2032 equals RAND and XRES \u2032 equals XRES\nand an instance of\n\u2013 U completing a run of the UMTS AKA\n\u2013 in which U received a value RAND \u2032\u2032 as nonce that is equal to RAND \u2032\n\u2013 and in which U sent a response RES \u2032\u2032 that equals XRES \u2032 .\nIntuitively, this theorem implies that if serving network S completes a run of UMTS AKA for\nuser U then U must indeed have been involved in a run of the UMTS AKA in which it generated\nmatching values.\nTheorem 3 (Key Secrecy in UMTS AKA). Let QUMTS be the game in CryptoVerifs process\ncalculus formalizing the UMTS AKA. Furthermore, let keyS1 and keyS2 denote in QUMTS the\nconfidentiality key CK and, respectively, the integrity key IK that are received by an honest serving\nnetwork from the home network and generated by the home network for the use between the serving\nnetwork and an honest user. Then QUMTS preserve the one-session secrecy of keyS1 and keyS2.\nThis theorem states that the exchanged keys CK , IK that an honest serving network S holds after\ncompleting a UMTS AKA run with honest user U are cryptographically secret (in the sense of\n1-session secrecy). It is already known that UMTS AKA does not offer entity authentication of\na serving network S to user equipment U (which, e.g., allows an attacker to set up false base\nstations; see [55]). Therefore, with respect to secrecy of exchanged session keys, we can only hope\nfor showing that the key that S holds at the end of a session with an honest U is secure. The\nprocess of user U cannot distinguish cases where it agreed on a session key with honest serving\nnetwork S from cases where the session key is agreed on with a dishonest serving network S \u2032 .\nTherefore U 's session key is not secret.\nProof (for Theorems 1, 2 & 3). In the CryptoVerif process formalizing the UMTS AKA, when the\nprocess for honest S completes a run of the AKA protocol it executes an event endAuthS (h, RAND \u2032 ,\nXRES \u2032 ) that contains the name h of the user equipment that supposedly participated in the protocol run, and a nonce RAND \u2032 and an expected response XRES \u2032 that were protected under a\nencrypt-then-mac scheme with key that is shared with H. The event is executed after S received\na response that equals XRES \u2032 . When the process for H completes a run of the authentication\ndata transfer it executes an event endAuthH (h2, h1, RAND, XRES ) that contains the name of\na registered serving network h1 from whom it received a request, the name h2 of a registered\nuser equipment U , a random nonce RAND generated by H, and an expected response XRES\ngenerated by H using a key shared between H and h2. Furthermore, it executes an event event\nendAuthHU (h2, RAND, XRES ). When the process for honest U completes a run of the AKA protocol then it executes an event partAuthU (RAND \u2032\u2032 , RES \u2032\u2032 ) that contains a nonce RAND \u2032\u2032 that\nU received together with a valid MAC produced with a key kuh shared between U and H, and\nthat contains a response RES \u2032\u2032 generated by U over RAND \u2032\u2032 using the key kuh . We can show with\nCryptoVerif the correspondence queries\nevent partAuthU (x, y) \u21d2 event endAuthHU (U, x, y)\nevent endAuthS (U, x, y) \u21d2 event endAuthH (U, S, x, y)\nevent endAuthS (U, x, y) \u21d2 event partAuthU (x, y).\nThe first of these queries captures the statement of Theorem 1.\n16\n\n\fWith respect to key secrecy: In QUMTS , when the process for the honest serving network\ncompletes a run in the UMTS AKA with H and an honest user U , then it stores the session keys\nreceived from H in keyS1 and keyS2, respectively. CryptoVerif can prove the one-session secrecy\nqueries secret1 keyS1 and secret1 keyS2 automatically.\nThe proof for Theorems 1, 2 & 3 takes 44 game transformations for CryptoVerif using the\ncommands\n1.\n2.\n3.\n4.\n5.\n6.\n\nauto\nSArename RAND 255;\nSArename @22 r2 272;\nSArename @22 r2 270;\nmove array @22 r2 493;\nsuccess.\n\u2293\n\u2294\n\nResults for LTE AKA For LTE AKA we can prove the following.\nTheorem 4 (Authentication of core network to User Equipment). In the LTE AKA, if\nthere is an instance of\n\u2013 an honest user U receiving a value RAND \u2032\u2032 as nonce in a user authentication request and\ngenerates with it and the key shared with home network H a response RES \u2032\u2032\nthen, with overwhelming probability, there is an instance of\n\u2013 the home network H completing a run of the LTE AKA for serving network S and user U\n\u2013 in which H generated a nonce RAND and an expected response XRES , where RAND equals\nRAND \u2032\u2032 and XRES equals RES \u2032\u2032 .\nAgain, as for UMTS AKA, the LTE AKA itself does not offer authentication of the serving network\nto the user, but we can only show that a serving network that a user equipment communicates\nwith has been authorized by the home network.\nTheorem 5 (Entity Authentication of User Equipment to Serving Network). In the\nLTE AKA, if there is an instance of\n\u2013 an honest serving network S completing a run of the LTE AKA with honest user equipment\nU and home network H\n\u2013 in which S received a value RAND \u2032 as nonce and a value XRES \u2032 as expected response from\nH in a authentication data response\n\u2013 and in which S received a value RES \u2032 as response in a user authentication response that equals\nXRES \u2032\nthen, with overwhelming probability, there is an instance of\n\u2013 H completing a data authentication transfer with S\n\u2013 in which H generated a nonce RAND and an expected response XRES for the use between S\nand U , where RAND \u2032 equals RAND and XRES \u2032 equals XRES\nand an instance of\n\u2013 U completing a run of the LTE AKA\n\u2013 in which U received a value RAND \u2032\u2032 as nonce in an user authentication request that is equal\nto RAND \u2032\n\u2013 and in which U sent a response RES \u2032\u2032 that equals XRES \u2032 .\nAs for UMTS AKA, the LTE AKA itself does not offer authentication of the serving network\nto the user, therefore we cannot show key secrecy for the session key held by the honest user. But\nwe can again show secrecy for the session key of the serving network.\n17\n\n\fTheorem 6 (Key Secrecy in LTE AKA). Let QLTE be the game in CryptoVerifs process\ncalculus formalizing the LTE AKA. Furthermore, let keyS denote in QLTE the session key KASME\nreceived by an honest serving network from the home network and generated by the home network\nfor the use between the serving network and an honest user. Then QLTE preserve the one-session\nsecrecy of keyS.\nProof (for Theorems 4, 5 & 6). The proof is analogous to the proof of Theorems 1, 2 & 3, using\nthe commands\n1.\n2.\n3.\n4.\n5.\n6.\n\nauto\nSArename RAND 275;\nSArename @22 r2 292;\nSArename @22 r2 290;\nmove array @22 r2 2150;\nsuccess.\n\nCryptoVerif needs 57 transformations.\n\n\u2293\n\u2294\n\nUnlike UMTS AKA, the LTE is designed to offer also authentication of S to U . For this reason\nthe session key KASME is generated using S's identity. Nevertheless, the authentication guarantee\nis not explicitly established in LTE AKA itself but should hold after the next message sent by S\nto U , i.e. the first message of the exchange called NAS Security Mode Command Procedure (NAS\nSMC) in [9]. This exchange uses KASME 12 as key for a message authentication code. Recall from\nSection 2.2, that we denote the LTE AKA with the additional first message of the NAS SMC by\nLTE AKA+1. For LTE AKA+1, we can show, in addition to Theorem 4 and 5, the following.\nTheorem 7 (Entity Authentication of Serving Network to user equipment). In the LTE\nAKA+1, if there is an instance of\n\u2013 an honest user equipment U completing a run of the LTE AKA+1 with honest serving network\nS and home network H\n\u2013 in which U received a value RAND \u2032\u2032 as nonce in an user authentication request and derived a\n\u2032\u2032\nkey seed KASME\n\u2013 and in which U verified a valid message authentication code on a received message using the\n\u2032\u2032\nkey generated from KASME\nthen, with overwhelming probability, there is an instance of\n\u2013 H completing a data authentication transfer with S\n\u2013 in which H generated a nonce RAND and derived a key seed KASME for the use between S\n\u2032\u2032\nand U , where RAND \u2032\u2032 equals RAND and KASME\nequals KASME\nand an instance of\n\u2013 S completing a run of the LTE AKA+1\n\u2013 in which S received a value RAND \u2032 as nonce from H that is equal to RAND \u2032\u2032 and derived a\n\u2032\n\u2032\u2032\nkey seed KASME\nthat equals KASME\n\u2013 and in which S sent out a NAS security mode command message with a message authentication\n\u2032\ncode under the key generated from KASME\n.\nProof (of Theorem 7). In the CryptoVerif process that formalizes the LTE AKA+1, when the\nprocess for honest user equipment U completes a run of the AKA+1 protocol, it executes an\n\u2032\u2032\nevent endAuthU1 (hostS , RAND \u2032\u2032 , KASME\n) that contains the name hostS of the serving network\nthat supposedly participated in the same run, a nonce RAND \u2032\u2032 that U received together with a\n\u2032\u2032\nvalid MAC produced with a key kuh shared between U and H, and a mac key seed KASME\nthat\n\u2032\u2032\nU derived from inputs including RAND , the name hostS and a key shared between U and H.\n12\n\nin our model a key generated from KASME\n\n18\n\n\fWhen the process for H completes a run of the authentication data transfer it executes an event\nendAuthH1 (h2, h1, RAND, KASME ) that contains the name of a registered serving network h1\nfrom whom it received a request, the name h2 of a registered user equipment U , a random nonce\nRAND generated by H, and a key seed KASME derived by H from inputs including RAND, the\nname h1 and a key shared between H and h2. We can show with CryptoVerif the correspondence\nqueries\nevent endAuthU1 (S, x, y) \u21d2 event endAuthS1 (U, x, y)\nevent endAuthU1 (S, x, y) \u21d2 event endAuthH1 (U, S, x, y).\nWe can show the queries with CryptooVerif automatically in 60 game transformations.\n\n\u2293\n\u2294\n\nRemark 1. Although LTE AKA+1 satisfies authentication of S to U , the session key that U holds\nat the end of a completed session is still not computationally secret. The reason in this case is the\nfollowing: (a key derived from) this session key is used during the session for generating a message\nauthentication code. This allows an attacker to distinguish the key easily. Given a challenge key,\nthe attacker just tries to verify this message authentication code with the challenge key. If the\nverification is successful, then the attacker guesses that the challenge key equals the session key, else\nthe challenge key must be random key. Thus, the attacker has a overwhelming success probability\nin distinguishing U 's session key. Moreover, for the same reason any session key that honest serving\nnetwork S holds at the end of a completed run does also not satisfy one-session secrecy, i.e. the\nresult from Theorem 6 does not hold for LTE AKA+1.\n\n5\n\nConclusions and Future Work\n\nWe present the first computational security analysis of the Authentication and Key Agreement\nof UMTS and LTE, where we consider entity authentication and key secrecy properties while\ntaking into account the carrying protocols within the core network. The analysis uncovers a flaw\nin the specifications of UMTS and LTE AKA and the network domain security with rather serious\nconsequences. An outside attacker can defeat entity authentication of the user equipments to the\nserving networks. And an inside attacker can authenticate as another honest subscriber to a serving\nnetwork and use the wireless services on his behalf. Previous published analyses of UMTS AKA\nwere working in a purely symbolic model and did not catch the attacks because they generally\nmade too strong assumptions on the connection between serving network and home network.\nThe attacks can be prevented if the carrying protocols use unique integrity-protected session\nidentifiers in the communication between serving and home network. In practice, UMTS AKA is\nvulnerable if it is run over MAP and MAPsec, as the session identifiers are not integrity-protected,\nwhile UMTS and LTE AKA run over the Diameter protocol and IPsec are secure. We use the tool\nCryptoVerif to verify entity authentication properties and key secrecy properties with respect to\nthe computational model for the UMTS and LTE AKA protocols when unique session IDs and\nauthenticated encryption in the core network are used.\nWe question whether it is prudent practice to make the security of the UMTS/LTE AKA\nprotocol (or, in fact, any other cryptographic protocol) reliant on the carrying protocols and their\nprotection without considering the security of the combined protocol. Instead we believe that it\nwould be much more desirable to directly consider the combination of AKA with carrying protocol\nand its protection. The UMTS/LTE AKA protocols should ideally be strengthened by making the\nbinding of H's authentication data response for an intended U explicit in the AKA specifications\nand by explicitly requiring that authenticated encryption is used to protect the connection between\nserving and home network. Moreover, the specifications [4] and [9] of UMTS/LTE AKA need to\nbe revised so that the desired security properties on all connections are explicitly stated. This is\nalso important for intra-domain connections, where operators are free to implement proprietary\nsolutions and may currently miss to implement or sufficiently protect mechnisms for the serving\nnetwork to correctly match the authentication data responses, even if their implementation is\nguided by the specifications of the security architecture [4,9].\n19\n\n\fWe are interested in further exploring to what extend real-world systems are vulnerable to\nour attack, which, e.g., also depends on how widely MAPsec or TCAPsec with short transaction\nidentifiers are deployed in practice. We would also like to expand our analysis to scenarios of the\nprotocol execution that are not covered in the present work, e.g. the scenarios that are related\nto the use of TMSIs, and include the usage of the sequence number in order to verify stronger\nauthentication properties than entity authentication. Moreover, it would be interesting to verify\nunder which conditions the specified MILENAGE algorithms and the key derivation algorithm\nsatisfy the computational assumptions made in this work.\nAcknowledgements We thank Valtteri Niemi and Steve Babbage for helpful discussions on the\nfeasibility of the session-mixup attack. And we thank Bruno Blanchet for helping to automate the\nproofs for entity authentication of the user to the serving network.\n\nReferences\n1. 3GPP\nTR\n33.902\nversion\n4.0.0.\nUniversal\nmobile\ntelecommunications\nsystem\n(umts);\n3g\nsecurity;\nformal\nanalysis\nof\nthe\n3g\nauthentication\nprotocol.\nhttp://www.3gpp.org/ftp/Specs/html-info/33902.htm.\n2. 3GPP TS 29.002 version 10.5.0. Digital cellular telecommunications system (phase 2+); universal mobile telecommunications system (umts); mobile application part (map) specification.\nhttp://www.3gpp.org/ftp/Specs/html-info/29002.htm.\n3. 3GPP TS 29.272 version 10.6.0. Universal mobile telecommunications system (umts); lte; evolved\npacket system (eps); mobility management entity (mme) and serving gprs support node (sgsn) related\ninterfaces based on diameter protocol. http://www.3gpp.org/ftp/Specs/html-info/29272.htm.\n4. 3GPP TS 33.102 version 11.4.0. Universal mobile telecommunications system (umts); lte; 3g security;\nsecurity architecture. http://www.3gpp.org/ftp/Specs/html-info/33102.htm.\n5. 3GPP TS 33.200 version 7.0.0. Universal mobile telecommunications system (umts); 3g security; network domain security (nds); mobile application part (map) application layer security.\nhttp://www.3gpp.org/ftp/Specs/html-info/33200.htm.\n6. 3GPP TS 33.204 version 10.0.0.\nDigital cellular telecommunications system (phase\n2+); universal mobile telecommunications system (umts); lte; 3g security; network domain security (nds); transaction capabilities application part (tcap) user security.\nhtpp://www.3gpp.org/ftp/Specs/html-info/33204.htm.\n7. 3GPP TS 33.210 version 10.3.0. Digital cellular telecommunications system (phase 2+); universal\nmobile telecommunications system (umts); lte; 3g security; network domain security (nds); ip network\nlayer security. http://www.3gpp.org/ftp/Specs/html-info/33210.htm.\n8. 3GPP\nTS\n33.310\nversion\n10.5.0.\nUniversal\nmobile\ntelecommunications\nsystem (umts); lte; network domain security (nds); authentication framework (af).\nhttp://www.3gpp.org/ftp/Specs/html-info/33310.htm.\n9. 3GPP TS 33.401 version 10.2.0. Digital cellular telecommunications system (phase 2+); universal\nmobile telecommunications system (umts); lte; 3gpp system architecture evolution (sae); security\narchitecture. http://www.3gpp.org/ftp/Specs/html-info/33401.htm.\n10. 3GPP TS 35.206 version 10.0.0. niversal mobile telecommunications system (umts); lte; 3g security;\nspecification of the milenage algorithm set: An example algorithm set for the 3gpp authentication\nand key generation functions f1, f1*, f2, f3, f4, f5 and f5*; document 2: Algorithm specification.\nhttp://www.3gpp.org/ftp/Specs/html-info/35206.htm.\n11. 3GPP TS 42.009 version 4.1.0. Digital cellular telecommunications system (phase 2+); security aspects. http://www.3gpp.org/ftp/Specs/html-info/42009.htm.\n12. 3GPP TS 43.020 version 10.1.0. Digital cellular telecommunications system (phase 2+); security\nrelated network functions. http://www.3gpp.org/ftp/Specs/html-info/43020.htm.\n13. M. Abdalla, P.-A. Fouque, and D. Pointcheval. Password-based authenticated key exchange in the\nthree-party setting. In Public Key Cryptography, pages 65\u201384, 2005.\n14. M. Arapinis, L. I. Mancini, E. Ritter, and M. Ryan. Formal analysis of umts privacy. CoRR,\nabs/1109.2066, 2011. http://arxiv.org/abs/1109.2066.\n15. A. Armando et al. The Avispa tool for the automated validation of internet security protocols and\napplications. In International Conference on Computer Aided Verification, CAV 2005, volume 3576\nof LNCS. Springer, 2005.\n\n20\n\n\f16. M. Backes, B. Pfitzmann, and M. Waidner. A composable cryptographic library with nested operations\n(extended abstract). In Proc. CCS'03, pages 220\u2013230, 2003.\n17. G. Barthe, B. Gr\u00e9goire, S. Heraud, and S. Zanella B\u00e9guelin. Computer-aided security proofs for the\nworking cryptographer. In Advances in Cryptology \u2013 CRYPTO 2011, volume 6841 of Lecture Notes\nin Computer Science, pages 71\u201390. Springer, 2011.\n18. G. Bella and L. C. Paulson. Using Isabelle to Prove Properties of the Kerberos Authentication System.\nIn DIMACS'97, Workshop on Design and Formal Verification of Security Protocols (CD-ROM), 1997.\n19. M. Bellare and C. Namprempre. Authenticated Encryption: Relations among notions and analysis\nof the generic composition paradigm. In ASIACRYPT 2000, volume 1976 of LNCS, pages 531\u2013545.\nSpringer Verlag, December 2000.\n20. M.\nBellare\nand\nP.\nRogaway.\nIntroduction\nto\nmodern\ncryptography.\nhttp://cseweb.ucsd.edu/~ mihir/cse207/classnotes.html.\n21. K. Bhargavan, C. Fournet, R. Corin, and E. Zalinescu. Cryptographically verified implementations\nfor tls. In Proceedings of the 15th ACM conference on Computer and communications security, CCS\n'08, pages 459\u2013468, New York, NY, USA, 2008. ACM.\n22. B. Blanchet. An Efficient Cryptographic Protocol Verifier Based on Prolog Rules. In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82\u201396, Cape Breton, Nova Scotia, Canada,\nJune 2001. IEEE Computer Society.\n23. B. Blanchet. A Computationally Sound Mechanized Prover for Security Protocols. In IEEE Symposium on Security and Privacy, pages 140\u2013154, May 2006.\n24. B. Blanchet. Computationally Sound Mechanized Proofs of Correspondence Assertions. In CSF 2007,\npages 97\u2013111, July 2007.\n25. B. Blanchet. A computationally sound mechanized prover for security protocols. IEEE Transactions\non Dependable and Secure Computing, 2007.\n26. B. Blanchet, A. D. Jaggard, A. Scedrov, and J.-K. Tsay. Computationally sound mechanized proofs\nfor basic and public-key kerberos. In ASIACCS, pages 87\u201399, 2008.\n27. B. Blanchet and D. Pointcheval. Automated Security Proofs with Sequences of Games. In CRYPTO\n2006, volume 4117 of LNCS, pages 537\u2013554. Springer Verlag, Aug. 2006.\n28. R. Canetti and J. Herzog. Universally composable symbolic analysis of cryptographic protocols (the\ncase of encryption-based mutual authentication and key exchange). In Proc. 3rd Theory of Cryptography Conference (TCC), 2006.\n29. I. Cervesato, A. D. Jaggard, A. Scedrov, J.-K. Tsay, and C. Walstad. Breaking and fixing public-key\nKerberos. Information and Computation, FCS-ARSPA'06 Special Issue:402 \u2013 424, 2008.\n30. H. Comon-Lundh, M. Hagiya, Y. Kawamoto, and H. Sakurada. Computational soundness of indistinguishability properties without computable parsing. In Proc. of the 8th International Conference\non Information Security Practice and Experience (ISPEC 2012), volume 7232 of Lecture Notes in\nComputer Science, pages 63\u201379, 2012.\n31. V. Cortier, S. Kremer, and B. Warinschi. A survey of symbolic methods in computational analysis of\ncryptographic systems. Journal of Automated Reasoning, 46(3-4):225\u2013259, Apr. 2010.\n32. C. Cremers. Scyther - Semantics and Verification of Security Protocols. Ph.D. dissertation, Eindhoven\nUniversity of Technology, 2006.\n33. A. Datta, A. Derek, J. C. Mitchell, and B. Warinschi. Computationally Sound Compositional Logic\nfor Key Exchange Protocols. In CSFW -18, pages 321 \u2013 334. IEEE Press, 2006.\n34. D. Dolev and A. Yao. On the security of public-key protocols. IEEE Trans. Info. Theory, 2(29):198\u2013\n208, 1983.\n35. S. Goldwasser and S. Micali. Probabilistic encryption and how to play mental poker keeping secret\nall partial information. In Proc. of 14th Annual Symp. Theory of Computing, pages 365\u2013377. ACM,\n1982.\n36. S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences,\n28:270\u2013299, 1984.\n37. IETF. Diameter base protocol, rfc 3588, September 2003. http://www.ietf.org/rfc/rfc3588.txt.\n38. IETF.\nExtensible\nauthentication\nprotocol\n(eap)\nrfc\n3748,\nJune\n2004.\nhttp://www.ietf.org/rfc/rfc3748.txt.\n39. IETF. Extensible authentication protocol method for 3rd generation authentication and key agreement\n(eap-aka) rfc 4187, January 2006. http://www.ietf.org/rfc/rfc4187.txt.\n40. International\nTelecom\nUnion.\nICT\nindication\ndatabase,\n2011.\nhttp://www.itu.int/ITU-D/ict/statistics/.\n41. ITU-T Recommendation Q.771. Specifications of signalling system no.7; functional description of\ntransaction capabilities. http://www.itu.int/rec/T-REC-Q.771-199706-I/en.\n\n21\n\n\f42. ITU-T Recommendation Q.772. Specifications of signalling system no.7; transaction capabilities information element definitions. http://www.itu.int/rec/T-REC-Q.772-199706-I/en.\n43. ITU-T Recommendation Q.773. Specifications of signalling system no.7; transaction capabilities formats and encoding. http://www.itu.int/rec/T-REC-Q.773-199706-I/en.\n44. ITU-T Recommendation Q.774. Specifications of signalling system no.7; transaction capabilities procedures. http://www.itu.int/rec/T-REC-Q.774-199706-I/en.\n45. ITU-T Recommendation Q.775. Specifications of signalling system no.7; guide-lines for using transaction capabilities. http://www.itu.int/rec/T-REC-Q.775-199706-I/en.\n46. P. Laud. Secrecy Types for a Simulatable Cryptographic Library. In CCS 2005, pages 71\u201385, May\n2005.\n47. G. Lowe. An Attack on the Needham-Schroeder Public-Key Authentication Protocol. Info. Proc.\nLett., 56(3):131\u2013133, 1995.\n48. C. Meadows. Analysis of the internet key exchange protocol using the NRL Protocol Analyzer. In\nProc. IEEE Symp. Security and Privacy, pages 216\u2013231, 1999.\n49. C. A. Meadows. The NRL protocol analyzer: An overview. Journal of Logic Programming, 26(2),\n1996.\n50. U. Meyer and S. Wetzel. A man-in-the-middle attack on umts. In Proceedings of the 3rd ACM\nworkshop on Wireless security, WiSe '04, pages 90\u201397, New York, NY, USA, 2004. ACM.\n51. J. Mitchell, A. Ramathan, A. Scedrov, and V. Teague. A Probabilistic Polynomial-Time Process\nCalculus for the Analysis of Cryptographic Protocols. Theoretical Computer Science, 353(1\u20133):118\u2013\n164, 2006.\n52. J. C. Mitchell, V. Shmatikov, and U. Stern. Finite-State Analysis of SSL 3.0. In Proc. 7th USENIX\nSecurity Symp., pages 201\u2013216, 1998.\n53. V. Shoup. Sequences of games: a tool for taming complexity in security proofs. Cryptology ePrint\nArchive, Report 2004/332, 2004. http://eprint.iacr.org/.\n54. C. Tang, D. A. Naumann, and S. Wetzel. Symbolic analysis for security of roaming protocols in\nmobile networks - [extended abstract]. In 7th International ICST Conference on Security and Privacy\nin Communication Networks (SecureComm 2011), pages 480\u2013490, 2011.\n55. M. Zhang and Y. Fang. Security analysis and enhancements of 3gpp authentication and key agreement\nprotocol. IEEE Transactions on Wireless Communications, 4(2):734\u2013742, 2005.\n\nA\n\nLTE AKA in CryptoVerif\n\nWe present, in Figures 7 \u2013 13, additional parts of the input scripts to CryptoVerif used in our\nanalysis of LTE AKA and LTE AKA+1, which we believe are sufficient to understand the modeling\nof the protocol and the explanations of the proofs in this paper. Please see the CryptoVerif manual,\nwhich ships with the tool downloadable at http://www.cryptoverif.ens.fr/, for further detail\non the syntax of the input language.\nNotation ue, sn and hn denote the types of, respectively, user equipments, serving networks\nand home networks. mkeyseed, mkey and macs denote the types of, respectively, inputs to the\nkey generator, keys, and outputs of the message authentication code (which is used for protection\nof the communication between serving network and home network). Similarly, keyseed, key and\nseed denote the types of, respectively, inputs to the key generator, keys and random seeds used by\nthe probabilistic encryption scheme (which ist used for protection of the communication between\nserving network and home network); the cleartexts and ciphertexts of the encryption scheme\nare of type bitstring. prfkeyseed, prfkey and prft denote the types of, respectively, inputs to the\nkey generator, keys and outputs of the pseudo-random function (which is used as key derivation\nfunction). prpckeyseed, prpckey and prpcblocksize denote the types of, respectively, inputs to the\nkey generator, keys and outputs of the pseudo-random permutation block cipher (which is used\nfor the functions f1 , . . . , f4 ). And econst denotes the type of constants that are used as input to\nthe prp block cipher in order to distinguish its usage as f1 , . . . , or f4 .\nkgen, enc and dec comprise the encryption scheme used to protect messages between serving\nnetwork and home network. i\u22a5 is the natural injection from the set of cleartexts to bitstring \u222a \u22a5\n(needed as decryption may fail). The patterns concatj for j \u2208 {1, . . . , 9} are used to wrap messages\n22\n\n\fof different formats so that they can be taken as input of a function, e.g. the encryption function. mkgen, mac and check comprise the message authentication code used to protect messages\nbetween serving network and home network. prpcenc and prpckgen denote the pseudo-random\npermutation block cipher and its key generation function used to model the functions f1 , . . . , f4 .\nprf and prfkgen denote the pseudo-random function and its key generation function used to model\nthe key derivation function.\nOtherwise the scripts follow the syntax as presented in Figure 5. Please contemplate the full\ninput scripts and CryptoVerif's manual for the exact type declarations and exact function declaration/expansion. The main process is given in Figure 13, which is equal for LTE AKA and\nLTE AKA+1 up to the different sub processes for user equipment and serving network. Before\nexecuting the processes for user equipment, serving network and home network in parallel, the\nmain process first generates values, e.g. key material, on which the adversary has a priori no\ninformation. The two processes presented in Figures 10 and 11 allow the adversary to register\nwith the home network as, respectively, serving network or user equipment (as needed for inside\nattacks). They are used by the home network H to look up long-term keys shared between H and\na serving network or a user equipment.\nQS = !iS \u2264NS c3 [iS ](h : ue, hostS \u2032 : sn);\nif hostS \u2032 = S then\nnew r1 : seed ;\nlet e1 = enc(concat2 (h, S), Ksh, r1 ) in\nc4 [iS ]hS, e1 , mac(e1 , mKsh)i;\nc9 [iS ](e\u20324 : bitstring , mac\u20324 : macs);\nif check(e\u20324 , mKsh, mac\u20324 ) then\n\u2032\nlet i\u22a5 (concat7 (= h, KASME\n, RAND \u2032 , XRES \u2032 , SQN \u2032 , MAC \u2032 )) = dec(e\u20324 , Ksh) in\nc10 [iS ]hRAND \u2032 , SQN \u2032 , MAC \u2032 i;\nc13 [iS ](RES \u2032 : prpcblocksize );\nif XRES \u2032 = RES \u2032 then\nevent endAuthS (h, RAND \u2032 , RES \u2032 );\nif h = U then\n(\n\u2032\nlet keyS : mkeyseed = KASME\n)\n\u2032\ni.\nelse cend 2 [iS ]hKASME\nFig. 7. CryptoVerif formalization of serving network (eNB/MME) actions in LTE AKA\n\nB\n\nGSM Authentication Protocol\n\nThe GSM Subscriber Identity Authentication protocol is depicted in Figure 14 and can be regarded\nas the 2G predecessor of the UMTS AKA protocol. When the home network H receives a security\ninformation request for U , then H looks up the individual subscriber authentication key K0 that it\nshares with U and generates the authentication vector response by generating a random RAND and\nby computing the signed response SRES . The authentication algorithm A3 and the ciphering key\ngenerating algorithm A8 fulfill similar tasks as, respectively, f2 and f3 /f4 /KDF for UMTS/LTE\nAKA.\nThe GSM SIA is specified in [12,11] and depicted in Figure 14 in Appendix B. This protocol\nsuffers from the same underspecification as UMTS and LTE AKA: there is no proper binding of\nthe response from the home network (called Authentication Vector Response) to the corresponding\nrequest or user. Therefore, both attacks of Figures 3 and 2 could also be deployed against GSM\nSIA. However, the case of GSM SIA is different from the case UMTS/LTE AKA. In the GSM\n23\n\n\fiU \u2264NU\nQ+\nc1 [iU ](hostS : sn);\nU = !\nc2 [iU ]hU, hostS i;\nc11 [iC ](RAND \u2032\u2032 : nonce, = SQN , MAC \u2032\u2032 : blocksize);\nlet MAC \u2032\u2032\u2032 = prpcenc(concat1 (const 1 , SQN , RAND), prpKuh) in\nif MAC \u2032\u2032\u2032 = MAC \u2032\u2032 then\nlet RES \u2032\u2032 = prpcenc(concat2 (const 2 , RAND), prpKuh) in\nlet CK \u2032\u2032 = prpcenc(concat2 (const 3 , RAND), prpKuh) in\nlet IK \u2032\u2032 = prpcenc(concat2 (const 4 , RAND), prpKuh) in\n\u2032\u2032\nlet KASME\n= prf(prfKuh, concat3 (SQN , CK \u2032\u2032 , IK \u2032\u2032 , hostS ))\nevent partAuthU (RAND \u2032\u2032 , RES \u2032\u2032 );\nc12 [iU ]hRES \u2032\u2032 i;\nc15 [iU ](= NASsma, mac 6 : macs);\n\u2032\u2032\nlet mKNAS \u2032\u2032 = mkgen(KASME\n) in\nif check(NASsma, mKNAS \u2032\u2032 , mac 6 ) then\nif hostS = S then\n\u2032\u2032\nevent endAuthU 1(hostS , RAND \u2032\u2032 , KASME\n).\n\nFig. 8. CryptoVerif formalization of user equipment actions in LTE AKA+1, where NASsma is considered\nto be a non-secret constant\n\niS \u2264NS\nQ+\nc3 [iS ](h : ue, hostS \u2032 : sn);\nS = !\nif hostS \u2032 = S then\nnew r1 : seed ;\nlet e1 = enc(concat2 (h, S), Ksh, r1 ) in\nc4 [iS ]hS, e1 , mac(e1 , mKsh)i;\nc9 [iS ](e\u20324 : bitstring , mac\u20324 : macs);\nif check(e\u20324 , mKsh, mac\u20324 ) then\n\u2032\nlet i\u22a5 (concat7 (= h, KASME\n, RAND \u2032 , XRES \u2032 , SQN \u2032 , MAC \u2032 )) = dec(e\u20324 , Ksh) in\n\u2032\n\u2032\nc10 [iS ]hRAND , SQN , MAC \u2032 i;\nc13 [iS ](RES \u2032 : prpcblocksize );\nif XRES \u2032 = RES \u2032 then\n\u2032\nlet mKNAS \u2032 = mkgen(KASME\n) in\n\u2032\nevent (endAuthS1 (h, RAND \u2032 , KASME\n).\nc14 [iS ]hNASsma, mac(NASsma, mKNAS \u2032 )i.\n\nFig. 9. CryptoVerif formalization of serving network (eNB/MME) actions in LTE AKA+1, where NASsma\nis considered to be a non-secret constant\n\nQK = !iK \u2264N2 c6 [iK ](Khost : sn, Kkey : key, Kmkey : mkey);\nletRkey : key =\nif Khost = S thenKsh else\nKkey\nin\nlet Rmkey : mkey =\nif Khost = S then mKsh else\nKmkey.\nFig. 10. CryptoVerif formalization of the process for registering long-term keys shared between honest\nhome network and possibly dishonest serving networks in LTE AKA and LTE AKA+1\n\n24\n\n\fQL = !iL \u2264N2 c7 [iL ](Lhost : ue, Lkey : prpckey , Lprfkey : prfkey);\nletUkey : prpckey =\nif Lhost = U thenprpckuh else\nLkey\nin\nlet Uprfkey : prfkey =\nif Lhost = U then prfKuh else\nLprfkey .\nFig. 11. CryptoVerif formalization of the process for registering long-term keys shared between honest\nhome network and possibly dishonest user equipments in LTE AKA and LTE AKA+1\nQH = !iS \u2264NH c5 [iH ](h1 : sn, e\u20321 : bitstring , mac \u2032 1 : macs);\nfind j1 \u2264 N2 suchthat defined(Khost [j1 ], Rmkey[j1 ], Rkey[j1 ]) \u2227 (Khost [j1 ] = h1 ) then\nif check(e\u20321 , Rmkey[j1 ], mac \u2032 1 ) then\nlet i\u22a5 (concat2 (h2 , = h1 )) = dec(e\u20321 , Rkey [j1 ]) in\nfind j2 \u2264 N2 suchthat defined(Lhost [j2 ], Ukey[j2 ], Uprfkey [j2 ]) \u2227 (Lhost [j2 ] = h2 ) then\nnew RAND : nonce;\nlet MAC = prpcenc(concat8 (const 1 , SQN , RAND), Ukey [j2 ]) in\nlet XRES = prpcenc(concat9 (const 2 , RAND), Ukey[j2 ]) in\nlet CK = prpcenc(concat9 (const 3 , RAND), Ukey [j2 ]) in\nlet IK = prpcenc(concat9 (const 4 , RAND), Ukey[j2 ]) in\nlet KASME = f (Uprfkey [j2 ], concat6 (SQN , CK , IK , h1 )) in\nnew r2 : seed ;\nlet e2 = enc(concat7 (h2 , KASME , RAND, XRES , SQN , MAC ), Rkey[j1 ], r2 ) in\nevent endAuthHU (h2 , RAND, XRES );\nevent endAuthH(h2 , h1 , RAND, XRES );\nevent endAuthH1(h2 , h1 , RAND, KASME );\nc8 [iH ]he2 , mac(e2 , Rmkey[j1 ])i.\nFig. 12. CryptoVerif formalization of home network (HSS/AuC) actions in LTE AKA and LTE AKA+1\nmain = !i\u2264N cstart ();\nnew rKuh : keyseed ;\nlet Kuh = kgen(rKuh) in\nnew rmKuh : mkeyseed ;\nlet mKuh = mkgen(rmKuh) in\nnew r0Kuh : prfkeyseed ;\nlet prfKuh = prfkgen(r0Kuh) in\nnew rprpcKuh : prpckeyseed ;\nlet prpcKuh = prpckgen(rprpcKuh ) in\nnew rKas : keyseed ;\nlet Kas = kgen(rKas) in\nnew rmKas : mkeyseed ;\nlet mKas = mkgen(rmKas) in\nnew rKsh : keyseed ;\nlet Ksh = kgen(rKsh) in\nnew rmKsh : mkeyseed ;\nlet mKsh = mkgen(rmKsh) in\nnew SQN : nonce;\ncstart hi\n(Q\u2217U |Q\u2217S |QH |QK |QL )\nFig. 13. CryptoVerif formalization of the main process, i.e. game G0 , in LTE AKA and LTE AKA+1,\n+\n\u2217\nwhere, respectively, Q\u2217U = QU , Q\u2217S = QS and Q\u2217U = Q+\nU , QS = QS\n\n25\n\n\fU\n\nS\n\nH\n\nIMSI , K0\n\nSNid\n\n{IMSI i , Ki }i\n\nid request\nIMSI\n\nsecurity related\ninformation request\nIMSI , SNid\nnew RAND\nSRES \u2190 A3,K (RAND )\n0\nSkey \u2190 A8,K (RAND )\n0\n\nauth vector response\nRAND, SRES , Skey\nRAND\nRES \u2190 A3,K (RAND )\n0\n\nRES\n?\nRES = SRES\n\nFig. 14. The GSM Subscriber Identity Authentication Protocol.\n\nSIA case, the specifications [12,11] are only concerned about adversaries that attack the radio\npath, i.e. the connection between user equipment and base stations, while completely neglecting\nother connections, including the connection between serving and home network. So it does not\nviolate the specifications even if there is no protection of the authentication vector response and\nthe session key is transmitted in the clear from the home to the serving network. An attacker that\nis able to listen on the connections within the core network does not need to resort to the sessionmixup attack to successfully violate GSM security. We warn, however, that any GSM operators\nthat would like to protect the connection between home and serving networks need to correct the\nGSM SIA protocol.\n\n26\n\n\f"}