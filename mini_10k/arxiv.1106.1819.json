{"id": "http://arxiv.org/abs/1106.1819v1", "guidislink": true, "updated": "2011-06-09T13:56:25Z", "updated_parsed": [2011, 6, 9, 13, 56, 25, 3, 160, 0], "published": "2011-06-09T13:56:25Z", "published_parsed": [2011, 6, 9, 13, 56, 25, 3, 160, 0], "title": "A Knowledge Compilation Map", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1106.6057%2C1106.3618%2C1106.4198%2C1106.2580%2C1106.5789%2C1106.0528%2C1106.6127%2C1106.3872%2C1106.2371%2C1106.0063%2C1106.4467%2C1106.1046%2C1106.0317%2C1106.5964%2C1106.2345%2C1106.3360%2C1106.4377%2C1106.2378%2C1106.0379%2C1106.0013%2C1106.5070%2C1106.5899%2C1106.2337%2C1106.6263%2C1106.5904%2C1106.2639%2C1106.2145%2C1106.0867%2C1106.5344%2C1106.5617%2C1106.1982%2C1106.0782%2C1106.1352%2C1106.6290%2C1106.2831%2C1106.4965%2C1106.4651%2C1106.4583%2C1106.2952%2C1106.2077%2C1106.5377%2C1106.0055%2C1106.5744%2C1106.3871%2C1106.1611%2C1106.0579%2C1106.0318%2C1106.3419%2C1106.2257%2C1106.5468%2C1106.6308%2C1106.0996%2C1106.0556%2C1106.3449%2C1106.2242%2C1106.0337%2C1106.3754%2C1106.2688%2C1106.5234%2C1106.6097%2C1106.1771%2C1106.6171%2C1106.5536%2C1106.1732%2C1106.2050%2C1106.2912%2C1106.4824%2C1106.4751%2C1106.3649%2C1106.6288%2C1106.0777%2C1106.4678%2C1106.2880%2C1106.3495%2C1106.2637%2C1106.0273%2C1106.2108%2C1106.1283%2C1106.4387%2C1106.0417%2C1106.5423%2C1106.2466%2C1106.2045%2C1106.4988%2C1106.5453%2C1106.4787%2C1106.2900%2C1106.6124%2C1106.4633%2C1106.3177%2C1106.4382%2C1106.4104%2C1106.6048%2C1106.0175%2C1106.0648%2C1106.5838%2C1106.0663%2C1106.1029%2C1106.5621%2C1106.1819%2C1106.5221&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "A Knowledge Compilation Map"}, "summary": "We propose a perspective on knowledge compilation which calls for analyzing\ndifferent compilation approaches according to two key dimensions: the\nsuccinctness of the target compilation language, and the class of queries and\ntransformations that the language supports in polytime. We then provide a\nknowledge compilation map, which analyzes a large number of existing target\ncompilation languages according to their succinctness and their polytime\ntransformations and queries. We argue that such analysis is necessary for\nplacing new compilation approaches within the context of existing ones. We also\ngo beyond classical, flat target compilation languages based on CNF and DNF,\nand consider a richer, nested class based on directed acyclic graphs (such as\nOBDDs), which we show to include a relatively large number of target\ncompilation languages.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1106.6057%2C1106.3618%2C1106.4198%2C1106.2580%2C1106.5789%2C1106.0528%2C1106.6127%2C1106.3872%2C1106.2371%2C1106.0063%2C1106.4467%2C1106.1046%2C1106.0317%2C1106.5964%2C1106.2345%2C1106.3360%2C1106.4377%2C1106.2378%2C1106.0379%2C1106.0013%2C1106.5070%2C1106.5899%2C1106.2337%2C1106.6263%2C1106.5904%2C1106.2639%2C1106.2145%2C1106.0867%2C1106.5344%2C1106.5617%2C1106.1982%2C1106.0782%2C1106.1352%2C1106.6290%2C1106.2831%2C1106.4965%2C1106.4651%2C1106.4583%2C1106.2952%2C1106.2077%2C1106.5377%2C1106.0055%2C1106.5744%2C1106.3871%2C1106.1611%2C1106.0579%2C1106.0318%2C1106.3419%2C1106.2257%2C1106.5468%2C1106.6308%2C1106.0996%2C1106.0556%2C1106.3449%2C1106.2242%2C1106.0337%2C1106.3754%2C1106.2688%2C1106.5234%2C1106.6097%2C1106.1771%2C1106.6171%2C1106.5536%2C1106.1732%2C1106.2050%2C1106.2912%2C1106.4824%2C1106.4751%2C1106.3649%2C1106.6288%2C1106.0777%2C1106.4678%2C1106.2880%2C1106.3495%2C1106.2637%2C1106.0273%2C1106.2108%2C1106.1283%2C1106.4387%2C1106.0417%2C1106.5423%2C1106.2466%2C1106.2045%2C1106.4988%2C1106.5453%2C1106.4787%2C1106.2900%2C1106.6124%2C1106.4633%2C1106.3177%2C1106.4382%2C1106.4104%2C1106.6048%2C1106.0175%2C1106.0648%2C1106.5838%2C1106.0663%2C1106.1029%2C1106.5621%2C1106.1819%2C1106.5221&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We propose a perspective on knowledge compilation which calls for analyzing\ndifferent compilation approaches according to two key dimensions: the\nsuccinctness of the target compilation language, and the class of queries and\ntransformations that the language supports in polytime. We then provide a\nknowledge compilation map, which analyzes a large number of existing target\ncompilation languages according to their succinctness and their polytime\ntransformations and queries. We argue that such analysis is necessary for\nplacing new compilation approaches within the context of existing ones. We also\ngo beyond classical, flat target compilation languages based on CNF and DNF,\nand consider a richer, nested class based on directed acyclic graphs (such as\nOBDDs), which we show to include a relatively large number of target\ncompilation languages."}, "authors": ["A. Darwiche", "P. Marquis"], "author_detail": {"name": "P. Marquis"}, "author": "P. Marquis", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1613/jair.989", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1106.1819v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1106.1819v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1106.1819v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1106.1819v1", "arxiv_comment": null, "journal_reference": "Journal Of Artificial Intelligence Research, Volume 17, pages\n  229-264, 2002", "doi": "10.1613/jair.989", "fulltext": "Journal of Artificial Intelligence Research 17 (2002) 229-264\n\nSubmitted 12/01; published 9/02\n\nA Knowledge Compilation Map\nAdnan Darwiche\n\ndarwiche@cs.ucla.edu\n\nComputer Science Department\nUniversity of California, Los Angeles\nLos Angeles, CA 90095, USA\n\nPierre Marquis\n\nmarquis@cril.univ-artois.fr\n\nUniversit\u00e9 d'Artois\nF-62307, Lens Cedex, France\n\nAbstract\nWe propose a perspective on knowledge compilation which calls for analyzing different compilation approaches according to two key dimensions: the succinctness of the target compilation\nlanguage, and the class of queries and transformations that the language supports in polytime.\nWe then provide a knowledge compilation map, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and\nqueries. We argue that such analysis is necessary for placing new compilation approaches within\nthe context of existing ones. We also go beyond classical, flat target compilation languages based\non CNF and DNF, and consider a richer, nested class based on directed acyclic graphs (such as\nOBDDs), which we show to include a relatively large number of target compilation languages.\n\n1. Introduction\nKnowledge compilation has emerged recently as a key direction of research for dealing with the\ncomputational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini,\n1997; Boufkhad, Gr\u00e9goire, Marquis, Mazure, & Sa\u0131\u0308s, 1997; Khardon & Roth, 1997; Selman &\nKautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de\nKleer, 1987). According to this direction, a propositional theory is compiled off-line into a target\nlanguage, which is then used on-line to answer a large number of queries in polytime. The key\nmotivation behind knowledge compilation is to push as much of the computational overhead into\nthe off-line phase, which is amortized over all on-line queries. But knowledge compilation can serve\nother important purposes as well. For example, target compilation languages and their associated\nalgorithms can be very simple, allowing one to develop on-line reasoning systems for simple software\nand hardware platforms. Moreover, the simplicity of algorithms that operate on compiled languages\nhelp in streamlining the effort of algorithmic design into a single task: that of generating the smallest\ncompiled representations possible, as that turns out to be the main computational bottleneck in\ncompilation approaches.\nThere are three key aspects of any knowledge compilation approach: the succinctness of the\ntarget language into which the propositional theory is compiled; the class of queries that can be\nanswered in polytime based on the compiled representation; and the class of transformations that\ncan be applied to the representation in polytime. The AI literature has thus far focused mostly on\ntarget compilation languages which are variations on DNF and CNF formulas, such as Horn theories\nand prime implicates. Moreover, it has focused mostly on clausal entailment queries, with very little\ndiscussion of tractable transformations on compiled theories.\nThe goal of this paper is to provide a broad perspective on knowledge compilation by considering\na relatively large number of target compilation languages and analyzing them according to their\nsuccinctness and the class of queries/transformations that they admit in polytime.\n\nc\n\u00b02002\nAI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\n\n\fDarwiche & Marquis\n\nInstead of focusing on classical, flat target compilation languages based on CNF and DNF, we\nconsider a richer, nested class based on representing propositional sentences using directed acyclic\ngraphs, which we refer to as NNF. We identify a number of target compilation languages that have\nbeen presented in the AI, formal verification, and computer science literature and show that they\nare special cases of NNF. For each such class, we list the extra conditions that need to be imposed\non NNF to obtain the specific class, and then identify the set of queries and transformations that the\nclass supports in polytime. We also provide cross-rankings of the different subsets of NNF, according\nto their succinctness and the polytime operations they support.\nThe main contribution of this paper is then a map for deciding the target compilation language\nthat is most suitable for a particular application. Specifically, we propose that one starts by identifying the set of queries and transformations needed for their given application, and then choosing\nthe most succinct language that supports these operations in polytime.\nThis paper is structured as follows. We start by formally defining the NNF language in Section 2,\nwhere we list a number of conditions on NNF that give rise to a variety of target compilation languages.\nWe then study the succinctness of these languages in Section 3 and provide a cross-ranking that\ncompares them according to this measure. We consider a number of queries and their applications in\nSection 4 and compare the different target compilation languages according to their tractability with\nrespect to these queries. Section 5 is then dedicated to a class of transformations, their applications,\nand their tractability with respect to the different target compilation languages. We finally close in\nSection 6 by some concluding remarks. Proofs of all theorems are delegated to Appendix A.\n\n2. The NNF Language\nWe consider more than a dozen languages in this paper, all of which are subsets of the NNF language,\nwhich is defined formally as follows (Darwiche, 1999, 2001a).\nDefinition 2.1 Let PS be a denumerable set of propositional variables. A sentence in NNFP S is\na rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false, X or \u00acX,\nX \u2208 P S; and each internal node is labeled with \u2227 or \u2228 and can have arbitrarily many children.\nThe size of a sentence \u03a3 in NNFP S , denoted | \u03a3 |, is the number of its DAG edges. Its height is the\nmaximum number of edges from the root to some leaf in the DAG.\nFigure 1 depicts a sentence in NNF, which represents the odd parity function (we omit reference\nto variables PS when no confusion is anticipated). Any propositional sentence can be represented\nas a sentence in NNF, so the NNF language is complete.\nIt is important here to distinguish between a representation language and a target compilation\nlanguage. A representation language is one which we expect humans to read and write with some\nease. The language of CNF is a popular representation language, and so is the language of Horn\nclauses (especially when expressed in rules form). On other hand, a target compilation language does\nnot need to be suitable for human specification and interpretation, but should be tractable enough\nto permit a non-trivial number of polytime queries and/or transformations. We will consider a\nnumber of target compilation languages that do not qualify as representation languages from this\nperspective, as they are not suitable for humans to construct or interpret. We will also consider a\nnumber of representation languages that do not qualify as target compilation languages.1\nA formal characterization of representation languages is outside the scope of this paper. But for\na language to qualify as a target compilation language, we will require that it permits a polytime\nclausal entailment test. Note that a polytime consistency test is not sufficient here, as only one\nconsistency test on a given theory does not justify its compilation. Given this definition, NNF does\n1. It appears that when proposing target compilation languages in the AI literature, there is usually an implicit\nrequirement that the proposed language is also a representation language. As we shall see later, however, the\nmost powerful target compilation languages are not suitable for humans to specify or interpret directly.\n\n230\n\n\fA Knowledge Compilation Map\n\nDecomposability\n\n(a)\n\n(b)\n\nor\n\nor\n\nor\n\nand\nA,B\n\nSmoothness\n\n(c)\n\nDeterminism\n\nor\nand\n\nand\n\nC,D\n\nor\n\nor\n\nor\n\nor\n\nand\n\nand\nor\n\nor\n\nor\n\nor\n\nand\nor\n\nor\n\nor\n\nA,B\nA,B\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\nand\n\n\u00acA\n\nB\n\n\u00acB\n\nA\n\nC\n\n\u00acD\n\nD\n\n\u00acC\n\n\u00acA\n\nB\n\n\u00acB\n\nA\n\nC\n\n\u00acD\n\nD\n\n\u00acC\n\n\u00acA\n\nB\n\n\u00acB\n\nA\n\nC\n\n\u00acD\n\nD\n\n\u00acC\n\nFigure 1: A sentence in NNF. Its size is 30 and height is 4.\nnot qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its\nsubsets do. We define a number of these subsets below, each of which is obtained by imposing\nfurther conditions on NNF.\nWe will distinguish between two key subsets of NNF: flat and nested subsets. We first consider\nflat subsets, which result from imposing combinations of the following properties:\n\u2022 Flatness: The height of each sentence is at most 2. The sentence in Figure 3 is flat, but the\none in Figure 1 is not.\n\u2022 Simple-disjunction: The children of each or-node are leaves that share no variables (the\nnode is a clause).\n\u2022 Simple-conjunction: The children of each and-node are leaves that share no variables (the\nnode is a term). The sentence in Figure 3 satisfies this property.\nDefinition 2.2 The language f-NNF is the subset of NNF satisfying flatness. The language CNF is\nthe subset of f-NNF satisfying simple\u2013disjunction. The language DNF is the subset of f-NNF satisfying\nsimple\u2013conjunction.\nCNF does not permit a polytime clausal entailment test (unless P=NP) and, hence, does not qualify\nas a target compilation language. But its dual DNF does.\nThe following subset of CNF, prime implicates, has been quite influential in computer science:\nDefinition 2.3 The language PI is the subset of CNF in which each clause entailed by the sentence\nis subsumed by a clause that appears in the sentence; and no clause in the sentence is subsumed by\nanother.\nA dual of PI, prime implicants IP, can also be defined.\nDefinition 2.4 The language IP is the subset of DNF in which each term entailing the sentence\nsubsumes some term that appears in the sentence; and no term in the sentence is subsumed by\nanother term.\nThere has been some work on representing the set of prime implicates of a propositional theory in\na compact way, allowing an exponential number of prime implicates to be represented in polynomial\nspace in certain cases-see for example the TRIE representation in (de Kleer, 1992), the ZBDD\nrepresentation used in (Simon & del Val, 2001), and the implicit representation based on metaproducts, as proposed in (Madre & Coudert, 1992). These representations are different from the\nlanguage PI in the sense that they do not necessarily support the same queries and transformations\n231\n\n\fDarwiche & Marquis\n\nthat we report in Tables 5 and 7. They also exhibit different succinctness relationships than the\nones we report in Table 3.\nHorn theories (and renamable Horn theories) represent another target compilation subset of CNF,\nbut we do not consider it here since we restrict our attention to complete languages L only, i.e., we\nrequire that every propositional sentence is logically equivalent to an element of L.\nWe now consider nested subsets of the NNF language, which do not impose any restriction on\nthe height of a sentence. Instead, these subsets result from imposing one or more of the following\nconditions: decomposability, determinism, smoothness, decision, and ordering. We start by defining\nthe first three properties. From here on, if C is a node in an NNF, then Vars(C) denotes the set of\nall variables that label the descendants of node C. Moreover, if \u03a3 is an NNF sentence rooted at C,\nthen Vars(\u03a3) is defined as Vars(C).\n\u2022 Decomposability (Darwiche, 1999, 2001a). An NNF satisfies this property if for each conjunction C in the NNF, the conjuncts of C do not share variables. That is, if C1 , . . . , Cn are\nthe children of and-node C, then Vars(Ci ) \u2229 Vars(Cj ) = \u2205 for i 6= j. Consider the and-node\nmarked in Figure 1(a). This node has two children, the first contains variables A, B while the\nsecond contains variables C, D. This and-node is then decomposable since the two children do\nnot share variables. Each other and-node in Figure 1(a) is also decomposable and, hence, the\nNNF in this figure is decomposable.\n\u2022 Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C\nin the NNF, each two disjuncts of C are logically contradictory. That is, if C1 , . . . , Cn are\nthe children of or-node C, then Ci \u2227 Cj |= false for i 6= j. Consider the or-node marked\nin Figure 1(b), which has two children corresponding to sub-sentences \u00acA \u2227 B and \u00acB \u2227 A.\nThe conjunction of these two sub-sentences is logically contradictory. The or-node is then\ndeterministic and so are the other or-nodes in Figure 1(b). Hence, the NNF in this figure is\ndeterministic.\n\u2022 Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the\nNNF, each disjunct of C mentions the same variables. That is, if C1 , . . . , Cn are the children of\nor-node C, then Vars(Ci ) = Vars(Cj ) for i 6= j. Consider the marked or-node in Figure 1(c).\nThis node has two children, each of which mentions variables A, B. This or-node is then\nsmooth and so are the other or-nodes in Figure 1(c). Hence, the NNF in this figure is smooth.\nIt is hard to ensure decomposability. It is also hard to ensure determinism while preserving decomposability. Yet any sentence in NNF can be smoothed in polytime, while preserving decomposability\nand determinism. Preserving flatness, however, may blow-up the size of given NNF. Hence, smoothness is not that important from a complexity viewpoint unless we have flatness.\nThe properties of decomposability, determinism and smoothness lead to a number of interesting\nsubsets of NNF.\nDefinition 2.5 The language DNNF is the subset of NNF satisfying decomposability; d-NNF is the subset satisfying determinism; s-NNF is the subset satisfying smoothness; d-DNNF is the subset satisfying\ndecomposability and determinism; and sd-DNNF is the subset satisfying decomposability, determinism\nand smoothness.\nNote that DNF is a strict subset of DNNF (Darwiche, 1999, 2001a). The following decision property\ncomes from the literature on binary decision diagrams (Bryant, 1986).\nDefinition 2.6 (Decision) A decision node N in an NNF sentence is one which is labeled with true,\nfalse, or is an or-node having the form (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2), where X is a variable, \u03b1 and \u03b2 are\ndecision nodes. In the latter case, dVar (N ) denotes the variable X.\nDefinition 2.7 The language BDD is the set of NNF sentences, where the root of each sentence is a\ndecision node.\n232\n\n\fA Knowledge Compilation Map\n\nor\n\nX1\nand\n\nand\n\nX1 \u00ac X1\nor\nand\n\u00ac X2\n\nor\n\nX2\nor\nand\n\n\u00ac X3\n\nand\nX3\n\ntrue\n\nand\n\nand\n\nX2\n\nX2\nand\n\u00ac X2\n\nX2\n\nX3\n\nX3\n\n1\n\n0\n\nor\nand\n\nand\nX3\n\n\u00ac X3\n\nfalse\n\nFigure 2: On the left, a sentence in the BDD language. On the right, its corresponding binary decision\ndiagram.\n\nThe NNF sentence in Figure 2 belongs to the BDD subset.\nThe BDD language corresponds to binary decision diagrams (BDDs), as known in the formal\nverification literature (Bryant, 1986). Binary decision diagrams are depicted using a more compact\nnotation though: the labels true and false are denoted by 1 and 0, respectively; and each decision\nor\nand\n\nand\n\nX\n\n\u03b2 . The BDD sentence on the left of Figure 2 corresponds to the\nnode X \u03b1 \u00acX \u03b2 is denoted by \u03b1\nbinary decision diagram on the right of Figure 2. Obviously enough, every NNF sentence that satisfies\nthe decision property is also deterministic. Therefore, BDD is a subset of d-NNF.\nAs we show later, BDD does not qualify as a target compilation language (unless P=NP), but the\nfollowing subset does.\n\nDefinition 2.8 FBDD is the intersection of DNNF and BDD.\nThat is, each sentence in FBDD is decomposable and satisfies the decision property. The FBDD language\ncorresponds to free binary decision diagrams (FBDDs), as known in formal verification (Gergov &\nMeinel, 1994a). An FBDD is usually defined as a BDD that satisfies the read-once property: on\neach path from the root to a leaf, a variable can appear at most once. FBDDs are also known as\nread-once branching programs in the theory literature. Imposing the read-once property on a BDD\nis equivalent to imposing the decomposability property on its corresponding BDD sentence.\nA more influential subset of the BDD language is obtained by imposing the ordering property:\nDefinition 2.9 (Ordering) Let < be a total ordering on the variables PS. The language OBDD<\nis the subset of FBDD satisfying the following property: if N and M are or-nodes, and if N is an\nancestor of node M , then dVar (N ) < dVar (M ).\nDefinition 2.10 The language OBDD is the union of all OBDD< languages.\nThe OBDD language corresponds to the well\u2013known ordered binary decision diagrams (OBDDs)\n(Bryant, 1986).\nOur final language definition is as follows:\nDefinition 2.11 MODS is the subset of DNF where every sentence satisfies determinism and smoothness.\n233\n\n\fDarwiche & Marquis\n\nor\nand\n\nX\n\nY\n\nand\n\nZ\n\nand\n\nand\n\n\u00acX \u00acY \u00ac Z\n\nFigure 3: A sentence in language MODS.\n\nNNF\nCO,\n\nd-NNF\n\ns-NNF\n\nCE, ME\n\nDNNF\n\nf-NNF\n\nVA, IM, CT\n\nBDD\n\nd-DNNF\n\nEQ?\n\nVA, IM\n\nFBDD\n\nEQ?\n\nDNF\n\nsd-DNNF\n\nCNF\n\nEQ\n\nOBDD\nSE\n\nOBDD<\n\nEQ, SE\n\nVA, IM, EQ, SE\n\nMODS\n\nIP\n\nCO , CE, EQ, SE, ME\n\nPI\n\nFigure 4: The set of DAG-based languages considered in this paper. An edge L1 \u2192 L2 means that\nL1 is a proper subset of L2 . Next to each subset, we list the polytime queries supported\nby the subset but not by any of its ancestors (see Section 4).\n\nFigure 3 depicts a sentence in MODS. As we show later, MODS is the most tractable NNF subset we\nshall consider (together with OBDD< ). This is not surprising since from the syntax of a sentence in\nMODS, one can immediately recover the sentence models.\nThe languages we have discussed so far are depicted in Figure 4, where arrows denote set inclusion.\nTable 1 lists the acronyms of all of these languages, together with their descriptions. Table 2 lists\nthe key language properties discussed in this section, together with a short description of each.\n\n3. On the Succinctness of Compiled Theories\nWe have discussed more than a dozen subsets of the NNF language. Some of these subsets are well\nknown and have been studied extensively in the computer science literature. Others, such as DNNF\n(Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new. The question now is:\nWhat subset should one adopt for a particular application? As we argue in this paper, that depends\n\n234\n\n\fA Knowledge Compilation Map\n\nAcronym\nNNF\nDNNF\nd-NNF\ns-NNF\nf-NNF\nd-DNNF\nsd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\nDescription\nNegation Normal Form\nDecomposable Negation Normal Form\nDeterministic Negation Normal Form\nSmooth Negation Normal Form\nFlat Negation Normal Form\nDeterministic Decomposable Negation Normal Form\nSmooth Deterministic Decomposable Negation Normal Form\nBinary Decision Diagram\nFree Binary Decision Diagram\nOrdered Binary Decision Diagram\nOrdered Binary Decision Diagram (using order <)\nDisjunctive Normal Form\nConjunctive Normal Form\nPrime Implicates\nPrime Implicants\nModels\n\nTable 1: Language acronyms.\n\nProperty\nFlatness\nSimple Disjunction\nSimple Conjunction\nDecomposability\nDeterminism\nSmoothness\nDecision\nOrdering\n\nShort Description\nThe height of NNF is at most 2\nEvery disjunction is a clause, where literals share no variables\nEvery conjunction is a term, where literals share no variables\nConjuncts do not share variables\nDisjuncts are logically disjoint\nDisjuncts mention the same set of variables\nA node of the form true, false, or (X \u2227 \u03b1 \u2228 \u00acX \u2227 \u03b2),\nwhere X is a variable and \u03b1, \u03b2 are decision nodes\nDecision variables appear in the same order on any path in the NNF\n\nTable 2: Language properties.\n\n235\n\n\fDarwiche & Marquis\n\non three key properties of the language: its succinctness, the class of tractable queries it supports,\nand the class of tractable transformations it admits.\nOur goal in this and the following sections is to construct a map on which we place different\nsubsets of the NNF language according to the above criteria. This map will then serve as a guide to\nsystem designers in choosing the target compilation language most suitable to their application. It\nalso provides an example paradigm for studying and evaluating further target compilation languages.\nWe start with a study of succinctness2 in this section (Gogic, Kautz, Papadimitriou, & Selman, 1995).\nDefinition 3.1 (Succinctness) Let L1 and L2 be two subsets of NNF. L1 is at least as succinct\nas L2 , denoted L1 \u2264 L2 , iff there exists a polynomial p such that for every sentence \u03b1 \u2208 L2 , there\nexists an equivalent sentence \u03b2 \u2208 L1 where |\u03b2| \u2264 p(|\u03b1|). Here, |\u03b1| and |\u03b2| are the sizes of \u03b1 and \u03b2,\nrespectively.\nWe stress here that we do not require that there exists a function that computes \u03b2 given \u03b1 in\npolytime; we only require that a polysize \u03b2 exists. Yet, our proofs in Appendix A contain specific\nalgorithms for computing \u03b2 from \u03b1 in certain cases. The relation \u2264 is clearly reflexive and transitive,\nhence, a pre-ordering. One can also define the relation <, where L1 < L2 iff L1 \u2264 L2 and L2 6\u2264 L1 .\nProposition 3.1 The results in Table 3 hold.\nAn occurrence of \u2264 in the cell of row r and column c of Table 3 means that the fragment Lr\ngiven at row r is at least as succinct as the fragment Lc given at column c. An occurrence of 6\u2264 (or\n6\u2264\u2217 ) means that Lr is not at least as succinct as Lc (provided that the polynomial hierarchy does\nnot collapse in the case of 6\u2264\u2217 ). Finally, the presence of a question mark reflects our ignorance about\nwhether Lr is at least as succinct as Lc . Figure 5 summarizes the results of Proposition 3.1 in terms\nof a directed acyclic graph.\nA classical result in knowledge compilation states that it is not possible to compile any propositional formula \u03b1 into a polysize data structure \u03b2 such that: \u03b1 and \u03b2 entail the same set of clauses,\nand clausal entailment on \u03b2 can be decided in time polynomial in its size, unless NP \u2286 P/poly\n(Selman & Kautz, 1996; Cadoli & Donini, 1997). This last assumption implies the collapse of the\npolynomial hierarchy at the second level (Karp & Lipton, 1980), which is considered very unlikely.\nWe use this classical result from knowledge compilation in some of our proofs of Proposition 3.1,\nwhich explains why some of its parts are conditioned on the polynomial hierarchy not collapsing.\nWe have excluded the subsets BDD, s-NNF, d-NNF and f-NNF from Table 3 since they do not\nqualify as target compilation languages (see Section 4). We kept NNF and CNF though given their\nimportance. Consider Figure 5 which depicts Table 3 graphically. With the exception of NNF and\nCNF, all other languages depicted in Figure 5 qualify as target compilation languages. Moreover, with\nthe exception of language PI, DNNF is the most succinct among all target compilation languages-we\nknow that PI is not more succinct than DNNF, but we do not know whether DNNF is more succinct\nthan PI.\nIn between DNNF and MODS, there is a succinctness ordering of target compilation languages:\nDNNF <\n\nd-DNNF <\n\nFBDD <\n\nOBDD <\n\nOBDD<\n\n< MODS.\n\nDNNF is obtained by imposing decomposability on NNF; d-DNNF by adding determinism; FBDD by\nadding decision; and OBDD and OBDD< by adding ordering (w.r.t. any total ordering on PS in the\nfirst case and a specific one in the second case). Adding each of these properties reduces language\nsuccinctness (assuming that the polynomial hierarchy does not collapse).\nOne important fact to stress here is that adding smoothness to d-DNNF does not affect its succinctness: the sd-DNNF and d-DNNF languages are equally succinct. It is also interesting to compare\n2. A more general notion of space efficiency (model preservation for polysize reductions) exists (Cadoli, Donini,\nLiberatore, & Schaerf, 1996), but we do not need its full generality here.\n\n236\n\n\fA Knowledge Compilation Map\n\nL\nNNF\nDNNF\nd-DNNF\nsd-DNNF\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\nNNF\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nDNNF\n\u2264\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nd-DNNF\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nsd-DNNF\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nFBDD\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nOBDD\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nOBDD<\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nDNF\n\u2264\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\n6\u2264\n6\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\nCNF\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\u2217\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\u2264\n6\u2264\n6\u2264\n6\u2264\n\nPI\n\u2264\n?\n?\n?\n6\u2264\n6\u2264\n6\u2264\n6\u2264\n\u2264\n\u2264\n6\u2264\n6\u2264\n\nIP\n\u2264\n\u2264\n?\n?\n6\u2264\n6\u2264\n6\u2264\n\u2264\n6\u2264\n6\u2264\n\u2264\n6\u2264\n\nMODS\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n?\n\u2264\n\u2264\n\nTable 3: Succinctness of target compilation languages. \u2217 means that the result holds unless the\npolynomial hierarchy collapses.\n\nNNF\nDNNF\nsd-DNNF\n\n=\n\nCNF\n\nd-DNNF\nDNF\n\nFBDD\n\nPI\nOBDD\nIP\nOBDD<\nMODS\n\nFigure 5: An edge L1 \u2192 L2 indicates that L1 is strictly more succinct than L2 : L1 < L2 , while\nL1 = L2 indicates that L1 and L2 are equally succinct: L1 \u2264 L2 and L2 \u2264 L1 . Dotted\narrows indicate unknown relationships; for instance, the dotted arrow from DNNF to PI\nmeans that we do not know whether DNNF is at least as succinct as PI. Some of the edges\nare conditioned on the polynomial hierarchy not collapsing-see Table 3.\n\nsd-DNNF (which is more succinct than the influential FBDD, OBDD and OBDD< languages) with MODS,\nwhich is a most tractable language. Both sd-DNNF and MODS are smooth, deterministic and decomposable. MODS, however, is flat and obtains its decomposability from the stronger condition\nof simple-conjunction. Therefore, sd-DNNF can be viewed as the result of relaxing from MODS the\nflatness and simple-conjunction conditions, while maintaining decomposability, determinism and\nsmoothness. Relaxing these conditions moves the language three levels up the succinctness hierarchy, although it compromises only the polytime test for sentential entailment and possibly the one\nfor equivalence as we show in Section 4.\n\n237\n\n\fDarwiche & Marquis\n\n4. Querying a Compiled Theory\nIn evaluating the suitability of a target compilation language to a particular application, the succinctness of the language must be balanced against the set of queries and transformations that it\nsupports in polytime. We consider in this section a number of queries, each of which returns valuable information about a propositional theory, and then identify target compilation languages which\nprovide polytime algorithms for answering such queries. We restrict our attention in this paper to\nthe existence of polytime algorithms for answering queries, but we do not present the algorithms\nthemselves. The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for\nsome of these algorithms and to the proofs of theorems in Appendix A for others.\nThe queries we consider are tests for consistency, validity, implicates (clausal entailment), implicants, equivalence, and sentential entailment. We also consider counting and enumerating theory\nmodels; see Table 4. One can also consider computing the probability of a propositional sentence,\nassuming that all variables are probabilistically independent. For the subsets we consider, however,\nthis can be done in polytime whenever models can be counted in polytime.\nFrom here on, L denotes a subset of language NNF.\nDefinition 4.1 (CO, VA) L satisfies CO (VA) iff there exists a polytime algorithm that maps\nevery formula \u03a3 from L to 1 if \u03a3 is consistent (valid), and to 0 otherwise.\nOne of the main applications of compiling a theory is to enhance the efficiency of answering\nclausal entailment queries:\nDefinition 4.2 (CE) L satisfies CE iff there exists a polytime algorithm that maps every formula\n\u03a3 from L and every clause \u03b3 from NNF to 1 if \u03a3 |= \u03b3 holds, and to 0 otherwise.\nA key application of clausal entailmentVis in testing equivalence. Specifically, suppose we have a\ndesignVexpressed as a set of clauses \u2206d = i \u03b1i and a specification expressed also as a set of clauses\n\u2206s = j \u03b2j , and we want to test whether the design and specification are equivalent. By compiling\neach of \u2206d and \u2206s to targets \u0393d and \u0393s that support a polytime clausal entailment test, we can test\nthe equivalence of \u2206d and \u2206s in polytime. That is, \u2206d and \u2206s are equivalent iff \u0393d |= \u03b2j for all j\nand \u0393s |= \u03b1i for all i.\nA number of the target compilation languages we shall consider support a direct polytime equivalent test:\nDefinition 4.3 (EQ, SE) L satisfies EQ (SE) iff there exists a polytime algorithm that maps every\npair of formulas \u03a3, \u03a6 from L to 1 if \u03a3 \u2261 \u03a6 (\u03a3 |= \u03a6) holds, and to 0 otherwise.\nNote that sentential entailment (SE) is stronger than clausal entailment and equivalence. Therefore,\nif a language L satisfies SE, it also satisfies CE and EQ.\nFor completeness, we consider the following dual to CE:\nDefinition 4.4 (IM) L satisfies IM iff there exists a polytime algorithm that maps every formula\n\u03a3 from L and every term \u03b3 from NNF to 1 if \u03b3 |= \u03a3 holds, and to 0 otherwise.\nFinally, we consider counting and enumerating models:\nDefinition 4.5 (CT) L satisfies CT iff there exists a polytime algorithm that maps every formula\n\u03a3 from L to a nonnegative integer that represents the number of models of \u03a3 (in binary notation).\nDefinition 4.6 (ME) L satisfies ME iff there exists a polynomial p(., .) and an algorithm that\noutputs all models of an arbitrary formula \u03a3 from L in time p(n, m), where n is the size of \u03a3 and\nm is the number of its models (over variables occurring in \u03a3).\n\n238\n\n\fA Knowledge Compilation Map\n\nNotation\nCO\nVA\nCE\nIM\nEQ\nSE\nCT\nME\n\nQuery\npolytime consistency check\npolytime validity check\npolytime clausal entailment check\npolytime implicant check\npolytime equivalence check\npolytime sentential entailment check\npolytime model counting\npolytime model enumeration\n\nTable 4: Notations for queries.\n\nL\nNNF\nDNNF\nd-NNF\ns-NNF\nf-NNF\nd-DNNF\nsd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\nCO\n\u25e6\n\u221a\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\nVA\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\nCE\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\nIM\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\nSE\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\nCT\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\nME\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\nEQ\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n?\n?\n\u25e6\n?\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\nTable 5: Subsets of the NNF language and their corresponding polytime queries.\nand \u25e6 means \"does not satisfy unless P = NP.\"\n\n\u221a\n\nmeans \"satisfies\"\n\nTable 4 summarizes the queries we are interested in and their acronyms.\nThe following proposition states what we know about the availability of polytime algorithms for\nanswering the above queries, with respect to all languages we introduced in Section 2.\nProposition 4.1 The results in Table 5 hold.\nThe results of Proposition 4.1 are summarized in Figure 4. One can draw a number of conclusions\nbased on the results in this figure. First, NNF, s-NNF, d-NNF, f-NNF, and BDD fall in one equivalence\nclass that does not support any polytime queries and CNF satisfies only VA and IM; hence, none\nof them qualifies as a target compilation language in this case. But the remaining languages all\nsupport polytime tests for consistency and clausal entailment. Therefore, simply imposing either\nof smoothness (s-NNF), determinism (d-NNF), flatness (f-NNF), or decision (BDD) on the NNF language does not lead to tractability with respect to any of the queries we consider-neither of these\nproperties seem to be significant in isolation. Decomposability (DNNF), however, is an exception and\nleads immediately to polytime tests for both consistency and clausal entailment, and to a polytime\nalgorithm for model enumeration.\n239\n\n\fDarwiche & Marquis\n\nRecall the succinctness ordering DNNF < d-DNNF < FBDD < OBDD < OBDD< < MODS\nfrom Figure 5. By adding decomposability (DNNF), we obtain polytime tests for consistency and\nclausal entailment, in addition to a polytime model enumeration algorithm. By adding determinism\nto decomposability (d-DNNF), we obtain polytime tests for validity, implicant and model counting,\nwhich are quite significant. It is not clear, however, whether the combination of decomposability and\ndeterminism leads to a polytime test for equivalence. Moreover, adding the decision property on top\nof decomposability and determinism (FBDD) does not appear to increase tractability with respect to\nthe given queries3 , although it does lead to reducing language succinctness as shown in Figure 5. On\nthe other hand, adding the ordering property on top of decomposability, determinism and decision,\nleads to polytime tests for equivalence (OBDD and OBDD< ) as well as sentential entailment provided\nthat the ordering < is fixed (OBDD< ).\nAs for the succinctness ordering NNF < DNNF < DNF < IP < MODS from Figure 5, note that\nDNNF is obtained by imposing decomposability on NNF, while DNF is obtained by imposing flatness\nand simple-conjunction (which is stronger than decomposability). What is interesting is that DNF is\nless succinct than DNNF, yet does not support any more polytime queries; see Figure 4. However, the\naddition of smoothness (and determinism) on top of flatness and simple-conjunction (MODS) leads to\nfive additional polytime queries, including equivalence and entailment tests.4\nWe close this section by noting that determinism appears to be necessary (but not sufficient) for\npolytime model counting: only deterministic languages, d-DNNF, sd-DNNF, FBDD, OBDD, OBDD< and\nMODS, support polytime counting. Moreover, polytime counting implies a polytime test of validity,\nbut the opposite is not true.\n\n5. Transforming a Compiled Theory\nA query is an operation that returns information about a theory without changing it. A transformation, on the other hand, is an operation that returns a modified theory, which is then operated\non using queries. Many applications require a combination of transformations and queries.\nDefinition 5.1 (\u2227C, \u2228C) Let L be a subset of NNF. L satisfies \u2227C (\u2228C) iff there exists a polytime\nalgorithm that maps every finite set of formulas \u03a31 , . . . , \u03a3n from L to a formula of L that is logically\nequivalent to \u03a31 \u2227 . . . \u2227 \u03a3n (\u03a31 \u2228 . . . \u2228 \u03a3n ).\nDefinition 5.2 (\u00acC) Let L be a subset of NNF. L satisfies \u00acC iff there exists a polytime algorithm\nthat maps every formula \u03a3 from L to a formula of L that is logically equivalent to \u00ac\u03a3.\nIf a language satisfies one of the above properties, we will say that it is closed under the corresponding operator. Closure under logical connectives is important for two key reasons. First, it has\nimplications on how compilers are constructed for a given target language. For example, if a clause\ncan be easily compiled into some language L, then closure under conjunction implies that compiling\na CNF sentence into L is easy. Second, it has implications on the class of polytime queries supported\nby the target language: If a language L satisfies CO and is closed under negation and conjunction,\nthen it must satisfy SE (to test whether \u2206 |= \u0393, all we have to do, by the Refutation Theorem,\nis test whether \u2206 \u2227 \u00ac\u0393 is inconsistent). Similarly, if a language satisfies VA and is closed under\nnegation and disjunction, it must satisfy SE by the Deduction Theorem.\n3. Deciding the equivalence of two sentences in FBDD, d-DNNF, or in sd-DNNF, can be easily shown to be in coNP.\nHowever, we do not have a proof of coNP-hardness, nor do we have deterministic polytime algorithms for deciding\nthese problems. Actually, the latter case is quite unlikely as the equivalence problem for FBDD has been intensively\nstudied, with no such algorithm in sight. Note, however, that the equivalence of two sentences in FBDD can be\ndecided probabilistically in polytime (Blum, Chandra, & Wegman, 1980), and similarly for sentences in d-DNNF\n(Darwiche & Huang, 2002).\n4. Given flatness, simple-conjunction and smoothness, we can obtain determinism by simply removing duplicated\nterms.\n\n240\n\n\fA Knowledge Compilation Map\n\nIt is important to stress here that some languages are closed under a logical operator, only if the\nnumber of operands is bounded by a constant. We will refer to this as bounded closure.\nDefinition 5.3 (\u2227BC, \u2228BC) Let L be a subset of NNF. L satisfies \u2227BC (\u2228BC) iff there exists\na polytime algorithm that maps every pair of formulas \u03a3 and \u03a6 from L to a formula of L that is\nlogically equivalent to \u03a3 \u2227 \u03a6 (\u03a3 \u2228 \u03a6).\nWe now turn to another important transformation:\nDefinition 5.4 (Conditioning) (Darwiche, 1999) Let \u03a3 be a propositional formula, and let \u03b3 be\na consistent term. The conditioning of \u03a3 on \u03b3, noted \u03a3 | \u03b3, is the formula obtained by replacing\neach variable X of \u03a3 by true (resp. false) if X (resp. \u00acX) is a positive (resp. negative) literal of \u03b3.\nDefinition 5.5 (CD) Let L be a subset of NNF. L satisfies CD iff there exists a polytime algorithm\nthat maps every formula \u03a3 from L and every consistent term \u03b3 to a formula from L that is logically\nequivalent to \u03a3 | \u03b3.\nConditioning has a number of applications, and corresponds to restriction in the literature on\nBoolean functions. The main application of conditioning is due to a theorem, which says that \u03a3 \u2227 \u03b3\nis consistent iff \u03a3 | \u03b3 is consistent (Darwiche, 2001a, 1999). Therefore, if a language satisfies CO\nand CD, then it must also satisfy CE. Conditioning also plays a key role in building compilers\nthat enforce decomposability. If two sentences \u22061 and \u22062 are both decomposable (belong to DNNF),\ntheir conjunction \u22061 \u2227 \u22062 is not necessarily decomposable since the sentences may share variables.\nConditioning\ncan be used to ensure decomposability in this case since \u22061 \u2227 \u22062 is equivalent to\nW\n(\u2206\n|\n\u03b3)\n\u2227\n(\u2206\n1\n2 | \u03b3) \u2227 \u03b3, where \u03b3 is a term covering all variables shared by \u22061 and \u22062 . Note that\nW\u03b3\n(\u2206\n|\n\u03b3)\n\u2227\n(\u2206\n1\n2 | \u03b3) \u2227 \u03b3 must be decomposable since \u22061 | \u03b3 and \u22062 | \u03b3 do not mention variables\n\u03b3\nin \u03b3. The previous proposition is indeed a generalization to multiple variables of the well-known\nShannon expansion in the literature on Boolean functions. It is also the basis for compiling CNF into\nDNNF (Darwiche, 1999, 2001a).\nAnother critical transformation we shall consider is that of forgetting (also referred to as marginalization, or elimination of middle terms (Boole, 1854)):\nDefinition 5.6 (Forgetting) Let \u03a3 be a propositional formula, and let X be a subset of variables\nfrom PS. The forgetting of X from \u03a3, denoted \u2203X.\u03a3, is a formula that does not mention any variable\nfrom X and for every formula \u03b1 that does not mention any variable from X, we have \u03a3 |= \u03b1 precisely\nwhen \u2203X.\u03a3 |= \u03b1.\nTherefore, to forget variables from X is to remove any reference to X from \u03a3, while maintaining all\ninformation that \u03a3 captures about the complement of X. Note that \u2203X.\u03a3 is unique up to logical\nequivalence.\nDefinition 5.7 (FO, SFO) Let L be a subset of NNF. L satisfies FO iff there exists a polytime\nalgorithm that maps every formula \u03a3 from L and every subset X of variables from PS to a formula\nfrom L equivalent to \u2203X.\u03a3. If the property holds for singleton X, we say that L satisfies SFO.\nForgetting is an important transformation as it allows us to focus/project a theory on a set of\nvariables. For example, if we know that some variables X will never appear in entailment queries,\nwe can forget these variables from the compiled theory while maintaining its ability to answer\nsuch queries correctly. Another application of forgetting is in counting/enumerating the instantiations of some variables Y, which are consistent with a theory \u2206. This query can be answered by\ncounting/enumerating the models of \u2203X.\u2206, where X is the complement of Y. Forgetting also has\napplications to planning, diagnosis and belief revision. For instance, in the SATPLAN framework,\n\n241\n\n\fDarwiche & Marquis\n\nNotation\nCD\nFO\nSFO\n\u2227C\n\u2227BC\n\u2228C\n\u2228BC\n\u00acC\n\nTransformation\npolytime conditioning\npolytime forgetting\npolytime singleton forgetting\npolytime conjunction\npolytime bounded conjunction\npolytime disjunction\npolytime bounded disjunction\npolytime negation\n\nTable 6: Notations for transformations.\n\nL\nNNF\nDNNF\nd-NNF\ns-NNF\nf-NNF\nd-DNNF\nsd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\nCD\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\nFO\n\u25e6\n\u221a\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u2022\n\u2022\n\u2022\n\u221a\n\nSFO\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u2022\n\u221a\n\n\u2022\n\u221a\n\n\u2227C\n\u221a\n\n\u2227BC\n\u221a\n\u25e6\n\u221a\n\u221a\n\n\u2228C\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u2228BC\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u2022\n\u25e6\n\u25e6\n\u221a\n\n\u2022\n\u25e6\n\u25e6\n\u221a\n\n\u2022\n\u25e6\n\u25e6\n\u221a\n\n\u2022\n\u25e6\n\u25e6\n\u221a\n\n\u2022\n\u2022\n\u2022\n\u2022\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u2022\n\u2022\n\u2022\n\u221a\n\n\u2022\n\u2022\n\u2022\n\n\u2022\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u2022\n\u2022\n\n\u00acC\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n?\n?\n\u221a\n\u221a\n\u221a\n\u221a\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\n\u221a\nTable 7: Subsets of the NNF language and their polytime transformations.\nmeans \"satisfies,\" \u2022\nmeans \"does not satisfy,\" while \u25e6 means \"does not satisfy unless P=NP.\"\ncompiling away fluents or actions amounts to forgetting variables. In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information\nrequired to compute the conflicts and the diagnoses of a system (Darwiche, 2001a). Forgetting has\nalso been used to design update operators with valuable properties (Herzig & Rifi, 1999).\nTable 6 summarizes the transformations we are interested in and their acronyms. The following\nproposition states what we know about the tractability of these transformations with respect to the\nidentified target compilation languages.\nProposition 5.1 The results in Table 7 hold.\nOne can draw a number of observations regarding Table 7. First, all languages we consider satisfy\nCD and, hence, lend themselves to efficient application of the conditioning transformation. As for\nforgetting multiple variables, only DNNF, DNF, PI and MODS permit that in polytime. It is important\nto stress here that none of FBDD, OBDD and OBDD< permits polytime forgetting of multiple variables.\nThis is noticeable since some of the recent applications of OBDD< to planning-within the so-called\nsymbolic model checking approach to planning (A. Cimmati & Traverso, 1997)-depend crucially\n242\n\n\fA Knowledge Compilation Map\n\non the operation of forgetting and it may be more suitable to use a language that satisfies FO in\nthis case. Note, however, that OBDD and OBDD< allow the forgetting of a single variable in polytime,\nbut FBDD does not allow even that. d-DNNF is similar to FBDD as it satisfies neither FO nor SFO.\nIt is also interesting to observe that none of the target compilation languages is closed under\nconjunction. A number of them, however, are closed under bounded conjunction, including OBDD< ,\nDNF, IP and MODS.\nAs for disjunction, the only target compilation languages that are closed under disjunction are\nDNNF and DNF. The OBDD< and PI languages, however, are closed under bounded disjunction. Again,\nthe d-DNNF, FBDD and OBDD languages are closed under neither.\nThe only target compilation languages that are closed under negation are FBDD, OBDD and OBDD< ,\nwhile it is not known whether d-DNNF or sd-DNNF are closed under this operation. Note that d-DNNF\nand FBDD support the same set of polytime queries (equivalence checking is unknown for both)\nso they are indistinguishable from that viewpoint. Moreover, the only difference between the two\nlanguages in Table 7 is the closure of FBDD under negation, which does not seem to be that significant\nin light of no closure under either conjunction or disjunction. Note, however, that d-DNNF is more\nsuccinct than FBDD as given in Figure 5.\nFinally, OBDD< is the only target compilation language that is closed under negation, bounded\nconjunction, and bounded disjunction. This closure actually plays an important role in compiling\npropositional theories into OBDD< and is the basis of state-of-the-art compilers for this purpose\n(Bryant, 1986).\n\n6. Conclusion\nThe main contribution of this paper is a methodology for analyzing propositional compilation approaches according to two key dimensions: the succinctness of the target compilation language, and\nthe class of queries and transformations it supports in polytime. The second main contribution\nof the paper is a comprehensive analysis, according to the proposed methodology, of more than\na dozen languages for which we have produced a knowledge compilation map, which cross-ranks\nthese languages according to their succinctness, and the polytime queries and transformations they\nsupport. This map allows system designers to make informed decisions on which target compilation\nlanguage to use: after the class of queries/transformations have been decided based on the application of interest, the designer chooses the most succinct target compilation language that supports\nsuch operations in polytime. Another key contribution of this paper is the uniform treatment we\nhave applied to diverse target compilation languages, showing how they all are subsets of the NNF\nlanguage. Specifically, we have identified a number of simple, yet meaningful, properties, including\ndecomposability, determinism, decision and flatness, and showed how combinations of these properties give rise to different target compilation languages. The studied subsets include some well known\nlanguages such as PI, which has been influential in AI; OBDD< , which has been influential in formal\nverification; and CNF and DNF, which have been quite influential in computer science. The subsets\nalso include some relatively new languages such as DNNF and d-DNNF, which appear to represent\ninteresting, new balances between language succinctness and query/transformation tractability.\n\nAcknowledgments\nThis is a revised and extended version of the paper \"A Perspective on Knowledge Compilation,\"\nin Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI'01), pp.\n175-182, 2001. We wish to thank Alvaro del Val, Mark Hopkins, J\u00e9r\u00f4me Lang and the anonymous\nreviewers for some suggestions and comments, as well as Ingo Wegener for his help with some of\nthe issues discussed in the paper. This work has been done while the second author was a visiting\nresearcher with the Computer Science Department at UCLA. The first author has been partly\n243\n\n\fDarwiche & Marquis\n\nsupported by NSF grant IIS-9988543 and MURI grant N00014-00-1-0617. The second author has\nbeen partly supported by the IUT de Lens, the Universit\u00e9 d'Artois, the Nord/Pas-de-Calais R\u00e9gion\nunder the TACT-TIC project, and by the European Community FEDER Program.\n\nAppendix A. Proofs\nTo simplify the proofs of our main propositions later on, we have identified a number of lemmas that\nwe list below. Some of the proofs of these lemmas are direct, but we include them for completeness.\nLemma A.1 Every sentence in d-DNNF can be translated to an equivalent sentence in sd-DNNF in\npolytime.\nProof: Let \u03b1 = \u03b11 \u2228 . . . \u2228 \u03b1n be an or-node in a d-DNNF sentence \u03a3. Suppose that \u03b1 is not smooth\nandWlet V = V\nVars(\u03b1). Consider now the sentence \u03a3s obtained by replacing in \u03a3 each such node\nn\nby i=1 \u03b1i \u2227 v\u2208V \\Vars(\u03b1i ) (\u00acv \u2228 v). Then \u03a3s is equivalent to \u03a3 and is smooth. Moreover, \u03a3s can\nbe computed in time polynomial in the size of \u03a3 and it satisfies decomposability and determinism. \u2737\nLemma A.2 Every sentence in FBDD can be translated to an equivalent sentence in FBDD \u2229 s-NNF\nin polytime.\nProof: Let \u03a3 be a sentence in FBDD and let \u03b1 be a node in \u03a3. We can always replace \u03b1 with (Y \u2227\u03b1)\u2228\n(\u00acY \u2227 \u03b1), for some variable Y , while preserving equivalence and the decision property. Moreover,\nas long as the variable Y does not appear in \u03b1 and is not an ancestor of \u03b1, then decomposability is\nalso preserved (that is, the resulting sentence is in FBDD). Note here that \"ancestor\" is with respect\nto the binary decision diagram notation of \u03a3\u2013see left of Figure 2.\nNow, suppose that (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2) is an or-node in \u03a3. Suppose further that the or-node\nis not smooth. Hence, there is some Y which appears in Vars(\u03b2) but not in Vars(\u03b1) (or the other\nway around). Since \u03a3 is decomposable, then Y cannot be an ancestor of \u03b1 (since in that case it\nwould also be an ancestor of \u03b2, which is impossible by decomposability of \u03a3). Hence, we can replace \u03b1 with (Y \u2227 \u03b1) \u2228 (\u00acY \u2227 \u03b1), while preserving equivalence, decision and decomposability. By\nrepeating the above process, we can smooth \u03a3 while preserving all the necessary properties. Finally,\nnote that for every or-node (X \u2227 \u03b1) \u2228 (\u00acX \u2227 \u03b2) in \u03a3, we need to repeat the above process at most\n| Vars(\u03b1) \u2212 Vars(\u03b2) | + | Vars(\u03b2) \u2212 Vars(\u03b1) | times. Hence, the smoothing operation can be performed in polytime.\n\u2737\nLemma A.3 If a subset L of NNF satisfies CO and CD, then it also satisfies ME.\nProof: Let \u03a3 be a sentence in L. First, we test if \u03a3 is inconsistent (can be done in polytime). If\nit is, we return the empty set of models. Otherwise, we construct a decision-tree representation of\nthe models of \u03a3. Given an ordering of the variables x1 , . . . , xn of Vars(\u03a3), we start with a tree\nT consisting of a single root node. For i = 1 to n, we repeat the following for each leaf node \u03b1\n(corresponds to a consistent term) in T :\na. If \u03a3 | \u03b1 \u2227 xi is consistent, we add xi as a child to \u03b1;\nb. If \u03a3 | \u03b1 \u2227 \u00acxi is consistent, we add \u00acxi as a child to \u03b1.\nThe key points are:\n\u2022 Test (a) and Test (b) can be performed in time polynomial in the size of \u03a3 (since L satisfies\nCO and CD).\n\n244\n\n\fA Knowledge Compilation Map\n\n\u2022 Either Test (a) or Test (b) above must succeed (since \u03a3 is consistent).\nHence, the number of tests performed is O(mn), where m is the number of leaf nodes in the final\ndecision tree (bounded by the number of models of \u03a3) and n is the number of variables of \u03a3.\n\u2737\nLemma A.4 If a subset of NNF satisfies CO and CD, then it also satisfies CE.\nProof: To test whether sentence \u03a3 entails non-valid clause \u03b1, \u03a3 |= \u03b1, it suffices to test whether\n\u03a3 | \u00ac\u03b1 is inconsistent (Darwiche, 2001a).\n\u2737\nLemma A.5 Let \u03b1 and \u03b2 be two sentences that share no variables. Then \u03b1 \u2228 \u03b2 is valid iff \u03b1 is valid\nor \u03b2 is valid.\nProof: \u03b1 \u2228 \u03b2 is valid iff \u00ac\u03b1 \u2227 \u00ac\u03b2 is inconsistent. Since \u00ac\u03b1 and \u00ac\u03b2 share no variables, then \u00ac\u03b1 \u2227 \u00ac\u03b2\nis inconsistent iff \u00ac\u03b1 is inconsistent or \u00ac\u03b2 is. This is true iff \u03b1 is valid or \u03b2 is valid.\n\u2737\nLemma A.6 Let \u03a3 be a sentence in d-DNNF and let \u03b3 be a clause. Then a sentence in d-DNNF\nwhich is equivalent to \u03a3 \u2228 \u03b3 can be constructed in polytime in the size of \u03a3 and \u03b3.\nWn\nVi\u22121\nProof: Let l1 , . . . , ln be the literals that appear in clause \u03b3. Then \u03b2 = i=1 (li \u2227 j=1 \u00aclj ) is\nequivalent to clause \u03b3, is in d-DNNF, and can be constructed in polytime in size of \u03b3. Now let \u03b1 be\nthe term equivalent to \u00ac\u03b3. We have that \u03a3 \u2228 \u03b3 is equivalent to ((\u03a3 | \u03b1) \u2227 \u03b1) \u2228 \u03b2. The last sentence\nis in d-DNNF and can be constructed in polytime in size of \u03a3 and \u03b3.\n\u2737\nLemma A.7 If a subset of NNF satisfies VA and CD, then it also satisfies IM.\nProof: To test whether a consistent term \u03b1 entails sentence \u03a3, \u03b1 |= \u03a3, it suffices to test whether\n\u00ac\u03b1 \u2228 \u03a3 is valid. This sentence is equivalent to \u00ac\u03b1 \u2228 (\u03b1 \u2227 \u03a3), to \u00ac\u03b1 \u2228 (\u03b1 \u2227 (\u03a3 | \u03b1)), and to \u00ac\u03b1 \u2228 (\u03a3 | \u03b1).\nSince \u00ac\u03b1 and \u03a3 | \u03b1 share no variables, the disjunction is valid iff \u00ac\u03b1 is valid or \u03a3 | \u03b1 is valid (by\nLemma A.5). \u00ac\u03b1 cannot be valid since \u03b1 is consistent. \u03a3 | \u03b1 can be constructed in polytime since\nthe language satisfies CD and its validity can be tested in polytime since the language satisfies VA. \u2737\nLemma A.8 Every CNF or DNF formula can be translated to an equivalent sentence in BDD in\npolytime.\nProof: It is straightforward to convert a clause or term into an equivalent sentence in BDD. In order\nto generate a BDD sentence corresponding to the conjunction (resp. disjunction) of BDD sentences \u03b1\nand \u03b2, it is sufficient to replace the 1-sink (resp. 0-sink) of \u03b1 with the root of \u03b2.\n\u2737\nLemma A.9 If a subset of NNF satisfies EQ, then it satisfies CO and VA.\nProof: true and false belong to every NNF subset. \u03a3 is inconsistent iff it is equivalent to false. \u03a3 is\nvalid iff it is equivalent to true.\n\u2737\nLemma A.10 If a subset of NNF satisfies SE, then it satisfies EQ, CO and VA.\nProof: Sentences \u03a31 and \u03a32 are equivalent iff \u03a31 |= \u03a32 and \u03a32 |= \u03a31 . EQ implies CO and VA\n(Lemma A.9).\n\u2737\n\n245\n\n\fDarwiche & Marquis\n\nLemma A.11 Let \u03a3 be a sentence in d-DNNF and let \u03b3 be a clause. The validity of \u03a3 \u2228 \u03b3 can be\ntested in time polynomial in the size of \u03a3 and \u03b3.\nProof: Construct \u03a3 \u2228 \u03b3 in polytime as given in Lemma A.6 and check its validity, which can be\ndone in polytime too.\n\u2737\nLemma A.12 For every propositional formula \u03a3 and every consistent term \u03b3, we have \u03a3|\u03b3 is\nequivalent to\n\u2203Vars(\u03b3).(\u03a3 \u2227 \u03b3).\nProof: Without loss of generality, assume that \u03a3 is given by the disjunctively-interpreted set of\nits models (over Vars(\u03a3)). Conditioning \u03a3 on \u03b3 leads (1) to removing every model of \u00ac\u03b3, then\n(2) projecting the remaining models so that every variable of \u03b3 is removed. Conjoining \u03a3 with \u03b3\nleads exactly to (1), while forgetting every variable of \u03b3 in the resulting formula leads exactly to (2)\n(Lang, Liberatore, & Marquis, 2000).\n\u2737\nLemma A.13 Each sentence \u03a3 in f-NNF can be converted into an equivalent sentence \u03a3\u2217 in polynomial time, where \u03a3\u2217 \u2208 CNF or \u03a3\u2217 \u2208 DNF.\nProof: We consider three cases for the sentence \u03a3:\n1. The root node of \u03a3 is an and-node. In this case, \u03a3 can be turned into a CNF sentence \u03a3\u2217 in\npolynomial time by simply ensuring that each or-node in \u03a3 is a clause (that is, a disjunction\nof literals that share no variables). Let C be an or-node in \u03a3. Since \u03a3 is flat and its root is\nan and-node, C must be a child of the root of \u03a3 and the children of C must be leaves. Hence,\nwe can easily ensure that C is a clause as follows:\n\u2022 If we have one edge from C to some leaf X and another edge from C to \u00acX (C is valid),\nwe replace the edge from the root to C by an edge from the root to true.\n\u2022 If we have more than one edge from C to the same leaf node X, we keep only one of these\nedges and delete the rest.\n2. The root of \u03a3 is an or-node. \u03a3 can be turned into a DNF sentence \u03a3\u2217 in a dual way.5\n3. The root of \u03a3 is a leaf node. \u03a3 is already a CNF sentence.\n\u2737\nLemma A.14 \u03b1 is a prime implicant (resp. an essential prime implicant) of sentence \u03a3 iff \u00ac\u03b1 is\na prime implicate (resp. an essential prime implicate) of \u00ac\u03a3. 6\nProof: This is a folklore result, immediate from the definitions.\n\n\u2737\n\nProof of Proposition 3.1\nThe proof of this proposition is broken down into eight steps. In each step, we prove a number of\nsuccinctness relationships between different languages, and then apply transitivity of the succinctness\nrelation to infer even more relationships. Associated with each step of the proof is a table in which\n\n246\n\n\fA Knowledge Compilation Map\n\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\nTable 8:\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\nFBDD\nOBDD\nOBDD<\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\nDNF\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\u2264\n\u2264\n\n\u2264\n\nTable 9:\nwe mark all relationships that are proved in that step\u2013we don't show these marks in the very first\ntable though.\nTable 8: Follows immediately from the language inclusions reported in Figure 4.\nTable 9: We can prove both that DNF 6\u2264 PI and CNF 6\u2264 IP (this slightly generalizes the results\nDNF 6\u2264 CNF and CNF 6\u2264 DNF given in (Gogic et al., 1995)).\nVn\u22121\nLet us consider the CNF formula \u03a3n = i=0 (x2i \u2228 x2i+1 ). This formula is in prime implicates\nform7 (and each clause in \u03a3n is an essential prime implicate of it). Hence its negation \u00ac\u03a3n is in\nprime implicants form (as an easy consequence of Lemma A.14).\nSince Quine's early work (Quine, 1959), we know that the number of essential prime implicants\n(resp. prime implicates) of a formula is a lower bound of the number of terms (resp. clauses) that\ncan be found in any DNF (resp. CNF) representation of it (indeed, any such representation must\ninclude the essential prime). \u03a3n has 2n essential prime implicants. Indeed, this can be easily shown\nby induction on n given that (i) every literal occurring in \u03a3n occurs only once, (ii) the set of prime\nimplicants of any nontautological clause is the set of literals occurring in it (up to logical equivalence),\nand (iii) the distribution property for prime implicants (see e.g., (dual of) Proposition 40 in (Marquis,\n2000)) which states that IP (\u03b1 \u2227\u03b2) = max({PI\u03b1 \u2227PI\u03b2 | PI\u03b1 \u2208 IP (\u03b1), PI\u03b2 \u2208 IP (\u03b2)}, |=) (up to logical\nequivalence). Subsequently, \u00ac\u03a3n has 2n essential prime implicates (cf. Lemma A.14). Accordingly,\nwe obtain that both DNF 6\u2264 PI and CNF 6\u2264 IP. We also obtain PI 6\u2264 IP and IP 6\u2264 PI. Now, it is\nwell\u2013known that some DNF formulas have exponentially many prime implicants (see the proof of\nProposition 5.1 where we show that IP does not satisfy SFO). Hence, their negations are CNF\n5. Note that f-NNF satisfies \u00acC and that the negation of a CNF sentence (resp. DNF sentence) can be turned into a\nDNF (resp. CNF) in linear time.\n6. A prime implicant (resp. a prime implicate) \u03b1 of \u03a3 is essential iff the disjunction (resp. conjunction) of all prime\nimplicants (resp. prime implicates) of \u03a3 except \u03b1 is not equivalent to \u03a3.\n7. The correctness of (the dual of) Quine's consensus algorithm for computing prime implicants (Quine, 1955)\nensures it, since no clause of \u03a3n is subsumed by another clause and no consensi can be performed since there are\nno negated variables.\n\n247\n\n\fDarwiche & Marquis\n\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\nFBDD\nOBDD\nOBDD<\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\nDNF\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n6\u2264\n\n\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n6\u2264\n6\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n6\u2264\n\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\nTable 10:\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\nFBDD\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n\u2264\n6\n\u2264\n\n\u2264\n6\n\u2264\n6\n\u2264\n\u2264\n\n\u2264\n\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\nTable 11:\nformulas having exponentially many prime implicates. Subsequently IP 6\u2264 DNF and PI 6\u2264 CNF. The\nremaining results in this table follow fromL\nthe transitivity of \u2264.\nn\u22121\nTable 10: The parity function On = i=0 xi has linear size OBDD< representations (Bryant,\n1986) but only exponential size CNF and DNF representations. The reason is that On has 2n\nessential prime implicants (resp. essential prime implicates) and the number of essential prime\nimplicants (resp. essential prime implicates) of a formula is a lower bound of the size of any of its\nDNF (resp. CNF) representation. This easily shows that both CNF 6\u2264 OBDD and DNF 6\u2264 OBDD. The\nremaining results in this table follow from the language inclusions reported in Figure 4.\nTable 11: It is shown in (Darwiche, 2001b) that there is a sentence in d-DNNF which only\nhas exponential FBDD representations. Accordingly, we have FBDD 6\u2264 d-DNNF. In (Gergov & Meinel,\n1994a), it is shownVthat OBDD 6\u2264 FBDD. Finally, it is easy to show that OBDD< 6\u2264 OBDD (for instance,\nn\nthe formula \u03a3n = i=1 (xi \u21d4 yi ) has an OBDD< representation of size polynomial in n whenever <\nsatisfies x1 < y1 < x2 < . . . < xn < yn , while it has an OBDD< representation of size exponential in\nn provided that < is s.t. x1 < x2 < . . . < xn < y1 < y2 < . . . < yn ). The remaining results in this\ntable follow from the language inclusions reported in Figure 4.\nTable 12: L' 6\u2264\u2217 L means that L' 6\u2264 L unless the polynomial hierarchy PH collapses. The\nresults in this table follow since the existence of polysize knowledge compilation functions for clausal\nentailment implies the collapse of the polynomial hierarchy PH (Selman & Kautz, 1996; Cadoli &\nDonini, 1997). Now, if DNNF \u2264 CNF, then for each sentence \u03a3 in CNF there exists a polysize equivalent\nsentence \u0393 in DNNF. Therefore, we can test whether a clause is entailed by \u03a3 in polytime by testing\nwhether the clause is entailed by \u0393. This proves the existence of polysize knowledge compilation\nfunctions for clausal entailment, leading to the collapse of the polynomial hierarchy PH. The same\nis true for d-DNNF and sd-DNNF since all these languages support a polytime clausal entailment test\n(see Proposition 4.1).\nTable 13: In (Wegener, 1987) (Theorem 6.2 pp. 436), a family of n2 -variable boolean functions\n\u03a3 is pointed out. Provided that every interpretation I over these n2 variables represents a n-vertices\ndigraph (for every 1 \u2264 i, j \u2264 n, we have I(xi,j ) = 1 iff (i, j) is an arc of the digraph), \u03a3(I) = 1 iff the\n248\n\n\fA Knowledge Compilation Map\n\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\n\n\u2264\n6 \u2217\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n6 \u2217\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n\u2264\n6\n\u2264\n\nDNNF\n\n\u2264\n\n6 \u2217\n\u2264\n\nd-DNNF\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\n\u2264\n\n\u2264\n\n\u2264\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6 \u2217\n\u2264\n\n6\u2264\u2217\n\nsd-DNNF\n\n\u2264\n\n\u2264\n6\n\u2264\n6\n\u2264\n\u2264\n\n6\u2264\u2217\n\n\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\nTable 12:\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\n\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n6\u2264\u2217\n6\u2264\u2217\n\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\n\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n6\u2264\n6\n\u2264\n\u2264\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n\u2264\n\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n\u2264\n\n6\u2264\n\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n6\n\u2264\n6\n\u2264\n6\n\u2264\n\n6\u2264\u2217\n\n6\u2264\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\u2217\n\n\u2264\n\nTable 13:\ndigraph represented by I contains a k-clique of a special kind (k is a parameter of the family). It is\nshown that for certain values of k (depending on n), every FBDD representation of \u03a3 has exponential\nsize. Moreover, it is shown that \u03a3 has only a cubic number of prime implicants. This shows that\nFBDD 6\u2264 IP, hence FBDD 6\u2264 DNF. Because FBDD satisfies \u00acC (see Proposition 5.1),8 it cannot be the\ncase that \u00ac\u03a3 has a polynomial size FBDD. Since \u00ac\u03a3 has only a cubic number of prime implicates, we\nobtain that FBDD 6\u2264 PI, hence FBDD 6\u2264 CNF. The remaining results in this table follow since FBDD\u2264\nOBDD \u2264 OBDD< .\nTable 14: Assume that d-DNNF \u2264 DNF holds. As a consequence, every sentence \u03a3 in DNF can be\ncompiled into an equivalent d-DNNF sentence \u03a3\u2217 of polynomial size. Now, checking whether a clause\n\u03b3 is entailed by the CNF sentence \u03a3 is equivalent to checking whether the DNF sentence \u00ac\u03a3 \u2228 \u03b3 is\nvalid. Checking whether (\u00ac\u03a3) \u2217 \u2228\u03b3 is valid-when (\u00ac\u03a3)\u2217 is a d-DNNF sentence and \u03b3 is a clause-can\nbe achieved in polynomial time by Lemma A.11. Therefore, (\u00ac\u03a3)\u2217 is a polysize compilation of the\n8. That is, a sentence in FBDD can be negated in polytime to yield a sentence in FBDD too.\n\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\n\n\u2264\n6\u2264\u2217\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n\u2264\n6\u2264\u2217\n\n6\u2264\n\n\u2264\n\u2264\n6 \u2217\n\u2264\n\n\u2264\n\n6 \u2217\n\u2264\n\n\u2264\n\u2264\n6 \u2217\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\nd-DNNF\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\n\n6\u2264\n6\u2264\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\nIP\nMODS\n\n6\u2264\n\nsd-DNNF\n\n6\u2264\u2217\n\n6\u2264\n6\u2264\n6\u2264\u2217\n\n\u2264\n\n\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\u2264\n\u2264\n\n6\u2264\n6\u2264\n\u2264\n\n6\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\nTable 14:\n\n249\n\n6\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\u2264\n6\u2264\u2217\n\n6 \u2217\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n6\u2264\n6\u2264\u2217\n\n\u2264\n6\u2264\n\n\u2264\n\n6\u2264\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n6\u2264\n\u2264\n\n\u2264\n\n6\u2264\n6\u2264\n\n6\u2264\n\n6\u2264\n6\u2264\n\n\u2264\n\u2264\n\n6\u2264\n\u2264\n\n\fDarwiche & Marquis\n\nL\n\nNNF\n\nDNNF\n\nd-DNNF\n\nFBDD\n\nOBDD\n\nOBDD<\n\nDNF\n\nCNF\n\nPI\n\nIP\n\nMODS\n\nsd-DNNF\n\nNNF\nDNNF\nd-DNNF\n\n\u2264\n6 \u2217\n\u2264\n6\u2264\u2217\n\n\u2264\n\u2264\n6\u2264\u2217\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n6\u2264\u2217\n\n\u2264\n6 \u2217\n\u2264\n6\u2264\u2217\n\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\n\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n\n6\u2264\n6\n\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n6\u2264\n\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\n6\u2264\n6\n\u2264\n\n6\u2264\n\u2264\n\n\u2264\n\n6\u2264\n\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\nsd-DNNF\n\n6\u2264\n6\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\n\u2264\n6\u2264\u2217\n\n6\u2264\n6\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\n\u2264\n6\u2264\u2217\n\n6\u2264\n6\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n\u2264\n\u2264\n6\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\u2264\n\u2264\n\n6\u2264\n6\u2264\n\u2264\n6\u2264\n6\n\u2264\n6\u2264\n\n6\n\u2264\n6\u2264\u2217\n\n\u2264\n6\n\u2264\n6\u2264\n\n6\n\u2264\n6\u2264\u2217\n\n\u2264\n\u2264\n6\u2264\n6\u2264\n\n6\u2264\n\n6\u2264\n6\n\u2264\n\u2264\n6\u2264\n\n\u2264\n\u2264\n\u2264\n\u2264\n\u2264\n\n\u2264\n\u2264\n\n6\u2264\n6\u2264\n6\n\u2264\n\n6\u2264\n6\u2264\n6\u2264\n\n6\u2264\n\u2264\n\nTable 15:\nCNF sentence \u03a3, allowing clausal entailment to be achieved in polynomial time. The existence of\nsuch (\u00ac\u03a3)\u2217 for every CNF sentence \u03a3 implies the collapse of the polynomial hierarchy (Selman &\nKautz, 1996; Cadoli & Donini, 1997). Hence, we obtain that d-DNNF 6\u2264\u2217 DNF. As a consequence, we\nalso have d-DNNF 6\u2264\u2217 DNNF. Finally, since every d-DNNF sentence can be turned in polynomial time\ninto an equivalent sd-DNNF sentence by Lemma A.1, we have sd-DNNF \u2264 d-DNNF. Moreover, since\nd-DNNF \u2264 sd-DNNF, we obtain sd-DNNF 6\u2264\u2217 DNF, sd-DNNF 6\u2264\u2217 DNNF, sd-DNNF \u2264 FBDD, sd-DNNF \u2264\nOBDD, sd-DNNF \u2264 OBDD< , FBDD 6\u2264 sd-DNNF, OBDD< 6\u2264 sd-DNNF, DNF 6\u2264 sd-DNNF, CNF 6\u2264 sd-DNNF, PI\n6\u2264 sd-DNNF and IP 6\u2264 sd-DNNF.\nTable 15: Let us now show that WMODS is not less succinct than PI, IP, sd-DNNF and OBDD.\nn\nFirst, let us consider the formula \u03a3 = i=1 xi . \u03a3 can be represented by PI, IP, sd-DNNF and OBDD\nformulas of size polynomial in n. Contrastingly, \u03a3 cannot be represented by a MODS formula of\nsize polynomial in n since \u03a3 has 2n \u2212 1 models over Vars(\u03a3). Now, it is well-known that the old\ngood Quine-McCluskey's algorithm for generating prime implicants from a MODS representation of\na propositional formula \u03a3 runs in time polynomial in the number of models of \u03a3 (Wegener, 1987).\nThis shows that IP \u2264 MODS. As to CNF and OBDD< , it is obvious that a decision tree (or Shannon tree)\nfor \u03a3 that respects a given total ordering over Vars(\u03a3) can be generated in polynomial time from a\nMODS representation of \u03a3. Such a decision tree has m 1-leaves where m is the number of models of\n\u03a3 over Vars(\u03a3). Accordingly, it has at most n \u2217 m 0-leaves where n = |Vars(\u03a3)|. Since the set of all\npaths from the root of the tree to any 0-leaf can be read as a CNF representation of \u03a3, we obtain that\nCNF \u2264 MODS. On the other hand, since reducing a decision tree to derive a corresponding OBDD<\ncan be done in polynomial time, it follows that an OBDD< representation of \u03a3 can also be generated\nfrom a MODS representation of it. Hence, OBDD< \u2264 MODS. The remaining results in this table follow\nfrom the language inclusions reported in Figure 4. \u2737\nProof of Proposition 4.1\nThe proof of this proposition is broken down into twelve steps. In each step, we prove a number\nof results. Associated with each step of the proof is a table in which we mark all results that are\nproved in that step. The table of the last step includes all results declared by this proposition.\nTable 16: Every classical CNF or DNF formula can be translated in a straightforward way into\nan equivalent f-NNF sentence (with a tree structure) in polytime. Moreover, every NNF sentence\ncan be translated into an equivalent s-NNF sentence in polytime (Lemma A.1). Given that CO\nis NP-hard (resp. VA is coNP-hard) for classical CNF (resp. DNF) sentences, and the inclusion\nbetween the various NNF subsets reported in Figure 4, we obtain the table.\nTable 17: SE implies both CO and VA (Lemma A.10). Moreover, since CT implies both CO\nand VA, IM implies VA (valid term), and CE implies CO (inconsistent clause), we obtain the\ntable.\n\n250\n\n\fA Knowledge Compilation Map\n\nL\n\nCO\n\nVA\n\nNNF\n\n\u25e6\n\n\u25e6\n\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\n\u25e6\n\ns-NNF\n\n\u25e6\n\nf-NNF\nsd-DNNF\n\n\u25e6\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nEQ\n\nCT\n\nSE\n\n\u25e6\n\n\u25e6\n\nME\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\nTable 16:\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nNNF\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\n\n\u25e6\n\ns-NNF\n\n\u25e6\n\nf-NNF\nsd-DNNF\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\nME\n\n\u25e6\n\n\u25e6\n\nTable 17:\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nCT\n\nSE\n\nNNF\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\n\u25e6\n\n\u221a\n\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\nEQ\n\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\nTable 18:\n\n251\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\nME\n\n\fDarwiche & Marquis\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\n\u221a\n\n\u221a\n\u25e6\n\u221a\n\nEQ\n\nCT\n\nSE\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\nME\n\n\u221a\n\n\u221a\n\n\u25e6\n\n\u221a\n\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\nCT\n\nSE\n\nME\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\nTable 19:\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\n\n\u25e6\n\n\u221a\n\u221a\n\u221a\n\u221a\n\nDNF\n\n\u221a\n\nCNF\nPI\n\n\u25e6\n\nIP\n\n\u221a\n\n\u221a\n\u221a\n\u221a\n\u25e6\n\nMODS\n\n\u221a\n\n\u221a\n\n\u25e6\n\n\u25e6\n\nsd-DNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u221a\n\ns-NNF\nf-NNF\n\nEQ\n\n\u25e6\n\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\n\u221a\n\u221a\n\u25e6\n\n\u25e6\n\u221a\n\n\u221a\n\u221a\n\n\u221a\n\u221a\n\n\u221a\n\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u221a\n\u221a\n\u25e6\n\u221a\n\n\u221a\n\u25e6\n\n\u221a\n\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\nTable 20:\nTable 18: A sentence \u03a3 is consistent (resp. valid) iff it has a model (resp. 2n models, where\nn = |Vars(\u03a3)|). Moreover, the number of models of \u03a3 is given by the number of edges outgoing\nfrom the or-node in any MODS representation of \u03a3. Accordingly, CO, VA and CT can be achieved\nin polynomial time when \u03a3 is given by a MODS formula which gives us the table.\nTable 19:Because DNNF satisfies CE (Darwiche, 2001a), CE implies CO and MODS \u2286 DNF \u2286\nDNNF, IP\u2286 DNF and\nsd-DNNF \u2286 d-DNNF \u2286 DNNF, we obtain the table.\nTable 20: We now use the following results:\nCD and CO imply CE (Lemma A.4).\nCD and VA imply IM (Lemma A.7).\nCD and CO imply ME (Lemma A.3).\nAll considered NNF subsets satify CD (cf. Proposition 5.1).\nIf an NNF subset does not satisfy CO it cannot satisfy ME.\nIt is well-known that FBDD satisfies CO, VA and CT, and that OBDD< satisfies (in addition)\nEQ (Gergov & Meinel, 1994a; Bryant, 1992).\nSince \u03a3 |= \u03b1 holds iff \u03a3 \u2227 \u00ac\u03b1 is inconsistent and since OBDD< satisfies CO, \u00acC and \u2227BC (cf.\nProposition 5.1), OBDD< also satisfies SE.\n252\n\n\fA Knowledge Compilation Map\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nCT\n\nSE\n\nME\n\nNNF\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u221a\n\u221a\n\u221a\n\n\u221a\n\u221a\n\u221a\n\nCNF\n\n\u25e6\n\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u221a\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\nEQ\n\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u221a\n\n\u25e6\n\u221a\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\n\u221a\n\u25e6\n\u25e6\n\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u221a\n\nCT\n\nSE\n\nME\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\nTable 21:\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nNNF\nDNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\nd-NNF\nd-DNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\nEQ\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\n\u25e6\n\n\u221a\n\u221a\n\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u221a\n\nTable 22:\nObviously enough, any query concerning OBDD is equivalent to the corresponding query concerning OBDD< provided that only one DAG is brought into play. Together with the above\nresults, we conclude that OBDD satisfies CO, VA and CT. Since this fragment satisfies CD as\nwell, it satisfies CE, IM and ME in addition. It also satisfies EQ (see Theorem 8.11 from\n(Meinel & Theobald, 1998)) but does not satisfy SE (unless P = NP). Indeed, it is known\nthat checking the consistency of two OBDD< formulas \u03b1 and \u03b2 (based on two different variable orderings <) is NP-complete (Lemma 8.14 from (Meinel & Theobald, 1998)). Since OBDD\nsatisfies \u00acC and since \u03b1 \u2227 \u03b2 is consistent iff \u03b1 6|= \u00ac\u03b2, checking sentential entailment for OBDD\nformulas is coNP-complete.\nThese results lead to the table.\nTable 21: It is known that IM is satisfied by classical CNF formulas (hence, PI) (in order to\ncheck whether a non-valid clause is implied by a consistent term, it is sufficient to test that they\nshare a literal). CNF (hence, PI) is also known to satisfy VA. We then obtain the table.\nTable 22: Every sentence in CNF or DNF can be turned into an equivalent sentence in BDD in\npolytime (Lemma A.8). Hence, a \u25e6 in a CNF or DNF cell implies a \u25e6 in the corresponding BDD cell.\nSimilarly, since BDD \u2286 d-NNF, a \u25e6 in a BDD cell implies a \u25e6 in the corresponding d-NNF cell. This\nleads to the table.\nTable 23: Since EQ implies CO and VA (Lemma A.9), a \u25e6 in a CO or VA cell implies a \u25e6 in\nthe corresponding EQ cell. This leads to the table.\nTable 24: By definition, PI satisfies CE and IP satisfies IM. Since PI \u2286 CNF and IP \u2286 DNF,\nthis implies that both PI and IP satisfy SE. Now, SE implies EQ, hence both PI and IP satisfy EQ\n(actually, two equivalent formulas share the same prime implicates and the same prime implicants\n(both forms are canonical ones, provided that one representative per equivalence class is considered,\n253\n\n\fDarwiche & Marquis\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nME\n\nNNF\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\nDNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\nd-NNF\nd-DNNF\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\nBDD\nFBDD\nOBDD\nOBDD<\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\nDNF\nCNF\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u221a\n\u221a\n\u221a\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u221a\n\n\u221a\n\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u221a\n\u221a\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\n\u221a\n\u25e6\n\n\u221a\n\n\u25e6\n\nTable 23:\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nME\n\nNNF\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\nTable 24:\n\n254\n\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\fA Knowledge Compilation Map\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nME\n\nNNF\nDNNF\nd-NNF\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u221a\n\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\n\u221a\n\n\u25e6\n\u221a\n\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\nTable 25:\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nME\n\nNNF\nDNNF\nd-NNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\n\u25e6\n\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\nTable 26:\nonly)). Since PI satisfies CE, it also satisfies CO. Since it satisfies CD as well (cf. Proposition 5.1),\nit also satisfies ME (Lemma A.3). Contrastingly, the models counting problem for monotone Krom\nformulas (i.e. conjunctions of clauses containing at most two literals and only positive literals)\nis #P-complete (Roth, 1996). Such formulas can easily be turned into prime implicates form in\npolynomial time (Marquis, 2000), hence PI does not satisfy CT. Now, since the negation of a\nformula \u03a3 in prime implicates form is a formula in prime implicants form (cf. Lemma A.14), and\nsince the number of models of \u00ac\u03a3 over Vars(\u03a3) is 2|Vars(\u03a3)| minus the number of models of \u03a3 over\nVars(\u03a3), we necessarily have that IP does not satisfy CT. This also imply that IP satisfies VA,\nleading to the table.\nTable 25: In the proof of Proposition 3.1, we have shown that the prime implicants of \u03a3 can\nbe computed in polytime from a MODS representation of \u03a3. As an immediate consequence, since IP\nsatisfies IM, EQ and SE, we obtain that MODS satisfies IM, EQ and SE, leading to the table.\nTable 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA. Since it satisfies\nCD (Proposition 5.1), it also satisfies IM as well (Lemma A.7). Since sd-DNNF \u2286 d-DNNF, these\nresults follow for sd-DNNF. Hence, we obtain the table.\nTable 27: It is known that determining whether the conjunction of two FBDD formulas \u03b11 and \u03b12\nis consistent is NP-complete (Gergov & Meinel, 1994b) Moreover, FBDD satisfies \u00acC. Since \u03b11 \u2227 \u03b12\nis inconsistent iff \u03b11 |= \u00ac\u03b12 , we can reduce the consistency test into an entailment test. Hence, FBDD\ndoes not satisfy SE. Since FBDD \u2286 d-DNNF, d-DNNF does not satisfy SE either. Finally, since every\nd-DNNF can be translated into an equivalent sd-DNNF sentence in polytime (Lemma A.1), sd-DNNF\ndoes not satisfy SE either. This leads to the final table above. \u2737\n\n255\n\n\fDarwiche & Marquis\n\nL\n\nCO\n\nVA\n\nCE\n\nIM\n\nEQ\n\nCT\n\nSE\n\nME\n\nNNF\nDNNF\nd-NNF\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\nd-DNNF\nBDD\nFBDD\nOBDD\nOBDD<\nDNF\nCNF\nPI\nIP\nMODS\ns-NNF\nf-NNF\nsd-DNNF\n\n\u25e6\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\u221a\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\u25e6\n\u221a\n\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u221a\n\u25e6\n\u221a\n\u221a\n\u221a\n\u25e6\n\u25e6\n\u221a\n\nTable 27:\nProof of Proposition 5.1\nThe proof of this proposition is broken down into eight steps. Each step corresponds to one of the\ntransformations, where we prove all results pertaining to that transformation.\n\u2022 CD. To show that a language L satisfies CD, we want to show that for any sentence \u03a3 \u2208 L\nand any consistent term \u03b3, we can construct in polytime a sentence which belongs to L and is\nequivalent to \u03a3 | \u03b3.\n\u2013 NNF, f-NNF, CNF and DNF. The property is trivially satisfied by these languages: If \u03a3\nbelongs to any of these languages, then replacing the literals of \u03b3 by a Boolean constant\nin \u03a3 results a sentence in the same language. In the case of DNF (resp. CNF), some\ninconsistent terms (valid clauses) may result through conditioning, but these can be\nremoved easily in polynomial time.\n\u2013 DNNF. It is sufficient to prove that conditioning preserves decomposability. For every\npropositional sentences \u03b1, \u03b2 and every consistent term \u03b3, if \u03b1 and \u03b2 do not share variables,\nthen \u03b1|\u03b3 and \u03b2|\u03b3 do not share variables either since Vars(\u03b1|\u03b3) \u2286 Vars(\u03b1) and Vars(\u03b2|\u03b3) \u2286\nVars(\u03b2).\n\u2013 d-NNF and d-DNNF. Since NNF and DNNF satisfy CD, it is sufficient to prove that conditioning preserves determinism, i.e. for every propositional formulas \u03b1, \u03b2 and every consistent\nterm \u03b3, if \u03b1 \u2227 \u03b2 |= false, then (\u03b1|\u03b3) \u2227 (\u03b2|\u03b3) |= false. If \u03b1 \u2227 \u03b2 |= false, then for every term\n\u03b3, we have (\u03b1 \u2227 \u03b2) \u2227 \u03b3 |= false. Since (\u03b1 \u2227 \u03b2) \u2227 \u03b3 \u2261 ((\u03b1 \u2227 \u03b2)|\u03b3) \u2227 \u03b3, this implies that\n((\u03b1 \u2227 \u03b2)|\u03b3) \u2227 \u03b3 |= false. Since \u03b3 is consistent and share no variable with (\u03b1 \u2227 \u03b2)|\u03b3, it must\nbe the case that (\u03b1 \u2227 \u03b2)|\u03b3 is inconsistent. This is equivalent to state that (\u03b1|\u03b3) \u2227 (\u03b2|\u03b3) |=\nfalse.\n\u2013 s-NNF and sd-DNNF. Since NNF satisfies CD, and since conditioning preserves decomposability and determinism, all we have to show is that conditioning also preserves smoothness. This follows immediately since for two propositional sentences \u03b1, \u03b2 and a consistent\nterm \u03b3, we have Vars(\u03b1) = Vars(\u03b2) only if Vars(\u03b1 | \u03b3) = Vars(\u03b2 | \u03b3).\n\n\u2013 BDD, FBDD, OBDD and OBDD< . It is well\u2013known that BDD satisfies CD-the conditioning\noperation on binary decision diagrams is known as the restrict operation (Bryant, 1986).\nTo condition a sentence \u03a3 in BDD on a consistent term \u03b3, we replace every node labeled\nby a variable in \u03b3 by one of its two children, according to the sign of the variable in \u03b3.\nThe resulting sentence is also a BDD and is equivalent to \u03a3 | \u03b3. The same applies to FBDD,\nOBDD and OBDD< .\n\n\u2013 PI. The prime implicates of \u03a3 \u2227 \u03b3 can be computed in polytime when \u03a3 is in prime\nimplicates form and \u03b3 is a term (see Proposition 36 in (Marquis, 2000)). Moreover, since\n256\n\n\fA Knowledge Compilation Map\n\nPI satisfies FO (see below), the prime implicates of \u2203Vars(\u03b3).(\u03a3 \u2227 \u03b3) can be computed in\npolytime. But these are exactly the prime implicates of \u03a3 | \u03b3 according to Lemma A.12.\nWn\n\u2013 IP.\nWnLet \u03a3 = i=1 \u03b3i be a formula in prime implicants form. It is clear that the formula\n( i=1 \u03b3i ) | \u03b3 is a DNF formula equivalent to \u03a3 | \u03b3. Now, our claim is\nWnthat the formula \u03a3\u2217\nobtained by keeping only the logically weakest terms \u03b3i | \u03b3 among ( i=1 \u03b3i ) | \u03b3 is a prime\nimplicants formula equivalent to \u03a3 | \u03b3. Removing such terms clearly is truth-preserving.\nSince generating \u03a3\u2217 requires only O(n2 ) entailment tests among terms, and since such\ntests can be easily achieved in polynomial time, we obtain that IP satisfies CD. Now,\nhow to prove that \u03a3\u2217 is in prime implicants form? Since any pair of different terms of\n\u03a3\u2217 cannot be compared w.r.t. logical entailment, the correctness of Quine's consensus\nalgorithm for generating prime implicants shows that it is sufficient to prove that every\nconsensus among two terms of \u03a3\u2217 is inconsistent or entails another term of \u03a3\u2217. Let's\nrecall that consensus is to DNF formulas what resolution is to CNF formulas. Since \u03a3\nis in prime implicants form, every consensus among two terms of \u03a3 is inconsistent or\nentails another term of \u03a3. What happens to the terms (here, the prime implicants) of \u03a3\nwhen conditioned by \u03b3? All those containing the negation of a literal of \u03b3 are removed\nand the remaining ones are shortened by removing from them every literal of \u03b3. Hence,\nfor every pair of terms \u03b31 , \u03b32 of \u03a3, if there is no consensus between \u03b31 and \u03b32 , then\nthere is no consensus between \u03b31 |\u03b3 and \u03b32 |\u03b3: conditioning cannot create new consensus.\nNow, it remains to prove that no unproductive consensus between terms of \u03a3 can be\nrendered productive through conditioning. Formally, let \u03b31 = \u03b31\u2032 \u2227 l and \u03b32 = \u03b32\u2032 \u2227 \u00acl be\ntwo prime implicates of \u03a3 s.t. l (resp. \u00acl) does not appear in \u03b31\u2032 (resp. \u03b32\u2032 ). There is a\nconsensus \u03b31\u2032 \u2227\u03b32\u2032 between \u03b31 and \u03b32 . Let us assume that both \u03b31 and \u03b32 have survived the\nconditioning: this means that both \u03b31 |\u03b3 and \u03b32 |\u03b3 are consistent. Especially, l belongs to\n\u03b31 |\u03b3 and \u00acl belongs to \u03b32 |\u03b3. Accordingly, there is a consensus between \u03b31 |\u03b3 and \u03b32 |\u03b3. By\nconstruction, this consensus is equivalent to (\u03b31\u2032 |\u03b3)\u2227(\u03b32\u2032 |\u03b3), hence equivalent to (\u03b31\u2032 \u2227\u03b32\u2032 )|\u03b3.\nNow, if \u03b31\u2032 \u2227 \u03b32\u2032 is inconsistent, then (\u03b31\u2032 \u2227 \u03b32\u2032 )|\u03b3 is inconsistent as well and we are done.\nOtherwise, let us assume that there exists a prime implicant \u03b33 of \u03a3 s.t. \u03b31\u2032 \u2227 \u03b32\u2032 |= \u03b33\nholds. Necessarily, \u03b33 is preserved by the conditioning of \u03a3 by \u03b3. Otherwise, \u03b33 would\ncontain the negation of a literal of \u03b3, but since every literal of \u03b33 is a literal of \u03b31 or a\nliteral of \u03b32 , \u03b32 and \u03b33 would not have both survived the conditioning. Since \u03b31\u2032 \u2227 \u03b32\u2032 |= \u03b33\nholds, we necessarily have (\u03b31\u2032 \u2227 \u03b32\u2032 )|\u03b3 |= \u03b33 |\u03b3. This completes the proof.\n\n\u2013 MODS. Direct consequence of Lemma A.12 and the fact that MODS satisfies \u2227BC and FO\n(see below).\n\u2022 FO.\n\u2013 DNNF and DNF. It is known that DNNF satisfies FO (Darwiche, 2001a). It is also known\nthat DNF satisfies FO (Lang et al., 2000).\n\n\u2013 NNF, s-NNF, f-NNF, d-NNF, BDD and CNF. Let \u03a3 be a sentence in CNF. We now show that\nif any of the previous languages satisfies FO, then we can test the consistency of \u03a3 in\npolytime. Since CNF does not satisfy CO (see Proposition 4.1), it then follows that none\nof the previous languages satisfy FO unless P = NP. First, we note that \u03a3 must also\nbelong to NNF and f-NNF. Moreover, \u03a3 can be turned into a sentence in BDD in polytime\n(Lemma A.8) or a sentence in s-NNF in polytime (see the proof of Lemma A.1). We\nalso have that \u03a3 can be turned into a sentence in d-NNF in polytime since BDD \u2286 d-NNF.\nSuppose now that one of the previous languages, call it L, satisfy FO. We can test the\nconsistency of \u03a3 in polytime as follows:\n\u2217 Convert \u03a3 into a sentence \u03a3\u2217 in L in polytime (as shown above).\n\u2217 Compute \u2203Vars(\u03a3\u2217).\u03a3\u2217, which can be done in polytime by assumption.\n257\n\n\fDarwiche & Marquis\n\n\u2217 Test the validity of \u2203Vars(\u03a3\u2217).\u03a3\u2217, which can be done in polytime since the sentence\ncontains no variables-all we have to do is check whether the sentence evaluates to\ntrue.\nFinally, note that the definition of forgetting implies that a sentence \u0393 is consistent iff\n\u2203Vars(\u0393).\u0393 is valid, which completes the proof.\n\n\u2013 d-DNNF and sd-DNNF. Follows immediately since none of these languages satisfies SFO\nunless P = NP (see below).\n\u2013 IP. Follows immediately since IP does not satisfy SFO.\n\u2013 FBDD, OBDD and OBDD< . We will show that if FBDD (resp. OBDD, OBDD< ) satisfies FO,\nthen for every sentence \u0393 in DNF, there must exist an equivalent sentence \u03a3 in FBDD (resp.\nOBDD, OBDD< ), which size is polynomial in the size of \u0393. This contradicts the fact that\nFBDD (resp. OBDD, OBDD< ) 6\u2264 DNF-see Table 3.\nGiven a DNF \u0393 consisting of terms \u03b31 , ..., \u03b3n , we can convert each of these terms into equivalent FBDD (resp. OBDD, OBDD< ) sentences \u03b11 , . . . , \u03b1n in polytime. Let {v1 , . . . , vn\u22121 }\nbe a set of variables that do not belong to P S. Construct a new set of variables\nP S \u2032 = P S \u222a {v1 , . . . , vn\u22121 }. In case of OBDD and OBDD< , we also assume that these\nnew variables are earlier than variables P S in the ordering. Consider now the sentence\n\u03a3 = \u2203{v1 , . . . , vn\u22121 }.\u22061 , with respect to variables P S \u2032 , where \u2206i is inductively defined\nby:\n\u2217 \u2206i = \u03b1i , for i = n, and\n\u2217 \u2206i = (\u03b1i \u2227 vi ) \u2228 (\u2206i+1 \u2227 \u00acvi ), for i = 1, . . . , n \u2212 1.\n\nClearly enough, an FBDD (resp. OBDD, OBDD< ) sentence equivalentWto \u22061 can W\nbe computed\nn\nn\nin time polynomial in the input size. Moreover, we have \u03a3 \u2261 i=1 \u03b1i \u2261 i=1 \u03b3i \u2261 \u0393.\nHence, if FBDD (resp. OBDD, OBDD< ) satisfies FO, then we can convert the DNF sentence \u0393\ninto an equivalent FBDD (resp. OBDD, OBDD< ) which size is polynomial in the size of the\ngiven DNF. This is impossible in general.\n\u2013 PI. It is known that the prime implicates of \u2203X.\u03a3 are exactly the prime implicates of \u03a3\nthat do not contain any variable from X (see Proposition 55 in (Marquis, 2000)). Hence,\nsuch prime implicates can be computed in time polynomial in the input size when \u03a3 is\nin prime implicates form.\n\u2013 MODS. Given a MODS formula \u03a3 and a subset X of P S, the formula obtained by removing\nevery leaf node (and the corresponding incoming edges) of \u03a3 labeled by a literal x or \u00acx\ns.t. x \u2208 X is a MODS representation of \u2203X.\u03a3-this is an easy consequence of Propositions\n18 and 20 from (Lang et al., 2000). See also the polytime operation of forgetting on DNNF,\nas defined in (Darwiche, 2001a), which applies to MODS, since\nMODS \u2286 DNNF, and which can be easily modified so it guarantees that the output is in\nMODS when the input is also in MODS.\n\u2022 SFO.\n\u2013 DNNF, DNF, PI and MODS. Immediate from the fact that each of these languages satisfies\nFO (see above).\n\u2013 NNF, d-NNF, s-NNF, f-NNF, BDD, OBDD< and CNF. Direct from the fact that \u2203x.\u03a3 \u2261 (\u03a3|x) \u2228\n(\u03a3|\u00acx) holds and the fact that any of these fragments satisfies CD and \u2228BC.\n\n\u2013 OBDD. Direct from the fact that only one OBDD sentence is considered in the transformation\nand OBDD< satisfies SFO.\n\n\u2013 d-DNNF, sd-DNNF and FBDD. Let \u03b11 and \u03b12 be two FBDD formulas. Let x be a variable\nnot included in Vars(\u03b11 ) \u222a Vars(\u03b12 ). The formula \u03a3 = (x \u2227 \u03b11 ) \u2228 (\u00acx \u2227 \u03b12 ) is a FBDD\n258\n\n\fA Knowledge Compilation Map\n\nformula since decomposability and decision are preserved by this construction. Since \u2203x.\u03a3\nis equivalent to \u03b11 \u2228 \u03b12 , if FBDD would satisfy SFO, it would satisfy \u2228BC as well, but\nthis is not the case unless P = NP (see below). The same conclusion can be drawn for\nd-DNNF. Hence, FBDD and d-DNNF do not satisfy SFO unless P = NP. Since every d-DNNF\nformula can be turned in polynomial time into an equivalent sd-DNNF formula, we obtain\nthat sd-DNNF does not satisfy SFO unless P = NP.\n\u2013 IP. Let us show that the number of prime implicants of \u2203x.\u03a3 can be exponentially greater\nthan the number of prime implicants of \u03a3. Let \u03a3\u2032 be the following DNF formula:\n\uf8eb\n\n\u03a3\u2032 = \uf8ed\n\nm\nk _\n_\n\ni=1 j=1\n\n\uf8f6\n\n(pi \u2227 qi,j )\uf8f8 \u2228\n\nk\n^\n\ni=1\n\n\u00acpi .\n\n\u03a3\u2032 has (m + 1)k + mk primes implicants (Chandra & Markowsky, 1978). Now, let \u03a3 be\nthe formula:\n\uf8eb\n\n\u03a3=\uf8ed\n\nm\nk _\n_\n\ni=1 j=1\n\n\uf8f6\n\n(x \u2227 pi \u2227 qi,j )\uf8f8 \u2228 (\u00acx \u2227\n\nk\n^\n\ni=1\n\n\u00acpi ).\n\nSince \u03a3\u2032 can be obtained from \u03a3 by removing in every term of \u03a3 every occurrence of x\nand \u00acx, \u03a3\u2032 is equivalent to \u2203{x}.\u03a3 (see (Lang et al., 2000)). Now, \u03a3 has only mk + 1\nprime implicants; indeed, every term of it is a prime implicant, and the converse holds\nsince every term is maximal w.r.t. logical entailment and every consensus of two terms\nis inconsistent. This completes the proof.\n\u2022 \u2227C.\n\u2013 NNF, s-NNF, d-NNF, CNF. The property is trivially satisfied by these languages since determinism and smoothness are only concerned with or-nodes. Hence, if \u03b11 , . . . , \u03b1n belong to\none of these languages, so is \u03b11 \u2227 . . . \u2227 \u03b1n .\n\u2013 BDD. It is well\u2013known that the conjunction of two BDDs \u03b1 and \u03b2 can be easily computed\nby connecting the 1-sink of \u03b1 to the root of \u03b2 (see proof of Lemma A.8). The size of the\nresulting BDD is just the sum of the sizes of the respective BDDs of \u03b1 and \u03b2. Accordingly,\nwe can repeat this operation n times in time polynomial in the input size.\n\u2013 f-NNF. Direct from the fact that f-NNF does not satisfy \u2227BC.\n\n\u2013 FBDD, OBDD, OBDD< , DNF, PI and IP. It is straightforward to convert a clause into an\nequivalent formula in any of these languages in polynomial time. In the proof of Proposition 3.1, we show specific CNF formulas which cannot be turned into an equivalent FBDD\n(resp. OBDD, OBDD< , DNF, PI and IP) formulas in polynomial space (see Tables 9 and 10).\nHence, such conversion cannot be accomplished in polynomial time either. This implies\nthat none of FBDD, OBDD, OBDD< , DNF, PI and IP satisfies \u2227C.\n\u2013 DNNF, d-DNNF and sd-DNNF. Direct from the fact that none of these languages satisfy\n\u2227BC unless\nP = NP.\nVn\n\u2013 MODS. Let \u03a3 = i=1 \u03a3i , where \u03a3i = (xi,1 \u2228 xi,2 ), i \u2208 1..n. Each \u03a3i has 3 models over\nVars(\u03a3i ). Since \u03a3 has 3n models, it does not have a MODS representation of size polynomial\nin the input size.\n\n\u2022 \u2227BC.\n\n259\n\n\fDarwiche & Marquis\n\n\u2013 NNF, s-NNF, d-NNF, BDD and CNF. Immediate since each of these languages satisfy \u2227C (see\nabove).\n\u2013 DNNF, d-DNNF, sd-DNNF, FBDD and OBDD. Checking whether the conjunction of two OBDD<\nformulas \u03b11 and \u03b12 (w.r.t. two different variable orderings <) is consistent is NP-complete\n(see Lemma 8.14 in (Meinel & Theobald, 1998)). Since OBDD satisfies CO, it cannot satisfy\n\u2227BC unless P = NP. Since OBDD \u2286 FBDD \u2286 d-DNNF \u2286 DNNF, and d-DNNF and DNNF satisfy\nCO, none of them can satisfy \u2227BC unless P = NP. Finally, since every d-DNNF formula\ncan be turned in polynomial time into an equivalent smoothed d-DNNF formula and since\nsd-DNNF satisfies CO, it cannot be the case that sd-DNNF satisfy \u2227BC unless P = NP.\n\n\u2013 OBDD< . Well-known fact (Bryant, 1986).\nWn\u22121\nVn\u22121\n\u2013 f-NNF. Let \u03b11 = i=0 (x2i \u2228 x2i+1 ) be a CNF formula and \u03b12 = i=0 (x\u20322i \u2227 x\u20322i+1 ) a DNF\nformula. \u03b11 has 2n essential prime implicants and n essential prime implicates (see the\nproof of Proposition 3.1, Table 9). By duality, \u03b12 has n essential prime implicants and 2n\nessential prime implicates. Now, \u03b11 and \u03b12 are two f-NNF formulas. By Lemma A.13, we\nknow that every f-NNF formula \u03b2 can be turned in polynomial time into a CNF formula or\na DNF formula. If f-NNF would satisfy \u2227BC, then a f-NNF formula \u03b2 s.t. \u03b2 \u2261 \u03b11 \u2227\u03b12 could\nbe computed in time polynomial in the input size. Hence, either a CNF formula equivalent\nto \u03b11 \u2227 \u03b12 or a DNF formula equivalent to \u03b11 \u2227 \u03b12 could be computed in polytime. But\nthis is impossible since \u03b11 \u2227 \u03b12 has n + 2n essential prime implicates and n \u2217 2n essential\nprime implicants. Hence every CNF (resp. DNF ) formula equivalent to \u03b11 \u2227 \u03b12 has a size\nexponential in |\u03b11 | + |\u03b12 |.\nNote that in the case where the two f-NNF formulas \u03b11 and \u03b12 into consideration can\nbe turned in polynomial time into either two CNF formulas or two DNF formulas, then a\nf-NNF formula equivalent to \u03b11 \u2227 \u03b12 can be computed in time polynomial in the input\nsize (this is obvious when two CNF formulas are considered and the next item of the proof\nshows how this can be achieved when two DNF formulas are considered).\n\n\u2013 DNF and MODS. If \u03b11 and \u03b12 are sentences in one of these languages L, then we can construct\na sentence in L which is equivalent to \u03b11 \u2227 \u03b12 by simply taking all the conjunctions of one\nterm from \u03b11 and one term from \u03b12 , while removing redundant literals in the resulting\nterms and removing any inconsistent terms in the result. The disjunction of all the\nresulting terms is a sentence from L equivalent to \u03b11 \u2227 \u03b12 and it has been computed in\npolynomial time.\nWk\nVk Vm\n\u2013 PI. Let \u03b11 = i=1 pi and \u03b12 = i=1 j=1 (\u00acpi \u2228qi,j ). Sentence \u03b11 has one prime implicate\nand \u03b12 has m \u2217 k prime implicates. But \u03b11 \u2227 \u03b12 has (m + 1)k + m \u2217 k prime implicates\n(Chandra & Markowsky, 1978).\n\u2013 IP. Let IP (\u03b1) be the set of prime implicants for \u03b1. We have IP (\u03b11 \u2227 \u03b12 ) = max({\u03b21 \u2227\n\u03b22 | \u03b21 \u2208 IP (\u03b11 ), \u03b22 \u2208 IP (\u03b12 )}, |=) (up to logical equivalence). See e.g., (dual of) Proposition 40 in (Marquis, 2000).\n\n260\n\n\fA Knowledge Compilation Map\n\n\u2022 \u2228C.\n\u2013 NNF, s-NNF, DNNF and DNF. The property is trivially satisfied by these languages since\ndecomposability is only concerned with and-nodes, and since every NNF formula can be\nturned in polynomial time into an equivalent smoothed NNF formula.\n\u2013 d-NNF and BDD. Direct consequence from the fact that d-NNF and BDD satisfies both \u2227C\nand \u00acC. Especially, it is well-known that the disjunction of two BDDs \u03b1 and \u03b2 can\nbe easily computed by connecting the 0-sink of \u03b1 to the root of \u03b2 (see the proof of\nLemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective\nBDDs of \u03b1 and \u03b2. Accordingly, we can repeat this operation n times in time polynomial\nin the input size.\n\u2013 f-NNF. Since f-NNF does not satisfy \u2227C but satisfies \u00acC, it cannot satisfy \u2228C (due to\nDe Morgan's laws).\n\u2013 FBDD, OBDD, OBDD< , CNF, PI, IP and MODS. It is straightforward to convert any term into\nan equivalent formula from any of the previous languages in polynomial time. In the\nproof of Proposition 3.1, we show specific DNF formulas which cannot be turned into\nequivalent FBDD (resp. OBDD, OBDD< , CNF , PI, IP and MODS) formulas in polynomial space\n(see Tables 9, 10 and 15). Hence, the conversion cannot be accomplished in polynomial\ntime either. This implies that none of FBDD, OBDD, OBDD< , CNF, PI, IP and MODS satisfies\n\u2228C.\n\n\u2013 d-DNNF and sd-DNNF. Immediate form the fact that none of these classes satisfies \u2228BC\nunless P = NP (see below).\n\u2022 \u2228BC.\n\u2013 NNF, d-NNF, DNNF, s-NNF, BDD and DNF. Immediate since each of these languages satisfies\n\u2228C.\n\u2013 OBDD< . Well-known fact (Bryant, 1986).\n\n\u2013 OBDD, FBDD, d-DNNF and sd-DNNF. Checking whether the conjunction of two OBDD< formulas \u03b11 and \u03b12 (w.r.t. two different variable orderings <) is consistent is NP-complete (see\nLemma 8.14 in (Meinel & Theobald, 1998)). Now, \u03b11 \u2227 \u03b12 is inconsistent iff \u00ac\u03b11 \u2228 \u00ac\u03b12\nis valid. Since OBDD satisfies \u00acC, an OBDD formula equivalent to \u00ac\u03b11 (resp. \u00ac\u03b12 ) can\nbe computed in time polynomial in |\u03b11 | (resp. |\u03b12 |). Since OBDD \u2286 FBDD \u2286 d-DNNF, the\nresulting formulas are also FBDD and d-DNNF formulas. If OBDD (resp. FBDD, d-DNNF)\nwould satisfy \u2228BC, then an OBDD (resp. FBDD, d-DNNF) formula equivalent to \u00ac\u03b11 \u2228 \u00ac\u03b12\ncould be computed in time polynomial in |\u03b11 | + |\u03b12 |. But since d-DNNF satisfies VA,\nthis is impossible unless P = NP. Finally, since every d-DNNF formula can be turned in\npolynomial time into an equivalent sd-DNNF formula, sd-DNNF cannot satisfy \u2228BC unless\nP = NP.\n\u2013 f-NNF. Since f-NNF does not satisfy \u2227BC but satisfies \u00acC, it cannot satisfy \u2228BC (due\nto De Morgan's laws).\n\u2013 CNF. If \u03b11 and \u03b12 are two CNF sentences, then we can construct a CNF sentence which\nis equivalent to \u03b11 \u2228 \u03b12 by simply taking all the disjunctions of one clause from \u03b11 and\none clause from \u03b12 , while removing redundant literals inside the resulting clauses and\nremoving any valid clause in the result. The conjunction of all the resulting clauses is a\nCNF sentence equivalent to \u03b11 \u2228 \u03b12 , and it has been computed in polynomial time.\n\u2013 PI. Let PI (\u03b1) be the set of prime implicates for sentence \u03b1. We have PI (\u03b11 \u2228 \u03b12 ) =\nmin({\u03b21 \u2228 \u03b22 | \u03b21 \u2208 PI (\u03b11 ), \u03b22 \u2208 PI (\u03b12 )}, |=). See Proposition 40 in (Marquis, 2000).\n\n261\n\n\fDarwiche & Marquis\n\nVk\nWk Wm\n\u2013 IP. Let \u03b11 = i=1 pi and \u03b12 = i=1 j=1 (\u00acpi \u2227qi,j ). Sentence \u03b11 has one prime implicant\nand \u03b12 has m \u2217 k prime implicants. But \u03b11 \u2228 \u03b12 has (m + 1)k + m \u2217 k prime implicants\n(Chandra & Markowsky, 1978).\nVn\n\u2013 MODS. Let \u03b11 = i=1 xi and \u03b12 = y. Sentence \u03b11 has 1 model over Vars(\u03b11 ) and \u03b12 has\n1 model over Vars(\u03b12 ). But \u03b11 \u2228 \u03b12 has 2n + 1 models over Vars(\u03b11 ) \u222a Vars(\u03b12 ).\n\u2022 \u00acC.\n\u2013 NNF, s-NNF, f-NNF, BDD, FBDD, OBDD and OBDD< . The property is obviously satisfied by\nNNF. s-NNF also satisfies \u00acC since every NNF formula can be turned in polynomial time\ninto an equivalent s-NNF formula. f-NNF satisfies \u00acC since applying De Morgan's laws\non a f-NNF formula results in a f-NNF formula. Finally, for all the forms of BDDs, it is\nsufficient to switch the labels of the sinks to achieve negation (Bryant, 1986).\n\u2013 CNF. Because the negation of a DNF formula is a CNF formula that can be computed in\npolynomial time, if CNF would satisfy \u00acC, then it would be possible to turn any DNF\nformula into an equivalent CNF formula in polynomial time (by involution of negation).\nBut we know that it is not possible in polynomial space since CNF 6\u2264 DNF(see the proof of\nProposition 3.1). Hence, CNF does not satisfy \u00acC.\n\n\u2013 DNF. Dual of the proof just above (just replace CNF by DNF and vice-versa).\nVn\u22121\n\u2013 PI. The formula \u03a3n = i=0 (x2i \u2228 x2i+1 ) is in prime implicates form (see the proof of\nProposition 3.1, Table 9). This formula has exponentially many prime implicants, that\nare just the negations of the prime implicates of \u00ac\u03a3n . Since \u00ac\u03a3n has exponentially many\nprime implicates, it cannot be the case that PI satisfies \u00acC.\n\n\u2013 IP. We just have to take the dual of the above proof (prime implicates case). The formula\nWn\u22121\n\u03a3n = i=0 (x2i \u2227x2i+1 ) is in prime implicants form. This formula has exponentially many\nprime implicates, that are just the negations of the prime implicants of \u00ac\u03a3n . Since \u00ac\u03a3n\nhas exponentially many prime implicants, it cannot be the case that IP satisfies \u00acC.\n\u2013 DNNF. The negation of any CNF formula can be computed in polynomial time as a DNF\nformula, hence as a DNNF formula. If DNNF would satisfy \u00acC, then it would be possible\nto turn a CNF formula into an equivalent DNNF one (by involution of negation). Because\nDNNF satisfies CO, we would have P = NP.\n\n\u2013 d-NNF. Following is a procedure for negating a d-NNF sentence \u2206:9\n\u2217 Traverse nodes in the DAG of \u2206, visiting the children of a node before you visit the\nnode itself. When visiting a node, construct its negation as follows:\n* true is the negation of false.\n* false is the negation of true.\n* \u2227(N1\u2032 , . . . , Nk\u2032 ) is the negation of \u2228(N1 , . . . , Nk ). Here, Ni\u2032 is the node representing\nthe negation of Ni .\n* \u2228(\u2227(N1\u2032 , M1 ), . . . , \u2227(Nk\u2032 , Mk )) is the negation of \u2227(N1 , . . . , Nk ). Here, Ni\u2032 is the\nnode representing the negation of Ni , and Mi is a node representing the conjunction N1 \u2227 . . . \u2227 Ni\u22121 .\n\u2217 Return the negation of the root of d-NNF \u2206.\n\nWe can implement the above four steps so that we when we visit a node with k children,\nwe only construct O(k) nodes and O(k) edges.10 Hence, the procedure complexity is\n9. Mark Hopkins pointed us to this procedure.\n10. We assume that any or-node (resp. and-node) with less than two children is removed and replaced by its unique\nchild or by f alse (resp. true) if it has no children. This simplification process is equivalence-preserving and it\ncan be achieved in time linear in the size of the input DAG.\n\n262\n\n\fA Knowledge Compilation Map\n\nlinear in the size of the original d-NNF. It is easy to check that the result is equivalent to\nthe negation of the given d-NNF sentence and is also in d-NNF.\n\u2013 sd-DNNF and d-DNNF. Unknown.\nVn\nSn\n\u2013 MODS. \u03a3 = Si=1 xi has only one model over i=1 {xi } but its negation \u00ac\u03a3 has 2n \u2212 1\nn\nmodels over i=1 {xi }. Hence MODS cannot satisfy \u00acC. \u2737\n\nReferences\nA. Cimmati, E. Giunchiglia, F. G., & Traverso, P. (1997). Planning via model checking: a decision\nprocedure for AR. In Proceedings of the 4th European Conference on Planning (ECP'97), pp.\n130\u2013142.\nBlum, M., Chandra, A. K., & Wegman, M. N. (1980). Equivalence of free Boolean graphs can be\ndecided probabilistically in polynomial time. Information Processing Letters, 10 (2), 80\u201382.\nBoole, G. (1854). An investigation of the laws of thought. Walton and Maberley, London.\nBoufkhad, Y., Gr\u00e9goire, E., Marquis, P., Mazure, B., & Sa\u0131\u0308s, L. (1997). Tractable cover compilations.\nIn Proc. of the 15th International Joint Conference on Artificial Intelligence (IJCAI'97), pp.\n122\u2013127, Nagoya.\nBryant, R. E. (1986). Graph-based algorithms for Boolean function manipulation. IEEE Transactions on Computers, C-35, 677\u2013691.\nBryant, R. E. (1992). Symbolic Boolean manipulation with ordered binary decision diagrams. ACM\nComputing Surveys, 24 (3), 293\u2013318.\nCadoli, M., & Donini, F. (1997). A survey on knowledge compilation. AI Communications, 10,\n137\u2013150. (printed in 1998).\nCadoli, M., Donini, F., Liberatore, P., & Schaerf, M. (1996). Comparing space efficiency of propositional knowledge representation formalisms. In Proc. of the 5rd International Conference on\nKnowledge Representation and Reasoning (KR'96), pp. 364\u2013373.\nChandra, A., & Markowsky, G. (1978). On the number of prime implicants. Discrete Mathematics,\n24, 7\u201311.\nDarwiche, A. (1999). Compiling knowledge into decomposable negation normal form. In Proceedings\nof International Joint Conference on Artificial Intelligence (IJCAI'99), pp. 284\u2013289. Morgan\nKaufmann, California.\nDarwiche, A. (2001a). Decomposable negation normal form. Journal of the ACM, 48 (4), 608\u2013647.\nDarwiche, A. (2001b). On the tractability of counting theory models and its application to belief\nrevision and truth maintenance. Journal of Applied Non-Classical Logics, 11 (1-2), 11\u201334.\nDarwiche, A., & Huang, J. (2002). Testing equivalence probabilistically. Tech. rep. D\u2013123, Computer\nScience Department, UCLA, Los Angeles, Ca 90095.\nde Kleer, J. (1992). An improved incremental algorithm for generating prime implicates. In Proc.\nof the 10th National Conference on Artificial Intelligence (AAAI'92), pp. 780\u2013785, San Jose,\nCalifornia.\nDechter, R., & Rish, I. (1994). Directional resolution: the Davis-Putnam procedure, revisited. In\nProceedings of the Fourth International Conference on Principles of Knowledge Representation\nand Reasoning (KR'94), pp. 134\u2013145, Bonn.\ndel Val, A. (1994). Tractable databases: How to make propositional unit resolution complete through\ncompilation. In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR'94), pp. 551\u2013561. Morgan Kaufmann Publishers, Inc., San\nMateo, California.\n263\n\n\fDarwiche & Marquis\n\nGergov, J., & Meinel, C. (1994a). Efficient analysis and manipulation of obdds can be extended to\nfbdds. IEEE Transactions on Computers, 43 (10), 1197\u20131209.\nGergov, J., & Meinel, C. (1994b). On the complexity of analysis and manipulation of Boolean\nfunctions in terms of decision diagrams. Information Processing Letters, 50, 317\u2013322.\nGogic, G., Kautz, H., Papadimitriou, C., & Selman, B. (1995). The comparative linguistics of\nknowledge representation. In Proc. of the 14th International Joint Conference on Artificial\nIntelligence (IJCAI'95), pp. 862\u2013869, Montreal.\nHerzig, A., & Rifi, O. (1999). Propositional belief base update and minimal change. Artificial\nIntelligence, 115 (1), 107\u2013138.\nKarp, R., & Lipton, R. (1980). Some connections between non-uniform and uniform complexity\nclasses. In Proc. of the 12th ACM Symposium on Theory of Computing (STOC'80), pp. 302\u2013\n309.\nKhardon, R., & Roth, D. (1997). Learning to reason. Journal of the ACM, 44 (5), 697\u2013725.\nLang, J., Liberatore, P., & Marquis, P. (2000). Propositional independence-Part I: formula\u2013variable\nindependence and forgetting. Submitted.\nMadre, J. C., & Coudert, O. (1992). A new method to compute prime and essential prime implicants\nof boolean functions. In Advanced research in VLSI and parallel systems, Proceedings of the\nBrown/MIT conference, pp. 113\u2013128.\nMarquis, P. (2000). Consequence finding algorithms, Vol. 5 of Handbook of Defeasible Reasoning\nand Uncertainty Management Systems: Algorithms for Uncertain and Defeasible Reasoning.\nKluwer Academic Publishers.\nMarquis, P. (1995). Knowledge compilation using theory prime implicates. In Proc. International\nJoint Conference on Artificial Intelligence (IJCAI'95), pp. 837\u2013843. Morgan Kaufmann Publishers, Inc., San Mateo, California.\nMeinel, C., & Theobald, T. (1998). Algorithms and Data Structures in VLSI Design: OBDD Foundations and Applications. Springer.\nPapadimitriou, C. (1994). Computational complexity. Addison\u2013Wesley.\nQuine, W. (1955). A way to simplify truth functions. American Mathematical Monthly, 52, 627\u2013631.\nQuine, W. (1959). On cores and prime implicants of truth functions. American Mathematical\nMonthly, 66, 755\u2013760.\nReiter, R., & de Kleer, J. (1987). Foundations of assumption-based truth maintenance systems:\nPreliminary report. In Proceedings of the Fifth National Conference on Artificial Intelligence\n(AAAI), pp. 183\u2013188.\nRoth, D. (1996). On the hardness of approximate reasoning. Artificial Intelligence, 82 (1-2), 273\u2013302.\nSchrag, R. (1996). Compilation for critically constrained knowledge bases. In Proc. of the 13th\nNational Conference on Artificial Intelligence (AAAI'96), pp. 510\u2013515, Portland, Oregan.\nSelman, B., & Kautz, H. (1996). Knowledge compilation and theory approximation. Journal of the\nAssociation for Computing Machinery, 43, 193\u2013224.\nSimon, L., & del Val, A. (2001). Efficient consequence finding. In Proc. of the 17th International\nJoint Conference on Artificial Intelligence (IJCAI'01), pp. 359\u2013365, Seattle (WA).\nWegener, I. (1987). The complexity of boolean functions. Wiley-Teubner, Stuttgart.\n\n264\n\n\f"}