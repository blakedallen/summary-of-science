{"id": "http://arxiv.org/abs/1102.0106v2", "guidislink": true, "updated": "2011-06-20T14:46:19Z", "updated_parsed": [2011, 6, 20, 14, 46, 19, 0, 171, 0], "published": "2011-02-01T09:27:39Z", "published_parsed": [2011, 2, 1, 9, 27, 39, 1, 32, 0], "title": "The Architecture of MEG Simulation and Analysis Software", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1102.4256%2C1102.0411%2C1102.2544%2C1102.3569%2C1102.3258%2C1102.4094%2C1102.4747%2C1102.1240%2C1102.5102%2C1102.1285%2C1102.5362%2C1102.2862%2C1102.1860%2C1102.3124%2C1102.1226%2C1102.0584%2C1102.1613%2C1102.1377%2C1102.1571%2C1102.0910%2C1102.5101%2C1102.5170%2C1102.1388%2C1102.1283%2C1102.0784%2C1102.4940%2C1102.2477%2C1102.4906%2C1102.0028%2C1102.0106%2C1102.0121%2C1102.5676%2C1102.1223%2C1102.2063%2C1102.3665%2C1102.4761%2C1102.0040%2C1102.0371%2C1102.4218%2C1102.0515%2C1102.4663%2C1102.4443%2C1102.1685%2C1102.0284%2C1102.4576%2C1102.5418%2C1102.2138%2C1102.1777%2C1102.1296%2C1102.0126%2C1102.0532%2C1102.4828%2C1102.4010%2C1102.0226%2C1102.5126%2C1102.0507%2C1102.4823%2C1102.3223%2C1102.0150%2C1102.0956%2C1102.2711%2C1102.5644%2C1102.2426%2C1102.2260%2C1102.3985%2C1102.0761%2C1102.1648%2C1102.3664%2C1102.5561%2C1102.0914%2C1102.1393%2C1102.1360%2C1102.5470%2C1102.5734%2C1102.1919%2C1102.3158%2C1102.0574%2C1102.2457%2C1102.4475%2C1102.1379%2C1102.4846%2C1102.5557%2C1102.3895%2C1102.4866%2C1102.1752%2C1102.0382%2C1102.1697%2C1102.2628%2C1102.1044%2C1102.3807%2C1102.4871%2C1102.1078%2C1102.2577%2C1102.3853%2C1102.3644%2C1102.5520%2C1102.4662%2C1102.0802%2C1102.3867%2C1102.3983%2C1102.0213&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The Architecture of MEG Simulation and Analysis Software"}, "summary": "MEG (Mu to Electron Gamma) is an experiment dedicated to search for the\n$\\mu^+ \\rightarrow e^+\\gamma$ decay that is strongly suppressed in the Standard\nModel but predicted in several Super Symmetric extensions of it at an\naccessible rate. MEG is a small-size experiment ($\\approx 50-60$ physicists at\nany time) with a life span of about 10 years. The limited human resource\navailable, in particular in the core offline group, emphasized the importance\nof reusing software and exploiting existing expertise. Great care has been\ndevoted to provide a simple system that hides implementation details to the\naverage programmer. That allowed many members of the collaboration to\ncontribute to the development of the software of the experiment with limited\nprogramming skill. The offline software is based on two frameworks: {\\bf REM}\nin FORTRAN 77 used for the event generation and detector simulation package\n{\\bf GEM}, based on GEANT 3, and {\\bf ROME} in C++ used in the readout\nsimulation {\\bf Bartender} and in the reconstruction and analysis program {\\bf\nAnalyzer}. Event display in the simulation is based on GEANT 3 graphic\nlibraries and in the reconstruction on ROOT graphic libraries. Data are stored\nin different formats in various stage of the processing. The frameworks include\nutilities for input/output, database handling and format conversion transparent\nto the user.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1102.4256%2C1102.0411%2C1102.2544%2C1102.3569%2C1102.3258%2C1102.4094%2C1102.4747%2C1102.1240%2C1102.5102%2C1102.1285%2C1102.5362%2C1102.2862%2C1102.1860%2C1102.3124%2C1102.1226%2C1102.0584%2C1102.1613%2C1102.1377%2C1102.1571%2C1102.0910%2C1102.5101%2C1102.5170%2C1102.1388%2C1102.1283%2C1102.0784%2C1102.4940%2C1102.2477%2C1102.4906%2C1102.0028%2C1102.0106%2C1102.0121%2C1102.5676%2C1102.1223%2C1102.2063%2C1102.3665%2C1102.4761%2C1102.0040%2C1102.0371%2C1102.4218%2C1102.0515%2C1102.4663%2C1102.4443%2C1102.1685%2C1102.0284%2C1102.4576%2C1102.5418%2C1102.2138%2C1102.1777%2C1102.1296%2C1102.0126%2C1102.0532%2C1102.4828%2C1102.4010%2C1102.0226%2C1102.5126%2C1102.0507%2C1102.4823%2C1102.3223%2C1102.0150%2C1102.0956%2C1102.2711%2C1102.5644%2C1102.2426%2C1102.2260%2C1102.3985%2C1102.0761%2C1102.1648%2C1102.3664%2C1102.5561%2C1102.0914%2C1102.1393%2C1102.1360%2C1102.5470%2C1102.5734%2C1102.1919%2C1102.3158%2C1102.0574%2C1102.2457%2C1102.4475%2C1102.1379%2C1102.4846%2C1102.5557%2C1102.3895%2C1102.4866%2C1102.1752%2C1102.0382%2C1102.1697%2C1102.2628%2C1102.1044%2C1102.3807%2C1102.4871%2C1102.1078%2C1102.2577%2C1102.3853%2C1102.3644%2C1102.5520%2C1102.4662%2C1102.0802%2C1102.3867%2C1102.3983%2C1102.0213&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "MEG (Mu to Electron Gamma) is an experiment dedicated to search for the\n$\\mu^+ \\rightarrow e^+\\gamma$ decay that is strongly suppressed in the Standard\nModel but predicted in several Super Symmetric extensions of it at an\naccessible rate. MEG is a small-size experiment ($\\approx 50-60$ physicists at\nany time) with a life span of about 10 years. The limited human resource\navailable, in particular in the core offline group, emphasized the importance\nof reusing software and exploiting existing expertise. Great care has been\ndevoted to provide a simple system that hides implementation details to the\naverage programmer. That allowed many members of the collaboration to\ncontribute to the development of the software of the experiment with limited\nprogramming skill. The offline software is based on two frameworks: {\\bf REM}\nin FORTRAN 77 used for the event generation and detector simulation package\n{\\bf GEM}, based on GEANT 3, and {\\bf ROME} in C++ used in the readout\nsimulation {\\bf Bartender} and in the reconstruction and analysis program {\\bf\nAnalyzer}. Event display in the simulation is based on GEANT 3 graphic\nlibraries and in the reconstruction on ROOT graphic libraries. Data are stored\nin different formats in various stage of the processing. The frameworks include\nutilities for input/output, database handling and format conversion transparent\nto the user."}, "authors": ["Paolo W. Cattaneo", "Fabrizio Cei", "Ryu Sawada", "Matthias Schneebeli", "Shuei Yamada"], "author_detail": {"name": "Shuei Yamada"}, "author": "Shuei Yamada", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1140/epjp/i2011-11060-6", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1102.0106v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1102.0106v2", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "Presented at the IEEE NSS Knoxville, 2010 Revised according to\n  referee's remarks Accepted by European Physical Journal Plus", "arxiv_primary_category": {"term": "physics.ins-det", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "physics.ins-det", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "hep-ex", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1102.0106v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1102.0106v2", "journal_reference": "Eur.Phys.J.Plus 126:60,2011", "doi": "10.1140/epjp/i2011-11060-6", "fulltext": "EPJ manuscript No.\n(will be inserted by the editor)\n\nThe Architecture of MEG Simulation and Analysis Software\nPaolo W. Cattaneo1 , Ryu Sawada2 , Fabrizio Cei3 , Shuei Yamada4 , and Matthias Schneebeli5\n1\n2\n3\n\narXiv:1102.0106v2 [physics.ins-det] 20 Jun 2011\n\n4\n5\n\na\n\nINFN Pavia, Via Bassi 6, Pavia, I-27100, Italy\nICEPP, The University of Tokyo, 7-3-1 Hongo, Bunkyo-ku, Tokyo 113-0033, Japan\nINFN and Department of Physics of the University of Pisa, Largo B.Pontecorvo 3, Pavia, I-56127, Italy\nKEK, High Energy Accelerator Research Organization, 1-1 Oho, Tsukuba, Ibaraki 305-0801, Japan\nPaul Scherrer Institute PSI, CH-5232 Villigen, Switzerland and Swiss Federal Institute of Technology ETH, CH-8093 Z\u00fcrich,\nSwitzerland\n04 March 2011\nAbstract. MEG (\u03bc+ \u2192 e+ \u03b3) is an experiment dedicated to search for the \u03bc+ \u2192 e+ \u03b3 decay that is strongly\nsuppressed in the Standard Model, but allowed in many alternative models and therefore very sensitive to\nnew physics. The offline software is based on two frameworks. The first is REM in FORTRAN 77, which\nis used for the event generation and detector simulation package GEM. The other is ROME in C++,\nused for the readout electronics simulation Bartender and for the reconstruction and analysis program\nAnalyzer. Event display in the simulation is based on GEANT3 graphic libraries and in the reconstruction\non ROOT graphic libraries. Data are stored in different formats at various stages of the processing. The\nframeworks include utilities for I/O, database access and format conversion transparent to the user.\nPACS. 29.85.Fj Data analysis\n\n1 Introduction\nThe MEG experiment at Paul Scherrer Institute (PSI) in\nSwitzerland is searching for the rare decay \u03bc+ \u2192 e+ \u03b3,\nemploying a very intense (3 \u00d7 107 s\u22121 ) \u03bc+ beam, which\nis stopped in a thin target at the center of the detector.\nMEG is a small-size collaboration (\u2248 50 \u2212 60 physicists at\nany time) with a life span of about 10 years.\nThe collaboration started the software development in\n2002 after a few years of prototype studies, with the goal\nof being ready for data taking in a technical run foreseen\nafter 3 years. Since the beginning, the tight time schedule\nand the limited human resource available, in particular in\nthe offline architecture group, emphasized the importance\nof reusing software developed during the prototype studies and exploiting existing expertise. Therefore great care\nhas been devoted to provide a simple system that hides\nimplementation details to the average programmer. That\nhas allowed many members of the collaboration with limited programming skill to contribute to the development\nof the software of the experiment.\nThe detector consists of a Liquid Xenon Calorimeter for\nmeasuring the \u03b3 momentum vector and timing and of a\nspectrometer consisting of a set of drift chambers and of\na timing counter embedded in a strong gradient magnetic\nfield generated by a superconducting magnet (COBRA)\nfor the measurement of e+ kinematic variables. A sketch\na\n\nPresent address: DECTRIS Ltd., Neuenhoferstrasse 107,\nCH-5400 Baden, Switzerland\n\nof the apparatus is in Fig.1. The waveforms from readout\nelectronics are digitized at \u2248 1 GHz frequency and stored\nin the output to optimize time resolution [1].\nWaveform data is encoded in a format developed in the\nMEG group. The data of each channel consists of a header\nand binary waveforms. Each header contains a hardware\nchannel number and parameters needed to decode data.\nThe data can be encoded in different ways depending on\nrequired compression factor, precision and characteristics\nof waveforms of each subdetector. The experiment totals\n\u2248 3000 channels and reduction by a factor of 3 in data\nsize is achieved applying zero suppression, waveform resampling or restricting the recorded region depending on\nthe subdetector.\nThe typical DAQ event rate is \u2248 6 Hz. Data size is about\n4.8 GB per run for 2000 events. Data files are compressed\nin the offline-cluster by a factor of 2. Event size after the\ncompression is 1.3 MB/event.\nDuring \u2248 3 months in 2010, \u2248 21 \u00d7 106 \u03bc+ \u2192 e+ \u03b3 triggers were collected for a total of 60 TB of data written\non disk, half of which from physics runs and the rest from\ncalibration runs.\nThe software requirements include the simulation of the\ngeneration of signal and background events, of their interaction with the detector and of the read out, the reconstruction from raw data, real or simulated, to high level\nobjects, e.g. tracks and photons as well as providing an\nanalysis environment.\nThe average time for simulating the interaction of a signal\n\n\f2\n\nPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\nevent in the detector is 5.8 s/event, while the average time\nfor simulating the readout electronics is 1.2 s/event. The\naverage time for reconstruction is 1.6 s/event.\nThe software organization designed to comply with these\nrequirements is presented.\nCOBRA Magnet\nDrift Chamber\n\n+\n\n\u03bc Beam\n\ne+\n\nTiming Counter\n\n\u03b3\n\nStopping Target\n\nx\n\nLiquid Xenon\n\u03b3-ray Detector\n\nz\n\n1m\n\nwhich contains a ROOT Tree and a histogram file for\nquick data checks. Before Analyzer starts a run, analysis\nparameters are read from the database. The analysis parameters (geometry, calibration etc.) can be changed later\nby users and data can be reprocessed with the updated\nparameters. If necessary, Analyzer copies raw data of selected events (cut for physics analysis) into raw ROOT\nfiles for future reprocessing.\nThe simulation program GEM, steered by configuration\nfiles created by the DB2Cards program by reading the\ndatabase, generates various types of events that are propagated in the detector. It is based on GEANT3 and CERNLIB and outputs data in exchange ZEBRA format [5].\nBartender reads those files and simulates the readout electronics to convert hits into waveforms. The simulated waveforms are written in raw ROOT files whose bank structure\nis the same as experimental data in MIDAS files. In sim\nfiles simulation specific variables, such as kinematics of\ngenerated particles and true hit information, are saved.\nAnalyzer reconstructs events from raw files using the same\nalgorithms as for the experimental data. High level physics\nanalysis is also realized within Analyzer.\nVersion control is managed by the Subversion [6] package.\n\n3 REM: a FORTRAN 77 framework\n\u03b3\n\ne+\n\ny\nx\n\nFig. 1. The MEG experimental setup.\n\nAs anticipated above, the technical choices in designing\nthe offline architecture were driven by considerations about\nthe time schedule, the man power and the technical skills\navailable in the collaboration at the start of the project.\nThe existence of important fragments of simulation code\ndeveloped in FORTRAN 77 and GEANT3 during the prototype phase at the time of the choice motivated the collaboration to retain the programming language and the\nlibrary for the simulation of the experiment.\nNevertheless the simulation software was organized following a modern programming paradigm, that is using an\nObject Oriented approach organized in a framework [7].\n\n2 The MEG software structure\nThe MEG offline software consists mainly of GEM (eventgeneration, particle tracking and detector simulation), Bartender (event-mixing and electronics simulation) and Analyzer (recostruction and analysis of experiment and simulation data). The relations between the various software\ncomponents are shown in Fig. 2.\nThe parameters in use in the programs are managed through\na common SQL database.\nThe MEG DAQ system is based on MIDAS [2]; raw experimental data are therefore saved as binary files in the\nnative format of the system. Briefly the MIDAS format\nconsists in an event header followed by MIDAS banks.\nEach bank is defined by a 4 character name and contains\na description of the unique data type and an array of data.\nThe DAQ system inserts run information and default analysis parameters into the database when a run is taken.\nThese files are read by Analyzer that reconstructs the\nevents and produces two files: a rec ROOT [3],[4] file,\n\n3.1 Implementation of a FORTRAN 77 framework\nThe detector simulation section GEM of the MEG software is written in FORTRAN 77, that was designed for\nprocedure oriented structured programming, not for OO\nprogramming.\nNevertheless a programming paradigm can be implemented\nin a variety of programming languages, even not designed\nfor it. A limited but satisfactory support to the OO paradigm\nis at reach also in FORTRAN 77 on the basis of the following list of approximate equivalences between procedure\noriented and OO concepts\n\u2013 Class \u2194 Library\n\u2013 Class data \u2194 Data structure (FORTRAN 77 Common\nblock)\n\u2013 Class interface \u2194 Set of library routines\n\u2013 Base Class \u2194 Module standardization\n\u2013 Virtual Class \u2194 Alternate choice of libraries\n\n\fPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\n\"raw\"\nROOT\n\nOutput file\n\nDAQ\n\n3\n\nMIDAS\nChannel mapping\nEvent selection\nDefault settings\n\nDatabase\nUpdating calibrations\nand settings\n\nOutput file\n\nDB2Cards\n\nFFREAD\ncards\n\nGEM\n\nAnalyzer\n\nZEBRA\n\nBartender\n\n\"raw\"\nROOT\n\nOutput file\n\n\"rec\"\nROOT\n\"histos\"\nROOT\n\nInteractive analysis\nInformation\n\n\"sim\"\nROOT\nOutput file\n\nInteractive analysis\n\nOutput file\nUser\n\nFig. 2. Connection between MEG software components\n\n3.2 Modules\n\n4 GEM: the Monte Carlo simulation\n\nThe Module is the basic unit manipulated by the framework that corresponds to an OO class. Each Module is\nimplemented concretely in a library. There are different\ntypes of Modules, that can be classified as\n\u2013 Basic Module : empty Module\n\u2013 Steerable Module : Module steerable by configuration\nfiles (cards)\n\u2013 Data Module : contains only data\n\u2013 Algorithm Module : implements an algorithm using\nother Modules\n\u2013 Service Module : provides interface to external libraries\nThese types share a common set of routines and differ by additional functionalities depending on the Module\ntype implementing the OO paradigm of class hierarchy.\n\nThe propagation of the \u03bc+ beam in the last section of\nthe beam line, its interaction in the target, the particle\ndecay and the propagation and interactions of the decay\nproducts in the detector are simulated with a FORTRAN\n77 Monte Carlo program (GEM) based on the GEANT3\npackage [8]. GEM can generate several event types, such\nas \u03bc+ \u2192 e+ \u03b3 signal (shown in the Fig. 3), radiative muon\ndecay, Michel muon decay, cosmic ray, alpha source calibration and many others. GEM incorporates a detailed\ndescription of the material and simulates the interactions\nof the particles in the detector as well as the response of\nthe sub-detectors up to the readout stage. In particular\nthe photon propagation in the Liquid Xenon Calorimeter\nand in the Timing Counter is simulated in detail.\nThe program is heavily modularized using the FORTRAN\n77 framework REM. This approach simplifies the addition\nof new Modules; Modules can be either sub-detector simulation sections or service tools like e.g. graphics.\nWithin this approach, the GEANT3 library can be treated\nas a Module and sequenced like any other module.\nGEM is steered by configuration files, called cards, read\nby the FFREAD package [9], that is available in REM.\nThese cards can be generated through the DB2Cards that\nis a ROME based framework. DB2Cards reads parameters from the database and output FFREAD cards, one\nfor each Module, under the control of a XML configuration file. This file permits to select the simulation configuration, e.g. year dependent or calibration setups, that are\nmaintained in the database.\nThe most natural choice for the format of the GEM output\nfiles is ZEBRA. Potential disadvantages of this approach\n\n3.3 The framework: REM\nThe framework is a Module with an event loop. The Modules associated to the framework are accessed in sequence\nby calling their routines in the corresponding framework\nroutines.\nThree module are provided by default in REM\n\u2013 Steering cards: FFREAD package\n\u2013 I/O : ZEBRA I/O\n\u2013 Histogramming : HBOOK package\nThe others Modules are project dependent and their\nroutines are called in the corresponding framework user\nroutines. These user routines, provided empty by default,\nare called by the framework routines. They can be overwritten implementing the OO inheritance mechanism.\n\n\f4\n\nPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\nare that the manipulation of ZEBRA banks is not user\nfriendly, error prone and requires significant knowledge\nof the package. A solution to these problems consists in\nmanipulating only variables in common blocks in the code\nand then mapping these variables into the output ZEBRA\nbanks. That is done automatically by providing a bank description based on the DZDOC format [5] and generating\nthrough a Perl [10] script the following routines for each\nbank xxxx\nget xxxx\nFetch the bank link\nprint xxxx Print out of the bank\nbuild xxxx Fill the bank with the variables in common\nblock (before writing out)\nfill xxxx\nFill the common block variables with bank\ncontent (after reading in)\nGEM provides for each Module yyyy the routines fill(build)yyyyrunheader\nand fill(build)yyyyeve that call all corresponding routines of the banks related to the module. GEM provides\nalso the routines fill(build)gemrunheader and fill(build)gemeve\nthat call the corresponding routines for all the Modules.\nThe buildgemrunheader is called once per run and buildgemeve\nis called once per event to build the banks from the variables in common blocks before calling the I/O ZEBRA\nroutines in REM.\n\n5 The database\nRun dependent information such as geometry, calibrations\nand analysis parameters are stored in a relational database,\nused for the DAQ frontend, analysis and simulation. Online data logger inserts an entry into the database immediately when a run is taken. A run can be processed\nby Analyzer with the default settings and reprocessed\nlater with improved calibration constants after modifying the database. For simulation, the dedicated program\nDB2Cards reads the database and write the FFREAD\ncards required by GEM for all the configurations required.\nTherefore all packages use consistently a common database.\nFor the main database, MySQL [11] is used so that\nclients can connect over the network. Daily snapshots are\ntaken in MySQL script format and SQLite[12] format.\nSQLite is a single file database; therefore it can be used\nwithout network, and can be used for test purposes by\nmodifying local copies without affecting other users. Information on all the runs and all the simulation configurations are stored in the database. The MEG database\nconsists of a few hundreds tables and each has a direct or\nindirect relation to the mother table RunCatalog so that\na run number suffices to retrieve all the information, and\nno recompilation or manual modification of configuration\nfiles is required to analyze any run sample. At May 2011,\nthe size of the MySQL database is \u2248 500 MB.\n\n6 ROME: a framework generator\nROME [13],[14] is a ROOT based framework generator for\nevent based data processing. It has been developed in the\n\nFig. 3. A \u03bc+ \u2192 e+ \u03b3 simulated event: the e+ track is in\nred with hits in drift chambers and timing counter in violet,\nred and blue, the \u03b3 track in blue with hits in Liquid Xenon\nCalorimeter in cyan.\n\nMEG collaboration but has been designed as a generalpurpose software so that it can be used for other experiments too.\nThe key concept of ROME is to generate most of the\ncode of a project, except the analysis (or simulation) algorithms.\nIn general, data processing software consist of three parts:\nthe first is a project independent part such as e.g. user\ninterface, handling of the event loop. The second is a\nproject dependent part, which can be summarized in a\ncompact way such as e.g. data structure and calling sequence of algorithms. The third is a completely project\ndependent part such as e.g. the implementation of analysis algorithms.\nFigure 4 shows components in the ROME environment. In\nthis environment, the first part is included in the ROME\npackage, and also the ROOT infrastructure is used. For\nthe second part, a programmer describes the framework\nfor his/her experiment in a clear and compact way in a\nXML definition file. Out of this file, ROMEBuilder program\ngenerates all experiment specific classes and modifies the\nframework. It calls also make command after the source\ncode generation; therefore the build procedure shown in\nFig. 4-(a) can be done with a single command. For the\nthird part, a programmer adds the algorithm code to the\n\n\fPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\npre-generated methods. Further modifications can be done\nby editing the definition XML file or by modifying algorithm implementations, then running ROMEBuilder again.\nBecause of the generation scheme, amount of hand written\ncode becomes smaller, and it becomes possible to start or\nmodify software without learning complicated implementation of the framework.\nThe generated framework is linked with the ROOT libraries; therefore all ROOT classes are available for the\nanalysis. Additional classes written by hand can be also\nlinked. The generated program is steered using a configuration XML file at the run time. Interactive control of the\nprogram, for example pausing the event loop and ploting\nhistograms, is possible.\n\nROOT\nrootcint\nROME\n\nDatabase\n(optional)\n\nROOT\nlibrary\n\nGenerate\n\nTTree\n\nProject\n\nROME\nlibrary\n\nDictionary\nGenerate\n\nCompile\nand link\n\nData\n\nLink\n\nHistograms\n\nMakefile\n\nROMEBuilder\n\nExecutable\n\nLink\nDocument\n\nSource\nHeader\n\nDefinition\nXML\n\nDescribe\nthe project\n\nExecutable\n\nCompile\nand link\nUser classes\n(optional)\n\nImplement\nalgorithms\n\nInteractive\ncontrol\n\nConfiguration\nXML\n\nCompile\nand link\n\nEdit\n\nUser\n\nLink\n\nSystem\nlibrary\n\nUser\n\n(a)\n\n(b)\n\nFig. 4. Components in the ROME environment (a) at build\ntime, and (b) at run time.\n\nThe following list is part of the items automatically\ngenerated by ROME according to a XML definition file.\n\u2013 Data classes (Folders), with a complete set of methods.\n\u2013 Algorithm classes (Tasks) with empty methods to be\nfilled by a programmer.\n\u2013 Visualization classes (Tabs) with empty methods to be\nfilled by a programmer.\n\u2013 Data input classes to read user defined data files with\nempty methods to be filled by a programmer.\n\u2013 Code to create and write histograms. The histograms\ncan be filled in user code.\n\u2013 Code for I/O of TTrees1 into files.\n\u2013 Code to read and write configuration XML files.\n\u2013 Code to read and write SQL database. MySQL, PostgreSQL [15] and SQLite are supported and switchable\nby a configuration file at run-time.\n\u2013 Code to read MIDAS format files and to connect to\nMIDAS Online Database System (ODB) to access online data.\n\u2013 Makefile is automatically generated or updated when\nnew classes are defined by a definition XML.\n\u2013 HTML document where description of Tasks and that\nof each variable in Folders are written. ROOT style\n1\n\nTTree is the ROOT implementation of the data structure\ntree concept\n\n5\n\ndocument, like \"reference guide\" in ROOT web page\ncan be also generated for user code.\nROME implements the organization commonly used\nin OO applications in high energy physics [16]: data objects, whose function is to store data, are separated from\nalgorithm objects, whose function is to incorporate algorithms.\nThe former are implemented as a Folder class, the latter as a Task class. Tasks are derived from ROOT TTask;\ntherefore recursive calling sequence is realized. ROME Folders\nare derived from ROOT TObject (not from TFolder), and\nthey can be filled into ROOT TTree as a single object or\nas an array in ROOT TClonesArray.\nFor Folders, ROME generates not only the class itself,\nbut also modifies the part of the framework related to the\nFolder such as allocation and initialization, adding or setting address of a branch in a TTree for writing (reading)\nthe Folder to (from) a file, filling variables by reading the\ndatabase at the beginning of a run (if required in XML).\nA definition of a Folder reads like a XML document\nshown in Fig. 5 together with part of C++ code generated by ROME according to the definition. This Photon\ninstance has two variables, Energy and Time. The generated class has these variables as its data members, and\nSet and Get methods are defined. The framework generates automatically, for example, 10 instances (the number\ncan be fixed or variable) at the beginning of the program\nand those instances are available in the user code out-ofpackage. For example, GetPhotonAt() and GetEnergy()\nshown in Fig. 6 are generated according to the description\nin the XML definition file of the Folder without manual\nprogramming. Any types of Field, both fundamental and\nderived, can be added in the Folder structure as far as it\nis supported by ROOT dictionary generation (dictionaries are needed for TTree I/O or socket connection over the\nnetwork).\nA definition of an algorithm object, that is a Task,\nreads like a XML document shown in Fig. 6. According\nto the definition file, ROME generates header and source\nfiles. A generated source file has empty methods, and a\nprogrammer can implement analysis in it immediately. As\nan example, in the code in Fig. 6, a few lines to access a\nFolder are added to the generated file. ROME generates\nnot only the task class itself, but modifies framework to\ncall it in an order specified in the definition XML. In this\nexample, a configuration parameter DebugPrint can be\nchanged using a configuration XML file at run-time without re-compile. A function call GetSP()->GetDebugPrint()\nshown in the example code is available without any manual programming, and a field to configure the parameter\nautomatically appears in a configuration XML file after\nthe first use of the file.\nThe framework outputs one or more TTrees. A programmer can define Trees and add Folders to it as branches\nin a XML description file. The framework code is automatically modified; therefore no manual programming is\nneeded to add branches to be read or written. Figure 7\nshows an example of Tree structure.\n\n\f6\n\nPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\n< Folder >\n< Task >\n< FolderName > Photon </ FolderName >\n< TaskName > P h o t o n A n a l y s i s </ TaskName >\n< ArraySize > 10 </ ArraySize >\n< SteeringParameters >\n< Field >\n< S te er in gPa ra me ter Fi el d >\n< FieldName > Energy </ FieldName >\n< SPFieldName > D e b u g P r i n t </ SPFieldName >\n< FieldType > D o u b l e t </ FieldType >\n< SPFieldType > B o o l t </ SPFieldType >\n< FieldComment > Energy o f a p h o t o n </ FieldComment\n</ S>te er ing Pa ra me ter Fi el d >\n</ Field >\n</ SteeringParameters >\n< Field >\n</ Task >\n< FieldName >Time </ FieldName >\n< FieldType > D o u b l e t </ FieldType >\n...\n< FieldComment >Time o f a p h o t o n </ FieldComment >\nvoid MEGTPhotonAnalysis : : Init ( )\n</ Field >\n{\n</ Folder >\n}\nc l a s s MEGPhoton : public TObject\n{\nprotected :\nDouble_t Energy ; // Energy o f a photon\nDouble_t Time ;\n// Time o f a photon\n...\n\nvoid MEGTPhotonAnalysis : : BeginOfRun ( )\n{\n}\n\nvoid MEGTPhotonAnalysis : : Event ( )\n{\n...\npublic :\ni f ( GetSP()\u2212>GetDebugPrint ( ) ) {\nMEGPhoton ( Double_t EnergyV =0 , Double_t TimeV =0); f o r ( i n t i =0;i <10; i++) {\nv i r t u a l  \u0303 MEGPhoton ( ) ;\ncout\n...\n<<gAnalyzer\u2212>GetPhotonAt ( i)\u2212>GetEnergy ( )\nDouble_t GetEnergy ( ) const\n<<endl ;\n{ return Energy ; }\n}\nDouble_t GetTime ( ) const\n}\n{ return Time ;\n}\n...\nvoid SetEnergy ( Double_t Energy_v )\n}\n{ Energy = Energy_v ; }\nvoid SetTime ( Double_t Time_v )\nvoid MEGTPhotonAnalysis : : EndOfRun ( )\n{ Time\n= Time_v ;\n}\n{\n...\n}\n}\nvoid MEGTPhotonAnalysis : : Terminate ( )\n{\nFig. 5. An example of Folder definition in a XML file (upper)\n}\nand part of the C++ code generated by ROME (lower).\n...\nFig. 6. An example of Task definition in a XML file (upper),\n\nOutput files can be used for interactive analysis, and fur- and part of the C++ code generated by ROME (lower).\nther analyzed by ROOT macros.\nOutput files of each step can be used as input files of\nthe following step; therefore the analysis can be separated < Tree >\ninto several steps. For example, in the analysis of MEG,\n< TreeName > DataTree </ TreeName >\n< Branch >\nwe can save results of waveform analysis, which is the most\n< BranchName > PhotonBranch </ BranchName >\ntime-consuming in the chain, and perform reconstructions\n< RelatedFolder > Photon </ RelatedFolder >\non this file to improve the algorithm many times without\n</ Branch >\nredoing the waveform analysis.\nAn interactive mode, which is almost the same as ROOT </ Tree >\ninteractive mode, is also provided. In the interactive mode\nor in macros, experiment specific classes are also available\nFig. 7. An example of Tree definition in a XML file.\nin addition to the standard ROOT classes.\nROME also generates a HTML document and a Makefile.\nThe generated framework is already compilable just by\nmake command and, after that, is executable.\nThe generation mechanism is used not only at the beginning of the project, but also during the code development.\nFor example, a programmer can easily add a new configu-\n\n\fPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\nration parameter to an existing Task, or add new variables\nto a Folder. Code in the framework is automatically modified consistently.\nMEG Analyzer consists of about 200 Folder classes and\n100 Task classes. The total number of lines in the Analyzer code is more than one million. 84% of them are either\ngenerated by rootcint [3] or ROME, or included in the\nROME package, while the rest were written manually.\n\n7 Readout simulation and event mixing\nFollowing the detector simulation and before the reconstruction and analysis program an intermediate program,\ncalled Bartender, is required for the processing of Monte\nCarlo data. This program serves different roles:\n\n7\n\nIn the first step, raw data are read and calibrations are applied to waveforms. In the second step, waveform analysis\nspecialized for each sub-detector are performed to extract\ntime and charge of pulses. Waveforms are also used to\nidentify pileup events and for particle identifications.\nIn the third and last step, events are reconstructed using\nalgorithms implemented by experts of each sub-detector.\nSeveral different algorithms are implemented to reconstruct each kinematic parameter for crosschecks. Each Task\nmay have a dedicated Folder to write its result. Tasks\nshare a Folder to hold results of a standard choice among\nthose algorithms; this choice is specified by a configuration\nfile. Tasks are executed in the same process and results are\nwritten in an output file together.\nFigure 8 shows a reconstructed experimental event.\n\n\u2013 Conversion of ZEBRA files into ROOT files\n\u2013 Readout simulation\n\u2013 Event mixing\nIt reads the GEM output ZEBRA files calling fillgemrunheader\nonce per run and fillgemeve once per event after calling\nthe I/O ZEBRA routines to fill the variables in FORTRAN common blocks from the banks. These variables\nare finally mapped to C++ classes manually.\nSimulation specific data such as kinematics of generated\nparticles, true hit information, etc. can be streamed in a\nsim Tree in separate ROOT files for further studies.\nIt simulates detector readout electronics and produces\nwaveforms. For example, the Liquid Xenon Calorimeter\nwaveforms are obtained by convolution of single photo+\n+\nelectron response of a photomultiplier tube (PMT) with Fig. 8. A \u03bc \u2192 e \u03b3 reconstructed event and closer views.\nhit-time information of scintillation photons simulated in Reconstructed hits in drift chambers and timing counters, a\nGEM. PMT amplification, signal attenuation, saturation positron track and a \u03b3-ray are shown. Color-code of Calorimeof the readout electronics, noise, etc. are taken into ac- ter PMTs represents output of each PMT.\ncount. Simulated waveforms are encoded in the same manner as the experimental ones and written in a raw Tree in\nROOT files.\nIt makes a mixture of several sub-events; rates of each\nevent type are set with a configuration file. To study the 8.2 Visualization\ncombinatorial background events, sub-events are mixed\nwith various relative timing with respect to each other Data quality is monitored for various time-spans: eventand with respect to the trigger. For instance random and by-event, run-by-run or in days.\nfixed timing can be selected. That allows simulating many\nFor event-by-event monitoring, several displays are imdifferent pile-up configurations with a limited number of plemented. Figure 9 shows one of them. The displays show\nsamples of events simulated through the detector.\nwaveforms, status of trigger, reconstructed hits and tracks\nand any other information useful for monitoring. Those\ndisplays are used for both online and offline. When it is\nused for online monitoring, Analyzer and DAQ run in par8 The reconstruction and analysis program\nallel and data are transferred over a socket connection.\nAnalyzer incorporates multiple purposes: event reconstruc- Hard copies of the displays are saved periodically for retion, visualization, computation of calibration constants motely monitoring using web-browsers.\nand physics analysis.\nTwo types of portable document format (PDF) files\nare automatically prepared by macros, which read histogram files made by Analyzer. The first type shows his8.1 Event reconstruction\ntograms to describe the run and is made automatically for\neach run soon after the run is finished. The second type\nAnalyzer consists of several Tasks for each step of analy- shows strip charts to monitor time variations of the status\nsis; each Task can be switched on/off.\nof the detector and of the electronics in a day or a week.\n\n\f8\n\nPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\nfunctions) to avoid biasing the analysis. In order to guarantee that, the data in the 'blinding box' are inaccessible\nduring the first phase of the analysis.\nThis concept is realized in Analyzer with Tasks streaming\nthe events into different ROOT files depending on the selection criteria they satisfy.\nA first round of processing operates a pre-selection on\ncoarsely calibrated data with loose cuts that are streamed\nin:\nselected\nEvents passing the pre-selection\nunselected Events not passing the pre-selection\nunbiased\nAll calibration trigger events and every fiftieth physics-trigger event\nTrees containing raw waveforms are produced for 'selected' and 'unbiased' events in this step. The 'unbiased'\nsamples are used for monitoring of the experiment and for\nFig. 9. A graphical display of timing counter hits, waveforms.\nthe calibrations. The 'selected' events are not accessible.\nA reconstructed positron track is also shown.\nAfter the calibrations are finalized, reconstruction is performed on the 'selected' samples using raw files. At the\nend of this step, another Task applies tighter cuts defin8.3 Calibration\ning the 'blinding box'. The events are streamed into the\nfiles:\nAnalyzer is used also to compute calibration constants blind\nEvents preselected in the 'blinding box',\n(photomultiplier gains, time-offsets, etc.). Each calibracandidate to be signal\ntion constant is associated to a Task. The calibration Tasks open\nEvents preselected but outside the 'blindare usually run on events already processed with a preliming box'\ninary set of calibration constants. The updated calibration\nand\n'selected'\nfiles\nare deleted. The 'blind' files are made\nconstants can be made available in a variety of format: hisaccessible\nonly\nwhen\nthe analysis is finalized.\ntograms, text file or SQL macro. They can be stored in the\ndatabase, and used in the next round of reconstruction.\n\n10 Conclusion\n8.4 Physics analysis\nEvent preselection and blinding for physics analysis, described in section 9, are implemented in Analyzer. On\nevents in the analysis region, likelihood analysis is performed to calculate the best estimate of the number of\n\u03bc+ \u2192 e+ \u03b3 signal candidates, its confidence interval and\nthe significance. The 90% confidence interval of the number of signal events is calculated using the unified approach [17]. We made independent likelihood analysis tools\nwith different statistical methods or parametrization of\nprobability density functions for cross checks.\n\n9 Offline processing\n\nSoftware is a crucial component of any experiment and its\npower and flexibility is a key ingredient of its success.\nMEG had the challenge to design a software structure that\ncould strike a balance between flexibility and user friendliness. The limited size of the offline architecture group and\nthe requirement that a large fraction of the collaboration\ncould contribute to the programming of the algorithms,\nhave led to greatly emphasize the use of known packages\nas well as the shielding from the average programmer of\nI/O handling, format conversion and Object Oriented programming into the frameworks.\nA mixed language environment with two separate frameworks, one for each environment, proved to be successful. It relies heavily on standard software elements like\nGEANT3, ZEBRA, FFREAD in the simulation section\nimplemented in FORTRAN 77; XML, ROOT in the rest\nof the code implemented in C++; MySQL and SQLite for\nthe database.\nThis configuration allowed the implementation of all experimental requirements within the tight time and manpower constraints, such to support the physics analysis\nfirst published in [18].\n\nJust after a run is taken, a raw data file written in the\nMIDAS format is sent to the offline-cluster, and a process\nto analyze it automatically starts. The MIDAS files are\ncompressed and stored on tapes. The compressed MIDAS\nfiles and rec files of calibration runs are accessible for further studies, while a special treatment is done for the data\nof physics runs.\nMEG has adopted the principle of 'blind' analysis in searching for \u03bc+ \u2192 e+ \u03b3 signal. That means that the events with Acknowledgment\nkinematic parameters closest to the expected signal (in the\n'blinding box') cannot be used for determining the anal- We acknowledge the role of Dr. Stefan Ritt from PSI, who\nysis parameters (e.g. the cuts or the probability density is the main author of the online software MIDAS.\n\n\fPaolo W. Cattaneo et al.: The Architecture of MEG Simulation and Analysis Software\n\nIntegration of each sub-detector part was done by many\ncollaborators; forty of them have contributed to the MEG\nsoftware.\n\nReferences\n1. Stefan Ritt, Roberto Dinapoli, and Ueli Hartmann. Application of the drs chip for fast waveform digitizing. Nuclear Instruments and Methods in Physics Research Section A: Accelerators, Spectrometers, Detectors and Associated Equipment, 623(1):486 \u2013 488, 2010. 1st International\nConference on Technology and Instrumentation in Particle\nPhysics.\n2. MIDAS : http://midas.psi.ch.\n3. ROOT : http://root.cern.ch.\n4. R. Brun and F. Rademakers. Root \u2013 an object oriented\ndata analysis framework. Nucl. Instr. and Meth. A, 389(12):81 \u2013 86, 1997.\n5. R. Brun and J. Zoll. ZEBRA-Data Structure Management\nSystem, CERN Program Library Long Writeups Q100,\n1995.\n6. Subversion : http://subversion.apache.org/.\n7. R. Brun. Software tools and frameworks in high energy\nphysics. European Physical Journal Plus, 126(1):14 \u2013 24,\n2011.\n8. R. Brun et al. GEANT3-Detector Description ans Simulaton Tool, CERN Program Library Long Writeups W5013,\n1993.\n9. FFREAD, CERN program Library Long Writeups Q123,\n1993.\n10. Larry Wall, Tom Christiansen, and Jon Orwant. Programming Perl. O'Reilly Media, Sebastopol, CA, 2010.\n11. MySQL : http://www.mysql.com/.\n12. SQLite : http://www.sqlite.org/.\n13. ROME : http://midas.psi.ch/rome.\n14. M. Schneebeli, R. Sawada, and S. Ritt. ROME - a universally applicable analysis framework generator. In Proceedings of the International Conference on Computing in\nHigh Energy and Nuclear Physics (CHEP06), Mumbai, India, 2006.\n15. PostgreSQL : http://www.postgresql.org/.\n16. G. Corti et al. Software for the LHCb Experiment. IEEE\nTNS, 53(3):1323\u20131328, June 2006.\n17. Gary J. Feldman and Robert D. Cousins. Unified approach\nto the classical statistical analysis of small signals. Phys.\nRev. D, 57(7):3873\u20133889, Apr 1998.\n18. J. Adam et al. A limit for the \u03bc+ \u2192 e+ \u03b3 decay from the\nMEG experiment. Nucl. Phys., B834:1\u201312, 2010.\n\n9\n\n\f"}