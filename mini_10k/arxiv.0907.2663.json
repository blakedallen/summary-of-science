{"id": "http://arxiv.org/abs/0907.2663v2", "guidislink": true, "updated": "2011-09-16T14:06:45Z", "updated_parsed": [2011, 9, 16, 14, 6, 45, 4, 259, 0], "published": "2009-07-15T17:25:43Z", "published_parsed": [2009, 7, 15, 17, 25, 43, 2, 196, 0], "title": "The Complexity of Approximating Bounded-Degree Boolean \\sharp CSP", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0907.1975%2C0907.3499%2C0907.0120%2C0907.0634%2C0907.1666%2C0907.4663%2C0907.5099%2C0907.2826%2C0907.0581%2C0907.4459%2C0907.3949%2C0907.4645%2C0907.0365%2C0907.3146%2C0907.3377%2C0907.1848%2C0907.1708%2C0907.0099%2C0907.0231%2C0907.0662%2C0907.0439%2C0907.3255%2C0907.4017%2C0907.3715%2C0907.1741%2C0907.5494%2C0907.3348%2C0907.4792%2C0907.1546%2C0907.1661%2C0907.0294%2C0907.0254%2C0907.1599%2C0907.5160%2C0907.4049%2C0907.0162%2C0907.2470%2C0907.0943%2C0907.4113%2C0907.2112%2C0907.3603%2C0907.0400%2C0907.3890%2C0907.5332%2C0907.2364%2C0907.5143%2C0907.4872%2C0907.0624%2C0907.3025%2C0907.0626%2C0907.1003%2C0907.4701%2C0907.5268%2C0907.1446%2C0907.3314%2C0907.2356%2C0907.0572%2C0907.3487%2C0907.4274%2C0907.2848%2C0907.2813%2C0907.0403%2C0907.3236%2C0907.2277%2C0907.3020%2C0907.3256%2C0907.1476%2C0907.2663%2C0907.1938%2C0907.1321%2C0907.4096%2C0907.0543%2C0907.5575%2C0907.4723%2C0907.4196%2C0907.0182%2C0907.0278%2C0907.1398%2C0907.3001%2C0907.2022%2C0907.0574%2C0907.0836%2C0907.0845%2C0907.4368%2C0907.3356%2C0907.3998%2C0907.3536%2C0907.1440%2C0907.0038%2C0907.3879%2C0907.2543%2C0907.0951%2C0907.1542%2C0907.1703%2C0907.0983%2C0907.3474%2C0907.4773%2C0907.3689%2C0907.1845%2C0907.5223%2C0907.1540&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The Complexity of Approximating Bounded-Degree Boolean \\sharp CSP"}, "summary": "The degree of a CSP instance is the maximum number of times that any variable\nappears in the scopes of constraints. We consider the approximate counting\nproblem for Boolean CSP with bounded-degree instances, for constraint languages\ncontaining the two unary constant relations {0} and {1}. When the maximum\nallowed degree is large enough (at least 6) we obtain a complete classification\nof the complexity of this problem. It is exactly solvable in polynomial-time if\nevery relation in the constraint language is affine. It is equivalent to the\nproblem of approximately counting independent sets in bipartite graphs if every\nrelation can be expressed as conjunctions of {0}, {1} and binary implication.\nOtherwise, there is no FPRAS unless NP=RP. For lower degree bounds, additional\ncases arise, where the complexity is related to the complexity of approximately\ncounting independent sets in hypergraphs.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0907.1975%2C0907.3499%2C0907.0120%2C0907.0634%2C0907.1666%2C0907.4663%2C0907.5099%2C0907.2826%2C0907.0581%2C0907.4459%2C0907.3949%2C0907.4645%2C0907.0365%2C0907.3146%2C0907.3377%2C0907.1848%2C0907.1708%2C0907.0099%2C0907.0231%2C0907.0662%2C0907.0439%2C0907.3255%2C0907.4017%2C0907.3715%2C0907.1741%2C0907.5494%2C0907.3348%2C0907.4792%2C0907.1546%2C0907.1661%2C0907.0294%2C0907.0254%2C0907.1599%2C0907.5160%2C0907.4049%2C0907.0162%2C0907.2470%2C0907.0943%2C0907.4113%2C0907.2112%2C0907.3603%2C0907.0400%2C0907.3890%2C0907.5332%2C0907.2364%2C0907.5143%2C0907.4872%2C0907.0624%2C0907.3025%2C0907.0626%2C0907.1003%2C0907.4701%2C0907.5268%2C0907.1446%2C0907.3314%2C0907.2356%2C0907.0572%2C0907.3487%2C0907.4274%2C0907.2848%2C0907.2813%2C0907.0403%2C0907.3236%2C0907.2277%2C0907.3020%2C0907.3256%2C0907.1476%2C0907.2663%2C0907.1938%2C0907.1321%2C0907.4096%2C0907.0543%2C0907.5575%2C0907.4723%2C0907.4196%2C0907.0182%2C0907.0278%2C0907.1398%2C0907.3001%2C0907.2022%2C0907.0574%2C0907.0836%2C0907.0845%2C0907.4368%2C0907.3356%2C0907.3998%2C0907.3536%2C0907.1440%2C0907.0038%2C0907.3879%2C0907.2543%2C0907.0951%2C0907.1542%2C0907.1703%2C0907.0983%2C0907.3474%2C0907.4773%2C0907.3689%2C0907.1845%2C0907.5223%2C0907.1540&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The degree of a CSP instance is the maximum number of times that any variable\nappears in the scopes of constraints. We consider the approximate counting\nproblem for Boolean CSP with bounded-degree instances, for constraint languages\ncontaining the two unary constant relations {0} and {1}. When the maximum\nallowed degree is large enough (at least 6) we obtain a complete classification\nof the complexity of this problem. It is exactly solvable in polynomial-time if\nevery relation in the constraint language is affine. It is equivalent to the\nproblem of approximately counting independent sets in bipartite graphs if every\nrelation can be expressed as conjunctions of {0}, {1} and binary implication.\nOtherwise, there is no FPRAS unless NP=RP. For lower degree bounds, additional\ncases arise, where the complexity is related to the complexity of approximately\ncounting independent sets in hypergraphs."}, "authors": ["Martin Dyer", "Leslie Ann Goldberg", "Markus Jalsenius", "David Richerby"], "author_detail": {"name": "David Richerby"}, "author": "David Richerby", "arxiv_comment": "22 pages. Full classification now applies to degree bounds of at\n  least 6 (formerly at least 25) but no other significant changes from previous\n  version (reduction in page count is just different typesetting)", "links": [{"href": "http://arxiv.org/abs/0907.2663v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0907.2663v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.CC", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.2.2; G.2.1", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0907.2663v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0907.2663v2", "journal_reference": null, "doi": null, "fulltext": "arXiv:0907.2663v2 [cs.CC] 16 Sep 2011\n\nThe Complexity of Approximating\nBounded-Degree Boolean #CSP\u2217\nMartin Dyer,\u2020 Leslie Ann Goldberg,\u2021\nMarkus Jalsenius\u00a7 and David Richerby\u2021\n\nAbstract\nThe degree of a CSP instance is the maximum number of times that any variable appears\nin the scopes of constraints. We consider the approximate counting problem for Boolean CSP\nwith bounded-degree instances, for constraint languages containing the two unary constant\nrelations {0} and {1}. When the maximum allowed degree is large enough (at least 6) we\nobtain a complete classification of the complexity of this problem. It is exactly solvable\nin polynomial-time if every relation in the constraint language is affine. It is equivalent to\nthe problem of approximately counting independent sets in bipartite graphs if every relation\ncan be expressed as conjunctions of {0}, {1} and binary implication. Otherwise, there\nis no FPRAS unless NP = RP. For lower degree bounds, additional cases arise, where\nthe complexity is related to the complexity of approximately counting independent sets in\nhypergraphs.\n\n1\n\nIntroduction\n\nIn the constraint satisfaction problem (CSP), we seek to assign values from some domain to a set\nof variables, while satisfying given constraints on the combinations of values that certain tuples\nof the variables may take. Constraint satisfaction problems are ubiquitous in computer science,\nwith close connections to graph theory, database query evaluation, type inference, satisfiability,\nscheduling and artificial intelligence [31, 33, 36]. CSP can also be reformulated in terms of homomorphisms between relational structures [26] and conjunctive query containment in database\ntheory [31]. Weighted versions of CSP appear in statistical physics, where they correspond to\npartition functions of spin systems [44].\nWe give formal definitions in Section 2 but, for now, consider an undirected graph G and\nthe CSP where the domain is {red, green, blue}, the variables are the vertices of G and the\nconstraints specify that, for every edge xy \u2208 G, x and y must be assigned different values.\nThus, in a satisfying assignment, no two adjacent vertices are given the same colour: the CSP\nis satisfiable if, and only if, the graph is 3-colourable. As a second example, given a formula in\n3-CNF, we can write a system of constraints over the variables, with domain {true, false}, that\nrequires the assignment to each clause of the formula to satisfy at least one literal. Clearly, the\nresulting CSP is directly equivalent to the original satisfiability problem.\n\u2217\nThe work described in this paper was partly supported by EPSRC Research Grant (refs EP/I011528/1 and\nEP/I012087/1) \"Computational Counting\".\n\u2020\nSchool of Computing, University of Leeds, Leeds, LS2 9JT, UK.\n\u2021\nDept of Computer Science, University of Liverpool, Liverpool, L69 3BX, UK.\n\u00a7\nDept of Computer Science, University of Bristol, Merchant Venturers Building, Bristol, BS8 1UB, UK.\n\n1\n\n\f1.1\n\nDecision CSP\n\nIn the uniform constraint satisfaction problem, we are given the set of constraints explicitly, as\nlists of allowable combinations for given tuples of the variables; these lists can be considered\nas relations over the domain. Since it includes problems such as 3-sat and 3-colourability,\nuniform CSP is NP-complete. However, uniform CSP also includes problems in P, such as\n2-sat and 2-colourability, raising the natural question of what restrictions lead to tractable\nproblems. It is natural to restrict either the form of the constraints or of the instances.\nThe most common restriction is to allow only certain fixed relations in the constraints. The\nlist of allowed relations is known as the constraint language and we write CSP(\u0393) for the socalled non-uniform CSP in which each constraint states that the values assigned to some tuple\nof variables must be a tuple in a specified relation in \u0393.\nThe classic example of this is due to Schaefer [37]. Restricting to Boolean constraint languages (i.e., those with domain {0, 1}), he showed that CSP(\u0393) is in P if \u0393 is included in one of\nsix classes and is NP-complete, otherwise. The Boolean case of CSP is often referred to as \"generalized satisfiability\" in the literature. More recently, Bulatov has produced a corresponding\ndichotomy for three-element domains [3].\nRestricting to relations of fixed arity over arbitrary finite domains has also been studied\nin depth. In particular, requiring \u0393 to be a single binary relation gives the directed graph\nhomomorphism problem, and the undirected graph homomorphism problem if the relation is\nalso required to be symmetric. Hell and Ne\u0161et\u0159il have shown that, for every symmetric binary\nrelation E, CSP(E) is either in P or is NP-complete [28]. They conjecture that this holds for\nall binary relations.\nIn all the above cases, CSP(\u0393) has been either in P or NP-complete and Feder and Vardi\nhave conjectured that this holds for all \u0393 [26]. No such dichotomy can exist for the whole of\nNP because Ladner has shown that either P = NP or there is an infinite, strict hierarchy\nbetween the two [34]. However, a dichotomy for CSP is possible as there are problems in NP,\nsuch as graph Hamiltonicity and even connectedness, that cannot be expressed as CSP(\u0393)1\nand Ladner's diagonalization does not seem to be expressible in CSP [26]. Resolving Hell and\nNe\u0161et\u0159il's conjecture for a class of simple acyclic digraphs would immediately resolve the CSP\ndichotomy [26], though recent work on the dichotomy has focused on methods from universal\nalgebra - see, for example, [3, 8] and the references there.\nAllowing arbitrary constraint languages but restricting the form of the instances has also been\nstudied. Dechter and Pearl [15] and Freuder [27] have shown that even uniform CSP is in P on\ninstances of bounded tree width; see also [32]. Bounded tree width and other similar restrictions\nare generalized by the \"guarded decompositions\" of Cohen, Jeavons and Gyssens [9]. Restricting\nthe degree of instances (the maximum number of times that each variable may appear in the\nscopes of constraints) is incomparable but not much is known in this case. In the non-uniform\nBoolean case, Dalmau and Ford have shown that, as long as \u0393 contains the relations Rzero = {0}\nand Rone = {1}, CSP(\u0393) for instances of degree at most three has the same complexity as the\ncase with no degree restrictions [14]. The degree-two case has not yet been completely classified,\nthough it is known that degree-2 CSP(\u0393) is as hard as general CSP(\u0393) whenever \u0393 contains\nRzero and Rone and some relation that is not a \u2206-matroid [14, 25].\n1\n\nThis follows from the observation that any set S of structures (e.g., graphs) that is definable in CSP has the\nproperty that, if A \u2208 S and there is a homomorphism B \u2192 A, then B \u2208 S; neither the set of Hamiltonian nor\nconnected graphs has this property.\n\n2\n\n\f1.2\n\nCounting CSP\n\nA generalization of the classical constraint satisfaction problem is to ask how many satisfying\nsolutions there are, rather than just whether the constraints are satisfiable. This is referred to\nas the counting CSP problem, #CSP. Clearly, the decision problem is reducible to counting:\nif we can efficiently count the solutions, we can efficiently determine whether there is at least\none. However, the converse does not hold: for example, there are well-known polynomial-time\nalgorithms that determine whether a graph admits a perfect matching but it is #P-complete to\ncount the perfect matchings, even in a bipartite graph [42].\nThe class #P can be considered to be the counting analogue of NP: it is defined as the\nclass of functions f for which there is a nondeterministic, polynomial-time Turing machine\nthat has exactly f (x) accepting paths for every input x [41]. The counting version of any NP\ndecision problem is easily seen to be in #P. Note that, although #P plays a similar role in the\ncomplexity of function problems to that of NP in decision problems, problems that are complete\nfor #P under appropriate reductions are, under standard complexity-theoretic assumptions,\nconsiderably harder than NP-complete problems. Toda has shown that P#P includes the whole\nof the polynomial hierarchy [40], but PNP is generally thought not to.\nAlthough it is not known if there is a dichotomy for CSP, Bulatov has recently shown that,\nfor every \u0393, #CSP(\u0393) is either computable in polynomial time or #P-complete [4]. Two of the\npresent authors have since given an elementary proof of this result and also shown the dichotomy\nto be decidable [24]. However, it is not obvious how the methods of these results could be applied\nto bounded-degree #CSP.\nSo, although there is a full dichotomy for #CSP(\u0393), results for restricted forms of constraint\nlanguage are still of interest. For Boolean constraint languages, Creignou and Hermann have\nshown that only one of Schaefer's polynomial-time cases survives the transition to counting:\n#CSP(\u0393) has a polynomial time algorithm if every relation in \u0393 is affine (i.e., the solution set of\na system of linear equations over GF2 ) and is #P-complete, otherwise [12]. It is not surprising\nthat there are fewer tractable cases - it is easy to arrange that every instance of CSP(\u0393) be\ntrivially satisfiable (say, by making the all-zeroes assignment satisfying), but the number of\nnon-trivial solutions might be difficult to compute. Dyer, Goldberg and Jerrum [19] extended\nCreignou and Hermann's result to weighted Boolean #CSP. Cai, Lu and Xia [6, 7] extended\nfurther to the case of complex weights and show that the dichotomy holds for the restriction of\nthe problem in which instances have degree 3. Their result implies that the degree-3 problem\n#CSP3 (\u0393) (#CSP(\u0393) restricted to instances of degree 3) has a polynomial time algorithm if\nevery relation in \u0393 is affine and is #P-complete, otherwise.\nThe case where \u0393 contains a single symmetric, binary relation E corresponds exactly to the\nproblem of counting the homomorphisms from an input graph to some fixed undirected graph\nH, also known as the counting H-colouring problem. Dyer and Greenhill have shown that\n#CSP({E}) is in polynomial time if E is a complete relation or defines a complete bipartite\ngraph and is #P-complete otherwise [22]. The dichotomy for directed acyclic graphs has been\ncharacterized by Dyer, Goldberg and Paterson [21] and, more recently, Cai and Chen have shown\na dichotomy for all directed graphs, even with non-negative algebraic weights [5]. In contrast to\nthe decision problem, it is not known whether a direct proof of the dichotomy for general directed\ngraphs would yield an alternative proof of the dichotomy for arbitrary constraint languages.\nRestricting the tree-width of instances has a dramatic effect. In the case of counting Hcolourings, restricting the instance to be a graph of tree-width at most k makes the problem\nsolvable in linear time for any graph H, a result due to D\u0131\u0301az, Serna and Thilikos [16]. This\n3\n\n\fresult follows immediately from Courcelle's theorem, which says that, if a decision problem is\ndefinable in monadic second-order logic (which H-colouring is, for any fixed H), then both it and\nthe corresponding counting problem are computable in linear time [10,11]. However, invocations\nof Courcelle's theorem hide enormous constants in the notation O(n) (in this case, a tower of\ntwos of height |H|), while the work of D\u0131\u0301az et al. not only yields practical constants but can also\nbe applied to classes of instances where the tree-width is allowed to grow logarithmically with\nthe order of the graph, rather than being constant.\n\n1.3\n\nApproximate counting\n\nSince #CSP(\u0393) is very often #P-complete, approximation algorithms play an important role.\nThe key concept is that of a fully polynomial randomized approximation scheme (FPRAS). This\nis a randomized algorithm for computing some function f (x), taking as its input x and a constant\n\u01eb > 0, and computing a value Y such that e\u2212\u01eb 6 Y /f (x) 6 e\u01eb with probability at least 43 , in\ntime polynomial in both |x| and \u01eb\u22121 . (See Section 2.4 for details.)\nDyer, Goldberg and Jerrum have classified the complexity of approximately computing\n#CSP(\u0393) for Boolean constraint languages [20]. When all relations in \u0393 are affine, #CSP(\u0393)\ncan be computed exactly in polynomial time by the result of Creignou and Hermann discussed\nabove [12]. Otherwise, if every relation in \u0393 can be defined by a conjunction of Boolean implications and pins (i.e., assertions of the form v = 0 or v = 1), then #CSP(\u0393) is as hard to\napproximate as the problem #BIS of counting independent sets in a bipartite graph; otherwise,\n#CSP(\u0393) is as hard to approximate as the problem #SAT of counting the satisfying truth assignments of a Boolean formula. Dyer, Goldberg, Greenhill and Jerrum have shown that the\nlatter problem is complete for #P under appropriate approximation-preserving reductions (see\nSection 2.4) and has no FPRAS unless NP = RP [18], which is thought to be unlikely. The\ncomplexity of #BIS is currently open: there is no known FPRAS but it is not known to be\n#P-complete, either. #BIS is known to be complete with respect to approximation-preserving\nreductions in a logically-defined subclass of #P [18].\n\n1.4\n\nOur result\n\nIn this paper we consider the complexity of approximately solving Boolean #CSP problems when\ninstances have bounded degree. Following Dalmau and Ford [14] and Feder [25] we consider the\ncase in which Rzero = {0} and Rone = {1} are available. We show that any Boolean relation\nthat is not definable as a conjunction of ORs or NANDs can be used in low-degree instances\nto assert equalities between variables. Thus, we can side-step degree restrictions by replacing\nhigh-degree variables with distinct variables that are constrained to be equal, reducing to Dyer,\nGoldberg and Jerrum's trichotomy for Boolean #CSP without degree restrictions [20].\nOur main result, Theorem 24, is a trichotomy for the case in which instances have maximum\ndegree d for any d > 6. If every relation in \u0393 is affine then #CSPd (\u0393 \u222a {Rzero , Rone }) is solvable\nin polynomial time. Otherwise, if every relation in \u0393 can be defined as a conjunction of Rzero ,\nRone and binary implications, then #CSPd (\u0393 \u222a {Rzero , Rone }) is equivalent in approximation\ncomplexity to #BIS. Otherwise, it has no FPRAS unless NP = RP. Theorem 23 gives a partial\nclassification of the complexity when d < 6. In the new cases that arise here, the complexity\nis given in terms of #w-HISd , the complexity of counting independent sets in hypergraphs of\ndegree at most d with hyper-edges of size at most w. The complexity of this problem is not fully\nunderstood. We explain what is known about it in Section 6.\n4\n\n\f1.5\n\nOrganization\n\nThe remainder of the paper is organized as follows. In Section 2, we define the basic notation,\nrelational operations and hypergraph properties that we use, and formally define bounded-degree\nCSPs. In Section 3, we introduce the classes of relations that we will use throughout the paper\nand give some of their basic properties. A key tool in this type of work [6, 25] is characterizing\nthe ability of certain relations or sets of relations to assert equalities between variables: we show\nwhen this can be done in Section 4. The last piece of preparatory work is to show that every\nBoolean relation that cannot simulate equality in this way is definable by a conjunction of pins\nand either ORs or NANDs, which is done in Section 5. Our classification of the approximation\ncomplexity of bounded-degree Boolean counting CSPs follows, in Section 6.\n\n2\n\nPreliminaries\n\n2.1\n\nBasic notation\n\nWe write \u0101 for the tuple h a1 , . . . , ar i, which we often shorten to a1 . . . ar . We write ar for the\nr-tuple a . . . a and \u0101b\u0304 for the tuple formed from the elements of \u0101 followed by those of b\u0304.\nThe bit-wise complement of a relation R \u2286 {0, 1}r is the relation\ne = {h a1 \u2295 1, . . . , ar \u2295 1 i | \u0101 \u2208 R} ,\nR\nwhere \u2295 denotes addition modulo 2.\nWe say that a relation R is ppp-definable 2 in a relation R\u2032 and write R 6ppp R\u2032 if R can be\nobtained from R\u2032 by some sequence of the following operations:\n\u2022 permutation of columns;\n\u2022 pinning (taking sub-relations of the form Ri7\u2192c = {\u0101 \u2208 R | ai = c} for some i and some\nc \u2208 {0, 1}); and\n\u2022 projection (\"deleting the ith column\" to give {a1 . . . ai\u22121 ai+1 . . . ar | a1 . . . ar \u2208 R}).\nThe three p's in \"ppp-definable\" refer to the initial letters of the words permutation, pinning\nand projection. Allowing permutation of columns is just a notational convenience: it clearly\nadds no expressive power.\nIt is easy to see that 6ppp is a partial order on Boolean relations and that, if R 6ppp R\u2032,\nthen R can be obtained from R\u2032 by first permuting the columns, then making some pins and\nthen projecting.\nWe write Rzero = {0}, Rone = {1}, R= = {00, 11}, R6= = {01, 10}, ROR = {01, 10, 11},\nRNAND = {00, 01, 10}, R\u2192 = {00, 01, 11} and R\u2190 = {00, 10, 11}. For k > 2, we write R=,k =\n{0k, 1k }, ROR,k = {0, 1}k \\ {0k } and RNAND,k = {0, 1}k \\ {1k } (i.e., k-ary equality, OR and\nNAND, respectively).\nWe write proji R for the projection of R onto its ith column and proji,j R for the projection\nonto columns i and j.\n2\n\nThis should not be confused with the concept of primitive positive definability (pp-definability) which appears\nin algebraic treatments of CSP and #CSP, for example in the work of Bulatov [4].\n\n5\n\n\f2.2\n\nBoolean constraint satisfaction problems\n\nA constraint language is a set \u0393 = {R1 , . . . , Rm } of named Boolean relations. Given a set V\nof variables, a constraint over \u0393 is an expression R(v\u0304) where R \u2208 \u0393 has arity r and v\u0304 \u2208 V r.\nNote that, if v and v \u2032 are variables, neither v = v \u2032 nor v 6= v \u2032 is a constraint, though of course\nR= (v, v \u2032 ) is a constraint if R= \u2208 \u0393 and similarly for R6= . The scope of a constraint R(v\u0304) is the\ntuple v\u0304. Note that the variables in the scope of a constraint need not all be distinct.\nAn instance of the constraint satisfaction problem (CSP) over \u0393 is a set V of variables and\na set C of constraints over \u0393 in the variables in V .\nAn assignment to a set V of variables is a function \u03c3 : V \u2192 {0, 1} and it satisfies an instance\n(V, C) if h \u03c3(v1 ), . . . , \u03c3(vr ) i \u2208 R for every constraint of the form R(v1 , . . . , vr ). Given an instance\nI of some CSP, we write Z(I) for the number of satisfying assignments.\nWe are interested in the counting CSP problem #CSP(\u0393) (parameterized by \u0393), defined as:\nInput: an instance I = (V, C) of CSP over \u0393.\nOutput: Z(I).\nThe degree of an instance is the greatest number of times any variable appears among its\nconstraints. Note that the variable v appears twice in the constraint R(v, v). Our specific interest\nin this paper is in classifying the complexity of bounded-degree counting CSPs. For a constraint\nlanguage \u0393 and a positive integer d, define #CSPd (\u0393) to be the restriction of #CSP(\u0393) to\ninstances of degree at most d. We can deal with instances of degree 1 immediately.\nTheorem 1. For any \u0393, #CSP1 (\u0393) \u2208 FP.\nProof. Because each variable appears at most once, the constraints are independent. Each\nconstraint R(v1 , . . . , vr ) can be satisfied in |R| ways and any variable that does not appear in a\nconstraint can take either the value 0 or 1. The total number of assignments is the product of\nthe number of ways each constraint can be satisfied, multiplied by 2k, where k is the number of\nunconstrained variables.\nA key technique in proving hardness results for #CSP and related problems is pinning\n[12, 14, 19, 20, 22, 25]. We write Rzero = {0} and Rone = {1} for the two unary relations that\ncontain only zero and one, respectively. We refer to constraints in Rzero and Rone as pins and\nwe say that the single variable in the scope of a pin is pinned. To make notation easier, we\nwill sometimes write constraints using constants instead of explicit pins. That is, we will write\nconstraints of the form R(x1 , . . . , xr ) where each xi is either a variable from V or a constant 0\nor 1 (again, the xi need not be distinct). Such a constraint can always be rewritten as a set of\n\"proper\" constraints by replacing each instance of a constant 0 or 1 with a fresh variable v and\nintroducing the appropriate constraint Rzero (v) or Rone (v). Note that every variable introduced\nin this way appears exactly twice in the resulting instance so if the degree of the CSP instance\nis at least two, the transformation does not increase the instance's degree. We let \u0393pin denote\nthe constraint language {Rzero , Rone }.\nWhen there are no degree bounds, adding pinning does not affect complexity results for\neither the exact or approximate version of #CSP. In the exact case, the addition of pinning\ndoes not affect the structural properties that determine the complexity of #CSP(\u0393) [24] whereas,\nfor approximation on the Boolean domain, there are reductions of the appropriate kind from\n#CSP(\u0393 \u222a \u0393pin ) to #CSP(\u0393) [19, 20]. However, these reductions increase the degree of variables\n6\n\n\fso are not applicable in our setting. In order to make progress, we follow earlier work on degreebounded CSP [14, 25] and assume that pinning is available in constraint languages. This plays\na significant role in Section 4.\n\n2.3\n\nHypergraphs\n\nA hypergraph H = (V, E) consists of a set V = V (H) of vertices and a set E = E(H) \u2282 P(V )\nof non-empty hyper-edges. The degree of a vertex v \u2208 V (H) is the number d(v) of hyper-edges\nit participates in: d(v) = |{e \u2208 E(H) | v \u2208 e}|. The degree of a hypergraph is the maximum\ndegree of its vertices. If w = max{|e| | e \u2208 E(H)}, we say that H has width w.\nAn independent set in a hypergraph H is a set S \u2286 V (H) such that e * S for every e \u2208 E(H).\nNotice that we may have more than one vertex of a hyper-edge in an independent set, so long\nas at least one vertex of each hyper-edge is omitted.\nWe write #w-HIS for the following problem:\nInput: a width-w hypergraph H\nOutput: the number of independent sets in H\nand #w-HISd for the following problem:\nInput: a width-w hypergraph H of degree at most d\nOutput: the number of independent sets in H.\n\n2.4\n\nApproximation complexity\n\nA randomized approximation scheme (RAS) for a function f : \u03a3\u2217 \u2192 N is a probabilistic Turing\nmachine that takes as input a pair (x, \u01eb) \u2208 \u03a3\u2217 \u00d7 (0, 1), and produces, on an output tape, an\ninteger random variable Y satisfying the condition Pr(e\u2212\u01eb 6 Y /f (x) 6 e\u01eb ) > 34 .3 A fully\npolynomial randomized approximation scheme (FPRAS) is a RAS that runs in time polynomial\nin both |x| and \u01eb\u22121.\nTo compare the complexity of approximate counting problems, we use the AP-reductions\nof [18]. Suppose that f and g are functions from some input domain \u03a3\u2217 to the natural numbers\nand we wish to compare the complexity of approximately computing them. An approximationpreserving reduction from f to g is a probabilistic oracle Turing machine M whose input is\na pair (x, \u01eb) \u2208 \u03a3\u2217 \u00d7 (0, 1), and which satisfies the following three conditions: (i) every oracle\ncall made by M is of the form (w, \u03b4) where w \u2208 \u03a3\u2217 is an instance of g and 0 < \u03b4 < 1 is an\nerror bound satisfying \u03b4\u22121 6 poly(|x|, \u01eb\u22121 ); (ii) M is a randomized approximation scheme for f\nwhenever the oracle is a randomized approximation scheme for g; and (iii) the running time of\nM is polynomial in |x| and \u01eb\u22121 .\nIf there is an approximation-preserving reduction from f to g, we write f 6AP g and say\nthat f is AP-reducible to g. If g has an FPRAS then so does f . If f 6AP g and g 6AP f then\nwe say that f and g are AP-interreducible and write f \u2261AP g.\nAP-reductions are well-suited to approximate counting problems. The class of problems\nadmitting an FPRAS is closed under these reductions and a Ladner-like hierarchy of APinterreducible approximation problems has been shown to exist [1]. Further, the intuition that\n3\n\nThe choice of the value\nprobability 21 < p < 1 [29].\n\n3\n4\n\nis inconsequential: the same class of problems has an FPRAS if we choose any\n\n7\n\n\fthe counting version of an NP-complete problem should be #P-complete is a theorem if #Pcompleteness is defined with respect to AP-reductions [18] but is not known to hold for other\ncandidate classes of reduction, such as Simon's parsimonious reductions [38] and polynomial-time\nTuring reductions.\n\n3\n\nClasses of relations\n\nA relation R \u2286 {0, 1}r is affine if it is the set of solutions to some system of linear equations\nover GF2L\n. That is, there is a set \u03a3 of equations in variables x1 , . . . , xr where each equation has\nthe form i\u2208I xi = c, where \u2295 denotes addition modulo 2, I \u2286 [1, r] and c \u2208 {0, 1}, and we have\n\u0101 \u2208 R if, and only if, the assignment x1 7\u2192 a1 , . . . , xr 7\u2192 ar satisfies every equation\nin \u03a3. Note\nL\nthat the empty relation is defined by the equation 0 = 1 (or, more formally, i\u2208\u2205 = 1) and the\ncomplete relation {0, 1}r is defined by the empty set of equations. If a variable xi occurs in an\nequation of the form xi = c, we say that it is pinned to c.\n\n3.1\n\nOR-conj, NAND-conj, IM-conj and normalized formulae\n\nLet OR-conj be the set of Boolean relations that are defined by conjunctions of pins and ORs of\nany arity and let NAND-conj be the set of Boolean relations definable by conjunctions of pins\nand NANDs (i.e., negated conjunctions) of any arity. For example, the 8-ary relation defined by\nthe formula\n(x1 = 0) \u2227 (x2 = 1) \u2227 OR(x3 , x4 , x5 , x6 ) \u2227 OR(x5 , x8 )\nis in OR-conj. (Note, also, that it does not constrain the variable x7 .) We say that one of the\ndefining formulae of these relations is normalized if\n\u2022 no pinned variable appears in any OR or NAND,\n\u2022 the arguments of each individual OR and NAND are distinct,\n\u2022 every OR or NAND has at least two arguments and\n\u2022 no OR or NAND's arguments are a subset of any other's.\nNote that the formula in the example above is normalized.\nLemma 2. Every OR-conj (respectively, NAND-conj) relation is defined by a unique normalized\nformula.\nProof. We show the result for OR-conj relations; the case for NAND-conj is similar.\nLet R be an OR-conj relation defined by the formula \u03c6. The second and subsequent occurrences of any variable within a single clause can be deleted. Any clause that contains a variable\npinned to one can be deleted; any variable that is pinned to zero can be deleted from any clause\nin which it appears. The disjunction OR(x) is equivalent to pinning x to one. If \u03c6 contains a\nclause that is a subset of another, any assignment that satisfies the smaller clause necessarily\nsatisfies the latter, which can, therefore, be deleted. This establishes that every OR-conj relation\nis defined by at least one normalized formula.\nTo prove uniqueness, suppose that the relation R \u2286 {0, 1}r is defined by the normalized\nformulae \u03c6 and \u03c8. The two formulae must obviously pin the same variables and we may assume\nthat none are pinned. Consider any clause in \u03c6, which we may assume, without loss of generality,\nto be OR(x1 , . . . , xk ). Since no clause of \u03c6 is a subset of {x1 , . . . , xk }, every other clause must\n8\n\n\finclude at least one variable from xk+1 , . . . , xr and, therefore, 0k\u22121 1r\u2212k+1 satisfies \u03c6 and 0k 1r\u2212k\ndoes not.\nNow, suppose that this clause does not appear in \u03c8. There are two cases. If \u03c8 contains\na clause whose variables are a subset of {x1 , . . . , xk }, which we may assume, without loss of\ngenerality, to be OR(x1 , . . . , xl ) for some l < k, then \u03c8 is not satisfied by 0k\u22121 1r\u2212k+1. Otherwise,\nevery clause of \u03c8 contains at least one variable from xk+1 , . . . , xr , so 0k 1r\u2212k satisfies \u03c8. In either\ncase, \u03c6 and \u03c8 define different relations. It follows that every clause that appears in \u03c6 must also\nappear in \u03c8. By symmetry, every clause that appears in \u03c8 must appear in \u03c6 so the two formulae\nare identical.\nGiven the uniqueness of defining normalized formulae, we define the width of an OR-conj or\nNAND-conj relation R to be width (R), the greatest number of arguments to any of the ORs or\nNANDs in the normalized formula that defines it. Note that, from the definition of normalized\nformulae, there are no relations of width 1. However, a conjunction of pins can be seen as an\nOR-conj formula with no ORs, i.e., of width 0: such a formula defines the complete relation,\npossibly padded with some constant columns. A conjunction of pins is also a NAND-conj formula\nwith no NANDs so we will usually just refer to these relations as \"relations of width 0.\" We\ndefine the width of an OR-conj or NAND-conj constraint language to be the greatest width of\nthe relations within it.\nWe define IM-conj to be the class of relations defined by conjunctions of pins and (binary)\nimplications - this class is called IM2 in [20]. We say that a conjunction of pins and implications is normalized if no pinned variable appears in an implication and the arguments of every\nimplication are distinct.\nLemma 3. Every relation in IM-conj is defined by a normalized formula.\nProof. Let R \u2208 IM-conj be defined by the formula \u03c6. Any implication x \u2192 x can be deleted\nas it does not constrain the value of x. If the variable y is pinned to zero then any implication\ny \u2192 z can be deleted and any implication z \u2192 y can be replaced by pinning z to zero. If y is\npinned to one, y \u2192 z can be replaced by pinning z to one and z \u2192 y can be deleted. Iterating,\nwe can remove all implications involving pinned variables.\nNote that, in contrast to normalized OR-conj and NAND-conj formulae, normalized IM-conj\nformulae are not necessarily unique. For example, the following three normalized formulae all\ndefine the same relation:\nx\u2192y \u2227 y\u2192z \u2227 z\u2192x\nx\u2192z \u2227 z\u2192y \u2227 y\u2192x\nx \u2192 y \u2227 y \u2192 x \u2227 x \u2192 z \u2227 z \u2192 x.\n\n3.2\n\nppp-defining Boolean connectives\n\nLemma 4. If R \u2208 IM-conj is not affine, then R\u2192 6ppp R.\nProof. Let R \u2208 IM-conj be defined by the normalized formula \u03c6. If there are variables x1 , . . . , xr\nsuch that \u03c6 contains the implications x1 \u2192 x2 , . . . , xr\u22121 \u2192 xr and xr \u2192 x1 then, in any\nsatisfying assignment for \u03c6, the variables x1 , . . . , xr must take the same value. Hence, we may\nassume that, if \u03c6 contains such a cycle of implications, it also contains xi \u2192 xj for every distinct\npair xi , xj \u2208 {x1 , . . . , xr }.\n9\n\n\fThere are two cases. First, if \u03c6 is symmetric (in the sense that, for every implication x \u2192 y\nin \u03c6, the formula also contains y \u2192 x) then \u03c6 is equivalent to a conjunction of pins and equalities\nbetween variables, so R is affine. Otherwise, there must be at least one pair of variables such\nthat x \u2192 y is a conjunct of \u03c6 but y \u2192 x is not. We ppp-define implication by pinning to zero\nevery unpinned variable v1 such that there is a chain of implications v1 \u2192 v2 , . . . , vr\u22121 \u2192 vr ,\nvr \u2192 x and pinning to one every other unpinned variable apart from x and y. Finally, project\nout the r \u2212 2 constant columns.\nLemma 5. If R \u2208 OR-conj has width w, then ROR,2 , . . . , ROR,w 6ppp R. Similarly, if R \u2208\nNAND-conj has width w, then RNAND,2 , . . . , RNAND,w 6ppp R.\nProof. Let R \u2208 OR-conj have arity r and width w. Let R be defined by the normalized formula\n\u03c6 which, without loss of generality, we may assume to contain the clause OR(x1 , . . . , xw ). Since\n\u03c6 is normalized, every other clause must contain at least one variable from xw+1 , . . . , xr . For\nany k with 2 6 k 6 w, we can ppp-define ROR,k by pinning xk+1 , . . . , xw to zero and pinning\nxw+1 , . . . , xr to one. The proof for R \u2208 NAND-conj is similar.\n\n3.3\n\nCharacterizations\n\nThe following proposition establishes a duality between OR-conj and NAND-conj relations.\ne is\nWhenever we say that R is OR-conj or NAND-conj, it is equivalent to say that R or R\ne is the bit-wise complement of R, as defined in Section 2.1. Of course, it is\nOR-conj, where R\ne is NAND-conj.\nalso equivalent to say that R or R\ne \u2208 NAND-conj.\nProposition 6. A relation R \u2286 {0, 1}r is in OR-conj if, and only if, R\nProof. Suppose R is defined by the normalized formula\n^ _\nxi ,\nP \u2227\n16j6m i\u2208Ij\n\ne is defined by the formula\nwhere P is a conjunction of pins and I1 , . . . , Im \u2286 [1, r]. Then R\n^ _\nP\u2032 \u2227\n\u00acxi ,\n16j6m i\u2208Ij\n\nwhere P \u2032 is the conjunction of pins with the opposite values to those in P . This formula is\nequivalent to\n^\n^\nP\u2032 \u2227\n\u00ac\nxi ,\n16j6m\n\ni\u2208Ij\n\nwhich is a NAND-conj formula, as required. The argument is reversible.\nGiven tuples \u0101, b\u0304 \u2208 {0, 1}r, we write \u0101 6 b\u0304 if ai 6 bi for all i \u2208 [1, r]. If \u0101 6 b\u0304 and \u0101 6= b\u0304,\nwe write \u0101 < b\u0304. We say that a relation R \u2286 {0, 1}r is monotone if, whenever \u0101 \u2208 R and \u0101 6 b\u0304,\nthen b\u0304 \u2208 R. We say that R is antitone if, whenever \u0101 \u2208 R and b\u0304 6 \u0101, then b\u0304 \u2208 R. That is,\nchanging zeroes to ones in a tuple in a monotone relation gives another tuple in the relation;\nsimilarly, antitone relations are preserved by changing ones to zeroes. It is easy to see that R is\ne is antitone. We say that a relation is pseudo-monotone (respectively,\nmonotone if, and only if, R\npseudo-antitone) if its restriction to non-constant columns is monotone (respectively, antitone).\nThe following is a simple consequence of results in [30, Section 7.1.1].\n10\n\n\fProposition 7. A relation R \u2286 {0, 1}r is in OR-conj (respectively, NAND-conj) if, and only\nif, it is pseudo-monotone (respectively, pseudo-antitone).\n\n4\n\nSimulating equality\n\nAn important ingredient in bounded-degree dichotomy theorems [6,25] is showing how to express\nequality using constraints from a constraint language that does not necessarily include the\nequality relation. In this section, we give the definitions that we need and some results about\nwhen equality can be expressed in our setting.\nRecall that, for all integers k > 2, R=,k is the k-ary equality relation {0k, 1k }. We say that\na constraint language \u0393 simulates R=,k if, for some l > k there is an integer m > 1 and a\n(\u0393 \u222a \u0393pin )-CSP instance I with variables x1 , . . . , xl and such that I has exactly m satisfying\nassignments \u03c3 with \u03c3(x1 ) = * * * = \u03c3(xk ) = 0, exactly m with \u03c3(x1 ) = * * * = \u03c3(xk ) = 1 and no\nother satisfying assignments. If, further, the degree of I is d and the degree of each variable\nx1 , . . . , xk is at most d \u2212 1, we say that \u0393 simulates R=,k with d variable repetitions or, for\nbrevity, that \u0393 d-simulates R=,k . We say that \u0393 d-simulates equality if it d-simulates R=,k for\nall k > 2. If only one relation R is involved in the simulation, we drop the curly brackets and\nsay that R, rather than {R}, d-simulates equality.\nThe point of this slightly strange definition is that, if \u0393 d-simulates equality, we can express\nthe constraint y1 = * * * = yk in \u0393 \u222a \u0393pin and then use each yi in one further constraint, while still\nhaving an instance of degree d. The variables xk+1 , . . . , xl in the definition function as auxiliary\nvariables and do not appear in any other constraint. This means that, if the variable y occurs\nk > d times in some instance, we can replace the successive occurrences with distinct variables\ny1 , . . . , yk that are constrained to be equal, giving an equivalent instance of degree at most d.\nConcepts similar to simulation have been used before, such as \"perfect implementation\" [13]\nand \"implementation\" [20]. The difference is that our setting demands degree bounds on the\nconstraints used in simulation and, for counting, we need to preserve the number of satisfying assignments (at least, up to some constant multiple) not just the existence of satisfying\nassignments.\nProposition 8. If \u0393 d-simulates equality, then #CSP(\u0393) 6AP #CSPd (\u0393 \u222a \u0393pin ).\nProof. Let I be an instance of #CSP(\u0393). We produce a new CSP instance I \u2032 over the constraint\nlanguage \u0393 augmented with R=,i constraints for certain values of i as follows. For each variable\nx that appears k > d times in I, replace the occurrences with new variables x1 , . . . , xk and add\nthe constraint R=,k (x1 , . . . , xk ). Clearly, Z(I \u2032 ) = Z(I).\nNote that every variable in I \u2032 either occurs exactly once in an equality constraint (one of the\nform R=,i (x\u0304)) and exactly once in a \u0393-constraint or occurs in no equality constraints and at most\nd times in \u0393-constraints. Since \u0393 d-simulates equality, we can replace the equality constraints\nwith (\u0393 \u222a \u0393pin )-constraints, using fresh auxiliary variables for each equality, to give an instance\nI \u2032\u2032 of #CSP(\u0393 \u222a \u0393pin ) with degree d. There is some constant m, depending only on the number\nand arities of the equality constraints in I \u2032, such that Z(I \u2032\u2032 ) = mZ(I \u2032 ). Since m can be computed\nin polynomial time, we have an AP-reduction.\nLemma 9. Let R \u2286 {0, 1}r. If R= 6ppp R, R6= 6ppp R or R\u2192 6ppp R, then R 3-simulates\nequality.\nNote that, if R\u2190 6ppp R then R\u2192 6ppp R, also.\n11\n\n\fProof of Lemma 9. For each k > 2, we show how to 3-simulate R=,k . We may assume without\nloss of generality that the ppp definition of R= , R6= or R\u2192 from R involves applying the identity\npermutation to the columns, pinning columns 3 to 3 + p \u2212 1 inclusive to zero, pinning columns\n3 + p to 3 + p + q \u2212 1 inclusive to one (that is, pinning p > 0 columns to zero and q > 0 to one)\nand then projecting away all but the first two columns.\nSuppose first that R= 6ppp R or R\u2192 6ppp R. R must contain \u03b1 > 1 tuples that begin\n000p 1q , \u03b2 > 0 that begin 010p 1q and \u03b3 > 1 that begin 110p 1q , and we have \u03b2 = 0 unless we are\nppp-defining R\u2192 .\nWe consider, first, the case where \u03b1 = \u03b3, and show that we can 3-simulate R=,k , expressing\nthe constraint R=,k (x1 , . . . , xk ) with the constraints\nR(x1 x2 0p 1q \u2217), R(x2 x3 0p 1q \u2217), . . . , R(xk\u22121 xk 0p 1q \u2217), R(xk x1 0p 1q \u2217) ,\nwhere \u2217 denotes a fresh (r\u22122\u2212p\u2212q)-tuple of variables in each constraint. This set of constraints\nis equivalent to either x1 = * * * = xk = x1 or x1 \u2192 * * * \u2192 xk \u2192 x1 so, in either case, constrains\nthe variables x1 , . . . , xk to have the same value, as required. Every variable appears at most\ntwice and there are \u03b1k solutions to these constraints that put x1 = * * * = xk = 0, the same\nnumber with x1 = * * * = xk = 1 and no other solutions. Therefore, R 3-simulates R=,k .\nWe now show, by induction on r, the arity of R, that we can 3-simulate R=,k even if \u03b1 is not\nnecessarily equal to \u03b3. For the base case, r = 2, we have \u03b1 = \u03b3 = 1 and we are done. For the\ninductive step, let r > 2 and assume, without loss of generality that \u03b1 > \u03b3 (we are already done\nif \u03b1 = \u03b3 and the case \u03b1 < \u03b3 is symmetric). In particular, we have \u03b1 > 2, so there are distinct\ntuples 000p 1q \u0101 and 000p 1q b\u0304 in R. R also contains a tuple 110p 1q c\u0304. Choose j such that aj 6= bj .\nPinning the (2 + p + q + j)th column of R to cj and projecting out the resulting constant column\ngives a relation of arity r \u2212 1 that still contains at least one tuple beginning 000p 1q and at least\none beginning 110p 1q : by the inductive hypothesis, this relation 3-simulates R=,k .\nFinally, we consider the case that R6= 6ppp R. R contains \u03b1 > 1 tuples beginning 010p 1q\nand \u03b2 > 1 beginning 100p 1q and no other tuples. We express the constraint R=,k (x1 , . . . , xk ) by\nintroducing fresh variables y1 , . . . , yk and using the constraints\nR(x1 y1 0p 1q \u2217), R(y1 x2 0p 1q \u2217),\nR(x2 y2 0p 1q \u2217), R(y2 x3 0p 1q \u2217),\n..\n.\nR(xk\u22121 yk\u22121 0p 1q \u2217), R(yk\u22121 xk 0p 1q \u2217),\nR(xk yk 0p 1q \u2217), R(yk x1 0p 1q \u2217) ,\nwhere \u2217 denotes a fresh (r \u2212 2 \u2212 p \u2212 q)-tuple of variables in each constraint, as before. These\nconstraints have \u03b1k \u03b2 k solutions with x1 = * * * = xk = 0 and y1 = * * * = yk = 1 and \u03b2 k \u03b1k\nsolutions that assign 1 to all the x's and 0 to all the y's. There are no other solutions and no\nvariable is used more than twice.\nThe following technical lemma and the definitions that support it are used only to prove\nLemma 11. For c \u2208 {0, 1}, an r-ary relation is c-valid if it contains the tuple cr. Given a relation\nR \u2286 {0, 1}r, a tuple \u0101 \u2208 R that contains both zeroes and ones and a constant c \u2208 {0, 1}, let\nR\u0101,c be the result of pinning the set of columns {i | ai = c} to c and then projecting out those\ncolumns. Observe that R\u0101,c is always (1 \u2212 c)-valid (because it contains the projection of \u0101) and\nis c-valid if R is (because then it contains the projection of cr ).\n12\n\n\fLemma 10. Let r > 3 and let R=,r ( R ( {0, 1}r. There are \u0101 \u2208 R and c \u2208 {0, 1} such that\nR\u0101,c is not complete.\nProof. Suppose there is a tuple \u0101 \u2208 R \\ {0r } such that changing some zero in \u0101 to a one gives\na tuple \u0101\u2032 \u2208\n/ R. Then R\u0101,1 does not contain the relevant projection of \u0101\u2032 and we are done.\nSimilarly, if there is a tuple b\u0304 \u2208 R \\ {1r } that leaves R by changing some one to a zero, then\nRb\u0304,0 is not complete. If no such tuple exists, then either R = {0, 1}r or R = R=,r , contradicting\nour assumptions.\nLemma 11. Let r > 2 and let R \u2282 {0, 1}r be 0- and 1-valid but not complete. Then R 3simulates equality.\nProof. We show by induction on r that either R= or R\u2192 is ppp-definable in R, and the result\nfollows by Lemma 9.\nIn the case r = 2, R is either R= , R\u2192 or R\u2190 . For r > 3, if R = R=,r then proj1,2 R = R= .\nOtherwise, by Lemma 10, there is some \u0101 \u2208 R and c \u2208 {0, 1} such that R\u0101,c is not complete.\nSince R\u0101,c 6ppp R and is 0- and 1-valid, we are done by the inductive hypothesis.\nWe will next show that, if binary OR is ppp-definable in R and binary NAND in R\u2032, then the\nconstraint language {R, R\u2032 } 3-simulates equality (R and R\u2032 need not be distinct). To do this,\nwe will use the following sets of constraints, \u03bek , for k > 2:\n\u03bek = {ROR (xi , yi ) | 1 6 i 6 k}\n\u222a {RNAND (yi , xi+1 ) | 1 6 i < k} \u222a {RNAND (yk , x1 )} .\nThe key point about these constraints is that they show that the language {ROR , RNAND }\n3-simulates equality.\nLemma 12. An assignment \u03c3 to {x1 , . . . , xk , y1 , . . . , yk } satisfies all constraints in \u03bek if, and\nonly if, \u03c3(x1 ) = * * * = \u03c3(xk ) 6= \u03c3(y1 ) = * * * = \u03c3(yk ).\nProof. It is easy to check that assignments of the given type satisfy \u03bek . Conversely, suppose that\n\u03c3 satisfies \u03bek .\nIf \u03c3(x1 ) = 0, we have \u03c3(y1 ) = 1 because ROR (x1 , y1 ) is satisfied and we must have \u03c3(x2 ) = 0\nbecause RNAND (y1 , x2 ) is satisfied. By a trivial induction, \u03c3(xi ) = 0 and \u03c3(yi ) = 1 for all i.\nOtherwise, \u03c3(x1 ) = 1. If \u03c3(xi ) = 0 for any i > 1 then, by the same argument as above,\n\u03c3(xi ) = 0 for all i \u2208 [1, k], contradicting the assumption that \u03c3(x1 ) = 1. Therefore, \u03c3(xi ) = 1\nfor all i. To satisfy the constraints RNAND (yi , xi+1 ), we must have \u03c3(yi ) = 0 for all i.\nWe now show that, in fact, we do not need to have ROR and RNAND in our constraint\nlanguage \u0393: it suffices to be able to ppp-define them from relations in \u0393.\nLemma 13. If ROR 6ppp R and RNAND 6ppp R\u2032 then {R, R\u2032 } 3-simulates equality.\nProof. Suppose first that R and R\u2032 are two distinct relations. We may assume, as in the proof\nof Lemma 9, that the ppp definition of ROR from R involves performing some permutation and\nprojecting to the first two columns after pinning the next p columns to zero and the q columns\nafter that to one. We may suppose further that we cannot pin any more columns of R and still\nppp-define ROR . Without loss of generality, we may assume the permutation to be the identity.\n\n13\n\n\fUnder these assumptions, R contains \u03b1 > 1 tuples beginning 010p 1q, \u03b2 > 1 tuples beginning\nand \u03b3 > 1 tuples beginning 110p 1q, but none beginning 000p 1q. We first show that, if\n\u03b1 6= \u03b2, then we are done because R6= 6ppp R, so R 3-simulates equality by Lemma 9\nTo this end, suppose \u03b1 > \u03b2 so, in particular, \u03b1 > 2 and there are distinct tuples 010p 1q \u0101\nand 010p 1q b\u0304 in R. We may assume, without loss of generality, that a1 6= b1 . Since \u03b2 > 1, there\nis at least one tuple 100p 1q c\u0304 \u2208 R. Suppose, now that we pin the (2 + p + q + 1)th column of\nR to c1 . R cannot contain any tuple 110p 1q d \u0304 with d1 = c1 because it is not possible to pin\nmore columns and still ppp-define ROR . But then R contains tuples beginning with each of\n010p 1q c1 and 100p 1q c1 and none beginning 000p 1q c1 or 110p 1q c1 , so R6= 6ppp R. We similarly\nhave R6= 6ppp R if \u03b1 < \u03b2. From this point, we may assume that \u03b1 = \u03b2.\nSimilarly, either R6= 6ppp R\u2032, so we are done, or R\u2032 contains \u03b1\u2032 tuples beginning with each\n\u2032\n\u2032\n\u2032\n\u2032\n\u2032\n\u2032\n\u2032\n\u2032\nof 010p 1q and 100p 1q , \u03b3 \u2032 tuples beginning 000p 1q and no tuples beginning 110p 1q .\nWe now show how to simulate equality. We can 3-simulate R=,k by replacing the constraint\nR=,k (x1 , . . . , xk ) with the following set of constraints, modelled on \u03bek :\n100p 1q\n\n\u039ek = {R(xi yi 0p 1q \u2217) | 1 6 i 6 k}\n\u2032\n\n\u2032\n\n\u2032\n\n\u2032\n\n\u222a {R\u2032 (yi xi+1 0p 1q \u2217) | 1 6 i < k} \u222a {R\u2032 (yk x1 0p 1q \u2217)} ,\nwhere the yi are fresh variables and, as before, \u2217 denotes a fresh tuple of variables for each\nconstraint, of the appropriate length. By Lemma 12, an assignment \u03c3 satisfies \u039ek if, and only\nif, \u03c3(x1 ) = * * * = \u03c3(xk ) 6= \u03c3(y1 ) = * * * = \u03c3(yk ).\nFurther, there are \u03b1 ways to satisfy the variables denoted by \u2217 in each R constraint and\n\u2032\n\u03b1 ways in each R\u2032 constraint. Therefore, there are (\u03b1\u03b1\u2032 )k satisfying assignments for \u039ek corresponding to each satisfying assignment for R=,k and we are done.\nNotice that our assumption that the ppp definitions of ROR in R and RNAND in R\u2032 involve\nthe identity permutation, pinning sequential columns to zero and one and projecting to the first\ntwo columns was made only for the notational convenience of referring to \"tuples beginning\n010p 1q \" and so on. This being the case, there is no requirement that R and R\u2032 be distinct, so\nthe proof is complete.\nNote that there are relations, such as R=,3 , that 2-simulate equality, though we do not require\nthis, here, so we omit the proof.\n\n5\n\nClassifying relations\n\nWe are now ready to prove that every Boolean relation R is in OR-conj, in NAND-conj or\n3-simulates equality. Given r-ary relations R0 and R1 , we write R0 + R1 for the relation {0\u0101 |\n\u0101 \u2208 R0 } \u222a {1\u0101 | \u0101 \u2208 R1 }. The proof of the classification is by induction on the arity of R and\nproceeds by decomposing R as R0 + R1 .\nRecall that a width-zero OR-conj (or, equivalently, NAND-conj) relation is a complete relation, possibly padded with some constant columns.\nLemma 14. Let R0 , R1 \u2286 OR-conj have arity r and width zero and let R = R0 + R1 . Then,\nR \u2208 OR-conj, R \u2208 NAND-conj or R 3-simulates equality.\nProof. We may assume that R has no constant columns, since adding or removing them does\nnot affect whether a relation is OR-conj or NAND-conj or whether it 3-simulates equality.\n\n14\n\n\fFor i \u2208 [2, r + 1], let Ri\u2032 = proj1,i R, so each Ri\u2032 6ppp R. If any Ri\u2032 is R= , R6= , R\u2192 or R\u2190\nthen R 3-simulates equality by Lemma 9. Otherwise, each Ri\u2032 is either {0, 1}2, ROR or RNAND .\nIf Rj\u2032 = ROR and Rk\u2032 = RNAND for some j and k, then R 3-simulates equality by Lemma 13.\nOtherwise, if no Ri\u2032 = RNAND , let I = {i | Ri\u2032 = ROR }. Then,\n^\nR=\nOR(x1 , xi ) ,\ni\u2208I\n\nso R \u2208 OR-conj. If no Ri\u2032 = ROR , then R \u2208 NAND-conj, by a similar argument.\nLemma 15. Let R0 , R1 \u2286 {0, 1}r be OR-conj and let R = R0 + R1 . Then, R \u2208 OR-conj,\nR \u2208 NAND-conj or R 3-simulates equality.\nProof. We may assume, as before, that R has no constant columns. We may also assume that at\nleast one of R0 and R1 has positive width: otherwise, the result is immediate from the previous\nlemma. We split the remaining work into two cases.\nCase 1: R0 \u2286 R1 . Note that R1 cannot have any constant columns in this case, since the same\ncolumn would also have to be constant in R0 , giving a constant column in R.\nSuppose Ri is defined by the normalized OR-conj formula \u03c6i in variables x2 , . . . , xr+1 . Then\nR is defined by the formula\n\u03c60 \u2228 (x1 = 1 \u2227 \u03c61 ) \u2261 (\u03c60 \u2228 x1 = 1) \u2227 (\u03c60 \u2228 \u03c61 )\n\u2261 (\u03c60 \u2228 x1 = 1) \u2227 \u03c61 ,\n\n(1)\n\nwhere the first equivalence is the distribution law and the second is because \u03c60 implies \u03c61\n(because R0 \u2286 R1 ). We consider the following two cases.\nCase 1.1: R0 has no constant columns. \u03c60 contains no pins and x1 = 1 is equivalent to OR(x1 )\nso we can rewrite \u03c60 \u2228 x1 = 1 in CNF. Therefore, (1) defines an OR-conj relation.\nCase 1.2: R0 has a constant column. R1 has no constant columns so, if projk R0 = {0} for some\nk, then proj1,k+1 R = R\u2190 , and R 3-simulates equality by Lemma 9. If every constant column of\nR0 is all ones, then \u03c60 is in CNF since every pinning xi = 1 in \u03c60 can be written OR(xi ). We\ncan therefore rewrite \u03c60 \u2228 x1 = 1 in CNF, as in Case 1.1.\nCase 2: R0 * R1 . We will show that R 3-simulates equality or is in NAND-conj. We consider\ntwo cases.\nCase 2.1: R1 has a constant column, say the kth. If the kth column of R0 is also constant, it\nmust have the opposite value (or R would have a constant column). Therefore, proj1,k+1 R is\neither R= or R6= , so R 3-simulates equality by Lemma 9.\nOtherwise, the kth column of R0 is not constant, so proj1,k+1 R is either R\u2192 or RNAND . In\nthe first case, R 3-simulates equality by Lemma 9. In the second case, ROR is ppp-definable in\nat least one of R0 and R1 by Lemma 5 so R 3-simulates equality by Lemma 13.\nCase 2.2: R1 has no constant columns. By Proposition 7, R1 is monotone. Let \u0101 \u2208 R0 \\ R1 : by\napplying the same permutation to the columns of R0 and R1 , we may assume that \u0101 = 0l 1r\u2212l .\nWe must have l > 1 as every non-empty r-ary monotone relation contains the tuple 1r. Let b\u0304 \u2208 R1\nbe a tuple such that ai = bi for all i in a maximal initial segment of [1, r]. By monotonicity of\nR1 , we may assume that b\u0304 = 0k 1r\u2212k . Further, we must have k < l, since, otherwise, we would\nhave b\u0304 < \u0101, contradicting our choice of \u0101 \u2208\n/ R1 .\n\n15\n\n\fNow, consider the relation\nR\u2032 = {a0 a1 . . . al\u2212k | a0 0k a1 . . . al\u2212k 1r\u2212l \u2208 R} ,\nwhich is the result of pinning columns 2 to (k + 1) of R to zero and columns (r \u2212 l + 1) to (r + 1)\nto one and discarding the resulting constant columns. R\u2032 contains 0l\u2212k+1 and 1l\u2212k+1 but is not\ncomplete, as 10l\u2212k \u2208\n/ R\u2032. By Lemma 11, R\u2032 3-simulates equality, so R does, too.\nf f\nThe following corollary follows from Proposition 6 and the facts that R^\n0 + R1 = R1 + R0\ne\nf\nand that, if R 3-defines equality, then so does R, since R= = R= .\nCorollary 16. Let R0 , R1 \u2208 NAND-conj and let R = R0 + R1 . Then R \u2208 OR-conj, R \u2208\nNAND-conj or R 3-simulates equality.\nTheorem 17. Every Boolean relation is in OR-conj, is in NAND-conj or 3-simulates equality.\nProof. Let R be a Boolean relation. We proceed by induction on its arity, r. If r 6 2, then,\nif R is neither OR-conj nor NAND-conj then it can only be R= , R6= , R\u2192 or R\u2190 ; all of these\n3-simulate equality by Lemma 9.\nNow let R have arity r + 1 > 2 and let R0 and R1 be such that R = R0 + R1 . By the\ninductive hypothesis, each of R0 and R1 is in OR-conj, in NAND-conj or 3-simulates equality.\nIf either of R0 and R1 3-simulates equality, then so does R. Otherwise, either both are\nin OR-conj, both are in NAND-conj or one is in OR-conj and the other in NAND-conj. In\nthe first two cases, R is in OR-conj or in NAND-conj or 3-simulates equality by Lemma 15 or\nCorollary 16. In the third case, if R0 and R1 have positive width, then R 3-simulates equality\nby Lemma 13; otherwise, we are in one of the first two cases.\n\n6\n\nComplexity\n\nThe complexity of approximating #CSP(\u0393) where the degree of instances is unbounded is given\nby Dyer, Goldberg and Jerrum [20, Theorem 3].\nTheorem 18. Let \u0393 be a Boolean constraint language.\n\u2022 If every R \u2208 \u0393 is affine, then #CSP(\u0393) \u2208 FP.\n\u2022 Otherwise, if \u0393 \u2286 IM-conj, then #CSP(\u0393) \u2261AP #BIS.\n\u2022 Otherwise, #CSP(\u0393) \u2261AP #SAT.\nTowards our classification of the approximation complexity of bounded-degree #CSP(\u0393),\nwe first deal with sub-cases. Recall that #BIS is the problem of counting independent sets in\nbipartite graphs and #w-HISd is that of counting independent sets in hypergraphs where every\nvertex has degree at most d and every hyper-edge contains at most w vertices.\nProposition 19. If \u0393 \u2286 IM-conj contains at least one non-affine relation then, for all d > 3,\n#CSPd (\u0393 \u222a \u0393pin ) \u2261AP #BIS.\nProof. It is immediate from [20, Lemma 9] that #CSPd (\u0393 \u222a \u0393pin ) 6AP #BIS.\nFor the converse, first observe that, by [20, Lemma 8], #BIS 6AP #CSP({R\u2192 }) and, since\nR\u2192 3-simulates equality by Lemma 9, we have #CSP({R\u2192 }) 6AP #CSPd ({R\u2192 } \u222a \u0393pin ) for all\nd > 3 by Proposition 8. We must show that #CSPd ({R\u2192 } \u222a \u0393pin ) 6AP #CSPd (\u0393 \u222a \u0393pin ).\n16\n\n\fTo this end, let R be any non-affine relation in \u0393. By Lemma 4, R\u2192 6ppp R and the\nppp definition involves projecting only pinned columns. Therefore, we can express the constraint\nR\u2192 (x, y) by a constraint of the form R(v1 , . . . , vr ), where, for some i and j, vi = x and vj = y\nand the other variables are pinned to zero or one.\nLemma 20. For d > 2 and w > 2,\n#w-HISd \u2261AP #CSPd ({ROR,w } \u222a \u0393pin ) \u2261AP #CSPd ({RNAND,w } \u222a \u0393pin ).\nProof. The second equivalence is trivial, since ROR,w and RNAND,w are bit-wise-complements.\nFor the first equivalence, let H be an instance of #w-HISd . We create an instance of\n#CSPd ({ROR,w } \u222a \u0393pin ) as follows. The variables are {xv | v \u2208 V (H)} and, for each hyperedge {v1 , . . . , vs }, there is a constraint ROR,w (xv1 , . . . , xvs , 0, . . . , 0). Each vertex appears in at\nmost d hyper-edges so each variable appears in at most d constraints. It is easy to see that a\nconfiguration \u03c3 of the resulting #CSPd ({ROR,w } \u222a \u0393pin ) instance is satisfying if, and only if,\n{v | \u03c3(xv ) = 0} is an independent set in H.\nConversely, if we are given an instance of #CSPd ({ROR,w } \u222a \u0393pin ), we create an instance\nH of #w-HISd as follows. There is a vertex vx for every variable x. For every constraint\nROR,w (x1 , . . . , xw ) (where the xi are not necessarily distinct), add the hyper-edge {vx1 , . . . , vxw }.\nNow, for every constraint Rzero (x), delete the vertex vx and remove it from every hyper-edge that\ncontains it. For every constraint Rone (x), delete vx and delete every hyper-edge that contains\nit. It is easy to see that a configuration \u03c3 is satisfying if, and only if, it satisfies the pins and\nthe set {vx | \u03c3(x) = 0} \u2229 V (H) is independent in H.\nIn the following two propositions, we just prove the OR-conj cases; the NAND-conj cases\nare equivalent.\nProposition 21. Let R be an OR-conj or NAND-conj relation of width w > 0. Then, for d > 2,\n#w-HISd 6AP #CSPd ({R} \u222a \u0393pin ).\nProof. By Lemma 5, ROR,w 6ppp R and the ppp definition involves pinning and then projecting\naway all but w of the columns. Thus, an ROR,w -constraint can be simulated by an R-constraint\nin which some elements of the scope are constants. The result follows from Lemma 20.\nWe define the variable rank of an OR-conj or NAND-conj relation R to be vrank (R), the\ngreatest number of times that any variable appears in the (unique) normalized formula that\ndefines R. We similarly define the variable rank of an OR-conj or NAND-conj constraint language\nto be the maximum variable rank of the relations within it.\nProposition 22. Let R be an OR-conj or NAND-conj relation of width w > 0 and variable\nrank k. Then, for d > 2, #CSPd ({R} \u222a \u0393pin ) 6AP #w-HISkd .\nProof. Given an instance I of #CSPd ({R} \u222a \u0393pin ), we produce an instance I \u2032 of the problem\n#CSP({ROR,2 , . . . , ROR,w } \u222a \u0393pin ) with the same variables by replacing every R-constraint with\nthe ROR,i -constraints and pins corresponding to the normalized formula that defines R. Clearly,\nZ(I) = Z(I \u2032 ) but a variable that appeared d times in I appears up to kd times in I \u2032, so we have\nestablished that\n#CSPd ({R} \u222a \u0393pin ) 6AP #CSPkd ({ROR,2 , . . . , ROR,w } \u222a \u0393pin )\n6AP #CSPkd ({ROR,w } \u222a \u0393pin ) ,\n17\n\n\fwhere the last reduction holds because, for any s < w, the constraint ROR,s (x1 , . . . , xs ) is equivalent to ROR,w (x1 , . . . , xs , 0, . . . , 0). By Lemma 20, #CSPkd ({ROR,w } \u222a \u0393pin ) \u2261AP #w-HISkd .\nWe now give the complexity of approximating #CSPd (\u0393 \u222a \u0393pin ) for d > 3.\nTheorem 23. Let \u0393 be a Boolean constraint language and let d > 3.\n\u2022 If every R \u2208 \u0393 is affine, then #CSPd (\u0393 \u222a \u0393pin ) \u2208 FP.\n\u2022 Otherwise, if \u0393 \u2286 IM-conj, then #CSPd (\u0393 \u222a \u0393pin ) \u2261AP #BIS.\n\u2022 Otherwise, if \u0393 \u2286 OR-conj or \u0393 \u2286 NAND-conj, then #w-HISd 6AP #CSPd (\u0393 \u222a \u0393pin ) 6AP\n#w-HISkd , where w = width (\u0393) and k = vrank (\u0393).\n\u2022 Otherwise, #CSPd (\u0393 \u222a \u0393pin ) \u2261AP #SAT.\nProof. The first three cases are immediate from Theorem 18 and Propositions 19, 21 and 22.\nNote that \u0393 \u222a \u0393pin is affine if, and only if, \u0393 is.\nFor the remaining case, suppose that \u0393 is not affine, \u0393 * IM-conj, \u0393 * OR-conj and \u0393 *\nNAND-conj. Since \u0393\u222a\u0393pin is neither affine nor a subset of IM-conj, we have #CSP(\u0393\u222a\u0393pin ) \u2261AP\n#SAT by Theorem 18 so, if we can show that \u0393 d-simulates equality, then #CSPd (\u0393 \u222a \u0393pin ) \u2261AP\n#CSP(\u0393 \u222a \u0393pin ) by Proposition 8 and we are done. If \u0393 contains a relation R that is neither\nOR-conj nor NAND-conj, then R 3-simulates equality by Theorem 17. Otherwise, \u0393 must\ncontain distinct relations R1 \u2208 OR-conj and R2 \u2208 NAND-conj that are non-affine so have width\nat least two, so \u0393 3-simulates equality by Lemma 13.\nSly has shown that there can be no FPRAS for the problem of counting independent sets\nin graphs of maximum degree at least 6, unless NP = RP [39]. Clearly, if there is no FPRAS\nfor counting independent sets in such graphs, there can be no FPRAS for #w-HISd with w > 2\nand d > 6. Further, since #SAT is complete for #P with respect to AP-reducibility [18], #SAT\ncannot have an FPRAS unless NP = RP. Thus, Theorem 24 below is an immediate corollary\nof Theorem 23.\nTheorem 24. Let \u0393 be a Boolean constraint language and let d > 6.\n\u2022 If every R \u2208 \u0393 is affine, then #CSPd (\u0393 \u222a \u0393pin ) \u2208 FP.\n\u2022 Otherwise, if \u0393 \u2286 IM-conj, then #CSPd (\u0393 \u222a \u0393pin ) \u2261AP #BIS.\n\u2022 Otherwise, there is no FPRAS for #CSPd (\u0393 \u222a \u0393pin ), unless NP = RP.\nNote that \u0393 \u222a \u0393pin is affine (respectively, in OR-conj or in NAND-conj) if, and only if, \u0393 is.\nTherefore, the case for large-degree instances (d > 6) corresponds exactly in complexity to the\nunbounded case [20].\nFor lower degree bounds, the picture is more complex. To put Theorem 23 in context,\nsummarize what is known about the approximability of #w-HISd for various values of d and w.\nThe case d = 1 is clearly in FP (Theorem 1) and so is the case d = w = 2, which corresponds\nto counting independent sets in graphs of maximum degree two. For d = 2 and width w > 3,\nDyer and Greenhill have shown that there is an FPRAS for #w-HISd [23]. For d = 3, they have\nshown that there is an FPRAS if the width w is at most 3. For larger width, the approximability\nof #w-HIS3 is still not known. With the width restricted to w = 2 (ordinary graphs), Weitz has\nshown that, for degree d \u2208 {3, 4, 5}, there is a deterministic approximation scheme that runs in\npolynomial time (a PTAS) [43]. This extends a result of Luby and Vigoda, who gave an FPRAS\n18\n\n\fDegree d\n1\n2\n2\n3\n3, 4, 5\n>6\n\nWidth w\n>2\n2\n>3\n2, 3\n2\n>2\n\nApproximability of #w-HISd\nExact counting in FP\nExact counting in FP\nFPRAS [23]\nFPRAS [23]\nPTAS [43]\nNo FPRAS unless NP = RP [39]\n\nTable 1: A summary of known approximability of #w-HISd . For values of d and w not covered\nby the table, the approximability is still unknown.\nfor d 6 4 [35]. For d > 5, approximating #w-HISd becomes considerably harder. Dyer, Frieze\nand Jerrum showed that, for d = 6, the Monte Carlo Markov chain technique is likely to fail,\nin the sense that a certain class of Markov chains are provably slowly mixing [17]. They also\nshowed that, for d = 25, there can be no polynomial-time algorithm for approximate counting,\nunless NP = RP. As mentioned above, Sly has recently improved on this, showing that there\ncan be no FPRAS for d > 6 unless NP = RP. Table 1 summarizes the results.\nReturning to bounded-degree #CSP, the case d = 2 seems to have a rather different flavour\nto higher degree bounds. This is also the case for decision CSP - recall that the complexity of\ndegree-d CSP(\u0393 \u222a \u0393pin ) is the same as unbounded-degree CSP(\u0393 \u222a \u0393pin ) for all d > 3 [14], while\ndegree-2 CSP(\u0393 \u222a \u0393pin ) is often easier than the unbounded-degree case [14,25] but there are still\nconstraint languages \u0393 for which the complexity of degree-2 CSP(\u0393 \u222a \u0393pin ) is open.\nOur key techniques for determining the complexity of #CSPd (\u0393 \u222a \u0393pin ) for d > 3 are the\n3-simulation of equality and Theorem 17, which says that every Boolean relation is in OR-conj,\nin NAND-conj or 3-simulates equality. However, it seems that not all relations that 3-simulate\nequality also 2-simulate equality so the corresponding classification of relations does not appear\nto hold. It seems that different techniques will be required for the degree-2 case. For example,\nit is possible that there is no FPRAS for #BIS and, therefore, no FPRAS for #CSP3 (\u0393 \u222a \u0393pin )\nexcept when \u0393 is affine. However, Bubley and Dyer have shown that there is an FPRAS for the\nrestriction of #SAT in which each variable appears at most twice, even though the exact counting\nproblem is #P-complete [2]; the corresponding constraint language is not affine. This also shows\nthat there is a class C of constraint languages for which #CSP2 (\u0393 \u222a \u0393pin ) has an FPRAS for\nevery \u0393 \u2208 C but for which no exact polynomial-time algorithm exists, unless FP = #P.\nWe leave the complexity of degree-2 #CSP and of #BIS and the various parameterized\nversions of the counting hypergraph independent sets problem as open questions.\n\nReferences\n[1] M. Bordewich. On the approximation complexity hierarchy. In 8th International Workshop\non Approximation and Online Algorithms (WOAO 2010), volume 6534 of LNCS, pages\n37\u201346, 2011.\n[2] R. Bubley and M. E. Dyer. Graph orientations with no sink and an approximation for a\nhard case of #SAT. In 8th ACM\u2013SIAM Symposium on Discrete Algorithms (SODA 1997),\npages 248\u2013257, 1997.\n\n19\n\n\f[3] A. A. Bulatov. A dichotomy theorem for constraint satisfaction problems on a 3-element\ndomain. Journal of the ACM, 53(1):66\u2013120, 2006.\n[4] A. A. Bulatov. The complexity of the counting constraint satisfaction problem. In 35th\nInternational Colloquium on Automata, Languages and Programming (ICALP 2008) Part\nI, volume 5125 of LNCS, pages 646\u2013661. Springer, 2008.\n[5] J.-Y. Cai and X. Chen. A decidable dichotomy theorem on directed graph homomorphisms\nwith non-negative weights. In 51st IEEE Symposium on Foundations of Computer Science\n(FOCS 2010), pages 437\u2013446. IEEE Computer Society, 2010.\n[6] J.-Y. Cai, P. Lu, and M. Xia. The complexity of complex weighted Boolean #CSP. Article\nin preparation, 2009.\n[7] J.-Y. Cai, P. Lu, and M. Xia. Holant problems and counting CSP. In 41st Annual ACM\nSymposium on Theory of Computing (STOC 2009), pages 715\u2013724, 2009.\n[8] D. A. Cohen and P. G. Jeavons. The complexity of constraint languages. In Handbook of\nConstraint Programming, chapter 8. Elsevier, 2006.\n[9] D. A. Cohen, P. G. Jeavons, and M. Gyssens. A unified theory of structural tractability for\nconstraint satisfaction problems. Journal of Computer and System Sciences, 74(5):721\u2013743,\n2008.\n[10] B. Courcelle. Graph rewriting: An algebraic and logic approach. In J. van Leeuwen, editor,\nHandbook of Theoretical Computer Science, pages 194\u2013242. Elsevier, 1990.\n[11] B. Courcelle, J. A. Makowski, and U. Rotics. On the fixed parameter complexity of graph\nenumeration problems definable in monadic second order logic. Discrete Applied Mathematics, 108(1\u20132):23\u201352, 2001.\n[12] N. Creignou and M. Hermann. Complexity of generalized satisfiability counting problems.\nInformation and Computation, 125(1):1\u201312, 1996.\n[13] N. Creignou, S. Khanna, and M. Sudan. Complexity Classification of Boolean Constraint\nSatisfaction Problems. SIAM, 2001.\n[14] V. Dalmau and D. K. Ford. Generalized satisfiability with limited occurrences per variable:\nA study through Delta-matroid parity. In Mathematical Foundations of Computer Science\n(MFCS 2003), volume 2747 of LNCS, pages 358\u2013367. Springer, 2003.\n[15] R. Dechter and J. Pearl. Tree clustering for constraint networks. Artificial Intelligence,\n38(3):353\u2013366, 1989.\n[16] J. D\u0131\u0301az, M. Serna, and D. M. Thilikos. Counting h-colorings of partial k-trees. Theoretical\nComputer Science, 281(1\u20132):291\u2013309, 2002.\n[17] M. E. Dyer, A. Frieze, and M. R. Jerrum. On counting independent sets in sparse graphs.\nSIAM Journal on Computing, 31(5):1527\u20131541, 2002.\n[18] M. E. Dyer, L. A. Goldberg, C. S. Greenhill, and M. R. Jerrum. The relative complexity\nof approximate counting problems. Algorithmica, 38(3):471\u2013500, 2003.\n20\n\n\f[19] M. E. Dyer, L. A. Goldberg, and M. R. Jerrum. The complexity of weighted Boolean #CSP.\nSIAM Journal on Computing, 38(5):1970\u20131986, 2009.\n[20] M. E. Dyer, L. A. Goldberg, and M. R. Jerrum. An approximation trichotomy for Boolean\n#CSP. Journal of Computer and System Sciences, 76(3\u20134):267\u2013277, 2010.\n[21] M. E. Dyer, L. A. Goldberg, and M. Paterson. On counting homomorphisms to directed\nacyclic graphs. Journal of the ACM, 54(6), 2007.\n[22] M. E. Dyer and C. S. Greenhill. The complexity of counting graph homomorphisms. Random\nStructures and Algorithms, 17(3\u20134):260\u2013289, 2000. (Corrigendum in Random Structures and\nAlgorithms, 25(3):346\u2013352, 2004.).\n[23] M. E. Dyer and C. S. Greenhill. On Markov chains for independent sets. Journal of\nAlgorithms, 35(1):17\u201349, 2000.\n[24] M. E. Dyer and D. M. Richerby. An effective dichotomy for the counting constraint satisfaction problem. SIAM Journal on Computing, to appear.\n[25] T. Feder. Fanout limitations on constraint systems. Theoretical Computer Science, 255(1\u2013\n2):281\u2013293, 2001.\n[26] T. Feder and M. Y. Vardi. The computational structure of monotone monadic SNP and\nconstraint satisfaction: A study through Datalog and group theory. SIAM Journal on\nComputing, 28(1):57\u2013104, 1998.\n[27] E. C. Freuder. Complexity of k-tree structured constraint satisfaction problems. In 8th Conference of the American Association for Artificial Intelligence, pages 4\u20139. AAAI Press/MIT\nPress, 1990.\n[28] P. Hell and J. Ne\u0161et\u0159il. On the complexity of h-coloring. Journal of Combinatorial Theory,\nSeries B, 48(1):92\u2013110, 1990.\n[29] M. R. Jerrum, L. G. Valiant, and V. V. Vazirani. Random generation of combinatorial\nstructures from a uniform distribution. Theoretical Computer Science, 43:169\u2013188, 1986.\n[30] D. E. Knuth. The Art of Computer Programming, Vol. 4A: Combinatorial Algorithms. In\npreparation.\n[31] Ph. G. Kolaitis and M. Y. Vardi. Conjunctive query containment and constraint satisfaction.\nJournal of Computer and System Sciences, 61(2):302\u2013332, 2000.\n[32] Ph. G. Kolaitis and M. Y. Vardi. A game-theoretic approach to constraint satisfaction.\nIn 17th Conference of the American Association for Artificial Intelligence, pages 175\u2013181.\nAAAI Press/MIT Press, 2000.\n[33] V. Kumar. Algorithms for constraint satisfaction problems: A survey. AI Magazine,\n13(1):33\u201342, 1992.\n[34] R. E. Ladner. On the structure of polynomial time reducibility. Journal of the ACM,\n22(1):155\u2013171, 1975.\n\n21\n\n\f[35] M. Luby and E. Vigoda. Fast convergence of the Glauber dynamics for sampling independent sets. Random Structures and Algorithms, 15(3\u20134):229\u2013241, 1999.\n[36] U. Montanari. Networks of constraints: Fundamental properties and applications to picture\nprocessing. Information Sciences, 7:95\u2013135, 1974.\n[37] T. J. Schaefer. The complexity of satisfiability problems. In 10th ACM Symposium on\nTheory of Computing, pages 216\u2013226, 1978.\n[38] J. Simon. On the difference between one and many (Preliminary version). In 4th International Colloquium on Automata, Languages and Programming (ICALP 1977), volume 52 of\nLNCS, pages 480\u2013491. Springer, 1977.\n[39] A. Sly. Computational transition at the uniqueness threshold. In 51st IEEE Symposium on\nFoundations of Computer Science (FOCS 2010), pages 287\u2013296. IEEE Computer Society,\n2010.\nL\n[40] S. Toda. On the computational power of PP and\nP. In 30th Annual Symposium on\nFoundations of Computer Science (FOCS 1989), pages 514\u2013519. IEEE Computer Society,\n1989.\n[41] L. G. Valiant. The complexity of computing the permanent. Theoretical Computer Science,\n8:189\u2013201, 1979.\n[42] L. G. Valiant. The complexity of enumeration and reliability problems. SIAM Journal on\nComputing, 8(3):410\u2013421, 1979.\n[43] D. Weitz. Counting independent sets up to the tree threshold. In 38th ACM Symposium\non Theory of Computing, pages 140\u2013149, 2006.\n[44] D. Welsh. Complexity: Knots, Colourings and Counting. Cambridge University Press, 1993.\n\n22\n\n\f"}