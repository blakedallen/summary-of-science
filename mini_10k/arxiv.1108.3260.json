{"id": "http://arxiv.org/abs/1108.3260v1", "guidislink": true, "updated": "2011-08-16T14:59:44Z", "updated_parsed": [2011, 8, 16, 14, 59, 44, 1, 228, 0], "published": "2011-08-16T14:59:44Z", "published_parsed": [2011, 8, 16, 14, 59, 44, 1, 228, 0], "title": "Finding Similar/Diverse Solutions in Answer Set Programming", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1108.4880%2C1108.3699%2C1108.1214%2C1108.5109%2C1108.1640%2C1108.6323%2C1108.3383%2C1108.4457%2C1108.1588%2C1108.3038%2C1108.4805%2C1108.6052%2C1108.1943%2C1108.0031%2C1108.3705%2C1108.0353%2C1108.4645%2C1108.1251%2C1108.6309%2C1108.6199%2C1108.4965%2C1108.1705%2C1108.4501%2C1108.0214%2C1108.3312%2C1108.5784%2C1108.0749%2C1108.1854%2C1108.3959%2C1108.3320%2C1108.0085%2C1108.3857%2C1108.1423%2C1108.3238%2C1108.3042%2C1108.3260%2C1108.0552%2C1108.5042%2C1108.2508%2C1108.1207%2C1108.3466%2C1108.2060%2C1108.5793%2C1108.2105%2C1108.4964%2C1108.1807%2C1108.5280%2C1108.4731%2C1108.3689%2C1108.4549%2C1108.1699%2C1108.4611%2C1108.4932%2C1108.0507%2C1108.4589%2C1108.0170%2C1108.4246%2C1108.2751%2C1108.6132%2C1108.2387%2C1108.2403%2C1108.4539%2C1108.6114%2C1108.6121%2C1108.4454%2C1108.6065%2C1108.4366%2C1108.1800%2C1108.3254%2C1108.5971%2C1108.2915%2C1108.0114%2C1108.5382%2C1108.1201%2C1108.2599%2C1108.6096%2C1108.5564%2C1108.1887%2C1108.1182%2C1108.5040%2C1108.6168%2C1108.1742%2C1108.3201%2C1108.0725%2C1108.2385%2C1108.1026%2C1108.1986%2C1108.0339%2C1108.6108%2C1108.5570%2C1108.4305%2C1108.4185%2C1108.5721%2C1108.4076%2C1108.3686%2C1108.0857%2C1108.6243%2C1108.2203%2C1108.5893%2C1108.1482%2C1108.0988&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Finding Similar/Diverse Solutions in Answer Set Programming"}, "summary": "For some computational problems (e.g., product configuration, planning,\ndiagnosis, query answering, phylogeny reconstruction) computing a set of\nsimilar/diverse solutions may be desirable for better decision-making. With\nthis motivation, we studied several decision/optimization versions of this\nproblem in the context of Answer Set Programming (ASP), analyzed their\ncomputational complexity, and introduced offline/online methods to compute\nsimilar/diverse solutions of such computational problems with respect to a\ngiven distance function. All these methods rely on the idea of computing\nsolutions to a problem by means of finding the answer sets for an ASP program\nthat describes the problem. The offline methods compute all solutions in\nadvance using the ASP formulation of the problem with an ASP solver, like\nClasp, and then identify similar/diverse solutions using clustering methods.\nThe online methods compute similar/diverse solutions following one of the three\napproaches: by reformulating the ASP representation of the problem to compute\nsimilar/diverse solutions at once using an ASP solver; by computing\nsimilar/diverse solutions iteratively (one after other) using an ASP solver; by\nmodifying the search algorithm of an ASP solver to compute similar/diverse\nsolutions incrementally. We modified Clasp to implement the last online method\nand called it Clasp-NK. In the first two online methods, the given distance\nfunction is represented in ASP; in the last one it is implemented in C++. We\nshowed the applicability and the effectiveness of these methods on\nreconstruction of similar/diverse phylogenies for Indo-European languages, and\non several planning problems in Blocks World. We observed that in terms of\ncomputational efficiency the last online method outperforms the others; also it\nallows us to compute similar/diverse solutions when the distance function\ncannot be represented in ASP.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1108.4880%2C1108.3699%2C1108.1214%2C1108.5109%2C1108.1640%2C1108.6323%2C1108.3383%2C1108.4457%2C1108.1588%2C1108.3038%2C1108.4805%2C1108.6052%2C1108.1943%2C1108.0031%2C1108.3705%2C1108.0353%2C1108.4645%2C1108.1251%2C1108.6309%2C1108.6199%2C1108.4965%2C1108.1705%2C1108.4501%2C1108.0214%2C1108.3312%2C1108.5784%2C1108.0749%2C1108.1854%2C1108.3959%2C1108.3320%2C1108.0085%2C1108.3857%2C1108.1423%2C1108.3238%2C1108.3042%2C1108.3260%2C1108.0552%2C1108.5042%2C1108.2508%2C1108.1207%2C1108.3466%2C1108.2060%2C1108.5793%2C1108.2105%2C1108.4964%2C1108.1807%2C1108.5280%2C1108.4731%2C1108.3689%2C1108.4549%2C1108.1699%2C1108.4611%2C1108.4932%2C1108.0507%2C1108.4589%2C1108.0170%2C1108.4246%2C1108.2751%2C1108.6132%2C1108.2387%2C1108.2403%2C1108.4539%2C1108.6114%2C1108.6121%2C1108.4454%2C1108.6065%2C1108.4366%2C1108.1800%2C1108.3254%2C1108.5971%2C1108.2915%2C1108.0114%2C1108.5382%2C1108.1201%2C1108.2599%2C1108.6096%2C1108.5564%2C1108.1887%2C1108.1182%2C1108.5040%2C1108.6168%2C1108.1742%2C1108.3201%2C1108.0725%2C1108.2385%2C1108.1026%2C1108.1986%2C1108.0339%2C1108.6108%2C1108.5570%2C1108.4305%2C1108.4185%2C1108.5721%2C1108.4076%2C1108.3686%2C1108.0857%2C1108.6243%2C1108.2203%2C1108.5893%2C1108.1482%2C1108.0988&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "For some computational problems (e.g., product configuration, planning,\ndiagnosis, query answering, phylogeny reconstruction) computing a set of\nsimilar/diverse solutions may be desirable for better decision-making. With\nthis motivation, we studied several decision/optimization versions of this\nproblem in the context of Answer Set Programming (ASP), analyzed their\ncomputational complexity, and introduced offline/online methods to compute\nsimilar/diverse solutions of such computational problems with respect to a\ngiven distance function. All these methods rely on the idea of computing\nsolutions to a problem by means of finding the answer sets for an ASP program\nthat describes the problem. The offline methods compute all solutions in\nadvance using the ASP formulation of the problem with an ASP solver, like\nClasp, and then identify similar/diverse solutions using clustering methods.\nThe online methods compute similar/diverse solutions following one of the three\napproaches: by reformulating the ASP representation of the problem to compute\nsimilar/diverse solutions at once using an ASP solver; by computing\nsimilar/diverse solutions iteratively (one after other) using an ASP solver; by\nmodifying the search algorithm of an ASP solver to compute similar/diverse\nsolutions incrementally. We modified Clasp to implement the last online method\nand called it Clasp-NK. In the first two online methods, the given distance\nfunction is represented in ASP; in the last one it is implemented in C++. We\nshowed the applicability and the effectiveness of these methods on\nreconstruction of similar/diverse phylogenies for Indo-European languages, and\non several planning problems in Blocks World. We observed that in terms of\ncomputational efficiency the last online method outperforms the others; also it\nallows us to compute similar/diverse solutions when the distance function\ncannot be represented in ASP."}, "authors": ["Thomas Eiter", "Esra Erdem", "Halit Erdogan", "Michael Fink"], "author_detail": {"name": "Michael Fink"}, "author": "Michael Fink", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1017/S1471068411000548", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1108.3260v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1108.3260v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "57 pages, 17 figures, 4 tables. To appear in Theory and Practice of\n  Logic Programming (TPLP)", "arxiv_primary_category": {"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.AI", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1108.3260v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1108.3260v1", "journal_reference": "Theory and Practice of Logic Programming, 13(3), 303-359, 2013", "doi": "10.1017/S1471068411000548", "fulltext": "Under consideration for publication in Theory and Practice of Logic Programming\n\n1\n\narXiv:1108.3260v1 [cs.AI] 16 Aug 2011\n\nFinding Similar/Diverse Solutions\nin Answer Set Programming\u2217\nTHOMAS EITER\nInstitute of Information Systems, Vienna University of Technology, Vienna, Austria\nE-mail: eiter@kr.tuwien.ac.at\n\nESRA ERDEM and HALIT ERDOGAN\nFaculty of Engineering and Natural Sciences, Sabanci University, Istanbul, Turkey\nE-mail: {esraerdem,halit}@sabanciuniv.edu\n\nMICHAEL FINK\nInstitute of Information Systems, Vienna University of Technology, Vienna, Austria\nE-mail: fink@kr.tuwien.ac.at\nsubmitted 11 January 2011; revised 27 July 2011; accepted 11 August 2011\n\nAbstract\nFor some computational problems (e.g., product configuration, planning, diagnosis, query answering,\nphylogeny reconstruction) computing a set of similar/diverse solutions may be desirable for better\ndecision-making. With this motivation, we have studied several decision/optimization versions of this\nproblem in the context of Answer Set Programming (ASP), analyzed their computational complexity, and introduced offline/online methods to compute similar/diverse solutions of such computational\nproblems with respect to a given distance function. All these methods rely on the idea of computing solutions to a problem by means of finding the answer sets for an ASP program that describes\nthe problem. The offline methods compute all solutions of a problem in advance using the ASP formulation of the problem with an existing ASP solver, like CLASP, and then identify similar/diverse\nsolutions using some clustering methods (possibly in ASP as well). The online methods compute\nsimilar/diverse solutions of a problem following one of the three approaches: by reformulating the\nASP representation of the problem to compute similar/diverse solutions at once using an existing\nASP solver; by computing similar/diverse solutions iteratively (one after other) using an existing\nASP solver; by modifying the search algorithm of an ASP solver to compute similar/diverse solutions incrementally. All these methods are sound; the offline method and the first online method are\ncomplete whereas the others are not. We have modified CLASP to implement the last online method\nand called it CLASP - NK. In the first two online methods, the given distance function is represented\nin ASP; in the last one however it is implemented in C++. We have showed the applicability and the\neffectiveness of these methods using CLASP or CLASP - NK on two sorts of problems with different\ndistance measures: on a real-world problem in phylogenetics (i.e., reconstruction of similar/diverse\nphylogenies for Indo-European languages), and on several planning problems in a well-known domain (i.e., Blocks World). We have observed that in terms of computational efficiency (both time and\nspace) the last online method outperforms the others; also it allows us to compute similar/diverse\n\u2217 Part of the results in this paper are contained, in preliminary form, in Proceedings of the 25'th International\nConference on Logic Programming (ICLP 2009). This work was partially supported by FWF (Austrian Science\nFunds) project P20841, the Wolfgang Pauli Institute, and TUBITAK Grants 107E229 and 108E229.\n\n\f2\n\nEiter et. al.\n\nsolutions when the distance function cannot be represented in ASP (e.g., due to some mathematical\nfunctions not supported by the ASP solvers) but can be easily implemented in C++.\nKEYWORDS: similar/diverse solutions, answer set programming, similar/diverse phylogenies, similar/diverse plans\n\n1 Introduction\nFor many computational problems, the main concern is to find a best solution (e.g., a most\npreferred product configuration, a shortest plan, a most parsimonious phylogeny) with respect to some well-described criterion. On the other hand, in many real-world applications,\ncomputing a subset of good solutions that are similar/diverse may be desirable for better\ndecision-making. For one reason, the given computational problem may have too many\ngood solutions, and the user may want to examine only a few of them to pick one. Also,\nin many real-world applications the users usually take into account furthermore criterion\nthat are not included in the formulation of the optimization problem; in such cases, good\nsolutions similar to a best one may also be useful. Here are some examples from several\ndomains illustrating the usefulness of finding similar/diverse solutions.\nProduct configuration Consider, for instance, a variation of the example given in (Hebrard et al. 2005) about buying a car. Suppose that there is a product advisor that asks\ncustomers about their constraints/preferences about a car, and then lists the available ones\nthat match their constraints/preferences. However, such a list may be too long. In that case,\nthe customer might ask for a few cars that not only suit her constraints/preferences but also\nare as diverse as possible. Then, if she likes one particular car among them, she might ask\nfor other cars that are as similar as possible to this particular car. Also, the customer may\nhave other (possibly secondary) criterion that the product advisor has not asked about; and\nthus the best alternatives listed by the product advisor may not cover some of the good\npossibilities. Then, the user may ask for a couple of good enough configurations that are\ndistant from a set of best configurations.\nPlanning Given an initial state, goal conditions, and a description of actions, planning is\nthe problem of finding a sequence of actions (i.e., a plan) that would lead the initial state\nto a goal state. Planning is applied in various domains, such as robotics, web service composition, and genome rearrangement. In planning, it may be desirable to compute a set of\nplans that are similar to each other, so that, when the plan that is being executed fails, one\ncan switch to a most similar one. For instance, consider a variation of the example given\nin (Srivastava et al. 2007) in connection with modeling web service composition as a planning problem (McIlraith and Son 2002): suppose that the web service engine computes\na plan/composition; then it can compute a set of compositions similar to this particular\none, so that if a failure occurs while executing one composition, an alternative composition\nwhich is less likely to be failing simultaneously can be used (Chafle et al. 2006). Alternatively, let us consider planning in the context of robotics in a dynamic environment with\nuncertainties. If the plan failure is, for instance, due to some collisions with an obstacle as\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n3\n\nin the scenarios presented in (Caldiran et al. 2009), the agent may want to find a plan that\nis distant from the previously computed plan so that it does not collide with the obstacle\nagain.\nPhylogeny reconstruction Phylogeny reconstruction is the problem of inferring a leaflabeled rooted directed tree (i.e., phylogeny) that would characterize the evolutionary relations between a family of species based on their shared traits. Phylogeny reconstruction is important for research areas as disparate as genetics, historical linguistics, zoology,\nanthropology, archaeology, etc.. For example, a phylogeny of parasites may help zoologists to understand the evolution of human diseases (Brooks and McLennan 1991); a\nphylogeny of languages may help scientists to better understand human migrations (White\nand O'Connell 1982). For a given set of taxonomic units, some existing phylogenetic systems, like that of (Brooks et al. 2005; Brooks et al. 2007), generate more than one good\nphylogeny that explains the evolutionary relationships between the given taxonomic units.\nHowever, usually there are too many phylogenies computed by a system, an expert needs\nto compare these phylogenies in detail, by analyzing the similar/diverse ones with respect\nto some distance measure, to pick the most plausible ones.\nMotivated by such examples, we have studied various problems related to computing\nsimilar/diverse solutions in the context of a new declarative programming paradigm, called\nAnswer Set Programming (ASP) (Lifschitz 2008). We have also introduced general offline/online methods in ASP that can be applied to various domains for such computations.\nIn ASP, a combinatorial search problem is represented as an ASP program whose models\n(called \"answer sets\") correspond to the solutions. The answer sets for the given formalism can be computed by special systems called answer set solvers, such as CLASP (Gebser\net al. 2007a). Due to the expressive formalism of ASP that allows us to represent, e.g., negation, defaults, aggregates, recursive definitions, and due to the continuous improvements\nof efficiency of solvers, ASP has been used in a wide-range of knowledge-intensive applications from different fields, such as product configuration (Soininen and Niemel\u00e4 1998),\nplanning (Lifschitz 1999), phylogeny reconstruction (Brooks et al. 2007), developing a decision support system for a space shuttle (Nogueira et al. 2001), multi-agent planning (Son\net al. 2009), answering biomedical queries (Bodenreider et al. 2008). For many of these\napplications, finding similar/diverse solutions (and thus the methods we have developed\nfor computing similar/diverse solutions in ASP) could be useful.\nThe main contributions of this paper can be summarized as follows.\n\u2022 We have described mainly two kinds of computational problems related to finding\nsimilar/diverse solutions of a given problem, in the context of ASP (Section 3). Both\nkinds of problems take as input an ASP program P that describes a problem, a\ndistance measure \u2206 that maps a set of solutions of the problem to a nonnegative\ninteger, and two nonnegative integers n and k . One problem asks for a set S of size n\nthat contains k -similar (resp. k -diverse) solutions, i.e., \u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k );\nthe other problem asks, given a set S of n solutions, for a k -close (resp. k -distant)\nsolution s (resp. s 6\u2208 S ), i.e., \u2206(S \u222a {s}) \u2264 k (resp. \u2206(S \u222a {s}) \u2265 k ). Note that, by\nfixing some parameters and minimizing/maximizing others, we can turn them into\nvarious related optimization problems.\n\n\f4\n\nEiter et. al.\n\u2022 We have studied the computational complexity of these decision/optimization problems establishing completeness results under reasonable assumptions for the problem parameters (Section 4).\n\u2022 We have introduced an offline method to compute a set of n k -similar (resp. k diverse) solutions to a given problem, by computing all solutions in advance using\nASP and then finding similar (resp. diverse) solutions using some clustering methods, possibly in ASP as well (Section 5.1.1). This method is sound and complete,\nassuming that the ASP formulations are correct.\n\u2022 We have introduced three online methods to compute a set of n k -similar (resp.\nk -diverse) solutions to a given problem (Sections 5.1.2, 5.1.3 and 5.1.4).\n- Online Method 1 reformulates the given program to compute n-distinct solutions and formulates the distance function as an ASP program, so that all n\nk -similar (resp. k -diverse) solutions can be extracted from an answer set for\nthe union of these ASP programs.\n- Online Method 2 does not modify the ASP program encoding the problem, but\nformulates the distance function as an ASP program, so that a unique k -close\n(resp. k -distant) solution can be extracted from an answer set for the union\nof these ASP programs and a previously computed solution; by iteratively\ncomputing k -close (resp. k -distant) solutions one after other, we can compute\nonline a set of n k -similar (or k -diverse) solutions.\n- Online Method 3 does not modify the ASP encoding of the problem, and does\nnot formulate the distance function as an ASP program, but it modifies the\nsearch algorithm of an ASP solver, in our case C LASP (Gebser et al. 2007b), to\ncompute all n k -similar (or k -diverse) solutions at once. The distance function\nis implemented in C++; in that sense, Online Method 3 allows for finding\nsimilar/diverse solutions when the distance function cannot be defined in ASP.\nAll the methods are sound, assuming that the ASP formulations are correct. Online\nMethod 1 is complete; however, Online Methods 2 and 3 are not because the computation of the similar/diverse solutions depend on the first solution computed by\nC LASP.\n\u2022 We have illustrated the applicability of these approaches on two sorts of problems:\nphylogeny reconstruction (based on the ASP encoding of the problem as in (Brooks\net al. 2007)) and planning (based on the ASP encoding of the Blocks World as in\n(Erdem 2002)).\n- For phylogeny reconstruction, we have defined novel distance measures for a\nset of phylogenies (Section 6.1), described how the offline method and the online methods are applied to find similar/diverse phylogenies (Section 6.2), and\ncompared the efficiency and effectiveness of these methods on the family of\nIndo-European languages studied in (Brooks et al. 2007) (Section 6.3). Since\nthere is no phylogenetic system that helps experts to analyze phylogenies by\ncomparing them, this particular application of our methods also plays a significant role in phylogenetics. In fact, Offline Method and Online Method 3 are\nintegrated in the phylogenetics system P HYLO -ASP (Erdem 2009).\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n5\n\n- For planning, we have considered the action-based Hamming distance of (Srivastava et al. 2007) to measure the distance among plans, and compared the\nefficiency and effectiveness of the offline method and the online methods on\nsome Blocks World problems (Section 7).\nFinding similar/diverse solutions has earlier been studied in the context of propositional\nlogic (Bailleux and Marquis 1999), constraint programming (Hebrard et al. 2005; Hebrard\net al. 2007), and automated planning (Srivastava et al. 2007). These studies consider the\nHamming distance (Hamming 1950) as a measure to compute distances between solutions.\nUnlike the problems studied in related work, the problems we have studied are not confined\nto polynomial-time distance functions with polynomial range. A more detailed discussion\non related work is presented in Section 8.\n\n2 Answer Set Programming\nWe study finding similar/diverse solutions in the context of Answer Set Programming\n(ASP) (Lifschitz 2008)-a new declarative programming paradigm where the idea is to\nrepresent a combinatorial search problem as a \"program\" whose models (called \"answer\nsets\" (Gelfond and Lifschitz 1991)) correspond to the solutions. This is in the vein of SAT\nsolving, which became popular after a surprising success in the area of planning (Kautz\nand Selman 1992), but offers in comparison features like variables ranging over domain\nelements, easy definition of transitive closure, and nonmonotonic negation. Furthermore, a\nrange of special constructs, such as aggregates, weight constraints and priorities, that are\nuseful in practical applications are supported by various ASP solvers; for more discussion,\nsee Section 8.\nBefore we proceed discussing our methods for finding similar/diverse solutions in ASP,\nlet us present the syntax of the kind of programs considered in this paper, and define the\nconcept of an answer set for such programs.1\nPrograms The syntax of formulas, rules and programs is defined as follows. Formulas are\nformed from propositional atoms and 0-place connectives > and \u22a5 using negation (written\nas not ), conjunction (written as a comma) and disjunction (written as a semicolon).\nA rule is an expression of the form\nF \u2190G\n\n(1)\n\nwhere F is an atom or \u22a5, and G is a formula; F is called the head and G is called the body\nof the rule. A rule of the form F \u2190 > will be identified with the formula F . A rule of the\nform \u22a5 \u2190 F (called a constraint) will be abbreviated as \u2190 F .\nA (normal nested) program is a finite set of rules. If bodies of all rules in a program are\nof the form\nA1 , . . . , Am , not Am+1 , . . . , not An\n1\n\nAnswer sets are defined for programs of a more general form that may contain classical negation \u00ac and disjunction (Gelfond and Lifschitz 1991) and nested expressions (Lifschitz et al. 1999) in heads of rules as well.\nSee (Lifschitz 2010) for definitions of answer sets.\n\n\f6\n\nEiter et. al.\n\nthen the program is a normal program. A program is positive if it does not contain any\nnegation.\nAnswer Sets To define the concept of an answer set for a program, let us first define the\nsatisfaction relation and the reduct of a program.\nThe satisfaction relation X |= F between a set X of atoms and a formula F is defined\nrecursively, as follows:\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\u2022\n\nfor an atom A, X |= A if A \u2208 X\nX |= >\nX 6|= \u22a5\nX |= (F , G) if X |= F and X |= G\nX |= (F ; G) if X |= F or X |= G\nX |= not F if X 6|= F .\n\nWe say that X satisfies a program \u03a0 (symbolically, X |= \u03a0) if, for every rule F \u2190 G\nin \u03a0, X |= F whenever X |= G.\nThe reduct F X of a formula F with respect to a set X of atoms is defined recursively,\nas follows:\n\u2022 if F is an atom or a 0-place connective then F X = F\n\u2022 (F , G)X = F X , G X\n\u2022 (F ; G)X = F\u001aX ; G X\n\u22a5 , if X |= F ,\n\u2022 (not F )X =\n> , otherwise.\nThe reduct \u03a0X of a program \u03a0 with respect to X is the set of rules\nF X \u2190 GX\nfor all rules F \u2190 G in \u03a0.\nLet us first define the answer set for a program \u03a0 that does not contain negation. We\nsay that X is an answer set for \u03a0, if X is minimal with respect to set inclusion (\u2286) among\nthe sets of atoms that satisfy \u03a0. For instance, the set {p} is the answer set for the program\nconsisting of the single rule\np\u2190*\n\n(2)\n\nNow consider a program \u03a0 that may contain negation. A set X of atoms is an answer\nset for \u03a0 if it is the answer set for the reduct \u03a0X . For instance, the reduct of the program\np \u2190 not not p\n\n(3)\n\nrelative to {p} is (2). Since {p} is the answer set for (2), {p} is an answer set for program\n(3). Similarly, {} is an answer set for program (3) as well.\nRepresenting a Problem in ASP The idea of ASP is to represent a computational problem\nas a program whose answer sets correspond to the solutions of the problem, and to find the\nanswer sets for that program using an answer set solver.\nWhen we represent a problem in ASP, two kinds of rules play an important role: those\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n7\n\nthat \"generate\" many answer sets corresponding to \"possible solutions\", and those that can\nbe used to \"eliminate\" the answer sets that do not correspond to solutions. Rules (3) are\nof the former kind: they generate the answer sets {p} and {}. Constraints are of the latter\nkind. For instance, adding the constraint\n\u2190p\nto program (3) eliminates the answer sets for the program that contain p.\nIn ASP, we use special constructs of the form\n{A1 , . . . , An }c\n\n(4)\n\n(called choice expressions), and of the form\nl \u2264 {A1 , . . . , Am } \u2264 u\n\n(5)\n\n(called cardinality expressions) where each Ai is an atom and l and u are nonnegative\nintegers denoting the \"lower bound\" and the \"upper bound\" (Simons et al. 2002). Programs\nusing these constructs can be viewed as abbreviations for normal nested programs defined\nabove, due to (Ferraris and Lifschitz 2005). For instance, the following program\n{p}c \u2190\nstands for program (3). The constraint\n\u2190 2 \u2264 {p, q, r }\nstands for the constraints\n\u2190 p, q\n\u2190 p, r\n\u2190 q, r *\nExpression (4) describes subsets of {A1 , . . . , An }. Such expressions can be used in\nheads of rules to generate many answer sets. For instance, the answer sets for the program\n{p, q, r }c \u2190\n\n(6)\n\nare arbitrary subsets of {p, q, r }. Expression (5) describes the subsets of the set {A1 , . . . , Am }\nwhose cardinalities are at least l and at most u. Such expressions can be used in constraints\nto eliminate some answer sets. For instance, adding the constraint\n\u2190 2 \u2264 {p, q, r }\nto program (6) eliminates the answer sets for (6) whose cardinalities are at least 2. Adding\nthe constraint\n\u2190 not (1 \u2264 {p, q, r })\nto program (6) eliminates the answer sets for (6) whose cardinalities are not at least 1.\nWe abbreviate the rules\n{A1 , . . . , Am }c \u2190 Body\n\u2190 not (l \u2264 {A1 , . . . , Am })\n\u2190 not ({A1 , . . . , Am } \u2264 u)\n\n(7)\n\n\f8\n\nEiter et. al.\n\nby\nl \u2264 {A1 , . . . , Am }c \u2264 u \u2190 Body*\nFor instance, rules (6), (7) and \u2190 not ({p, q, r } \u2264 1) can be written as\n1 \u2264 {p, q, r }c \u2264 1 \u2190\nwhose answer sets are the singleton subsets of {p, q, r }.\nFinding a Solution using an Answer Set Solver Once we represent a computational problem as a program whose answer sets correspond to solutions of the problem, we can use\nan answer set solver to compute the solutions of the problem. To present a program to an\nanswer set solver, like CLASP, we need to make some syntactic modifications.\nThe syntax of the input language of CLASP is more limited in some ways than the class\nof programs defined above, but it includes many useful special cases. For instance, the head\nof a rule can be an expression of one of the forms\n{A1 , . . . , An }c\nl \u2264 {A1 , . . . , An }c\n{A1 , . . . , An }c \u2264 u\nl \u2264 {A1 , . . . , An }c \u2264 u\nbut the superscript c and the sign \u2264 are dropped. The body can contain cardinality expressions but the sign \u2264 is dropped.\nIn the input language of CLASP, :- stands for \u2190, and each rule is followed by a period.\nA group of rules that follow a pattern can be often described in a compact way using\n\"(schematic) variables\". Variables must be capitalized. For instance, the program \u03a0n\npi \u2190 not pi+1\n\n(1 \u2264 i \u2264 n)\n\ncan be presented to CLASP as follows:\nindex(1..n).\np(I) :- not p(I+1), index(I).\nHere index is a \"domain predicate\" used to describe the range of variable I.\nVariables can be also used \"locally\" to describe the list of formulas in a cardinality\nexpression. For instance, the rule\n1 \u2264 {p1 , . . . , pn } \u2264 1\ncan be expressed in CLASP as follows\nindex(1..n).\n1{p(I) : index(I)}1.\nfinds an answer set for a program in two stages: first it gets rid of the schematic\nvariables using a \"grounder\", like GRINGO, and then it finds an answer set for the ground\nprogram using a DPLL-like branch and bound algorithm (outlined in Algorithm 2).\nCLASP\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n9\n\n3 Computational Problems\nWe study various problems related to finding similar/diverse solutions to a computational\nproblem P formulated in ASP. For that, we assume that the problem is represented as\na normal (possibly nested) program P whose answer sets characterize solutions of the\nproblem. More precisely, let Sol(P ) denote the set of solutions of P and let AS(P) denote\nthe set of answer sets of P. Then, there is a many-to-one mapping of AS(P) onto Sol(P ).\nMoreover, given an answer set of P the corresponding solution from Sol(P ) can efficiently\nbe extracted. We also assume that a distance function that maps a set S of solutions to a\nnumber is defined, to measure how similar/diverse the solutions are in S . To this end, we\nconsider set-distance measures \u2206 : 2Sol(P) 7\u2192 N0 on solutions for P .\nWe are mainly interested in two sorts of problems related to computation of a diverse/similar\ncollection of solutions:\nn k - SIMILAR SOLUTIONS (resp. n k - DIVERSE SOLUTIONS)\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, and two\nnonnegative integers n and k , decide whether a set S of n solutions for P exists\nsuch that \u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k ).\nk - CLOSE SOLUTION (resp. k - DISTANT SOLUTION)\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, a set S of\nsolutions for P , and a nonnegative integer k , decide whether some solution s (s 6\u2208 S )\nfor P exists such that \u2206(S \u222a {s}) \u2264 k (resp. \u2206(S \u222a {s}) \u2265 k ).\nFor instance, suppose that the ASP program P describes the phylogeny reconstruction\nproblem for Indo-European languages as in (Brooks et al. 2005); so each answer set of\nP represents a phylogeny for Indo-European languages. Using this ASP program with an\nexisting ASP solver, one can compute many phylogenies for the same input dataset and\nwith the same input parameters. Instead of analyzing all of these phylogenies manually, a\nhistorical linguist may ask for, for instance, three phylogenies whose diversity is at least\n20 with respect to some domain-independent or domain-dependent distance function \u2206;\nthis problem is an instance of n k -diverse solutions problem where n = 3 and k = 20. On\nthe other hand, a historical linguist may have found two phylogenies P1 and P2 that are\nplausible, for instance, based on some archeological evidence, and she may want to infer a\nsimilar phylogeny whose distance from {P1 , P2 } is at most 10; this problem is an instance\nof k -close solution problem where k = 10.\nThe first kind of problems above has two parameters, n and k , so we can fix one and try\nto minimize (resp. maximize) the distance between solutions to find the most similar (resp.\ndiverse) solutions.\nn MOST SIMILAR SOLUTIONS (resp. n MOST DIVERSE SOLUTIONS)\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, and a nonnegative integer n, find a set S of n solutions for P with the minimum (resp. maximum)\ndistance \u2206(S ).\nMAXIMAL n k - SIMILAR SOLUTIONS (resp. MAXIMAL n k - DIVERSE SOLUTIONS)\n\n\f10\n\nEiter et. al.\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, and a nonnegative integer k , find a \u2286-maximal set S of at most n solutions for P such that\n\u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k ) exists.\n\nIn the second class of problems, we can try to minimize (resp. maximize) the distance k\nbetween a solution and a set of solutions, to find the closest (resp. most distant) solution.\nCLOSEST SOLUTION (resp. MOST DISTANT SOLUTION )\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, and a set S of\nsolutions for P , find a solution s (s 6\u2208 S ) for P with the minimum (resp. maximum)\ndistance \u2206(S \u222a {s}).\n\nWe can generalize k - CLOSE SOLUTION (resp. k - DISTANT SOLUTION) problems to sets\nof solutions:\nk - CLOSE SET (resp. k - DISTANT SET)\nGiven an ASP program P that formulates a computational problem P , a distance\nmeasure \u2206 that maps a set of solutions for P to a nonnegative integer, a set S of\nsolutions for P , and a nonnegative integer k , decide whether a set S 0 of solutions\nfor P (S 0 6= S ) exists such that |\u2206(S ) \u2212 \u2206(S 0 )| \u2264 k (resp. |\u2206(S ) \u2212 \u2206(S 0 )| \u2265 k ).\nUsually an expert is interested in several kinds of problems to be able to systematically\nanalyze solutions. For instance, a historical linguist may want to find three most diverse\nphylogenies; and after identifying one particular plausible phylogeny among them, she\nmay want to compute another phylogeny that is the closest. An example of such an analysis\nis shown in Section 6.3 for understanding the classification of Indo-European languages.\nWe note that the problems on similar/diverse solutions from above can be analogously\ndefined for computation problems with multiple (or possibly none) solutions in general,\nand in particular for such problems with NP complexity. Since ASP can express all NP\nsearch problems (Marek and Remmel 2003), in fact similar/diverse solution computation\nfor each such problem can be formulated in the framework above (in fact with polynomial\noverhead).\n4 Complexity Results\nBefore we discuss how the computational problems described in the previous section can\nbe solved in ASP, let us turn our attention to the computational complexity of the problems\npresented in Section 3. In order to do so, we first make some reasonable assumptions on\nsome of the problem parameters.\nIn the following we assume that given an answer set s of P, extracting a solution of P\nfrom s can be accomplished in time polynomial wrt. the size of s. Moreover, w.l.o.g. we\nidentify s with the solution it encodes, and sets S \u2286 Sol(P ) with corresponding sets of\nanswer sets from AS(P).\nWe assume that all numbers are given in binary and that the given number n of different\nsolutions to consider (respectively the size of the set S ) for instances of the problems n\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n11\n\nTable 1. Complexity results for computing similar solutions.\n#\n\nProblem\n\nComplexity\n\n1\n2\n3\n4\n5\n6\n\nn k - SIMILAR SOLUTIONS\nk - CLOSE SOLUTION\nMAXIMAL n k - SIMILAR SOLUTIONS\nn MOST SIMILAR SOLUTIONS\n\nNP\nNP\nFNP//log\nFPNP (FNP//log)\nFPNP (FNP//log)\nNP\n\nCLOSEST SOLUTION\n\nk - CLOSE SET\n\nk - SIMILAR SOLUTIONS, MAXIMAL n k - SIMILAR SOLUTIONS, and n MOST SIMILAR\nSOLUTIONS is polynomial in the size of the input. The same assumption applies to the size\nof the sets S 0 to consider in instances of k - CLOSE SET problems.\nFurthermore, we consider distance measures \u2206 such that deciding whether \u2206(S ) \u2264 k\n(resp. whether \u2206(S ) \u2265 k ) for a given k is in NP. Moreover, we assume that the value of\n\u2206(S ) is bounded by an exponential in the size of S (and thus has polynomially many bits\nin the size of S ). Thus, when considering \u2206 as an input to a problem, we assume that it\nis given as the description of a non-deterministic Turing machine M\u2206\u2264 , or M\u2206\u2265 , or both,\nwhere M\u2206\u2264 (resp. M\u2206\u2265 ) nondeterministically decides \u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k ) in time\npolynomial in the length of its input S and k . Consequently, a witness for a computation of\nM\u2206\u03c7 on some input S and k , where \u03c7 \u2208 {\u2264, \u2265} is a sequence of configurations of M\u2206\u03c7 , such\nthat the input tape contains S and k in the initial configuration, successive configurations\ncorrespond to transitions of M\u2206\u03c7 , and the final configuration accepts. In addition, we say\nthat a \u2206 is normal if |S | \u2264 1 implies \u2206(S ) = 0.\nUnder these assumptions, the computational complexity (cf. (Papadimitriou 1994) for a\nbackground on the subject) of the problems concerning the computation of similar/diverse\nsolutions we are interested in, is given in Table 1. All entries are completeness results\n(under usual reductions) and hardness holds even if \u2206(S ) is computable in polynomial\ntime. Moreover, the results are the same for the 'symmetric' problems, i.e., when SIMILAR\nis replaced with DIVERSE, and CLOSE is replaced with DISTANT, respectively. The proofs\nare included in Appendix A.\nTheorem 1\nProblem n k - SIMILAR SOLUTIONS (resp. n k - DIVERSE SOLUTIONS) is NP-complete.\nHardness holds even if \u2206(S ) is computable in constant time and for any normal \u2206.\nMembership for problem n k - SIMILAR SOLUTIONS (resp. n k - DIVERSE SOLUTIONS)\nfollows from the fact that we can guess not only a candidate set S via the program P (since\nS is polynomially bounded) but also a witness for \u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k ), and check\nin polynomial time whether every s \u2208 S is a solution and that \u2206(S ) \u2264 k (resp. \u2206(S ) \u2265 k ).\nFor hardness, one simply reduces answer-set existence for normal, propositional programs\nto this problem, which is an NP-complete problem. For a hardness result resorting to partial\nHamming distance, one can confer (Bailleux and Marquis 1999).\nIn our experiments with phylogeny reconstruction, by Theorem 1, we know that deciding\nthe existence of n k -similar (resp. k -diverse) phylogenies is NP-complete, if the distance\n\n\f12\n\nEiter et. al.\n\nmeasure is the nearest neighbor interchange distance (DasGupta et al. 1997) whose computation is beyond polynomial time, or if the distance measure is the nodal distance or\ncomparison of descendants distance (both defined in Section 6.1) that are computable in\npolynomial time. Also, in planning, if we consider the Hamming distance (Hamming 1950)\n(as defined in Section 7), which is polynomially computable, or the edit distance involving\ntranspositions, which is conjectured to be NP-hard (Bafna and Pevzner 1998), deciding the\nexistence of n k -similar (resp. k -diverse) plans is NP-complete. Therefore, it makes sense\nto find similar/diverse phylogenies/plans using ASP.\nBy similar arguments we obtain NP-completeness for problem k - CLOSE SOLUTION\n(resp. k - DISTANT SOLUTION).\nTheorem 2\nProblem k - CLOSE SOLUTION (resp. k - DISTANT SOLUTION) is NP-complete. Hardness\nholds even if \u2206(S ) is computable in constant time and for any normal \u2206.\nWhen looking for maximal sets of solutions, we face a function problem; here we also\nassume a polynomial upper bound on the size of the sets S to consider (given by input\nn and our corresponding assumption). Recall that function problems generalize decision\nproblems asking for a finite, possibly empty set of solutions of every problem instance.\nThe solutions to function problems can be computed by transducers, i.e., possibly nondeterministic Turing machines equipped with an output tape, which contains a solution if the\ninput is accepted. Note that if the Turing machine is nondeterministic, then it computes\na multi-valued (partial) function. For instance, FNP is the class of multi-valued function\nproblems that can be solved by a nondeterministic transducer in polynomial time, such that\na given solution candidate can be checked in polynomial time.\nIn particular, MAXIMAL n k - SIMILAR SOLUTIONS (resp. n MAXIMAL k - DIVERSE SO LUTIONS ) is solvable in FNP//log. Intuitively, FNP//log is the class of function problems\nsolvable in polynomial time using a nondeterministic Turing machine with output tape that\nmay consult once an oracle that computes the optimal value of an optimization problem\nwhose associated decision problem is solvable in NP, provided that this value has logarithmically many bits in the size of the input (see, e.g., (Chen and Toda 1995; Eiter and\nSubrahmanian 1999) for more information on FNP//log and other function classes used\nin this section).\nTheorem 3\nProblem MAXIMAL n k - SIMILAR SOLUTIONS (resp. MAXIMAL n k - DIVERSE SOLU TIONS ) is FNP//log-complete. Hardness holds even if \u2206(S ) is computable in polynomial\ntime.\nMembership can be shown by computing the maximum cardinality of a set of at most\nn solutions S using the oracle. Obviously, computing the maximum cardinality c of a set\nof at most n solutions S is an optimization problem whose associated decision problem is\nthe following: decide whether a given c (such that c \u2264 n) is the cardinality of a set S of\n(at most n) solutions. Since the latter problem is in NP (guess S and check in polynomial\ntime whether |S | = c, \u2206(S ) \u2264 k , and every s \u2208 S is a solution), the optimization problem\nis amenable to the oracle provided that the computed value (optimal c) has logarithmically\nmany bits in the size of the input. Note that since |S | is polynomially bounded in the size of\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n13\n\nthe input, it has logarithmically many bits as required. Once the optimal value is computed,\none can nondeterministically compute a set S of respective size together with a witness for\n\u2206(S ) \u2264 k , and check in polynomial time that this is indeed the case.\nHardness can be shown by a reduction of X -MinModel (cf. (Chen and Toda 1995)). We\nremark that the slightly different problem asking for a polynomial-size set S of solutions\nsuch that \u2206(S ) is minimal (respectively maximal), again under the assumption that this\nvalue has logarithmically many bits, is also FNP//log-complete. For this variant, hardness\ncan be shown, e.g., for \u2206(S ) that takes the minimal (respectively maximal) Hamming distance between answer sets in S on a subset of the atoms; note that such a partial Hamming\ndistance is a natural measure for problem encodings, where the disagreement on output\natoms is measured.\nTheorem 4\nProblem n MOST SIMILAR SOLUTIONS (resp. n MOST DIVERSE SOLUTIONS) is FPNP complete, and FNP//log-complete if the value of \u2206(S ) is polynomial in the size of S .\nHardness holds even if \u2206(S ) is computable in polynomial time.\nFPNP -membership of n MOST SIMILAR SOLUTIONS (resp. n MOST DIVERSE SOLU TIONS ) is obtained by first using the NP-oracle to compute the minimum distance using\nbinary search (deciding polynomially many n k - SIMILAR SOLUTIONS problems). Then,\nthe oracle is used to compute some suitable S in polynomial time. Hardness follows from\na reduction of the Traveling Salesman Problem (TSP). Notably, if the distances are polynomial in the size of the input, i.e., if the value of \u2206(S ) is polynomially bounded in the\nsize of S , then the problem is FNP//log-complete.\nProceeding similarly as before, completeness for FPNP (resp. FNP//log if \u2206(S ) is\nsmall) is obtained for CLOSEST SOLUTION (and for MOST DISTANT SOLUTION):\nTheorem 5\nProblem CLOSEST SOLUTION (resp. MOST DISTANT SOLUTION) is FPNP -complete, and\nFNP//log-complete if the value of \u2206(S ) is polynomial in the size of S . Hardness holds\neven if \u2206(S ) is computable in polynomial time.\nFor the generalization of k - CLOSE SOLUTION (resp. of k - DISTANT SOLUTION) to sets,\nnamely k - CLOSE SET (resp. k - DISTANT SET), NP-completeness holds by similar arguments as for the former problem(s):\nTheorem 6\nProblem k - CLOSE SET (resp. k - DISTANT SET) is NP-complete. Hardness holds even if\n\u2206(S ) is computable in constant time and for any normal \u2206.\nDiscussion The results above, summarized in Table 1, show that computing similar solutions is intractable in general. This already holds under the reasonable assumption that the\ndistance measure \u2206 is normal, where all considered decision problems are NP-complete.\nThe precise complexity characterization of the search problems (MAXIMAL n k - SIMILAR\nSOLUTIONS , n MOST SIMILAR SOLUTIONS , and CLOSEST SOLUTION ) reveals some information about the type of algorithm we can expect to be suitable for solving these problems in practice (for background, see (Chen and Toda 1995) and references therein). In\n\n\f14\n\nEiter et. al.\n\nparticular, we may not expect that they can be solved by parallelization to NP-problems\nin polynomial time, i.e., solve in parallel polynomially many NP-problems, e.g., SAT instances, and then combine the results. On the other hand, for problem MAXIMAL n k SIMILAR SOLUTIONS this is possible under randomization, i.e., with high probability of\na correct outcome, due to the characteristics of FNP//log, while this is not the case for\nthe problems n MOST SIMILAR SOLUTIONS and CLOSEST SOLUTION in the general case.\nRather, the results suggest that consecutive, dependent calls to NP oracles are needed. Intuitively, backtracking-style algorithms, which explore the search space to find solutions\nand then see to (dis)prove optimality by finding better solutions, appropriately reflect adaptivity.\nHowever, from a worst-case complexity perspective, a simple realization of such a scheme\nmay not be optimal, as far too many solution improvements (exponentially resp. polynomially many under \"small\" distance values) may happen until an optimal solution is found;\nhere a two phase algorithm (first compute the optimal solution cost in binary search and\nthen a solution of that cost, e.g., with backtracking) gives better guarantees. In practice,\none may intertwine bound and solution computation and conduct a binary search over\ncomputations of solutions within a given bound.\nIn the next section, we consider first solving the search problem analog of the decision\nproblem n k SIMILAR SOLUTIONS, using different approaches, ranging from declarative\nencodings in ASP over the explicit respectively implicit set of solutions, to a generalized\nbacktracking algorithm for evaluation ASP programs. We then consider solving the related\nsearch problems n MOST SIMILAR SOLUTIONS and MAXIMAL n k - SIMILAR SOLUTIONS\nbased on the above considerations. Finally, we discuss how we can solve the problems\nk - CLOSE SOLUTION, CLOSEST SOLUTION and k - CLOSE SET utilizing the methods introduced for n k SIMILAR SOLUTIONS and its variants.\n\n5 Computing Similar/Diverse Solutions\nNow we have a better understanding of the computational problems, let us present our computational methods to find n k -similar/diverse solutions, n most similar/diverse solutions\nand maximal n k -similar/diverse solutions for a given computational problem P . Since the\ncomputation of similar solutions and diverse solutions are symmetric, for simplicity, let us\nonly focus on the problems related to similarity. In the following, suppose that the problem\nP is described by an ASP program Solve.lp.\n\n5.1 Computing n k -Similar Solutions\nTo compute a set of n solutions whose distance is at most k , we introduce an offline method\nand three online methods.\n\n5.1.1 Offline Method\nIn the offline method, we compute the set S of all the solutions for P in advance using\nthe ASP program Solve.lp, with an existing ASP solver. Then, we use some clustering\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n15\n\nAlgorithm 1 Offline Method\nInput: A set S of solutions, a distance function d : S \u00d7 S 7\u2192 N, and two nonnegative\nintegers n and k .\nOutput: A set C of n solutions whose distance is at most k .\nV \u2190 Define a set of |S | vertices, each denoting a unique solution in S ;\nE = {{vi , vj } | vi 6= vj , vi , vj denote si , sj \u2208 S , d (si , sj ) \u2264 k };\nC \u2190 Find a clique of size n in hV , E i;\nreturn C\nmethod to find similar solutions in S . The idea is to form clusters of n solutions, measure\nthe distance of each cluster, and pick the cluster whose distance is less than or equal to k .\nWe can compute clusters of n solutions whose distance is at most k by means of a graph\nproblem: build a complete graph G whose nodes correspond to the solutions in S and\nedges are labeled by distances between the corresponding solutions; and decide whether\nthere is a clique C of size n in G whose weight (i.e., the distance of the set of solutions\ndenoted by the weight of the clique) is less than or equal to k . The set of vertices in the\nclique represents n k -similar solutions.\nThe weight of a clique (or the distance \u2206 of the solutions in the cluster) can be computed\nas follows: Given a function d to measure the distance between two solutions, let \u2206(S )\nbe the maximum distance between any two solutions in S . Then n k -similar solutions can\nbe computed by Algorithm 1 where the graph G is built as follows: nodes correspond to\nsolutions in S , and there is an edge between two nodes s1 and s2 in G if d (s1 , s2 ) \u2264 k .\nNodes of a clique of size n in this graph correspond to n k -similar solutions. Such a clique\ncan be computed using the ASP formulation in (Lifschitz 2008), or one of the existing\nexact/approximate algorithms discussed in (Gutin 2003).\n5.1.2 Online Method 1: Reformulation\nInstead of computing all the solutions in advance as in the offline method, we can compute n k -similar solutions to the given problem P on the fly. First we reformulate the\nASP program Solve.lp in such a way to compute n-distinct solutions; let us call the\nreformulation as SolveN.lp. Such a reformulation can be obtained from Solve.lp as\nfollows:\n1. We specify the number of solutions: solution(1..n).\n2. In each rule of the program Solve.lp, we replace each atom p(T1,T2,...,Tm)\n(except the ones specifying the input) with p(N,T1,T2...,Tm), and add to the\nbody solution(N).\n3. Now we have a program that computes n solutions. To ensure that they are distinct,\nwe add a constraint which expresses that every two solutions among these n solutions are different from each other.\nNext we describe the distance function \u2206 as an ASP program, Distance.lp. In addition, we represent the constraints on the distance function (e.g., the distance of the solutions\nin S is at most k ) as an ASP program Constraint.lp. Then we can compute n-distinct\nsolutions for the given problem P that are k -similar, by one call of an existing ASP solver\n\n\f16\n\nEiter et. al.\n\nFig. 1. Computing n k -similar solutions, with Online Method 1.\n\nwith the program SolveN.lp \u222a Distance.lp \u222a Constraint.lp, as shown in\nFig. 1. Let us give an example to illustrate Online Method 1.\nExample 1\nSuppose that we want to compute n k -similar cliques in a graph. Assume that the similarity\nof two cliques is measured by the Hamming Distance: the distance between two cliques C\nand C 0 is equal to the number of different vertices, (C \\ C 0 ) \u222a (C 0 \\ C ). The distance of\na set S of cliques can be defined as the maximum distance among any two cliques in S .\nThe clique problem can be represented in ASP (Solve.lp) as in (Lifschitz 2008), also\nshown in Appendix B (Fig. B 1). The reformulation (SolveN.lp) of this ASP program\nas described above can be seen in Fig. B 2 of Appendix B. This reformulation computes n\ndistinct cliques.\nThe Hamming Distance between any two cliques can be represented by the ASP program\n(Distance.lp) shown in Fig. B 3 of Appendix B.\nFinally, Fig. B 4 shows the constraint (Constraint.lp) that eliminates the sets whose\ndistance is above k .\nAn answer set for the union of these three programs, SolveN.lp \u222a Distance.lp\n\u222a Constraint.lp, corresponds to n k -similar cliques.\n\n5.1.3 Online Method 2: Iterative Computation\nThis method does not modify the given ASP program Solve.lp as in Online Method\n1, but still formulates the distance function and the distance constraints as ASP programs.\nThe idea is to find similar/diverse solutions iteratively, where the i 'th solution is k -close\nto the previously computed i \u2212 1 solutions (Fig. 2). Here n iterations lead to n solutions\nwhose distance is at most k (i.e., n k -similar solutions).\nNote that, like Offline Method and Online Method 1, this method is sound; however,\nunlike Offline Method and Online Method 1, it is not complete since computation of each\nsolution depends on the previously computed solutions. The method may not return n k -\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n17\n\nFig. 2. Computing n k -similar solutions, with Online Method 2. Initially S = \u2205. In each\nrun, a solution is computed and added to S , until |S | = n. The distance function and the\nconstraints in the program ensures that when we add the computed solution to S , the set\nstays k -similar.\nsimilar solutions (even it exists) if the previously computed solutions comprise a bad solution set.\n5.1.4 Online Method 3: Incremental Computation\nThis method is different from the other two online methods in that it does not modify\nthe ASP program Solve.lp describing the given computational problem P , it does not\nformulate the distance function \u2206 and the distance constraints as ASP programs. Instead,\nmodifies the search algorithm of an existing ASP solver in such a way that the modified\nASP solver can compute n k -similar solutions (Fig. 3). In this method, we modify the\nsearch algorithm of the ASP solver CLASP (Version 1.1.3); the modified version is called\nCLASP - NK . The given distance measure \u2206 is implemented as a C++ program.\nLet us describe how we modified CLASP to obtain CLASP - NK. CLASP performs a DPLLlike (Davis et al. 1962; Marques-Silva and Sakallah 1999) branch and bound search to find\nan answer set for a given ASP program (Algorithm 2): at each level, it \"propagates\" some\nliterals to be included in the answer set, \"selects\" new literals to branch on, or \"backtracks\" to an earlier appropriate point in search while \"learning conflicts\" to avoid redundant search.\nWe modify CLASP's algorithm as shown in Algorithm 3 to obtain CLASP - NK: the underlined parts show these modifications. To use CLASP - NK, one needs to prepare an options\nfile, NKoptions, to describe the input parameters to compute n k -similar phylogenies, such\nas the values n and k , along with the names of predicates that characterize solutions and\nthat are considered for computing the distance between solutions. Note that since an answer set (thus a solution) is computed incrementally in CLASP - NK, we cannot compute the\ndistance between a partial solution and a set of solutions with respect to the given distance\nfunction \u2206. Instead, one needs to implement a heuristic function to estimate a lower bound\n\n\f18\n\nEiter et. al.\n\nFig. 3. Computing n k -similar solutions, with Online Method 3. CLASP - NK is a modification of the ASP solver CLASP, that takes into account the distance function and constraints\nwhile computing an answer set in such a way that CLASP - NK becomes biased to compute\nsimilar solutions. Each computed solution is stored by CLASP - NK until a set of n k -similar\nsolutions is computed.\n\nAlgorithm 2 CLASP\nInput: An ASP program \u03a0\nOutput: An answer set A for \u03a0\nA \u2190 \u2205 // current assignment of literals\n5 \u2190 \u2205 // set of conflicts\nwhile No Answer Set Found do\nPROPAGATION (\u03a0, A, 5)\n// propagate literals\nif There is a conflict in the current assignment then\nRESOLVE - CONFLICT (\u03a0, A, 5)\n// learn and update conflicts, and backtrack\nelse\nif Current assignment does not yield an answer set then\nSELECT (\u03a0, A, 5)\n// select a literal to continue search\nelse\nreturn A\nend if\nend if\nend while\n\nfor the distance between any completion s of a partial solution with a set S of previously\ncomputed solutions. If this heuristic function is admissible then it does not underestimate\nthe distance of S \u222a{s} (i.e., it returns a lower bound that is less than or equal to the optimal\nlower bound for the distance).\nNote that similar to Online Method 2, this method is also sound but not complete since\neach solution depends on all previously computed solutions.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n19\n\nAlgorithm 3 CLASP-NK\nInput: An ASP program \u03a0, nonnegative integers n, and k\nOutput: A set X of n solutions that are k similar (n k -similar solutions)\nA \u2190 \u2205 // current assignment of literals\n5 \u2190 \u2205 // set of conflicts\nX \u2190 \u2205 // computed solutions\nwhile |X | < n do\nPartialSolution \u2190 A\nLowerBound \u2190 DISTANCE - ANALYZE(X , PartialSolution)\n// compute a lower\nbound for the distance between any completion of a partial solution and the set of\npreviously computed solutions\nPROPAGATION (\u03a0, A, 5)\n// propagate literals\nif Conflict in propagation OR LowerBound > k then\nRESOLVE - CONFLICT (\u03a0, A, 5)\n// learn and update conflicts, and backtrack\nelse\nif Current assignment does not yield an answer set then\nSELECT (\u03a0, A, 5) // select a literal to continue search\nelse\nX \u2190 X \u222a {A}\nA\u2190\u2205\nend if\nend if\nend while\nreturn X\n5.2 Computing n Most Similar Solutions\nIn the previous sections, we have described some computational methods to solve the\ndecision problem n k - SIMILAR SOLUTIONS. Let us discuss how we can solve the optimization problem n MOST SIMILAR SOLUTIONS. Let NKSimilar (n, k ) be a function that\nreturns-with one of the methods described in the previous subsections-a set S of n solutions which is k -similar; or returns empty set if no such set exists. Using this function,\nwe can find n most similar solutions as follows: First we compute a lower bound and an\nupper bound for the distance k of a set of n solutions. Then, we perform a binary search\nwithin these bounds to find a set S of solutions with the optimal value for k . Computations\nof a lower bound and an upper bound are usually specific to the particular problem. For\ninstance, consider the clique problem described in Section 5.1.2. We can find two most\nsimilar cliques in a graph, specifying the lower bound as 0 and the upper bound as the\nnumber of vertices in the graph and using one of the methods described above.\n5.3 Computing Maximal n k -Similar Solutions\nAnother optimization problem we are interested in is MAXIMAL n k - SIMILAR SOLU TIONS , which asks for a maximal set of solutions whose distance is at most k . We can\nsolve this problem by modifying Online Method 2: start with a solution (computed using\n\n\f20\n\nEiter et. al.\n\nSolve.lp), then repeatedly find a solution which is k -close to the previously found solutions until there does not exists such a solution. Recall that Online Method 2 iterates n\ntimes; here the iterations continue until no k -close solution is found. Since Online Method\n2 is incomplete, this method of computing maximal n k -similar solutions is incomplete as\nwell.\n5.4 Computing Close/Distant Solutions\nWe can solve the problem k - CLOSE SOLUTION utilizing the methods for n k - SIMILAR\nSOLUTIONS . For instance, we can modify Online Method 2: start with a set S of solutions,\nthen find a solution which is k -close to S . Based on this modified method, we can solve\nthe problem CLOSEST SOLUTION: we can compute a lower bound and an upper bound for\nk , and find the optimal value for k by a binary search between these bounds as described\nin the method for n MOST SIMILAR SOLUTIONS.\nAlternatively, for k - CLOSE SOLUTION, we can modify the ASP program P (Solve.lp)\nthat describes the computational problem P , by adding constraints, to ensure that the answer sets for P characterize solutions for P except for the ones included in the given set\nS of solutions. Let us call the modified ASP program P 0 . Next, we define a distance measure \u22060 that maps a set of solutions for P to a nonnegative integer, in terms of the given\nmeasure \u2206 as follows: \u22060 (X ) = \u2206(S \u222a X ). Then, we can use one of the computational\nmethods introduced for n k - SIMILAR SOLUTIONS with the ASP program P 0 , the distance\nfunction \u22060 and n = 1. In a similar way, we can find a solution to the problem CLOSEST\nSOLUTION utilizing the computational method for n MOST SIMILAR SOLUTIONS, with the\nASP program P 0 , the distance measure \u22060 and n = 1.\nWe can solve the problem k - CLOSE SET using one of the computational methods for\nn k - SIMILAR SOLUTIONS as well. For instance, we can use Online Method 1 with n =\n1, 2, 3, . . . , m, where m is an upper bound on the number of solutions for P , until a k close set S 0 of solutions is computed. For each n, we reformulate the ASP program P\nto compute a set S 0 of n solutions and add a constraint to this reformulation to ensure\nthat S 0 6= S when n = |S |; let us call this modified reformulation Pn . Then we try to\nfind a k -close set S 0 of n solutions with the ASP program Pn , and the distance measure\n\u220600 = |\u2206(S ) \u2212 \u2206(S 0 )|.\nAlternatively, we can use Online Method 2 or 3 with the ASP program P, with the\ndistance measure\n\u001a\n\u221e\nS = S0\n000\n\u2206 =\n|\u2206(S ) \u2212 \u2206(S 0 )| otherwise\nand with n = 1, 2, 3, . . . , m where m is an upper bound on the number of solutions for P .\n6 Computing Similar/Diverse Phylogenies\nLet us now illustrate the usefulness of our methods in a real-world application: reconstruction of evolutionary trees (or phylogenies) of a set of species based on their shared traits.\nThis problem is important for research areas as disparate as genetics, historical linguistics,\nzoology, anthropology, archeology, etc.. For example, a phylogeny of parasites may help\nzoologists to understand the evolution of human diseases (Brooks and McLennan 1991); a\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n21\n\nphylogeny of languages may help scientists to better understand human migrations (White\nand O'Connell 1982).\nThere are several software systems, such as PHYLIP (Felsenstein 2009), PAUP (Swofford 2003) or P HYLO -ASP (Erdem 2009), that can reconstruct a phylogeny for a set of\ntaxonomic units, based on \"maximum parsimony\" (Edwards and Cavalli-Sforza 1964) or\n\"maximum compatibility\" (Camin and Sokal 1965) criterion. With some of these systems,\nsuch as P HYLO -ASP, we can compute many good phylogenies (most parsimonious phylogenies, perfect phylogenies, phylogenies with most number of compatible traits, etc.)\naccording to the phylogeny reconstruction criterion. In such cases, in order to decide the\nmost \"plausible\" ones, domain experts manually analyze these phylogenies, since there is\nno available phylogenetic system that can analyze/compare these phylogenies.\nFor instance, P HYLO -ASP computes 45 plausible phylogenies for the Indo-European\nlanguages based on the dataset of (Brooks et al. 2007). In order to pick the most plausible\nphylogenies, in (Brooks et al. 2007), the historical linguist Don Ringe analyzes these phylogenies by trying to cluster these phylogenies into diverse groups, each containing similar\nphylogenies. In such a case, having a tool that reconstructs similar/diverse solutions would\nbe useful: with such a tool, an expert can compute (instead of computing all solutions) few\nmost diverse solutions, pick the most plausible one, and then compute phylogenies that are\nclose to this phylogeny.\nLet us show how our methods can be used for this purpose. Before that, we define a\nphylogeny and some distance functions to measure the similarity/diversity of phylogenies.\n6.1 Distance Measures for Phylogenies\nA phylogeny for a set of taxa is a finite rooted leaf-labeled binary directed tree hV , E i\nwith a set L of leaves (L \u2286 V ). The set L represents the given taxonomic units, whereas\nthe set V describes their ancestral units and the set E describes the genetic relationships\nbetween them. The labelings of leaves denote the values of shared traits at those nodes.\nWe consider distance measures that depend on topologies of phylogenies, therefore, while\ndefining them we discard these labelings.\nThere are various measures to compute the distance between two phylogenies (Nye et al.\n2006; Robinson and Foulds 1981; Hon et al. 2000; Kuhner and Felsenstein 1994; DasGupta\net al. 1997). In the following, first we consider one of these domain-independent functions,\nthe nodal distance measure (Bluis and Shin 2003), to compare two phylogenies; and then\nwe define a distance measure for a set of phylogenies based on the nodal distances of\npairwise phylogenies, to show the applicability of our methods for finding n k -similar\nphylogenies. Then we define a novel distance function that measures the distance of two\nphylogenies, and a distance function that measures the distance of a set of phylogenies,\ntaking into account some expert knowledge specific to evolution. With this measure we\nalso show the effectiveness of our methods.\n6.1.1 Nodal Distance of Two Phylogenies\nThe nodal distance NDP (x , y) of two leaves x and y in a phylogeny P is defined as follows: First, transform the phylogeny P (which is a directed tree) to an undirected graph G\n\n\f22\n\nEiter et. al.\n\nP1\n\nP2\n\na\n\nb\n\nb\n\nc\n\na\n\nc\n\nFig. 4. Two phylogenies P1 = (a, (b, c)) and P2 = (b, (a, c))\n\nwhere there is an undirected edge {i , j } in the graph for each directed edge (i , j ) in the\nphylogeny. Then NDP (x , y) is equal to the length of the shortest path between x and y\nin the undirected graph G. For example, consider the phylogeny, P1 in Fig. 4; the nodal\ndistance between a and b is 3, whereas the nodal distance between b and c is 2. Intuitively, the nodal distance between two leaves in a phylogeny represents the degree of their\nrelationship in that phylogeny.\nGiven two phylogenies P1 and P2 both with same set L of leaves, the nodal distance\nDn (P1 , P2 ) of two phylogenies is calculated as follows:\nDn (P1 , P2 ) =\n\nX\n\n|NDP1 (x , y) \u2212 NDP2 (x , y)|*\n\nx ,y\u2208L\n\nHere the difference of the nodal distances of two leaves x and y represents the contribution\nof this pair of leaves to the distance between the phylogenies.\nProposition 1\nGiven two phylogenies P1 and P2 with same set L of leaves and the same leaf-labeling\nfunction, Dn (P1 , P2 ) can be computed in O(|L|2 ) time.\nExample 2 shows an example of computing the nodal distance between two phylogenies.\nIn that example, we suppose that the phylogenies are presented in the Newick format,\nwhere the sister sub-phylogenies are enclosed by parentheses. For instance, the first tree,\nP1 , of Fig. 4 can be represented in the Newick format as (a, (b, c)).\nExample 2\nIn order to compute the nodal distance Dn (P1 , P2 ) between the phylogenies P1 = (a, (b, c))\nand P2 = (b, (a, c)) shown in Fig. 4, we compute the nodal distances of the pairs of leaves,\n{a, b}, {a, c} and {b, c}, and take the sum of the differences:\n\n\f23\n\nFinding Similar/Diverse Solutions in Answer Set Programming\nPairs of leaves\n\nDistance in P1\n\nDistance in P2\n\nDifference\n\n{a,b}\n{a,c}\n{b,c}\n\n3\n3\n2\n\n3\n2\n3\n\n0\n1\n1\n\nTotal distance\n\n2\n\nIn this case the distance between P1 and P2 is 2.\n\n6.1.2 Descendant Distance of Two Phylogenies\nNodal distance measure computes the distance between two rooted binary trees and does\nnot consider the evolutionary relations between nodes. In that sense, it is a domain-independent\ndistance measure for comparing phylogenies. A distance measure that takes into account\nthese relations and might give more accurate results. Therefore, we define a new distance\nfunction based on our discussions with the historical linguist Don Ringe. In particular, we\ntake into account the following domain-specific information in phylogenetics: the similarities of phylogenies towards their roots are more significant; and thus two phylogenies are\nmore similar if the diversifications closer to their roots are more similar.\nFor each vertex v of a tree T = hV , E i, let us define the descendants of x as follows:\n\u001a\n{v }\nv is a leaf in V\ndescT (v ) =\ndescT (u) \u222a descT (u 0 ) otherwise (v , u), (v , u 0 ) \u2208 E , u 6= u 0\nand the depth of a vertex v as follows:\n\u001a\n0\nv is the root of T\ndepthT (v ) =\n1 + depthT (u) otherwise(u, v ) \u2208 E *\nTo define the similarity of two phylogenies T = hV , E i and T 0 = hV 0 , E 0 i, let us first\ndefine the similarity of two vertices v \u2208 V and v 0 \u2208 V 0 :\n\u001a\n1 descT (v ) 6= descT 0 (v 0 )\n0\nf (v , v ) =\n0 otherwise\nFor every depth i (0 \u2264 i \u2264 min{maxv \u2208V depthT (v ), maxv 0 \u2208V 0 depthT 0 (v 0 )}), let us\nalso define a weight function weight(i ) that assigns a number to each depth i . The idea\nis to assign bigger weights to smaller depths so that two phylogenies are more similar if\nthe diversifications closer to the root are more similar. This is motivated by the fact that\nreconstructing the evolution of languages closer to the root is more important for historical\nlinguists.\nNow we can define the similarity of two trees T = hV , E i and T 0 = hV 0 , E 0 i, with the\nroots R and R 0 respectively, at depth i (0 \u2264 i \u2264 min{maxv \u2208V depth(v ), maxv 0 \u2208V 0 depth(v 0 )}),\nby the following measure:\ng(0, T , T 0 ) = weight(0) \u00d7 f (R, R 0 )\ng(i , T , T 0 ) = g(i \u2212 1, T , T 0 )+\nP\nweight(i ) \u00d7 x \u2208V ,y\u2208V 0 ,depth\n\nT\n\n(x )=depthT 0 (y)=i\n\nf (x , y),\n\ni >0\n\n\f24\n\nEiter et. al.\n\nand the similarity of two trees as follows:\nDl (T , T 0 ) = g(min{max depthT (v ), max\ndepthT 0 (v 0 )}, T , T 0 )*\n0\n0\nv \u2208V\n\nv \u2208V\n\nProposition 2\nGiven two trees P1 and P2 with same set L of leaves and the same leaf-labeling function,\nDl (P1 , P2 ) can be computed in O(|L|3 ) time.\nExample 3 shows an example of computing the distance between two trees shown in\nFig. 4.\nExample 3\nIn order to compute the descendant distance Dl (P1 , P2 ) between the phylogenies P1 =\n(a, (b, c)) and P2 = (b, (a, c)) shown in Fig. 4, for each depth level, we multiply the\nnumber of vertices that have different descendants with the weight of that depth level.\nThen, we add up the products to find the total distance between P1 and P2 .\nDepth\n\nWeight of Depth i\n\nNumber of pairs of vertices that\nhave different descendant sets\n\n0\n1\n2\n\n2\n1\n0\n\n0\n4\n3\n\nDistance =\n\n2\u00d70+1\u00d74+0\u00d73=4\n\nThe descendant distance between P1 and P2 is 4.\n\n6.1.3 Distance of a Set of Phylogenies\nIn the previous subsections, we defined distance functions for measuring the distance between two phylogenies. However, the problems that we defined in Section 3 requires a\ndistance function that measures the distance of a set of phylogenies. We can define the\ndistance of a set of phylogenies based on the distances among pairwise phylogenies. For\ninstance, the distance of a set S of phylogenies can be defined as the maximum distance\namong any two phylogenies in S .\nLet D be one of the distance measures defined in the previous subsection. Then, to be\nable to find similar phylogenies, the distance of a set S of phylogenies (\u2206D ) is defined as\nfollows:\n\u2206D (S ) = max{D(P1 , P2 ) | P1 , P2 \u2208 S }*\nTo be able to find diverse phylogenies, the distance of a set S of phylogenies (\u2206D ) is\ndefined as follows:\n\u2206D (S ) = min{D(P1 , P2 ) | P1 , P2 \u2208 S }*\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n25\n\n6.2 Computing n k -Similar/Diverse Phylogenies\nAnalogous to the n k -similar (resp. diverse) solutions, we define the n k -similar (resp.\ndiverse) phylogenies as follows:\nn k - SIMILAR PHYLOGENIES ( RESP. n k - DIVERSE PHYLOGENIES )\nGiven an ASP program P that formulates a phylogeny reconstruction problem P , a\ndistance measure \u2206D that maps a set of phylogenies for P to a nonnegative integer,\nand two nonnegative integers n and k , decide whether a set S of n phylogenies exists\nsuch that \u2206D (S ) \u2264 k (resp. \u2206D (S ) \u2265 k ).\nRecall that in order to compute n k -similar (resp. diverse) solutions we need an ASP\nprogram that computes a solution and a distance measure. We consider the ASP program\nphylogeny-improved.lp described in (Brooks et al. 2007) as our main program\nthat computes a phylogeny; this program is shown Fig.s B 5 and B 6 in Appendix B. We\nrepresent the nodal distance Dn (resp. the descendant Dl ) of two phylogenies as the ASP\nprogram in Fig. B 10 (resp. Figs. B 11 and B 12) in Appendix B. In addition, we consider\nthe program in Fig. B 13 that computes the total distance of a set of solutions with \u2206D and\neliminates the ones whose total distance is greater than k .\nFor Offline Method, we compute all the phylogenies using phylogeny-improved.lp.\nThen we build a graph of phylogenies as in Subsection 5.1.1. Then, we use the ASP program in Fig. B 1 in Appendix B to find a clique of size n in the constructed graph. This\nclique corresponds to n k -similar phylogenies.\nFor Online Method 1, we reformulate the main program phylogeny-improved.lp\nto obtain a program that computes n distinct phylogenies as in Section 5.1.2. The reformulation is shown in Fig.s B 7\u2013B 9 in Appendix B.\nFor Online Method 3, we define a heuristic function to estimate a low bound for the\ndistance between any completion of a given partial phylogeny and a complete phylogeny.\nLet Pc be any complete phylogeny, Pp be any partial phylogeny and Lp be the set of\npairs of leaves that appear in Pp . Consider the nodal distance (Section 6.1.1) for comparing\ntwo phylogenies. Then we can define a lower bound as follows:\nX\nLB n (Pp , Pc ) =\n|NDPc (x , y) \u2212 NDPp (x , y)|*\nx ,y\u2208Lp\n\nThis lower bound does not overestimate the distance between a phylogeny and any completion of a partial phylogeny.\nProposition 3\nGiven a partial phylogeny Pp and a complete phylogeny Pc , LB n (Pp , Pc ) is admissible,\ni.e., for every completion P of Pp ,\nLB n (Pp , Pc ) \u2264 Dn (P , Pc )*\nSimilarly, we can define an upper bound for the differences of nodal distances measure as\nfollows:\n\u0012 \u0013 \u0012\n\u0013\nX\nl\n|Lp |\n|NDPc (x , y) \u2212 NDPp (x , y)| + (\nUB n (Pp , Pc ) =\n\u2212\n) \u00d7 l*\n2\n2\nx ,y\u2208LP\n\n\f26\n\nEiter et. al.\n\nwhere l denotes the number of leaves in the complete tree.\nThis upper bound does not underestimate the distance between a phylogeny and any\ncompletion of a partial phylogeny.\nProposition 4\nGiven a partial phylogeny Pp and a complete phylogeny Pc , UB n (Pp , Pc ) is admissible,\ni.e., for every completion P of Pp , UB n (Pp , Pc ) \u2265 Dn (P , Pc )*\nAs regards the comparison of descendants distance measure, we could not find a tight\nlower and upper bounds. In our experiments, we consider that the lower bound (resp. upper\nbound) between a complete phylogeny and any completion of a partial phylogeny is 0\n(resp. \u221e).\n6.3 Experimental Results for Phylogeny Reconstruction\nWe applied the offline method and the online methods described in Section 5.1 to reconstruct similar/diverse phylogenies for Indo-European languages. We used the dataset assembled by Don Ringe and Ann Taylor (Ringe et al. 2002). As in (Brooks et al. 2007),\nto compute similar/diverse phylogenies, we considered the language groups Balto-Slavic\n(BS), Italo-Celtic (IC), Greco-Armenian (GA), Anatolian (AN), Tocharian (TO), IndoIranian (IIR), Germanic (GE), and the language Albanian (AL). While computing phylogenies, we also took into account some domain-specific information about these languages.\nIn our experiments, we considered the distance measures described in Section 6.1 as in\nSection 6.2.\nBelow all CPU times are in seconds, for a workstation with a 1.5GHz Xeon processor\nand 4x512MB RAM, running Red Hat Enterprise Linux (Version 4.3).\nExperiments with the Nodal Distance Let us first examine the results of experiments, considering the distance measure \u2206n , based on the nodal distance (Table 2). We present the\nresults for the following computations: 2 most similar solutions, 2 most diverse solutions,\n3 most similar solutions, 3 most diverse solutions, 6 most similar solutions. We solve these\noptimization problems by iteratively solving the corresponding decision problems (n k SIMILAR / DIVERSE SOLUTION ). For each method, we present the computation time, the\nsize of the memory used in computation, and the optimal value of k .\nLet us first compare the online methods. In terms of both computation time and memory\nsize, Online Method 3 performs the best, and Online Method 2 performs better than Online\nMethod 1. These results conforms with our expectations. Online Method 1 takes as input\nan ASP representation of computing n k -similar/diverse phylogenies, which is almost n\ntimes as large as the ASP program describing the phylogeny reconstruction problem used\nin other methods. Therefore, its computational performance may not be as good as the other\nonline methods. Online Method 2 relaxes this requirement a little bit so that the answer set\nsolver can compute the solutions more efficiently: it takes as input an ASP representation\nof phylogeny reconstruction, and an ASP representation of the distance measure, and then\ncomputes similar/diverse solutions one at a time. However, since the answer set solver\nneeds to compute the distances between every two solutions, the computation time and\nthe size of memory do not decrease much, compared to those for Online Method 1. Online\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n27\n\nTable 2. Computing similar/diverse phylogenies using the nodal distance \u2206n .\nProblem\n\nOffline Method\nReformulation\n(CLASP)\n\nOnline Methods\nIterative Comp. Incremental Comp.\n(CLASP, perl)\n(CLASP - NK)\n\n2 most similar\n(k = 12)\n\n12.39 sec.\n32MB\nk = 12\n\n26.23 sec.\n430MB\nk = 12\n\n19.00 sec.\n410MB\nk = 12\n\n1.46 sec.\n12MB\nk = 12\n\n2 most diverse\n(k = 32)\n\n11.81 sec.\n32MB\nk = 32\n\n21.75 sec.\n430MB\nk = 32\n\n18.41 sec.\n410MB\nk = 24\n\n1.01 sec.\n15MB\nk = 32\n\n3 most similar\n(k = 15)\n\n11.59 sec.\n32MB\nk = 15\n\n60.20 sec.\n730MB\nk = 15\n\n43.56 sec.\n626MB\nk = 15\n\n1.56 sec.\n15MB\nk = 16\n\n3 most diverse\n(k = 26)\n\n11.91sec.\n32MB\nk = 26\n\n46.32 sec.\n730MB\nk = 26\n\n44.67 sec.\n626MB\nk = 21\n\n0.96 sec.\n15MB\nk = 26\n\n6 most similar\n(k = 25)\n\n11.66sec.\n32MB\nk = 25\n\n327.28 sec.\n1.8GB\nk = 25\n\n178.96 sec.\n1.2GB\nk = 29\n\n1.96 sec.\n15MB\nk = 25\n\nMethod 3 deals with the time consuming computation of distances between solutions, not at\nthe representation level but at the search level. In that sense, its computational performance\nis better than Online Method 2.\nThe offline method takes into account the previously computed 8 phylogenies for IndoEuropean languages (with at most 17 incompatible characters), and computes similar/diverse\nsolutions using ASP as explained in Section 3. The offline method is more efficient, in\nterms of both computation time and memory, than Online Methods 1 and 2 since it does\nnot compute phylogenies. On the other hand, the offline method is less efficient, in terms\nof both computation time and memory, than Online Method 3, since it requires both representation and computation of distances between solutions.\nHere both the offline method and Online Method 1 guarantee finding optimal solutions\nby iteratively solving the corresponding decision problems. On the other hand, Online\nMethods 2 and 3 compute similar/diverse solutions with respect to the first computed solution, and thus may not find the optimal value for k , as observed in the computation of 3\nmost similar phylogenies.\nExperiments with the Nodal Distance Now, let us consider the distance measures \u2206l ,\nbased on preference over diversifications (Table 3): two phylogenies are more similar if\nthe diversifications closer to the root are more similar. Here we consider the similarities\nof diversifications until depth 3 (inclusive). We present the results for the following computations: 2 most similar solutions, 3 most diverse solutions, 6 most similar solutions. In\n\n\f28\n\nEiter et. al.\n\nTable 3, for each method, we present the computation time, the size of the memory used\nin computation, and the optimal value of k . Unlike what we have observed in Table 2, the\noffline method takes more time/space to compute similar/diverse solutions; this is due to\nthe computation of distances with respect to \u2206l which requires summations. Other results\nare similar to the ones presented in Table 2.\nAccuracy Let us compare the phylogenies computed by different distance measures in\nterms of accuracy. In (Brooks et al. 2007), after computing all 34 plausible phylogenies,\nthe authors examine them manually and come up with three forms of tree structures, and\nthen \"filter\" the phylogenies with respect to these tree structures. For instance, in Group 1,\nthe trees are of the form\n(AN, (TO, (AL, (IC, (a tree formed for GE, GA, BS, IIR)))));\nin Group 2, the trees are of the form\n(AN, (TO, (IC, (a tree formed for GE, GA, BS, IIR, AL))));\nin Group 3, the trees are of the form\n(AN, (TO, ((AL, IC), (a tree formed for GE, GA, BS, IIR)))).\nThe results of our experiments with the distance measure \u2206l comply with these groupings.\nFor instance, the 2 most similar phylogenies computed by Online Method 1 are in Group 1;\n(AN, (TO, (IC, ((GE, AL), (GA, (IIR, BS)))))),\n(AN, (TO, (IC, ((GE, AL), (BS, (IIR, GA)))))),\nPhylogenies 7 and 8 of (Brooks et al. 2007); both are in Group 1. The 3 most diverse\nphylogenies computed by Online Method 2 are\n(AN, (TO, (IC, (AL, (GE, (GA, (IIR, BS))))))),\n(AN, (TO, (AL, (IC, (GE, (GA, (IIR, BS))))))),\n(AN, (TO, ((GE, (GA, (IIR, BS))), (AL, IC)))),\nPhylogenies 10, 1, 40 of (Brooks et al. 2007); all in different groups. Likewise, the 6 similar\nphylogenies computed by our methods fall into Group 2.\nThese results (in terms of computational efficiency and accuracy) show the effectiveness of our methods in phylogeny reconstruction: we can automatically compare many\nphylogenies in detail.\n\n7 Computing Similar/Diverse Plans\nIn order to show the applicability and effectiveness of our methods to other domains, we\nextend our experiments further with the Blocks World planning problems.\nIn these experiments, we study the following instance of n k - SIMILAR SOLUTIONS\n(resp. n k - DIVERSE SOLUTIONS):\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n29\n\nTable 3. Computing similar/diverse phylogenies using the descendant distance \u2206l .\nProblem\n\nOffline Method\nReformulation\n(CLASP)\n\nOnline Methods\nIterative Comp. Incremental Comp.\n(CLASP, perl)\n(CLASP - NK)\n\n2 most similar\n(k = 18)\n\n365.16 sec.\n4.2GB\nk = 18\n\n16.11 sec.\n236MB\nk = 18\n\n16.23 sec.\n212MB\nk = 18\n\n0.635 sec.\n22MB\nk = 18\n\n3 most diverse\n(k = 20)\n\n368.59 sec.\n4.2GB\nk = 20\n\n46.11 sec.\n659MB\nk = 20\n\n44.21 sec.\n430MB\nk = 20\n\n1.014 sec.\n22MB\nk = 20\n\n6 most similar\n(k = 18)\n\n368.45 sec.\n4.2GB\nk = 18\n\n137.31 sec.\n1.8GB\nk = 18\n\n212.59 sec.\n1.1GB\nk = 18\n\n0.685 sec.\n22MB\nk = 20\n\nn k - SIMILAR PLANS ( RESP. n k - DIVERSE PLANS )\nGiven an ASP program P that formulates a planning problem P , a distance measure\n\u2206h that maps a set of plans for P to a nonnegative integer, and two nonnegative\nintegers n and k , decide whether a set S of n plans for P exists such that \u2206h (S ) \u2264 k\n(resp. \u2206h (S ) \u2265 k ).\n\nWe take P as the ASP formulation of the non-concurrent Blocks World as in (Erdem\n2002) to compute a plan of length at most l (Fig. B 14 in Appendix B), together with an\nASP description of the planning problem instance shown in Fig. 5.\nWe define the distance \u2206h (S ) of a set S of plans as follows:\n\u2206h (S ) = max{Dh (P1 , P2 ) | P1 , P2 \u2208 S , |P1 | \u2264 |P2 |}\nbased on the action-based Hamming distance Dh defined in (Srivastava et al. 2007) to\nmeasure the distance between two plans. Intuitively, Dh (P1 , P2 ) is the number of differentiating actions in each time step of two plans P1 and P2 . More precisely: let us denote a\nplan X of length l by a function actX that maps every nonnegative integer i (1 \u2264 i \u2264 l )\nto the i 'th action of the plan X , and let us denote by |X | the length of a plan X ; then the\nHamming Distance Dh (P1 , P2 ) between two plans P1 and P2 such that |P1 | \u2264 |P2 | can\nbe defined as follows:\nDh (P1 , P2 ) = |{i | actP1 (i ) 6= actP2 (i ), 1 \u2264 i \u2264 |P1 |}| + |P2 | \u2212 |P1 |\nASP formulations of the distance functions Dh and \u2206h (S ) are presented in Fig.s B 16\nand B 17 in Appendix B.\nConsider, for instance, a planning problem in the Blocks World that asks for a plan of\nlength less than or equal to 7. Consider two plans, P1 and P2 , that are characterized by the\n\n\f30\n\nEiter et. al.\n\nfunctions actP1 and actP2 respectively, as follows:\nactP1 (1) = moveop(b1 , Table) actP1 (2) = moveop(b2 , b1 )\nactP1 (3) = moveop(b4 , Table) actP1 (4) = moveop(b3 , b2 )\nactP1 (5) = moveop(b4 , b3 )\nactP1 (6) = moveop(b5 , b4 )\nactP2 (1) = moveop(b1 , Table) actP2 (2) = moveop(b2 , b1 )\nactP2 (3) = moveop(b4 , b5 )\nactP2 (4) = moveop(b3 , b2 )\nactP2 (5) = moveop(b4 , Table) actP2 (6) = moveop(b4 , b3 )\nactP2 (7) = moveop(b5 , b4 )\nThe distance Dh (P1 , P2 ) between P1 and P2 is 4 since the actions at time steps 3, 5 and 6\nare different and P2 has an additional action (at time step 7).\nTo be able to apply our Online Method 3 with CLASP - NK to compute n k -similar plans\nof length at most l , we define a heuristic function LB h to estimate a lower bound for the\ndistance between a plan Pc and any plan-completion of a \"partial\" plan Pp . Intuitively,\na partial plan consists of parts of a plan. Let us characterize a partial plan Pp by a partial\nfunction actPp from {1, ** *, l } to the set of actions; that is, actPp is a function from a subset\nof {1, * * *, l } to the set of actions. A plan-completion of a partial plan Pp is a plan Y of\nlength l 0 (l 0 \u2264 l ) for the planning problem P such that actY is an extension of actPp to\n{1, ***, l 0 }. Then we can define LB h (Pp , Pc ) for a partial plan Pp and a plan Pc as follows:\nLB h (Pp , Pc ) = |{i | actPp (i ) 6= actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}|\n+ |{i | i \u2208 dom actPp , |Pc | < i \u2264 l }|\nIn the Blocks World example above, consider a partial plan Pp characterized by the\nfunction actPp as follows:\nactPp (2) = moveop(b2 , b1 )\nactPp (4) = moveop(b3 , b2 )\nactPp (5) = moveop(b4 , Table) actPp (7) = moveop(b5 , b4 )\nThe lower bound LB h (Pp , P1 ) for the distance between any completion of Pp and P1 is\ncomputed as follows:\nLB h (Pp , P1 )\n\n=\n=\n\n|{i | actPp (i ) 6= actP1 (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 6}|\n+ |{i | i \u2208 dom actPp , 6 < i \u2264 7}|\n|{5}| + |{7}| = 2*\n\nOne completion of Pp is P2 . Note that LB h (Pp , P1 ) \u2264 Dh (P1 , P2 ). Indeed, the following\nproposition expresses that LB h does not overestimate the distance between Pc and any\nplan-completion X of Pp .\nProposition 5\nFor a partial plan Pp and a plan Pc for the planning problem P , LB h (Pp , Pc ) is admissible.\nSimilarly, to be able to apply our Online Method 3 with CLASP - NK to compute n k diverse plans of length at most l , we define a heuristic function UB h (Pp , Pc ) to estimate\nan upper bound for the distance between a plan Pc and any plan-completion of Pp :\nUB h (Pp , Pc ) = l \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}|*\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n31\n\nFig. 5. Blocks World problem.\nFor instance, for the partial plan Pp and P1 above,\nUB h (Pp , P1 )\n\n= 7 \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 6}|\n= 7 \u2212 |{2, 4}| = 7 \u2212 2 = 5\n\nand UB h (Pp , P1 ) \u2265 Dh (P1 , P2 ). Indeed, the following proposition expresses that this\nupper bound function does not underestimate the distance between Pc and any plancompletion X of Pp .\nProposition 6\nFor a partial plan Pp and a plan Pc for the planning problem P , UB h (Pp , Pc ) is admissible.\nWe performed some experiments with the ASP formulation, planning problem, and distance measures above, to find 2 most similar plans, 2 most diverse plans, 3 most similar plans, 3 most diverse plans, 6 most similar plans. Table 4 summarizes the results of\nthese experiments.\nIt can be observed that the planning problem in Fig. 5 has too many solutions to the\nproblem (more than 50.000), and it is intractable to compute all of them in advance and\nthen the distances between all pairwise solutions. Therefore, instead of computing all the\nsolutions in advance, we compute a subset of them (around 200) which is small enough\nto construct a distance graph, and apply our Offline Method in this way. However, these\n200 solutions are not diverse enough, and thus, although we can find many very similar\nsolutions, it is hard to find diverse solutions; for instance, we can find 6 1-similar solutions\nbut we can find only 3 6-diverse solutions.\nOnline Method 1 performs the worst in comparison with the other online methods, as in\nour experiments with phylogeny reconstruction problems, due to the large ASP program\n(Fig. B 15 in Appendix B) used for computing n distinct plans.\nOnline Method 2 is comparable with Online Method 3 in terms of computing similar\nsolutions. After computing a solution, computing a 1-similar solutions has a very small\nsearch space and C LASP can find a similar solution in a short time. On the other hand,\ncomputing a 21-diverse solution has a huge search space. Therefore, performance of computing diverse solutions with Online Method 2 is worse than that of Online Method 3.\n\n\f32\n\nEiter et. al.\n\nTable 4. Computing similar/diverse plans for the blocks world problem. OM denotes \"Out\nof memory.\"\nProblem\n\nOffline Method\nReformulation\n(CLASP)\n\nOnline Methods\nIterative Comp. Incremental Comp.\n(CLASP, perl)\n(CLASP - NK)\n\n2 most similar\n(k = 1)\n\nOM\n-\n\n6 min. 45 sec.\n106 MB\nk =1\n\n6 min. 53 sec.\n73 MB\nk =1\n\n7 min. 17 sec.\n111 MB\nk =1\n\n2 most diverse\n(k = 22)\n\nOM\n-\n\n33 min. 28 sec.\n213 MB\nk = 22\n\n11 min.\n73 MB\nk = 22\n\n7 min. 40 sec.\n112 MB\nk = 21\n\n3 most similar\n(k = 1)\n\nOM\n-\n\n7 min. 5 sec.\n141 MB\nk =1\n\n7 min. 3 sec.\n73 MB\nk =1\n\n7 min. 21 sec.\n112 MB\nk =2\n\n3 most diverse\n(k = 22)\n\nOM\n-\n\n78 min 42 sec.\n333 MB\nk = 22\n\n18 min. 49 sec.\n73 MB\nk = 21\n\n12 min. 40 sec.\n167 MB\nk = 21\n\n6 most similar\n(k = 1)\n\nOM\n-\n\n64 min. 42 sec.\n584 MB\nk =1\n\n7 min. 32 sec.\n73 MB\nk =1\n\n7 min. 18 sec.\n112 MB\nk =2\n\nOnline Method 3 deals with the Hamming distance computation at the search level. In\naddition, it does not restart the search process to compute a new solution; instead, it learns\nthe conflicts caused by distance difference while computing a new solution and backtracks\nto approximate levels to compute similar/diverse solutions. Especially, for the computation\nof diverse solutions, such a search strategy creates a significant performance gain.\n\n8 Related Work\nFinding similar/diverse solutions has been studied in other areas such as propositional logic\n(Bailleux and Marquis 1999), constraint programming (Hebrard et al. 2007; Hebrard et al.\n2005), and planning (Srivastava et al. 2007). Let us briefly describe related work in each\narea, and discuss the similarities and the differences compared with our approach.\nRelated Work in Propositional Logic In (Bailleux and Marquis 1999), Bailleux and Marquis study the following problem\nDISTANCE - SAT\nGiven a CNF formula \u03a3, a partial interpretation PI , and a nonnegative integer d ,\ndecide whether there is a model I of \u03a3 such that I disagrees with PI on at most d\natoms.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n33\n\nThis problem is similar to k - CLOSE SOLUTION in that it asks for a k -close solution. On\nthe other hand, it asks for a solution k -close to a partial solution, whereas k - CLOSE SO LUTION asks for a solution that is k -close to a set of previously computed solutions. Also,\nDISTANCE - SAT considers a distance measure (i.e., partial Hamming distance) computable\nin polynomial time; whereas k - CLOSE SOLUTION considers any distance measure such\nthat deciding whether the distance of a set of solutions is less than a given k is in NP. Despite these differences, with S containing a single solution and \u2206 being a partial Hamming\ndistance, k - CLOSE SOLUTION becomes essentially the same as DISTANCE - SAT.\nAs for the computational complexity analysis, Proposition 1 of (Bailleux and Marquis\n1999) shows that in the general case DISTANCE - SAT is NP-complete. However, determining whether \u03a3 has a model that disagrees with a complete interpretation I on at most d\nvariables, where d is a constant, is in P.\nTo solve DISTANCE - SAT, the authors propose two algorithms, DPdistance and DPdistance+lasso .\nOur modification of CLASP's algorithm is similar to the first algorithm in that both algorithms check whether a partial interpretation computed in the DPLL-like search obeys the\ngiven distance constraints. On the other hand, unlike DPdistance , CLASP also uses conflictdriven learning: when it learns a conflicting set of literals, it will never try to select them\nin the later stages of the search. DPdistance+lasso offers manipulations while selecting a new\nvariable: it creates a set of candidate variables with respect to the distance function, computes weights of these variables relative to the distance function, and selects one with\nthe maximum weight. On the other hand, in SELECT, CLASP creates a set of candidate\nvariables, and selects one of the candidates to continue the search. Using the idea of\nDPdistance+lasso , we can modify CLASP further to manipulate the selection of variables with\nrespect to the distance function. However, in the phylogeny reconstruction problem, since\nthe domain of the distance function consists of the edge atoms which are far outnumbered\nby many auxiliary atoms, in SELECT the set of candidate variables generally consists of\nonly auxiliary variables; due to these cases, the manipulation of the selection of variables\nis not expected to improve the computational efficiency.\nRelated Work in Constraint Programming In (Hebrard et al. 2007; Hebrard et al. 2005), the\nauthors study various computational problems related to finding similar/diverse solutions.\nThe main decision problems studied in (Hebrard et al. 2005) are the following:\nd D ISTANTk S ET (resp. d C LOSEk S ET)\nGiven a polynomial-time decidable and polynomially balanced relation R over strings,\na symmetric, reflexive, total and polynomially bounded distance function \u03b4 between\nstrings, and some string x , decide whether there is a set S of k strings (i.e., S \u2282\n{y | (x , y) \u2208 R}) such that miny,z \u2208S \u03b4(y, z ) \u2265 d (resp. maxy,z \u2208S \u03b4(y, z ) \u2264 d ).\nwhich are similar to d - DISTANT SET (resp. d - CLOSE SET): (Hebrard et al. 2005) asks for a\nset of k solutions d -distant/close to one solution, whereas d - DISTANT / CLOSE SET asks for\na set of solutions that is d -close/distant to a set of previously computed solutions. Also, the\ndistance measure considered in d D ISTANTk S ET (resp. d C LOSEk S ET) is computable in\npolynomial time; in d - DISTANT SET (resp. d - CLOSE SET) deciding whether the distance\nof a set of solutions is less than a given d is assumed to be in NP.\nThe main decision problems studied in (Hebrard et al. 2007) are the following:\n\n\f34\n\nEiter et. al.\nd D ISTANT (resp. d C LOSE)\nGiven a constraint satisfaction problem P with variables ranging over finite domains,\na symmetric, reflexive, total and polynomially bounded distance function \u03b4 between\npartial instantiations of variables, and some partial instantiation p of variables of P ,\ndecide whether there is a solution s of P such that \u03b4(p, s) \u2265 d (\u03b4(p, s) \u2265 d ).\n\nwhich are similar to d - DISTANT SOLUTION and d - CLOSE SOLUTION. On the other hand,\n(Hebrard et al. 2007) asks for a solution d -close to a partial solution rather than a set\nof solutions. Also, the distance measure considered in these problems is computable in\npolynomial time. However, with S containing a single solution and \u2206 being computable in\npolynomial time, d - DISTANT SOLUTION (resp. d - CLOSE SOLUTION) becomes essentially\nthe same as d D ISTANT (resp. d C LOSE).\nThe authors also study some optimization problems related to these problems, similar to\nthe ones that we study above.\nAs for the computational complexity analysis of these problems, the authors find out that\nthey are all NP-complete; these results comply with the ones presented in Section 4 subject\nto conditions under which the problems of (Hebrard et al. 2005; Hebrard et al. 2007) above\nare equivalent to the problems we study in this paper.\nConsidering partial Hamming distance as in (Bailleux and Marquis 1999), Hebrard et\nal. present an offline method (similar to our method) that applies clustering methods, and\ntwo online methods: one based on reformulation (similar to Online Method 1), the other\nbased on a greedy algorithm (similar to Online Method 2) that iteratively computes a solution that maximizes similarity to previous solutions. The computation of a k -close solution\nis due to a Branch & Bound algorithm (similar to the idea behind Online Method 3) that\npropagates some similarity/diversity constraints specific to the given distance function. Our\noffline/online methods are inspired by these methods of (Hebrard et al. 2007; Hebrard et al.\n2005).\nWe note that partial Hamming distance not unrelated to the ones introduced for comparing phylogenies in Section 6.1; one can polynomially reduce nodal distance to partial\nHamming distance, and vice versa also partial Hamming distance to nodal distance of trees\n(allowing auxiliary atoms in the LP encoding).\nRelated Work in Planning In (Srivastava et al. 2007), the authors study the following decision problem:\nd D ISTANTk S ET (resp. d C LOSEk S ET)\nFind a set S of k plans for a planning problem PP , such that miny,z \u2208S \u03b4(y, z ) \u2265 d\n(resp. maxy,z \u2208S \u03b4(y, z ) \u2264 d ).\nThe authors study these problems considering domain-independent distance measures computable in polynomial time (such as Hamming distance or set difference). They present a\nmethod (similar to our Online Method 1), where they add global constraints to the underlying constraint satisfaction solver of the GP-CSP planner (Do and Kambhampati 2001). As\nanother method they present a greedy approach (similar to our Online Method 2), where\nthey add global constraints which forces solver to compute k -diverse solutions in each iteration until it computes n solutions. They also present a method (similar to our Online\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n35\n\nMethod 3) which modifies an existing planner's (Gerevini et al. 2003) heuristic function\nand computes n k -similar solutions in the search level.\nAdvantages of using ASP-Based Methods/Tools Our ASP-based methods for computing\nsimilar/diverse or close/distant solutions to a given problem have three main advantages\ncompared to other approaches:\n\u2022 they are not restricted to some domain-independent distance function, like (partial)\nHamming distance considered in all the methods/tools above;\n\u2022 depending on the particular ASP-based method, we can represent domain-independent\nor domain-specific distance functions in ASP or implement them in C++;\n\u2022 we can use the definitions of distance functions modularly, without modifying the\nmain problem description or without modifying the search algorithm or the implementation of the solver.\nThus, our ASP-based methods/tools for computing similar/diverse or close/distant solutions are applicable to various problems with different (often domain-specific) distance\nmeasures.\nIn that sense, a user may prefer to use our ASP-based methods/tools for computing\nsimilar/diverse or close/distant solutions to a given problem, compared to the SAT-based\nmethods/tools and the CP-based methods/tools, if the user considers a domain-specific\ndistance function but does not want to modify the CP/SAT solvers to be able to compute\nsimilar/diverse or distant/close solutions.\nAlso, our ASP-based methods/tools may be preferred when it is easier to represent the\nmain problem in ASP, due to advantages inherited from the expressive representation language of ASP, such as being able to define the transitive closure. Some sample applications\ninclude phylogenetic network reconstruction (Erdem et al. 2006) and wire routing (Coban\net al. 2008; Erdem and Wong 2004).\nASP-based methods for computing similar/diverse or close/distant solutions to a given\nproblem are probably most useful for existing well-studied ASP applications, such as\nphylogeny reconstruction (Brooks et al. 2005; Brooks et al. 2007) or product configuration (Soininen and Niemel\u00e4 1998), to be used with domain-specific measures.\n\n9 Conclusion\nWe have studied two kinds of computational problems related to finding similar/diverse solutions of a given problem, in the context of ASP: one problem asks for a set of n k -similar\n(resp. k -diverse) solutions; the other asks, given a set of solutions, for a k -close (k -distant)\nsolution s. We have analyzed the computational complexity of these problems, and introduced offline/online methods to solve them. We have applied these offline/online methods\nto the phylogeny reconstruction problem, and observed their effectiveness in computing\nsimilar/diverse phylogenies for Indo-European languages. Similarly we have applied these\nmethods to planning problems, and observed their effectiveness in computing in particular diverse plans in Blocks World. Finally, we have compared our work with related approaches based on other formalisms.\n\n\f36\n\nEiter et. al.\n\nThere are many appealing ASP applications for which finding similar/diverse solutions could be useful. In this sense, our methods and implementation (i.e., CLASP - NK)\ncan be useful for ASP. On the other hand, no existing phylogenetic system can compute similar/diverse phylogenies. In this sense, our distance functions, methods, and tools\ncan be useful for phylogenetics. Similarly, no planner can compute similar/diverse plans\nwith respect to a domain-specific measure, our methods and tools can be useful for planning. In general, the ASP-based methods/tools can be useful for finding similar/diverse\nor close/distant solutions to a problem in two cases: representing the problem in ASP is\neasier (e.g., if the problem involves recursive definitions like transitive closure), or the distance measure is different from the Hamming distance (implemented in the SAT/CP-based\ntools).\nWe are also interested in combinations of the problems studied above (for instance,\nfinding a phylogeny that is the most distant from a given set of phylogenies and that is\nthe closest to another given set of phylogenies), and application of our methods to other\nproblems. The study of these problems is left as a future work.\nAcknowledgments\nWe are grateful to the reviewers of the paper as well as the reviewers of the preliminary\nconference version for their comments and constructive suggestions for improvement, in\nparticular regarding the computation of nodal distances.\nReferences\nBAFNA , V. AND P EVZNER , P. 1998. Sorting by transpositions. SIAM Journal of Discrete Mathematics 11, 224\u2013240.\nBAILLEUX , O. AND M ARQUIS , P. 1999. DISTANCE-SAT: complexity and algorithms. In Proc. of\nAAAI. 642\u2013647.\nB LUIS , J. AND S HIN , D.-G. 2003. Nodal distance algorithm: Calculating a phylogenetic tree comparison metric. In Proc. of BIBE. 87.\nB ODENREIDER , O., \u00c7 OBAN , Z. H., D O \u011eANAY, M. C., E RDEM , E., AND KO\u015eUCU , H. 2008. A\npreliminary report on answering complex queries related to drug discovery using answer set programming. In Proc. of ALPSWS.\nB ROOKS , D. AND M C L ENNAN , D. 1991. Phylogeny, Ecology, and Behavior: A Research Program\nin Comparative Biology. University of Chicago Press, Chicago, IL.\nB ROOKS , D. R., E RDEM , E., E RDOGAN , S. T., M INETT, J. W., AND R INGE , D. 2007. Inferring\nphylogenetic trees using answer set programming. J. Autom. Reasoning 39, 4, 471\u2013511.\nB ROOKS , D. R., E RDEM , E., M INETT, J. W., AND R INGE , D. 2005. Character-based cladistics and\nanswer set programming. In Proc. of PADL. 37\u201351.\nC ALDIRAN , O., H ASPALAMUTGIL , K., O K , A., PALAZ , C., E RDEM , E., AND PATOGLU , V. 2009.\nBridging the gap between high-level reasoning and low-level control. In Proc. of LPNMR.\nC AMIN , J. AND S OKAL , R. 1965. A method for deducing branching sequences in phylogeny. Evolution 19, 3, 311\u2013326.\nC HAFLE , G., DASGUPTA , K., K UMAR , A., M ITTAL , S., AND S RIVASTAVA , B. 2006. Adaptation\nin web service composition and execution. In Proc. of ICWS. 549\u2013557.\nC HEN , Z.-Z. AND T ODA , S. 1995. The complexity of selecting maximal solutions. Information and\nComputation 119, 231\u2013239.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n37\n\nC OBAN , E., E RDEM , E., AND T URE , F. 2008. Comparing ASP, CP, ILP on two challenging applications: Wire routing and haplotype inference. In Proc. of the 2nd International Workshop on\nLogic and Search (LaSh 2008).\nDAS G UPTA , B., H E , X., J IANG , T., L I , M., T ROMP, J., AND Z HANG , L. 1997. On distances\nbetween phylogenetic trees. In Proc. of SODA. 427\u2013436.\nDAVIS , M., L OGEMANN , G., AND L OVELAND , D. 1962. A machine program for theorem-proving.\nCommunications of the ACM 5, 394\u2013397.\nD O , M. B. AND K AMBHAMPATI , S. 2001. Planning as constraint satisfaction: Solving the planning\ngraph by compiling it into CSP. Artificial Intelligence 132, 2, 151\u2013182.\nE DWARDS , A. AND C AVALLI -S FORZA , L. 1964. Phenetic and Phylogenetic Classification, 67\u201376.\nE ITER , T. AND S UBRAHMANIAN , V. 1999. Heterogeneous active agents, ii: Algorithms and complexity. Artif. Intell. 108(1-2), 257\u2013307.\nE RDEM , E. 2002. Theory and applications of answer set programming. Ph.D. thesis, Department of\nComputer Sciences, University of Texas at Austin.\nE RDEM , E. 2009. PHYLO-ASP: Phylogenetic systematics with answer set programming. In Proc.\nof LPNMR. 567\u2013572.\nE RDEM , E., L IFSCHITZ , V., AND R INGE , D. 2006. Temporal phylogenetic networks and logic\nprogramming. Theory and Practice of Logic Programming 6, 5, 539\u2013558.\nE RDEM , E. AND W ONG , M. D. F. 2004. Rectilinear Steiner Tree construction using answer set\nprogramming. In Proc. of ICLP. 386\u2013399.\nF ELSENSTEIN , J. 2009. Phylip. http://evolution.genetics.washington.edu/\nphylip.html.\nF ERRARIS , P. AND L IFSCHITZ , V. 2005. Weight constraints as nested expressions. Theory and\nPractice of Logic Programming 5, 45\u201374.\nG EBSER , M., K AUFMANN , B., N EUMANN , A., AND S CHAUB , T. 2007a. clasp: A Conflict-Driven\nAnswer Set Solver. In Proc. of LPNMR. 260\u2013265.\nG EBSER , M., K AUFMANN , B., N EUMANN , A., AND S CHAUB , T. 2007b. T.: Conflict-driven answer\nset solving. In Proc. of IJCAI. 386\u2013392.\nG ELFOND , M. AND L IFSCHITZ , V. 1991. Classical negation in logic programs and disjunctive\ndatabases. New Generation Computing 9, 365\u2013385.\nG EREVINI , A., S AETTI , A., AND S ERINA , I. 2003. Planning through stochastic local search and\ntemporal action graphs in lpg. J. Artif. Int. Res. 20, 1, 239\u2013290.\nG UTIN , G. 2003. Handbook of Graph Theory. CRC Press, Chapter 5.3 Independent sets and cliques,\n389\u2013402.\nH AMMING , R. W. 1950. Error detecting and error correcting codes. Bell System Technical Journal 29, 2, 147\u2013160.\nH EBRARD , E., H NICH , B., O'S ULLIVAN , B., AND WALSH , T. 2005. Finding diverse and similar\nsolutions in constraint programming. In Proc. of AAAI. 372\u2013377.\nH EBRARD , E., O'S ULLIVAN , B., AND WALSH , T. 2007. Distance constraints in constraint satisfaction. In Proc. of IJCAI. 106\u2013111.\nH ON , W.-K., K AO , M.-Y., AND L AM , T.-W. 2000. Algorithms and Computation. Springer Berlin\n/ Heidelberg, Chapter Improved Phylogeny Comparisons: Non-shared Edges, Nearest Neighbor\nInterchanges, and Subtree Transfers, 369\u2013382.\nK AUTZ , H. A. AND S ELMAN , B. 1992. Planning as satisfiability. In Proc. of ECAI. 359\u2013363.\nK UHNER , M. AND F ELSENSTEIN , J. 1994. A simulation comparison of phylogeny algorithms\nunder equal and unequal evolutionary rates [published erratum appears in mol biol evol 1995\nmay;12(3):525]. Mol Biol Evol 11, 3 (May), 459\u2013468.\nL IFSCHITZ , V. 1999. Action languages, answer sets and planning. In The Logic Programming\nParadigm: a 25-Year Perspective. Springer Verlag, 357\u2013373.\n\n\f38\n\nEiter et. al.\n\nL IFSCHITZ , V. 2008. What is answer set programming? In Proc. of. AAAI. 1594\u20131597.\nL IFSCHITZ , V. 2010. Thirteen definitions of a stable model. In Fields of Logic and Computation.\n488\u2013503.\nL IFSCHITZ , V., TANG , L. R., AND T URNER , H. 1999. Nested expressions in logic programs. Annals\nof Mathematics and Artificial Intelligence 25, 369\u2013389.\nM AREK , W. AND R EMMEL , J. 2003. On the expressibility of stable logic programming. Theory\nand Practice of Logic Programming 3, 4-5, 551\u2013567.\nM ARQUES -S ILVA , J. AND S AKALLAH , K. 1999. A search algorithm for propositional satisfiability.\nIEEE Trans. Computers 5, 506\u2013521.\nM C I LRAITH , S. A. AND S ON , T. C. 2002. Adapting Golog for composition of semantic web\nservices. In Proc. of KR. 482\u2013496.\nN OGUEIRA , M., BALDUCCINI , M., G ELFOND , M., WATSON , R., AND BARRY, M. 2001. An aprolog decision support system for the space shuttle. In Proc. of PADL. Springer-Verlag, London,\nUK, 169\u2013183.\nN YE , T. M., L IO , P., AND G ILKS , W. R. 2006. A novel algorithm and web-based tool for comparing\ntwo alternative phylogenetic trees. Bioinformatics 22, 1 (January), 117\u2013119.\nPAPADIMITRIOU , C. 1994. Computational Complexity. Addison-Wesley.\nR INGE , D., WARNOW, T., AND TAYLOR , A. 2002. Indo-European and computational cladistics.\nTransactions of the Philological Society 100, 1, 59\u2013129.\nROBINSON , D. F. AND F OULDS , L. R. 1981. Comparison of phylogenetic trees. Mathematical\nBiosciences 53, 1-2 (February), 131\u2013147.\nS IMONS , P., N IEMEL \u00c4 , I., AND S OININEN , T. 2002. Extending and implementing the stable model\nsemantics. Artificial Intelligence 138, 181\u2013234.\nS OININEN , T. AND N IEMEL \u00c4 , I. 1998. Developing a declarative rule language for applications in\nproduct configuration. In Proc. of PADL. 305\u2013319.\nS ON , T., P ONTELLI , E., AND S AKAMA , C. 2009. Logic programming for multiagent planning with\nnegotiation. In Proc. of ICLP. 99\u2013114.\nS RIVASTAVA , B., N GUYEN , T. A., G EREVINI , A., K AMBHAMPATI , S., D O , M. B., AND S ERINA ,\nI. 2007. Domain independent approaches for finding diverse plans. In Proc. of IJCAI. 2016\u20132022.\nS WOFFORD , D. L. 2003. PAUP*: Phylogenetic analysis under parsimony (and other methods).\nversion 4.0. Sinauer Associates, Sunderland, Mass.\nW HITE , J. AND O'C ONNELL , J. 1982. A Prehistory of Australia, New Guinea, and Sahul. Academic, San Diego, CA.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n39\n\nAppendix A Proofs of Theorems\nProof of Theorem 1\nMembership: Consider a non-deterministic Turing machine M , operating on input P, M\u2206\u2264\n(resp. M\u2206\u2265 ), n, and k , which guesses S as a set {s1 , . . . , sn } of n interpretations over the\nalphabet of P, together with a potential witness w for a computation of M\u2206\u2264 (resp. M\u2206\u2265 ) of\nlength polynomial in n. After that, for 1 \u2264 i \u2264 n, M checks whether si is an answer set\nof P and whether all si represent distinct solutions of the problem. It rejects if any of these\ntests does not succeed. Otherwise, M proceeds by verifying that w is a witness of M\u2206\u2264\n(resp. M\u2206\u2265 ) given S and k as its input. If so, then M accepts, otherwise it rejects. Since n\nis polynomial in the size of the input to M , this also holds for the guess of M . Moreover,\nthe subsequent computation of M , i.e., the tests carried out, can be accomplished in time\npolynomial in n. Therefore, M is a non-deterministic Turing machine which decides n k SIMILAR SOLUTIONS (respectively n k - DIVERSE SOLUTIONS) in polynomial time, which\nproves NP-membership for these problems.\nV\nHardness: Let \u03c6 = 1\u2264i\u2264l ci be a Boolean formula in conjunctive normal form (CNF)\nover variables B = {b1 , . . . , bm }, i.e., each ci is a clause over variables from B . By x\u0304\nwe denote the complement of a literal x , i.e., x\u0304 = \u00acb if x = b, and x\u0304 = b if x = \u00acb.\nThis notation is extended to clauses in the obvious way: c\u0304 = x\u03041 \u2227 . . . \u2227 x\u0304lc for a clause\nc = x1 \u2228 . . . \u2228 xlc .\nConsider the normal logic program P = {bi \u2190 not nbi ; nbi \u2190 not bi | 1 \u2264 i \u2264\nm} \u222a {\u2190 c\u0304i0 | 1 \u2264 i \u2264 l }, where c\u0304 0 denotes the conjunction obtained from c\u0304 by replacing\nnegative literals \u00acx in c\u0304 by nx (and using ',' instead of '\u2227'). It is easily verified (and wellknown) that P has an answer set iff \u03c6 is satisfiable (and that every answer set of P is in\n1-to-1 correspondence with a satisfying assignment of \u03c6 in the obvious way).\nGiven P, consider the n k - SIMILAR SOLUTIONS (respectively n k - DIVERSE SOLU TIONS ) problem, where n = 1, k = 0, and for any set S of answer sets of P, the distance\nmeasure \u2206 is defined by \u2206(S ) = 0. Note that \u2206 is normal and computable in constant\ntime. Then, there exists a solution to the problem iff there exists a set S of answer sets of P\nsuch that |S | = 1, i.e., P has an answer set. Since P has an answer set iff \u03c6 is satisfiable,\nthis proves NP-hardness of the n k - SIMILAR SOLUTIONS (respectively n k - DIVERSE SO LUTIONS ) problem. Note that this argument holds for any normal \u2206.\nProof of Theorem 2\nMembership: Consider a non-deterministic Turing machine M , operating on input P, M\u2206\u2264\n(resp. M\u2206\u2265 ), a set S of solutions given by answer sets of P, and k . It guesses an interpretation s over the alphabet of P (which is polynomial in the size of P), together with a potential witness w for a computation of M\u2206\u2264 (resp. M\u2206\u2265 ) of length polynomial in |S |+|s|+log k .\nAfter that, M checks whether s is an answer set of P and whether it represents a solution\ndifferent from all solutions in S . It rejects if any of these tests does not succeed. Otherwise, M proceeds by verifying that w is a witness of M\u2206\u2264 (resp. M\u2206\u2265 ) on input S \u222a {s}\nand k . If so, then M accepts, otherwise it rejects. The guess of M is polynomial in its input\nand the subsequent computation of M , i.e., the tests carried out, can be accomplished in\npolynomial time. Therefore, M is a non-deterministic Turing machine which decides k CLOSE SOLUTION (respectively k - DISTANT SOLUTION ) in polynomial time, which proves\nNP-membership for these problems.\n\n\f40\n\nEiter et. al.\n\nHardness: Consider the normal logic program given in the proof of Theorem 1, and the\nk - CLOSE SOLUTION problem, where S = \u2205, k = 0, and for any set S 0 of answer sets of P,\nthe distance measure \u2206 is defined by \u2206(S 0 ) = 0. Note that \u2206 is normal and computable\nin constant time. Then, there exists a solution to the problem iff there exists a set S 0 of\nanswer sets of P such that S 0 6= \u2205, i.e., P has an answer set, which proves NP-hardness of\nthe k - CLOSE SOLUTION problem. Similarly, the k - DISTANT SOLUTION problem, where\nS = \u2205, k = 0, and \u2206(S 0 ) = 0, has a solution iff P has an answer set. Moreover, the above\narguments hold for any normal \u2206. This proves the claim.\nProof of Theorem 3\nMembership: The problem of computing the cardinality of a maximal solution S of size\nat most n is an optimization problem for a problem in NP such that the optimal value can\nbe represented using log n bits. Let Mopt be an oracle for this problem, and consider a\nnon-deterministic Turing machine M 0 , with output tape operating on input P, M\u2206\u2264 (resp.\nM\u2206\u2265 ), and k . Initially, M 0 calls Mopt with P, M\u2206\u2264 (resp. M\u2206\u2265 ), and k as input to compute\nthe maximum cardinality c of a set of solutions S such that |S | \u2264 n. Then, M 0 proceeds\nlike the nondeterministic Turing machine M in the proof of Theorem 1 using n = c, additionally writing the guessed solution S to its output tape. Since the latter is accomplished\nin time polynomial in c, M 0 is a non-deterministic Turing machine with output tape that\nconsults an oracle once for computing the optimal value of an optimization problem solvable in NP. Thus, M 0 is in FNP//log and decides MAXIMAL n k - SIMILAR SOLUTIONS\n(respectively MAXIMAL n k - DIVERSE SOLUTIONS).\nHardness: We reduce X -MinModel to the problem of computing MAXIMAL n k - SIMILAR\nSOLUTIONS . X -MinModel is the following FNP//log-complete problem: Given a Boolean\nformula in CNF as in the proof of Theorem 1, and a subset X of B , compute an X -minimal\nmodel of \u03c6, i.e., a satisfying assignment for \u03c6, which is subset minimal among all satisfying assignments for \u03c6 on the variables from X which are assigned true. We identify a\ntruth assignment with the set of Boolean variables that are assigned true, and for a truth\nassignment s, we use s|X to denote its restriction to variables from X .\nConsider the normal logic program given in the proof of Theorem 1, and the MAXIMAL\nn k - SIMILAR SOLUTIONS problem, where n = |X |, k = 0, and \u2206 is defined as follows.\nFor a given set S of answer sets of P, such that |S | > 0, we set \u2206(S ) = 0 if for every pair\nof answer sets s1 , s2 in S , either s1 |X \u2282 s2 |X , or s2 |X \u2282 s1 |X . Otherwise (and if S = \u2205),\n\u2206(S ) = 1. Note that \u2206 is computable in polynomial time, performing less than 2n 2 checks\nfor proper containment, where |S | = n. Observe also that the answer sets in a set S such\nthat \u2206(S ) = 0, can be strictly ordered wrt. subset inclusion on their restrictions to X ,\nand that |X | is the maximum cardinality for such a set of answer sets. Given S such that\n\u2206(S ) = 0, let s1 denote the minimal answer set in S wrt. subset inclusion on the restriction\nto X . The following is trivial: the MAXIMAL n k - SIMILAR SOLUTIONS problem above has\na solution iff \u03c6 is satisfiable. By the problem definition, it also holds for every solution S\nof the problem that \u2206(S ) = 0.\nWe show that if S is a solution of the MAXIMAL n k - SIMILAR SOLUTIONS problem\ngiven above, then s1 is an X -minimal model of \u03c6. Towards a contradiction assume that\nthere exists a satisfying assignment s 0 for \u03c6, such that s 0 |X \u2282 s1 |X . Consider s0 = s 0 \u222a\n{nb | b \u2208 B , b 6\u2208 s 0 }. Since s 0 satisfies \u03c6, it holds that s0 is an answer set of P. Moreover\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n41\n\ns0 6\u2208 S , since s0 |X \u2282 s1 |X and s1 is the minimal answer set in S wrt. subset inclusion on\nthe restriction to X . As a consequence, S \u222a{s0 } \u2283 S and \u2206(S \u222a{s0 }) = 0. However, since\nthe latter also implies |S \u222a {s0 }| \u2264 n, this contradicts our assumption that S is a solution\nof the MAXIMAL n k - SIMILAR SOLUTIONS problem above. We have thus shown that no\nsatisfying assignment s 0 for \u03c6 exists, such that s 0 |X \u2282 s1 |X , i.e., that s1 is an X -minimal\nmodel of \u03c6. This completes the reduction of X -MinModel to the problem of computing\nMAXIMAL n k - SIMILAR SOLUTIONS, proving FNP//log-hardness.\nFor a reduction of X -MinModel to the problem of computing MAXIMAL n k - DIVERSE\nSOLUTIONS , we simply swap the values of \u2206 and define: \u2206(S ) = 1 if |S | > 0 and for\nevery pair of answer sets s1 , s2 in S , either s1 |X \u2282 s2 |X , or s2 |X \u2282 s1 |X . Otherwise (and\nif S = \u2205), \u2206(S ) = 0. FNP//log-hardness follows by analogous arguments.\nProof of Theorem 4\nMembership: Consider a deterministic Turing machine M 0 , with output tape and an oracle\nfor NP-problems, which operates on input P, M\u2206\u2264 (resp. M\u2206\u2265 ), and n. Initially, M 0 prepares an integer k1 of n bits with the less significant half of bits set to 1 and the remaining\nbits set to 0. Then, M 0 successively uses its oracle operating as the nondeterministic Turing\nmachine M in the proof of Theorem 1, starting with input P, M\u2206\u2264 (resp. M\u2206\u2265 ), n, and k1 ,\nperforming a binary search for an optimal k . After that, M 0 once more uses its oracle like\nthe nondeterministic Turing machine M in the proof of Theorem 1, but additionally copying the solution S guessed by the oracle to its output tape. Since the latter is accomplished\nin time polynomial in n, and since a polynomial number of calls to the oracle is sufficient\nto complete the binary search, M 0 is in FPNP and decides n MOST SIMILAR SOLUTIONS\n(respectively n MOST DIVERSE SOLUTIONS).\nIf the value of \u2206(S ) is polynomial in the size of S , then the problem of computing the\nmaximal value of \u2206(S ) over all solutions S is an optimization problem for a problem in\nNP such that the optimal value can be represented using log n bits. Let Mopt be an oracle\nfor this problem, and consider a non-deterministic Turing machine M 00 with output tape\noperating on input P, M\u2206\u2264 (resp. M\u2206\u2265 ), and n. Initially, M 00 calls Mopt with P, M\u2206\u2264 (resp.\nM\u2206\u2265 ), and n as input to compute the value k for \u2206(S ) of an optimal solution S . Then, M 00\nproceeds like the nondeterministic Turing machine M in the proof of Theorem 1, additionally writing the guessed solution S to its output tape. Since the latter is accomplished\nin time polynomial in n, M 00 is in FNP//log and decides n MOST SIMILAR SOLUTIONS\n(respectively n MOST DIVERSE SOLUTIONS).\nHardness: We reduce the Traveling Salesman Problem (as, e.g., in (Papadimitriou 1994))\nto the problem of computing n MOST SIMILAR SOLUTIONS. Consider m cities 1, . . . , m,\nand a non-negative integer distance di,j between any two cities i and j . The task is to\ncompute a tour visiting all cities once (i.e., a Hamilton Cycle) of shortest length.\nFor a reduction, consider P = { pi,j \u2190 not npi,j ; npi,j \u2190 not pi,j ; rj \u2190 pi,j ;\n\u2190 not rj | i 6= j } \u222a {\u2190 pi,j , pk ,j ; \u2190 pi,j , pi,k | i 6= j , i 6= k , j 6= k }, where indices i , j ,\nand k range over 1, . . . , m. Every answer set s of P uniquely corresponds to a Hamilton\nCycle encoded by the atoms pi,j in s, and every permutation of the cities gives rise to\nexactly one answer set of P. This can easily be verified observing that the first two rules\nencode a nondeterministic guess of a set of atoms pi,j . The third and fourth rule are satisfied\niff 'every city is reached', i.e., if for every index j there exists an index i , such that pi,j is\n\n\f42\n\nEiter et. al.\n\ntrue. The last two rules are satisfied iff every city 'is reached from at most one different\ncity' and 'reaches at most one different city', i.e., iff for different indices i , j , and k , pi,j\nand pk ,j cannot both be true, as well as pi,j and pi,k cannot both be true.\nGiven this program, consider the n MOST SIMILAR SOLUTIONS problem, where n = 1,\nand for any set S of answer sets of P, the distance measure \u2206 is defined by \u2206(S ) =\n\u03a3s\u2208S \u03a3pi,j \u2208s di,j . Note that \u2206 is monotonic and thus computable in polynomial time in\nthe size of S . Moreover, S is a solution to this problem iff, by its definition, S contains\nexactly one answer set s of P, and iff \u2206(S ) is minimal among all sets of answer sets\nof P, thus in particular among elementary such sets. By the definition of \u2206, this implies\nthat S = {s} is a solution iff s encodes a Hamilton Cycle of minimal cost. This proves\nFPNP -hardness for the n MOST SIMILAR SOLUTIONS problem in general.\nFor a reduction of TSP to the problem of computing n MOST DIVERSE SOLUTIONS,\nconsider \u22060 (S ) = m \u00d7 maxd \u2212 \u2206(S ), where maxd is the maximum distance di,j given.\nAlso \u22060 is monotonic and computable in polynomial time, and by analogous arguments\nFPNP -hardness follows for the n MOST DIVERSE SOLUTIONS problem in the general\ncase.\nIf the value of \u2206(S ) is polynomial in the size of S , then FNP//log-hardness is obtained\nby a reduction of X -MinMod: Let P be the normal logic program in the proof of Theorem 1, and consider the n MOST SIMILAR SOLUTIONS problem, where n = 1, and \u2206(S )\nis given by the minimal (respectively maximal) partial Hamming distance on X between\nan answer set s \u2208 S and \u2205 (respectively X ). It is a straightforward consequence of the\ndefinition of \u2206, that if S = {s} is a solution to this n MOST SIMILAR SOLUTIONS problem (respectively to this n MOST DIVERSE SOLUTIONS problem), then s is an X -minimal\nmodel of \u03c6 (cf. also the proof of Theorem 3).\nProof of Theorem 5\nMembership: Consider a deterministic Turing machine M 0 , with output tape and an oracle\nfor NP-problems, which operates on input P, M\u2206\u2264 (resp. M\u2206\u2265 ), and S . Initially, M 0 prepares an integer k1 of n bits with the less significant half of bits set to 1 and the remaining\nbits set to 0. Then, M 0 successively uses its oracle operating as the nondeterministic Turing machine M in the proof of Theorem 2, starting with input P, M\u2206\u2264 (resp. M\u2206\u2265 ), S , and\nk1 , performing a binary search for an optimal k . After that, M 0 once more uses its oracle\nlike the nondeterministic Turing machine M in the proof of Theorem 2, but additionally\ncopying the answer set s guessed by the oracle to its output tape. Since the latter is accomplished in time polynomial in n, and since a polynomial number of calls to the oracle is\nsufficient to complete the binary search, M 0 is in FPNP and decides CLOSEST SOLUTION\n(respectively MOST DISTANT SOLUTIONS).\nIf the value of \u2206(S ) is polynomial in the size of a set S of n solutions, then the problem\nof computing the maximal value of \u2206(S \u222a {s}) for any solution S \u222a {s} is an optimization problem for a problem in NP such that the optimal value can be represented using\nlogarithmically many bits in the size of S \u222a {s}. Let Mopt be an oracle for this problem,\nand consider a non-deterministic Turing machine M 00 with output tape operating on input\nP, M\u2206\u2264 (resp. M\u2206\u2265 ), and S . Initially, M 00 calls Mopt with P, M\u2206\u2264 (resp. M\u2206\u2265 ), and S as\ninput to compute the value k for \u2206(S \u222a {s}) of an optimal solution S \u222a {s}. Then, M 00\nproceeds like the nondeterministic Turing machine M in the proof of Theorem 2, addition-\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n43\n\nally writing the guessed answer set s to its output tape. Since the latter is accomplished\nin time polynomial in the input, M 00 is in FNP//log and decides CLOSEST SOLUTION\n(respectively MOST DISTANT SOLUTIONS).\nHardness: The respective lower bounds are an immediate consequence of the problem\nreductions in the proof of the previous Theorem 4. Just observe that for given P and \u2206,\nthe solutions of an n MOST SIMILAR SOLUTIONS problem with input n = 1 coincide with\nthe solutions of the CLOSEST SOLUTION problem with input S = \u2205, (and the same holds\nfor the problem n MOST DIVERSE SOLUTIONS with input n = 1 and MOST DISTANT\nSOLUTION with input S = \u2205). It thus suffices to recall that the reductions mentioned above\nare reductions to problems with input n = 1.\nProof of Theorem 6\nMembership: Consider a non-deterministic Turing machine M , operating on input P, M\u2206\u2264 ,\nM\u2206\u2265 , a set S of answer sets of P, and k . Let n be the size of its input. First, M guesses\n0\nS 0 , such that |S 0 | is polynomial in n, as a set {s10 , . . . , sm\n} of interpretations over the\nalphabet of P, two integers k1 and k2 in binary representation of size at most polynomial\nin n, together with two potential witnesses w1 and w3 of M\u2206\u2264 and of length polynomial in\n|S | and |S 0 |, respectively, as well as two potential witnesses w2 and w4 of M\u2206\u2265 of length\npolynomial in |S | and |S 0 |, respectively. After that, M checks whether S 0 is different from\nS , as well as whether si0 is an answer set of P, for 1 \u2264 i \u2264 m. It rejects if any of these\ntests does not succeed. Otherwise, M proceeds by verifying that w1 is a witness of M\u2206\u2264\non input S and k1 , that w2 is a witness of M\u2206\u2265 on input S and k1 , as well as that w3 is\na witness of M\u2206\u2264 on input S 0 and k2 , and that w4 is a witness of M\u2206\u2265 on input S 0 and\nk2 . If either test fails M rejects, otherwise it checks whether |k1 \u2212 k2 | \u2264 k (respectively\n|k1 \u2212 k2 | \u2265 k ), and if so accepts, otherwise it rejects. Note that due to our assumptions\nthat the size of S 0 to consider is polynomial in n, and that the value of \u2206(S ), respectively\n\u2206(S 0 ) is bounded by an exponential in the size of S , respectively in the size of S 0 , the\nguess of M , which is polynomial in n, is sufficient for deciding the problem. Moreover, the\nsubsequent computation of M , i.e., the tests carried out, can be accomplished in polynomial\ntime. Therefore, M is a non-deterministic Turing machine which decides k - CLOSE SET\n(respectively k - DISTANT SET) in polynomial time, which proves NP-membership for these\nproblems.\nHardness: Consider the normal logic program given in the proof of Theorem 1, and the\nk - CLOSE SET problem, where S = \u2205, k = 0, and for any set S 0 of answer sets of P,\nthe distance measure \u2206 is defined by \u2206(S 0 ) = 0. Note that \u2206 is normal and computable\nin constant time. Then, there exists a solution to the problem iff there exists a set S 0 of\nanswer sets of P such that S 0 6= \u2205, i.e., P has an answer set, which proves NP-hardness of\nthe k - CLOSE SET problem. Similarly, the k - DISTANT SET problem, where S = \u2205, k = 0,\nand \u2206(S 0 ) = 0, has a solution iff P has an answer set. Again the arguments hold for any\nnormal \u2206, which proves the claim.\nProof of Proposition 1\n\u0001\nnodal distance computations\nIn order to compute Dn (P1 , P2 ), we need to perform |L|\n2\nwhere |L| is the number of leaves. The nodal distance NDP (x , y) between leaves x and y\n\n\f44\n\nEiter et. al.\n\nin a phylogeny P can be computed as\nNDP (x , y) = depthP (x ) + depthP (y) \u2212 2 \u00d7 depthP (lcaP (x , y)),\nwhere lcaP (x , y) is the lowest common ancestor of x and y in P . Note that, if depthP (v )\nfor all vertices v in P is given (which is computable in O(|L|) time, as P is a binary tree),\nthe computation of NDP (x , y) takes constant time if lcaP (x , y) is known. Then, computing NDP (x , y) for all leaves x , y in P is possible in O(|L|2 ) time. In a standard post-order\ntraversal of P , a called node v always fulfills v = lcaP (x , y) for any vertices x , y that\noccur in different subtrees rooted at children of v . Thus, if each call returns all leaves of P\nreached from v (which has overall cost O(|L|)), we can calculate in the traversal ND(x , y)\nfor all leaves x , y of P in the setting above. In total, the time to compute NDP1 (x , y)\nand NDP2 (x , y), for all x , y \u2208 L, is 2\u00d7O(|L|) + O(|L|2 ) = O(|L|2 ). Therefore, in total\nDn (P1 , P2 ) is computable in O(|L|2 ) time.\nProof of Proposition 2\nLet v be the number of vertices in one tree, then v 2 is an upper bound for the number\nof the pairs that we can compare their descendants. Therefore, we have at most O(v 2 )\ncomparisons.\nSince the number of descendants is bounded by |L| (after obtaining the descendants of\neach vertex by preprocessing in O(v *|L|) time), each comparison takes time O(|L|).\nSince v = 2 \u00d7 |L| \u2212 1, Dl (P1 , P2 ) can be computed in (2 \u00d7 |L| \u2212 1)2 \u00d7 |L| steps which\nis O(|L|3 ).\nProof of Proposition 3\nLet Sp0 be a set of all completions of the partial phylogeny Pp . For every P \u2208 Sp0 , we need\nto prove that\nLB n (Pp , Pc ) \u2264 Dn (P , Pc )\nholds.\nLet Pl \u2208 arg minP\u2208Sp0 (Dn (P , Pc )) be a completion with smallest distance. Then it will\nbe enough to prove that\nLB n (Pp , Pc ) \u2264 Dn (Pl , Pc )\nholds. If we replace LB n and Dn with their equivalents, the inequality will look like the\nfollowing:\nX\nX\n|NDPc (x , y) \u2212 NDPp (x , y)| \u2264\n|NDPl (x , y) \u2212 NDPc (x , y)|\nx ,y\u2208Lp\n\nx ,y\u2208L\n\nWe can break the right hand side summation into two for Lp and L\\Lp as follows:\nP\n|NDPc (x , y) \u2212 NDPp (x , y)| \u2264\nPx ,y\u2208Lp\nP\nx ,y\u2208Lp |NDPl (x , y) \u2212 NDPc (x , y)| +\n(x ,y)\u2208L2 \\L2p |NDPl (x , y) \u2212 NDPc (x , y)|\nThe distance between x and y is the same for Pp and Pl where x , y \u2208 Lp . Therefore, terms\ncancel each other and we have the following:\n0\u2264\n\nX\n(x ,y)\u2208L2 \\L2p\n\n|NDPl (x , y) \u2212 NDPc (x , y)|\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n45\n\nSince the right hand side is a summation of absolute values, the inequality holds which\ncompletes the proof.\nProof of Proposition 4\nLet Sp0 be a set of all completions of the partial phylogeny Pp . For every P \u2208 Sp0 , we need\nto prove that\nUB n (Pp , Pc ) \u2265 Dn (P , Pc )*\nLet Pu \u2208 arg maxp\u2208Sp0 (Dn (p, Pc )) be a completion at largest distance. Then it will be\nenough to prove that\nUB n (Pp , Pc ) \u2265 Dn (Pu , Pc )*\nIf we replace UB n and Dn with their definition, the inequality is\n\u0012 \u0013 \u0012\n\u0013\nX\nX\nl\n|Lp |\n|NDPc (x , y)\u2212NDPp (x , y)|+(\n\u2212\n)\u00d7l \u2265\n|NDPl (x , y)\u2212NDPc (x , y)|*\n2\n2\nx ,y\u2208Lp\n\nx ,y\u2208L\n\nWe can break the right hand side summation into two for Lp and L\\Lp as follows:\n\u0001\n\u0001\nP\nl\n|Lp |\n)\u00d7l \u2265\nx ,y\u2208Lp |NDPc (x , y) \u2212 NDPp (x , y)| + ( 2 \u2212\n2\nP\nP\nx ,y\u2208Lp |NDPu (x , y) \u2212 NDPc (x , y)| +\nx ,y\u2208L\\Lp |NDPu (x , y) \u2212 NDPc (x , y)|\nThe distance between x and y is same for Pp and Pu where x , y \u2208 Lp . Terms cancel each\nother:\n\u0013\n\u0012 \u0013 \u0012\nX\n|Lp |\nl\n\u2212\n)\u00d7l \u2265\n|NDPu (x , y) \u2212 NDPc (x , y)|*\n(\n2\n2\nx ,y\u2208L\\Lp\n\nThe maximum nodal distance in a tree is equal to the number of leaves; therefore,\neach\n\u0001\n\u0001\nterm in the right hand side of the inequality is at most l . Since, there are ( 2l \u2212 |L2p | )\n\u0001\n\u0001\nterms in the right hand side summation, ( 2l \u2212 |L2p | ) \u00d7 l is greater than or equal to the\nsummation.\nProof of Proposition 5\nTake any plan-completion X of the partial plan Pp . Consider two cases.\nCase 1: |X | \u2264 |Pc |. Our goal is to prove that\nLB h (Pp , Pc ) \u2264 Dh (X , Pc )*\nBy the definition of Dh , the distance between X and Pc is:\nDh (X , Pc ) = |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}| + |Pc | \u2212 |X |*\nSince X is a plan-completion of Pp and |X | \u2264 |Pc |, dom actPp \u2286 dom actPc ; then, by the\ndefinition of LB h :\nLB h (Pp , Pc ) = |{i | actPp (i ) 6= actPc (i ), i \u2208 dom actPp }|*\nSince X is a plan-completion of Pp ,\n{i | actPp (i ) 6= actPc (i ), i \u2208 dom actPp } \u2286 {i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}*\n\n\f46\n\nEiter et. al.\n\nHence,\nLB h (Pp , Pc ) \u2264 |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}| + |Pc | \u2212 |X | = Dh (X , Pc )*\nCase 2: |X | > |Pc |. Our goal is to prove that\nLB h (Pp , Pc ) \u2264 Dh (Pc , X )*\nBy the definition of Dh , the distance between X and Pc is:\nDh (Pc , X ) = |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |Pc |}| + |X | \u2212 |Pc |*\nBy the definition of LB h :\nLB h (Pp , Pc ) = |{i | actPp (i ) 6= actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}|+\n|{i | l \u2265 i > |Pc |, i \u2208 dom actPp }|*\nSince X is a plan-completion of Pp , actX extends actPp , and then\n{i | actPp (i ) 6= actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}\n\u2286 {i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}*\nSince |X | > |Pc |,\n|X |\u2212|Pc | > |{i | |X | \u2265 i > |Pc |, i \u2208 dom actPp }| = |{i | l \u2265 i > |Pc |, i \u2208 dom actPp }|*\nHence,\nLB h (Pp , Pc ) \u2264 |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}| + |X | \u2212 |Pc | = Dh (Pc , X )*\n\nProof of Proposition 6\nTake any plan-completion X of partial plan Pp . Consider two cases.\nCase 1: |X | \u2264 |Pc |. Our goal is to prove that\nUB h (Pp , Pc ) \u2265 Dh (X , Pc )\nwhere\nUB h (Pp , Pc ) = l \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp }|,\nDh (X , Pc ) = |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}| + |Pc | \u2212 |X |*\nSince |X | \u2264 |Pc | and X is a plan-completion of Pp , the set\n{i | actPp (i ) = actPc (i ), i \u2208 dom actPp }\ndoes not intersect with the set\nY = {i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |} \u222a {i | |X | < i \u2264 |Pc |}*\nThen\n{1, * * *, l } \\ {i | actPp (i ) = actPc (i ), i \u2208 dom actPp }\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\nis a superset of Y . Therefore,\nUB h (Pp , Pc ) = l \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp }|\n\u2265 |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |X |}| + |Pc | \u2212 |X |\n= Dh (X , Pc )*\nCase 2: |X | > |Pc |. Our goal is to prove that\nUB h (Pp , Pc ) \u2265 Dh (Pc , X )\nwhere\nUB h (Pp , Pc ) = l \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}|,\nDh (Pc , X ) = |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |Pc |}| + |X | \u2212 |Pc |*\nSince |X | > |Pc | and X is a plan-completion of Pp , the set\n{i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}\ndoes not intersect with the set\nY = {i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |Pc |} \u222a {i | |Pc | < i \u2264 |X |}*\nThen\n{1, * * *, l } \\ {i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}\nis a superset of Y . Therefore,\nUB h (Pp , Pc ) = l \u2212 |{i | actPp (i ) = actPc (i ), i \u2208 dom actPp , 1 \u2264 i \u2264 |Pc |}|\n\u2265 |{i | actX (i ) 6= actPc (i ), 1 \u2264 i \u2264 |Pc |}| + |X | \u2212 |Pc |\n= Dh (Pc , X )*\n\n47\n\n\f48\n\nEiter et. al.\nAppendix B ASP Formulations\n\nc{clique(X) : vertex(X)}c.\n:- clique(X), clique(Y), vertex(X), vertex(Y), X!=Y, not edge(X,Y),\nnot edge(Y,X).\n\nFig. B 1. ASP formulation of the c-clique problem (a clique of size c).\n\nsolution(1..n).\nc{clique(S,X) : vertex(X)}c :- solution(S).\n:- clique(S,X), clique(S,Y), not edge(X,Y), not edge(Y,X), X!=Y.\ndifferent(S1,S2) :- clique(S1,X), clique(S2,Y), S1 != S2, X != Y.\n:- not different(S1,S2), solution(S1;S2), S1!=S2.\n\nFig. B 2. ASP formulation that computes n distinct c-cliques.\n\nsame(S1,S2,V) :- clique(S1,V), clique(S2,V), solution(S1;S2),\nvertex(V), S1 < S2.\nhammingDistance(S1,S2,c-H) :- H{same(S1,S2,V): vertex(V)}H,\nsolution(S1;S2), maximumDistance(H), S1 < S2.\n\nFig. B 3. ASP formulation of the Hamming distance between two cliques.\n\n:- solution(S1;S2), hammingDistance(S1,S2,H), H > k,\nmaximumDistance(H).\n\nFig. B 4. A constraint that forces the distance among any two solution is less than or equal\nto k .\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n% generate a rooted binary tree\nvertex(0..2*k). root(2*k).\ninternal(X) :- vertex(X), not leaf(X).\n2 {edge(X,Y) : vertex(Y) : X > Y} 2 :- internal(X).\nreachable(X,Y) :- edge(X,Y), vertex(X;Y), X > Y.\nreachable(X,Y) :- edge(X,Z), reachable(Z,Y),\nX > Z, vertex(X;Y;Z).\n:- vertex(Y), not reachable(X,Y), root(X), Y != X.\n:- reachable(X,X), vertex(X).\nmaxY(X,Y) :- edge(X,Y), edge(X,Y1), Y > Y1,\nvertex(Y;Y1), internal(X).\n:- maxY(X,Y), maxY(X1,Y1), Y > Y1, X < X1,\nvertex(Y;Y1), internal(X;X1).\n\nFig. B 5. The phylogeny reconstruction program of Brooks et. al.: Part 1.\n\n49\n\n\f50\n\nEiter et. al.\n\n% ensure that the tree does not have more than x incompatible characters\ng0(X,I,S) :- f(X,I,S), informative_character(I),\nessential_state(I,S).\ng0(Y,I,S) :- g0(X,I,S), g0(X1,I,S), edge(Y,X), edge(Y,X1),\nX>X1, internal(Y), vertex(X;X1), informative_character(I),\nessential_state(I,S).\nmarked(X,I) :- g0(X,I,S), informative_character(I),\nvertex(X), essential_state(I,S).\ng(X,I,S) :- g0(X,I,S), informative_character(I),\nvertex(X), essential_state(I,S).\n{g(X,I,S): essential_state(I,S)} 1 :- internal(X),\nnot marked(X,I), informative_character(I).\n{root_is(X,I,S)} :- g(X,I,S), vertex(X),\ninformative_character(I), essential_state(I,S).\n:- root_is(X,I,S), root_is(Y,I,S),\nvertex(X;Y), X < Y, informative_character(I),\nessential_state(I,S).\n:- root_is(X,I,S), g(Y,I,S), reachable(Y,X), Y > X,\nvertex(X;Y), informative_character(I),\nessential_state(I,S).\nreachable_is(X,I,S) :- root_is(X,I,S),\nvertex(X), informative_character(I), essential_state(I,S).\nreachable_is(X,I,S) :- g(X,I,S), reachable_is(Z,I,S),\nedge(Z,X), Z > X, vertex(X;Z), informative_character(I),\nessential_state(I,S).\nincompatible(I) :- g(X,I,S), not reachable_is(X,I,S),\nvertex(X), informative_character(I), essential_state(I,S).\n:- n+1 {incompatible(I) : informative_character(I)}.\n\nFig. B 6. The phylogeny reconstruction program of Brooks et. al.: Part 2.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n51\n\n% generate n rooted trees\nsolution(1..n).\nvertex(0..2*k). root(2*k).\ninternal(X) :- vertex(X), not leaf(X).\n2 {edge(N,X,Y) : vertex(Y) : X > Y} 2 :- internal(X), solution(N).\nreachable(N,X,Y) :- edge(N,X,Y), vertex(X;Y), X > Y, solution(N).\nreachable(N,X,Y) :- edge(N,X,Z), reachable(N,Z,Y), solution(N),\nX > Z, vertex(X;Y;Z).\n:- vertex(Y), not reachable(N,X,Y), root(X), Y != X, solution(N).\n:- reachable(N,X,X), vertex(X), solution(N).\nmaxY(N,X,Y) :- edge(N,X,Y), edge(N,X,Y1), Y > Y1,\nvertex(Y;Y1), internal(X), solution(N).\n:- maxY(N,X,Y), maxY(N,X1,Y1), Y > Y1, X < X1,\nvertex(Y;Y1), internal(X;X1), solution(N).\n\nFig. B 7. A reformulation of the phylogeny reconstruction program of Brooks et. al. (Figures B 5 and B 6), to find n distinct phylogenies: Part 1.\n\n\f52\n\nEiter et. al.\n\n% ensure that no tree has more than x incompatible characters\ng0(N,X,I,S) :- f(X,I,S), informative_character(I),\nessential_state(I,S), solution(N).\ng0(N,Y,I,S) :- g0(N,X,I,S), g0(N,X1,I,S), edge(N,Y,X), edge(N,Y,X1),\nX>X1, internal(Y), vertex(X;X1), informative_character(I),\nessential_state(I,S), solution(N).\nmarked(N,X,I) :- g0(N,X,I,S), informative_character(I),\nvertex(X), essential_state(I,S), solution(N).\ng(N,X,I,S) :- g0(N,X,I,S), informative_character(I),\nvertex(X), essential_state(I,S), solution(N).\n{g(N,X,I,S): essential_state(I,S)} 1 :- internal(X),\nnot marked(N,X,I), informative_character(I), solution(N).\n{root_is(N,X,I,S)} :- g(N,X,I,S), vertex(X),\ninformative_character(I), essential_state(I,S), solution(N).\n:- root_is(N,X,I,S), root_is(N,Y,I,S),\nvertex(X;Y), X < Y, informative_character(I),\nessential_state(I,S), solution(N).\n:- root_is(N,X,I,S), g(N,Y,I,S), reachable(N,Y,X), Y > X,\nvertex(X;Y), informative_character(I), essential_state(I,S),\nsolution(N).\nreachable_is(N,X,I,S) :- root_is(N,X,I,S),\nvertex(X), informative_character(I), essential_state(I,S),\nsolution(N).\nreachable_is(N,X,I,S) :- g(N,X,I,S), reachable_is(N,Z,I,S),\nedge(N,Z,X), Z > X, vertex(X;Z), informative_character(I),\nessential_state(I,S), solution(N).\nincompatible(N,I) :- g(N,X,I,S), not reachable_is(N,X,I,S),\nvertex(X), informative_character(I), essential_state(I,S),\nsolution(N).\n:- x+1 {incompatible(N,I) : informative_character(I)}, solution(N).\n\nFig. B 8. A reformulation of the phylogeny reconstruction program of Brooks et. al. (Figures B 5 and B 6), to find n distinct phylogenies: Part 2.\n% make sure that these n trees are distinct\ndifferent(S1,S2) :- edge(S1,X1,Y), edge(S2,X2,Y),\nvertex(X2;X1;Y), solution(S1;S2), S1 != S2, X1 != X2.\n:- not different(S1,S2), solution(S1;S2), S1 != S2.\n\nFig. B 9. A reformulation of the phylogeny reconstruction program of Brooks et. al., to\nfind n distinct phylogenies: Part 3.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n53\n\ndist(0..m).\n% compute the nodal distances using distance_v.\n% nodaldistance(S,X,Y,T): the nodal distance between X and Y\n%\nin the S'th tree is T.\nnodaldistance(S,X,Y,T) :- tempnodaldistance(S,X,Y,T),\nnot notminnodal(S,X,Y,T), solution(S), leaf(X;Y), dist(T).\n% distance_v(S,X,Y,T): the distance between the vertex X and\n%\nits descendant Y is T in the S'th tree.\ndistance_v(S,X,Y,1) :- edge(S,X,Y), vertex(X;Y), solution(S).\ndistance_v(S,X,Z,T+1) :- distance_v(S,X,Y,T), edge(S,Y,Z),\nvertex(X;Y;Z), dist(T), solution(S).\n% length of a path between vertices X and Y\ntempnodaldistance(S,X,Y,T1+T2) :- distance_v(S,CA,X,T1),\ndistance_v(S,CA,Y,T2), X<Y, dist(T1;T2), leaf(X;Y),\nvertex(CA), solution(S).\nnotminnodal(S,X,Y,T1) :- tempnodaldistance(S,X,Y,T1),\ntempnodaldistance(S,X,Y,T2), T2 < T1, leaf(X;Y),\ndist(T1;T2), solution(S).\n% compute the differences of nodal distances of each pairs of\n%\nleaves in each pairs of trees.\ndiffnodal(P1,P2,X,Y,abs(D1-D2)) :- nodaldistance(P1,X,Y,D1),\nnodaldistance(P2,X,Y,D2), P2>P1, leaf(X;Y), dist(D1;D2),\nsolution(P1;P2).\n% compute the distance between each pairs of trees.\n% distance_t(P1,P2,T) : the distance between (trees) P1 and P2 is T.\ntempdistance(P1,P2,0,1,D) :- diffnodal(P1,P2,0,1,D),\nsolution(P1;P2), dist(D).\ntempdistance(P1,P2,L1,L2,D+K) :- tempdistance(P1,P2,L1,L2-1,D),\ndiffnodal(P1,P2,L1,L2,K), L2-L1 > 1, solution(P1;P2),\nleaf(L1;L2), dist(D;K).\ntempdistance(P1,P2,L1,L2,D+K) :- tempdistance(P1,P2,L1-1,k,D),\ndiffnodal(P1,P2,L1,L2,K), L2 = L1+1, L2 > 1, solution(P1;P2),\nleaf(L1;L2), dist(D;K).\ndistance_t(P1,P2,T) :- tempdistance(P1,P2,k-1,k,T), dist(T),\nsolution(P1;P2).\n\nFig. B 10. A formulation of the nodal distance function Dn in ASP.\n\n\f54\n\nEiter et. al.\n\ndist(0..m).\n% at each solution N, define reachability of leaf Y from X\nreachableN(N,X,Y) :- edge(N,X,Y), vertex(X), leaf(Y), X > Y,\nsolution(N).\nreachableN(N,X,Y) :- edge(N,X,Z), reachableN(N,Z,Y),\nsolution(N), X > Z, vertex(X;Z), leaf(Y).\n% at each solution S, assign depths to vertices Y\ndepth(S,2*k,0) :- solution(S).\ndepth(S,Y,T+1) :- depth(S,X,T), edge(S,X,Y),\nvertex(X;Y), depthRange(T), solution(S), T<r.\n% vertices V1 and v2 have different descendants\ndiff(N1,V1,N2,V2) :- solution(N1;N2), vertex(V1;V2), leaf(X),\nN1 < N2, reachableN(N1,V1,X), not reachableN(N2,V2,X).\ndiff(N1,V1,N2,V2) :- solution(N1;N2), vertex(V1;V2), leaf(X),\nN1 < N2, not reachableN(N1,V1,X), reachableN(N2,V2,X).\n% definition of the function f\nfN(N1,V1,N2,V2,1) :- diff(N1,V1,N2,V2), solution(N1;N2),\nvertex(V1;V2), N1 < N2.\nfN(N1,V1,N2,V2,0) :- not diff(N1,V1,N2,V2), solution(N1;N2),\nvertex(V1;V2), N1 < N2.\n% definition of the function g\ngN(0,N1,N2,0) :- solution(N1;N2), N1 < N2.\ngN(D+1,N1,N2,D1) :- gN(D,N1,N2,X), solution(N1;N2), N1 < N2,\ndepthRange(D;Y), dist(Z;D1;X), maxdepth2(N1,N2,Y), D<Y,\ndepthV2(N1,N2,D+1,2*k,Z), w(D+1,M), D1=X+M*Z.\n\nFig. B 11. An ASP formulation of the descendant distance function Dl for two phylogenies: Part 1\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n55\n\n% depthV2 computes the summation of f(x,y) over all x,y at the same depth\nsamedepth(N1,V1,N2,V2,D) :- depth(N1,V1,D), depth(N2,V2,D),\nvertex(V1;V2), solution(N1;N2), N1 < N2, depthRange(D).\ndepthV(N1,N2,D,W,0,Z) :- solution(N1;N2), N1 < N2, depthRange(D),\nvertex(W), samedepth(N1,W,N2,0,D), fN(N1,W,N2,0,Z), dist(Z).\ndepthV(N1,N2,D,W,0,0) :- solution(N1;N2), N1 < N2, depthRange(D),\nvertex(W), not samedepth(N1,W,N2,0,D).\ndepthV(N1,N2,D,W,X+1,Z+Z1) :- solution(N1;N2), N1 < N2,\ndepthRange(D), vertex(W), depthV(N1,N2,D,W,X,Z),\nsamedepth(N1,W,N2,X+1,D), fN(N1,W,N2,X+1,Z1), dist(Z;Z1),\nvertex(X), X<2*k.\ndepthV(N1,N2,D,W,X+1,Z) :- solution(N1;N2), N1 < N2, depthRange(D),\nvertex(W), depthV(N1,N2,D,W,X,Z),\nnot samedepth(N1,W,N2,X+1,D), dist(Z;Z1), vertex(X), X<2*k.\ndepthV2(N1,N2,D,0,Z) :- solution(N1;N2), N1 < N2, depthRange(D),\ndepthV(N1,N2,D,0,2*k,Z), dist(Z).\ndepthV2(N1,N2,D,X+1,Z+Z1) :- solution(N1;N2), N1 < N2,\ndepthRange(D), vertex(X), depthV2(N1,N2,D,X,Z),\ndepthV(N1,N2,D,X+1,2*k,Z1), dist(Z;Z1), X<2*k.\n% definition of the distance function D_n for two phylogenies\ndepth2(N1,N2,X) :- depth(N1,Y1,X), depth(N2,Y2,X),\nvertex(Y1;Y2), depthRange(X), solution(N1;N2), N1 < N2.\nmaxdepth2(N1,N2,X) :- depth2(N1,N2,X), not depth2(N1,N2,X+1),\ndepthRange(X), solution(N1;N2), N1 < N2.\ndistance_t(N1,N2,X) :- gN(D,N1,N2,X), solution(N1;N2), N1 < N2,\ndist(X), depthRange(D), maxdepth2(N1,N2,D).\n\nFig. B 12. An ASP formulation of the descendant distance function Dl for two phylogenies: Part 2\n% distance of a set of phylogenies\nnotmaxdistance_t(P1,P2,T1) :- distance_t(P1,P2,T1), distance_t(P3,P4,T2),\nT1 < T2, solution(P1;P2;P3;P4), dist(T1;T2).\ndelta(T1) :- distance_t(P1,P2,T1), not notmaxdistance_t(P1,P2,T1),\nsolution(P1;P2), dist(T1).\n% constraints on the distance function, for similarity\n:- delta(T), dist(T), T > k.\n\nFig. B 13. An ASP formulation of the distance function \u2206D for a set of phylogenies, and\nthe constraints for k -similarity.\n\n\f56\n\nEiter et. al.\n\n% effect of moving a block\non(B,L,T1) :- block(B), location(L), moveop(B,L,T), next(T,T1).\n% a block can be moved only when it's clear\n:- location(L), block(B), block(B1), time(T),\nmoveop(B,L,T), on(B1,B,T).\n% any two blocks cannot be on the same block at the same time\n:- 2{on(B1,B,T):block(B1)}, time(T), block(B).\n% wherever a block is, it's not anywhere else\nnon(B,L1,T) :- time(T), location(L1), location(L), block(B),\non(B,L,T), not eq(L,L1).\n% every block is supported by the table\nsupported(B,T) :- block(B), time(T), on(B,table,T).\nsupported(B,T) :- block(B), block(B1), time(T), on(B,B1,T),\nsupported(B1,T), not eq(B,B1).\n:- block(B), time(T), not supported(B,T).\n% no concurrency\n:- 2{moveop(B,L,T):block(B):location(L)},time(T).\n% inertia\non(B,L,T1) :- location(L), block(B), on(B,L,T), not non(B,L,T1),\nnext(T,T1).\n% initial values and actions are exogenous\n1{non(B,L,0),on(B,L,0)}1 :- block(B), location(L).\n:- non(B,L,T), on(B,L,T), block(B), location(L), time(T).\n{moveop(B,L,T)} :- block(B), location(L), time(T), T < lasttime.\n% auxiliary predicates\ntime(0..lasttime).\nnext(T,T+1) :- time(T), lt(T,lasttime).\nlocation(L) :- block(L).\nlocation(table).\ngoal :- time(T), goal(T).\n:- not goal.\n\nFig. B 14. Blocks world formulation.\n\n\fFinding Similar/Diverse Solutions in Answer Set Programming\n\n57\n\nsolution(1..n).\n% effect of moving a block\non(S,B,L,T1) :- block(B), location(L),\nmoveop(S,B,L,T), next(T,T1), solution(S).\n% a block can be moved only when it's clear\n:- location(L), block(B), block(B1), time(T),\nmoveop(S,B,L,T), on(S,B1,B,T), solution(S).\n% any two blocks cannot be on the same block at the same time\n:- 2{on(S,B1,B,T):block(B1)}, time(T), block(B), solution(S).\n% wherever a block is, it's not anywhere else\nnon(S,B,L1,T) :- time(T), location(L1), location(L), block(B),\non(S,B,L,T), not eq(L,L1), solution(S).\n% every block is supported by the table\nsupported(S,B,T) :- block(B), time(T), on(S,B,table,T), solution(S).\nsupported(S,B,T) :- block(B), block(B1), time(T), on(S,B,B1,T),\nsupported(S,B1,T), not eq(B,B1), solution(S).\n:- block(B), time(T), not supported(S,B,T), solution(S).\n% no concurrency\n:- 2{moveop(S,B,L,T):block(B):location(L)},time(T), solution(S).\n% inertia\non(S,B,L,T1) :- location(L), block(B), on(S,B,L,T),\nnot non(S,B,L,T1), next(T,T1), solution(S).\n% initial values and actions are exogenous\n1{non(S,B,L,0),on(S,B,L,0)}1 :- block(B), location(L), solution(S).\n:- non(S,B,L,T), on(S,B,L,T), block(B), location(L), time(T), solution(S).\n{moveop(S,B,L,T)} :- block(B), location(L), time(T), T < lasttime, solution(S).\n% auxiliary predicates\ntime(0..lasttime).\nnext(T,T+1) :- time(T), lt(T,lasttime).\nlocation(L) :- block(L).\nlocation(table).\ngoal(S) :- time(T), goal(S,T), solution(S).\n:- not goal(S), solution(S).\n% compute distinct plans\ndifferent(S1,S2) :- time(T), moveop(S1,X,Y,T), not moveop(S2,X,Y,T),\nsolution(S1;S2), block(X), location(Y), S1 < S2.\ndifferent(S1,S2) :- time(T), not moveop(S1,X,Y,T), moveop(S2,X,Y,T),\nsolution(S1;S2), block(X), location(Y), S1 < S2.\n:- not different(S1,S2), solution(S1;S2), S1 < S2.\n\nFig. B 15. A reformulation of the Blocks World program shown in Fig. B 14, to compute\nn distinct plans.\n\n\f58\n\nEiter et. al.\n\n% for every time step T, check that the T'th actions\n% of Plans P1 and P2 are different:\ndifferent(P1,P2,T) :- moveop(P1,X,Y,T), not moveop(P2,X,Y,T),\ntime(T), solution(P1;P2), block(X), location(Y), P1 < P2.\ndifferent(P1,P2,T) :- not moveop(P1,X,Y,T), moveop(P2,X,Y,T),\ntime(T), solution(P1;P2), block(X), location(Y), P1 < P2.\n% and define the hamming distance between two plans P1 and P2\n% in terms of these differences:\nhammingdistance(P1,P2,H) :- H{different(P1,P2,T): time(T)}H,\nsolution(P1;P2), distRange(H), P1 < P2.\n\nFig. B 16. An ASP formulation of the Hamming distance Dh for two plans.\nsomedistance(H) :- hammingdistance(P1,P2,H),\nsolution(P1;P2), distRange(H).\nnotmaxdistance(H1) :- somedistance(H1), somedistance(H2),\nH2 > H1, distRange(H1;H2).\ntotaldistance(H) :- not notmaxdistance(H),\ndistRange(H), somedistance(H).\n\nFig. B 17. An ASP formulation of the distance \u2206h for a set of plans.\n\n\f"}