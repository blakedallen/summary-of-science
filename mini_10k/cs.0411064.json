{"id": "http://arxiv.org/abs/cs/0411064v5", "guidislink": true, "updated": "2005-05-13T17:20:22Z", "updated_parsed": [2005, 5, 13, 17, 20, 22, 4, 133, 0], "published": "2004-11-17T22:07:46Z", "published_parsed": [2004, 11, 17, 22, 7, 46, 2, 322, 0], "title": "Lower-Stretch Spanning Trees", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0503016%2Ccs%2F0503067%2Ccs%2F0503021%2Ccs%2F0503089%2Ccs%2F0503006%2Ccs%2F0503092%2Ccs%2F0503080%2Ccs%2F0503070%2Ccs%2F0503062%2Ccs%2F0503047%2Ccs%2F0503042%2Ccs%2F0503012%2Ccs%2F0503061%2Ccs%2F0503082%2Ccs%2F0503049%2Ccs%2F0503054%2Ccs%2F0503004%2Ccs%2F0503078%2Ccs%2F0503029%2Ccs%2F0503063%2Ccs%2F0503030%2Ccs%2F0503071%2Ccs%2F0503013%2Ccs%2F0503060%2Ccs%2F0503041%2Ccs%2F0503048%2Ccs%2F0503068%2Ccs%2F0503015%2Ccs%2F0503066%2Ccs%2F0503032%2Ccs%2F0503007%2Ccs%2F0503036%2Ccs%2F0503039%2Ccs%2F0503001%2Ccs%2F0503079%2Ccs%2F0503023%2Ccs%2F0503005%2Ccs%2F0503076%2Ccs%2F0503073%2Ccs%2F0503022%2Ccs%2F0503020%2Ccs%2F0503069%2Ccs%2F0503072%2Ccs%2F0503044%2Ccs%2F0503081%2Ccs%2F0503003%2Ccs%2F0503028%2Ccs%2F0503056%2Ccs%2F0503019%2Ccs%2F0503055%2Ccs%2F0503058%2Ccs%2F0503074%2Ccs%2F0503024%2Ccs%2F0503064%2Ccs%2F0503031%2Ccs%2F0503083%2Ccs%2F0503026%2Ccs%2F0503040%2Ccs%2F0503084%2Ccs%2F0503087%2Ccs%2F0503090%2Ccs%2F0503014%2Ccs%2F0503075%2Ccs%2F0503010%2Ccs%2F0503018%2Ccs%2F0503065%2Ccs%2F0503050%2Ccs%2F0503046%2Ccs%2F0503008%2Ccs%2F0503038%2Ccs%2F0503057%2Ccs%2F0503052%2Ccs%2F0503037%2Ccs%2F0503085%2Ccs%2F0503033%2Ccs%2F0503043%2Ccs%2F0503053%2Ccs%2F0503091%2Ccs%2F0503002%2Ccs%2F0503086%2Ccs%2F0503045%2Ccs%2F0503025%2Ccs%2F0503077%2Ccs%2F0411080%2Ccs%2F0411008%2Ccs%2F0411020%2Ccs%2F0411071%2Ccs%2F0411045%2Ccs%2F0411063%2Ccs%2F0411049%2Ccs%2F0411046%2Ccs%2F0411004%2Ccs%2F0411068%2Ccs%2F0411089%2Ccs%2F0411037%2Ccs%2F0411024%2Ccs%2F0411064%2Ccs%2F0411026%2Ccs%2F0411054%2Ccs%2F0411013%2Ccs%2F0411044&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Lower-Stretch Spanning Trees"}, "summary": "We prove that every weighted graph contains a spanning tree subgraph of\naverage stretch O((log n log log n)^2). Moreover, we show how to construct such\na tree in time O(m log^2 n).", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0503016%2Ccs%2F0503067%2Ccs%2F0503021%2Ccs%2F0503089%2Ccs%2F0503006%2Ccs%2F0503092%2Ccs%2F0503080%2Ccs%2F0503070%2Ccs%2F0503062%2Ccs%2F0503047%2Ccs%2F0503042%2Ccs%2F0503012%2Ccs%2F0503061%2Ccs%2F0503082%2Ccs%2F0503049%2Ccs%2F0503054%2Ccs%2F0503004%2Ccs%2F0503078%2Ccs%2F0503029%2Ccs%2F0503063%2Ccs%2F0503030%2Ccs%2F0503071%2Ccs%2F0503013%2Ccs%2F0503060%2Ccs%2F0503041%2Ccs%2F0503048%2Ccs%2F0503068%2Ccs%2F0503015%2Ccs%2F0503066%2Ccs%2F0503032%2Ccs%2F0503007%2Ccs%2F0503036%2Ccs%2F0503039%2Ccs%2F0503001%2Ccs%2F0503079%2Ccs%2F0503023%2Ccs%2F0503005%2Ccs%2F0503076%2Ccs%2F0503073%2Ccs%2F0503022%2Ccs%2F0503020%2Ccs%2F0503069%2Ccs%2F0503072%2Ccs%2F0503044%2Ccs%2F0503081%2Ccs%2F0503003%2Ccs%2F0503028%2Ccs%2F0503056%2Ccs%2F0503019%2Ccs%2F0503055%2Ccs%2F0503058%2Ccs%2F0503074%2Ccs%2F0503024%2Ccs%2F0503064%2Ccs%2F0503031%2Ccs%2F0503083%2Ccs%2F0503026%2Ccs%2F0503040%2Ccs%2F0503084%2Ccs%2F0503087%2Ccs%2F0503090%2Ccs%2F0503014%2Ccs%2F0503075%2Ccs%2F0503010%2Ccs%2F0503018%2Ccs%2F0503065%2Ccs%2F0503050%2Ccs%2F0503046%2Ccs%2F0503008%2Ccs%2F0503038%2Ccs%2F0503057%2Ccs%2F0503052%2Ccs%2F0503037%2Ccs%2F0503085%2Ccs%2F0503033%2Ccs%2F0503043%2Ccs%2F0503053%2Ccs%2F0503091%2Ccs%2F0503002%2Ccs%2F0503086%2Ccs%2F0503045%2Ccs%2F0503025%2Ccs%2F0503077%2Ccs%2F0411080%2Ccs%2F0411008%2Ccs%2F0411020%2Ccs%2F0411071%2Ccs%2F0411045%2Ccs%2F0411063%2Ccs%2F0411049%2Ccs%2F0411046%2Ccs%2F0411004%2Ccs%2F0411068%2Ccs%2F0411089%2Ccs%2F0411037%2Ccs%2F0411024%2Ccs%2F0411064%2Ccs%2F0411026%2Ccs%2F0411054%2Ccs%2F0411013%2Ccs%2F0411044&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We prove that every weighted graph contains a spanning tree subgraph of\naverage stretch O((log n log log n)^2). Moreover, we show how to construct such\na tree in time O(m log^2 n)."}, "authors": ["Michael Elkin", "Yuval Emek", "Daniel A. Spielman", "Shang-Hua Teng"], "author_detail": {"name": "Shang-Hua Teng"}, "author": "Shang-Hua Teng", "links": [{"href": "http://arxiv.org/abs/cs/0411064v5", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0411064v5", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.DM", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.2.2; G.2.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0411064v5", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0411064v5", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "arXiv:cs/0411064v5 [cs.DS] 13 May 2005\n\nLower-Stretch Spanning Trees\nMichael Elkin\u2217\nDepartment of Computer Science\nBen-Gurion University of the Negev\n\nYuval Emek\nDepartment of Computer Science\nand Applied Mathematics\nWeizmann Institute of Science\n\nDaniel A. Spielman\u2020\nDepartment of Mathematics\nMassachusetts Institute of Technology\n\nShang-Hua Teng\u2021\nDepartment of Computer Science\nBoston University and\nAkamai Technologies Inc.\n\nAbstract\nWe show that every weighted connected graph G contains as a subgraph a spanning tree\ninto which the edges of G can be embedded with average stretch O(log2 n log log n). Moreover,\nwe show that this tree can be constructed in time O(m log n + n log2 n) in general, and in time\nO(m log n) if the input graph is unweighted. The main ingredient in our construction is a novel\ngraph decomposition technique.\nOur new algorithm can be immediately used to improve the running time of the recent solver\nfor symmetric diagonally dominant linear systems of Spielman and Teng from\nm2(O(\n\n\u221a\nlog n log log n))\n\nto m logO(1) n,\n\nand to O(n log2 n log log n) when the system is planar. Our result can also be used to improve\nseveral earlier approximation algorithms that use low-stretch spanning trees.\n\nCategories and Subject Descriptors: F.2 [Theory of Computation]: Analysis of Algorithms\nand Problem Complexity\nGeneral Terms: Algorithms, Theory.\nKeywords: Low-distortion embeddings, probabilistic tree metrics, low-stretch spanning trees.\n\n1\n\nIntroduction\n\nLet G = (V, E, w) be a weighted connected graph, where w is a function from E into the positive\nreals. We define the length of each edge e \u2208 E to be the reciprocal of its weight:\nd(e) = 1/w(e).\n\u2217\n\nPart of this work was done in Yale University, and was supported by the DoD University Research Initiative\n(URI) administered by the Office of Naval Research under Grant N00014-01-1-0795. The work was also partially\nsupported by the Lynn and William Frankel Center for Computer Sciences.\n\u2020\nPartially supported by NSF grant CCR-0324914. Part of this work was done at Yale University.\n\u2021\nPartially supported by NSF grants CCR-0311430 and ITR CCR-0325630.\n\n1\n\n\fGiven a spanning tree T of V , we define the distance in T between a pair of vertices u, v \u2208 V ,\ndistT (u, v), to be the sum of the lengths of the edges on the unique path in T between u and v.\nWe can then define the stretch1 of an edge (u, v) \u2208 E to be\nstretchT (u, v) =\n\ndistT (u, v)\n,\nd(u, v)\n\nand the average stretch over all edges of E to be\nave-stretch T (E) =\n\n1 X\nstretchT (u, v).\n|E|\n(u,v)\u2208E\n\nAlon, Karp, Peleg and West [1] proved that every weighted connected graph G = (V, E, w) of\nn vertices and m edges contains a spanning tree T such that\n\u0011\n\u0010 p\nave-stretch T (E) = exp O( log n log log n) ,\n\nand that there exists a collection \u03c4 = {T1 , . . . , Th } of spanning trees of G and a probability distribution \u03a0 over \u03c4 such that for every edge e \u2208 E,\n\u0010 p\n\u0011\nET \u2190\u03a0 [stretchT (e)] = exp O( log n log log n) .\n\nThe class of weighted graphs considered in this paper includes multi-graphs that may contain\nweighted self-loops and multiple weighted-edges between a pair of vertices. The consideration of\nmulti-graphs is essential for several results (including some in [1]).\nThe result of [1] triggered the study of low-distortion embeddings into probabilistic tree metrics.\nMost notable in this context is the work of Bartal [5, 6] which shows that if the requirement that\nthe trees T be subgraphs of G is abandoned, then the upper bound of [1] can be improved by\nfinding a tree whose distances approximate those in the original graph with average distortion\nO(log n * log log n). On the negative side, a lower bound of \u03a9(log n) is known for both scenarios\n[1, 5]. The gap left by Bartal was recently closed by Fakcharoenphol, Rao, and Talwar [11], who\nhave shown a tight upper bound of O(log n).\nHowever, some applications of graph-metric-approximation require trees that are subgraphs.\nUntil now, no progress had been made on reducing the gap between the upper and lower bounds\nproved in [1] on the average stretch of subgraph spanning trees. The bound achieved in [1] for general\nweighted graphs had been the best bound known for unweighted graphs, even for unweighted planar\ngraphs.\n2\nIn this\nnarrow this gap by improving the upper bound of [1] from\n\u221a paper , we significantly\n2\nexp(O( log n log log n)) to O(log n log log n). Specifically, we give an algorithm that for every weighted connected graph G = (V, E, w), constructs a spanning tree T \u2286 E that satisfies\nave-stretch T (E) = O(log2 n log log n). The running time of our algorithm is O(m log n + n log2 n)\nfor weighted graphs, and O(m log n) for unweighted. Note that the input graph need not be simple\n1\n\nOur definition of the stretch differs slightly from that used in [1]: distT (u, v)/distG (u, v), where distG (y, v) is the\nlength of the shortest-path between u and v. See Subsection 1.1 for a discussion of the difference.\n2\nIn the submitted version of this paper, we proved the weaker bound on average stretch of O((log n log log n)2 ).\nThe improvement in this paper comes from re-arranging the arithmetic in our analysis. Bartal [7] has obtained a\nsimilar improvement by other means.\n\n2\n\n\f\u0001\nand its number of edges m can be much larger than n2 . However, as proved in [1], it is enough to\nconsider graphs with at most n(n + 1) edges.\nWe begin by presenting a simpler algorithm that guarantees a weaker bound, ave-stretch T (E) =\nO(log3 n). As a consequence of the result in [1] that the existence of a spanning tree with average stretch f (n) for every weighted graph implies the existence of a distribution of spanning trees\nin which every edge has expected stretch f (n), our result implies that for every weighted connected graph G = (V, E, w) there exists a probability distribution \u03a0 over a set \u03c4 = {T1 , . . . , Th }\nof spanning trees (T \u2286 E for every T \u2208 \u03c4 ) such that for every e \u2208 E, ET \u2190\u03a0 [stretchT (e)] =\nO(log2 n log log n). Furthermore, our algorithm itself can be adapted to produce a probability distribution \u03a0 that guarantees a slightly weaker bound of O(log3 n) in time O(m * log2 n). So far, we\nhave not yet been able to verify whether our algorithm can be adapted to produce the bound of\nO(log2 n * log log n) within similar time limits.\n\n1.1\n\nApplications\n\nFor some of the applications listed below it is essential to define the stretch of an edge (u, v) \u2208 E\nas in [1], namely, stretchT (u, v) = distT (u, v)/distG (u, v). The algorithms presented in this paper\ncan be adapted to handle this alternative definition for stretch simply by assigning new weight\nw\u2032 (u, v) = 1/distG (u, v) to every edge (u, v) \u2208 E (the lengths of the edges remain unchanged).\nObserve that the new weights can be computed in a preprocessing stage independently of the\nalgorithms themselves, but the time required for this computation may dominant the running time\nof the algorithms.\n1.1.1\n\nSolving Linear Systems\n\nBoman and Hendrickson [8] were the first to realize that low-stretch spanning trees could be used\nto solve symmetric diagonally dominant linear systems. They applied the spanning trees of [1] to\ndesign solvers that run in time\n\u221a\n\nm3/2 2O(\n\nlog n log log n)\n\nlog(1/\u01eb),\n\nwhere \u01eb is the precision of the solution. Spielman and Teng [21] improved their results to\n\u221a\n\nm2O(\n\nlog n log log n)\n\nlog(1/\u01eb).\n\nUnfortunately, the trees produced by the algorithms of Bartal [5, 6] and Fakcharoenphol, Rao,\nand Talwar [11] cannot be used to improve these linear solvers, and it is currently not known\nwhether it is possible to solve linear systems efficiently using trees that are not subgraphs.\nBy applying the low-stretch spanning trees developed in this paper, we can reduce the time for\nsolving these linear systems to\nm logO(1) n log(1/\u01eb),\nand to O(n log2 n log log n log(1/\u01eb)) when the systems are planar. Applying a recent reduction of\nBoman, Hendrickson and Vavasis [9], one obtains a O(n log2 n log log n log(1/\u01eb)) time algorithm\nfor solving the linear systems that arise when applying the finite element method to solve twodimensional elliptic partial differential equations.\n\n3\n\n\f1.1.2\n\nAlon-Karp-Peleg-West Game\n\nAlon, Karp, Peleg and West [1] constructed low-stretch spanning trees to upper-bound the value of\na zero-sum two-player game that arose in their analysis of an algorithm for the k-server problem:\nat each turn, the tree player chooses a spanning tree T and the edge player chooses an edge e \u2208 E,\nsimultaneously. The payoff to the edge player is 0 if e \u2208 T and stretchT (e) + 1 otherwise. They\nshowed that if every n-vertex weighted connected graph G has a spanning tree T of average stretch\nf (n), then the value of this game is at most f (n)\u221a+ 1. Our new\u0001result lowers the bound\n\u0001 on the\nvalue of this graph-theoretical game from exp O( log n log log n) to O log2 n log log n .\n1.1.3\n\nMCT Approximation\n\nOur result can be used to improve drastically the upper bound on the approximability of the minimum communication cost spanning tree (henceforth, MCT ) problem. This problem was introduced\nin [14], and is listed as [ND7] in [12] and [10].\nThe instance of this problem is a weighted graph G = (V, E, w), and a matrix {r(u, v) | u, v \u2208 V }\nof\nnonnegative\nrequirements. The goal is to construct a spanning tree T that minimizes c(T ) =\nP\nu,v\u2208V r(u, v) * distT (u, v).\n\u221a\n\nPeleg and Reshef [19] developed a 2O( log n*log log n) approximation algorithm for the MCT problem on metrics using the result of [1]. A similar approximation ratio can be achieved for arbitrary\ngraphs. Therefore our result can be used to produce an efficient O(log2 n log log n) approximation\nalgorithm for the MCT problem on arbitrary graphs.\n1.1.4\n\nMessage-Passing Model\n\nEmbeddings into probabilistic tree metrics have been extremely useful in the context of approximation algorithms (to mention a few: buy-at-bulk network design [3], graph Steiner problem [13],\ncovering Steiner problem [15]). However, it is not clear that these algorithms can be implemented\nin the message-passing model of distributed computing (see [18]). In this model, every vertex of\nthe input graph hosts a processor, and the processors communicate over the edges of the graph.\nConsequently, in this model executing an algorithm that starts by constructing a non-subgraph\nspanning tree of the network, and then solves a problem whose instance is this tree is very problematic, since direct communication over the links of this \"virtual\" tree is impossible. This difficulty\ndisappears if the tree in this scheme is a subgraph of the graph. We believe that our result will\nenable the adaptation of the these approximation algorithms to the message-passing model.\n\n1.2\n\nOur Techniques\n\nWe build our low-stretch spanning trees by recursively applying a new graph decomposition that\nwe call a star-decomposition. A star-decomposition of a graph is a partition of the vertices into sets\nthat are connected into a star: a central set is connected to each other set by a single edge (see\nFigure 1). We show how to find star-decompositions that do not cut too many short edges and\nsuch that the radius of the graph induced by the star decomposition is not much larger than the\nradius of the original graph.\nOur algorithm for finding a low-cost star-decomposition applies a generalization of the ballgrowing technique of Awerbuch [4] to grow cones, where the cone at a vertex x induced by a set of\n\n4\n\n\fvertices S is the set of vertices whose shortest path to S goes through x.\n\n1.3\n\nThe Structure of the Paper\n\nIn Section 2, we define our notation. In Section 3, we introduce the star decomposition of a weighted\nconnected graph. We then show how to use this decomposition to construct a subgraph spanning\ntree with average stretch O(log3 n). In Section 4, we present our star decomposition algorithm.\n\u0001\nIn Section 5, we refine our construction and improve the average stretch to O log2 n log log n .\nFinally, we conclude the paper in Section 6 and list some open questions.\n\n2\n\nPreliminaries\n\nThroughout the paper, we assume that the input graph is a weighted connected multi-graph G =\n(V, E, w), where w is a weight function from E to the positive reals. Unless stated otherwise, we\nlet n and m denote the number of vertices and the number of edges in the graph, respectively. The\nlength of an edge e \u2208 E is defined as the reciprocal of its weight, denoted by d(e) = 1/w(e).\nFor two vertices u, v \u2208 V , we define dist(u, v) to be the length of the shortest path between u and\nv in E. We write distG (u, v) to emphasize that the distance is in the graph G.\nFor a set of vertices, S \u2286 V , G(S) is the subgraph induced by vertices in S. We write distS (u, v)\ninstead of distG(S) (u, v) when G is understood. E(S) is the set of edges with both endpoints in S.\nFor S, T \u2286 V , E(S, T ) is the set of edges with one endpoint in S and the other in T .\nThe boundary of a set S, denoted \u2202 (S), is the set of edges with exactly one endpoint in S.\nFor a vertex x \u2208 V , distG (x, S) is the length of the shortest path between x and a vertex in S.\nS\nA multiway partition of V is a collection of pairwise-disjoint sets {V1 , . . . , Vk } such that i Vi = V .\nThe boundary of a multiway partition, denoted \u2202 (V1 , . . . , Vk ), is the set of edges with endpoints in\ndifferent sets in the partition.\nThe volume of a set F of edges, denoted vol (F ), is the size of the set |F |.\nThe cost of a set F of edges, denoted cost (F ), is the sum of the weights of the edges in F .\nThe volume of a set S of vertices, denoted vol (S), is the number of edges with at least one endpoint\nin S.\nThe ball of radius r around a vertex v, denoted B(r, v), is the set of vertices of distance at most r\nfrom v.\nThe ball shell of radius r around a vertex v, denoted BS(r, v), is the set of vertices right outside\nB(r, v), that is, BS(r, v) consists of every vertex u \u2208 V \u2212 B(r, v) with a neighbor w \u2208 B(r, v) such\nthat dist(v, u) = dist(v, w) + d(u, w).\nFor v \u2208 V , radG (v) is the smallest r such that every vertex of G is within distance r from v. For\na set of vertices S \u2286 V , we write radS (v) instead of radG(S) (v) when G is understood.\n5\n\n\fSpanning-Trees of O(log3 n) Stretch\n\n3\n\nWe present our first algorithm that generates a spanning tree with average stretch O(log3 n). We\nfirst state the properties of the graph decomposition algorithm at the heart of our construction.\nWe then present the construction and analysis of the low-stretch spanning trees. We defer the\ndescription of the graph decomposition algorithm and its analysis to Section 4.\n\n3.1\n\nLow-Cost Star-Decomposition\n\nDefinition 3.1 (Star-Decomposition). A multiway partition {V0 , . . . , Vk } is a star-decomposition\nof a weighted connected graph G with center x0 \u2208 V (see Figure 1) if x0 \u2208 V0 and\n1. for all 0 \u2264 i \u2264 k, the subgraph induced on Vi is connected, and\n2. for all i \u2265 1, Vi contains an anchor vertex xi that is connected to a vertex yi \u2208 V0 by an edge\n(xi , yi ) \u2208 E. We call the edge (xi , yi ) the bridge between V0 and Vi .\nLet r = radG (x0 ), and ri = radVi (xi ) for each 0 \u2264 i \u2264 k. For \u03b4, \u01eb \u2264 1/2, a star-decomposition\n{V0 , . . . , Vk } is a (\u03b4, \u01eb)-star-decomposition if\na. \u03b4r \u2264 r0 \u2264 (1 \u2212 \u03b4)r, and\nb. r0 + d(xi , yi ) + ri \u2264 (1 + \u01eb)r, for each i \u2265 1.\nThe cost of the star-decomposition is cost (\u2202 (V0 , . . . , Vk )).\n\nx\n\n1\n\nxk\ny\n\nk\n\ny\n\nx\n\n2\n\n1\n\nV0\n\ny\n\n2\n\nx0\n\nFigure 1: Star Decomposition.\nNote that if {V0 , . . . , Vk } is a (\u03b4, \u01eb) star-decomposition of G, then the graph consisting of the\nunion of the induced subgraphs on V0 , . . . , Vk and the bridge edges (yk , xk ) has radius at most\n(1 + \u01eb) times the radius of the original graph.\nIn Section 4, we present an algorithm StarDecomp that satisfies the following cost guarantee.\nLet x = (x1 , . . . , xk ) and y = (y1 , . . . , yk ).\nLemma 3.2 (Low-Cost Star Decomposition). Let G = (V, E, w) be a connected weighted graph\nand let x0 be a vertex in V . Then for every positive \u01eb \u2264 1/2,\n({V0 , . . . , Vk } , x , y ) = starDecomp(G, x0 , 1/3, \u01eb) ,\n6\n\n\fin time O(m + n log n), returns a (1/3, \u01eb)-star-decomposition of G with center x0 of cost\ncost (\u2202 (V0 , . . . , Vk )) \u2264\n\n6 m log2 (m + 1)\n.\n\u01eb * radG (x0 )\n\nOn unweighted graphs, the running time is O(m).\n\n3.2\n\nA Divide-and-Conquer Algorithm\n\nThe basic idea of our algorithm is to use low-cost star-decomposition in a divide-and-conquer\n(recursive) algorithm to construct a spanning tree. We use n\nb (respectively, m)\nb rather than n (resp.,\nm) to distinguish the number of vertices (resp., number of edges) in the original graph, input to\nthe first recursive invocation, from that of the graph input to the current one.\nBefore invoking our algorithm we apply a linear-time transformation from [1] that transforms\nthe graph into one with at most n\nb(b\nn + 1) edges (recall that a multi-graph of n\nb vertices may have an\narbitrary number of edges), and such that the average-stretch of the spanning tree on the original\ngraph will be at most twice the average-stretch on this graph.\nWe begin by showing how to construct low-stretch spanning trees in the case that all edges\nhave length 1. In particular, we use the fact that in this case the cost of a set of edges equals the\nnumber of edges in the set.\nFix \u03b1 = (2 log4/3 (b\nn + 6))\u22121 .\nT = UnweightedLowStretchTree(G, x0 ).\n0. If |V | \u2264 2, return G. (If G contains multiple edges, return a single copy.)\n\n1. Set \u03c1 = radG (x0 ).\n\n2. ({V0 , . . . , Vk } , x , y ) = StarDecomp(G, x0 , 1/3, \u03b1)\n3. For 0 \u2264 i \u2264 k,\nset Ti = UnweightedLowStretchTree(G(Vi ), xi )\nS\nS\n4. Set T = i Ti \u222a i (yi , xi ).\n\nTheorem 3.3 (Unweighted). Let G = (V, E) be an unweighted connected graph and let x0 be a\nvertex in V . Then\nT = UnweightedLowStretchTree(G, x0 ) ,\nin time O(m\nb log n\nb), returns a spanning tree of G satisfying\n\u221a\nradT (x0 ) \u2264 e * radG (x0 )\n\n(1)\n\nand\nave-stretchT (E) \u2264 O(log3 m)\nb .\n\n(2)\n\nProof. For our analysis, we define a family of graphs that converges to T . For a graph G, we let\n({V0 , . . . , Vk } , x , y ) = StarDecomp(G, x0 , 1/3, \u03b1)\n7\n\n\fand recursively define\nR0 (G) = G and\n\nRt (G) =\n\n[\n[\n(yi , xi ) \u222a Rt\u22121 (G(Vi )) .\ni\n\ni\n\nThe graph Rt (G) is what one would obtain if we forced UnweightedLowStretchTree to return its\ninput graph after t levels of recursion.\nBecause for all n\nb \u2265 0, (2 log4/3 (b\nn + 6))\u22121 \u2264 1/12, we have (2/3 + \u03b1) \u2264 3/4. Thus, the depth\nof the recursion in UnweightedLowStretchTree is at most log4/3 n\nb, and we have Rlog4/3 nb (G) = T .\nOne can prove by induction that, for every t \u2265 0,\nradRt (G) (x0 ) \u2264 (1 + \u03b1)t radG (x0 ) .\n\nThe claim in (1) now follows from (1 + \u03b1)log4/3 nb \u2264\nX\nX\nstretchT (u, v) \u2264\n(u,v)\u2208\u2202(V0 ,...,Vk )\n\n\u221a\n\ne. To prove the claim in (2), we note that\n\n(u,v)\u2208\u2202(V0 ,...,Vk )\n\n\u2264\n\nX\n\n(u,v)\u2208\u2202(V0 ,...,Vk )\n\n(distT (x0 , u) + distT (x0 , v))\n\n(3)\n\n\u221a\n2 e * radG (x0 ) , by (1)\n\n(4)\n\n\u221a\n\u2264 2 e * radG (x0 )\n\n\u0012\n\nb + 1)\n6 m log2 (m\n\u03b1 * radG (x0 )\n\n\u0013\n\n, by Lemma 3.2.\n\nApplying this inequality to all graphs at all log4/3 n\nb levels of the recursion, we obtain\nX\n\n(u,v)\u2208E\n\nstretchT (u, v) \u2264 24\n\n\u221a\n\nem\nb log2 m\nb log4/3 n\nb log4/3 (b\nn + 6) = O(m\nb log3 m)\nb .\n\nWe now extend our algorithm and proof to general weighted connected graphs. We begin\nby pointing out a subtle difference between general and unit-weight graphs. In our analysis of\nUnweightedLowStretchTree, we used the facts that radG (x0 ) \u2264 n and that each edge length is 1\nto show that the depth of recursion is at most log4/3 n. In general weighted graphs, the ratio of\nradG (x0 ) to the length of the shortest edge can be arbitrarily large. Thus, the recursion can be\nvery deep. To compensate, we will contract all edges that are significantly shorter than the radius\nof their component. In this way, we will guarantee that each edge is only active in a logarithmic\nnumber of iterations.\nLet e = (u, v) be an edge in G = (V, E, w). The contraction of e results in a new graph by\nidentifying u and v as a new vertex whose neighbors are the union of the neighbors of u and v. All\nself-loops created by the contraction are discarded. We refer to u and v as the preimage of the new\nvertex.\nWe now state and analyze our algorithm for general weighted graphs.\n\n8\n\n\fFix \u03b2 = (2 log4/3 (b\nn + 32))\u22121 .\nT = LowStretchTree(G = (V, E, w), x0 ).\n0. If |V | \u2264 2, return G. (If G contains multiple edges, return the shortest copy.)\n\n1. Set \u03c1 = radG (x0 ).\ne = (Ve , E)\ne be the graph obtained by contracting all edges in G of length less than\n2. Let G\n\u03b2\u03c1/b\nn.\n\u0010n\no\n\u0011\ne x0 , 1/3, \u03b2).\n3.\nVe0 , . . . , Vek , xe , ye = StarDecomp(G,\n\n4. For each i, let Vi be the preimage under the contraction of step 2 of vertices in Vei , and\n(xi , yi ) \u2208 V0 \u00d7 Vi be the edge of shortest length for which xi is a preimage of x\nei and yi\nis a preimage of yei .\n\n5. For 0 \u2264 i \u2264 k, set Ti = LowStretchTree(G(Vi ), xi )\nS\nS\n6. Set T = i Ti \u222a i (yi , xi ).\n\ne obtained by contracting some of the edges of the graph\nIn what follows, we refer to the graph G,\nG, as the edge-contracted graph.\n\nTheorem 3.4 (Low-Stretch Spanning Tree). Let G = (V, E, w) be a weighted connected graph\nand let x0 be a vertex in V . Then\nT = LowStretchTree(G, x0 ) ,\nin time O(m\nb log n\nb+n\nb log2 n\nb), returns a spanning tree of G satisfying\n\u221a\nradT (x0 ) \u2264 2 e * radG (x0 )\n\n(5)\n\nand\nb\nave-stretchT (E) = O(log3 m)\n\n(6)\n\nProof. We first establish notation similar to that used in the proof of Theorem 3.3. Our first step\nis to define a procedure, SD, that captures the action of the algorithm in steps 2 through 4. We\nthen define R0 (G) = G and\n[\n[\nRt (G) = (yi , xi ) \u222a\nRt\u22121 (G(Vi )),\ni\n\ni\n\nwhere\n({V0 , . . . , Vk } , x1 , . . . , xk , y1 , . . . , yk ) = SD(G, x0 , 1/3, \u03b2).\nWe now prove the claim in (5). Let \u03c1 = radG (x0 ). Let t = 2 log4/3 (b\nn + 32) and let \u03c1t =\nradRt (G) (x0 ). Each contracted edge is of length at most \u03b2\u03c1/b\nn, and every path in the graph G(Vi )\ncontains at most n contracted edges, hence the insertion of the contracted edges to G(Vi ) increases\nits radius by an additive factor of at most \u03b2\u03c1. Since (2 log4/3 (b\nn + 32))\u22121 \u2264 1/24 for every n \u2265 0, it\nfollows that 2/3 + 2 \u03b2 \u2264 3/4. Therefore, following the proof of Theorem 3.3, we can show that \u03c1t\n\u221a\nis at most e * radG (x0 ).\n9\n\n\fWe know that each component of G that remains after t levels of the recursion has radius at\nmost \u03c1(3/4)t \u2264 \u03c1/b\nn2 . We may also assume by induction that for the graph induced on each of\n\u221a\nthese components, LowStretchTree outputs a tree of radius at most 2 e(\u03c1/b\nn2 ). As there are at\nmost n of these components, we know that the tree returned by the algorithm has radius at most\n\u221a\n\u221a\n\u221a\ne \u03c1 + n \u00d7 2 e(\u03c1/b\nn2 ) \u2264 2 e \u03c1 ,\nfor n\nb \u2265 2.\nWe now turn to the claim in (6), the bound on the stretch. In this part, we let Et \u2286 E denote\nthe set of edges that are present at recursion depth t. That is, their endpoints are not identified\nby the contraction of short edges in step 2, and their endpoints remain in the same component.\nWe now observe that no edge can be present at more than log4/3 ((2 n\nb/\u03b2) + 1) recursion depths.\nTo see this, consider an edge (u, v) and let t be the first recursion level for which the edge is in\nEt . Let \u03c1t be the radius of the component in which the edge lies at that time. As u and v are not\nidentified under contraction, they are at distance at least \u03b2\u03c1t /b\nn from each other. (This argument\ncan be easily verified, although the condition for edge contraction depends on the length of the\nedge rather than on the distance between its endpoints.) If u and v are still in the same graph on\nrecursion level t + log4/3 ((2 n\nb/\u03b2) + 1), then the radius of this graph is at most \u03c1t /((2 n\nb/\u03b2) + 1),\nthus its diameter is strictly less\nn, in contradiction to the distance between u and v.\nPthan \u03b2\u03c1t /b\nSimilarly to the way that (u,v)\u2208\u2202(V0 ,...,Vk ) stretchT (u, v) is upper-bounded in inequalities (3)(4) in the proof of Theorem 3.3, it follows that the total contribution to the stretch at depth t is\nat most\nO(vol (Et ) log2 m).\nb\n\nThus, the sum of the stretches over all recursion depths is\nX\n\u0001\n\u0001\nO vol (Et ) log2 m\nb =O m\nb log3 m\nb .\nt\n\nWe now analyze the running time of the algorithm. On each recursion level, the dominant cost\nis that of performing the StarDecomp operations on each edge-contracted graph. Let Vt denote\nthe set of vertices in all edge-contracted graphs on recursion level t. Then the total cost of the\nStarDecomp\noperations on recursion\nP\nP level t is at most O(|Et | + |Vt | log |Vt |). We will prove soon\nthat t |Vt | = O(b\nn log n\nb), and as t |Et | = O(m\nb log m),\nb it follows that the total running time is\n2\nO(m\nb log n\nb+n\nb log n\nb). Note that for unweighted graphs G, the running time is only O(m\nb log n\nb).\nThe following lemma shows that even though the number of recursion levels can be very large,\nthe overall number of vertices in edge-contracted graphs appearing on different recursion levels is\nat most O(b\nn log n\nb). This lemma is used only for the analysis of the running time of our algorithm;\na reader interested only in the existential bound can skip it.\nLemma\nP 3.5. Let Vt be the set of vertices appearing in edge-contracted graphs on recursion level t.\nThen t |Vt | = O(b\nn log n\nb).\n\ne = (Ve , E)\ne on recursion level t and let x be a vertex in\nProof. Consider an edge-contracted graph G\ne\nV . The vertex x was formed as a result of a number of edge contractions (maybe 0). Consequently,\nx can be viewed as a set of all original vertices that were identified together to form it, i.e., x can be\n10\n\n\fviewed as a super-vertex. Let \u03c7(x) denote the set of original vertices that were identified together\nto form the super-vertex v \u2208 Ve .\nWe claim that for every super-vertex x \u2208 Vt+1 , there exist a super-vertex y \u2208 Vt such that\n\u03c7(x) \u2286 \u03c7(y). To prove it, note that every graph on recursion level t + 1 corresponds to a single\ncomponent of a star decomposition on recursion level t. Moreover, an edge that was contracted\non recursion level t + 1 must have been contracted on recursion level t as well. Therefore we can\nconsider a directed forest F in which every node at depth t, corresponds to some super-vertex in\nVt , and an edge leads from a node y at depth t to a node x at depth t + 1, if \u03c7(x) \u2286 \u03c7(y). Note that\nthe roots of F correspond to super-vertices on recursion level 0 and the leaves of F correspond to\nthe original vertices of the graph G.\nIn the proof of Theorem 3.4, we showed that every edge is present on O(log n\nb) recursion levels.\nFollowing a similar line of arguments, one can show that every super-vertex is present on O(log n\nb)\n(before it decomposes to smaller super-vertices, each contains a subset of its vertices). Since there\nare n\nb vertices in the original graph G, there are n\nb leaves in F.P Therefore the overall number of\nnodes in the directed forest F is O(b\nn log n\nb), and the bound on t |Vt | holds.\n\n4\n\nStar decomposition\n\nOur star decomposition algorithm exploits two algorithms for growing sets. The first, BallCut, is\nthe standard ball growing technique introduced by Awerbuch [4], and was the basis of the algorithm\nof [1]. The second, ConeCut, is a generalization of ball growing to cones. So that we can analyze\nthis second algorithm, we abstract the analysis of ball growing from the works of [16, 2, 17]. Instead\nof nested balls, we consider concentric systems, which we now define.\nDefinition 4.1 (Concentric System). A concentric system in a weighted graph G = (V, E, w)\nis a family of vertex sets L = {Lr \u2286 V : r \u2208 R+ \u222a {0}} such that\n1. L0 6= \u2205,\n2. Lr \u2286 Lr\u2032 for all r < r \u2032 , and\n3. if a vertex u \u2208 Lr and (u, v) is an edge in E then v \u2208 Lr+d(u,v) .\nFor example, for any vertex x \u2208 V , the set of balls {B(r, x)} is a concentric system. The radius\nof a concentric system L is radius(L) = min{r : Lr = V }. For each vertex v \u2208 V , we define kvkL\nto be the smallest r such that v \u2208 Lr .\nLemma 4.2 (Concentric System Cutting). Let G = (V, E, w) be a connected weighted graph\nand let L = {Lr } be a concentric system. For every two reals 0 \u2264 \u03bb < \u03bb\u2032 , there exists a real\nr \u2208 [\u03bb, \u03bb\u2032 ) such that\n\u0014\n\u0012\n\u0013\u0015\nm+\u03c4\nvol (Lr ) + \u03c4\nmax 1, log2\n,\ncost (\u2202 (Lr )) \u2264\n\u03bb\u2032 \u2212 \u03bb\nvol (E(L\u03bb )) + \u03c4\nwhere m = |E| and\n\n(\n1\n\u03c4=\n0\n\nif vol (E(L\u03bb )) = 0\notherwise.\n11\n\n\fProof. Note that rescaling terms does not effect the statement of the lemma. For example, if all\nthe weights are doubled, then the costs are doubled but the distances are halved. Moreover, we\nmay assume that \u03bb\u2032 \u2264 radius(L), since otherwise, choosing r = radius(L) implies that \u2202 (Lr ) = \u2205\nand the claim holds trivially.\nLet ri = kvi k, and assume that the vertices are ordered so that r1 \u2264 r2 \u2264 * * * \u2264 rn . We may\nnow assume without loss of generality that each edge in the graph has minimal length. That is,\nan edge from vertex i to vertex j has length |ri \u2212 rj |. The reason we may make this assumption\nis that it only increases the weights of edges, making our lemma strictly more difficult to prove.\n(Recall that the weight of an edge is the reciprocal of its length.)\nLet Bi = Lri . Our proof will make critical use of a quantity \u03bci , which is defined to be\nX\n\n\u03bci = \u03c4 + vol (E(Bi )) +\n\n(vj ,vk )\u2208E:j\u2264i<k\n\nri \u2212 rj\n.\nrk \u2212 rj\n\nThat is, \u03bci sums the edges inside Bi , proportionally counting edges that are split by the boundary\nof the ball. The two properties of \u03bci that we exploit are\n\u03bci+1 = \u03bci + cost (\u2202 (Bi )) (ri+1 \u2212 ri ),\n\n(7)\n\n\u03c4 + vol (E(Bi )) \u2264 \u03bci \u2264 \u03c4 + vol (Bi ) .\n\n(8)\n\nand\nThe equality (7) follows from the definition by a straight-forward calculation, as\n\u03bci = \u03c4 + vol (E(Bi+1 )) \u2212 vol ({(vj , vi+1 ) \u2208 E | j \u2264 i}) +\nand\ncost (\u2202 (Bi )) (ri+1 \u2212 ri ) =\n\nX\n\n(vj ,vk )\u2208E:j\u2264i<k\n\nX\n\n(vj ,vk )\u2208E:j\u2264i<k\n\nri \u2212 rj\nrk \u2212 rj\n\nri+1 \u2212 ri\n.\nrk \u2212 rj\n\nChoose a and b so that ra\u22121 \u2264 \u03bb < ra and rb < \u03bb\u2032 \u2264 rb+1 . Let \u03bd = \u03bb\u2032 \u2212 \u03bb. We first consider\nthe trivial case in which b < a. In that case, there is no vertex whose distance from v0 is between\n\u03bb and \u03bb\u2032 . Thus every edge crossing L(\u03bb+\u03bb\u2032 )/2 has length at least \u03bd, and therefore cost at most 1/\u03bd.\nTherefore, by setting r = (\u03bb + \u03bb\u2032 )/2, we obtain\ncost (\u2202 (Lr )) \u2264 vol (\u2202 (Lr ))\nestablishing the lemma in this case.\nWe now define\n\u03b7 = log2\n\n\u0012\n\n1\n1\n\u2264 vol (Lr ) ,\n\u03bd\n\u03bd\n\nm+\u03c4\nvol (E(Ba\u22121 )) + \u03c4\n\n\u0013\n\n.\n\nNote that Ba\u22121 = L\u03bb , by the choice of a. A similarly trivial case is when [a, b] is non-empty, and\nwhere there exists an i \u2208 [a \u2212 1, b] such that\nri+1 \u2212 ri \u2265\n12\n\n\u03bd\n.\n\u03b7\n\n\fIn this case, every edge in \u2202 (Bi ) has cost at most \u03b7/\u03bd, and by choosing r to be max{ri , \u03bb}, we\nsatisfy\n\u03b7\n\u03b7\ncost (\u2202 (Lr )) \u2264 |\u2202 (Lr )| \u2264 vol (Lr ) ,\n\u03bd\n\u03bd\nhence, the lemma is established in this case.\nIn the remaining case that the set [a, b] is non-empty and for all i \u2208 [a \u2212 1, b],\nri+1 \u2212 ri <\n\n\u03bd\n,\n\u03b7\n\n(9)\n\nwe will prove that there exists an i \u2208 [a \u2212 1, b] such that\ncost (\u2202 (Bi )) \u2264\n\n\u03bci \u03b7\n,\n\u03bd\n\nhence, by choosing r = max{ri , \u03bb}, the lemma is established due to (8).\nAssume by way of contradiction that\ncost (\u2202 (Bi )) > \u03bci \u03b7/\u03bd\nfor all i \u2208 [a \u2212 1, b]. It follows, by (7), that\n\u03bci+1 > \u03bci + \u03bci (ri+1 \u2212 ri )\u03b7/\u03bd\nfor all i \u2208 [a \u2212 1, b], which implies\n\u03bcb+1 > \u03bca\u22121\n\nb\nY\n\ni=a\u22121\n\n\u2265 \u03bca\u22121\n\nb\nY\n\n(1 + (ri+1 \u2212 ri )\u03b7/\u03bd)\n2((ri+1 \u2212ri )\u03b7/\u03bd) , by (9) and since 1 + x \u2265 2x for every 0 \u2264 x \u2264 1\n\ni=a\u22121\n(rb+1 \u2212ra\u22121 )\u03b7/\u03bd\n\n= \u03bca\u22121 * 2\n\n\u2265 \u03bca\u22121 * ((m + \u03c4 )/(vol (E(Ba\u22121 )) + \u03c4 ))\n\n\u2265 m + \u03c4 , by (8),\nwhich is a contradiction.\n\nAn analysis of the following standard ball growing algorithm follows immediately by applying\nLemma 4.2 to the concentric system {B(r, x)}.\nr = BallCut(G, x0 , \u03c1, \u03b4)\n1. Set r = \u03b4\u03c1.\n0 ))+1\n2. While cost (\u2202 (B(r, x0 ))) > vol(B(r,x\nlog2 (m + 1),\n(1\u22122 \u03b4)\u03c1\na. Find the vertex v 6\u2208 B(r, x0 ) that minimizes dist(x0 , v) and set r = dist(x0 , v).\n\n13\n\n\fCorollary 4.3 (Weighted Ball Cutting). Let G = (V, E, w) be a connected weighted graph, let\nx \u2208 V , \u03c1 = radG (x), r = BallCut(G, x0 , \u03c1, 1/3), and V0 = B(r, x). Then \u03c1/3 \u2264 r < 2 \u03c1/3 and\ncost (\u2202 (V0 )) \u2264\n\n3 (vol (V0 ) + 1) log 2 (|E| + 1)\n.\n\u03c1\n\nWe now examine the concentric system that enables us to construct V1 , . . . , Vk in Lemma 3.2.\nDefinition 4.4 (Ideals and Cones). For any weighted graph G = (V, E, w) and S \u2286 V , the set\nof forward edges induced by S is\nF (S) = {(u \u2192 v) : (u, v) \u2208 E, dist(u, S) + d(u, v) = dist(v, S)}.\nFor a vertex v \u2208 V , the ideal of v induced by S, denoted IS (v), is the set of vertices reachable from\nv by directed edges in F (S), including v itself.\nFor a vertex v \u2208 V , the cone of width l around v induced by S, denoted CS (l, v), is the set of\nvertices in V that can be reached from v by a path, the sum of the lengths of whose edges e that\ndo not belong to F (S) is at most l. Clearly, CS (0, v) = IS (v) for all v \u2208 V .\nThat is, IS (v) is the set of vertices that have shortest paths to S that intersect v. Also,\nu \u2208 CS (l, v) if there exist a0 , . . . , ak\u22121 and b1 , . . . , bk such that a0 = v, bk = u, bi+1 \u2208 Is (ai ),\n(bi , ai ) \u2208 E, and\nX\nd(bi , ai ) \u2264 l.\ni\n\nWe now establish that these cones form concentric systems.\n\nProposition 4.5 (Cones are concentric). Let G = (V, E, w) be a weighted graph and let S \u2286 V .\nThen for all v \u2208 V , {CS (l, v)}l is a concentric system in G.\n\nProof. Clearly, CS (l, v) \u2286 CS (l\u2032 , v) if l < l\u2032 . Moreover, suppose u \u2208 CS (l, v) and (u, w) \u2208 E. Then\nif (u \u2192 w) \u2208 F , then w \u2208 CS (l, v) as well. Otherwise, the path witnessing that u \u2208 CS (l, v)\nfollowed by the edge (u, w) to w is a witness that w \u2208 CS (l + d(u, w), v).\nr = ConeCut(G, v, \u03bb, \u03bb\u2032 , S)\n1. Set r = \u03bb and if vol (E(CS (\u03bb, v))) = 0,\nSet \u03bc = (vol (CS (r, v)) + 1) log2 (m + 1)\notherwise,\nSet \u03bc = vol (CS (r, v)) log2 (m/vol (E(CS (\u03bb, v)))\n2. While cost (\u2202 (CS (r, v))) > \u03bc/(\u03bb\u2032 \u2212 \u03bb),\na.Find the vertex w 6\u2208 CS (r, v) minimizing dist(w, CS (r, v)) and set r = r +\ndist(w, CS (r, v)).\nCorollary 4.6 (Cone Cutting). Let G = (V, E, w) be a connected weighted graph, let v be a\nvertex in V and let S \u2286 V . Then for any two reals 0 \u2264 \u03bb < \u03bb\u2032 , ConeCut(G, v, \u03bb, \u03bb\u2032 , S) returns a\nreal r \u2208 [\u03bb, \u03bb\u2032 ) such that\n\u0014\n\u0015\nvol (CS (r, v)) + \u03c4\nm+\u03c4\ncost (\u2202 (CS (r, v))) \u2264\nmax 1, log2\n,\n\u03bb\u2032 \u2212 \u03bb\nvol (E(CS (\u03bb, v))) + \u03c4\n14\n\n\fwhere m = |E|, and\n\n\u001a\n\n\u03c4 =\n\n1,\n0,\n\nif vol (E(CS (\u03bb, v))) = 0\notherwise.\n\nWe will use two other properties of the cones CS (l, v): that we can bound their radius (Proposition 4.7), and that their removal does not increase the radius of the resulting graph (Proposition 4.9).\nProposition 4.7 (Radius of Cones). Consider a connected weighted graph G = (V, E, w), a\nvertex subset S \u2286 V and let \u03c8 = maxv\u2208V dist(v, S). Then, for every x \u2208 S,\nradCS (l,x) (x) \u2264 \u03c8 + 2l.\nProof. Let u be a vertex in CS (l, x), and let a0 , . . . , ak\u22121 and b1 , . . . , bk be vertices such that a0 = x,\nbk = u, bi+1 \u2208 Is (ai ), (bi , ai ) \u2208 E, and\nX\nd(bi , ai ) \u2264 l.\ni\n\nThese vertices provide a path connecting x to u inside CS (l, x) of length at most\nX\nX\nd(bi , ai ) +\ndist(ai , bi+1 ).\ni\n\ni\n\nAs the first term is at most l, we just need to bound the second term by \u03c8 + l. To do this, consider\nthe distance of each of these vertices from S. We have the relations\ndist(bi+1 , S) = dist(ai , S) + dist(ai , bi+1 )\ndist(ai , S) \u2265 dist(bi , S) \u2212 d(bi , ai ),\nwhich imply that\n\u03c8 \u2265 dist(bk , S) \u2265\n\nX\ni\n\ndist(ai , bi+1 ) \u2212 d(bi , ai ) \u2265\n\nX\ni\n\n!\n\ndist(ai , bi+1 )\n\n\u2212l ,\n\nas desired.\nIn our proof, we actually use Proposition 4.8 which is a slight extension of Proposition 4.7. It's\nproof is similar.\nProposition 4.8 (Radius of Cones, II). Consider a connected weighted graph G = (V, E, w), a\nvertex x0 \u2208 V and let \u03c1 = radG (x0 ). Consider a real r0 < \u03c1 and let V0 = B(r0 , x0 ), V \u2032 = V \u2212 V0\nand S = BS(r0 , x0 ). Consider a vertex x1 \u2208 S and let \u03c8 = \u03c1 \u2212 distG (x0 , x1 ). Then the cones\nCS (l, x1 ) in the graph G(V \u2032 ) satisfy\nradCS (l,x1 ) (x1 ) \u2264 \u03c8 + 2l.\nProposition 4.9 (Deleting Cones). Consider a connected weighted graph G = (V, E, w), a vertex\nsubset S \u2286 V , a vertex x \u2208 S and a real l \u2265 0 and let V \u2032 = V \u2212 CS (l, x), S \u2032 = S \u2212 CS (l, x) and\n\u03c8 = maxv\u2208V dist(v, S). Then\nmax\u2032 distV \u2032 (v, S \u2032 ) \u2264 \u03c8 .\nv\u2208V\n\n15\n\n\fProof. Consider some v \u2208 V \u2032 . If the shortest path from v to S intersects CS (l, x), then v \u2208 CS (l, x).\nSo, the shortest path from v to S in V must lie entirely in V \u2032 .\nThe basic idea of StarDecomp is to first use BallCut to construct V0 and then repeatedly apply\nConeCut to construct V1 , . . . , Vk .\n({V0 , . . . , Vk , x , y }) = StarDecomp(G = (V, E, w), x0 , \u03b4, \u01eb)\n1. Set \u03c1 = radG (x0 ); Set r0 = BallCut(G, x0 , \u03c1, \u03b4) and V0 = B(r0 , x0 );\n2. Let S = BS(r0 , x0 );\n3. Set G\u2032 = (V \u2032 , E \u2032 , w\u2032 ) = G(V \u2212 V0 ), the weighted graph induced by V \u2212 V0 ;\n\n4. Set ({V1 , . . . , Vk , x }) = ConeDecomp(G\u2032 , S, \u01eb\u03c1/2);\n\n5. For each i \u2208 [1 : k], set yk to be a vertex in V0 such that (xk , yk ) \u2208 E and yk is on a\nshortest path from x0 to xk . Set y = (y1 , . . . , yk ).\n({V1 , . . . , Vk , x }) = ConeDecomp(G, S, \u2206)\n1. Set G0 = G, S0 = S, and k = 0.\n2. while Sk is not empty\na. Set k = k + 1; Set xk to be a vertex of Sk\u22121 ; Set rk = ConeCut(Gk\u22121 , xk , 0, \u2206, Sk\u22121 )\nb. Set Vk = CSk\u22121 (rk , xk ); Set Gk = G(V \u2212 \u222aki=1 Vk ) and Sk = Sk\u22121 \u2212 Vk .\n3. Set x = (x1 , . . . , xk ).\n\nProof of Lemma 3.2. Let \u03c1 = radG (x0 ). By setting \u03b4 = 1/3, Corollary 4.3 guarantees \u03c1/3 \u2264 r0 \u2264\n(2/3)\u03c1. Applying \u2206 = \u01eb\u03c1/2 and Propositions 4.7 and 4.9, we can bound for every i, r0 + d(xi , yi ) +\nri \u2264 \u03c1 + 2\u2206 = \u03c1 + \u01eb\u03c1. Thus StarDecomp(G, x0 , 1/3, \u01eb) returns a (1/3, \u01eb)-star-decomposition with\ncenter x0 .\nTo bound the cost of the star-decomposition that the algorithm produces, we use Corollaries\n4.3 and 4.6.\n3 (1 + vol (V0 )) log2 (m + 1)\n, and\n\u03c1\n\u0011\u0011 2 (1 + vol (V )) log (m + 1)\n\u0010 \u0010\nj\n2\n\u2264\ncost E Vj , V \u2212 \u222aji=0 Vi\n\u01eb\u03c1\n\ncost (\u2202 (V0 )) \u2264\n\nfor every 1 \u2264 i \u2264 k, thus\n\ncost (\u2202 (V0 , . . . , Vk )) \u2264\n\u2264\n\u2264\n\nk\nX\nj=0\n\n\u0011\u0011\n\u0010 \u0010\ncost E Vj , V \u2212 \u222aji=0 Vi\nk\n\n2 log2 (m + 1) X\n(vol (Vj ) + 1)\n\u01eb\u03c1\nj=0\n\n6 m log2 (m + 1)\n.\n\u01eb\u03c1\n16\n\n\fTo implement StarDecomp in O(m + n log n) time, we use a Fibonacci heap to implement steps\n(2) of BallCut and ConeCut. If the graph is unweighted, this can be replaced by a breadth-first\nsearch that requires O(m) time.\n\n5\n\nImproving the Stretch\n\n\u0001\nIn this section, we improve the average stretch of the spanning tree to O log2 n log log n by introducing a procedure ImpConeDecomp which refines ConeDecomp. This new cone decomposition trades\noff the volume of the cone against the cost of edges on its boundary (similar to Seymour [20]). Our\nrefined star decomposition algorithm ImpStarDecomp is identical to algorithm StarDecomp, except\nthat it calls\n({V1 , . . . , Vk , x }) = ImpConeDecomp(G\u2032 , S, \u01eb\u03c1/2, t, m)\nb\nat Step 4, where t is a positive integer that will be defined soon.\n({V1 , . . . , Vk , x }) = ImpConeDecomp(G, S, \u2206, t, m)\nb\n1. Set G0 = G, S0 = S and j = 0.\n\n2. while Sj is not empty\na. Set j = j + 1, set xj to be a vertex of Sj\u22121 , and set p = t \u2212 1;\nb. while p > 0\ni. rj = ConeCut(Gj\u22121 , xj , (t\u2212p\u22121)\u2206\n, (t\u2212p)\u2206\n, Sj\u22121 );\nt\nt\n\u0001\nm\nii. if vol E(CSj\u22121 (rj , xj )) \u2264 logp/t mb then exit the loop; else p = p \u2212 1;\n2\n\nc. Set Vj = CSj\u22121 (rj , xj ) and set Gj = G(V \u2212 \u222aji=1 Vi ) and Sj = Sj\u22121 \u2212 Vj ;\n\n3. Set x = (x1 , . . . , xk ).\n\nLemma 5.1 (Improved Low-Cost Star Decomp). Let G, x0 and \u01eb be as in Lemma 3.2, t be\na positive integer control parameter, and \u03c1 = radG (x0 ). Then\n({V0 , . . . , Vk }, x , y ) = ImpStarDecomp(G, x0 , 1/3, \u01eb, t, m)\nb ,\n\nin time O(m + n log n), returns a (1/3, \u01eb)-star-decomposition of G with center x0 that satisfies\ncost (\u2202 (V0 )) \u2264\n\n6 vol (V0 ) log2 (m\nb + 1)\n,\n\u03c1\n\nand for every index j \u2208 {1, 2, . . . , k} there exists p = p(j) \u2208 {0, 1, . . . , t \u2212 1} such that\n\nand unless p = 0,\n\n\u0011\u0011\n\u0010 \u0010\n4 vol (Vj ) log(p+1)/t (m\nb + 1)\n\u2264t*\ncost E Vj , V \u2212 \u222aji=0 Vi\n,\n\u01eb\u03c1\nvol (E(Vj )) \u2264\n\n17\n\nm\np/t\nb\n2log m\n\n.\n\n(10)\n\n(11)\n\n\fProof. In what follows, we call p(j) the index-mapping of the vertex set Vj . We begin our proof\nby observing that 0 \u2264 rj < \u01eb\u03c1/2 for every 1 \u2264 j \u2264 k. We can then show that {V0 , . . . , Vk } is a\n(1/3, \u01eb)-star decomposition as we did in the proof of Lemma 3.2.\nWe now bound the cost of the decomposition. Clearly, the bound on cost (\u2202 (V0 )) remains\nunchanged from that proved in Lemma 3.2, but here we bound vol (V0 ) + 1 by 2vol (V0 ).\nBelow we will use \u2206 = \u01eb\u03c1/2 as specified in the algorithm.\nFix an index j \u2208 {1, 2, . . . , k}, and let p = p(j) be the final value of variable p in the loop\nabove (that is, the value of p when the execution left the loop while constructing Vj ). Observe that\np \u2208 {0, 1, . . . , t\u22121}, and that unless the loop is aborted due to p = 0, we have vol (E(Vj )) \u2264 logm\np/t m\nb\n2\nand inequality (11) holds.\nFor inequality (10), we\n\u0011\u0011 to two cases. First, consider the case p = t \u2212 1.\n\u0010 split\n\u0010 the discussion\nj\n\u2264 (vol (Vj ) + 1) log(m\nb + 1)(t/\u2206) follows directly\nThen the inequality cost E Vj , V \u2212 \u222ai=0 Vi\nfrom Corollary 4.6, and inequality (10) holds.\nSecond, consider the case p < t \u2212 1 and let rj\u2032 be the value of the variable rj at the beginning of\nthe last iteration of the loop (before the last invocation\nof Algorithm\n\u0010\n\u0011 ConeCut). In this case, observe\nm\n\u2032\nthat at the beginning of the last iteration, vol E(CSj\u22121 (rj , xj )) > log(p+1)/t\n(as otherwise the\nm\nb\n2\nloop would have been aborted in the previous iteration). By Corollary 4.6,\n\uf8f6\uf8f9\n\uf8ee\n\uf8eb\n\u0011\u0011\n\u0010 \u0010\nm\nvol (Vj )\n\u0010\n\u0010 \u0010\n\u0011\u0011\u0011 \uf8f8\uf8fb ,\n\u2264\n\u00d7 max \uf8f01, log2 \uf8ed\ncost E Vj , V \u2212 \u222aji=0 Vi\n(t\u2212p\u22121)\u2206\n\u2206/t\nvol E C\n,x\nSj\u22121\n\nt\n\nj\n\nwhere Vj = CSj\u22121 (rj , xj ). Since\n\n(t \u2212 p \u2212 2)\u2206\n(t \u2212 p \u2212 1)\u2206\n\u2264 rj\u2032 <\n,\nt\nt\nit follows that\n\u0012 \u0012\n\u0012\n\u0013\u0013\u0013\n\u0001\n(t \u2212 p \u2212 1)\u2206\nm\n.\nvol E CSj\u22121\n, xj\n\u2265 vol E(CSj\u22121 (rj\u2032 , xj )) >\n(p+1)/t\nlog\nm\nb\nt\n2\n\nTherefore\n\nand\n\n\uf8ee\n\n\uf8eb\n\nlog(p+1)/t m\nb \u2265 max \uf8f01, log2 \uf8ed\n\n\u0010 \u0010\nvol E CSj\u22121\n\nm\n\u0010\n\n(t\u2212p\u22121)\u2206\n, xj\nt\n\n\uf8f6\uf8f9\n\n\u0011\u0011\u0011 \uf8f8\uf8fb ,\n\n\u0011\u0011\n\u0010 \u0010\nvol (Vj ) log(p+1)/t m\nb\n2 vol (Vj ) log(p+1)/t m\nb\n\u2264\ncost E Vj , V \u2212 \u222aji=0 Vi\n= t*\n.\n\u2206/t\n\u01eb\u03c1\n\nOur improved algorithm ImpLowStretchTree(G, x0 , t, m),\nb is identical to LowStretchTree exe\ncept that in Step 3 it calls ImpStarDecomp(G, x0 , 1/3, \u03b2, t, m),\nb\nand in Step 5 it calls\nImpLowStretchTree(G(Vi ), xi , t, m).\nb\nWe set t = log log n throughout the execution of the algorithm.\n18\n\n\fTheorem 5.2 (Lower\u2013Stretch Spanning Tree). Let G = (V, E, w) be a connected weighted\ngraph and let x0 be a vertex in V . Then\nT = ImpLowStretchTree(G, x0 , t, m)\nb ,\n\nin time O(m\nb log n\nb+n\nb log2 n\nb), returns a spanning tree of G satisfying\n\u221a\nradT (x0 ) \u2264 2 e * radG (x)\nand\n\n\u0001\nave-stretchT (E) = O log2 n\nb log log n\nb .\n\nProof. The bound on the radius of the tree remains unchanged from that proved in Theorem 3.4.\nWe begin by defining a system of notations for the recursive process, assigning for every graph\nG = (V, E) input to some recursive invocation of Algorithm ImpLowStretchTree, a sequence \u03c3(G)\nof non-negative integers. This is done as follows. If G is the original graph input to the first\ninvocation of the recursive algorithm, than \u03c3(G) is empty. Assuming that the halt condition of the\nrecursion is not satisfied for G, the algorithm continues and some of the edges in E are contracted.\ne = (Ve , E)\ne be the resulting graph. (Recall that we refer to G\ne as the edge-contracted graph.) Let\nLet G\ne Let Vj \u2208 V be the preimage under edge contraction\n{Ve0 , Ve1 , . . . , Vek } be the star decomposition of G.\nof Vej \u2208 Ve for every 0 \u2264 j \u2264 k. The graph G(Vj ) is assigned the sequence \u03c3(G(Vj )) = \u03c3(G) * j.\nNote that |\u03c3(G)| = h implies that the graph G is input to the recursive algorithm on recursion level\nh. We warn the reader that the edge-contracted graph obtained from a graph assigned with the\nsequence \u03c3 may have fewer edges than the edge-contracted graph obtained from the graph assigned\nwith the sequence \u03c3 *j, because the latter may contain edges that were contracted out in the former.\ne which is the edgeWe say that the edge e is present at recursion level h if e is an edge in G\ncontracted graph obtained from some graph G with |\u03c3(G)| = h (that is, it was not contracted out).\nAn edge e appears at the first level h at which it is present, and it disappears at the level at which it\nis present and its endpoints are separated by the star decomposition. If an edge appears at recursion\nlevel h, then a path connecting its endpoints was contracted on every recursion level smaller than\nh, and no such path will be contracted on any recursion level greater than h. Moreover, an edge is\nnever present at a level after it disappears. We define h(e) and h\u2032 (e) to be the recursion levels at\nwhich the edge e appears and disappears, respectively.\nFor every edge e and every recursion level i at which it is present, we let U (e, i) denote the set\nof vertices Ve of the edge-contracted graph containing its endpoints. If h(e) \u2264 i < h\u2032 (e), then we let\nW (e, i) denote the set of vertices Vej output by ImpStarDecomposition that contains the endpoints\nof e.\nRecall that p(j) denote the index-mapping of the vertex set Vj in the star decomposition. For\neach index i \u2208 {0, 1, . . . , t \u2212 1}, let Ii = {j \u2208 {1, 2, . . . , k} | p(j) = i}. For a vertex subset U \u2286 V ,\nlet AS(U ) denote the average stretch that the algorithm guarantees for the edges of E(U ). Let\n\n19\n\n\fTS(U ) = AS(U ) * |E(U )|. Then by Lemma 5.1, the following recursive formula applies.\n\uf8f6\n\uf8eb\nk\nX\nTS(Vej )\uf8f8\nTS(V ) \u2264 \uf8ed\nj=0\n\n\uf8eb\n\n\uf8f6\nt\u22121\n\u0010\n\u0011\n\u0010\n\u0011\nX\nX\n\u221a\nt\nb + 1) * vol Ve0 + 4\n+ 4 e \u00d7 \uf8ed6 log(m\nvol Vej \uf8f8\nlog(p+1)/t (m\nb + 1)\n\u03b2\np=0\nj\u2208Ip\n\uf8f6\n\uf8eb\nX\nstretchT (e)\uf8f8\n+ \uf8ed\n\uf8eb\n\n= \uf8ed\n\ne\ne\u2208E\u2212E\n\nk\nX\nj=0\n\n\uf8f6\n\nTS(Vj )\uf8f8\n\n\uf8eb\n\uf8f6\nt\u22121\n\u0010 \u0011\n\u0010\n\u0011\nX\nX\n\u221a\nt\nb + 1) * vol Ve0 + 4\n+ 4 e \u00d7 \uf8ed6 log(m\nvol Vej \uf8f8 ,(12)\nlog(p+1)/t (m\nb + 1)\n\u03b2 p=0\nj\u2208Ip\n\nwhere we recall \u03b2 = \u01eb = (2 log4/3 (n + 32))\u22121 .\nFor every edge e and for every h(e) \u2264 i < h\u2032 (e), let \u03c0i (e) denote the index-mapping of the\ncomponent W (e, i) in the invocation of Algorithm ImpConeDecomp on recursion level i. For every\nindex p \u2208 {0, . . . , t \u2212 1}, define the variable lp (e) as follows\n\b\nlp (e) =\nh(e) \u2264 i < h\u2032 (e) | \u03c0i (e) = p .\n\nFor a fixed edge e and an index p \u2208 {0, . . . , t \u2212 1}, every h(e) \u2264 i < h\u2032 (e) such that \u03c0i (e) = p\nreflects a contribution of O(t/\u03b2) * log(p+1)/t (m\nb + 1) to the right term in (12). Summing p over\n{0, 1, . . . , t \u2212 1}, we obtain\nt\u22121\nX\nO(t/\u03b2)lp (e) log (p+1)/t (m\nb + 1).\np=0\n\nIn a few moments, we will prove that\nt\u22121\nXX\ne\n\np=0\n\nlp (e) log p/t (m\nb + 1) \u2264 O(m\nb log2 m),\nb\n\n(13)\n\nwhich implies that the sum of the contributions of all edges e in levels h(e) \u2264 i < h\u2032 (e) to the right\nterm in (12) is\n\u0013\n\u0012\n\u0010\n\u0011\nt\n1+1/t\n2+1/t\n*m\nb log\nm\nb =O t*m\nb log\nm\nb\nO\n\u03b2\n\nAs vol (Vj ) counts the internal edges of Vj as well as its boundary edges, we must also account\nfor the contribution of each edge e at level h\u2032 (e). At this level, it will be counted twice-once in\neach component containing one of its endpoints. Thus, at this stage, it contributes a factor of at\nmost O((t/\u03b2) * log m)\nb to the sum TS(V ). Therefore all edges e \u2208 E contribute an additional factor\n20\n\n\fof O(t * m\nb log2 m).\nb Summing over all the edges, we find that all the contributions to the right term\nin (12) sum to at most\n\u0010\n\u0011\nO t*m\nb log2+1/t m\nb .\n\nAlso, every h(e) \u2264 i < h\u2032 (e) such that the edge e belongs to the central component Ve0 of the\nstar decomposition, reflects a contribution of O(log m)\nb to the left term in (12). Since there are at\nmost O(log m)\nb such is, it follows that the contribution of the left term in (12) to TS(V ) sums up\nto an additive term of O(log2 m)\nb for every single edge, and (m\nb log2 m)\nb for all edges.\nIt follows that TS(V ) = O(t * m\nb log2+1/t m).\nb This is optimized by setting t = log log m,\nb obtaining the desired upper bound of O(log2 n\nb * log log n\nb) on the average stretch AS(V ) guaranteed by\nAlgorithm ImpLowStretchTree.\nWe now return to the proof of (13). We first note that l0 (e) is at most O(log m)\nb for every edge\n\u2032\ne. We then observe that for each index p > 0 and each h(e) \u2264 i < h (e) such that \u03c0i (e) = p,\np/t\nb (by Lemma 5.1, (11)). For h(e) \u2264 i < h\u2032 (e),\nvol (E(U (e, i))) /vol (E(W (e, i))) is at least 2log m\nlet gi (e) = vol (E(U (e, i + 1))) /vol (E(W (e, i))). We then have\nY \u0010 p/t \u0011lp (e)\nY\nb\n2log m\n\u2264 m\nb\ngi (e) ,\n1\u2264p\u2264t\u22121\n\nhence\n\nPt\u22121\n\np=1 lp (e) log\n\np/t\n\nm\nb \u2264 log m\nb+\nX\n\nh(e)\u2264i<h\u2032 (e)\n\nP\n\nh(e)\u2264i<h\u2032 (e) log gi (e).\n\nX\n\ne h(e)\u2264i<h\u2032 (e)\n\nWe will next prove that\n\nlog gi (e) \u2264 m\nb log m,\nb\n\n(14)\n\nwhich implies (13).\nLet Ei denote the set of edges present at recursion level i. For every edge e \u2208 Ei such that\ni < h\u2032 (e), we have\nX\ngi (e\u2032 ) = gi (e)vol (E(W (e, i))) = vol (E(U (e, i + 1))) ,\ne\u2032 \u2208E(W (e,i))\n\nP\nand so Pe\u2208Ei :i<h\u2032 (e) gi (e) = vol (Ei+1 ) . As each edge is present in at most O(log m)\nb recursion\nb log m,\nb which proves (14).\ndepths, i vol (Ei ) \u2264 m\n\n6\n\nConclusion\n\nAt the beginning of the paper, we pointed out that the definition of stretch used in this paper\ndiffers slightly from that used by Alon, Karp, Peleg and West [1]. If one is willing to accept a\nlonger running time, then this problem is easily remedied as shown in Subsection 1.1. If one is\nwilling to accept a bound of O(log3 n) on the stretch, then one can extend our analysis to show\nthat the natural randomized variant LowStretchTree, in which one chooses the radii of the balls\nand cones at random, works.\n\u0001\nA natural open question is whether one can improve the stretch bound from O log2 n log log n\nto O(log n). Algorithmically, it is also desirable to improve the running time of the algorithm to\nO(m log n). If we can successfully achieve both improvements, then we can use the Spielman-Teng\nsolver to solve planar diagonally dominant linear systems in O(n log n log(1/\u01eb)) time.\n21\n\n\fAs the average stretch3 of any spanning tree in a weighted\nconnected graph is \u03a9(1), our low\u0001\nstretch tree algorithm also provides an O log2 n log log n -approximation to the optimization problem of finding the spanning tree with the lowest average stretch. It remains open (a) whether our\nalgorithm has a better approximation ratio and (b) whether one can in polynomial time find a\nspanning tree with better approximation ratio, e.g., O(log n) or even O(1).\n\n7\n\nAcknowledgments\n\nWe are indebted to David Peleg, who was offered co-authorship on this paper.\n\nReferences\n[1] Noga Alon, Richard M. Karp, David Peleg, and Douglas West. A graph-theoretic game and\nits application to the k-server problem. SIAM Journal on Computing, 24(1):78\u2013100, February\n1995.\n[2] Yonatan Aumann and Yuval Rabani. An o(log k) approximate min-cut max-flow theorem and\napproximation algorithm. SIAM J. Comput., 27(1):291\u2013301, 1998.\n[3] B. Awerbuch and Y. Azar. Buy-at-bulk network design. In Proceedings of the 38th IEEE\nFOCS, pages 542\u2013547, 1997.\n[4] Baruch Awerbuch. Complexity of network synchronization. J. ACM, 32(4):804\u2013823, 1985.\n[5] Yair Bartal. Probabilistic approximation of metric spaces and its algorithmic applications. In\nProceedings of the 37th IEEE FOCS, pages 184\u2013193, 1996.\n[6] Yair Bartal. On approximating arbitrary metrices by tree metrics. In Proceedings of the 30th\nACM STOC, pages 161\u2013168, 1998.\n[7] Yair Bartal. Personal Communication, 2005.\n[8] Erik Boman and Bruce Hendrickson. On spanning tree preconditioners. Manuscript, Sandia\nNational Lab., 2001.\n[9] Erik Boman, Bruce Hendrickson, and Stephen Vavasis. Solving elliptic finite element systems in\nnear-linear time with support preconditioners. Manuscript, Sandia National Lab. and Cornell,\nhttp://arXiv.org/abs/cs/0407022.\n[10] P. Crescenzi and V. Kann. A compendium of NP-hard problems.\nhttp://www.nada.kth.se/theory/compendium, 1998.\n\nAvailable online at\n\n[11] Jittat Fakcharoenphol, Satish Rao, and Kunal Talwar. A tight bound on approximating arbitrary metrics by tree metrics. In Proceedings of the 35th ACM STOC, pages 448\u2013455, 2003.\n3\nIn the context of the optimization problem of finding a spanning tree with the lowest average stretch, the stretch\nis defined as in [1].\n\n22\n\n\f[12] M.R. Garey and D.S. Johnson. Computers and Intractability: a Guide to Theory of NPCompleteness. 1979.\n[13] N. Garg, G. Konjevod, and R. Ravi. A polylogarithmic approximation algorithm for the group\nsteiner tree problem. In Proceedings of the 9th ACM-SIAM SODA, pages 253\u2013259, 1998.\n[14] T.C. Hu. Optimum communication spanning trees. SIAM Journal on Computing, pages 188\u2013\n195, 1974.\n[15] G. Konjevod and R. Ravi. An approximation algorithm for the covering Steiner problem. In\nProceedings of the 11th ACM-SIAM SODA, pages 338\u2013344, 2000.\n[16] Tom Leighton and Satish Rao. Multicommodity max-flow min-cut theorems and their use in\ndesigning approximation algorithms. J. ACM, 46(6):787\u2013832, 1999.\n[17] Nathan Linial, Eran London, and Yuri Rabinovich. The geometry of graphs and some of its\nalgorithmic applications. Combinatorica, 15:215\u2013245, 1995.\n[18] D. Peleg. Distributed Computing: A Locality-Sensitive Approach. 2000. SIAM Philadelphia\nPA.\n[19] D. Peleg and E. Reshef. Deterministic polylogarithmic approximation for minimum communication spanning trees. In Proc. 25th International Colloq. on Automata, Languages and\nProgramming, pages 670\u2013681, 1998.\n[20] P. D. Seymour. Packing directed circuits fractionally. Combinatorica, 15(2):281\u2013288, 1995.\n[21] Daniel A. Spielman and Shang-Hua Teng. Nearly-linear time algorithms for graph partitioning,\ngraph sparsification, and solving linear systems. In Proceedings of the 36th ACM STOC, pages\n81\u201390, 2004.\n\n23\n\n\f"}