{"id": "http://arxiv.org/abs/0707.4389v1", "guidislink": true, "updated": "2007-07-30T12:09:16Z", "updated_parsed": [2007, 7, 30, 12, 9, 16, 0, 211, 0], "published": "2007-07-30T12:09:16Z", "published_parsed": [2007, 7, 30, 12, 9, 16, 0, 211, 0], "title": "Separation Logic for Small-step Cminor", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0707.0863%2C0707.4559%2C0707.2463%2C0707.2527%2C0707.3185%2C0707.0314%2C0707.2316%2C0707.3434%2C0707.3325%2C0707.2820%2C0707.1832%2C0707.4657%2C0707.1410%2C0707.4357%2C0707.3597%2C0707.2723%2C0707.2005%2C0707.1721%2C0707.1016%2C0707.0498%2C0707.3301%2C0707.1780%2C0707.3033%2C0707.1787%2C0707.2442%2C0707.0690%2C0707.1095%2C0707.2681%2C0707.1435%2C0707.0738%2C0707.2818%2C0707.1790%2C0707.3042%2C0707.1867%2C0707.1388%2C0707.4389%2C0707.4572%2C0707.0698%2C0707.1720%2C0707.1976%2C0707.2001%2C0707.0186%2C0707.0772%2C0707.0901%2C0707.4243%2C0707.3845%2C0707.3432%2C0707.3323%2C0707.3298%2C0707.1962%2C0707.0806%2C0707.4633%2C0707.1170%2C0707.2878%2C0707.2273%2C0707.2352%2C0707.4010%2C0707.3534%2C0707.3476%2C0707.4662%2C0707.1085%2C0707.1885%2C0707.0459%2C0707.2127%2C0707.1451%2C0707.4274%2C0707.2686%2C0707.1022%2C0707.0630%2C0707.3309%2C0707.0932%2C0707.2739%2C0707.2418%2C0707.0358%2C0707.2260%2C0707.4293%2C0707.3896%2C0707.4311%2C0707.1214%2C0707.4386%2C0707.1178%2C0707.3733%2C0707.0422%2C0707.4058%2C0707.3381%2C0707.1689%2C0707.1416%2C0707.3571%2C0707.4111%2C0707.0542%2C0707.2959%2C0707.3083%2C0707.3586%2C0707.2900%2C0707.2083%2C0707.4106%2C0707.2801%2C0707.2937%2C0707.1419%2C0707.3166%2C0707.2726&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Separation Logic for Small-step Cminor"}, "summary": "Cminor is a mid-level imperative programming language; there are\nproved-correct optimizing compilers from C to Cminor and from Cminor to machine\nlanguage. We have redesigned Cminor so that it is suitable for Hoare Logic\nreasoning and we have designed a Separation Logic for Cminor. In this paper, we\ngive a small-step semantics (instead of the big-step of the proved-correct\ncompiler) that is motivated by the need to support future concurrent\nextensions. We detail a machine-checked proof of soundness of our Separation\nLogic. This is the first large-scale machine-checked proof of a Separation\nLogic w.r.t. a small-step semantics. The work presented in this paper has been\ncarried out in the Coq proof assistant. It is a first step towards an\nenvironment in which concurrent Cminor programs can be verified using\nSeparation Logic and also compiled by a proved-correct compiler with formal\nend-to-end correctness guarantees.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0707.0863%2C0707.4559%2C0707.2463%2C0707.2527%2C0707.3185%2C0707.0314%2C0707.2316%2C0707.3434%2C0707.3325%2C0707.2820%2C0707.1832%2C0707.4657%2C0707.1410%2C0707.4357%2C0707.3597%2C0707.2723%2C0707.2005%2C0707.1721%2C0707.1016%2C0707.0498%2C0707.3301%2C0707.1780%2C0707.3033%2C0707.1787%2C0707.2442%2C0707.0690%2C0707.1095%2C0707.2681%2C0707.1435%2C0707.0738%2C0707.2818%2C0707.1790%2C0707.3042%2C0707.1867%2C0707.1388%2C0707.4389%2C0707.4572%2C0707.0698%2C0707.1720%2C0707.1976%2C0707.2001%2C0707.0186%2C0707.0772%2C0707.0901%2C0707.4243%2C0707.3845%2C0707.3432%2C0707.3323%2C0707.3298%2C0707.1962%2C0707.0806%2C0707.4633%2C0707.1170%2C0707.2878%2C0707.2273%2C0707.2352%2C0707.4010%2C0707.3534%2C0707.3476%2C0707.4662%2C0707.1085%2C0707.1885%2C0707.0459%2C0707.2127%2C0707.1451%2C0707.4274%2C0707.2686%2C0707.1022%2C0707.0630%2C0707.3309%2C0707.0932%2C0707.2739%2C0707.2418%2C0707.0358%2C0707.2260%2C0707.4293%2C0707.3896%2C0707.4311%2C0707.1214%2C0707.4386%2C0707.1178%2C0707.3733%2C0707.0422%2C0707.4058%2C0707.3381%2C0707.1689%2C0707.1416%2C0707.3571%2C0707.4111%2C0707.0542%2C0707.2959%2C0707.3083%2C0707.3586%2C0707.2900%2C0707.2083%2C0707.4106%2C0707.2801%2C0707.2937%2C0707.1419%2C0707.3166%2C0707.2726&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Cminor is a mid-level imperative programming language; there are\nproved-correct optimizing compilers from C to Cminor and from Cminor to machine\nlanguage. We have redesigned Cminor so that it is suitable for Hoare Logic\nreasoning and we have designed a Separation Logic for Cminor. In this paper, we\ngive a small-step semantics (instead of the big-step of the proved-correct\ncompiler) that is motivated by the need to support future concurrent\nextensions. We detail a machine-checked proof of soundness of our Separation\nLogic. This is the first large-scale machine-checked proof of a Separation\nLogic w.r.t. a small-step semantics. The work presented in this paper has been\ncarried out in the Coq proof assistant. It is a first step towards an\nenvironment in which concurrent Cminor programs can be verified using\nSeparation Logic and also compiled by a proved-correct compiler with formal\nend-to-end correctness guarantees."}, "authors": ["Andrew W. Appel", "Sandrine Blazy"], "author_detail": {"name": "Sandrine Blazy"}, "author": "Sandrine Blazy", "arxiv_comment": "Version courte du rapport de recherche RR-6138", "links": [{"href": "http://arxiv.org/abs/0707.4389v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0707.4389v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.PL", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0707.4389v1", "affiliation": "CEDRIC, INRIA Rocquencourt", "arxiv_url": "http://arxiv.org/abs/0707.4389v1", "journal_reference": "Dans 20th Int. Conference on Theorem Proving in Higher Order\n  Logics (TPHOLs 2007) 4732 (2007) 5-21", "doi": null, "fulltext": "Separation Logic for Small-step Cminor\nAndrew W. Appel1,\u22c6 and Sandrine Blazy2,\u22c6\n\narXiv:0707.4389v1 [cs.PL] 30 Jul 2007\n\n1\n\nPrinceton University\n2\nENSIIE\n\nAbstract. Cminor is a mid-level imperative programming language;\nthere are proved-correct optimizing compilers from C to Cminor and\nfrom Cminor to machine language. We have redesigned Cminor so that\nit is suitable for Hoare Logic reasoning and we have designed a Separation Logic for Cminor. In this paper, we give a small-step semantics\n(instead of the big-step of the proved-correct compiler) that is motivated by the need to support future concurrent extensions. We detail\na machine-checked proof of soundness of our Separation Logic. This is\nthe first large-scale machine-checked proof of a Separation Logic w.r.t. a\nsmall-step semantics. The work presented in this paper has been carried\nout in the Coq proof assistant. It is a first step towards an environment\nin which concurrent Cminor programs can be verified using Separation\nLogic and also compiled by a proved-correct compiler with formal endto-end correctness guarantees.\n\n1\n\nIntroduction\n\nThe future of program verification is to connect machine-verified source programs to machine-verified compilers, and run the object code on machine-verified\nhardware. To connect the verifications end to end, the source language should\nbe specified as a structural operational semantics (SOS) represented in a logical framework; the target architecture can also be specified that way. Proofs\nof source code can be done in the logical framework, or by other tools whose\nsoundness is proved w.r.t. the SOS specification; these may be in safety proofs\nvia type-checking, correctness proofs via Hoare Logic, or (in source languages\ndesigned for the purpose) correctness proofs by a more expressive proof theory.\nThe compiler-if it is an optimizing compiler-will be a stack of phases, each\nwith a well specified SOS of its own. There will be proofs of (partial) correctness\nof each compiler phase, or witness-driven recognizers for correct compilations,\nw.r.t. the SOS's that are inputs and outputs to the phases.\nMachine-verified hardware/compiler/application stacks have been built before. Moore described a verified compiler for a \"high-level assembly language\"\n[13]. Leinenbach et al. [11] have built and proved a compiler for C0, a small\nC-like language, as part of a project to build machine-checked correctness proofs\nof source programs, Hoare Logic, compiler, micro-kernel, and RISC processor.\nThese are both simple one- or two-pass nonoptimizing compilers.\n\u22c6\n\nAppel supported in part by NSF Grants CCF-0540914 and CNS-0627650. This work\nwas done, in part, while both authors were on sabbatical at INRIA.\n\n\fLeroy [12] has built and proved correct in Coq [1] a compiler called CompCert\nfrom a high-level intermediate language Cminor to assembly language for the\nPower PC architecture. This compiler has 4 intermediate languages, allowing\noptimizations at several natural levels of abstraction. Blazy et al. have built and\nproved correct a translator from a subset of C to Cminor [5]. Another compiler\nphase on top (not yet implemented) will then yield a proved-correct compiler\nfrom C to machine language. We should therefore reevaluate the conventional\nwisdom that an entire practical optimizing compiler cannot be proved correct.\nA software system can have components written in different languages, and\nwe would like end-to-end correctness proofs of the whole system. For this, we propose a new variant of Cminor as a machine-independent intermediate language\nto serve as a common denominator between high-level languages. Our new Cminor has a usable Hoare Logic, so that correctness proofs for some components\ncan be done directly at the level of Cminor.\nCminor has a \"calculus-like\" view of local variables and procedures (i.e. local\nvariables are bound in an environment), while Leinenbach's C0 has a \"storageallocation\" view (i.e. local variables are stored in the stack frame). The calculuslike view will lead to easier reasoning about program transformations and easier\nuse of Cminor as a target language, and fits naturally with a multi-pass optimizing compiler such as CompCert; the storage-allocation view suits the one-pass\nnonoptimizing C0 compiler and can accommodate in-line assembly code.\nCminor is a promising candidate as a common intermediate language for\nend-to-end correctness proofs. But we have many demands on our new variant\nof Cminor, only the first three of which are satisfied by Leroy's Cminor.\n\u2022\n\u2022\n\u2022\n\u25e6\n\u25e6\n\u25e6\n\n\u25e6\n\n\u25e6\n\nCminor has an operational semantics represented in a logical framework.\nThere is a proved-correct compiler from Cminor to machine language.\nCminor is usable as the high-level target language of a C compiler.\nOur semantics is a small-step semantics, to support reasoning about input/output, concurrency, and nontermination.\nCminor is machine-independent over machines in the \"standard model\" (i.e.\n32- or 64-bit single-address-space byte-addressable multiprocessors).\nCminor can be used as a mid-level target language of an ML compiler [8], or\nof an OO-language compiler, so that we can integrate correctness proofs of\nML or OO programs with the proofs of their run-time systems and libraries.\nAs we show in this paper, Cminor supports an axiomatic Hoare Logic (in fact,\nSeparation Logic), proved sound with respect to the small-step semantics,\nfor reasoning about low-level (C-like) programs.\nIn future work, we plan to extend Cminor to be concurrent in the \"standard model\" of thread-based preemptive lock-synchronized weakly consistent\nshared-memory programming. The sequential soundness proofs we present\nhere should be reusable in a concurrent setting, as we will explain.\n\nLeroy's original Cminor had several Power-PC dependencies, is slightly clumsy\nto use as the target of an ML compiler, and is a bit clumsy to use in Hoare-style\nreasoning. But most important, Leroy's semantics is a big-step semantics that\n2\n\n\fcan be used only to reason about terminating sequential programs. We have redesigned Cminor's syntax and semantics to achieve all of these goals. That part\nof the redesign to achieve target-machine portability was done by Leroy himself.\nOur redesign to ease its use as an ML back end and for Hoare Logic reasoning\nwas fairly simple. Henceforth in this paper, Cminor will refer to the new version\nof the Cminor language.\nThe main contributions of this paper are a small-step semantics suitable\nfor compilation and for Hoare Logic; and the first machine-checked proof of\nsoundness of a sequential Hoare Logic (Separation Logic) w.r.t. a small-step\nsemantics. Schirmer [17] has a machine-checked big-step Hoare-Logic soundness\nproof for a control flow much like ours, extended by Klein et al. [10] to a C-like\nmemory model. Ni and Shao [14] have a machine-checked proof of soundness of\na Hoare-like logic w.r.t. a small-step semantics, but for an assembly language\nand for much simpler assertions than ours.\n\n2\n\nBig-step Expression Semantics\n\nThe C standard [2] describes a memory model that is byte- and word-addressable\n(yet portable to big-endian and little-endian machines) with a nontrivial semantics for uninitialized variables. Blazy and Leroy formalized this model [6] for\nthe semantics of Cminor. In C, pointer arithmetic within any malloc'ed block\nis defined, but pointer arithmetic between different blocks is undefined; Cminor therefore has non-null pointer values comprising an abstract block-number\nand an int offset. A NULL pointer is represented by the integer value 0. Pointer\narithmetic between blocks, and reading uninitialized variables, are undefined but\nnot illegal: expressions in Cminor can evaluate to undefined (Vundef) without\ngetting stuck.\nEach memory load or store is to a non-null pointer value with a \"chunk\"\ndescriptor ch specifying number of bytes, signed or unsigned, int or float. Storing\nas 32-bit-int then loading as 8-bit-signed-byte leads to an undefined value. Load\nch\n\nch\n\nand store operations on memory, m \u22a2 v1 7\u2192 v2 and m\u2032 = m[v1 := v2 ], are partial\nfunctions that yield results only if reading (resp., writing) a chunk of type ch\nch\n\nat address v1 is legal. We write m \u22a2 v1 7\u2192 v to mean that the result of loading\nfrom memory m at address v1 a chunk-type ch is the value v.\nThe values of Cminor are undefined (Vundef), integers, pointers, and floats.\nThe int type is an abstract data-type of 32-bit modular arithmetic. The expressions of Cminor are literals, variables, primitive operators applied to arguments,\nand memory loads.\nThere are 33 primitive operation symbols op; two of these are for accessing\nglobal names and local stack-blocks, and the rest is for integer and floating-point\narithmetic and comparisons. Among these operation symbols are casts. Cminor\ncasts correspond to all portable C casts. Cminor has an infinite supply ident of\nvariable and function identifiers id . As in C, there are two namespaces-each id\ncan be interpreted in a local scope (using Evar (id )) or in a global scope (using\nEop with the operation symbol for accessing global names).\n3\n\n\fi : int ::= [0, 232 )\nv : val ::= Vundef | Vint (i) | Vptr (b, i) | Vfloat (f )\ne : expr ::= Eval (v) | Evar (id ) | Eop (op, el ) | Eload (ch, e)\nel : exprlist ::= Enil | Econs (e, el )\nExpression Evaluation. In original Cminor, expression evaluation is expressed\nby an inductive big-step relation. Big-step statement execution is problematic\nfor concurrency, but big-step expression evaluation is fine even for concurrent\nprograms, since we will use the separation logic to prove noninterference.\nEvaluation is deterministic. Leroy chose to represent evaluation as a relation\nbecause Coq had better support for proof induction over relations than over\nfunction definitions. We have chosen to represent evaluation as a partial function; this makes some proofs easier in some ways: f (x) = f (x) is simpler than\nf x y \u21d2 f x z \u21d2 y = z. Before Coq's new functional induction tactic was available, we developed special-purpose tactics to enable these proofs. Although we\nspecify expression evaluation as a function in Coq, we present evaluation as a\njudgment relation in Fig. 1. Our evaluation function is (proved) equivalent to\nthe inductively defined judgment \u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 e \u21d3 v where:\n\u03a8 is the \"program,\" consisting of a global environment (ident \u2192 option block)\nmapping identifiers to function-pointers and other global constants, and a\nglobal mapping (block \u2192 option function) that maps certain (\"text-segment\")\naddresses to function definitions.\nsp : block. The \"stack pointer\" giving the address and size of the memory\nblock for stack-allocated local data in the current activation record.\n\u03c1 : env. The local environment, a finite mapping from identifiers to values.\n\u03c6 : footprint. It represents the memory used by the evaluation of an expression\n(or a statement). It is a mapping from memory addresses to permissions.\nLeroy's Cminor has no footprints.\nm : mem. The memory, a finite mapping from blocks to block contents [6].\nEach block represents the result of a C malloc, or a stack frame, a global\nstatic variable, or a function code-pointer. A block content consists of the\ndimensions of the block (low and high bounds) plus a mapping from byte\noffsets to byte-sized memory cells.\ne : expr. The expression being evaluated.\nv : val. The value of the expression.\nLoads outside the footprint will cause expression evaluation to get stuck.\nSince the footprint may have different permissions for loads than for stores to\nsome addresses, we write \u03c6 \u22a2 loadch v (or \u03c6 \u22a2 storech v) to mean that all the\naddresses from v to v + |ch| \u2212 1 are readable (or writable).\nTo model the possibility of exclusive read/write access or shared read-only\naccess, we write \u03c60 \u2295 \u03c61 = \u03c6 for the \"disjoint\" sum of two footprints, where \u2295\nis an associative and commutative operator with several properties such as \u03c60 \u22a2\nstorech v \u21d2 \u03c61 6\u22a2 loadch v, \u03c60 \u22a2 loadch v \u21d2 \u03c6 \u22a2 loadch v and \u03c60 \u22a2 storech v \u21d2\n4\n\n\fx \u2208 dom \u03c1\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 Evar (x) \u21d3 \u03c1(x)\n\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 Eval (v) \u21d3 v\n\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 el \u21d3 vl\n\u03a8 ; sp \u22a2 op(vl) \u21d3eval operation v\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 Eop (op, el) \u21d3 v\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 e1 \u21d3 v1\n\u03c6 \u22a2 loadch v1\n\u03a8 ; (sp; \u03c1; \u03c6; m) \u22a2 Eload (ch, e1 ) \u21d3 v\n\nch\n\nm \u22a2 v1 7\u2192 v\n\nFig. 1. Expression evaluation rules\n\n\u03c6 \u22a2 storech v. One can think of \u03c6 as a set of fractional permissions [7], with 0\nmeaning no permission, 0 < x < 1 permitting read, and 1 giving read/write\npermission. A store permission can be split into two or more load permissions,\nwhich can be reconstituted to obtain a store permission. Instead of fractions, we\nuse a more general and powerful model of sharable permissions similar to one\ndescribed by Parkinson [16, Ch. 5].\nMost previous models of Separation Logic (e.g., Ishtiaq and O'Hearn [9])\nrepresent heaps as partial functions that can be combined with an operator like\n\u2295. Of course, a partial function can be represented as a pair of a domain set\nand a total function. Similarly, we represent heaps as a footprint plus a Cminor\nmemory; this does not add any particular difficulty to the soundness proofs for\nour Separation Logic.\nTo perform arithmetic and other operations, in the third rule of Fig. 1, the\njudgment \u03a8 ; sp \u22a2 op(vl ) \u21d3eval operation v takes an operator op applied to a list of\nvalues vl and (if vl contains appropriate values) produces some value v. Operators\nthat access global names and local stack-blocks make use of \u03a8 and sp respectively\nto return the address of a global name or a local stack-block address.\nStates. We shall bundle together (sp; \u03c1; \u03c6; m) and call it the state, written as \u03c3.\nWe write \u03a8 ; \u03c3 \u22a2 e \u21d3 v to mean \u03a8 ; (sp \u03c3 ; \u03c1\u03c3 ; \u03c6\u03c3 ; m\u03c3 ) \u22a2 e \u21d3 v.\nNotation. We write \u03c3[:= \u03c1\u2032 ] to mean the state \u03c3 with its environment component\n\u03c1 replaced by \u03c1\u2032 , and so on (e.g. see rules 2 and 3 of Fig. 2 in Section 4).\nch\n\nFact. \u03a8 ; sp \u22a2 op(vl ) \u21d3eval operation v and m \u22a2 v1 7\u2192 v are both deterministic\nrelations, i.e. functions.\nLemma 1. \u03a8 ; \u03c3 \u22a2 e \u21d3 v is a deterministic relation. (Trivial by inspection.)\nLemma 2. For any value v, there is an expression e such that \u2200\u03c3. (\u03a8 ; \u03c3 \u22a2 e \u21d3 v).\nProof. Obvious; e is simply Eval v. But it is important nonetheless: reasoning\nabout programs by rewriting and by Hoare Logic often requires this property, and\nit was absent from Leroy's Cminor for Vundef and Vptr values. \u0004\nAn expression may fetch from several different memory locations, or from\nthe same location several times. Because \u21d3 is deterministic, we cannot model a\nsituation where the memory is updated by another thread after the first fetch\n5\n\n\fand before the second. But we want a semantics that describes real executions\non real machines. The solution is to evaluate expressions in a setting where we\ncan guarantee noninterference. We will do this (in our extension to Concurrent\nCminor) by guaranteeing that the footprints \u03c6 of different threads are disjoint.\nErased Expression Evaluation. The Cminor compiler (CompCert) is proved correct w.r.t. an operational semantics that does not use footprints. Any program\nthat successfully evaluates with footprints will also evaluate ignoring footprints.\nThus, for sequential programs where we do not need noninterference, it is sound\nto prove properties in a footprint semantics and compile in an erased semantics.\nWe formalize and prove this in the full technical report [4].\n\n3\n\nSmall-step Statement Semantics\n\nThe statements of sequential Cminor are:\ns : stmt ::= x := e | [e1 ]ch :=e2 | loop s | block s | exit n\n| call xl e el | return el | s1 ; s2 | if e then s1 else s2 | skip.\nThe assignment x := e puts the value of e into the local variable x. The store\n[e1 ]ch :=e2 puts (the value of) e2 into the memory-chunk ch at address given\nby (the value of) e1 . (Local variables are not addressable; global variables and\nheap locations are memory addresses.) To model exits from nested loops, block s\nruns s, which should not terminate normally but which should exit n from the\n(n+1)th enclosing block, and loop s repeats s infinitely or until it returns or exits.\ncall xl e el calls function e with parameters (by value) el and results returned back\ninto the variables xl. return el evaluates and returns a sequence of results, (s1 ; s2 )\nexecutes s1 followed by s2 (unless s1 returns or exits), and the statements if and\nskip are as the reader might expect.\nCombined with infinite loops and if statements, blocks and exits suffice to\nexpress efficiently all reducible control-flow graphs, notably those arising from\nC loops. The C statements break and continue are translated as appropriate exit\nstatements. Blazy et al. [5] detail the translation of these C statements into\nCminor.\nFunction Definitions. A program \u03a8 comprises two mappings: a mapping from\nfunction names to memory blocks (i.e., abstract addresses), and a mapping from\nmemory blocks to function definitions. Each function definition may be written as\nf = (xl , yl , n, s), where params(f ) = xl is a list of formal parameters, locals(f ) =\nyl is a list of local variables, stackspace(f ) = n is the size of the local stack-block\nto which sp points, and the statement body(f ) = s is the function body.\nOperational Semantics. Our small-step semantics for statements is based on\ncontinuations, mainly to allow a uniform representation of statement execution\nthat facilitates the design of lemmas. Such a semantics also avoids all search\n6\n\n\frules (congruence rules), which avoids induction over search rules in both the\nHoare-Logic soundness proof and the compiler correctness proof.3\nDefinition 1. A continuation k has a state \u03c3 and a control stack \u03ba. There are\nsequential control operators to handle local control flow (Kseq, written as *), intraprocedural control flow (Kblock), and function-return (Kcall); this last carries\nnot only a control aspect but an activation record of its own. The control operator\nKstop represents the safe termination of the computation.\n\u03ba : control ::= Kstop | s * \u03ba | Kblock \u03ba | Kcall xl f sp \u03c1 \u03ba\nk : continuation ::= (\u03c3, \u03ba)\nThe sequential small-step function takes the form \u03a8 \u22a2 k 7\u2212\u2192 k \u2032 (see Fig. 2),\nand we define as usual its reflexive transitive closure 7\u2212\u2192\u2217 . As in C, there is no\nboolean type in Cminor. In Fig. 2, the predicate is true v holds if v is a pointer or\na nonzero integer; is false holds only on 0. A store statement [e1 ]ch :=e2 requires\nthe corresponding store permission \u03c6\u03c3 \u22a2 storech v1 .\nGiven a control stack block s * \u03ba, the small-step execution of the block statement block s enters that block: s becomes the next statement to execute and the\ncontrol stack becomes s * Kblock \u03ba.\nExit statements are only allowed from blocks that have been previously entered. For that reason, in the two rules for exit statements, the control stack\nends with (Kblock \u03ba) control. A statement (exit n) terminates the (n + 1)th enclosing block statements. In such a block, the stack of control sequences s1 * * * sj\nfollowing the exit statement is not executed. Let us note that this stack may be\nempty if the exit statement is the last statement of the most enclosing block.\nThe small-step execution of a statement (exit n) exits from only one block (the\nmost enclosing one). Thus, the execution of an (exit 0) statement updates the\ncontrol stack (exit 0 * s1 * * * * sj * Kblock \u03ba) into \u03ba. The execution of an (exit n + 1)\nstatement updates the control stack (exit (n+1)*s1 ** * * sj *Kblock \u03ba) into exit n*\u03ba.\nLemma 3. If \u03a8 ; \u03c3 \u22a2 e \u21d3 v then \u03a8 \u22a2 (\u03c3, (x := e) * \u03ba) 7\u2212\u2192 k \u2032 iff \u03a8 \u22a2 (\u03c3, (x :=\nEval v) * \u03ba)) 7\u2212\u2192 k \u2032 (and similarly for other statements containing expressions).\nProof. Trivial: expressions have no side effects. A convenient property nonetheless, and not true of Leroy's original Cminor. \u0004\nDefinition 2. A continuation k = (\u03c3, \u03ba) is stuck if \u03ba 6= Kstop and there does\nnot exist k \u2032 such that \u03a8 \u22a2 k 7\u2212\u2192 k \u2032 .\nDefinition 3. A continuation k is safe (written as \u03a8 \u22a2 safe(k)) if it cannot\nreach a stuck continuation in the sequential small-step relation 7\u2212\u2192\u2217 .\n3\n\nWe have proved in Coq the equivalence of this small-step semantics with the big-step\nsemantics of CompCert (for programs that terminate).\n\n7\n\n\f\u03a8 ; \u03c3 \u22a2 e \u21d3 v \u03c1\u2032 = \u03c1\u03c3 [x := v]\n\u03a8 \u22a2 (\u03c3, (x := e) * \u03ba) 7\u2212\u2192 (\u03c3[:= \u03c1\u2032 ], \u03ba)\n\n\u03a8 \u22a2 (\u03c3, (s1 ; s2 ) * \u03ba) 7\u2212\u2192 (\u03c3, s1 * s2 * \u03ba)\n\u03a8 ; \u03c3 \u22a2 e1 \u21d3 v1\n\n\u03a8 ; \u03c3 \u22a2 e2 \u21d3 v2\n\nch\n\nm\u2032 = m\u03c3 [v1 := v2 ]\n\n\u03c6\u03c3 \u22a2 storech v1\n\u2032\n\n\u03a8 \u22a2 (\u03c3, ([e1 ]ch :=e2 ) * \u03ba) 7\u2212\u2192 (\u03c3[:= m ], \u03ba)\n\u03a8; \u03c3 \u22a2 e \u21d3 v\nis true v\n\u03a8 \u22a2 (\u03c3, (if e then s1 else s2 ) * \u03ba) 7\u2212\u2192 (\u03c3, s1 * \u03ba)\n\u03a8; \u03c3 \u22a2 e \u21d3 v\nis false v\n\u03a8 \u22a2 (\u03c3, (if e then s1 else s2 ) * \u03ba) 7\u2212\u2192 (\u03c3, s2 * \u03ba)\n\u03a8 \u22a2 (\u03c3, (loop s) * \u03ba) 7\u2212\u2192 (\u03c3, s * loop s * \u03ba)\n\n\u03a8 \u22a2 (\u03c3, skip * \u03ba) 7\u2212\u2192 (\u03c3, \u03ba)\n\n\u03a8 \u22a2 (\u03c3, (block s) * \u03ba) 7\u2212\u2192 (\u03c3, s * Kblock \u03ba)\n\nj\u22651\n\u03a8 \u22a2 (\u03c3, exit 0 * s1 * * * * sj * Kblock \u03ba) 7\u2212\u2192 (\u03c3, \u03ba)\nj\u22651\n\u03a8 \u22a2 (\u03c3, exit (n + 1) * s1 * * * * sj * Kblock \u03ba) 7\u2212\u2192 (\u03c3, exit n * \u03ba)\nFig. 2. Sequential small-step relation. We omit here call and return, which are in the\nfull technical report [4].\n\n4\n\nSeparation Logic\n\nHoare Logic uses triples {P } s {Q} where P is a precondition, s is a statement of\nthe programming language, and Q is a postcondition. The assertions P and Q are\npredicates on the program state. The reasoning on memory is inherently global.\nSeparation Logic is an extension of Hoare Logic for programs that manipulate\npointers. In Separation Logic, reasoning is local [15]; assertions such as P and\nQ describe properties of part of the memory, and {P } s {Q} describes changes\nto part of the memory. We prove the soundness of the Separation Logic via a\nshallow embedding, that is, we give each assertion a semantic meaning in Coq.\nWe have P, Q : assert where assert = prog \u2192 state \u2192 Prop. So P \u03a8 \u03c3 is a\nproposition of logic and we say that \u03c3 satisfies P .\nAssertion Operators. In Fig. 3, we define the usual operators of Separation Logic:\nthe empty assertion emp, separating conjunction \u2217, disjunction \u2228, conjunction\n\u2227, implication \u21d2, negation \u00ac, and quantifier \u2203. A state \u03c3 satisfies P \u2217 Q if its\nfootprint \u03c6\u03c3 can be split into \u03c61 and \u03c62 such that \u03c3[:= \u03c61 ] satisfies P and\n\u03c3[:= \u03c62 ] satisfies Q. We also define some novel operators such as expression\nevaluation e \u21d3 v and base-logic propositions \u2308A\u2309.\nO'Hearn and Reynolds specify Separation Logic for a little language in which\nexpressions evaluate independently of the heap [15]. That is, their expressions\naccess only the program variables and do not even have read side effects on the\n8\n\n\femp =def \u03bb\u03a8 \u03c3. \u03c6\u03c3 = \u2205\nP \u2217 Q =def \u03bb\u03a8 \u03c3. \u2203\u03c61 .\u2203\u03c62 . \u03c6\u03c3 = \u03c61 \u2295 \u03c62 \u2227 P (\u03c3[:= \u03c61 ]) \u2227 Q(\u03c3[:= \u03c62 ])\nP \u2228 Q =def \u03bb\u03a8 \u03c3. P \u03c3 \u2228 Q\u03c3\nP \u2227 Q =def \u03bb\u03a8 \u03c3. P \u03c3 \u2227 Q\u03c3\nP \u21d2 Q =def \u03bb\u03a8 \u03c3. P \u03c3 \u21d2 Q\u03c3\n\u00acP =def \u03bb\u03a8 \u03c3. \u00ac(P \u03c3)\n\u2203z.P =def \u03bb\u03a8 \u03c3. \u2203z. P \u03c3\n\u2308A\u2309 =def \u03bb\u03a8 \u03c3. A\n\nwhere \u03c3 does not appear free in A\nfalse =def \u2308False\u2309\n\ntrue =def \u03bb\u03a8 \u03c3.True\n\ne \u21d3 v =def emp \u2227 \u2308pure(e)\u2309 \u2227 \u03bb\u03a8 \u03c3. (\u03a8 ; \u03c3 \u22a2 e \u21d3 v)\n\u2308e\u2309expr =def \u2203v. e \u21d3 v \u2227 \u2308is true v\u2309\nint\n\nfloat\n\ndefined(e) =def \u2308e == e\u2309expr \u2228 \u2308e == e\u2309expr\nch\n\nch\n\ne1 7\u2192 e2 =def \u2203v1 .\u2203v2 .(e1 \u21d3 v1 ) \u2227 (e2 \u21d3 v2 ) \u2227 (\u03bb\u03c3, m\u03c3 \u22a2 v1 7\u2192 v2 \u2227 \u03c6\u03c3 \u22a2 storech v1 ) \u2227 defined(v2 )\nFig. 3. Main operators of Separation Logic\n\nmemory. Memory reads are done by a command of the language, not within\nexpressions. In Cminor we relax this restriction; expressions can read the heap.\nBut we say that an expression is pure if it contains no Eload operators-so that\nit cannot read the heap.\nIn Hoare Logic one can use expressions of the programming language as\nassertions-there is an implicit coercion. We write the assertion e \u21d3 v to mean\nthat expression e is pure and evaluates to value v in the operational semantics.\nThis is an expression of Separation Logic, in contrast to \u03a8 ; \u03c3 \u22a2 e \u21d3 v which is\na judgment in the underlying logic. In a previous experiment, our Separation\nLogic permitted impure expressions in e \u21d3 v. But, this complicated the proofs\nunnecessarily. Having emp \u2227 \u2308pure(e)\u2309 in the definition of e \u21d3 v leads to an\neasier-to-use Separation Logic.\nHoare Logic traditionally allows expressions e of the programming language\nto be used as expressions of the program logic. We will define explicitly \u2308e\u2309expr\nto mean that e evaluates to a true value (i.e. a nonzero integer or non-null\npointer). Following Hoare's example, we will usually omit the \u2308 \u2309expr braces in\nour Separation Logic notation.\nint\n\nCminor's integer equality operator, which we will write as e1 == e2 , applies\nto integers or pointers, but in several cases it is \"stuck\" (expression evaluation\ngives no result): when comparing a nonzero integer to a pointer; when comparing\nint\n\nVundef or Vfloat(x) to anything. Thus we can write the assertion \u2308e == e\u2309expr\nint\n\n(or just write e == e) to test that e is a defined integer or pointer in the current\nfloat\n\nstate, and there is a similar operator e1 == e2 .\nFinally, we have the usual Separation Logic singleton \"maps-to\", but annoch\ntated with a chunk-type ch. That is, e1 7\u2192 e2 means that e1 evaluates to v1 , e2\nevaluates to v2 , and at address v1 in memory there is a defined value v2 of the\ngiven chunk-type. Let us note that in this definition, defined(v1 ) is implied by\n9\n\n\fthe third conjunct. defined(v2 ) is a design decision. We could leave it out and\nhave a slightly different Separation Logic.\nThe Hoare Sextuple. Cminor has commands to call functions, to exit (from\na block), and to return (from a function). Thus, we extend the Hoare triple\n{P } s {Q} with three extra contexts to become \u0393 ; R; B \u22a2 {P }s{Q} where:\n\u0393 : assert describes context-insensitive properties of the global environment;\nR : list val \u2192 assert is the return environment, giving the current function's postcondition as a predicate on the list of returned values; and\nB : nat \u2192 assert is the block environment giving the exit conditions of each\nblock statement in which the statement s is nested.\nMost of the rules of sequential Separation Logic are given in Fig. 4. In this\npaper, we omit the rules for return and call, which are detailed in the full technical report. Let us note that the \u0393 context is used to update global function\nnames, none of which is illustrated in this paper.\nP \u21d2 P\u2032\n\n\u0393 ; R; B \u22a2 {P \u2032 }s{Q\u2032 }\n\u0393 ; R; B \u22a2 {P }s{Q}\n\nQ\u2032 \u21d2 Q\n\n\u0393 ; R; B \u22a2 {P }skip{P }\n\n\u0393 ; R; B \u22a2 {P }s1 {P \u2032 }\n\u0393 ; R; B \u22a2 {P \u2032 }s2 {Q}\n\u0393 ; R; B \u22a2 {P }s1 ; s2 {Q}\n\u03c1\u2032 = \u03c1\u03c3 [x := v]\nP = (\u2203v. e \u21d3 v \u2227 \u03bb\u03c3. Q \u03c3[:= \u03c1\u2032 ])\n\u0393 ; R; B \u22a2 {P }x := e{Q}\npure (e)\n\npure (e2 )\n\nch\n\nP = (e 7\u2192 e2 \u2227 defined(e1 ))\nch\n\n\u0393 ; R; B \u22a2 {P }[e]ch :=e1 {e 7\u2192 e1 }\npure (e)\n\n\u0393 ; R; B \u22a2 {P \u2227 e}s1 {Q}\n\u0393 ; R; B \u22a2 {P \u2227 \u00ace}s2 {Q}\n\u0393 ; R; B \u22a2 {P }if e then s1 else s2 {Q}\n\n\u0393 ; R; B \u22a2 {I}s{I}\n\u0393 ; R; B \u22a2 {I}loop s{false}\n\n\u0393 ; R; Q * B \u22a2 {P }s{false}\n\u0393 ; R; B \u22a2 {P }block s{Q}\n\n\u0393 ; R; B \u22a2 {B(n)}exit n{false}\n\u0393 ; R; B \u22a2 {P }s{Q}\nmodified vars(s) \u2229 free vars(A) = \u2205\n\u0393 ; (\u03bbvl.A \u2217 R(vl)); (\u03bbn.A \u2217 B(n)) \u22a2 {A \u2217 P }s{A \u2217 Q}\nFig. 4. Axiomatic Semantics of Separation Logic (without call and return)\n\nThe rule for [e]ch :=e1 requires the same store permission than the small-step\nch\n\nrule, but in Fig. 4, the permission is hidden in the definition of e 7\u2192 e2 . The\nrules for [e]ch :=e1 and if e then s1 else s2 require that e be a pure expression. To\nreason about an such statements where e is impure, one reasons by program\ntransformation using the following rules. It is not necessary to rewrite the actual\n10\n\n\fsource program, it is only the local reasoning that is by program transformation.\nx, y not free in e, e1 , Q\n\n\u0393 ; R; B \u22a2 {P } x := e; y := e1 ; [x]ch :=y {Q}\n\u0393 ; R; B \u22a2 {P }[e]ch :=e1 {Q}\n\nx not free in s1 , s2 , Q\n\u0393 ; R; B \u22a2 {P } x := e; if x then s1 else s2 {Q}\n\u0393 ; R; B \u22a2 {P } if e then s1 else s2 {Q}\nThe statement exit i exits from the (i + 1)th enclosing block. A block environment B is a sequence of assertions B0 , B1 , . . . , Bk\u22121 such that (exit i) is safe as\nlong as the precondition Bi is satisfied. We write nilB for the empty block envi\u2032\nronment and B \u2032 = Q * B for the environment such that B0\u2032 = Q and Bi+1\n= Bi .\nGiven a block environment B, a precondition P and a postcondition Q, the\naxiomatic semantics of a (block s) statement consists in executing some statements of s given the same precondition P and the block environment Q * B\n(i.e. each existing block nesting is incremented). The last statement of s to be\nexecuted is an exit statement that yields the false postcondition. An (exit n)\nstatement is only allowed from a corresponding enclosing block, i.e. the precondition B(n) must exist in the block environment B and it is the precondition of\nthe (exit n) statement.\nFrame Rules. The most important feature of Separation Logic is the frame rule,\nusually written\n{P } s {Q}\n{A \u2217 P } s {A \u2217 Q}\nThe appropriate generalization of this rule to our language with control flow is\nthe last rule of Fig. 4. We can derive from it a special frame rule for simple\nstatements s that do not exit or return:\n\u2200R, B.(\u0393 ; R; B \u22a2 {P } s {Q})\nmodified vars(s) \u2229 free vars(A) = \u2205\n\u0393 ; R; B \u22a2 {A \u2217 P } s {A \u2217 Q}\nFree Variables. We use a semantic notion of free variables: x is not free in assertion A if, in any two states where only the binding of x differs, A gives the\nsame result. However, we found it necessary to use a syntactic (inductive) definition of the variables modified by a command. One would think that command c\n\"modifies\" x if there is some state such that by the time c terminates or exits, x\nhas a different value. However, this definition means that the modified variables\nof if false then B else C are not a superset of the modified variables of C;\nthis lack of an inversion principle led to difficulty in proofs.\nAuxiliary Variables. It is typical in Hoare Logic to use auxiliary variables to\nrelate the pre- and postconditions, e.g., the variable a in {x = a} x := x + 1 {x =\na + 1}. In our shallow embedding of Hoare Logic in Coq, the variable a is a\nCoq variable, not a Cminor variable; formally, the user would prove in Coq\nthe proposition, \u2200a, (\u0393 ; R; B \u22a2 {P }s{Q}) where a may appear free in any of\n11\n\n\f\u0393, R, B, P, s, Q. The existential assertion \u2203z.Q is useful in conjunction with this\ntechnique.\nAssertions about functions require special handling of these quantified auxiliary variables. The assertion that some value f is a function with precondition\nP and postcondition Q is written f : \u2200x1 \u2200x2 . . . \u2200xn , {P }{Q} where P and Q\nare functions from value-list to assertion, each \u2200 is an operator of our separation\nlogic that binds a Coq variable xi using higher-order abstract syntax.\nApplication. In the full technical report [4], we show how the Separation Logic\n(i.e. the rules of Fig. 4) can be used to prove partial correctness properties of\nprograms, with the classical in-place list-reversal example. Such proofs rely on\na set of tactics, that we have written in the tactic definition language of Coq, to\nserve as a proof assistant for Cminor Separation Logic proofs [3].\n\n5\n\nSoundness of Separation Logic\n\nSoundness means not only that there is a model for the logic, but that the\nmodel is the operational semantics for which the compiler guarantees correctness!\nIn principle we could prove soundness by syntactic induction over the Hoare\nLogic rules, but instead we will give a semantic definition of the Hoare sextuple\n\u0393 ; R; B \u22a2 {P } s {Q}, and then prove each of the Hoare rules as a derived lemma\nfrom this definition.\nA simple example of semantic specification is that the Hoare Logic P \u21d2 Q\nis defined, using the underlying logical implication, as \u2200\u03a8 \u03c3. P \u03a8 \u03c3 \u21d2 Q \u03a8 \u03c3.\nFrom this, one could prove soundness of the Hoare Logic rule on the left (where\nthe \u21d2 is a symbol of Hoare Logic) by expanding the definitions into the lemma\non the right (where the \u21d2 is in the underlying logic), which is clearly provable\nin higher-order logic:\n\u2200\u03a8 \u03c3.(P \u03a8 \u03c3 \u21d2 Q\u03a8 \u03c3) \u2200\u03a8 \u03c3.(Q\u03a8 \u03c3 \u21d2 R\u03a8 \u03c3)\nP \u21d2Q\nQ\u21d2R\nP \u21d2R\n\u2200\u03a8 \u03c3.(P \u03a8 \u03c3 \u21d2 R\u03a8 \u03c3)\n\u2032\n\u223c \u03c3 \u2032 ) if\nDefinition 4. (a) Two states \u03c3 and \u03c3 are equivalent (written as \u03c3 =\nthey have the same stack pointer, extensionally equivalent environments, identical footprints, and if the footprint-visible portions of their memories are the\nsame. (b) An assertion is a predicate on states that is extensional over equivalent\nenvironments (in Coq it is a dependent product of a predicate and a proof of\nextensionality).\nDefinition 5. For any control \u03ba, we define the assertion safe \u03ba to mean that\nthe combination of \u03ba with the current state is safe:\nsafe \u03ba =def \u03bb\u03a8 \u03c3. \u2200\u03c3 \u2032 . (\u03c3 \u223c\n= \u03c3 \u2032 \u21d2 \u03a8 \u22a2 safe (\u03c3 \u2032 , \u03ba))\nDefinition 6. Let A be a frame, that is, a closed assertion (i.e. one with no free\nCminor variables). An assertion P guards a control \u03ba in the frame A (written\nas P \u2293\n\u2294A \u03ba) means that whenever A \u2217 P holds, it is safe to execute \u03ba. That is,\nP\u2293\n\u2294A \u03ba =def A \u2217 P \u21d2 safe \u03ba.\n12\n\n\fWe extend this notion to say that a return-assertion R (a function from valuelist to assertion) guards a return, and a block-exit assertion B (a function from\nblock-nesting level to assertions) guards an exit:\nR\u2293\nr A \u03ba =def \u2200vl .R(vl ) \u2293\n\u2294\n\u2294A return vl * \u03ba\n\nB\u2293\nb A \u03ba =def \u2200n.B(n) \u2293\n\u2294\n\u2294A exit n * \u03ba\n\nLemma 4. If P \u2293\n\u2294A s1 * s2 * \u03ba then P \u2293\n\u2294A (s1 ; s2 ) * \u03ba.\nLemma 5. If R \u2293\nr A \u03ba then \u2200s, R \u2293\nr A s * \u03ba.\n\u2294\n\u2294\n\nIf B \u2293\nb A \u03ba then \u2200s, B \u2293\nb A s * \u03ba.\n\u2294\n\u2294\n\nDefinition 7 (Frame). A frame is constructed from the global environment \u0393 ,\nan arbitrary frame assertion A, and a statement s, by the conjunction of \u0393 with\nthe assertion A closed over any variable modified by s:\nframe(\u0393, A, s) =def \u0393 \u2217 closemod(s, A)\nDefinition 8 (Hoare sextuples). The Hoare sextuples are defined in \"continuation style,\" in terms of implications between continuations, as follows:\n\u0393 ; R; B \u22a2 {P } s {Q} =def \u2200A, \u03ba.\nb frame(\u0393,A,s) \u03ba \u2227 Q \u2293\nR\u2293\nr frame(\u0393,A,s) \u03ba \u2227 B \u2293\n\u2294frame(\u0393,A,s) s * \u03ba\n\u2294frame(\u0393,A,s) \u03ba \u21d2 P \u2293\n\u2294\n\u2294\nFrom this definition we prove the rules of Fig. 4 as derived lemmas.\nIt should be clear from the definition-after one gets over the backward\nnature of the continuation transform-that the Hoare judgment specifies partial\ncorrectness, not total correctness. For example, if the statement s infinitely loops,\nthen the continuation (\u03c3, s * \u03ba) is automatically safe, and therefore P \u2293\n\u2294A s * \u03ba\nalways holds. Therefore the Hoare tuple \u0393 ; R; B \u22a2 {P }s{Q} will hold for that\ns, regardless of \u0393, R, B, P, Q.\nSequence. The soundness of the sequence statement is the proof that if the\nhypotheses H1 : \u0393 ; R; B \u22a2 {P } s1 {P \u2032 } and H2 : \u0393 ; R; B \u22a2 {P \u2032 } s2 {Q} hold,\nthen we have to prove Goal : \u0393 ; R; B \u22a2 {P } s1 ; s2 {Q} (see Fig. 4). If we unfold\nthe definition of the Hoare sextuples, H1 , H2 and Goal become:\n\n(\u2200A, \u03bai )\n\n(\u2200A, \u03ba)\n\nR\u2293\nr frame(\u0393,A,si ) \u03bai\n\u2294\n\n\u2032\nB\u2293\nb frame(\u0393,A,si ) \u03bai P \u2293\n\u2294frame(\u0393,A,si ) \u03bai\n\u2294\nHi , i = 1, 2\n\u2293frame(\u0393,A,si ) si * \u03bai\nP\u2294\n\nR\u2293\nr frame(\u0393,A,(s1 ;s2 )) \u03ba\n\u2294\n\nQ\u2293\n\u2294frame(\u0393,A,(s1 ;s2 )) \u03ba\n\nB\u2293\nb frame(\u0393,A,(s1 ;s2 )) \u03ba\n\u2294\nP\u2293\n\u2294frame(\u0393,A,(s1 ;s2 )) (s1 ; s2 ) * \u03ba\n\nWe prove P \u2293\n\u2294frame(\u0393,A,(s1 ;s2 )) (s1 ; s2 ) * k using Lemma 4:4\nR\u2293\nr k\n\u2294\nLm. 5\n\u2293\nR\u2294\nr s2 * k\n\n4\n\nB\u2293\nb k\n\u2294\nLm. 5\n\u2293\nB\u2294\nb s2 * k\nP\u2293\n\u2294 s1 * s2 * k\nP\u2293\n\u2294 (s1 ; s2 ) * k\n\nR\u2293\nr k\n\u2294\n\nB\u2293\nb k Q\u2293\n\u2294k\n\u2294\nH2\nP \u2293\n\u2294 s2 * k\n\u2032\n\nH1\n\nLm. 4\n\n\u2293 without a subscript;\nWe will elide the frames from proof sketches by writing \u2294\nthis particular proof relies on a lemma that closemod(s1 , closemod((s1 ; s2 ), A)) =\nclosemod((s1 ; s2 ), A).\n\n13\n\nGoal\n\n\fLoop Rule. The loop rule turns out to be one of the most difficult ones to prove. A\nloop continues executing until the loop-body performs an exit or return. If loop s\nexecutes n steps, then there will be 0 or more complete iterations of n1 , n2 , . . .\nsteps, followed by j steps into the last iteration. Then either there is an exit\n(or return) from the loop, or the loop will keep going. But if the exit is from an\ninner-nested block, then it does not terminate the loop (or even this iteration).\nThus we need a formal notion of when a statement exits.\nConsider the statement s = if b then exit 2 else (skip; x := y), executing in state\n\u03c3. Let us execute n steps into s, that is, \u03a8 \u22a2 (\u03c3, s * \u03ba) 7\u2212\u2192n (\u03c3 \u2032 , \u03ba\u2032 ). If n is small,\nthen the behavior should not depend on \u03ba; only when we \"emerge\" from s is\n\u03ba important. In this example, if \u03c1\u03c3 b is a true value, then as long as n \u2264 1 the\nstatement s can absorb n steps independent of \u03ba; if \u03c1\u03c3 b is a false value, then s can\nabsorb up to 3 steps. To reason about absorption, we define the concatenation\n\u03ba1 \u25e6 \u03ba2 of a control prefix \u03ba1 and a control \u03ba2 as follows:\nKstop \u25e6 \u03ba =def \u03ba\n(Kblock \u03ba\u2032 ) \u25e6 \u03ba =def Kblock (\u03ba\u2032 \u25e6 \u03ba)\n\u2032\n\u2032\n(s * \u03ba ) \u25e6 \u03ba =def s * (\u03ba \u25e6 \u03ba)\n(Kcall xl f sp \u03c1 \u03ba\u2032 ) \u25e6 \u03ba =def Kcall xl f sp \u03c1 (\u03ba\u2032 \u25e6 \u03ba)\nKstop is the empty prefix; Kstop \u25e6 \u03ba does not mean \"stop,\" it means \u03ba.\nDefinition 9 (absorption). A statement s in state \u03c3 absorbs n steps (written\nas absorb(n, s, \u03c3)) iff \u2200j \u2264 n. \u2203\u03baprefix .\u2203\u03c3 \u2032 . \u2200\u03ba. \u03a8 \u22a2 (\u03c3, s * \u03ba) 7\u2212\u2192j (\u03c3 \u2032 , \u03baprefix \u25e6 \u03ba).\nExample 1. An exit statement by itself absorbs no steps (it immediately uses its\ncontrol-tail), but block (exit 0) can absorb the 2 following steps:\n\u03a8 \u22a2 (\u03c3, block (exit 0) * \u03ba) 7\u2212\u2192 (\u03c3, exit 0 * Kblock \u03ba) 7\u2212\u2192 (\u03c3, \u03ba)\nLemma 6. 1. absorb(0, s, \u03c3).\n2. absorb(n + 1, s, \u03c3) \u21d2 absorb(n, s, \u03c3).\n3. If \u00acabsorb(n, s, \u03c3), then \u2203i < n.absorb(i, s, \u03c3) \u2227 \u00acabsorb(i + 1, s, \u03c3). We say\nthat s absorbs at most i steps in state \u03c3.\nDefinition 10. We write (s; )n s\u2032 to mean s; s; . . . ; s; s\u2032 .\n| {z }\nn\n\n\u0393 ; R; B \u22a2 {I}s{I}\nLemma 7.\n\u0393 ; R; B \u22a2 {I}(s; )n loop skip{false}\nProof. For n = 0, the infinite-loop (loop skip) satisfies any precondition for parb \u03ba; by the induction hypothesis\ntial correctness. For n + 1, assume \u03ba, R \u2293\nr \u03ba, B \u2293\n\u2294\n\u2294\nn\nr (s; ) loop skip*\u03ba\nb \u03ba) we know I \u2293\n(with R \u2293\nr \u03ba and B \u2293\n\u2294\n\u2294 (s; )n loop skip*\u03ba. We have R \u2293\n\u2294\n\u2294\nn\nand B \u2293\nb (s; ) loop skip * \u03ba by Lemma 5. We use the hypothesis \u0393 ; R; B \u22a2 {I}s{I}\n\u2294\nto augment the result to I \u2293\n\u2294 (s; (s; )n loop skip) * \u03ba. \u0004\nTheorem 1.\n\n\u0393 ; R; B \u22a2 {I}s{I}\n\u0393 ; R; B \u22a2 {I}loop s{false}\n\n\u2293 loop s * \u03ba, assume \u03c3 and I\u03c3\n\u2293\nb \u03ba. To prove I \u2294\nProof. Assume \u03ba, R \u2294\nr \u03ba, B \u2293\n\u2294\nand prove safe (\u03c3, loop s * \u03ba). We must prove that for any n, after n steps we\nare not stuck. We unfold the loop n times, that is, we use Lemma 7 to show\n14\n\n\fsafe (\u03c3, (s; )n loop skip * \u03ba). We can show that if this is safe for n steps, so is\nloop s * \u03ba by the principle of absorption. Either s absorbs n steps, in which case\nwe are done; or s absorbs at most j < n steps, leading to a state \u03c3 \u2032 and a control\n(respectively) \u03baprefix \u25e6 (s; )n\u22121 loop skip * \u03ba or \u03baprefix \u25e6 loop s * \u03ba. Now, because s\ncannot absorb j + 1 steps, we know that either \u03baprefix is empty (because s has\nterminated normally) or \u03baprefix starts with a return or exit, in which case we\nescape (resp. past the loop skip or the loop s) into \u03ba. If \u03baprefix is empty then we\napply strong induction on the case n \u2212 j steps; if we escape, then (\u03c3 \u2032 , \u03ba) is safe\niff (\u03c3, loop s * \u03ba) is safe. (For example, if j = 0, then it must be that s = return\nor s = exit , so in one step we reach \u03baprefix \u25e6 (loop s * \u03ba) with \u03baprefix = return or\n\u03baprefix = exit .) \u0004\n\n6\n\nSequential Reasoning about Sequential Features\n\nConcurrent Cminor, like most concurrent programming languages used in practice, is a sequential programming language with a few concurrent features (locks\nand threads) added on. We would like to be able to reason about the sequential\nfeatures using purely sequential reasoning. If we have to reason about all the\nmany sequential features without being able to assume such things as determinacy and sequential control, then the proofs become much more difficult.\nOne would expect this approach to run into trouble because critical assumptions underlying the sequential operational semantics would not hold in the\nconcurrent setting. For example, on a shared-memory multiprocessor we cannot assume that (x:=x+1; x:=x+1) has the same effect as (x:=x+2); and on\nany real multiprocessor we cannot even assume sequential consistency-that the\nsemantics of n threads is some interleaving of the steps of the individual threads.\nWe will solve this problem in several stages. Stage 1 of this plan is the current\npaper. Stages 2, 3, and 4 are work in progress; the remainder is future work.\n1. We have made the language, the Separation Logic, and our proof extensible:\nthe set of control-flow statements is fixed (inductive) but the set of straightline statements is extensible by means of a parameterized module in Coq.\nWe have added to each state \u03c3 an oracle which predicts the meaning of the\nextended instruction (but which does nothing on the core language). All the\nproofs we have described in this paper are on this extensible language.\n2. We define spawn, lock, and unlock as extended straight-line statements. We\ndefine a concurrent small-step semantics that assumes noninterference (and\ngets \"stuck\" on interference).\n3. From this semantics, we calculate a single-thread small-step semantics equipped with the oracle that predicts the effects of synchronizations.\n4. We define a Concurrent Separation Logic for Cminor as an extension of the\nSequential Separation Logic. Its soundness proof uses the sequential soundness proof as a lemma.\n5. We will use Concurrent Separation Logic to guarantee noninterference of\nsource programs. Then (x:=x+1; x:=x+1) will have the same effect as (x:=x+2).\n15\n\n\f6. We will prove that the Cminor compiler (CompCert) compiles each footprintsafe source thread into an equivalent footprint-safe machine-language thread.\nThus, noninterfering source programs will produce noninterfering machinelanguage programs.\n7. We will demonstrate, with respect to a formal model of weak-memoryconsistency microprocessor, that noninterfering machine-language programs\ngive the same results as they would on a sequentially consistent machine.\n\n7\n\nThe Machine-checked Proof\n\nWe have proved in Coq the soundness of Separation Logic for Cminor. Each\nrule is proved as a lemma; in addition there is a main theorem that if you prove\nall your function bodies satisfy their pre/postconditions, then the program \"call\nmain()\" is safe. We have informally tested the adequacy of our result by doing\ntactical proofs of small programs [3].\nLines Component\n41 Axioms: dependent unique choice, relational choice, extensionality\n8792 Memory model, floats, 32-bit integers, values, operators, maps (exactly as in CompCert [12])\n4408 Sharable permissions, Cminor language, operational semantics\n462 Separation Logic operators and rules\n9874 Soundness proof of Separation Logic\nThese line counts include some repetition of specifications (between Modules\nand Module Types) in Coq's module system.\n\n8\n\nConclusion\n\nIn this paper, we have defined a formal semantics for the language Cminor. It\nconsists of a big-step semantics for expressions and a small-step semantics for\nstatements. The small-step semantics is based on continuations mainly to allow\na uniform representation of statement execution. The small-step semantics deals\nwith nonlocal control constructs (return, exit) and is designed to extend to the\nconcurrent setting.\nThen, we have defined a Separation Logic for Cminor. It consists of an assertion language and an axiomatic semantics. We have extended classical Hoare\ntriples to sextuples in order to take into account nonlocal control constructs.\nFrom this definition of sextuples, we have proved the rules of axiomatic semantics, thus proving the soundness of our Separation Logic.\nWe have also proved the semantic equivalence between our small-step semantics and the big-step semantics of the CompCert certified compiler, so the Cminor\nprograms that we prove in Separation Logic can be compiled by the CompCert\ncertified compiler. We plan to connect a Cminor certified compiler directly to\nthe small-step semantics, instead of going through the big-step semantics.\nSmall-step reasoning is useful for sequential programming languages that will\nbe extended with concurrent features; but small-step reasoning about nonlocal\ncontrol constructs mixed with structured programming (loop) is not trivial. We\n16\n\n\fhave relied on the determinacy of the small-step relation so that we can define\nconcepts such as absorb(n, s, \u03c3).\n\nReferences\n1. The Coq proof assistant. http://coq.inria.fr.\n2. American National Standard for Information Systems \u2013 Programming Language \u2013\nC. American National Standards Institute, 1990.\n3. Andrew W. Appel. Tactics for separation logic. http://www.cs.princeton.edu/\n~appel/papers/septacs.pdf, January 2006.\n4. Andrew W. Appel and Sandrine Blazy. Separation logic for small-step Cminor\n(extended version). Technical Report RR 6138, INRIA, March 2007. https://\nhal.inria.fr/inria-00134699.\n5. Sandrine Blazy, Zaynah Dargaye, and Xavier Leroy. Formal verification of a C\ncompiler front-end. In Symp. on Formal Methods (FM'06), volume 4805 of Lecture\nNotes in Computer Science, pages 460\u2013475, 2006.\n6. Sandrine Blazy and Xavier Leroy. Formal verification of a memory model for Clike imperative languages. In Formal Engineering Methods, volume 3785 of Lecture\nNotes in Computer Science, pages 280\u2013299, 2005.\n7. Richard Bornat, Cristiano Calcagno, Peter O'Hearn, and Matthew Parkinson. Permission accounting in separation logic. In POPL '05, pages 259\u2013270, 2005.\n8. Zaynah Dargaye. D\u00e9curryfication certifi\u00e9e. In JFLA (Journ\u00e9es Fran\u00e7aises des\nLangages Applicatifs), pages 119\u2013133, 2007.\n9. Samin Ishtiaq and Peter O'Hearn. BI as an assertion language for mutable data\nstructures. In POPL'01, pages 14\u201326. ACM Press, January 2001.\n10. Gerwin Klein, Harvey Tuch, and Michael Norrish. Types, bytes, and separation\nlogic. In POPL'07, pages 97\u2013108. ACM Press, January 2007.\n11. Dirk Leinenbach, Wolfgang Paul, and Elena Petrova. Towards the formal verification of a C0 compiler: Code generation and implementation correctness. In IEEE\nConference on Software Engineering and Formal Methods (SEFM'05), 2005.\n12. Xavier Leroy. Formal certification of a compiler back-end, or: programming a\ncompiler with a proof assistant. In POPL'06, pages 42\u201354. ACM Press, 2006.\n13. J Strother Moore. A mechanically verified language implementation. Journal of\nAutomated Reasoning, 5(4):461\u2013492, 1989.\n14. Zhaozhong Ni and Zhong Shao. Certified assembly programming with embedded\ncode pointers. In POPL'06, pages 320\u2013333. ACM Press, January 2006.\n15. Peter O'Hearn, John Reynolds, and Hongseok Yang. Local reasoning about programs that alter data structures. In CSL'01, volume 2142 of Lecture Notes in\nComputer Science, pages 1\u201319, September 2001.\n16. Matthew J. Parkinson. Local Reasoning for Java. PhD thesis, University of Cambridge, 2005.\n17. Norbert Schirmer. Verification of Sequential Imperative Programs in Isabelle/HOL.\nPhD thesis, Technische Universit\u00e4t M\u00fcnchen, 2006.\n\n17\n\n\f"}