{"id": "http://arxiv.org/abs/1204.2983v1", "guidislink": true, "updated": "2012-04-13T13:17:56Z", "updated_parsed": [2012, 4, 13, 13, 17, 56, 4, 104, 0], "published": "2012-04-13T13:17:56Z", "published_parsed": [2012, 4, 13, 13, 17, 56, 4, 104, 0], "title": "Parameterized Resolution with bounded conjunction", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1204.1922%2C1204.1708%2C1204.2889%2C1204.6485%2C1204.6390%2C1204.6089%2C1204.1214%2C1204.5495%2C1204.5508%2C1204.3334%2C1204.3688%2C1204.1988%2C1204.2950%2C1204.1482%2C1204.2410%2C1204.1932%2C1204.4153%2C1204.0659%2C1204.4522%2C1204.2796%2C1204.2994%2C1204.2632%2C1204.3694%2C1204.1870%2C1204.3220%2C1204.2406%2C1204.3819%2C1204.2983%2C1204.2891%2C1204.3023%2C1204.0929%2C1204.1547%2C1204.1222%2C1204.0274%2C1204.5232%2C1204.3903%2C1204.6177%2C1204.3799%2C1204.0222%2C1204.1630%2C1204.5039%2C1204.2907%2C1204.0682%2C1204.0629%2C1204.6714%2C1204.0609%2C1204.5003%2C1204.3350%2C1204.1485%2C1204.2209%2C1204.6335%2C1204.5381%2C1204.5791%2C1204.0979%2C1204.3898%2C1204.0698%2C1204.0806%2C1204.1168%2C1204.5220%2C1204.2992%2C1204.2343%2C1204.2744%2C1204.2874%2C1204.4033%2C1204.4087%2C1204.4529%2C1204.1862%2C1204.1154%2C1204.2221%2C1204.1999%2C1204.3731%2C1204.4806%2C1204.2931%2C1204.1441%2C1204.4700%2C1204.1149%2C1204.0285%2C1204.0963%2C1204.0736%2C1204.3239%2C1204.2882%2C1204.6517%2C1204.2238%2C1204.5406%2C1204.4694%2C1204.0559%2C1204.2980%2C1204.1712%2C1204.1646%2C1204.2862%2C1204.3997%2C1204.0518%2C1204.1736%2C1204.5175%2C1204.3618%2C1204.3008%2C1204.6331%2C1204.1457%2C1204.3412%2C1204.1794%2C1204.5908&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Parameterized Resolution with bounded conjunction"}, "summary": "We provide separations between the parameterized versions of Res(1)\n(Resolution) and Res(2). Using a different set of parameterized contradictions,\nwe also separate the parameterized versions of Res*(1) (tree-Resolution) and\nRes*(2).", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1204.1922%2C1204.1708%2C1204.2889%2C1204.6485%2C1204.6390%2C1204.6089%2C1204.1214%2C1204.5495%2C1204.5508%2C1204.3334%2C1204.3688%2C1204.1988%2C1204.2950%2C1204.1482%2C1204.2410%2C1204.1932%2C1204.4153%2C1204.0659%2C1204.4522%2C1204.2796%2C1204.2994%2C1204.2632%2C1204.3694%2C1204.1870%2C1204.3220%2C1204.2406%2C1204.3819%2C1204.2983%2C1204.2891%2C1204.3023%2C1204.0929%2C1204.1547%2C1204.1222%2C1204.0274%2C1204.5232%2C1204.3903%2C1204.6177%2C1204.3799%2C1204.0222%2C1204.1630%2C1204.5039%2C1204.2907%2C1204.0682%2C1204.0629%2C1204.6714%2C1204.0609%2C1204.5003%2C1204.3350%2C1204.1485%2C1204.2209%2C1204.6335%2C1204.5381%2C1204.5791%2C1204.0979%2C1204.3898%2C1204.0698%2C1204.0806%2C1204.1168%2C1204.5220%2C1204.2992%2C1204.2343%2C1204.2744%2C1204.2874%2C1204.4033%2C1204.4087%2C1204.4529%2C1204.1862%2C1204.1154%2C1204.2221%2C1204.1999%2C1204.3731%2C1204.4806%2C1204.2931%2C1204.1441%2C1204.4700%2C1204.1149%2C1204.0285%2C1204.0963%2C1204.0736%2C1204.3239%2C1204.2882%2C1204.6517%2C1204.2238%2C1204.5406%2C1204.4694%2C1204.0559%2C1204.2980%2C1204.1712%2C1204.1646%2C1204.2862%2C1204.3997%2C1204.0518%2C1204.1736%2C1204.5175%2C1204.3618%2C1204.3008%2C1204.6331%2C1204.1457%2C1204.3412%2C1204.1794%2C1204.5908&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We provide separations between the parameterized versions of Res(1)\n(Resolution) and Res(2). Using a different set of parameterized contradictions,\nwe also separate the parameterized versions of Res*(1) (tree-Resolution) and\nRes*(2)."}, "authors": ["Stefan Dantchev", "Barnaby Martin"], "author_detail": {"name": "Barnaby Martin"}, "author": "Barnaby Martin", "links": [{"href": "http://arxiv.org/abs/1204.2983v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1204.2983v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.1.3", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1204.2983v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1204.2983v1", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "Parameterized Resolution with bounded conjunction\nStefan Dantchev and Barnaby Martin\u2217\nEngineering and Computing Sciences, Durham University, U.K.\n\narXiv:1204.2983v1 [cs.LO] 13 Apr 2012\n\nJuly 5, 2018\n\nAbstract\nWe provide separations between the parameterized versions of Res(1) (Resolution) and\nRes(2). Using a different set of parameterized contradictions, we also separate the parameterized versions of Res\u2217 (1) (tree-Resolution) and Res\u2217 (2).\n\n1\n\nIntroduction\n\nIn a series of papers [8, 3, 4, 5] a program of parameterized proof complexity is initiated and various\nlower bounds and classifications are extracted. The program generally aims to gain evidence that\nW[2] is different from FPT (though in the journal version [9] of [8] the former becomes W[SAT],\nand in the note [14] W[1] is entertained). Parameterized proof (in fact, refutation) systems aim\nat refuting parameterized contradictions which are pairs (F , k) in which F is a propositional CNF\nwith no satisfying assingment of weight \u2264 k. Several parameterized (hereafter often abbreviated\nas \"p-\") proof systems are discussed in [8, 3, 5]. The lower bounds in [8, 3] and [5] amount\nto proving that the systems p-tree-Resolution, p-Resolution and p-bounded-depth Frege are not\nfpt-bounded. Indeed, this is witnessed by the Pigeonhole principle, and so holds even when one\nconsiders parameterized contradictions (F , k) where F is itself an actual contradiction. Such\nparameterized contradictions are termed \"strong\" in [5], in which the authors suggest these are\nthe only parameterized contradictions that should be considered, as general lower bounds \u2013 even\nin p-bounded-depth Frege \u2013 are trivial (see [5]). We sympathise with this outlook, but remind\nthat there are alternative parameterized proof systems built from embedding (see [8, 9]) for which\nno good lower bounds are known even for general parameterized contradictions.\nKraj\u0131\u0301\u010dek introduced the system Res(j) of Resolution-with-bounded-conjunction in [13]. The\ntree-like variant of this system is normally denoted Res\u2217 (j). Res(j + 1) incorporates Res(j) and\nis ostensibly more powerful. This was demonstrated first for Res(1) and Res(2) in [2], where a\nquasi-polynomial separation was given. This was improved in [1], until an exponential separation\nwas given in [16], together with like separations for Res(j) and Res(j + 1), for j > 1. Similar\nseparations of Res\u2217 (j) and Res\u2217 (j+1) were given in [11]. We are motivated mainly by the simplified\nand improved bounds of [7], which use relativisations of the Least number principle, LNPn and\nan ordered variant thereof, the Induction principle, IPn . The contradiction LNPn asserts that a\npartial n-order has no minimal element. In the literature it enjoys a myriad of alternative names:\nthe Graph Ordering Principle GOP, Ordering Principle OP and Minimal Element Principle MEP.\n\u2217\n\nSupported by EPSRC grant EP/G020604/1.\n\n1\n\n\fWhere the order is total it is also known as TLNP and GT. The contradiction IPn uses the built-in\norder of {1, . . . , n} and asserts that: 1 has property P , n fails to have property P , and any number\nhaving property P entails a larger number also having property P . Relativisation of these involves\nasserting that everything holds only on some non-empty subset of the domain (in the case of IPn\nwe force 1 and n to be in this relativising subset).\nIn the world of parameterized proof complexity, we already have lower bounds for p-Res(j) (as\nwe have for p-bounded-depth Frege), but we are still interested in separating levels p-Res(j). We\nare again able to use the relativised least number principle, RLNPn to separate p-Res(1) and pRes(2). Specifically, we prove that (RLNPn , k) admits a polynomial-sized\nin n refutation in Res(2),\n\u221a\nk/4\nbut all p-Res(1) refutations of (RLNPn , k) are of size \u2265 n\n. Although we use the same principle\nas [7], the proof given there does not adapt to the parameterized world, and instead we look for\ninspiration to the proof given in [5] for the Pigeonhole principle. For tree-Resolution, the situation\nis more complicated. The Relativised induction principle RIPn of IPn admits fpt-bounded proofs\nin Res\u2217 (1), indeed of size O(k!), therefore we are forced to alter this principle. Thus we come up\nwith the Relativised vectorised induction principle RVIPn . We are able to show that (RVIPn , k)\nadmits O(n4 ) refutations in Res\u2217 (2), while every refutation in Res\u2217 (1) is of size \u2265 nk/16 . Note\nthat both of our parameterized contradictions are \"strong\", in the sense of [5]. We go on to give\nextended versions of RVIPn and explain how they separate p-Res\u2217 (j) from p-Res\u2217 (j + 1), for j > 1.\nThis paper is organised as follows. After the preliminaries, we give our separations of p-Res\u2217 (j)\nfrom p-Res\u2217 (j + 1) in Section 3 and our separation of p-Res(1) from p-Res(2) in Section 4. We\nthen conclude with some remarks and open questions.\n\n2\n\nPreliminaries\n\nA parameterized language is a language L \u2286 \u03a3\u2217 \u00d7 N; in an instance (x, k) \u2208 L, we refer to k\nas the parameter. A parameterized language is fixed-parameter tractable (fpt - and in FPT) if\nmembership in L can be decided in time f (k).|x|O(1) for some computable function f . If FPT is\nthe parameterized analog of P, then (at least) an infinite chain of classes vye for the honour to be\nthe analog of NP. The so-called W-hierarchy sit thus: FPT \u2286 W[1] \u2286 W[2] \u2286 . . . \u2286 W[SAT].\nFor more on parameterized complexity and its theory of completeness, we refer the reader to\nthe monographs [10, 12]. Recall that the weight of an assignment to a propositional formula is\nthe number of variables evaluated to true. Of particular importance to us is the parameterized\nproblem Bounded-CNF-Sat whose input is (F , k) where F is a formula in CNF and whose\nyes-instances are those for which there is a satisfying assignment of weight \u2264 k. Bounded-CNFSat is complete for the class W[2], and its complement (modulo instances that are well-formed\nformulae) PCon is complete for the class co-W[2]. Thus, PCon is the language of parameterized\ncontradictions, (F , k) s.t. F is a CNF which has no satisfying assignment of weight \u2264 k.\nA proof system for a parameterized language L \u2286 \u03a3\u2217 \u00d7 N is a poly-time computable function\nP : \u03a3\u2217 \u2192 \u03a3\u2217 \u00d7 N s.t. range(P ) = L. P is fpt-bounded if there exists a computable function f so\nthat each (x, k) \u2208 L has a proof of size at most f (k).|x|O(1) . These definitions come from [3, 4, 5]\nand are slightly different from those in [8, 9] (they are less unwieldy and have essentially the same\nproperties). The program of parameterized proof complexity is an analog of that of Cook-Reckow\n[6], in which one seeks to prove results of the form W[2] 6=co-W[2] by proving that parameterized\nproof systems are not fpt-bounded. This comes from the observation that there is an fpt-bounded\nparameterized proof system for a co-W[2]-complete L iff W[2] =co-W[2].\nResolution is a refutation system for sets of clauses (formulae in CNF) \u03a3. It operates on clauses\n2\n\n\fby the resolution rule, in which from (P \u2228 x) and (Q \u2228 \u00acx) one can derive (P \u2228 Q) (P and Q are\ndisjunctions of literals), with the goal being to derive the empty clause. The only other permitted\nrule in weakening \u2013 from P to derive P \u2228 l for a literal l. We may consider a Resolution refutation\nto be a DAG whose sources are labelled by initial clauses, whose unique sink is labelled by the\nempty clause, and whose internal nodes are labelled by derived clauses. As we are not interested in\npolynomial factors, we will consider the size of a Resolution refutation to be the size of this DAG.\nFurther, we will measure this size of the DAG in terms of the number of variables in the clauses to\nbe resolved \u2013 we will never consider CNFs with number of clauses superpolynomial in the number\nof variables. We define the restriction of Resolution, tree-Resolution, in which we insist the DAG\nbe a tree.\nThe system of parameterized Resolution [8] seeks to refute the parameterized contradictions\nof PCon. Given (F , k), where F is a CNF in variables x1 , . . . , xn , it does this by providing a\nResolution refutation of\nF \u222a {\u00acxi1 \u2228 . . . \u2228 \u00acxik+1 : 1 \u2264 i1 < . . . < ik+1 \u2264 n}.\n\n(1)\n\nThus, in parameterized Resolution we have built-in access to these additional clauses of the form\n\u00acxi1 \u2228 . . . \u2228 \u00acxik+1 , but we only count those that appear in the refutation.\nA j-clause is an arbitrary disjunction of conjunctions of size at most j. Res(j) is a system to\nrefute a set of j-clauses.\nThere are\nV\nV four derivationVrules. The \u2227-introduction rule allows one to\nderive from P \u2228 i\u2208I1 li and Q \u2228 i\u2208I2 li , P \u2228 Q \u2228 i\u2208I1 \u222aI2 li , provided |IW\n1 \u222a I2 | \u2264 j (P and\nV Q are\nj-clauses). The cut (or resolution) rule allows one to derive from\nV P \u2228 i\u2208I li and Q \u2228 i\u2208I \u00acli ,\nP \u2228Q. Finally,\nthe\ntwo\nweakening\nrules\nallow\nthe\nderivation\nof\nP\n\u2228\ni\u2208I li from P , provided |I| \u2264 j,\nV\nV\nand P \u2228 i\u2208I1 li from P \u2228 i\u2208I1 \u222aI2 li .\nIf we turn a Res(j) refutation of a given set of j-clauses \u03a3 upside-down, i.e. reverse the edges\nof the underlying graph and negate the j-clauses on the vertices, we get a special kind of restricted\nbranching j-program. The restrictions are as follows. Each vertex is labelled by a j-CNF which\npartially represents the information that can be obtained along any path from the source to the\nvertex (this is a record in the parlance of [15]). Obviously, the (only) source is labelled with the\nconstant \u22a4. There are two kinds of queries, which can be made by a vertex:\n1. Querying\na new j-disjunction,\nand branching\non the answer: that is, from C and the question\nW\nW\nV\nl\n?\nwe\nsplit\non\nC\n\u2227\nl\nand\nC\n\u2227\n\u00acl\ni.\ni\u2208I i\ni\u2208I i\ni\u2208I\n2. Querying\na known j-disjunction,\nto the answer:\nthat is, from\nW\nW and splitting it according\nW\nW\nC \u2227 i\u2208I1 \u222aI2 li and the question i\u2208I1 li ? we split on C \u2227 i\u2208I1 li and C \u2227 i\u2208I2 li .\nW\nThere are two ways ofWforgetting information. From C1 \u222aC2 we can move to C1 . And from C \u2227 i\u2208I1 li\nwe can move to C \u2227 i\u2208I1 \u222aI2 li . The point is that forgetting allows us to equate the information\nobtained along two different branches and thus to merge them into a single new vertex. A sink\nof the branching j-program must be labelled with the negation of a j-clause from \u03a3. Thus the\nbranching j-program is supposed by default to solve the Search problem for \u03a3: given an assignment\nof the variables, find a clause which is falsified under this assignment.\nThe equivalence between a Res(j) refutation of \u03a3 and a branching j-program of the kind above\nis obvious. Naturally, if we allow querying single variables only, we get branching 1-programs \u2013\ndecision DAGs \u2013 that correspond to Resolution. If we do not allow the forgetting of information,\nwe will not be able to merge distinct branches, so what we get is a class of decision trees that\ncorrespond precisely to the tree-like version of these refutation systems. These decision DAGs\n3\n\n\fpermit the view of Resolution as a game between a Prover and Adversary (originally due to Pudlak\nin [15]). Playing from the unique source, Prover questions variables and Adversary answers either\nthat the variable is true or false (different plays of Adversary produce the DAG). Internal nodes\nare labelled by conjunctions of facts (records to Pudlak) and the sinks hold conjunctions that\ncontradict an initial clause. Prover may also choose to forget information at any point \u2013 this is\nthe reason we have a DAG and not a tree. Of course, Prover is destined to win any play of the\ngame \u2013 but a good Adversary strategy can force that the size of the decision DAG is large, and\nmany Resolution lower bounds have been expounded this way.\nWe may consider any refutation system as a parameterized refutation system, by the addition\nof the clauses given in (1). In particular, parameterized Res(j) \u2013 p-Res(j) \u2013 will play a part in the\nsequel.\n\n3\n\nSeparating p-Res\u2217(j) and p-Res\u2217(j + 1)\n\nThe Induction Principle IPn (see [7]) is given by the following clauses:\nP1 , \u00acPn\nW\ni \u2208 [n \u2212 1]\nj>i Si,j\n\u00acSi,j \u2228 \u00acPi \u2228 Pj i \u2208 [n \u2212 1], j \u2208 [n]\nThe Relativised Induction Principle RIPn (see [7]) is similar, and is given as follows.\nR1 , W\nP1 , Rn , \u00acPn\ni \u2208 [n \u2212 1]\nj>i Si,j\n\u00acSi,j \u2228 \u00acRi \u2228 \u00acPi \u2228 Rj i \u2208 [n \u2212 1], j \u2208 [n]\n\u00acSi,j \u2228 \u00acRi \u2228 \u00acPi \u2228 Pj i \u2208 [n \u2212 1], j \u2208 [n]\nThe important properties of IPn and RIPn , from the perspective of [7], are as follows. IPn admits\nrefutation in Res\u2217 (1) in polynomial size, as does RIPn in Res\u2217 (2). But all refutations of RIPn in\nRes\u2217 (1) are of exponential size. In the parameterized world things are not quite so well-behaved.\nBoth IPn and RIPn admit refutations of size, say, \u2264 4k! in p-Res\u2217 (1); just evaluate variables Si,j\nfrom i := n \u2212 1 downwards. Clearly this is an fpt-bounded refutation. We are forced to consider\nsomething more elaborate, and thus we introduce the Relativised Vectorised Induction Principle\nRVIPn .\nRW1 , P1,1, Rn , \u00acPn,j\nj \u2208 [n]\ni, j \u2208 [n]\nl>i,m\u2208[n] Si,j,l,m\n\u00acSi,j,l,m \u2228 \u00acRi \u2228 \u00acPi,j \u2228 Rl i \u2208 [n \u2212 1], j, l, m \u2208 [n]\n\u00acSi,j,l,m \u2228 \u00acRi \u2228 \u00acPi,j \u2228 Pl,m i \u2208 [n \u2212 1], j, l, m \u2208 [n]\n\n3.1\n\nLower bound: A strategy for Adversary over RVIPn\n\nWe will give a strategy for Adversary in the game representation of a Res\u2217 (1) refutation. For\nconvenience, we will assume that Prover never questions the same variable twice.\nInformation conceded by Adversary of the form Ri , \u00acRi , Pi,j and Si,j,l,m makes the element i\nbusy (\u00acPi,j and \u00acSi,j,l,m do not). The source is the largest element i for which there is a j such\nthat Adversary has conceded Ri \u2227Pi,j . Initially, the source is 1. Adversary always answers R1 , P1,1 ,\nRn , \u00acPn,j (for j \u2208 [n]), according to the axioms.\n4\n\n\fIf i is below the source. When Adversary is asked Ri , Pi,j or Si,j,l,m, then he answers \u22a5.\nIf i is above the source. When Adversary is asked Ri , or Pi,j , then he gives Prover a free\nchoice unless: 1.) Ri is asked when some Pi,j was previously answered \u22a4 (in this case Ri should\nbe answered \u22a5); or 2.) Some Pi,j is asked when Ri was previously answered \u22a4 (in this case Pi,j\nshould be answered \u22a5). When Adversary is asked Si,j,l,m, then again he offers Prover a free choice.\nIf Prover chooses \u22a4 then Adversary sets Pi,j to \u22a5.\nSuppose i is the source. Then Adversary answers Pi,j and Si,j,k,l as \u22a5, unless Ri \u2227 Pi,j witnesses\nthe source. If Ri \u2227 Pi,j witnesses the source, then, if k is not the next non-busy element above\ni, answer Si,j,l,m as \u22a5. If k is the next non-busy element above i, then give Si,j,l,m a free choice,\nunless \u00acPl,m is already conceded by Adversary, in which case answer \u22a5.\nUsing this strategy, Adversary can not be caught lying until either he has conceded that k\nvariables are true, or he has given Prover at least n \u2212 k free choices.\nLet T (p, q) be some monotone decreasing function that bounds the size of the game tree from\nthe point at which Prover has answered p free choices \u22a4 and q free choices \u22a5. We can see that\nT (p, q) \u2265 T (p + a, q) + T (p, q + a) + 1 and T (k, n \u2212 k) \u2265 0. The following solution to this recurrence\ncan be found in [9].\nCorollary 1. Every p-Res\u2217 (1) refutation of RVIPn is of size \u2265 nk/16 .\nWe may increase the number of relativising predicates to define RVIPrn (note RVIP1n = RVIPn ).\n1\n1\nr\nR11 , . . . , R\nW1 , P1,1 , Rn , . . . , Rn \u00acPn,j\nl>i,m\u2208[n] Si,j,l,m\n1\n\u00acSi,j,l,m \u2228 \u00acRi \u2228 . . . \u2228 \u00acRir \u2228 \u00acPi,j \u2228 Rl1\n..\n.\n\nj \u2208 [n]\ni, j \u2208 [n]\ni \u2208 [n \u2212 1], j, l, m \u2208 [n]\n\n\u00acSi,j,l,m \u2228 \u00acRi1 \u2228 . . . \u2228 \u00acRir \u2228 \u00acPi,j \u2228 Rlr i \u2208 [n \u2212 1], j, l, m \u2208 [n]\n\u00acSi,j,l,m \u2228 \u00acRi1 \u2228 . . . \u2228 \u00acRir \u2228 \u00acPi,j \u2228 Pl,m i \u2208 [n \u2212 1], j, l, m \u2208 [n]\nWe show how to adapt the previous argument in order to demonstrate the following.\nCorollary 2. Every p-Res\u2217 (j + 1) refutation of RVIPj is of size \u2265 nk/16 .\nWe use essentially the same Adversary strategy in a branching j-program. We answer questions\nl1 \u2228 . . . \u2228 lj as either forced or free exactly according to the disjunction of how we would have\nanswered the corresponding li s, i \u2208 [j], before (if one li is free, then the disjunction is also free).\nThe key point is that once some positive disjunction involving some subset of Ri1 , . . . , Rir or Pi,j\n(never all of these together, of course), is questioned then, on a positive answer to this, the\nremaining unquestioned variables of this form should be set to \u22a5.\n\n3.2\n\nUpper bound: a Res\u2217 (j + 1) refutation of RVIPjn\n\nLook at the simpler, but very similar, refutation of RIPn in Res\u2217 (2), of size O(n2 ), as appears in\nFigure 3.2.\nProposition 1. There is a refutation of RVIPjn in Res\u2217 (j + 1), of size O(nj+3).\n\n5\n\n\f\u00acRn \u2228 \u00acPn ?\n\u22a4\n\n\u000f\n\n\u22a5\n\n\u22a5\n\n\u00acRn\u22121 \u2228 \u00acPn\u22121 ?\n\u22a4\n\n/\n\n/\n\nSn\u22121,n ?\n\u22a4\n\n\u000f\n\n..\n.\n\n\u22a4\n\n\u000f\n\n\u00acR1 \u2228 \u00acP1 ?\n\u22a4\n\n#\n\u22a5\n\n#\n/\n\n\u000f\n\n#\n\n\u22a5\n\n/\n\nS1,n ?\n\u22a4\n\n\u000f\n\n#\n\n\u22a5\n\n/\n\n***\n\n\u22a5\n\n/\n\nS1,2 ?\n\u22a4\n\n\u000f\n\n#\n\n\u22a5\n\n/#\n\n\u000f\n\n#\n\nFigure 1: Refutation of RIPn in Res\u2217 (2)\nProof. We give the branching program for j := 1 \u2013 the generalisation is clear.\n\u00acRn \u2228 \u00acPn,n ?\n\u22a4\n\n\u22a4\n\n/\n\n#\n\n\u22a5\n\n/\n\n#\n\n\u000f\n\n..\n.\n\u000f\n\n\u00acRn \u2228 \u00acPn,1 ?\n\u22a4\n\n\u22a5\n\n\u000f\n\n\u22a5\n\n\u00acRn\u22121 \u2228 \u00acPn\u22121,n ?\n\u22a4\n\n\u22a4\n\n\u000f\n\n..\n.\n\n\u22a4\n\n\u22a4\n\nSn\u22121,n ?\n\u22a4\n\n..\n.\n\u000f\n\n\u22a5\n\n\u000f\n\n\u000f\n\n#\n\n\u22a5\n\n/\n\n#\n\n\u000f\n\nS1,n ?\n/\n\n\u22a4\n\n..\n.\n\n\u00acR1 \u2228 \u00acP1,1 ?\n\n#\n\n#\n\n\u000f\n\n\u22a4\n\n\u22a4\n\n/\n\n\u000f\n\n\u00acR1 \u2228 \u00acP1,n ?\n\n/\n\n\u000f\n\n\u000f\n\n\u22a4\n\n\u22a5\n\n#\n\n\u00acRn\u22121 \u2228 \u00acPn\u22121,1 ?\u22a5\n\u22a4\n\nSn\u22121,n ?\n/\n\n\u22a5\n\n***\n/\n\n\u22a5\n\nS1,2 ?\n/\n\n\u22a4\n\n\u000f\n\n#\n\n\u22a5\n\n/\n\nS1,n ?\n\u22a4\n\n\u000f\n\n#6\n\n\u22a5\n\n/\n\n#\n\n\u22a5\n\n/\n\n#\n\n\u000f\n\n#\n\n\u22a5\n\n/\n\n***\n\n\u22a5\n\n/\n\nS1,2 ?\n\u22a4\n\n\u000f\n\n#\n\n\f4\n\nSeparating p-Res(1) and p-Res(2)\n\nThe Relativized Least Number Principle RLNPn is given by the following clauses:\n\u00acRi \u2228 \u00acLi,i\n\u00acRi \u2228 \u00acRj \u2228 \u00acR\nWk \u2228 \u00acLi,j \u2228 \u00acLj,k \u2228 Li,k\ni\u2208[n] Si,j\n\u00acSi,j \u2228 \u00acRj \u2228 Ri\n\u00acSi,j \u2228 \u00acRj \u2228 \u00acLi,j\nRn\n\ni \u2208 [n]\ni, j, k \u2208 [n]\nj \u2208 [n]\ni, j \u2208 [n]\ni, j \u2208 [n]\n\nThe salient properties of RLNPn are that it is polynomial to refute in Res(2), but exponential in\nRes(1) (see [7]). Polynomiality clearly transfers to fpt-boundedness in p-Res(2), so we address the\nlower bound for p-Res(1).\n\n4.1\n\nLower bound: A strategy for Adversary over RLNPn\n\nWe will give a strategy for Adversary in the game representation of a p-Res(1) refutation. The\nargument used in [7] does not adapt to the parameterized case, so we instead use a technique\ndeveloped for the Pigeonhole principle by Razborov in [5].\nRecall that a parameterized clause is of the form \u00acv1 \u2228 . . . \u2228 \u00acvk+1 (where each vi is some R\n,L or S variable). The i, j appearing in Ri , Li,j and Si,j are termed co-ordinates. We define the\nfollowing random restrictions. Set Rn := \u22a4.\n\u221a Randomly choose i0 \u2208 [n \u2212 1] and set Ri0 := \u22a4 and\nLi0 ,n = Si0 ,n := \u22a4. Randomly choose n \u2212 n elements from [n \u2212 1] \\ i0 , and call this set C. Set\nRi := \u22a5 for i \u2208 C. Pick a random bijection \u03c0 on C and set Li,j and Si,j , for i, j \u2208 C, according to\nwhether \u03c0(j) = i. Set Li,j = Lj,i := \u22a5, if j \u2208 C and i \u2208 [n] \\ (C \u222a {i0 }).\nWhat is the probability that a parameterized clause is not evaluated to true by the random\nassignment? We allow that each of \u00acRn , \u00acRi,0p\n, \u00acLio ,n and \u00acSi0 ,n appear in the clause \u2013 leaving\nk + 1 \u2212 4 = k \u2212 3 literals, within \u221a\nmust appear (k \u2212 3)/4 distinct co-ordinates. The probability\nthat some \u00acRi is not true is \u2264 n\u2212\u221an n \u2264 \u221a2n . The probability that some \u00acLi,j is not true, where\n\u221a\n\none of the co-ordinates i, j is possibly mentioned before, is \u2264 \u221a1n n\u22121\u221an * n\u2212n n \u2264 \u221a2n . Likewise with\n\u00acSi,j . Thus we get that the probability\nthat a parameterized clause is not evaluated to true by\n\u221a\n\u221a\n\u221a\n(k\u22123)/4\nthe random assignment is \u2264 \u221a2n\n\u2264 (n/4)\u2212 k\u22123 \u2264 n\u2212 k/4 .\n\u221a\nNow we are ready to complete the proof. Suppose fewer than n k/4 parameterized clauses\nappear in a p-Res(1) refutation of RLNPn , then there is a random restriction as per the previous\nparagraph that evaluates all of these clauses\u221ato true. What remains is a Res(1) refutation of\nRLNP\u221an , which must be of size larger than n k/4 itself, for n sufficiently large (see [7]). Thus we\nhave proved.\n\u221a\nTheorem 1. Every p-Res(1) refutation of RLNPn is of size \u2265 n k/4 .\n\n7\n\n\f5\n\nConcluding remarks\n\nIt is most natural when looking for separators of p-Res\u2217 (1) and p-Res\u2217 (2) to look for CNFs, like\nRVIPn that we have given. p-Res\u2217 (2) is naturally able to process 2-clauses and we may consider\np-Res\u2217 (1) acting on 2-clauses, when we think of it using any of the clauses obtained from those\n2-clauses by distributivity. In this manner, we offer the following principle as being fpt-bounded for\np-Res\u2217 (2) but not fpt-bounded for p-Res\u2217 (1). Consider the two axioms \u2200x(\u2203y\u00acS(x, y) \u2227 T (x, y)) \u2228\nP (x) and \u2200x, yT (x, y) \u2192 S(x, y). This generates the following system \u03a3P ST of 2-clauses.\nW\nPi \u2228 j\u2208[n](\u00acSi,j \u2227 Ti,j ) i \u2208 [n]\n\u00acTi,j \u2228 Si,j\ni, j \u2208 [n]\nNote that the expansion of \u03a3P ST to CNF makes it exponentially larger. It is not hard to see that\n\u03a3P ST has refutations in p-Res\u2217 (2) of size O(kn), while any refutation in p-Res\u2217 (1) will be of size\n\u2265 nk/2 .\nAll of our upper bounds, i.e. for both RVIPn and RLNPn , are in fact polynomial, and do not\ndepend on k. That is, they are rather more than fpt-bounded. If we want examples that depend\nalso on k then we may enforce this easily enough, as follows. For a set of clauses \u03a3, build a set of\n\u2032\nclauses \u03a3\u2032k with new propositional variables A and B1 , B1\u2032 , . . . , Bk+1, Bk+1\n. From each clause C \u2208 \u03a3,\n\u2032\n\u2032\ngenerate the clause A \u2228 C in \u03a3k . Finally, augment \u03a3k with the following clauses: \u00acA \u2228 B1 \u2228 B1\u2032 , . . . ,\n\u2032\n\u00acA \u2228 Bk+1 \u2228 Bk+1\n. If \u03a3 admits refutation of size \u0398(nc ) in p-Res\u2217 (j) then (\u03a3\u2032k , k) admits refutation\nof size \u0398(nc + 2k+1 ). The parameterized contradictions so obtained are no longer \"strong\", but we\ncould even enforce this by augmenting instead a Pigeonhole principle from k + 1 to k.\nIt is hard to prove p-Res(1) lower bounds for parameterized k-clique on a random graph [4], but\nwe now introduce a contradiction that looks similar but for which lower bounds should be easier.\nIt is a variant of the Pigeonhole principle which could give us another very natural separation of\np-Res(1) from p-Res(2). Define the contradiction PHPk+1,n,k , on variables pi,j (i \u2208 [k + 1] and\nj \u2208 [n]) and qi,j (i \u2208 [n] and j \u2208 [k]), and with clauses:\n\u00acpi,j \u2228 \u00acpl,j\n\u00acq\nW i,j \u2228 \u00acql,j\ni,\u03bb\n\u03bb\u2208[n] pW\n\u00acpi,j \u2228 \u03bb\u2208[k] qj,\u03bb\n\ni 6= l \u2208 [k + 1]; j \u2208 [n]\ni 6= l \u2208 [n]; j \u2208 [k]\ni \u2208 [k]\nj \u2208 [n]\n\nWe conjecture that this principle, which admits fpt-bounded refutation in p-Res(2), does not in\np-Res(1).\nFinally, we leave open the technical question as to whether suitably defined, further-relativised\nversions of RLNPn can separate p-Res(j) from p-Res(j + 1). We conjecture that they can.\n\nReferences\n[1] A. Atserias and M. Bonet. On the automatizability of resolution and related propositional\nproof systems. In 16th Annual Conference of the European Association for Computer Science\nLogic, 2002.\n[2] Albert Atserias, Maria Luisa Bonet, and Juan Luis Esteban. Lower bounds for the weak\npigeonhole principle and random formulas beyond resolution. Inf. Comput., 176(2):136\u2013152,\n2002.\n8\n\n\f[3] Olaf Beyersdorff, Nicola Galesi, and Massimo Lauria. Hardness of parameterized resolution.\nTechnical report, ECCC, 2010.\n[4] Olaf Beyersdorff, Nicola Galesi, and Massimo Lauria. Parameterized complexity of dpll search\nprocedures. In Theory and Applications of Satisfiability Testing - SAT 2011 - 14th International Conference, SAT 2011, pages 5\u201318, 2011.\n[5] Olaf Beyersdorff, Nicola Galesi, Massimo Lauria, and Alexander A. Razborov. Parameterized bounded-depth frege is not optimal. In Automata, Languages and Programming - 38th\nInternational Colloquium, ICALP (1) 2011., pages 630\u2013641, 2011.\n[6] S. Cook and R. Reckhow. The relative efficiency of propositional proof systems. Journal of\nSymbolic Logic, 44(1):36\u201350, March 1979.\n[7] S. Dantchev. Relativisation provides natural separations for resolution-based proof systems.\nIn Computer Science - Theory and Applications, First International Computer Science Symposium in Russia, CSR 2006, St. Petersburg, Russia, June 8-12, 2006, Proceedings, volume\n3967 of Lecture Notes in Computer Science, pages 147\u2013158. Springer, 2006.\n[8] Stefan Dantchev, Barnaby Martin, and Stefan Szeider. Parameterized proof complexity. In\n48th IEEE Symp. on Foundations of Computer Science, pages 150\u2013160, 2007.\n[9] Stefan Dantchev, Barnaby Martin, and Stefan Szeider. Parameterized proof complexity. Computational Complexity, 20, 2011.\n[10] Rodney G. Downey and Michael R. Fellows. Parameterized Complexity. Monographs in\nComputer Science. Springer Verlag, 1999.\n[11] J.L. Esteban, N. Galesi, and J. Mesner. On the complexity of resolution with bounded\nconjunctions. In Proceedings of the 29th International Colloquium on Automata, Languages\nand Programming, 2002.\n[12] J\u00f6rg Flum and Martin Grohe. Parameterized Complexity Theory, volume XIV of Texts in\nTheoretical Computer Science. An EATCS Series. Springer Verlag, 2006.\n[13] J. Kraj\u0131\u0301\u0109ek. On the weak pigeonhole principle. Fundamenta Mathematica, 170:123\u2013140, 2001.\n[14] Barnaby Martin. Parameterized proof complexity and W[1]. CoRR: arxiv.org/abs/1203.5323,\n2012. Submitted to Information Processing Letters.\n[15] P. Pudl\u00e1k. Proofs as games. American Mathematical Monthly, pages 541\u2013550, June-July\n2000.\n[16] N. Segerlind, S. Buss, and R. Impagliazzo. A switching lemma for small restrictions and lower\nbounds for k-dnf resolution. In Proceedings of the 43rd annual symposium on Foundations Of\nComputer Science. IEEE, November 2002.\n\n9\n\n\f"}