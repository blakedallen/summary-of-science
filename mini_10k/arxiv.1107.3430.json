{"id": "http://arxiv.org/abs/1107.3430v2", "guidislink": true, "updated": "2011-09-20T15:13:58Z", "updated_parsed": [2011, 9, 20, 15, 13, 58, 1, 263, 0], "published": "2011-07-18T13:26:45Z", "published_parsed": [2011, 7, 18, 13, 26, 45, 0, 199, 0], "title": "Randomisation and Derandomisation in Descriptive Complexity Theory", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1107.0681%2C1107.4739%2C1107.4948%2C1107.5354%2C1107.5715%2C1107.1454%2C1107.4370%2C1107.0628%2C1107.3601%2C1107.2133%2C1107.5734%2C1107.2684%2C1107.4516%2C1107.3278%2C1107.2747%2C1107.4917%2C1107.3619%2C1107.4668%2C1107.3136%2C1107.1853%2C1107.5412%2C1107.1599%2C1107.2922%2C1107.0317%2C1107.4501%2C1107.2224%2C1107.5793%2C1107.6026%2C1107.4633%2C1107.1048%2C1107.5027%2C1107.4281%2C1107.5313%2C1107.2220%2C1107.3703%2C1107.0499%2C1107.0843%2C1107.2362%2C1107.4662%2C1107.3260%2C1107.4731%2C1107.1284%2C1107.3911%2C1107.3759%2C1107.4772%2C1107.1199%2C1107.1189%2C1107.4776%2C1107.0619%2C1107.3668%2C1107.5511%2C1107.5830%2C1107.3780%2C1107.3056%2C1107.1002%2C1107.5940%2C1107.6017%2C1107.5325%2C1107.3404%2C1107.0376%2C1107.5357%2C1107.5165%2C1107.4029%2C1107.5424%2C1107.1133%2C1107.4557%2C1107.1789%2C1107.3769%2C1107.1238%2C1107.2845%2C1107.0314%2C1107.5009%2C1107.4234%2C1107.1280%2C1107.5222%2C1107.1356%2C1107.3659%2C1107.5188%2C1107.2198%2C1107.0730%2C1107.5947%2C1107.5721%2C1107.5267%2C1107.1025%2C1107.5230%2C1107.3232%2C1107.3778%2C1107.2904%2C1107.0522%2C1107.3430%2C1107.4943%2C1107.3577%2C1107.5968%2C1107.3857%2C1107.0005%2C1107.1866%2C1107.0906%2C1107.2495%2C1107.3068%2C1107.1324%2C1107.0790&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Randomisation and Derandomisation in Descriptive Complexity Theory"}, "summary": "We study probabilistic complexity classes and questions of derandomisation\nfrom a logical point of view. For each logic L we introduce a new logic BPL,\nbounded error probabilistic L, which is defined from L in a similar way as the\ncomplexity class BPP, bounded error probabilistic polynomial time, is defined\nfrom PTIME. Our main focus lies on questions of derandomisation, and we prove\nthat there is a query which is definable in BPFO, the probabilistic version of\nfirst-order logic, but not in Cinf, finite variable infinitary logic with\ncounting. This implies that many of the standard logics of finite model theory,\nlike transitive closure logic and fixed-point logic, both with and without\ncounting, cannot be derandomised. Similarly, we present a query on ordered\nstructures which is definable in BPFO but not in monadic second-order logic,\nand a query on additive structures which is definable in BPFO but not in FO.\nThe latter of these queries shows that certain uniform variants of AC0\n(bounded-depth polynomial sized circuits) cannot be derandomised. These results\nare in contrast to the general belief that most standard complexity classes can\nbe derandomised. Finally, we note that BPIFP+C, the probabilistic version of\nfixed-point logic with counting, captures the complexity class BPP, even on\nunordered structures.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1107.0681%2C1107.4739%2C1107.4948%2C1107.5354%2C1107.5715%2C1107.1454%2C1107.4370%2C1107.0628%2C1107.3601%2C1107.2133%2C1107.5734%2C1107.2684%2C1107.4516%2C1107.3278%2C1107.2747%2C1107.4917%2C1107.3619%2C1107.4668%2C1107.3136%2C1107.1853%2C1107.5412%2C1107.1599%2C1107.2922%2C1107.0317%2C1107.4501%2C1107.2224%2C1107.5793%2C1107.6026%2C1107.4633%2C1107.1048%2C1107.5027%2C1107.4281%2C1107.5313%2C1107.2220%2C1107.3703%2C1107.0499%2C1107.0843%2C1107.2362%2C1107.4662%2C1107.3260%2C1107.4731%2C1107.1284%2C1107.3911%2C1107.3759%2C1107.4772%2C1107.1199%2C1107.1189%2C1107.4776%2C1107.0619%2C1107.3668%2C1107.5511%2C1107.5830%2C1107.3780%2C1107.3056%2C1107.1002%2C1107.5940%2C1107.6017%2C1107.5325%2C1107.3404%2C1107.0376%2C1107.5357%2C1107.5165%2C1107.4029%2C1107.5424%2C1107.1133%2C1107.4557%2C1107.1789%2C1107.3769%2C1107.1238%2C1107.2845%2C1107.0314%2C1107.5009%2C1107.4234%2C1107.1280%2C1107.5222%2C1107.1356%2C1107.3659%2C1107.5188%2C1107.2198%2C1107.0730%2C1107.5947%2C1107.5721%2C1107.5267%2C1107.1025%2C1107.5230%2C1107.3232%2C1107.3778%2C1107.2904%2C1107.0522%2C1107.3430%2C1107.4943%2C1107.3577%2C1107.5968%2C1107.3857%2C1107.0005%2C1107.1866%2C1107.0906%2C1107.2495%2C1107.3068%2C1107.1324%2C1107.0790&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We study probabilistic complexity classes and questions of derandomisation\nfrom a logical point of view. For each logic L we introduce a new logic BPL,\nbounded error probabilistic L, which is defined from L in a similar way as the\ncomplexity class BPP, bounded error probabilistic polynomial time, is defined\nfrom PTIME. Our main focus lies on questions of derandomisation, and we prove\nthat there is a query which is definable in BPFO, the probabilistic version of\nfirst-order logic, but not in Cinf, finite variable infinitary logic with\ncounting. This implies that many of the standard logics of finite model theory,\nlike transitive closure logic and fixed-point logic, both with and without\ncounting, cannot be derandomised. Similarly, we present a query on ordered\nstructures which is definable in BPFO but not in monadic second-order logic,\nand a query on additive structures which is definable in BPFO but not in FO.\nThe latter of these queries shows that certain uniform variants of AC0\n(bounded-depth polynomial sized circuits) cannot be derandomised. These results\nare in contrast to the general belief that most standard complexity classes can\nbe derandomised. Finally, we note that BPIFP+C, the probabilistic version of\nfixed-point logic with counting, captures the complexity class BPP, even on\nunordered structures."}, "authors": ["Kord Eickmeyer", "Martin Grohe"], "author_detail": {"name": "Martin Grohe"}, "author": "Martin Grohe", "links": [{"title": "doi", "href": "http://dx.doi.org/10.2168/LMCS-7(3:14)2011", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1107.3430v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1107.3430v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.4.1, F.1.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1107.3430v2", "affiliation": "Humboldt-Universit\u00e4t Berlin", "arxiv_url": "http://arxiv.org/abs/1107.3430v2", "arxiv_comment": null, "journal_reference": "Logical Methods in Computer Science, Volume 7, Issue 3 (September\n  21, 2011) lmcs:714", "doi": "10.2168/LMCS-7(3:14)2011", "fulltext": "Logical Methods in Computer Science\nVol. 7 (3:14) 2011, pp. 1\u201324\nwww.lmcs-online.org\n\nSubmitted\nPublished\n\nNov. 17, 2010\nSep. 21, 2011\n\nRANDOMISATION AND DERANDOMISATION IN DESCRIPTIVE\nCOMPLEXITY THEORY\nKORD EICKMEYER AND MARTIN GROHE\nHumboldt-Universit\u00e4t zu Berlin, Institut f\u00fcr Informatik, Logik in der Informatik\nUnter den Linden 6, 10099 Berlin, Germany\ne-mail address: eickmeye@informatik.hu-berlin.de, grohe@informatik.hu-berlin.de\n\nAbstract. We study probabilistic complexity classes and questions of derandomisation\nfrom a logical point of view. For each logic L we introduce a new logic BPL, bounded\nerror probabilistic L, which is defined from L in a similar way as the complexity class BPP,\nbounded error probabilistic polynomial time, is defined from P.\nOur main focus lies on questions of derandomisation, and we prove that there is a\nquery which is definable in BPFO, the probabilistic version of first-order logic, but not\nin C\u03c9\n\u221e\u03c9 , finite variable infinitary logic with counting. This implies that many of the\nstandard logics of finite model theory, like transitive closure logic and fixed-point logic,\nboth with and without counting, cannot be derandomised. Similarly, we present a query\non ordered structures which is definable in BPFO but not in monadic second-order logic,\nand a query on additive structures which is definable in BPFO but not in FO. The latter\nof these queries shows that certain uniform variants of AC0 (bounded-depth polynomial\nsized circuits) cannot be derandomised. These results are in contrast to the general belief\nthat most standard complexity classes can be derandomised.\nFinally, we note that BPIFP+C, the probabilistic version of fixed-point logic with counting, captures the complexity class BPP, even on unordered structures.\n\n1. Introduction\nThe relation between different modes of computation - deterministic, nondeterministic,\nrandomised - is a central topic of computational complexity theory. The P vs. NP problem\nfalls under this topic, and so does a second very important problem, the relation between\nrandomised and deterministic polynomial time. In technical terms, this is the question\nof whether P = BPP, where BPP is the class of all problems that can be solved by a\nrandomised polynomial time algorithm with two-sided errors and bounded error probability.\nThis question differs from the question of whether P = NP in that most complexity theorists\nseem to believe that the classes P and BPP are indeed equal. This belief is supported by\ndeep results due to Nisan and Wigderson [31] and Impagliazzo and Wigderson [20], which\nlink the derandomisation question to the existence of one-way functions and to circuit lower\n1998 ACM Subject Classification: F.4.1 [Mathematical Logic]: Finite Model Theory, F.1.2 [Modes of\nComputation]: Probabilistic Computation.\nKey words and phrases: Descriptive Complexity, Probabilistic Complexity Classes, Derandomisation.\n\nl\n\nLOGICAL METHODS\nIN COMPUTER SCIENCE\n\nc\nDOI:10.2168/LMCS-7 (3:14) 2011\n\n1\n\nCC\n\nK. Eickmeyer and Martin Grohe\nCreative Commons\n\n\fbounds; cf. also [21]. Similar derandomisation questions are studied for other complexity\nclasses such as logarithmic space, and it is believed that derandomisation is possible for\nthese classes as well.\nDescriptive complexity theory gives logical descriptions of complexity classes and thus\nenables us to translate complexity theoretic questions into the realm of logic. While logical\ndescriptions are known for most natural deterministic and nondeterministic time and space\ncomplexity classes, probabilistic classes such as BPP have received very little attention in\ndescriptive complexity theory yet. In this paper, we study probabilistic complexity classes\nand questions of derandomisation from a logical point of view. For each logic L we introduce\na new logic BPL, bounded error probabilistic L, which is defined from L in a similar way as\nBPP is defined from P. The randomness is introduced to the logic by letting formulas of\nvocabulary \u03c4 speak about random expansions of \u03c4 -structures to a richer vocabulary \u03c4 \u222a \u03c1.\nWe also introduce variants RL, co-RL with one-sided bounded error and PL with unbounded\nerror, corresponding to other well known complexity classes.\nOur main technical results are concerned with questions of derandomisation. By this we\nmean upper bounds on the expressive power of randomised logics in terms of classical logics.\nTrivially, BPL is at least as expressive as L, and if the two logics are equally expressive,\nthen we say that BPL derandomisable. More generally, if L\u2032 is a (deterministic) logic that\nis at least as expressive as BPL, then we say that BPL derandomisable within L\u2032 . We prove\nthat BPFO, bounded error probabilistic first-order logic, is not derandomisable within C\u03c9\u221e\u03c9 ,\nfinite variable infinitary logic with counting. This implies that many of the standard logics\nof finite model theory, like transitive closure logic and fixed-point logic, both with and\nwithout counting, cannot be derandomised. Note that these results are in contrast to the\ngeneral belief that most standard complexity classes can be derandomised.\nWe then investigate whether BPFO can be derandomised on classes of structures with\nbuilt-in relations, such as ordered structures and arithmetic structures. We prove that\nBPFO cannot be derandomised within MSO, monadic second-order logic, on structures\nwith built-in order. Furthermore, BPFO cannot be derandomised on structures with builtin order and addition. Interestingly and nontrivially, BPFO can be derandomised within\nMSO on structures with built-in order and addition. Behle and Lange [5] showed that the\nexpressive power of FO on classes of ordered structures with certain predefined relation\nsymbols corresponds to uniform subclasses of AC0 , the class of problems decidable by circuit families of bounded depth, unbounded fan-in and polynomial size. In fact, for any\nset R of built-in relations they show that FO[R] captures FO[R]-uniform AC0 . Arguably\nthe most intensively studied uniformity condition on AC0 is dlogtime-uniform AC0 , which\ncorresponds to FO[+, \u00d7], first-order logic with built-in arithmetic (Barrington et al. [3]).\nThe question of whether dlogtime-uniform BPAC0 can be derandomised is still open, but\nthere is a conditional derandomisation by Viola [39]. There are less uniform variants of\nBPAC0 that can be proved to be derandomisable by standard arguments; cf. [1]. We prove\nthat the more uniform FO[+]-uniform AC0 is not derandomisable. This raises the question\nof how weak uniformity must be for derandomisation to be possible.\nIn the last section of this paper, we turn to more standard questions of descriptive complexity theory. We prove that BPIFP+C, the probabilistic version of fixed-point logic with\ncounting, captures the complexity class BPP, even on unordered structures. For ordered\nstructures, this result is a direct consequence of the Immerman-Vardi Theorem [18, 38], and\nfor arbitrary structures it follows from the observation that we can define a random order\nwith high probability in BPIFP+C. Still, the result is surprising at first sight because of its\n2\n\n\fsimilarity with the open question of whether there is a logic capturing P, and because it is\nbelieved that P = BPP. The caveat is that the logic BPIFP+C does not have an effective\nsyntax and thus is not a \"logic\" according to Gurevich's [16] definition underlying the question for a logic that captures P. Nevertheless, we believe that BPIFP+C gives a completely\nadequate description of the complexity class BPP, because the definition of BPP is inherently ineffective as well (as opposed to the definition of P in terms of the decidable set of\npolynomially clocked Turing machines). We obtain similar descriptions of other probabilistic complexity classes. For example, randomised logspace is captured by the randomised\nversion of deterministic transitive closure logic with counting.\nRelated work\nAs mentioned earlier, probabilistic complexity classes such as BPP have received very little\nattention in descriptive complexity theory. There is an unpublished paper due to Kaye [22]\nthat gives a logical characterisation of BPP on ordered structures. M\u00fcller [30] and Montoya (unpublished) study a logical BP-operator in the context of parameterised complexity\ntheory. What comes closest to our work \"in spirit\" and also in some technical aspects is\nHella, Kolaitis, and Luosto's work on almost everywhere equivalence [17], which may be\nviewed as a logical account of average case complexity in a similar sense that our work\ngives a logical account of randomised complexity. There is a another logical approach to\ncomputational complexity, known as implicit computational complexity, which is quite different from descriptive complexity theory. Mitchell, Mitchell, and Scedrov [28] give a logical\ncharacterisation of BPP by a higher-order typed programming language in this context.\nLet us emphasise that the main purpose of this paper is not the definition of new\nprobabilistic logics, but an investigation of these logics in a complexity theoretic context.\n\n2. Preliminaries\n2.1. Structures and Queries\nA vocabulary is a finite set \u03c4 of relation symbols of fixed arities. A \u03c4 -structure A consists\nof a finite set V (A), the universe of the structure, and, for all R \u2208 \u03c4 , a relation R(A) on\nA whose arity matches that of R. Thus we only consider finite and relational structures.\nLet \u03c3, \u03c4 be vocabularies with \u03c3 \u2286 \u03c4 . Then the \u03c3-restriction of a \u03c4 -structure B is the \u03c3structure B|\u03c3 with universe V (B|\u03c3 ) := V (B) and relations R(B|\u03c3 ) := R(B) for all R \u2208 \u03c3.\nA \u03c4 -expansion of a \u03c3-structure A is a \u03c4 -structure B such that B|\u03c3 = A. For every class C of\nstructures, C[\u03c4 ] denotes the class of all \u03c4 -structures in C. A renaming of a vocabulary \u03c4 is\na bijective mapping r from \u03c4 to a vocabulary \u03c4 \u2032 such that for all R \u2208 \u03c4 the relation symbol\nr(R) \u2208 \u03c4 \u2032 has the same arity as R. If r : \u03c4 \u2192 \u03c4 \u2032 is a renaming and A is a \u03c4 -structure then\nAr is the \u03c4 \u2032 -structure with V (Ar ) := V (A) and r(R)(Ar ) := R(A) for all R \u2208 \u03c4 .\nWe let 6, + and \u00d7 be distinguished relation symbols of arity two, three and three,\nrespectively. Whenever any of these relations symbols appear in a vocabulary \u03c4 , we demand\nthat they be interpreted by a linear order and ternary addition and multiplication relations,\nrespectively, in all \u03c4 -structures. To be precise, let [a, b] be the set {a, a + 1, . . . , b} for\n\n3\n\n\fa \u2264 b \u2208 N, and denote by Nn the {6, +, \u00d7}-structure with\nV (Nn ) = [0, n \u2212 1],\n\n6(Nn ) = {(a, b) | a 6 b} and\n\n+(Nn ) = {(a, b, c) | a + b = c},\n\u00d7(Nn ) = {(a, b, c) | a * b = c}.\nWe demand A|{6,+,\u00d7}\u2229\u03c4 \u223c\n= (N|A| )|{6,+,\u00d7}\u2229\u03c4 for all \u03c4 -structures A. We call structures whose\nvocabulary contains any of these relation symbols ordered, additive and multiplicative, respectively. We say that a formula \u03c6(x) with exactly one free variable x defines an element\nif in every structure it is satisfied by exactly one element. Since we may identify the elements of an ordered structure uniquely with natural numbers it makes sense to say, e.g.,\nthat \"\u03c6(x) defines a prime number\" or \"\u03c6(x) defines a number \u2264 logO(1) |A|\", and we will\nsometimes do so.\nOn ordered structures, every fixed natural number i can be defined in first-order logic\nby a formula \u03c6i-th using only three variables as follows:\n\u03c60-th (x) := \u2200y x \u2264 y\n\u03c6(n+1)-th (x) := \u2203y\u2200z \u03c6n-th (y) \u2227 \u00ac(x=y)\n \u0307 \u2227 y \u2264 x\u2227\n\n\u0001\n((y \u2264 z \u2227 z \u2264 x) \u2192 (y =z\n \u0307 \u2228 y =z))\n \u0307\n.\n\nBecause the ordering may be defined using the addition relation, the same holds true on\nadditive structures, again using only three variables.\nA k-ary \u03c4 -global relation is a mapping R that associates a k-ary relation R(A) with\neach \u03c4 -structure A. A 0-ary \u03c4 -global relation is usually called a Boolean \u03c4 -global relation.\nWe identify the two 0-ary relations \u2205 and {()}, where () denotes the empty tuple, with the\ntruth values false and true, respectively, and we identify the Boolean \u03c4 -global relation R\nwith the class of all \u03c4 -structures A with R(A) = true. A k-ary \u03c4 -query is a k-ary \u03c4 -global\nrelation Q preserved under isomorphism, that is, if f is an isomorphism from a \u03c4 -structure\nA to a \u03c4 -structure B then for all ~a \u2208 V (A)k it holds that ~a \u2208 Q(A) \u21d0\u21d2 f (~a) \u2208 Q(B).\n2.2. Logics\nA logic L has a syntax that assigns a set L[\u03c4 ] of L-formulas of vocabulary \u03c4 with each\nL[\u03c4 ]\nvocabulary \u03c4 and a semantics that associates a \u03c4 -global relation Q\u03c6 with every formula\n\u03c6 \u2208 L[\u03c4 ] such that for all vocabularies \u03c3, \u03c4, \u03c4 \u2032 the following three conditions are satisfied:\nL[\u03c4 ]\n\n(1) For all \u03c6 \u2208 L[\u03c4 ] the global relation Q\u03c6 is a \u03c4 -query.\n(2) If \u03c3 \u2286 \u03c4 then L[\u03c3] \u2286 L[\u03c4 ], and for all formulas \u03c6 \u2208 L[\u03c3] and all \u03c4 -structures A it holds\nL[\u03c3]\nL[\u03c4 ]\nthat Q\u03c6 (A|\u03c3 ) = Q\u03c6 (A).\n\u2032\n(3) If r : \u03c4 \u2192 \u03c4 is a renaming, then for every formula \u03c6 \u2208 L[\u03c4 ] there is a formula \u03c6r \u2208 L[\u03c4 \u2032 ]\nL[\u03c4 ]\nL[\u03c4 \u2032 ]\nsuch that for all \u03c4 -structures A it holds that Q\u03c6 (A) = Q\u03c6r (Ar ).\nCondition (ii) justifies dropping the vocabulary \u03c4 in the notation for the queries and just\nwrite QL\u03c6 . For a \u03c4 -structure A and a tuple ~a whose length matches the arity of QL\u03c6 , we\nusually write A |=L \u03c6[~a] instead of ~a \u2208 QL\u03c6 (A). If QL\u03c6 is a k-ary query, then we call \u03c6 a\nk-ary formula, and if QL\u03c6 is Boolean, then we call \u03c6 a sentence. Instead of A |=L \u03c6[()] we\njust write A |=L \u03c6 and say that A satisfies \u03c6. We omit the index L if L is clear from the\ncontext.\nA query Q is definable in a logic L if there is an L-formula \u03c6 such that Q = QL\u03c6 . Two\nformulas \u03c61 , \u03c62 \u2208 L[\u03c4 ] are equivalent (we write \u03c61 \u2261 \u03c62 ) if they define the same query. We\n4\n\n\fsay that a logic L1 is weaker than a logic L2 (we write L1 \u2266 L2 ) if every query definable in\nL1 is also definable in L2 . Similarly, we define it for L1 and L2 to be equivalent (we write\nL1 \u2261 L2 ) and for L1 to be strictly weaker than L2 (we write L1 \b L2 ). The logics L1 and L2\nare incomparable if neither L1 \u2266 L2 nor L2 \u2266 L1 .\nRemark 2.1. Our notion of logic is very minimalistic, usually logics are required to meet\nadditional conditions (see [8] for a thorough discussion). In particular, we do not require\nthe syntax of a logic to be effective. Indeed, the main logics studied in this paper have an\nundecidable syntax. Our definition is in the tradition of abstract model theory (cf. [4]);\nproof theorists tend to have a different view on what constitutes a logic.\nWe assume that the reader has heard of the standard logics studied in finite model\ntheory, specifically first-order logic FO, second-order logic SO and its fragments \u03a31k , monadic\nsecond-order logic MSO, transitive closure logic TC and its deterministic variant DTC, least,\ninflationary, and partial fixed-point logic LFP, IFP, and PFP, and finite variable infinitary\nlogic L\u03c9\u221e\u03c9 . For all these logics except LFP there are also counting versions, which we denote\nby FO+C, TC+C, . . ., PFP+C and C\u03c9\u221e\u03c9 , respectively. Only familiarity with first-order logic\nis required to follow most of the technical arguments in this paper. The other logics are\nmore or less treated as \"black boxes\". We will say a bit more about some of them when\nthey occur later. The following diagram shows how the logics compare in expressive power:\nFO\n\b\nDTC\n\b\nTC\n\b LFP \u2261 IFP \b\nPFP\n\b L\u03c9\u221e\u03c9\n\b\n\b\n\b\n\b\n\b\n\b\nFO+C \b DTC+C \b TC+C \b\nIFP+C\n\b PFP+C \b C\u03c9\u221e\u03c9 .\n\n(2.1)\n\nFurthermore, MSO is strictly stronger than FO and incomparable with all other logics\ndisplayed in (2.1).\n2.3. Complexity theory\nWe assume that the reader is familiar with the basics of computational complexity theory\nand in particular the standard complexity classes such as P and NP. Let us briefly review the\nclass BPP, bounded error probabilistic polynomial time, and other probabilistic complexity\nclasses: A language L \u2286 \u03a3\u2217 is in BPP if there is a polynomial time algorithm M , expecting\nas input a string x \u2208 \u03a3\u2217 and a string r \u2208 {0, 1}\u2217 of \"random bits\", and a polynomial p such\nthat for every x \u2208 \u03a3\u2217 the following two conditions are satisfied:\n\u0001\n(i) If x \u2208 L, then Prr\u2208{0,1}p(|x|) M accepts (x, r) \u2265 23 .\n\u0001\n(ii) If x 6\u2208 L, then Prr\u2208{0,1}p(|x|) M accepts (x, r) \u2264 31 .\n\nIn both conditions, the probabilities range over strings r \u2208 {0, 1}p(|x|) chosen uniformly at\nrandom. The choice of the error bounds 1/3 and 2/3 in (i) and (ii) is somewhat arbitrary,\nthey can be replaced by any constants \u03b1, \u03b2 with 0 < \u03b1 < \u03b2 < 1 without changing the\ncomplexity class. (To reduce the error probability of an algorithm we simply repeat it\nseveral times with independently chosen random bits r.)\nHence BPP is the class of all problems that can be solved by a randomised polynomial\ntime algorithm with bounded error probabilities. RP is the class of all problems that can\nbe solved by a randomised polynomial time algorithm with bounded one-sided error on\nthe positive side (the bound 1/3 in (ii) is replaced by 0), and co-RP is the class of all\nproblems that can be solved by a randomised polynomial time algorithm with bounded\none-sided error on the negative side (the bound 2/3 in (i) is replaced by 1). Finally, PP\n5\n\n\fis the class we obtain if we replace the lower bound \u2265 2/3 in (i) by > 1/2 and the upper\nbound \u2264 1/3 in (ii) by \u2264 1/2. Note that PP is not a realistic model of \"efficient randomised\ncomputation\", because there is no easy way of deciding whether an algorithm accepts or\nrejects its input. Indeed, by Toda's Theorem [37], the class PPP contains the full polynomial\nhierarchy. By the Sipser-G\u00e1cs Theorem (see [24]), BPP is contained in the second level of\nthe polynomial hierarchy. More precisely, BPP \u2286 \u03a3p2 \u2229 \u03a0p2 . It is an open question whether\nBPP \u2286 NP. However, as pointed out in the introduction, there are good reasons to believe\nthat BPP = P.\n2.4. Descriptive complexity\nIt is common in descriptive complexity theory to view complexity classes as classes of\nBoolean queries, rather than classes of formal languages. This allows it to compare logics\nwith complexity classes. The translation between queries and languages is carried out as\nfollows: Let \u03c4 be a vocabulary, and assume that 6 6\u2208 \u03c4 . With each ordered (\u03c4 \u222a {6})structure B we can associate a binary string s(B) \u2208 {0, 1}\u2217 in a canonical way. Then with\neach class C \u2286 O[\u03c4 \u222a {6}] of ordered \u03c4 structures we associate\nthe language L(C) := {s(B) |\n\b\n\u2217\nB \u2208 C} \u2286 {0, 1} . For a Boolean \u03c4 -query Q, let Q6 := B \u2208 O[\u03c4 \u222a 6] B|\u03c4 \u2208 Q be the\nclass of all ordered (\u03c4 \u222a {6})-expansions of structures in Q. We say that Q is decidable in a\ncomplexity class K if the language L(Q6 ) is contained in K. We say that a logic L captures\nK if for all Boolean queries Q it holds that Q is definable in L if and only if Q is decidable\nin K. We say that L is contained in K if all Boolean queries definable in L are decidable in\nK.\nRemark 2.2. Just like our notion of \"logic\", our notion of a logic \"capturing\" a complexity\nclass is very minimalistic, but completely sufficient for our purposes. For a deeper discussion\nof logics capturing complexity classes we refer the reader to one of the textbooks [9, 15, 19,\n25].\n\n3. Randomised logics\nThroughout this section, let \u03c4 and \u03c1 be disjoint vocabularies. Relations over \u03c1 will be\n\"random\", and we will reserve the letter R for relation symbols from \u03c1. We are interested\nin random (\u03c4 \u222a \u03c1)-expansions of \u03c4 -structures. For a \u03c4 -structure A, by X (A, \u03c1) we denote\nthe class of all (\u03c4 \u222a \u03c1)-expansions of A. We view X (A, \u03c1) as a probability space with the\nuniform distribution. Note that we can \"construct\" a random X \u2208 X (A, \u03c1) by deciding\nindependently for all k-ary R \u2208 \u03c1 and all tuples ~a \u2208 V (A)k with probability 1/2 whether\n~a \u2208 R(X). Hence if \u03c1 = {R1 , . . . , Rk }, where Ri is ri -ary, then a random X \u2208 X (A, \u03c1) can\nP\nbe described by random bitstring of length ki=1 nri , where n := |V (A)|. We are mainly\ninterested in the probabilities\nPr (X |= \u03c6)\nX\u2208X (A,\u03c1)\n\nthat a random (\u03c4 \u222a \u03c1)-expansion of a \u03c4 -structure A satisfies a sentence \u03c6 of vocabulary \u03c4 \u222a \u03c1\nof some logic.\nDefinition 3.1. Let L be a logic and 0 \u2264 \u03b1 \u2264 \u03b2 \u2264 1.\n6\n\n\f(1) A formula \u03c6 \u2208 L[\u03c4 \u222a \u03c1] that defines a k-ary query has an (\u03b1, \u03b2]-gap if for all \u03c4 -structures\nA and all ~a \u2208 V (A)k it holds that\nPr\n\n(X |= \u03c6[~a]) \u2264 \u03b1\n\nX\u2208X (A,\u03c1)\n\nor\n\nPr\n\nX\u2208X (A,\u03c1)\n\n(X |= \u03c6[~a]) > \u03b2.\n\n(2) The logic P(\u03b1,\u03b2] L is defined as follows: For each vocabulary \u03c4 ,\n[\b\n\u03c6 \u2208 L[\u03c4 \u222a \u03c1] \u03c6 has an (\u03b1, \u03b2]-gap ,\nP(\u03b1,\u03b2] L[\u03c4 ] :=\n\u03c1\n\nwhere the union ranges over all vocabularies \u03c1 disjoint from \u03c4 . To define the semantics,\nlet \u03c6 \u2208 P(\u03b1,\u03b2] L[\u03c4 ]. Let k, \u03c1 such that \u03c6 \u2208 L[\u03c4 \u222a\u03c1] and \u03c6 is k-ary. Then for all \u03c4 -structures\nA,\n\b\nP\nL\nPr (X |=L \u03c6[~a]) > \u03b2 .\nQ\u03c6(\u03b1,\u03b2] (A) := ~a \u2208 V (A)k\nX\u2208X (A,\u03c1)\n\nIt is easy to see that for every logic L and all \u03b1, \u03b2 with 0 \u2264 \u03b1 \u2264 \u03b2 \u2264 1 the logic P(\u03b1,\u03b2] L\nsatisfies conditions (i)\u2013(iii) from Subsection 2.2 and hence is indeed a well-defined logic. We\nlet\nPL := P(1/2,1/2] L and RL := P(0,2/3] L and BPL := P(1/3,2/3] L.\nWe can also define a logic P[\u03b1,\u03b2) L and let co-RL := P[1/3,1) L. The following lemma, which is\nan adaptation of classical probability amplification techniques to randomised logics, shows\nthat for reasonable L the strength of the logic P(\u03b1,\u03b2] L does not depend on the exact choice\nof the parameters \u03b1, \u03b2. This justifies the arbitrary choice of the constants 1/3, 2/3 in the\ndefinitions of RL and BPL.\nLemma 3.2. Let L be a logic that is closed under conjunctions and disjunctions. Then for\nall \u03b1, \u03b2 with 0 < \u03b1 < \u03b2 < 1 it holds that P(0,\u03b2] L \u2261 RL and P(\u03b1,\u03b2] L \u2261 BPL.\nProof. Let \u03c4 an \u03c1 = {R1 , . . . , Rk } be disjoint relational vocabularies and let \u03c6 \u2208 L[\u03c4 \u222a \u03c1].\nFor any n \u2265 1 we define a new vocabulary\n(i)\n\n(i)\n\n\u03c1(n) := {Rj | 1 \u2264 i \u2264 n, 1 \u2264 j \u2264 k},\n\nwhere the arity of Rj is that of Rj \u2208 \u03c1. Using the renaming property with the renaming\nr (i) : (\u03c4 \u222a \u03c1) \u2192 (\u03c4 \u222a \u03c1(n) )\n(i)\n\nthat leaves \u03c4 fixed and maps Rj \u2208 \u03c1 to Rj we get sentences \u03c6(i) , which are the sentence\n(i)\n\n\u03c6 with every occurrence of Rj replaced by Rj . Since L is closed under conjunctions and\ndisjunctions, for every 0 < l \u2264 n there is an L[\u03c4 \u222a \u03c1(n) ]-sentence\n_ ^\n\u03c6(n,l) :=\n\u03c6(i)\nI\u2286[n] i\u2208I\n|I|=l\n\nwhich is satisfied iff at least l of the \u03c6(i) are satisfied. Notice that the \u03c6(i) use distinct\nrandom relations, so they are satisfied independently of each other.\nClearly, if Pr(X |= \u03c6) = 0 then also Pr(X |= \u03c6(n,l) ) = 0, because we assumed l \u2265 1.\nOn the other hand, if Pr(X |= \u03c6) > \u03b2 for some \u03b2 \u2208 (0, 1), then\nPr(X |= \u03c6(n,1) ) = 1 \u2212 (1 \u2212 Pr(X |= \u03c6))n\nn\n\n> 1 \u2212 (1 \u2212 \u03b2) ,\n7\n\n(3.1)\n(3.2)\n\n\fand this bound can be made arbitrarily close to 1 by choosing n sufficiently large. This\nproves the claim about RL.\nFor BPL, notice that if \u03c6 has an (\u03b1, \u03b2]-gap for some any 0 < \u03b1 < \u03b2 < 1, then for any\n0 < \u03b1\u2032 < \u03b2 \u2032 < 1 there is an n \u2208 N such that\n\u03c6(n,\u2308\n\n\u03b2\u2212\u03b1\n\u2309)\n2\n\nhas an (\u03b1\u2032 , \u03b2 \u2032 ]-gap. In fact, the Chernoff bound (see, e.g., [29]) gives very sharp estimates\non n in terms of \u03b1, \u03b2, \u03b1\u2032 and \u03b2 \u2032 , though we only need the mere existence of such an n\nhere.\n3.1. First observations\nWe start by observing that the syntax of BPFO and thus of most other logics BPL is undecidable. This follows easily from Trakhtenbrot's Theorem (see [9] for similar undecidability\nproofs):\nObservation 3.3. For all \u03b1, \u03b2 with 0 \u2264 \u03b1 < \u03b2 < 1 and all vocabularies \u03c4 containing at\nleast one at least binary relation symbol, the set BP(\u03b1,\u03b2] FO[\u03c4 ] is undecidable.\nProof Sketch. Assume for some 0 \u2264 \u03b1 < \u03b2 < 1 and some \u03c4 containing a binary relation\nsymbol E the set BP(\u03b1,\u03b2] FO[\u03c4 ] is decidable.\nBy Trakhtenbrot's Theorem (cf. [9, Thm. 7.2.1]), the satisfiability of a first-order\nformula \u03c8 \u2208 FO[\u03c4 ] on finite graphs is undecidable. Let G be the class of all graphs with\nexactly one isolated vertex, and let \u03c6G be a sentence defining G on finite structures. By\nstandard arguments, whether a formula is satisfiable in G or on is undecidable.\nLet p = a * 2\u2212k \u2208 (\u03b1, \u03b2) with a \u2208 N be a dyadic rational in the interval (\u03b1, \u03b2), and let\nR1 , . . . , Rk be unary random relations. For every S \u2282 [k], the sentence\n\uf8eb\n\uf8f6\n^\n^\n\u03c8S := \u2203x \uf8ed(\u2200y \u00acExy) \u2227\nRi x \u2227\n\u00acRi x\uf8f8\ni\u2208S\n\ni6\u2208S\n\nhas satisfaction probability 2\u2212k in all structures in G. Thus for a family S = {S1 , . . . , Sa }\nof a distinct subsets of [k], the sentence\n_\n\u03c8S :=\n\u03c8S\nS\u2208S\n\nis satisfied with probability p on such structures. But now the sentence\n\u03c6G \u2192 (\u03c7 \u2227 \u03c8S )\n\nis in BP(\u03b1,\u03b2] FO[\u03c4 ] if and only if \u03c7 is not satisfiable on G.\nFor each n, let Sn be the \u2205-structure with universe V (Sn ) := {1, . . . , n}. Recall the\n0-1-law for first order logic [12, 14]. In our terminology, it says that for each vocabulary \u03c1\nand each sentence \u03c6 \u2208 FO[\u03c1] it holds that\nlim\n\nPr\n\n(X |= \u03c6) \u2208 {0, 1}\n\nn\u2192\u221e X\u2208X (Sn ,\u03c1)\n\n(in particular, this limit exists). There is also an appropriate asymptotic law for formulas\nwith free variables. This implies that on structures with empty vocabulary, PFO (and in\n8\n\n\fparticular BPFO) has the same expressive power as FO. As there is also a 0-1-law for the\nlogic L\u03c9\u221e\u03c9 [23], we actually get the following stronger statement:\nObservation 3.4. Every formula \u03c6 \u2208 PL\u03c9\u221e\u03c9 [\u2205] is equivalent to a formula \u03c6\u2032 \u2208 FO[\u2205].\nAs FO+C is strictly stronger than FO even on structures of empty vocabulary, this observation implies that there are queries definable in FO+C, but not in (B)PL\u03c9\u221e\u03c9 .\nFurthermore, the Sipser-G\u00e1cs Theorem [24] that BPP \u2286 \u03a3p2 \u2229 \u03a0p2 , the fact that the\nfragment \u03a312 of second-order logic captures \u03a3p2 [11, 36], and the observation that BPFO \u2266\nBPP imply the following:\nBPFO \u2266 \u03a312 .\n\nObservation 3.5.\n\nWe will use Lautemann's proof of the Sipser-G\u00e1cs Theorem in section 5 in the context\nof monadic second-order logic.\nWe close this section by observing that randomised logics without probability gaps are\nconsiderably more powerful than their non-randomised counterparts:\nObservation 3.6. Let K be a class of finite structures such that there is a first-order\nformula \u03c6c (x) defining a single element in each structure of K. Then every \u03a311 -query on K\ncan be defined in PFO.\nProof. Let \u03c6 be a \u03a311 -query on K, i.e., \u03c6 is of the form \u2203X1 * * * \u2203Xk \u03c8, where the Xi are\nrelation variables and \u03c8 is first-order. We replace each of the Xi by a random relation Ri\nof the same arity to get a new sentence \u03c6\u2032 and introduce an extra unary random relation\nR0 . Then \u03c6 is equivalent to the PFO-sentence\n\u2203x(R0 x \u2227 \u03c6c (x)) \u2228 \u03c6\u2032 ,\n\nbecause the first part is satisfied with probability exactly 1/2.\nToda's Theorem [37] that the polynomial hierarchy is contained in PPP suggests that,\nin fact, every second-order query is definable in PFO. However, Toda's proof does not carry\nover easily to the PFO-case. Observation 3.4 suggests that some technical condition such\nas definability of an element of the structure is necessary to separate PFO from FO at all.\nOne example of such a class K is the class of all ordered structures, with \u03c6c (x) defining the\nminimum element.\n\n4. Separation results for BPFO\nIn this section we study the expressive power of the randomised logics RFO, co-RFO, and\nBPFO. Our main results are the following:\n\u2022 RFO is not contained in C\u03c9\u221e\u03c9\n\u2022 BPFO is not contained in MSO on ordered structures\n\u2022 RFO is stronger than FO on additive structures\nA forteriori, the first and the third result also hold with BPFO instead of RFO, and the\nconstructions used in their proofs are also definable in co-RFO.\nIt turns out that we need three rather different queries to get these separation results.\nFor the first two queries this is obvious, because every query on ordered structures is\ndefinable in C\u03c9\u221e\u03c9 . The third query (on additive structures) is readily seen to be definable\nin MSO. In fact, in Section 5 we show the following:\n9\n\n\f\u2022 Any BPFO-definable query on additive structures can be defined in MSO.\n4.1. RFO is not contained in C\u03c9\u221e\u03c9\nFormulas of the logic C\u03c9\u221e\u03c9 may contain arbitrary (not necessarily finite) conjunctions and\ndisjunctions, but only finitely many variables, and counting quantifiers of the form \u2203\u2265n x \u03c6\n(\"there exists at least n x such that \u03c6\"). For example, the class of finite structures of even\ncardinality can be defined in this logic by the sentence\n\u0011\n\u0010\n\u0011\n_\u0010\n\u2203\u22652k x x=x\n \u0307\n\u2227 \u00ac \u2203\u22652k+1 x x=x\n \u0307\n.\nk\u22650\n\nTheorem 4.1. There is a class T CFI of structures that is definable in RFO and co-RFO,\nbut not in C\u03c9\u221e\u03c9 .\nRecall that by Observation 3.4 there also is a class of structures definable in FO+C \u2264\nbut not in BPFO.\nOur proof of Theorem 4.1 is based on a well-known construction due to Cai, F\u00fcrer,\nand Immerman [6], who gave an example of a Boolean query in P that is not definable in\nC\u03c9\u221e\u03c9 . We modify their construction in a way reminiscent to a proof by Dawar, Hella, and\nKolaitis [7] for results on implicit definability in first-order logic, and obtain a query T CFI\ndefinable in (co-)RFO, but not in C\u03c9\u221e\u03c9 . Just like in Cai, F\u00fcrer and Immerman's original\nproof, the reason why C\u03c9\u221e\u03c9 can not define our query T CFI is its inability to choose one out\nof a pair of two elements. Using a random binary relation this can \u2013 with high probability\n\u2013 be done in FO.\nWe first review the construction of [6] and then show how to modify it to suit our needs.\nGiven a graph G = (V, E), Cai et al. construct a new graph G\u2032 , replacing all vertices and\nedges of G with certain gadgets. We shall call graphs G\u2032 resulting in this fashion CFI-graphs,\nand will from now on restrict ourselves to connected 3-regular graphs G and CFI-graphs\nresulting from these.\nC\u03c9\u221e\u03c9 ,\n\na 1 b1\n\nvertex\n\nedge\ngroup\ncentre\ngroup\n\n\u2205\n\na 2 b2\n\n12\n\n13\n\n23\n\nedge\n\na\n\nb\n\na\n\nb\n\na\n\nb\n\na\n\nb\n\nstraight\ntwisted\n\na 3 b3\n\nFigure 1: The gadgets for CFI-graphs. Dashed ellipses indicate groups of equivalent vertices. Vertex labels are not part of the actual structure.\nThe construction is as follows: For each vertex in G, we place a copy of the gadget\nshown on the left of Figure 1 in G\u2032 . It has a group of four nodes (henceforth called centre\nnodes) plus three pairs of nodes, which are to be thought of as ends of the three edges\nincident with that node. For the time being, we think of the pairs as ordered from 1 to\n10\n\n\f3 and distinguish between the two nodes in each pair, say one of them is the a-node, the\nother one being the b node. Each of the four centre nodes is connected to one node from\neach pair, and each of them to an even number of a's. To illustrate this, the centre nodes\nare labelled with the even subsets of {1, 2, 3}. We also introduce an equivalence relation\n(or colouring, if you like) of nodes as shown in Figure 1, so any isomorphism of the gadget\nnecessarily permutes nodes within each edge group and the centre group.\n\n2\n\nb2\n\n3\n\nb3\n\na2\n\na3\n\n1\n\n\u2205\n\n1\n2\n2\n\n12\n\n13\n\n23\n\n3\n2\n\n3\n\n3\n1\n\n1\n\na1\n\nb1\n\na1\n\nb1\n\n\u2205\n\n12\n\n13\n\nedget\n(straight)\n\n23\n\nb2\nb2\n\na3\na2\n\nb3\n\na2\n\na3\n\u2205\n\na1\n\n12\n\n13\n\nedget\n(twisted)\n\nb3\n\na2\n\na3\n\u2205\n\n23\n\na1\n\nb1\n\nb3\n\nb2\n12\n\n13\n\n23\n\nb1\n\nFigure 2: The CFI-graph construction for a part of a graph. Edge and nodes labels are not\npart of the actual graph.\nFor each edge in G, we connect the a- and b-nodes in the corresponding pairs as shown\non the right of Figure 1. We say an edge is \"twisted\" if the a-node of one pair is connected\nto the b-node of the other and vice versa. This completes our construction of G\u2032 . For\ndefiniteness, when we speak of an edge group we mean an equivalence class of size two,\nand by a centre group we mean one of size four. An edget is a pair of edge groups which\nform an edge gadget as on the right of Figure 1. Figure 2 shows the result of applying this\nconstruction to a small subgraph (a vertex with its three neighbours).\nWithout the a- and b-labels, we cannot decide which of the edges have been twisted.\nIn fact there are only two isomorphism classes of CFI-graphs derived from G, namely those\nwith an even number of edges twisted and those with an odd number (we call the latter\nones twisted CFI-graphs). This relies on the fact that isomorphisms of the gadget on the\nleft of Figure 1 are exactly those permutations swapping an even number of a's and b's.\nSince we assume G to be connected, we can twist edges along a path between two nodes\nadjacent to twisted edges, reducing the number of twisted edges by two; cf. [6, Lemma 6.2]\nfor details.\nBy [6, Thm. 6.4], if the original graph G has no separator of size at most s then the two\nisomorphism classes of CFI graphs derived from it can not be distinguished by a sentence\n11\n\n\f\u03c6 \u2208 Cs\u221e\u03c9 , i.e., by a C\u03c9\u221e\u03c9 sentence with at most s distinct variables. In P, on the other\nhand, twisted CFI-graphs can easily be recognised: Choose exactly one node from each\nedge group and label this one a and the other one b. A centre node is connected to an even\nnumber of a's if and only if all four nodes in its centre group are. In this case we call the\ncentre group even, otherwise we call it odd. Then a CFI-graph is twisted if and only if\n(number of odd centre groups + number of twisted edgets) is odd.\nWe aim for a (co-)RFO-sentence which defines exactly the twisted connected 3-regular\nCFI-graphs. In view of the above P-algorithm, we are done if we can\n\u2022 express connectedness of the graph,\n\u2022 count edgets and centre groups modulo two and\n\u2022 choose one representative from each centre group, edge group and edget.\nFor counting modulo two and to get representatives for centre groups and edgets, we\naugment the structures with a Boolean algebra in the following way: Let \u03c4 be the vocabulary\n{E, \u223c, <, \u2291, P, O}, with unary P and O, and binary E, \u223c, < and \u2291. Let CFI be the class\nof structures A such that\n\u2022 E defines a 3-regular, connected CFI-graph on V (A) \\ P (A),\n\u2022 (P (A), \u2291) is a Boolean algebra B, and O is true exactly for its members of even cardinality\n\u2022 < defines a linear order on the set of atoms of B (and no other element of A is <-related\nto any other).\n\u2022 \u223c defines an equivalence relation, where each equivalence class\n\u2212 contains one atom of B and the nodes of one edget\n\u2212 or contains one atom of B and the nodes of one centre group\n\u2212 or consists of a single non-atom of B.\nIn particular, the number of atoms of the Boolean algebra B is equal to the number of\nedgets plus the number of centre groups. Note also that we can distinguish the two edge\ngroups in an edget because only nodes in the same edge group are connected to nodes in\nthe same centre group.\nTheorem 4.2. The class CFI is definable in FO. The subclass T CFI of twisted CFIgraphs is definable in BPFO but not in C\u03c9\u221e\u03c9 .\nProof. That CFI is definable is easy to establish, the only subtlety being that B allows us\nto quantify over sets of centre groups, which makes connectedness expressible.\nThe proof that T CFI is not definable in C\u03c9\u221e\u03c9 is the same as in [6]; it is unaffected by the\nadditional structure. Note that because the atoms are ordered, the Boolean algebra is rigid,\ni.e., it has no non-trivial automorphism, therefore the isomorphism group of a CFI-graph\nis not changed by adding the Boolean algebra.\nIt remains to show that twistedness can be defined in BPFO. We pick one vertex from\neach edge group by viewing a random binary relation R as assigning an m-bit number to\neach vertex, where m is the number of atoms in the Boolean algebra. From each pair, we\nchoose the vertex with the smaller number, expressed by\n\u0010\n\u0001\u0011\n\u03be(x) := \u2203y x \u223c y \u2227 \u2203z \u03b1(z) \u2227 \u00acRxz \u2227 Ryz \u2227 \u2200w(w < z \u2192 (Rxw \u2194 Ryw)) ,\n\nwhere \u03b1(x) is an FO-formula satisfied exactly by the atoms of the Boolean algebra. It is\neasy to see that if the random relation R assigns a different set of atoms to the two vertices\nin each edge group, then \u03be succeeds in picking exactly one vertex from each edge group, and\n12\n\n\fboolean algebra\n\nperfectly matched set\n***\n\nM = PA\n\nN = A \\ PA\n\nFigure 3: The structures in B contain a Boolean algebra and a perfectly matched set.\ntwistedness can then be checked by looking at the O-predicate of the element of B which\ncontains exactly the atoms equivalent to twisted centre groups or twisted edgets.\nTo prove that the resulting formula has a large probability gap, we need to establish a\nhigh probability of success only for structures in the class CFI, because this class is FOdefinable. But in such structures, the probability that the two nodes of an edge group are\nassigned the same number is 2\u2212m , so by a union bound the probability that we successfully\npick one node from each group is at least\n1 \u2212 m2\u2212m \u2192 1\n\nbecause there are less than m edgets. Furthermore, we can check in FO whether there is\nan edge group whose members we can not distinguish, and choose to invariably reject or\naccept in these cases, resulting in an RFO or co-RFO sentence, respectively.\n4.2. BPFO on ordered structures is not contained in MSO\nIn the presence of a linear order, any query becomes definable in L\u03c9\u221e\u03c9 , and the query T CFI\nbecomes definable even in FO. However, randomisation adds expressive power to FO also\non ordered structures:\nTheorem 4.3. There is a class B of ordered structures that is definable in BPFO, but not\nin MSO.\nRemember that monadic second-order logic MSO is the the fragment of second-order\nlogic that allows quantification over individual elements and sets of elements.\nLet \u03c3EP \u2264 := {\u2264, E, P }, with binary relations \u2264 and E, and a unary predicate P . We\ndefine two classes B \u2032 , B of \u03c3EP \u2264 -structures (cf. Figure 4.2):\nB \u2032 is the class of all \u03c3EP \u2264 -structures A for which\n(1) E defines a perfect matching on the set M := P (A)\n(2) the set N := V (A) \\ P (A) forms a Boolean algebra with the relation E and\n(3) no x \u2208 N and y \u2208 M are E-related\n(4) \u2264 defines a linear order on the whole structure, which puts the M before the N and\norders M in such a way that matched elements are always successive.\nIt is easy to see that the class B \u2032 is definable in FO. B is the subclass of B \u2032 whose elements\nsatisfy the additional condition\n2|M | \u2265 |N |2 .\n(4.1)\nWe will prove that B is definable in BPFO, but not in MSO. To prove that B is definable\nin BPFO, we will use the following lemma:\n13\n\n\fn\np \u2264 0.2\nm=\n\nn2\n4\n\nm = n2\n\nnc\n\np \u2265 0.5\nm\n\nFigure 4: The Birthday Paradox with \u01eb1 = 0.2, \u01eb2 = 0.5 and c = 4. Here, p denotes\nPr(f is injective).\nLemma 4.4 (Birthday Paradox). Let m, n \u2265 1 and let F : [n] \u2192 [m] be a random function\ndrawn uniformly from the set of all such functions.\n2\n(1) For any \u01eb1 > 0 and c > 2 ln \u01eb11 there is an nc \u2265 1 such that if n > nc and m \u2264 nc we\nhave\nPr(F is injective) \u2264 \u01eb1\n\n(2) For any \u01eb2 > 0, if m \u2265\n\nn2\n2\u01eb2 ,\n\nthen\n\nPr(F is injective) \u2265 1 \u2212 \u01eb2\n\nProof. For the first part, we note that\n\u0012\n\u0013 n\u22121\n\u0013\n\u0012\n\u0013\nn\u22121\nY\u0012\nY\ni\ni\nn(n \u2212 1)\nPr(F injective) =\n1\u2212\nexp \u2212\n\u2264\n= exp \u2212\n.\nm\nm\n2m\ni=0\n\ni=0\n\nFor the second part, note that\n\u0012 \u0013\n\u0010\n\u0011 X 1\nn 1\nn2\n=\n\u2264\n.\nPr(F not injective) = Pr F (i) = F (j) for all i < j \u2264\n2 m\nm\n2m\ni<j\n\nProof of Theorem 4.3. To see that B is not definable in MSO, we use two simple and wellknown facts about MSO. The first is that for every q \u2265 0 there are natural numbers\np, m such that for all k \u2265 0, a plain linear order of length m is indistinguishable from the\nlinear order of length m + k * p by MSO-sentences of quantifier rank at most q. The same\nfact also holds for linear orders with a perfect matching on successive elements, because\nsuch a matching is definable in MSO anyway. The second fact we use is a version of the\nFeferman-Vaught Theorem (cf. [27, Thm. 1.5(ii)]):\nTheorem 4.5. Suppose two \u03c4 -structures U and V satisfy the same MSO-sentences of\nquantifier rank up to q, and let W be another \u03c4 -structure. Denote by U \u2294 W (resp. V \u2294 W )\nthe disjoint union of U (resp. V ) and W . Then U \u2294 W and V \u2294 W satisfy the same\nMSO-sentences of quantifier rank up to q.\nThe theorem also holds for the ordered disjoint union \u2294< instead of the disjoint union,\nbut in our case the elements of the individual structures in the disjoint union are definable\nanyway. If we put these two facts together, we see that for every q \u2265 0 there are p, m\n14\n\n\fsuch that for all k, n the structure A \u2208 B with parts M, N of sizes m, n, respectively, is\nindistinguishable from the structure A\u2032 with parts of sizes m + k * p and n. We can easily\nchoose k and n in such a way that A \u2208 B and A\u2032 6\u2208 B.\nIt remains to prove that B is definable in BPFO. Consider the sentence\n\u0010\n\u0001\u0011\n\u03c6inj := \u2200x\u2200y x=y\n \u0307 \u2228 P x \u2228 P y \u2228 \u2203z P z \u2227 \u00ac(Rxz \u2194 Ryz) ,\n\nwhich states that the random binary relation R, considered as a function\nf : N \u2192 Pow(M ),\n\nx 7\u2192 {y \u2208 M | Rxy}\n\nfrom N to subsets of M , is injective. By the definition of R, the function f is drawn\nuniformly from the set of all such functions. If we fix |N |, the probability for f to be\ninjective increases monotonically with |M |. Furthermore, for every structure in B \u2032 , the size\nof N and M are a power of two and an even number, respectively. Thus either\n1\n2|M | \u2264 |N |2 or 2|M | \u2265 |N |2 ,\n4\nand this factor of 4 translates into a probability gap for \u03c6inj in all sufficiently large structures\nin B \u2032 , by Lemma 4.4 with \u01eb1 = 0.2, \u01eb2 = 0.5 and c = 4. The remaining finitely many\nstructures in B \u2032 can be dealt with separately.\n4.3. RFO is stronger than FO on additive structures\nRecall that an additive structure is one whose vocabulary contains a ternary relation +,\nsuch that A|+ is isomorphic to ([0, |A| \u2212 1], {(a, b, c) | a + b = c}).\nTheorem 4.6. There is a class A of additive structures that is definable in RFO and\nco-RFO, but not in FO.\nOur proof uses the following result:\nTheorem 4.7 (Lynch [26]). For every k \u2208 N there is an infinite set Ak \u2286 N and a dk \u2208 N\nsuch that for all finite Q0 , Q1 \u2286 Ak with |Q0 | = |Q1 | or |Q0 | , |Q1 | > dk the structures\n(N, +, Q0 ) and (N, +, Q1 ) satisfy exactly the same FO-sentences of quantifier rank at most\nk.\nHere (N, +, Qi ) denotes a {+, P }-structure with ternary + and unary P , where + is\ninterpreted as above and P is interpreted by Qi . For a finite set M \u2286 N we denote by\nmax M the maximum element of M . By relativising quantifiers to the maximum element\nsatisfying P , we immediately get the following corollary:\nCorollary 4.8. Let k, Ak , dk , Q0 and Q1 be as above. Then the (finite) structures\n([0, max Q0 ], +, Q0 ) and ([0, max Q1 ], +, Q1 ) satisfy exactly the same FO-sentences of quantifier rank at most k.\nWe call a set Q \u2286 N sparse if |Q \u2229 {n, . . . , 3n}| \u2264 1 for all n \u2265 0. Note that if Q is sparse\nand finite, then |Q| \u2264 log3 (max Q)+1. It is easy to see that there is an FO[{+, P }]-sentence\n\u03c6sparse such that\n([0, max Q], +, Q) |= \u03c6sparse \u21d4 Q is sparse\nfor all finite Q \u2286 N.\n15\n\n\fProof of Theorem 4.6. We define the following class of additive {+, P }-structures:\nA = {([0, max Q], +, Q) | Q is finite, sparse and |Q| is even},\n\nwith + defined as usual. It follows immediately from Corollary 4.8 that A is not definable\nin FO.\nIt remains to prove that A is definable in (co-)RFO. We consider a binary random\nrelation R on Q = ([0, max Q], +, Q) for some finite Q \u2286 N.\nEach element a \u2208 [0, max Q] defines a subset of Q, namely the set of b \u2208 Q for which\n(a, b) \u2208 R(Q) holds. If Q is a sparse set, it has\nmax Q\n2|Q| \u2264 2log3 (max Q)+1 \u2264\n2 ln(max Q)\nmany subsets, and by standard estimates on the coupon collector's problem (see, e.g., [29];\nor use a union-bound argument), if max Q is large enough, with high probability every\nsubset of Q is defined by some element of [0, max Q]. We may check in FO whether this is\nactually the case. If so, we use the random relation R and the linear order induced by + to\ncheck whether Q is even. Otherwise we reject (accept) to get an RFO- (co-RFO-)sentence.\n\n5. BPFO is contained in MSO on additive structures\nIn this section, we prove our first and only nontrivial derandomisation result. It complements the result of Section 4.2 by saying that, on additive structures, every BPFO-sentence\nis equivalent to an MSO-sentence.\nTheorem 5.1. Let \u03c4 be a finite relational vocabulary containing a ternary relation + and\nlet \u03c6 be a BPFO[\u03c4 ]-sentence. Then there exists an MSO-sentence \u03c8 such that on additive\nstructures A\nA |= \u03c6 \u21d4 A |= \u03c8.\nWe first use Nisan's pseudorandom generator for constant depth circuits [32] to reduce\nthe number of random bits to logO(1) n; throughout this section, n will denote the size of\nthe input structure. We then derandomise the resulting formula following Lautemann's\nargument in [24]. The second-order quantifier depth of the resulting MSO formula does not\ndepend on the input formula \u03c6.\nIn MSO[+], one can define a multiplication\nrelation (see [35, Lemma 5.4]) and thus\n\u221a\nquantify over pairs of elements in [0, n]. We only need the existence of such a pairing\nfunction, a slightly weaker form of which is made precise in the following lemma:\nLemma 5.2 (Pairing Lemma). There are MSO[+]-formulas \u03c6p (x) and \u03c6h*,*,*i(x, y, z, w)\nsuch that on additive structures A\n\u2022 \u03c6p (x) defines a number p satisfying\np\np\n|A|\n\u2264 p \u2264 |A|.\n2\nMoreover, p is a prime number.\n\u2022 For every b, c < p there is a unique m such that \u03c6h*,*,*i(0, b, c, m) is satisfied. Furthermore,\nfor every m there is a unique tuple (a, b, c) \u2208 [0, p \u2212 1]3 such that \u03c6h*,*,*i(a, b, c, m) is\nsatisfied. Henceforth we write m = ha, b, ci for this.\n16\n\n\fProof. In MSO[+], we may define a formulas \u03c6X=hxi (X, x) and \u03c6divides (x, y) stating that X\nis the set of multiples of x and x divides y, respectively. We may thus check whether x is\na prime number. Furthermore, we may define the set of powers of a prime number x: It is\nthe largest set containing only numbers whose only prime divisor is x.\nThen p is the largest prime number whose set of powers contains at least one element\nother that 0 and itself. Any number m \u2208 [0, p2 \u2212 1] may be written as m = bp + c with\nb, c \u2208 [0, p \u2212 1]. Both b and c are definable in MSO[+]; notice that b is the largest divisor of\nm \u2212 c smaller than p, or 0 if m < p. For m \u2265 p2 we define m = ha, b, ci with a \u2208 {1, 2, 3}\nand m \u2212 ap2 = h0, b, ci.\nWhenever we write p in this section, we mean the p defined by the \u03c6p above. The Pairing\nLemma allows us to quantify over binary relations on [0, p \u2212 1] \u223c\n= Fp . In particular, we may\ndefine addition and multiplication modulo p, i.e., there are MSO[+]-formulas \u03c6+ (x, y, z)\nand \u03c6\u00d7 (x, y, z) such that for a, b, c \u2208 Fp ,\nand\n\nA |= \u03c6+ (a, b, c)\n\n\u21d4\n\na + b \u2261 c (mod p)\n\nA |= \u03c6\u00d7 (a, b, c) \u21d4 a * b \u2261 c (mod p).\nFor the proof of Theorem 5.1 we may assume that the BPFO-sentence \u03c6 contains only\none random relation, say R of arity r. In fact, using the formulas \u03c6i-th defining the i-th\nelement of an additive structure (cf. section 2.1) we may pack several random relations\nR1 , . . . , Rk of arities r1 , . . . , rk into one random relation R of arity r = 1 + max{r1 , . . . , rk }\nby replacing every occurrence of Ri x1 . . . xri by\n\u2203y (\u03c6i-th (y) \u2227 R\n\ny...y\n| {z }\n\nx1 . . . xri ).\n\n(r\u2212ri ) times\n\nWe first apply a result by Nisan [32] to reduce the number of random bits:\nLemma 5.3. For every r, d \u2208 N and \u01eb > 0 there are n0 \u2208 N and MSO[+]-formulas \u03c6l (x)\nand \u03c6prg (S, x1 , . . . , xr ), where S is a set variable, such that in every additive structure A of\nsize n > n0 ,\n\u2022 \u03c6l defines a number l \u2264 logO(1) n and\n\u2022 if \u03c6 is an FO[\u03c4 \u222a {R}]-sentence of quantifier rank \u2264 d, where \u03c4 is some finite relational\nvocabulary and R is of arity r, then\nPr\n\nX\u2208X (A,{R})\n\n(X |= \u03c6) \u2212 Pr (A |= \u03c6\u2032 (S)) < \u01eb,\nS\u2286[l]\n\nwhere \u03c6\u2032 is the MSO[+]-formula obtained from \u03c6 by replacing every occurrence of R~x by\n\u03c6prg (S, ~x).\nProof. For any fixed structure A of size n we may construct a polynomial-sized circuit\nC\u03c6,A of depth \u2264 d which describes the behaviour of \u03c6 on (\u03c4 \u222a {R})-extensions of A. The\ncircuit has nr inputs indexed by the elements of V (A)r , and an input vector ~x denotes the\n(\u03c4 \u222a {R})-extension B~x of A given by\n~a \u2208 R(B~x ) iff\n\nx~a = 1.\n\nThen C\u03c6,A (~x) evaluates to 1 iff B~x |= \u03c6.\nNisan [32] gave a pseudorandom generator for such circuits which hinges on the following\nlemma:\n17\n\n\fconstant depth\ncircuit\n\nC\nx1\n\nL\n\nL\n\ni\u2208A1 yi\n\n1\n\n...\n\nxn\n\n...\ni\u2208A2 yi\n\nm\n\nL\n\ni\u2208An yi\n\n...\n\n...\n\npseudo\u2212random\nbit generator\n\n...\n\n...\ny1\n\ny2\n\ny3\n\nyl\n\nFigure 5: Nisan's pseudo-random bit generator. The sets Ai \u2286 {1, . . . , l} form a partial(log n, m)-design, i.e., they satisfy |Ai | = m and |Ai \u2229 Aj | \u2264 log n for all 1 \u2264 i 6=\nj \u2264 n.\nLemma 5.4 (restated from [32, Lemma 2.2]). Let {Cn } be a family of circuits of depth d\nand polynomial size, let m = m(n) = (log n)d+3 , l = l(n) and suppose for each n the sets\n(n)\n(n)\nA1 , . . . , An \u2286 [l] satisfy\n(n)\n\n\u2022 Ai\n\u2022\n\n(n)\nAi\n\nThen\n\n= m for all 1 \u2264 i \u2264 n and\n(n)\n\n\u2229 Aj\n\n\u2264 log n for all 1 \u2264 i 6= j \u2264 n.\n\n1\nnc\nfor any c \u2208 N and large enough n. Here, the first probability is taken uniformly over all\nstrings ~x \u2208 {0, 1}n , whereas the second is taken uniformly over all strings ~y \u2208 {0, 1}l .\n|Pr(Cn (~x) = 0) \u2212 Pr(Cn (\u2295i\u2208A1 yi , . . . , \u2295i\u2208An yi ) = 0)| \u2264\n\n(n)\n\nThe resulting pseudorandom generator is depicted in Figure 5. Families of sets Ai\nsatisfying the above conditions are called partial-(log n, m)-designs. Nisan gives a construction with l = m2 = logO(1) n, which drastically reduces the size of the probability space,\ni.e., the number of random bits needed. We now show how his construction can be defined\nin MSO[+].\nOn [0, p \u2212 1], we may define a formula \u03c6log (x, y) which is satisfied iff x = \u2308log2 y\u2309. Using\nthis and the fact that\n2\u2308log p\u2309 \u2212 1 \u2264 \u2308log n\u2309 \u2264 2\u2308log p\u2309 + 2,\nwe let \u03c6m (x) and \u03c6l (x) be two formulas defining natural numbers m and l such that\n\u2022 m is a prime number between (r 2 \u2308log n\u2309)d+3 and 2(r 2 (\u2308log n\u2309 + 3)d+3\n\u2022 l = m2\nUsing the pairing function \u03c6h*,*,*i we may assume that R is a 3r-ary relation which we\nonly need to define for elements in Fp . That is, we define \u03c6prg (S, x1 , . . . , xr ) by\n\u2203z1 * * * \u2203z3r x1 = hz1 , z2 , z3 i \u2227 . . . \u2227 xr = hz3r\u22122 , z3r\u22121 , z3r i \u2227 \u03c6\u2032prg (S, z1 , . . . , z3r )\n\nThe formula \u03c6\u2032prg (S, ~z) takes the parity of a subset of S indexed by ~z:\n\u03c6\u2032prg (S, ~z) := \" |S \u2229 \u03c8(A; ~z )| is even\",\n18\n\n\fwhere \u03c8(x, ~z) is an MSO[+]-formula and \u03c8(A; ~z ) := {x | A |= \u03c8(x, ~z )}; evenness may be\nexpressed in MSO on ordered structures. By Lemma 5.4, we are done if we can define a\nformula \u03c8(x, ~z) such that\n(i) \u03c8(A; ~z) \u2286 [l] for all ~z \u2208 F3r\np ,\n(ii) |\u03c8(A; ~z )| = m for all ~z \u2208 F3r\np , and\n(iii) |\u03c8(A; ~z1 ) \u2229 \u03c8(A; ~z2 )| \u2264 log n for all ~z1 6= ~z2 \u2208 F3r\np ,\nwhich means the sets \u03c8(A; ~z) form a partial-(log n, m)-design. We use the same construction\nas Nisan: We interpret the tuple ~z as a polynomial f~z \u2208 Fm [\u03be] of degree \u2264 log n. The set\n\u03c8(A; ~z ) is then the graph of this polynomial, namely\n\u03c8(A; ~z ) = {(\u03be, f~z (\u03be)) | \u03be \u2208 Fm } \u2286 F2m ,\n\nand we identify F2m with [l]. We first encode the coefficients of f~z into a set variable X as\nfollows: Consider the binary representations\nX\nzi =\nzi,j 2j with zi,j \u2208 {0, 1}\nj\u22650\n\nof the zi . We can define an MSO[+]-sentence \u03c6pack (~z , X) which holds iff X, interpreted as\na binary relation over Fp , holds exactly for pairs (a, b) with\nX\n0 \u2264 a \u2264 \u2308log p\u2309 and b =\nzi,a 2i\u22121 .\n1\u2264i\u22643r\n\nThus for each 0 \u2264 a \u2264 \u2308log p\u2309 there is exactly one b = b(a) with (a, b) \u2208 X, and all\nbs are between 0 and 23r , and thus in Fm if n is large enough. We may now define an\nMSO[+]-sentence \u03c6eval (X, u, v) which, for these Xs, holds iff\nX\nv = f~y (u) =\nb(a)ua ,\n0\u2264a<\u2308log p\u2309\n\nwith addition and multiplication according to\ndefine\n\nFm.\n\nPutting these ingredients together, we\n\n\u03c8(x, ~z) = \u2203X\u2203u\u2203v \"0 \u2264 u, v < m\" \u2227 \u03c6pack (~z, X) \u2227 \u03c6eval (X, u, v) \u2227 \"x = u * m + v\",\n\nwhich is easily verified to satisfy conditions (i) to (iii) above.\n\nSo far we have reduced the number of random bits from nr to l = logO(1) n, and these\nare conveniently packed into the first l bits of a single set variable S. We may now follow\nLautemann's proof [24] to derandomise this sentence.\nProof of Theorem 5.1. After applying Lemma 5.3 we are left with MSO[+]-sentences \u03c6l and\n\u03c6\u2032 such that \u03c6l defines a number l \u2264 logO(1) n and \u03c6\u2032 has a free set variable S. We may\nassume that for all additive structures A,\n1\n1\nor Pr (A |= \u03c6\u2032 (S)) > 1 \u2212 ,\n(5.1)\neither Pr (A |= \u03c6\u2032 (S)) <\nl\nl\nS\u2286[l]\nS\u2286[l]\nbecause otherwise we may use independent repetition and majority vote to obtain these\nbounds. To be precise, let \u03c7(S, i, j) be defined by\n\u03c7(S, i, j) := (0 \u2264 i < l) \u2227 (0 \u2264 j < l) \u2227 \u2203z(z =i\n \u0307 * l + j \u2227 Sz).\n\nThat is, we divide the first l2 bits of S into l blocks of l bits each, and let \u03c7(S, i, j) select\nthe i-th bit of the j-th block. We replace each occurrence of Sx in \u03c6\u2032 by \u03c7(S, i, x) to obtain\n19\n\n\fa formula \u03c6\u0303\u2032 (S, i). Because l is of order logO(1) n, we may quantify over pairs of elements\nof [0, l \u2212 1], which allows us to express the formula\n\u03c6\u0304\u2032 (S) = \"\u03c6\u0303\u2032 (S, i) holds for at least half of the i \u2208 [0, l \u2212 1]\"\n\nin MSO[+], e.g., by stating that there exists a matching M on [0, l \u2212 1] such that\n\u2022 if {i, j} \u2208 M , then exactly one of \u03c6\u0303\u2032 (S, i) and \u03c6\u0303\u2032 (S, j) holds and\n\u2022 all i \u2208 [0, l \u2212 1] for which \u03c6\u0303\u2032 (S, i) does not hold are matched by M .\nThen \u03c6\u0304\u2032 uses l2 = logO(1) n many bits of S, and by the Chernoff bound on the tails of the\nbinomial distribution it satisfies (5.1), even with l replaced by l2 (details can be found in\n[2, sec. 7.4]).\nWe identify subsets of [l] with vectors in Fl2 . Let M \u2286 Fl2 be the set of vectors for\nwhich A |= \u03c6\u2032 (S) holds. Equation (5.1) translates into\n\u0012\n\u0013\nl\nF\n1\n2\nFl2 .\nor |M | > 1 \u2212\n|M | <\nl\nl\nFor a vector ~y \u2208 Fl2 we define\n\n~y \u2295 M := {~x \u2295 ~y | ~x \u2208 M }\n\nto be the set M translated by ~y . We claim the following:\n(a) If |M | < Fl2 /l, then for every choice of vectors ~y1 , . . . , ~yl we have\n[\n(~yi \u2295 M ) 6= Fl2 .\n(b) If |M | > (1 \u2212 1/l)\n\nF\n\nl\n2\n\n1\u2264i\u2264l\n\n, then there are vectors ~y1 , . . . , ~yl such that\n[\n(~yi \u2295 M ) = Fl2 .\n1\u2264i\u2264l\n\nThe first claim follows immediately from |~y \u2295 M | = |M |. For (b), assume that we randomly\nchoose the vectors ~yi independently and uniformly from Fl2 . For any vector ~x \u2208 Fl2 we have\n\u0010\n\u0011 Y\n[\nPr ~x 6\u2208 (~yi \u2295 M ) =\nPr(~x 6\u2208 ~yi \u2295 M )\ni\n\n\u0012 \u0013l\n1\n\u2264\n,\nl\nby the independence of the ~yi . But then the expected number of vectors not in\nis\ni\nh\n\u0010\n\u0011\nX\n[\n[\nPr ~x 6\u2208 (~yi \u2295 M )\nE Fl2 \\ (~yi \u2295 M ) =\n\nS\n\n(~yi \u2295 M )\n\n~\nx\u2208Fl2\n\n\u2264\n\nFl2\nll\n\n=\n\n\u0012 \u0013l\n2\n< 1,\nl\n\nS\nso there must be a choice of ~yi s such that this number is zero, i.e., (~yi \u2295 M ) = Fl2 .\nAgain using the formula \u03c7(S, i, j), we can pack\nS the vectors ~y1 , . . . , ~yl into a single\nexistentially quantified set variable and check that (~yi \u2295 M ) = Fl2 as follows:\n\u03c6\u2032\u2032 = \u2203Y \u2200X\u2203i \u03c6\u2032 (X \u2295 \u03c7(Y, i, *)),\n20\n\n\fwhere \u03c6\u2032 (X \u2295 \u03c7(Y, i, *)) is the formula \u03c6\u2032 (S) with every occurrence of Sx replaced by\n(Xx \u2227 \u03c7(Y, i, x)) \u2228 (\u00acXx \u2227 \u00ac\u03c7(Y, i, x)).\n\nClaims (a) and (b) imply that\n\nA |= \u03c6\u2032\u2032\n\n\u21d4\n\n1\nPr(A |= \u03c6\u2032 (S)) > 1 \u2212 ,\nl\n\nwhich completes the proof.\n\n6. A logic capturing BPP\nIn this section, we prove that the logic BPIFP+C captures the complexity class BPP. Technically, the results of this section are closely related to results in [17].\nCounting logics like FO+C and IFP+C are usually defined via two-sorted structures,\nwhich are equipped with an initial segment of the natural numbers of appropriate length.\nThe expressive power of the resulting logic turns out to be rather robust under changes in\nthe exact definition, see [33] for a detailed survey of this. However, we will only need the\nlimited counting ability provided by the Rescher quantifier, which goes back to a unary\nmajority quantifier defined in [34], see [33].\nWe let FO(J ) be the logic obtained from first-order logic by adjoining a generalised\nquantifier J , the Rescher quantifier. For any two formulas \u03c61 (~x) and \u03c62 (~x), where ~x is a\nk-tuple of variables, we form a new formula\nJ ~x.\u03c61 (~x)\u03c62 (~x).\n\nIts semantics is defined by\nA |= J ~x.\u03c61 (~x)\u03c62 (~x)\n\niff\n{~a \u2208 V (A)k | A |= \u03c61 [~a]} \u2264 {~a \u2208 V (A)k | A |= \u03c62 [~a]} . (6.1)\n\nThe logic IFP(J ) is defined similarly.\nLemma 6.1. Let R be a 6-ary relation symbol. There is a formula \u03c6\u2264 (x, y) \u2208 FO(J )[{R}]\nsuch that\n\u0010\n\u0011\nlim\nPr\n{(a, b) A |= \u03c6\u2264 [a, b] is a linear order of V (A) = 1.\nn\u2192\u221e A\u2208X(Sn ,{R})\n\n(Recall that Sn is the \u2205-structure with universe {1, . . . , n}. Thus X(Sn , {R}) just denotes\nthe set of all {R}-structures with universe {1, . . . , n}.)\nProof. We let\n\u03c6\u2264 (x, y) := J x1 . . . x5 .Rxx1 . . . x5 Ryx1 . . . x5 .\nTo see that \u03c6\u2264 (x, y) defines an order with high probability, let A be a structure with universe\nV (A) = {1, . . . , n}. For each a \u2208 V (A), let\nXa := {~a \u2208 V (A)5 | A |= Ra~a.}\n\nThen A |= \u03c6\u2264 (a, b) iff Xa \u2264 Xb , and \u03c6\u2264 linearly orders A iff the Xa are pairwise distinct.\nBut for a =\n6 b \u2208 V (A), the random variables Xa and Xb are independent and each is\n\n21\n\n\fbinomially distributed with parameters p = 1/2 and m = n5 , and thus\n\u0012 \u0013\n\u0012 \u0013\u0013\nm \u0012\nX\n1 m 2\n1 X m 2\nPr(Xa = Xb ) =\n= 2m\nk\n2m k\n2\nk=0\n\u0012 \u0013\n\u0012\n\u0013\n\u0012\n\u0013\u0012\n\u0013\n1\nm\n1 2m\n1 X m\n=\u0398 \u221a\n,\n= 2m\n= 2m\n2\n2\nm\nm\nk\nm\u2212k\n\nwhere the final approximation can be\nfound, for example, in [13]. The second part now\nn\u0001\nfollows by a union bound over the 2 = \u0398(m2/5 ) pairs a 6= b.\n\nTheorem 6.2. The logic BPIFP(J ) captures BPP.\n\nProof. BPIFP(J ) is contained in BPP, because a randomised polynomial time algorithm\ncan interpret the random relations by using its random bits.\nFor the other direction, let Q be a Boolean query in BPP. This means that there is a\nrandomised polynomial time algorithm M that decides the query Q\u2264 of ordered expansions\nof structures in Q. We may view the (polynomially many) random bits used by M as\npart of the input. Then it follows from the Immerman-Vardi Theorem that there is a\nBPIFP-sentence \u03c8M defining Q\u2264 . Note that, by the definition of Q\u2264 , this sentence is orderinvariant. We replace every occurrence of \u2264 in \u03c8M by the formula \u03c6\u2264 (x, y) of Lemma 6.1,\nwhich with high probability defines a linear order on the universe.\nIt is easy to see that BPIFP+C is also contained in BPP and that IFP(J ) \u2266 IFP+C.\nThus we get the following corollary.\nCorollary 6.3. BPIFP+C = BPIFP(J ), and both capture BPP.\nRemark 6.4. Lemma 6.1 also implies that BPL\u03c9\u221e\u03c9 (J ) \u2261 BPC\u03c9\u221e\u03c9 , because, in the presence\nof an ordering, a quantifier of the form \u2203\u2265n x \u03c6 may be spelled out as\n_ ^\n\u2203x (\u03c6i-th (x) \u2227 \u03c6(x)),\nS\u2282N i\u2208S\n|S|=n\n\nwhere \u03c6i-th (x) defines i-th element in the linear order (cf. section 2.1).\nIn fact, because the formulas \u03c6i use only three distinct variables independent of i, any\nquery is definable in L\u03c9\u221e\u03c9 on ordered structures, as well as on BPC\u03c9\u221e\u03c9 .\n\n7. Summary and Open Problems\nOur main motivation for introducing randomised logics was to apply tools from finite model\ntheory to problems in computational complexity theory, and possibly vice versa. Because\nmost capturing results from descriptive complexity remain valid when both the logic and\nthe complexity class they involve are randomised in the same way, our definitions are indeed\nsuitable for this purpose. In particular, the capturing results by Barrington et al. [3] for\nFO[+, \u00d7] and Behle and Lange [5] for FO[\u2264] and FO[+] fall into this category.\nThis asks for a more detailed investigation of the expressive power of randomised logics.\nFor example, we have shown that BPFO[+] can not be derandomised, while conditional derandomisation results for dlogtime-uniform BPAC0 (cf. [39]) suggest that BPFO[+, \u00d7] might\nbe derandomisable. As this question seems to elude currect techniques, a first step might be\nto find some relation R for which BPFO[R] is derandomisable. Note that derandomisability\n22\n\n\fof non-uniform BPAC0 implies the existence of an infinite sequence (Ri )i\u22651 of relations for\nwhich BPFO[R1 , R2 , . . .] is derandomisable.\nOne obstruction to proving results about randomised logics is that, for example, Ehrenfeucht-Fra\u0131\u0308ss\u00e9 games become quite complicated on structures with both a random and\na non-random part. In [10], the first author proves some non-definability results for BPFO,\nnamely that, on vocabularies with only unary relations, BPFO can be derandomised, and\nthat the ordering relation \u2264 can not be defined in BPFO from its corresponding successor\nrelation. A natural next step would be to prove whether BPFO can be derandomised on\nword models or not.\n\nAcknowledgements\nWe would like to thank Nicole Schweikardt and Dieter van Melkebeek for helpful comments\non an earlier version of this paper.\n\nReferences\n[1] Miklos Ajtai and Michael Ben-Or. A theorem on probabilistic constant depth computations. In Proceedings of the sixteenth annual ACM symposium on Theory of computing, STOC, pages 471\u2013474, New\nYork, NY, USA, 1984. ACM.\n[2] Sanjeev Arora and Boaz Barak. Computational Complexity. Cambridge University Press, 2009.\n[3] David A. Mix Barrington, Neil Immerman, and Howard Straubing. On uniformity within NC1 . J.\nComput. Syst. Sci., 41(3):274\u2013306, 1990.\n[4] J. Barwise and S. Feferman, editors. Model Theoretic Logics. Perspectives in Mathematical Logic.\nSpringer-Verlage, 1985.\n[5] Christoph Behle and Klaus-J\u00f6rn Lange. FO[<]-uniformity. In IEEE Conference on Computational Complexity, pages 183\u2013189, 2006.\n[6] J.-Y. Cai, M. F\u00fcrer, and N. Immerman. An optimal lower bound on the number of variables for graph\nidentifications. Combinatorica, 12(4):389\u2013410, 1992.\n[7] Anuj Dawar, Lauri Hella, and Phokion G. Kolaitis. Implicit definability and infinitary logic in finite\nmodel theory. In ICALP, volume 944 of LNCS, pages 624\u2013635. Springer Verlag, 1995.\n[8] H.-D. Ebbinghaus. Extended logics: The general framework. In J. Barwise and S. Feferman, editors,\nModel\u2013Theoretic Logics, pages 25\u201376. Springer-Verlag, 1985.\n[9] H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Perspectives in Mathematical Logic. SpringerVerlag, 2nd edition, 1999.\n[10] Kord Eickmeyer. Non-definability results for random first-order logic. In Computer Science Logic, September 2011.\n[11] R. Fagin. Generalized first-order spectra and polynomial-time recognizable sets. In Richard M. Karp,\neditor, Complexity of Computation, volume 7 of SIAM-AMS Proceedings, pages 43\u201373, 1974.\n[12] R. Fagin. Probabilities on finite models. Journal of Symbolic Logic, 41:50\u201358, 1976.\n[13] W. Feller. An Introduction to Probability Theory and Its Aplications, volume I. John Wiley & Sons,\n1957.\n[14] Y.V. Glebski\u0131\u0306, D.I. Kogan, M.I. Liogon'ki\u0131\u0306, and V.A. Talanov. Range and degree of realizability of formulas in the restricted predicate calculus. Kibernetika, 2:17\u201328, 1969. Englisch translation, Cybernetics\n5:142\u2013154,1969.\n[15] E. Gr\u00e4del, P.G. Kolaitis, L. Libkin, M. Marx, J. Spencer, M.Y. Vardi, Y. Venema, and S. Weinstein.\nFinite Model Theory and Its Applications. Texts in Theoretical Computer Science. Springer-Verlag,\n2007.\n[16] Y. Gurevich. Logic and the challenge of computer science. In E. B\u00f6rger, editor, Current trends in\ntheoretical computer science, pages 1\u201357. Computer Science Press, 1988.\n[17] L. Hella, P.G. Kolaitis, and K. Luosto. Almost everywhere equivalence of logics in finite model theory.\nThe Bulletin of Symbolic Logic, 2(4):422\u2013443, December 1996.\n23\n\n\f[18] N. Immerman. Relational queries computable in polynomial time. Information and Control, 68:86\u2013104,\n1986.\n[19] N. Immerman. Descriptive Complexity Theory. Graduate Texts in Computer Science. Springer-Verlag,\n1999.\n[20] R. Impagliazzo and A. Wigderson. P = BPP if E requires exponential circuits: Derandomizing the XOR\nlemma. In Proceedings of the 29th ACM Symposium on Theory of Computing, pages 220\u2013229, 1997.\n[21] Russell Impagliazzo. Can every randomized algorithm be derandomized? In Proceedings of the thirtyeighth annual ACM symposium on Theory of computing, STOC '06, pages 373\u2013374, 2006.\n[22] P. Kaye. A logical characterisation of the computational complexity class BPP. Technical report, University of Waterloo, 2002.\n[23] P. G. Kolaitis and M. Y. Vardi. Infinitary logics and 0-1 laws. Information and Computation, 98:258\u2013294,\n1992.\n[24] C. Lautemann. BPP and the polynomial hierarchy. Information Processing Letters, 17(4):215\u2013217, 1983.\n[25] L. Libkin. Elements of Finite Model Theory. Texts in Theoretical Computer Science. Spinger-Verlag,\n2004.\n[26] J.F. Lynch. On sets of relations definable by addition. Journal of Symbolic Logic, 47(3):659\u2013668, 1982.\n[27] J. A. Makowski. Algorithmic uses of the feferman-vaught theorem. Annals of Pure and Applied Logic,\n126(1-3):159\u2013213, April 2004.\n[28] J.C. Mitchell, M. Mitchell, and A. Scedrov. A linguistic characterization of bounded oracle computation\nand probabilistic polynomial time. In Proceedings of the 39th Annual IEEE Symposium on Foundations\nof Computer Science, pages 725\u2013733, 1998.\n[29] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University Press, 1995.\n[30] M. M\u00fcller. Valiant-vazirani lemmata for various logics. Electronic Colloquium on Computational Complexity (ECCC), 15(063), 2008.\n[31] N. Nisan and A. Wigderson. Hardness vs randomness. Journal of Computer and System Sciences,\n49:149\u2013167, 1994.\n[32] Noam Nisan. Pseudorandom bits for constant depth circuits. Combinatorica, 11(1):63\u201370, 1991.\n[33] M. Otto. Bounded Variable Logics and Counting. Lecture Notes in Logic. Springer-Verlag, 1996.\n[34] N. Rescher. Plurality quantification. Journal of Symbolic Logic, 27(3):373\u2013374, 1962.\n[35] Nicole Schweikardt. On the expressive power of monadic least fixed point logic. Theor. Comput. Sci.,\n350(2-3):325\u2013344, 2006.\n[36] L. Stockmeyer. The polynomial hierarchy. Theoretical Computer Science, 3:1\u201322, 1977.\n[37] S. Toda. PP is as hard as the polynomial-time hierarchy. SIAM Journal on Computing, 20(5):865\u2013877,\n1991.\n[38] M.Y. Vardi. The complexity of relational query languages. In Proceedings of the 14th ACM Symposium\non Theory of Computing, pages 137\u2013146, 1982.\n[39] Emanuele Viola. The complexity of constructing pseudorandom generators from hard functions. Computational Complexity, 13:147\u2013188, 2004.\n\n24\n\nThis work is licensed under the Creative Commons Attribution-NoDerivs License. To view\na copy of this license, visit http://creativecommons.org/licenses/by-nd/2.0/ or send a\nletter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or\nEisenacher Strasse 2, 10777 Berlin, Germany\n\n\f"}