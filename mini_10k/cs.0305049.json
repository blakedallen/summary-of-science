{"id": "http://arxiv.org/abs/cs/0305049v1", "guidislink": true, "updated": "2003-05-28T15:16:08Z", "updated_parsed": [2003, 5, 28, 15, 16, 8, 2, 148, 0], "published": "2003-05-28T15:16:08Z", "published_parsed": [2003, 5, 28, 15, 16, 8, 2, 148, 0], "title": "The Athena Data Dictionary and Description Language", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0506002%2Ccs%2F0506017%2Ccs%2F0506036%2Ccs%2F0506032%2Ccs%2F0506054%2Ccs%2F0506018%2Ccs%2F0506059%2Ccs%2F0506013%2Ccs%2F0506035%2Ccs%2F0506007%2Ccs%2F0506022%2Ccs%2F0506100%2Ccs%2F0506027%2Ccs%2F0506038%2Ccs%2F0506037%2Ccs%2F0506103%2Ccs%2F0506039%2Ccs%2F0506062%2Ccs%2F0506065%2Ccs%2F0506006%2Ccs%2F0506021%2Ccs%2F0506019%2Ccs%2F0506051%2Ccs%2F0506001%2Ccs%2F0506044%2Ccs%2F0506020%2Ccs%2F0506034%2Ccs%2F0506076%2Ccs%2F0506011%2Ccs%2F0506008%2Ccs%2F0506053%2Ccs%2F0506033%2Ccs%2F0305041%2Ccs%2F0305049%2Ccs%2F0305023%2Ccs%2F0305060%2Ccs%2F0305014%2Ccs%2F0305040%2Ccs%2F0305002%2Ccs%2F0305044%2Ccs%2F0305004%2Ccs%2F0305012%2Ccs%2F0305033%2Ccs%2F0305024%2Ccs%2F0305021%2Ccs%2F0305054%2Ccs%2F0305055%2Ccs%2F0305027%2Ccs%2F0305048%2Ccs%2F0305047%2Ccs%2F0305052%2Ccs%2F0305022%2Ccs%2F0305007%2Ccs%2F0305059%2Ccs%2F0305010%2Ccs%2F0305030%2Ccs%2F0305063%2Ccs%2F0305026%2Ccs%2F0305051%2Ccs%2F0305061%2Ccs%2F0305062%2Ccs%2F0305005%2Ccs%2F0305058%2Ccs%2F0305008%2Ccs%2F0305001%2Ccs%2F0305006%2Ccs%2F0305009%2Ccs%2F0305016%2Ccs%2F0305056%2Ccs%2F0305018%2Ccs%2F0305029%2Ccs%2F0305028%2Ccs%2F0305019%2Ccs%2F0305037%2Ccs%2F0305032%2Ccs%2F0305053%2Ccs%2F0305017%2Ccs%2F0305035%2Ccs%2F0305045%2Ccs%2F0305036%2Ccs%2F0305050%2Ccs%2F0305064%2Ccs%2F0305034%2Ccs%2F0305057%2Ccs%2F0305066%2Ccs%2F0305046%2Ccs%2F0305020%2Ccs%2F0305065%2Ccs%2F0305042%2Ccs%2F0305038%2Ccs%2F0305011%2Ccs%2F0305003%2Ccs%2F0305039%2Ccs%2F0305031%2Ccs%2F0305013%2Ccs%2F0305015%2Ccs%2F0305025%2Ccs%2F0207066%2Ccs%2F0207070%2Ccs%2F0207087%2Ccs%2F0207020&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The Athena Data Dictionary and Description Language"}, "summary": "Athena is the ATLAS off-line software framework, based upon the GAUDI\narchitecture from LHCb. As part of ATLAS' continuing efforts to enhance and\ncustomise the architecture to meet our needs, we have developed a data object\ndescription tool suite and service for Athena. The aim is to provide a set of\ntools to describe, manage, integrate and use the Event Data Model at a design\nlevel according to the concepts of the Athena framework (use of patterns,\nrelationships, ...). Moreover, to ensure stability and reusability this must be\nfully independent from the implementation details. After an extensive\ninvestigation into the many options, we have developed a language grammar based\nupon a description language (IDL, ODL) to provide support for object\nintegration in Athena. We have then developed a compiler front end based upon\nthis language grammar, JavaCC, and a Java Reflection API-like interface. We\nhave then used these tools to develop several compiler back ends which meet\nspecific needs in ATLAS such as automatic generation of object converters, and\ndata object scripting interfaces. We present here details of our work and\nexperience to date on the Athena Definition Language and Athena Data\nDictionary.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0506002%2Ccs%2F0506017%2Ccs%2F0506036%2Ccs%2F0506032%2Ccs%2F0506054%2Ccs%2F0506018%2Ccs%2F0506059%2Ccs%2F0506013%2Ccs%2F0506035%2Ccs%2F0506007%2Ccs%2F0506022%2Ccs%2F0506100%2Ccs%2F0506027%2Ccs%2F0506038%2Ccs%2F0506037%2Ccs%2F0506103%2Ccs%2F0506039%2Ccs%2F0506062%2Ccs%2F0506065%2Ccs%2F0506006%2Ccs%2F0506021%2Ccs%2F0506019%2Ccs%2F0506051%2Ccs%2F0506001%2Ccs%2F0506044%2Ccs%2F0506020%2Ccs%2F0506034%2Ccs%2F0506076%2Ccs%2F0506011%2Ccs%2F0506008%2Ccs%2F0506053%2Ccs%2F0506033%2Ccs%2F0305041%2Ccs%2F0305049%2Ccs%2F0305023%2Ccs%2F0305060%2Ccs%2F0305014%2Ccs%2F0305040%2Ccs%2F0305002%2Ccs%2F0305044%2Ccs%2F0305004%2Ccs%2F0305012%2Ccs%2F0305033%2Ccs%2F0305024%2Ccs%2F0305021%2Ccs%2F0305054%2Ccs%2F0305055%2Ccs%2F0305027%2Ccs%2F0305048%2Ccs%2F0305047%2Ccs%2F0305052%2Ccs%2F0305022%2Ccs%2F0305007%2Ccs%2F0305059%2Ccs%2F0305010%2Ccs%2F0305030%2Ccs%2F0305063%2Ccs%2F0305026%2Ccs%2F0305051%2Ccs%2F0305061%2Ccs%2F0305062%2Ccs%2F0305005%2Ccs%2F0305058%2Ccs%2F0305008%2Ccs%2F0305001%2Ccs%2F0305006%2Ccs%2F0305009%2Ccs%2F0305016%2Ccs%2F0305056%2Ccs%2F0305018%2Ccs%2F0305029%2Ccs%2F0305028%2Ccs%2F0305019%2Ccs%2F0305037%2Ccs%2F0305032%2Ccs%2F0305053%2Ccs%2F0305017%2Ccs%2F0305035%2Ccs%2F0305045%2Ccs%2F0305036%2Ccs%2F0305050%2Ccs%2F0305064%2Ccs%2F0305034%2Ccs%2F0305057%2Ccs%2F0305066%2Ccs%2F0305046%2Ccs%2F0305020%2Ccs%2F0305065%2Ccs%2F0305042%2Ccs%2F0305038%2Ccs%2F0305011%2Ccs%2F0305003%2Ccs%2F0305039%2Ccs%2F0305031%2Ccs%2F0305013%2Ccs%2F0305015%2Ccs%2F0305025%2Ccs%2F0207066%2Ccs%2F0207070%2Ccs%2F0207087%2Ccs%2F0207020&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Athena is the ATLAS off-line software framework, based upon the GAUDI\narchitecture from LHCb. As part of ATLAS' continuing efforts to enhance and\ncustomise the architecture to meet our needs, we have developed a data object\ndescription tool suite and service for Athena. The aim is to provide a set of\ntools to describe, manage, integrate and use the Event Data Model at a design\nlevel according to the concepts of the Athena framework (use of patterns,\nrelationships, ...). Moreover, to ensure stability and reusability this must be\nfully independent from the implementation details. After an extensive\ninvestigation into the many options, we have developed a language grammar based\nupon a description language (IDL, ODL) to provide support for object\nintegration in Athena. We have then developed a compiler front end based upon\nthis language grammar, JavaCC, and a Java Reflection API-like interface. We\nhave then used these tools to develop several compiler back ends which meet\nspecific needs in ATLAS such as automatic generation of object converters, and\ndata object scripting interfaces. We present here details of our work and\nexperience to date on the Athena Definition Language and Athena Data\nDictionary."}, "authors": ["Alain Bazan", "Thierry Bouedo", "Philippe Ghez", "Massimo Marino", "Craig Tull"], "author_detail": {"name": "Craig Tull"}, "author": "Craig Tull", "arxiv_comment": "4 pages, 2 figures", "links": [{"href": "http://arxiv.org/abs/cs/0305049v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0305049v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.SE", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "D.2.2", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0305049v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0305049v1", "journal_reference": "ECONFC0303241:MOJT010,2003", "doi": null, "fulltext": "Computing in High Energy and Nuclear Physics, La Jolla, California, March 24-28, 2003\n\n1\n\nThe Athena Data Dictionary and Description Language\nAlain Bazan, Thierry Bouedo, Philippe Ghez\nLAPP, Annecy-le-Vieux, FRANCE\nMassimo Marino, Craig Tull\nLBNL, Berkeley, USA\nAthena is the ATLAS off-line software framework, based upon the GAUDI architecture from LHCb. As part of ATLAS'\ncontinuing efforts to enhance and customise the architecture to meet our needs, we have developed a data object description\ntool suite and service for Athena. The aim is to provide a set of tools to describe, manage, integrate and use the Event Data\nModel at a design level according to the concepts of the Athena framework (use of patterns, relationships, ...). Moreover, to\nensure stability and reusability this must be fully independent from the implementation details. After an extensive investigation\ninto the many options, we have developed a language grammar based upon a description language (IDL, ODL) to provide\nsupport for object integration in Athena. We have then developed a compiler front end based upon this language grammar,\nJavaCC, and a Java Reflection API-like interface. We have then used these tools to develop several compiler back ends which\nmeet specific needs in ATLAS such as automatic generation of object converters, and data object scripting interfaces. We\npresent here details of our work and experience to date on the Athena Definition Language and Athena Data Dictionary.\n\nformats) which contain metadata describing the\npayload of the data file, etc...\n\n1. INTRODUCTION\nThis document describes in brief the development and\nimplementation of an \"ATLAS Data Dictionary\" (ADD) in\nthe Athena Architecture. For full details see:[1].\nAthena is the ATLAS off-line software framework, based\nupon the GAUDI architecture from LHCb. As part of\nATLAS' continuing efforts to enhance and customise the\narchitecture to meet needs of the users, we have developed\na data object description tool suite and service for Athena.\nThe term \"data dictionary\" is being used in ATLAS to\ncover several related, but distinct concepts and techniques.\nEach of these concepts plays a different set of roles in an\narchitecture dependent upon a data dictionary. We\ncategorise these concepts into three general topics:\n\u2022 Introspection/Reflection/Object\nDescription/Run-Time Typing: This refers to\nobjects in program memory with the ability to\ndescribe themselves in a programmatic way through\na public API such that they can be manipulated\nwithout a priori knowledge of the specific\nclass/type of the object.\n\u2022\nCode Generation: This refers to a process of\ngenerating code for performing a specific task from\na generic description/input file.\n\u2022\nSelf-Describing External Data Representation\n(e.g. Data Files): This refers to external data\nrepresentations (e.g. file formats, on-wire data\nMachine Independence\nProgramming Language Independence\nOpen-Source/Free Parsers Available\nObject Behavior Definable\nObject State Definable\nPublic/Private Member\nPersistency\nUse of Predefined Types\nUse of External (Undefined) Types\n\n2. ADVANTAGE OF A DATA DICTIONARY\nThe data dictionary is a description of the objects to a\nhigh abstraction level.\nThese tool avoid tedious integration of objects to the\nframework, concentrate the object development only on\nhis behaviour and provide the objects with all the\nmechanism of conversion between transient and persistent\nstores . At run time it gives access to transient objects\nallowing debugging, visualisation, use scripting... These\ndescription allows re-use of the objects already present in\nthe dictionary, the management of the evolution of the\ndescribed objects and provides information on persistent\nobjects and collections without loading them in transient\nstore.\n\n3. LANGUAGE AND TOOLS\n3.1.\n\nOne of the most visible implementation decisions of a\nDD for Athena is the choice of the computer language\nused in the dictionary. Declarative computer languages are\nwidely used tools in the CS and IT communities. A list of\n\nC++\n\nIDL\n\nJAVA\n\nODL\n\nDDL\n\nXML\n\nNo\nNo\nYes\nYes\nYes\nYes\nNo\nYes\nNo\n\nYes\nYes\nYes\nYes\nYes\nNo\nNo\nYes\nNo\n\nYes\nNo\nYes\nYes\nYes\nYes\nYes\nYes\nNo\n\nYes\nYes\nYes\nYes\nYes\nNo\nNo\nYes\nNo\n\nYes\nNo\nNo\nYes\nYes\nYes\nYes\nYes\nNo\n\nYes\nYes\n?\n?\n?\n?\n?\n?\n?\n\nTable 3: ADL candidate feature comparison\nMOJT010\n\nChoice\n\n\f2\n\nComputing in High Energy and Nuclear Physics, La Jolla, California, March 24-28, 2003\n\nchoices considered and associated tools available to parse\nthe language is shown in the comparison's Table 3:\nAfter an extensive investigation into the many options,\nwe concluded that none of the language candidates fully\nmatched ATLAS requirements, and that some compromise\nand/or language extension would be required.\nWe settled on and developed a language grammar based\nupon a proper subset of IDL 2.0 extended to provide\nsupport for object persistency and complex inter-object\nrelationships.\nThe included extensions are:\nODL keyword to express bi-directional relationships:\nrelationship\nkeyword to express persistency: persistent\nkeyword to support opaque objects: extern\nkeyword to declare objects of Athena: DataObject,\nContainedObject, CollectionObject keyword to manage\nthe visibility of the objects attributes: private\n\nOf all the tools considered and evaluated, JavaCC was the\nonly one which supported all of the candidate languages.\nThis made it particularly attractive in that a change in\nADL language does not imply a change in parser.\n\n4. DESIGN\n4.1. From description to utilisation\nThe high-level design of the code generator is a standard\n2-tier design. An ADL object description is fed into the\nCompiler Front End (CFE) consisting of the JavaCC\ngenerated parser (from the ADL Grammar). The parser\nproduces an Abstract Syntax Tree using the JJTree\npackage. A standard visitor pattern class walks the AST\nand fills an in-memory representation of the object\ndescription (the Meta-Object Representation). Multiple\nCompiler Back Ends (CBEs) use the information stored in\nthe Meta-Object Representation to generate code for use in\nthe Athena framework.\n\nWe called this extended proper subset of IDL: ADL for\nAthena Description Language. Such a declarative language\nhelps separating objects' interfaces and behaviours from\ntheir implementations, isolating users of a system from\nimplementation details, facilitating technology migration,\nand easing software development by eliminating tedious\nand error-prone rote programming.\nMoreover, the choice of ADL because of its explicit\nindependence of programming languages makes future\npossible evolution more feasible.\n\nBack\nBack\nEEnndd\nCode\n\nCxx,Java,...\n\nSource\nA\nDL\nADL\n\nADL\nParser\nJavaCC\n\nADL\nAnalyzer\n\nMeta Objet\nRepresentation\n\nBack\nBack\nEEnndd\nCode\n\nCxx,Java,...\n\nCompiler Front End\nBack\nBack\nEEnndd\n\n3.2. Tools\n\nCode\n\nCode generation tools are parser-based tools which\nprocess the ADL. With the choice of a real computer\nlanguage as the basis of the Data Dictionary, it becomes\nimperative that a real parser be used to compile the DD\nlanguage and realise the DD functionality. Experience has\nshown that multiple back-ends (emitters) for the parser are\nnecessary. The reality of a possible evolution of ADL\nsuggests that the compiler front-end should be replaceable.\nWe chose JavaCC (the Java Compiler Compiler) as the\nparser for our compiler front end for the following\nreasons:\n\u2022 Large number of languages supported (34\ngrammars from Ada to XML)\n\u2022 Widely used & actively supported and developed\n\u2022 Easily extended grammar\n\u2022 Platform independence\n\nMOJT010\n\nCxx,Java,...\n\n4.2. Meta-model\nThe Meta-Object Representation is a set of classes\nimplementing a Java Reflection-like API and which\ninsulates the writers of the compiler back-ends (CBEs)\nfrom the details of the JJTree AST. The static class\ndiagram including the Meta-Object Representation design\nis shown in Figure 4.2.\n\n\fComputing in High Energy and Nuclear Physics, La Jolla, California, March 24-28, 2003\n\n3\n\nGenObject\n\nInterfaceDefinition\n\n0..*\n\n1\n\nRelationDefinition\n\nElementaryDefinition\n\n0..*\n\n0..*\n\n0..*\n\n0..*\n\n0..*\n\n0..*\nStructureDefinition\n\n1\nAttributeDefinition1\n0..*\n\n0..1\n\nTypeDefinition\n\n1\nOperationDefinition\n\n1\n\nParameterDefinition\n\n0..*\n\nFigure 4.2 UML static class diagram\n\n5. FUNCTIONALITIES\n5.1. Code generation\nThe last code for the ATLAS data dictionary was\nreleased at the end of November 2002. Included in this\nrelease was the full ADL JavaCC grammar and generated\nparser, the JJTree-based visitor and Meta-Object\nRepresentation classes, and three compiler back ends. The\nfollowing use cases diagram shows how to generate code:\n\n\u2022 Scripting CBE: Provides a Python interface allowing\nlimited access to, and control of data objects at the\ncommand line (see CHEP'01 paper 3-064). The three back\nends work together or independently to provide needed\nAthena functionalities.\n\n5.2. Dynamic interaction\nAnother main functionality of the Athena Data\nDictionary is to dynamically manage the described objects.\nIt answers the use cases as shown in the following\ndiagram:\n\nChoose the back-end\nfind described object\n\nconfigure the back-end\n\ncreate described object\n\nbrowse described objects\n\ndelete described object\n\nuser\nuser\n\ncompile & generate code\n\nfind object description\naccess attributes of a described object\n\nAlthough it is easy to write a new back-end as needed, the\nthree following Compiler Back Ends are provided today:\n\u2022 Data Object CBE: Generates C++ classes for user\ndata objects with: ATLAS defined Constructors and\nDestructors, Single and Multiple Inheritance, Private Data\nMembers & Accessor/ Mutator Methods, Public Method\nFunctions (beyond accessors/mutators), Interobject\nAssociations, STL Support, and user written extensions.\n\u2022 Converter CBE: Generates Athena converters for\npersistency using Objectivity Conversion service or ROOT\nconversion service.\n\nMOJT010\n\ncall method on a described object\n\nThis functionality is mainly based on an\nIntrospection/Reflection mechanism allowing connections\nbetween object's description and object's instance at runtime. This refers to objects in program memory with the\nability to describe themselves in a programmatic way\nthrough a public API such that they can be manipulated\nwithout a priori knowledge of the specific class/type of the\nobject.\n\n\f4\n\nComputing in High Energy and Nuclear Physics, La Jolla, California, March 24-28, 2003\n\nThis functionality should integrated and used in Athena\naccording to the sequence shown in the figure 5.3.\n\nCreation\nCreation\n\nData Dictionary\n\u2022 Service\n\nAccess interface\n\nRegistration\nRegistration\n\nAlgorithm\n\nADL\nADL\nObject\n\nRegistration\nRegistration\n\nSERVICES\nRegistered objects list\nObject description\nMethod invocation\nData member consultation\n\nAccess\nAccess\nDescription\nDescription\n\nScripting Browser\n\nTransient\nEvent Store\n\nADL Object Descriptions\nRepository\n\nAccess\nAccess\n\nIntrospection\nModule\n\nFigure 5.3 Dynamic interaction\nThe sequence goes through the following steps:\n1. Creation of the object by the algorithm\n2. Registration to the transient store and the data\ndictionary service\n3. Access to the object description by the interactive part\nof the framework\n4. Access to the object through the data dictionary\nservice and the introspection module\n\nmodel. Integration in Athena has also been done by\nwriting CMT fragments and Automatic ClassID\ngeneration. Connected to the ADL, a module has been\ndeveloped for the Together case tool to generate\ngraphically ADL code [2]. Moreover, a large amount of\ndocumentation (user guide, language reference manual,\npocket guide, examples, FAQ,...) has been produce to\nprovide user support.\nNevertheless, although this data dictionary project was\nanswering the Atlas requirements, it has been abandon.\nThis implies to ask ourselves about the reasons to draw\nlessons from that:\n\u2022 Are people really ready to concentrate there efforts\nat the design level using an high level description\nlanguage, independent of the implementation?\n\u2022 Has this tool taken place too late in the Athena\nframework while a lot of C++ code was already\nwritten? (connected feedback: reverse engineering\nis not miraculous!).\n\u2022 Has this project been politically killed at the birth of\nthe LCG?\n\nReferences\n[1]\n\n[2]\n\n6. CONCLUSION\nThe data dictionary-based code generators have been\nsuccessfully used by some ATLAS collaborators, and\nthree tutorials were given in June 2001, March 2002 and\nMay 2002 based upon a Liquid Argon reconstruction data\n\nMOJT010\n\nA. Bazan, T. Bouedo, P.Ghez, M.Marino, C.E.Tull,\n\"Athena Web site - Dictionary\",\nhttp://atlas.web.cern.ch/Atlas/GROUPS/\nSOFTWARE/OO/architecture/DataDictionary/.\nM.Marino \"Extending the code generation\ncapabilities of the Together CASE tool to support\nData Definition languages\", 2003 Computing in\nHigh Energy and Nuclear Physics (CHEP03), La\nJolla, CA, USA, 2003\n\n\f"}