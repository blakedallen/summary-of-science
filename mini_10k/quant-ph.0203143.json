{"id": "http://arxiv.org/abs/quant-ph/0203143v1", "guidislink": true, "updated": "2002-03-28T22:54:43Z", "updated_parsed": [2002, 3, 28, 22, 54, 43, 3, 87, 0], "published": "2002-03-28T22:54:43Z", "published_parsed": [2002, 3, 28, 22, 54, 43, 3, 87, 0], "title": "Programmable Logic Devices in Experimental Quantum Optics", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0203107%2Cquant-ph%2F0203085%2Cquant-ph%2F0203127%2Cquant-ph%2F0203083%2Cquant-ph%2F0203064%2Cquant-ph%2F0203132%2Cquant-ph%2F0203011%2Cquant-ph%2F0203042%2Cquant-ph%2F0203072%2Cquant-ph%2F0203063%2Cquant-ph%2F0203026%2Cquant-ph%2F0203130%2Cquant-ph%2F0203071%2Cquant-ph%2F0203067%2Cquant-ph%2F0203151%2Cquant-ph%2F0203055%2Cquant-ph%2F0203007%2Cquant-ph%2F0203056%2Cquant-ph%2F0203030%2Cquant-ph%2F0203079%2Cquant-ph%2F0203060%2Cquant-ph%2F0203150%2Cquant-ph%2F0203093%2Cquant-ph%2F0203105%2Cquant-ph%2F0203069%2Cquant-ph%2F0203003%2Cquant-ph%2F0203100%2Cquant-ph%2F0203005%2Cquant-ph%2F0203092%2Cquant-ph%2F0203143%2Cquant-ph%2F0203053%2Cquant-ph%2F0203140%2Cquant-ph%2F0203002%2Cquant-ph%2F0203111%2Cquant-ph%2F0203025%2Cquant-ph%2F0203077%2Cquant-ph%2F0203044%2Cquant-ph%2F0203018%2Cquant-ph%2F0203058%2Cquant-ph%2F0203090%2Cquant-ph%2F0203120%2Cquant-ph%2F0203033%2Cquant-ph%2F0203125%2Cquant-ph%2F0203080%2Cquant-ph%2F0203112%2Cquant-ph%2F0203097%2Cquant-ph%2F0203121%2Cquant-ph%2F0203035%2Cquant-ph%2F0203041%2Cquant-ph%2F0203144%2Cquant-ph%2F0203084%2Cquant-ph%2F0203019%2Cquant-ph%2F0203124%2Cquant-ph%2F0203108%2Cquant-ph%2F0203010%2Cquant-ph%2F0203049%2Cquant-ph%2F0203126%2Cquant-ph%2F0203133%2Cquant-ph%2F0203116%2Cquant-ph%2F0203141%2Cquant-ph%2F0203008%2Cquant-ph%2F0203146%2Cquant-ph%2F0203082%2Cquant-ph%2F0203015%2Cquant-ph%2F0203113%2Cquant-ph%2F0203051%2Cquant-ph%2F0203061%2Cquant-ph%2F0203152%2Cquant-ph%2F0203054%2Cquant-ph%2F0203029%2Cquant-ph%2F0203149%2Cquant-ph%2F0203066%2Cquant-ph%2F0203045%2Cquant-ph%2F0203046%2Cquant-ph%2F0203139%2Cquant-ph%2F0203052%2Cquant-ph%2F0203006%2Cquant-ph%2F0203009%2Cquant-ph%2F0203099%2Cquant-ph%2F0203148%2Cquant-ph%2F0203028%2Cquant-ph%2F0203098%2Cquant-ph%2F0203057%2Cquant-ph%2F0203135%2Cquant-ph%2F0203129%2Cquant-ph%2F0203043%2Cquant-ph%2F0203142%2Cquant-ph%2F0203089%2Cquant-ph%2F0203020%2Cquant-ph%2F0203048%2Cquant-ph%2F0203021%2Cquant-ph%2F0203106%2Cquant-ph%2F0203118%2Cquant-ph%2F0203117%2Cquant-ph%2F0203096%2Cquant-ph%2F0203014%2Cquant-ph%2F0203027%2Cquant-ph%2F0203138%2Cquant-ph%2F0203119%2Cquant-ph%2F0203013%2Cquant-ph%2F0203086&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Programmable Logic Devices in Experimental Quantum Optics"}, "summary": "We discuss the unique capabilities of programmable logic devices (PLD's) for\nexperimental quantum optics and describe basic procedures of design and\nimplementation. Examples of advanced applications include optical metrology and\nfeedback control of quantum dynamical systems. As a tutorial illustration of\nthe PLD implementation process, a field programmable gate array (FPGA)\ncontroller is used to stabilize the output of a Fabry-Perot cavity.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=quant-ph%2F0203107%2Cquant-ph%2F0203085%2Cquant-ph%2F0203127%2Cquant-ph%2F0203083%2Cquant-ph%2F0203064%2Cquant-ph%2F0203132%2Cquant-ph%2F0203011%2Cquant-ph%2F0203042%2Cquant-ph%2F0203072%2Cquant-ph%2F0203063%2Cquant-ph%2F0203026%2Cquant-ph%2F0203130%2Cquant-ph%2F0203071%2Cquant-ph%2F0203067%2Cquant-ph%2F0203151%2Cquant-ph%2F0203055%2Cquant-ph%2F0203007%2Cquant-ph%2F0203056%2Cquant-ph%2F0203030%2Cquant-ph%2F0203079%2Cquant-ph%2F0203060%2Cquant-ph%2F0203150%2Cquant-ph%2F0203093%2Cquant-ph%2F0203105%2Cquant-ph%2F0203069%2Cquant-ph%2F0203003%2Cquant-ph%2F0203100%2Cquant-ph%2F0203005%2Cquant-ph%2F0203092%2Cquant-ph%2F0203143%2Cquant-ph%2F0203053%2Cquant-ph%2F0203140%2Cquant-ph%2F0203002%2Cquant-ph%2F0203111%2Cquant-ph%2F0203025%2Cquant-ph%2F0203077%2Cquant-ph%2F0203044%2Cquant-ph%2F0203018%2Cquant-ph%2F0203058%2Cquant-ph%2F0203090%2Cquant-ph%2F0203120%2Cquant-ph%2F0203033%2Cquant-ph%2F0203125%2Cquant-ph%2F0203080%2Cquant-ph%2F0203112%2Cquant-ph%2F0203097%2Cquant-ph%2F0203121%2Cquant-ph%2F0203035%2Cquant-ph%2F0203041%2Cquant-ph%2F0203144%2Cquant-ph%2F0203084%2Cquant-ph%2F0203019%2Cquant-ph%2F0203124%2Cquant-ph%2F0203108%2Cquant-ph%2F0203010%2Cquant-ph%2F0203049%2Cquant-ph%2F0203126%2Cquant-ph%2F0203133%2Cquant-ph%2F0203116%2Cquant-ph%2F0203141%2Cquant-ph%2F0203008%2Cquant-ph%2F0203146%2Cquant-ph%2F0203082%2Cquant-ph%2F0203015%2Cquant-ph%2F0203113%2Cquant-ph%2F0203051%2Cquant-ph%2F0203061%2Cquant-ph%2F0203152%2Cquant-ph%2F0203054%2Cquant-ph%2F0203029%2Cquant-ph%2F0203149%2Cquant-ph%2F0203066%2Cquant-ph%2F0203045%2Cquant-ph%2F0203046%2Cquant-ph%2F0203139%2Cquant-ph%2F0203052%2Cquant-ph%2F0203006%2Cquant-ph%2F0203009%2Cquant-ph%2F0203099%2Cquant-ph%2F0203148%2Cquant-ph%2F0203028%2Cquant-ph%2F0203098%2Cquant-ph%2F0203057%2Cquant-ph%2F0203135%2Cquant-ph%2F0203129%2Cquant-ph%2F0203043%2Cquant-ph%2F0203142%2Cquant-ph%2F0203089%2Cquant-ph%2F0203020%2Cquant-ph%2F0203048%2Cquant-ph%2F0203021%2Cquant-ph%2F0203106%2Cquant-ph%2F0203118%2Cquant-ph%2F0203117%2Cquant-ph%2F0203096%2Cquant-ph%2F0203014%2Cquant-ph%2F0203027%2Cquant-ph%2F0203138%2Cquant-ph%2F0203119%2Cquant-ph%2F0203013%2Cquant-ph%2F0203086&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We discuss the unique capabilities of programmable logic devices (PLD's) for\nexperimental quantum optics and describe basic procedures of design and\nimplementation. Examples of advanced applications include optical metrology and\nfeedback control of quantum dynamical systems. As a tutorial illustration of\nthe PLD implementation process, a field programmable gate array (FPGA)\ncontroller is used to stabilize the output of a Fabry-Perot cavity."}, "authors": ["J. Stockton", "M. Armen", "H. Mabuchi"], "author_detail": {"name": "H. Mabuchi"}, "author": "H. Mabuchi", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1364/JOSAB.19.003019", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/quant-ph/0203143v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/quant-ph/0203143v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/quant-ph/0203143v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/quant-ph/0203143v1", "arxiv_comment": null, "journal_reference": "J. Opt. Soc. Am. B 19, 3019 (2002)", "doi": "10.1364/JOSAB.19.003019", "fulltext": "Programmable Logic Devices in Experimental Quantum Optics\nJ. Stockton,\u2217 M. Armen, and H. Mabuchi\nNorman Bridge Laboratory of Physics 12-33, California Institute of Technology, Pasadena, California 91125 USA\n(Dated: October 25, 2018)\n\narXiv:quant-ph/0203143v1 28 Mar 2002\n\nWe discuss the unique capabilities of programmable logic devices (PLD's) for experimental quantum optics and describe basic procedures of design and implementation. Examples of advanced\napplications include optical metrology and feedback control of quantum dynamical systems. As a\ntutorial illustration of the PLD implementation process, a field programmable gate array (FPGA)\ncontroller is used to stabilize the output of a Fabry-Perot cavity.\n\nI.\n\nINTRODUCTION\n\nAutomatic controllers are pervasive in experimental\nphysics. Servos typically play a role behind the scenes,\nstabilizing environmental conditions (e.g. temperature,\nfrequency and amplitude of driving lasers) for the physical system of primary interest (e.g. quantum dots,\ntrapped atoms or molecules). But the system of interest\ncan itself be the explicit object of sophisticated control\nstrategies. An increasing number of experimental quantum systems are developing to the point where coherent\ndynamics occur at a time scale longer than that of available detectors and actuators [1, 2, 3]. This separation of\ntime scales opens the door for real-time feedback control\nto be applied in quantum-mechanical scenarios.\nNew theoretical and experimental tools will be required to achieve quantum control objectives. Concerted\nefforts are currently being made to extend classical control theory to quantum problems where back-action cannot be ignored [5, 6]. Given the inherent nonlinearity\nof conditional quantum dynamics, optimal control laws\ncannot be practically implemented with analog circuits,\nnecessitating fast digital control. Even for linear systems,\nprogrammable logic may be superior to analog methods\nwhen a precisely shaped transfer function is desired. For\nthese reasons, one expects that programmable logic devices (PLD) with high processing speed and low latency\nwill prove to be invaluable as quantum and classical controllers.\nPLD's are already a standard tool in industry and some\nareas of science, but they have yet to attain widespread\nuse in fields such as quantum optics and quantum information science. Our aim in this paper will be to convey\na base level of knowledge required to use these devices in\nrepresentative experimental setups. First, we motivate\nthe use of programmable logic with some potential applications. We then describe the details of practical implementation, from determining the required hardware\nspecifications to completing the design flow. Finally, we\ndemonstrate this process with a familiar example of classical optical control by using a Field Programmable Gate\nArray (FPGA) to lock a Fabry-Perot cavity.\n\n\u2217 Electronic\n\naddress: jks@caltech.edu\n\nII.\n\nAPPLICATIONS\n\nAn outstanding feature of PLD's is that they can implement complex non-linear logic with relatively low latency. Here 'latency' refers to the delay between the\ntime that a signal is received as input and the time that\na calculation based on it becomes available as output.\nThis reaction time is of little consequence in many dataprocessing applications, but is critical in control loops.\nThe control bandwidth of any servo is limited by the inverse of this delay.\nIn addition, most PLD's can be completely reprogrammed in a matter of minutes, allowing for a high\ndegree of design flexibility in experimental situations.\nGiven a PLD with these capabilities, it is not difficult\nto imagine a variety of control applications related to\nquantum optics. Here we summarize a few potential examples, some of which are currently being developed.\n\nA.\n\nPrecise linear servos\n\nIn linear control tasks, PLD controllers have a distinct\npractical advantage over analog circuitry with regard to\nprecision and flexibility. For example, it is a well known\ncontrol problem to stabilize a plant over one of its resonances. An appropriate controller should precisely compensate the measured center frequency and quality factor\nof the resonance. When creating an analog servo the designer must work with discrete components (resistors, capacitors, etc.) whose impedances have a non-negligible\nerror range. However a PLD transfer function can be\nspecified digitally, making it much easier to closely match\nthe system dynamics.\nFigure 1 shows the near-compensation of a harmonic\noscillator (HO) resonance with a PLD 'anti-harmonicoscillator' (AHO) transfer function. (Actually, both\ntransfer functions in the graph are implemented with\na PLD by techniques described later.) Ideally, the HO\ntransfer function will be transformed into an integrator\ntransfer function (with a constant -90 degrees of phase)\nwhen multiplied by the AHO compensator. The deviation from a perfect integrator is due to a slight error in\nthe assumed damping. Refinements to the AHO design\ncould remove this non-ideality.\nPLD's will obviously not replace every linear servo in\n\n\f2\nMagnitude (dB)\n\n30\n20\n\nHO*AHO\n\n10\n\nHO\n\n0\n10\n\nAHO\n\n20\n30\n\n2\n\n3\n\n10\n\n4\n\n10\n\n10\n\n100\n\nPhase (deg)\n\n50\n\nAHO\n\nHO\n\n0\n\nHO*AHO\n\n50\n\nDespite this simplistic description, the general optimal\nalgorithm (f : I \u21d2 \u03a6) is a highly non-linear function\nbased on state estimation. It has been shown that the\nestimated state at any time is a function of only two parameters and the initial conditions. In terms of a scaled\ntime v, the parameters are\nZ v\nAv =\nI(u)ei\u03a6(u) du\n(1)\n0\nZ v\ne2i\u03a6(u) du\n(2)\nBv = \u2212\n0\n\n100\n150\n200\n2\n10\n\n3\n\n10\n\n4\n\n10\n\nFrequency (Hz)\n\nFIG. 1: The blue plot is a harmonic oscillator (HO) transfer function and the red plot is the anti-harmonic-oscillator\n(AHO) transfer function. The product of the two should resemble an integrator transfer function (green) with a constant\n-90 degree phase.\n\nthe typical laboratory, but the ability to optimize the\nstability of critical laser systems (for example) is a considerable resource. We detail the use of a PLD controller\nto optimally perform a linear control task in a later section.\n\nB.\n\nOptimal measurement\n\nIn quantum feedback scenarios, either the measurement operators or the system Hamiltonian can be modulated in real time according to the information gained\nfrom a continuous measurement record.\nConsider the case where only the measurement operators are adjusted. The goal of the entire measurement\nmay be to most accurately determine the initial state of\nthe system. Other situations may call for the measurement of only a single state parameter, where all other\nstate variables are either assumed or neglected. The\nauthors are currently developing a system of this type\nwhere the goal is to optimally measure the phase of a\nsingle pulse of light. We constrain ourselves to measuring pulses that are long enough to have their phase be\nwell defined and also long enough to allow us to feedback\nthe measurement signal multiple times before the pulse\nhas been completely destroyed by the detectors.\nWiseman et al. have determined close-to-optimal measurement schemes for this system based on quantum trajectory theory [6]. In short, they consider the signal to\nbe measured in an adaptive homodyne set-up where the\npulse is mixed with a strong local oscillator whose phase,\n\u03a6, is continuously adjusted (within the duration of each\npulse) according to the measured homodyne current, I.\nTo first order, the job of the algorithm is to lock to the\nside of the interference fringe, thus \u03a6 is adjusted until I\nis zero.\n\nThe phase of the local oscillator is usually taken to be\n\u03a6(v) = \u03c6\u0302(v) + \u03c02 where \u03c6\u0302(v) is the phase estimate to\nbe used during the course of feedback. If one were to\nstop the feedback at any time, the best phase estimate\nwould be \u03c6\u0302C (v) = arg(Cv ) where Cv = Av v + Bv A\u2217v .\nHowever, for subtle reasons, \u03c6\u0302C (v) should not be used as\nthe estimate during the course of the feedback.\nOne simple algorithm uses \u03c6\u0302(v) = arg(Av ). With this\nchoice, the algorithm simply reduces to a gain-scheduled\nintegrator of the form\nI(v)\nd\u03a6(v) = \u221a\nv\n\n(3)\n\nwhere\n\u221a v is the time since the beginning of the pulse and\nthe v factor represents the effective gain. Currently,\nthis algorithm\n\u221a is being implemented with an FPGA that\ncreates the v gain factor with a look-up table representation of the function as described in a later section.\nMore sophisticated algorithms (with optimal performance for certain squeezed states) have been proposed\nthat use feedback of the form\n\u03c6\u0302(v) = arg(Cv1\u2212\u01eb(v) Av\u01eb(v) )\n\n(4)\n\nwhere \u01eb(v) is also a function of Av and Bv . In this case,\nthe algorithm is sufficiently complex that any analog implementation would be extremely difficult to design.\nIn any case, the non-linear, low latency behavior of\nPLD's suggest that they are a suitable tool for this task.\nGiven that the form of a desired algorithm may change\nfrequently with the introduction of realistic experimental\ncomplications, the rapid prototyping allowed by a PLD\nis also extremely convenient.\n\nC.\n\nFeedback control\n\nWhen the goal is control rather than optimal measurement, a non-trivial Hamiltonian of the system will be controlled by the measurement record. Consider the case of\nan atom drifting through the light field of a small FabryPerot cavity. As has been demonstrated, the position of\nthe atom may be imprinted onto the output light of the\ncavity [3]. This information can potentially be mapped\nback onto the intensity and phase of the input laser with\n\n\f3\nthe goal of trapping the atom in the cavity for extended\nperiods of time [4].\nOptimal control of the atom's position will require\na complex predictor-corrector structure in the feedback\nloop at \u03bcsec time scales. If the associated calculations\ncan be sufficiently reduced, a PLD with effective clocking speeds above a MHz will be able perform this task. Of\ncourse, the effectiveness of the control algorithm will depend on the assumed dynamics of the system from which\nit is derived. If the system needs to be described quantum\nmechanically, we should institute a conditional quantum\nstate estimator. If a classical description is sufficient, we\ncan use a less complicated algorithm. The performance\nof different controllers will be a strong indicator of the\nvalidity of our descriptions. The ability to quickly redesign the PLD will be particularly advantageous when\nexploring this boundary.\nHamiltonian feedback can also be used to manipulate\nthe internal states of atomic and molecular systems. Numerous groups have become interested in shaping femtosecond laser pulses to drive transitions which may be\ninaccessible using traditional means [8]. This includes\nthe ability to synthesize rare molecular compounds. For\nexample, by iteratively reading the fluorescence spectrum\nof the system and intelligently moving in the parameter\nspace of the pulse shape, one attempts to land at a shape\nconducive to creating the desired state or compound.\nThis procedure can happen in two regimes, 'learning\ncontrol' or 'feedback control'. For learning control we\nconsider using a new sample for every pulse, whereas for\nfeedback control we consider using the same sample on\nevery pulse. In the latter case, the algorithm assumes\nthat the sample has a long enough dephasing time (memory) that a significant degree of coherence is retained between pulses. For either case, especially the second, a\nPLD based controller may have significant advantages\nover alternative controller architectures.\n\nD.\n\nDecision and control for quantum information\nprocessing\n\nIn a generic quantum computing architecture, there\nexist classical logic steps which involve performing a coherent quantum operation conditioned on the result of\na measurement. For example, quantum error correcting codes can combat decoherence by mapping measured\nerrors to appropriate correction operators [7]. In an experiment, this measurement-operation procedure should\nbe performed much faster than the dephasing rate of the\nsystem. If the operations can be performed quickly upon\ncommand, PLD's will be able to orchestrate these codes\nin a reliable and reconfigurable fashion with minimal delay.\nEven for non-conditional algorithms, PLD's can\nstreamline the implementation of complex instruction\nsets. In particular, groups working on ion trap computing have developed means of performing entangle-\n\nment algorithms [1], but with an extensive overhead of\nmacroscopic equipment that requires detailed manual adjustment whenever the algorithm is changed. Without\npushing its computational limits, a PLD can be made\nto streamline such logic networks. By using software defined algorithms, the users eliminate the time and risk\nof error associated with manual realignment of network\ncomponents. Commercial magnetic resonance systems\nuse PLD's for similar reasons.\nAs quantum computing architectures grow to the point\nwhere conditional and non-conditional algorithms must\nbe integrated in a way that is fast and flexible, programmable logic will be able to handle the task in a\nconvenient manner.\nThe success of any PLD controller will depend on its\ndynamic range and effective bandwidth. Next we discuss in more practical terms what levels of system performance can be reasonably expected from currently available PLD's.\n\nIII.\n\nDESIGN\n\nA.\n\nHardware\n\nOnce it is determined that a control algorithm needs to\nbe implemented digitally, a designer is confronted with\na wide array of possible controllers and corresponding\nacronyms. In addition to PLD's, the options include conventional microprocessor systems, DSP's (digital signal\nprocessors), and ASIC's (application specific integrated\ncircuits). Of course, the choice of controller is highly\ndependent on the algorithm being implemented because\neach device has its own trade-offs. Microprocessor systems are general enough to allow for a simple means of\nprogramming complex algorithms. However, these systems rely on a single bus architecture which forms a\nsignificant bottleneck in signal processing applications.\nOverall throughput may be high, but a large delay limits typical controllers to slow applications with kHz scale\nbandwidths. In addition, unreliable operating systems\nmay present undesirable interrupt signals during critical\nstages of processing. DSPs are specialized microprocessor systems with a multiple bus design that are optimized\nfor signal processing applications. Due to their parallel\narchitecture, DSP's can attain low-latency performance,\nbut require a significant degree of high-level design expertise. ASIC's are like PLD's in that the user designs them\nfrom the gate level, but ASIC's are irreversibly hardwired with a single application. While PLD's generally\nhave fewer resources available than ASIC's, they offer an\nefficient parallel computation structure along with reprogrammability and a relatively simple design process [9].\nThe market for PLD's is currently dominated by two\ncompanies: Xilinx and Altera. Devices from both companies have had extensive product development in industry,\nthus a substantial support network is available to designers. In choosing between PLD companies, several fac-\n\n\f4\n\nMagnitude (dB)\n\n10\n0\n\u221210\n\u221220\n\u221230\n\u221240\n\u221250\n\u221260\n\u221270\n5\n10\n\n6\n\n10\n\n7\n\n10\n\n8\n\n10\n\n200\n\nDelay (ns)\n\ntors beyond the chip performance need to be considered,\nincluding the quality of the associated software environments. To obtain the maximum control bandwidth, we\nchose to work with a Field Programmable Gate Array\n(FPGA) from Xilinx.\nThe logic structure of a Xilinx FPGA is designed to\nhandle arbitrary algorithm architectures. The FPGA\nmostly consists of a grid with thousands of Configurable\nLogic Blocks (CLB) connected by programmable interconnections. Each CLB contains a few small look-up\ntables which can serve as a simple logic elements (AND,\nOR, etc) when programmed. Also interspersed in this\ngrid are larger blocks of RAM that can be programmed\nas user defined functions with a large domain and range.\nSince each logic element needs to be triggered to operate,\nthe distribution of a uniform clock signal with constant\nfrequency and phase is a considerable design issue. Thus\nFPGA architectures commonly have digital clock managers (DCM) or delay locked loops (DLL) that de-skew\nthe clock signal across the device.\nThe performance of FPGA architectures has been impressively increasing in recent years. To give a current\nindication of their level of performance, we quote some\nof the characteristics of one of the top of the line devices available on the market today. The Xilinx Virtex\nII can contain up to 10 million system gates and have\nan internal clock frequency (fC ) up to 420 MHz. The\ninput-output speed can be above 840 Mb/s which roughly\nmatches the maximum speed of the best analog to digital converters (100 MSPS for a 12 bit sample Analog\nAD9432). This same FPGA has up to 192 SelectRAM\nblocks of 18 kbit each. Because a strong demand from\nindustry drives the development of FPGA technology,\nthese performance specifications will likely improve significantly in the short term future.\nOf course these devices must be coupled to a board, introducing other practical issues. The system used in the\ncavity lock described below is a GVA-290 board (G.V. &\nAssociates) with two Xilinx Virtex-E XCV1000E FPGA\nchips. Signals enter and exit the board through four input and four output SMA connectors. The signals are\ndigitized by an ADC (Analog AD9432) at the input and\nconverted back to analog by a DAC (Analog AD9762)\nat the output. Each ADC is located on a detachable\ndaughter board, allowing for converter upgrades and the\naddition of customized components and filters. Both the\nADCs and DACs have 12 bit resolution and are driven at\nthe clock speed of 100 MHz. A crystal oscillator provides\nthe clock signal to the FPGA, which distributes a synchronized signal internally with DLLs and also outputs\nthe driving signal for the ADC and DAC at a controlled\nphase. Unlike standard models, the board was ordered\nwith DC coupled inputs, allowing us to have broadband\ncontrol to DC. Boards often come with anti-aliasing analog filters, but were not included here due to the substantial group delay a high-order filter can impose on the\nsignal. The cost of this particular board including devices is approximately $10,000, but it should be stressed\n\n150\n\n100\n\n50\n\n0\n5\n10\n\n6\n\n10\n\n7\n\n10\n\n8\n\n10\n\nFrequency (Hz)\n\nFIG. 2: The amplitude response and delay of the entire GV290 board (ADC \u2192 FPGA \u2192 DAC). Notice that the delay\nbelow the Nyquist frequency (fC /2 = 50 MHz) is \u223c 160 ns.\nThe phase response in the constant delay region is linear with\nslope proportional to the delay.\n\nthat functional systems could be assembled at far less\ncost.\nXilinx also offers a special academic program through\nwhich university researchers can obtain the necessary\nsoftware environment and a limited range of hardware\nproducts.\nWe can now discuss the latency and throughput of our\ncontroller in more detail. The latency is defined as the\namount of time for an algorithm to process a single sample all the way through. The throughput is defined as\nthe number of samples (or bits) per second being output\nfrom the device. For example, consider a system of N\ncomponents in series, each with the same sampling rate\nf = \u03c41 . Also assume the system is 'pipelined' meaning\nthat a new sample is loaded every \u03c4 seconds and samples are registered (values held) in-between components.\nIn this case, the latency is N \u03c4 , while the throughput is\nf . If this were a controller, the bandwidth of control\nwould be limited to the inverse of the latency N1\u03c4 , not\nthe throughput.\nOne of the principle advantages of FPGA technology\nis that the delay can be quite small. Consider the case\nwhere the FPGA of the GVA-290 board is programmed\nto pass a signal through without any manipulation. Figure 2 shows the transfer function and delay of this configuration. The ADC, FPGA, and DAC are all clocked at\n100 MHz and each one takes a certain number of cycles\n(10 ns/cycle) to perform its function. The ADC imposes\na delay of 10 cycles, the buffers of the FPGA impose a\ndelay of 4 cycles, and the DAC only delays the signal\nabout 1 cycle. Adding all this to a small delay from\nother components, we find that below the Nyquist frequency (fC /2 = 50 MHz) the signal passes through at\nunity gain with a constant overall delay of \u223c 160 ns.\nThus the maximum control bandwidth for this device is\n\n\f5\n\u223c 6 MHz, and bandwidths in the tens of MHz may be\nanticipated with newer versions. If the FPGA algorithm\nis simple enough that the ADC dominates the delay, it\nmay be desirable to use Flash ADCs that have less latency at the expense of a larger power consumption and\nsmaller number of output bits.\nIf the FPGA performs a complex calculation that requires multiple logical steps in series, the delay is increased by an integer number of cycles and the effective\nbandwidth suffers. A typical example is that of the FIR\nfilter mentioned below where, for BU input bits, the sampling rate becomes fC /BU . For any general algorithm,\ncare should be taken to minimize the number of serial\nelements before implementation. If possible, calculations\nshould be performed in parallel and look-up tables should\nbe used to evaluate complicated functions.\n\nB.\n\nSoftware\n\nThe design process for a particular algorithm has been\nlargely automated with implementation software environments like Foundation ISE (Xilinx). Once the design\nis entered via one of the options described below, the\nprogram steps through a series of compilation tasks before downloading onto the device. In order, the design is\nanalyzed for syntactic errors, synthesized into a generic\ncircuit, and implemented into an optimal bit stream appropriate to the particular device and board. The bit\nstream is then downloaded onto the device to achieve a\nstand-alone realization of the desired algorithm. Simulation programs are available at intermediate stages for\ndebugging purposes. The latest version of Foundation\nISE (4.1) compiles up to 100,000 gates/min. For reasonable designs, an entire design flow can be expected to\ntake about 10 minutes. This allows for a rapid prototyping cycle which is one of the most desirable features of\nthis technology.\nNumerous algorithm entry options are available. Using a library of primitive components, one can create a\nschematic of the desired circuit. Abstract finite state machine diagrams can also be interpreted. The third option\nis a text based design written in either Verilog or VHDL\n(VHSIC Hardware Design Language).\nAs is common in technology standards, the choice of\nVerilog vs. VHDL has become a religious one for everyday practitioners. It is worth pointing out some of the\naccepted differences between the languages. Verilog is\ngenerally regarded as being easier to learn. A strong majority of engineers implementing commercial systems use\nVerilog. Historically, VHDL was meant as a description\nlanguage before being adopted as a means of synthesis.\nAs a result, VHDL is a much more strongly 'typed' language. The range of abstraction is also different between\nthe two languages. Although there is a considerable overlap, Verilog extends to a lower level of abstraction while\nVHDL extends to a slightly higher level. For non-critical\nreasons, we chose to design in VHDL, hence we will dis-\n\ncuss the following designs in those terms. However, the\ndiscussion is abstract enough that most concepts apply\nto both languages.\nTo first order, VHDL is a text based description of a\nschematic design. The mapping between input and output bus variables consists of a series of abstractly defined\ncomponents where output ports are connected to input\nports with defined signal variables. Each component has\nan associated 'entity' and 'architecture', where an architecture is an instantiation of an entity. For example, a\ncomponent with entity 'op-amp' (with only input and\noutput ports defined) could have its functionality determined by the particular architecture 'op27'. The internal\nworkings of a particular architecture are can be specified\nin another VHDL file with more components that are defined elsewhere. In this way, the code lends itself nicely\nto nested level of detail and organized project design.\nAlso one can easily swap out components by changing\narchitectures, but not entities, within the code.\nAt some point in the hierarchy, primitive components\nmust be called upon. The Xilinx software offers an extensive library of such components (AND, OR, etc.) for\nuse with each particular device. In addition to these basic primitives, one can also create more complicated, but\ncommonly used, components with the Xilinx 'Core Generator'. These objects (adders, multipliers, filters, DSP\nelements) can be customized with user specified parameters.\nEach component loads inputs and returns outputs triggered by an input clock signal. Hence, when designing\nin VHDL one thinks in terms of circuit diagrams where,\non every clock cycle, events happen concurrently across\nthe device. On the other hand, in traditional C-like computer languages events progress in a serial manner. At\ntimes, serial logic is convenient and in fact VHDL offers a restricted form of serial logic in a form known as a\n'process'. These processes are bits of C-like code that execute when triggered. Inside a process, variables can be\nmanipulated with functions defined in other VHDL files.\nHowever, a signal can only be changed once within a process. For this and other reasons, processes are best used\nas referees to generate secondary triggering signals and\nlogic. While processes can perform some level of math,\nthe heavy lifting is best left to the components which\nhave been streamlined for such purposes.\nAn appropriate use of a process is to initialize parameters and control timing. For example, Figure 3 demonstrates how the simple adaptive phase algorithm mentioned above is implemented. Both the VHDL and an\nequivalent schematic are shown. The photocurrent, I,\nenters the device and is multiplied by the time dependent\ngain factor, G(t) = \u221a1t , which is created by sending the\ntime signal, t, through a look-up table (described below).\n\u221a , is then sent to one port\nThe resulting signal, d\u03a6(t) = I(t)\nt\nof an adder, with the other input port being wired to the\noutput signal \u03a6(t). Because the output is connected to\nthe input with a delay, the adder serves as an integrator\nand executes the relation \u03a6(t) = \u03a6(t\u22121)+d\u03a6(t) at every\n\n\f6\n6\n\n+\n\nG(t)\nLUT\n\n5\n\nd\u03c6(t)\n\nX\n\n\u03c6(t)\n\nProcess\nTime\n\nReset\n\nVHDL Equivalent (the symbol -- precedes comments)\n--first component is the look-up table\n--component format is 'instance: type'\n--port map plugs signals into component ports; _# is label for bit size of bus\n\n4\n\n\u03a6 (rad); I (arb.)\n\nI(t)\n\n\u03a6\n\n3\n\n2\n\n1\n\n0\n\nI\n\n\u22121\n\nlut_num1 : ramblock_core\nport map (EN=>vcc_sig, WE=>gnd_sig, RST=>gnd_sig, CLK=>clksys,\nADDR=>time_8,DO=>Gtime_16,DI=>Gtime_16);\n\n\u22122\n\n0\n\n20\n\n40\n\n--trim signal back down to size\ndphi_12 <= dphi_28(27 downto 16);\nadder_num1 : adder_core\nport map (A => dphi_12, B => phi_21_a, Q => phi_21_b, CLK => clksys);\n--plug signals together\nphi_21_c <= phi_21_b;\n--start process on clock change\nPROCESS(clksys)\nVARIABLE time : integer;\nBEGIN\n--trigger on rising edge of clock\nIF clksys='1' AND clksys'EVENT THEN\nIF time < tau_experiment THEN\nphi_21_a <= phi_21_c;\nphi_12 <= phi_21_c(20 downto 9);\nELSE\n--zero signals during dead time\nphi_21_a <= \"000000000000000000000\";\nphi_12 <= \"000000000000\";\nEND IF;\nIF time = tau_experiment+tau_dead THEN\ntime := 0;\nEND IF;\ntime := time+1;\n--convert variable to signal\ntime_8 <= int_to_bus(time);\nEND IF;\nEND PROCESS;\n\nFIG. 3: FPGA schematic and corresponding code for the\nadaptive phase measurement algorithm. In the schematic the\nprocess is not represented as a block component because it is\ncoded in a serial manner.\n\n80\n\n100\n\nFIG. 4: The \u03a6(t) and I(t) trajectories for the phase measurement of a single pulse of light. The current is locked to zero\nand the ending point of the phase is a rough estimate of the\nmeasured phase. The true phase measurement is a functional\nof both traces. The small oscillations are due to the delay in\nthe loop.\n\nthe loop, our effective feedback bandwidth is limited to\n\u223c 1 MHz.\nAs will be demonstrated below, Matlab plays a complementary role in the design process. It can be used to\ncreate the necessary coefficients and memory blocks used\nas parameters in the VHDL components. In particular,\nthe Control and DSP toolboxes provide relevant functionality. Also, Simulink is a good tool for simulating\nthe associated experiments, where delays and other realistic factors can complicate the dynamics. There exist\nsoftware packages that attempt to directly translate from\na Simulink design of an algorithm into equivalent VHDL,\nbut these packages remain in early stages of development.\nDue to their extensive utility, RAM look-up tables and\nfilter components are worth discussing in greater detail.\n1.\n\ntime step. The 'process' plays an important role in this\nalgorithm by initializing the integral value and creating\nthe time signal. At the beginning of the pulse (integration), the process initializes t and \u03a6 to zero. Every subsequent clock signal, the process increments t by one and\nlets the adder integrate up the signal. At the end of the\npulse, the process waits for the next pulse then repeats\nthe sequence. Figure 4 shows the algorithm in action.\nThrough the integrator structure, \u03a6 is adjusted until I\nis locked to zero. The overshoot is a result of the FPGA\ndelay.\nA single measurement using this algorithm is shown in\nFigure 4. Here the 'pulse' is a 50 \u03bcsec long time slice of a\nweak cw coherent beam. The feedback algorithm is sampling at 100 MHz with a delay less than 1 \u03bc sec. Because\nof the delay and other bandwidth limiting components in\n\n60\n\nTime (\u03bcsec)\n\nmultiplier_num1 : multiplier_core\nport map (A => I_12, B => Gtime_16, CLK => clksys, P => dphi_28);\n\nLook-Up Tables\n\nMost FPGA chips come equipped with large blocks of\ninternal RAM that can be used as generalized functions\nor look-up tables (LUT). Given an amount of memory on\na particular block, the user can decide on a certain number of input and output bits. During operation the RAM\nblock returns the value held at the address specified by\nthe input, effectively implementing the desired function.\nFor example, on the XCV1000E, 160 blocks of 4096 =\n212 bits are available for internal use. (As noted above,\nthe Virtex II devices have much larger 18 kbit blocks.)\nTo make one block behave as the function f with Bi\ninput bits, the designer would choose the output to be\nBo = 212\u2212Bi bits. Possible partitions are (Bi , Bo ) \u2208\n[(1, 2048), (2, 1024), (3, 512)..., (8, 16), ...(12, 1)]. Once a\npartition is chosen, the designer would use Matlab to\ndefine a block of data consisting of 2Bi values each of\n\n\f7\nsize Bo bits, and use this block of data as a parameter\nin the VHDL LUT component. If the discretization is a\nproblem, more RAM blocks can be used to represent the\nfunction. If desired, the memory of a RAM block can\nalso be dynamically written during operation. With this\nability, an algorithm could easily adapt itself according\nto the signals it receives. Both the read and write operations (from/to one RAM address) only take a single\nclock cycle.\nAs mentioned above, these LUT functions play an extremely important role in speeding the functionality of\nnon-linear algorithms. The application may be as simple\nas non-linear gain-scheduling of a controller or as complicated as full quantum-mechanical state estimation with\nthe LUT performing functions based on assumed system\nparameters. In general, it is a matter of judgment how to\npartition complex algorithms, but any optimal partition\nwill likely involve the use of these LUTs to perform the\ndifficult parts of the calculation with minimal time delay.\n\n2.\n\nFilters\n\nPLD's have a clear edge over analog circuitry in nonlinear processing, but they also have a potential advantage in implementing precise, generic linear filters and\ntransfer functions.\nA standard core element offered by Xilinx is the FIR\n(Finite Impulse Response) filter. The FIR is defined in\ndiscrete time as\ny(n) =\n\nN\nX\ni=0\n\na(i)u(n \u2212 i)\n\n(5)\n\nwhere y(n) and u(n) are the output and input at the\ndiscrete time n respectively. With standard Matlab\nfunctions (firls, remez) one can specify an arbitrary\namplitude response and get out the corresponding a(i)\nvector. The sampling frequency for a FIR element is\nfF = BfCU = \u03c41F where BU is the number of bits chosen to\nrepresent u(n). Of course, the filter is useless at shaping\nthe response above this frequency. The group delay of\nthe signal through the filter is approximately \u03c4F N2 .\nThe range of attenuation is also a concern in the design of any filter. For an FPGA with BF bits entering\nand leaving, the dynamic range is 20 log(2BF )dB. For our\nboard with 12 bit ADC/DAC inputs and outputs, this\ncorresponds to 70 dB. The designer should also have a\nsense of the size of the input and output signals. If the\ninput signal is too high, the FPGA will rail; if the input is\ntoo low, it will fail to rise above the smallest bit size. To\navoid these types of problems, broadband gain elements\ncan be used at the input and output of the FPGA board.\nA drawback of the FIR design is that it cannot be used\nto control the phase response of its transfer function. On\nthe other hand, a generic continous time linear transfer\n\nu_12\n\nFIR a\n\n'au'\nT\n\n+\nFIR b\n\ny_12\n\ny\nT\n\nT\n'-by'\n\nFIG. 5: Implementation of IIR filter. 'T' components trim a\ncertain number of least significant bits from the data bus.\n\nfunction\nGC (s) =\n\nc(N )sN + c(N \u2212 1)sN \u22121 + ... + c(1)\nd(N )sN + d(N \u2212 1)sN \u22121 + ... + d(1)\n\n(6)\n\nwhere YC = GC UC , has phase control built in through\nthe denominator. To approximate this function on a\nPLD, an Infinite Impulse Response (IIR) filter needs to\nbe used.\nOne possible IIR design process illustrates this need.\nTo generate a digital IIR design, first create GC (s) using\nstandard control techniques (Nyquist, LQR, etc.). Next,\nconvert from a continuous to a discrete transfer function\nGC \u21d2 GD (z) =\n\na(0) + a(1)z \u22121 + ... + a(N )z \u2212N\nb(0) + b(1)z \u22121 + ... + b(N )z \u2212N\n\n(7)\n\nwith the Matlab function c2d. We have used the definition YD = GD UD in the discrete time representation.\nApply a z-transform (z \u22121 \u21d2 unit delay) to create the\ndiscrete time difference equation\ny(n) =\n\nN\nX\ni=0\n\na(i)u(n \u2212 i) \u2212\n\nN\nX\ni=1\n\nb(i)y(n \u2212 i)\n\n(8)\n\nwith the definition b(0) = 1. Finally, implement the difference equation in hardware as in Figure 5 with 2 FIR\nblocks and 1 adder.\nWith b(n > 0) = 0 the filter is just a FIR filter, however with b(n > 0) 6= 0 the output is fed back to itself.\nHence an impulse response will have an infinite effect on\nthe output. Of course, with internal feedback loops, the\nsystem is potentially unstable to noise and rounding errors. For this reason, among others, the Xilinx 'Core\nGenerator' does not create flexible IIR modules.\nHowever, with careful consideration of the number of\nbits required at each stage, a stable IIR filter can be\ncreated as in Figure 5. The sampling frequency for this\nfC\nsimple architecture is 2B\nwhere BY is the number of\nY\nbits used to keep track of y(n) internally. The factor\nof 2 results from the delay of both the adder and the\nFIR element. Because of the feedback, the IIR filter can\nachieve a given amplitude response with lower number\nof coefficients than the FIR filter. This means the filter\ndelays the signal less. Even though the IIR has fewer\n\n\f8\nVCO-AOM\n\nEOM\n\nPZT\n\nCavity\n\nFPGA\nT_upper\nT_lower\n\nFIG. 6: Feedback architecture for a Fabry-Perot Cavity. The\nEOM puts sidebands on the beam necessary to generate the\nlocking signal. The FPGA algorithm T upper maps the error\nsignal to the fast VCO-AOM frequency shifting combination.\nThe FPGA algorithm T lower maps the signal to the slow\nPZT.\n\ncoefficients than an analagous FIR filter, the coefficients\nof the IIR filter have to be specified to a greater degree\nof precision to achieve the same amplitude response.\n\nIV.\n\nSPECIFIC EXAMPLE: CAVITY LOCK\n\nWe now discuss the use of an FPGA to perform a classical task necessary for low-noise experiments. High precision optical measurements demand laser intensity noise\nbe minimized as much as possible. In the adaptive phase\nexperiment mentioned above, the input laser is a Lightwave Nd:YAG model 126 (1064 nm) with an inherent\nbroad relaxation oscillation noise peak at \u223c 100 kHz. To\nperform broadband detection and control near 1 MHz,\nthis intensity noise must be removed from the beam with\na Fabry-Perot cavity.\nA block diagram of the system is shown in Figure 6.\nThe output intensity of the cavity is stabilized with the\nstandard Pound-Drever-Hall method so that the error\nsignal is created from a reflected carrier beam with sidebands. At low frequencies (below 100 Hz) the feedback\nloop is dominated by a piezoelectric element (PZT) which\ncontrols the length of the cavity. At higher frequencies\nand through the closing point of the servo, the feedback\nis from an AOM (Acousto-Optic Modulator) driven by a\nVCO (Voltage Controlled Oscillator) which adjusts the\nfrequency of the input beam.\nGiven the control architecture of Figure 6, the design\nprocess can be made very systematic with the flexibility\nof the FPGA. Because the critical behavior of the servo\nwill be dominated by the VCO-AOM loop, we concentrate on the design of TU (T upper). First, the transfer\nfunctions of the elements in the loop are measured. Here\nwe find that the VCO-AOM combination behaves like a\nlow-pass filter (TV ) with a corner at 100 kHz. The cavity\nitself can be modelled as a low-pass filter (TC ) with a corner at about 10 kHz (the cavity linewidth). The goal is\n\nto design TU such that the closed loop transfer function\nTCL = 1+TTCC TTVV TU is stable.\nAt this point, we can use the Matlab Control Toolbox to design an optimal TU . One option is to provide\nthe function lqr with the state space representations of\nTV and TC and an appropriate cost function to create the\noptimal TU . The result simply tells us to make the combi1\nnation TC TV TU behave like an integrator (TI = 1s = j\u03c9\n)\nsuch that the controller satisfies the Nyquist criterion\nwith 90 degrees of phase margin.\nThere are practical problems with this approach. In\nparticular, the gain of TU must be infinite for very low\nand very high frequencies. To remedy this, we flatten the\nresponse of TU below 100 Hz (where the PZT arm takes\nover) and roll off the response at 300 kHz, beyond the\nclosing point of the servo. So instead of making TU =\n2\nTLP 1 TLP\nTI\n2\nwhere TLP 1 is a low-pass\nTC TV we use TU =\nTC TV\nfilter with the corner at 100 Hz and TLP 2 is a low-pass\nfilter with the corner at 300 kHz.\nTo get high gain at frequencies below 100 Hz, we make\nTL (T lower) behave as a low-pass filter with a corner at\nonly a few Hz. A better choice would be to implement TL\nas a high-gain analog integrator, but we use the FPGA\nto implement TL here for demonstration purposes.\nNext, we generate proper IIR coefficients for both\npaths by the method described previously, treating TL\nand TU as the continuous transfer function GC . With a\nclock frequency of 100 MHz and an internal sample size\nof BY = 32 bits, the IIR structure had an effective bandfC\nwidth of 1.5 MHz ( 2B\n), which is adequate to generate\nY\nthe critical features of the transfer function.\nFigures 7 and 8 show the desired and actual transfer\nfunctions of both arms. Each arm fails to match the\ndesired phase and amplitude response in a similar way.\nFirst, because of the finite size of the sampling time, the\nactual phase response differs from the desired response\nas the frequency approaches the effective sampling frequency. In fact, this mismatch happens lower than the\nsampling frequency because of the delay of the IIR filter.\nSecond, at low frequencies, the FPGA gives less gain than\nthe desired result. This is due to the fact that we are\ndealing with finite precision coefficients. The price paid\nfor having a large sampling frequency with small delay\nis that we have less control over the size of the low frequency gain. Finally, note that the PZT arm integrator\nachieves the full 70dB of expected range (input/output\nsize is 12 bits).\nThe closed loop transfer function behavior for both\narms matches our expectations for noise rejection at low\nfrequencies. A mismatch at higher frequencies is due to\ninadequate modelling of the PZT and other components.\n(The PZT behaves more like a collection of oscillators\nwith different resonances than a low pass filter.) Qualitatively, the FPGA lock was much more robust to high\nfrequency noise than an analog version of the servo. This\nwas likely due to the precise match to the plant dynamics near the unity gain point of the servo, achieved by\nthe use of large FIR coefficients. However, the FPGA\n\n\f9\n\nMagnitude (dB)\n\n120\n\nFPGA\nDesign\n\n100\n80\n60\n40\n20\n0\n\u221220\n1\n10\n\n2\n\n10\n\n3\n\n10\n\n4\n\n10\n\n5\n\n10\n\n0\n\nPhase (deg)\n\n\u221220\n\u221240\n\u221260\n\u221280\n\u2212100\n\u2212120\n1\n10\n\n2\n\n10\n\n3\n\n10\n\n4\n\n10\n\n5\n\n10\n\nFrequency (Hz)\n\nFIG. 7: Bode plot of T lower (transfer function leading to\nPZT). The design is a low-pass filter which dominates control\nbelow \u223c 100 Hz.\n\nMagnitude (dB)\n\n70\n\nFPGA\nDesign\n\n60\n50\n40\n30\n20\n1\n10\n\n2\n\n10\n\n3\n\n10\n\n4\n\n10\n\n5\n\n10\n\nPhase (deg)\n\n50\n\n0\n\n\u221250\n\n\u2212100\n\n\u2212150\n1\n10\n\n2\n\n10\n\n3\n\n10\n\n4\n\n10\n\n5\n\n10\n\nfrequencies. This problem could easily be remedied by\nusing an analog integrator with more DC gain to replace\nthe FPGA PZT transfer function. The main advantage\nof the FPGA is its fast accurate response and, besides\nthe demonstration presented here, there is no practical\nreason to use the FPGA for high-gain, low-frequency applications.\nFinally, another feature of FPGA control is the possibility of adding logical automation to this system. Specifically, if the controller loses the lock, then the FPGA\ncould be programmed to sense this condition, sweep for\na signal, hone in, and re-acquire the lock. The abstract\nlogical nature of VHDL code makes this task simple relative to the procedure needed to create an acquisition\nsystem using standard electronics.\nV.\n\nSUMMARY\n\nTo demonstrate the use of programmable logic technology in an otherwise familiar setting, we have concentrated on a linear control application. We have used this\nexample to convey the issues associated with a digital\ncontroller, including design, latency, and discretization.\nHowever, we have only hinted at the more interesting\nadvanced applications in experimental quantum optics\nwhich are sure to develop more quickly because of this\ntechnology. FPGAs and similar devices are particularly\nsuited to any physical system where non-linear mappings\nare desired between output and input variables within the\nnatural dynamical time-scale. With these devices and\nsufficiently protected quantum systems in hand, the field\nof coherent quantum control may soon have enough speed\nto match the intelligence of its proposed controllers.\n\nFrequency (Hz)\n\nFIG. 8: Bode plot of T upper (transfer function leading to\nVCO-AOM). The peak in phase is designed to stabilize the\nplant through the unity gain point.\n\nlock was unable to retain the lock over time scales more\nthan a few hours due to the saturated gain at very low\n\n[1]\n[2]\n[3]\n[4]\n\nC.A. Sackett et al., Nature 404, 256 (2000).\nM. R. Andrews et al., Science 273, 84 (1996).\nC. J. Hood et al., Science 287, 1447 (2000).\nS. Habib, K. Jacobs, and H. Mabuchi, Feedback control of\natomic motion in an optical cavity, Unpublished.\n[5] A. C. Doherty et al., Phys. Rev. A 62, 012105 (2000);\nA. C. Doherty et al., Phys. Rev. A 63, 062306 (2001).\n[6] H. M. Wiseman and R. B. Killip, Phys. Rev. A 57, 2169\n(1998);\n\nACKNOWLEDGEMENTS\nJ.S. acknowledges the support of a Hertz Foundation\nFellowship, and H.M. acknowledges the support of an A.\nP. Sloan Research Fellowship. This work was supported\nby the NSF under grant PHY-9987541, and by the ONR\nunder Young Investigator Award N00014-00-1-0479.\n\nD. W. Berry and H. M. Wiseman, Phys. Rev. A 63, 013813\n(2000).\n[7] M. A. Nielsen and I. L. Chuang, Quantum Computation\nand Quantum Information (Cambridge University Press,\n2000).\n[8] H. Rabitz et al., Science 288, 824 (2000).\n[9] D. Stranneby, Digital Signal Processing (Newnes, 2001).\n\n\f"}