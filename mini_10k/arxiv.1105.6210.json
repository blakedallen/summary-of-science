{"id": "http://arxiv.org/abs/1105.6210v1", "guidislink": true, "updated": "2011-05-31T09:12:29Z", "updated_parsed": [2011, 5, 31, 9, 12, 29, 1, 151, 0], "published": "2011-05-31T09:12:29Z", "published_parsed": [2011, 5, 31, 9, 12, 29, 1, 151, 0], "title": "Generic Traces and Constraints, GenTra4CP revisited", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1105.0565%2C1105.4000%2C1105.3363%2C1105.1360%2C1105.5579%2C1105.5949%2C1105.4608%2C1105.2777%2C1105.4733%2C1105.4778%2C1105.0457%2C1105.0032%2C1105.4307%2C1105.4478%2C1105.1294%2C1105.2822%2C1105.6184%2C1105.4059%2C1105.3797%2C1105.1057%2C1105.1835%2C1105.5417%2C1105.3893%2C1105.5926%2C1105.5469%2C1105.4941%2C1105.1012%2C1105.0620%2C1105.6335%2C1105.5295%2C1105.4420%2C1105.4570%2C1105.0589%2C1105.4301%2C1105.5538%2C1105.3689%2C1105.1377%2C1105.6350%2C1105.5542%2C1105.4993%2C1105.4369%2C1105.0831%2C1105.3366%2C1105.2965%2C1105.3425%2C1105.6038%2C1105.0056%2C1105.5420%2C1105.3409%2C1105.3894%2C1105.5795%2C1105.0585%2C1105.1674%2C1105.1476%2C1105.2481%2C1105.5853%2C1105.3139%2C1105.0276%2C1105.5745%2C1105.3648%2C1105.4168%2C1105.3778%2C1105.2387%2C1105.1597%2C1105.0870%2C1105.1108%2C1105.2794%2C1105.1809%2C1105.0665%2C1105.3719%2C1105.0548%2C1105.2200%2C1105.3731%2C1105.4727%2C1105.6331%2C1105.4737%2C1105.0103%2C1105.0682%2C1105.2814%2C1105.3403%2C1105.1192%2C1105.3199%2C1105.5866%2C1105.5803%2C1105.0882%2C1105.3676%2C1105.2699%2C1105.5529%2C1105.0073%2C1105.6210%2C1105.3951%2C1105.6268%2C1105.6220%2C1105.5744%2C1105.6275%2C1105.6151%2C1105.6187%2C1105.5807%2C1105.0333%2C1105.5206%2C1105.0969&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Generic Traces and Constraints, GenTra4CP revisited"}, "summary": "The generic trace format GenTra4CP has been defined in 2004 with the goal of\nbecoming a standard trace format for the observation of constraint solvers over\nfinite domains. It has not been used since. This paper defines the concept of\ngeneric trace formally, based on simple transformations of traces. It then\nanalyzes, and occasionally corrects, shortcomings of the proposed initial\nformat and shows the interest that a generic tracer may bring to develop\nportable applications or to standardization efforts, in particular in the field\nof constraints.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1105.0565%2C1105.4000%2C1105.3363%2C1105.1360%2C1105.5579%2C1105.5949%2C1105.4608%2C1105.2777%2C1105.4733%2C1105.4778%2C1105.0457%2C1105.0032%2C1105.4307%2C1105.4478%2C1105.1294%2C1105.2822%2C1105.6184%2C1105.4059%2C1105.3797%2C1105.1057%2C1105.1835%2C1105.5417%2C1105.3893%2C1105.5926%2C1105.5469%2C1105.4941%2C1105.1012%2C1105.0620%2C1105.6335%2C1105.5295%2C1105.4420%2C1105.4570%2C1105.0589%2C1105.4301%2C1105.5538%2C1105.3689%2C1105.1377%2C1105.6350%2C1105.5542%2C1105.4993%2C1105.4369%2C1105.0831%2C1105.3366%2C1105.2965%2C1105.3425%2C1105.6038%2C1105.0056%2C1105.5420%2C1105.3409%2C1105.3894%2C1105.5795%2C1105.0585%2C1105.1674%2C1105.1476%2C1105.2481%2C1105.5853%2C1105.3139%2C1105.0276%2C1105.5745%2C1105.3648%2C1105.4168%2C1105.3778%2C1105.2387%2C1105.1597%2C1105.0870%2C1105.1108%2C1105.2794%2C1105.1809%2C1105.0665%2C1105.3719%2C1105.0548%2C1105.2200%2C1105.3731%2C1105.4727%2C1105.6331%2C1105.4737%2C1105.0103%2C1105.0682%2C1105.2814%2C1105.3403%2C1105.1192%2C1105.3199%2C1105.5866%2C1105.5803%2C1105.0882%2C1105.3676%2C1105.2699%2C1105.5529%2C1105.0073%2C1105.6210%2C1105.3951%2C1105.6268%2C1105.6220%2C1105.5744%2C1105.6275%2C1105.6151%2C1105.6187%2C1105.5807%2C1105.0333%2C1105.5206%2C1105.0969&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The generic trace format GenTra4CP has been defined in 2004 with the goal of\nbecoming a standard trace format for the observation of constraint solvers over\nfinite domains. It has not been used since. This paper defines the concept of\ngeneric trace formally, based on simple transformations of traces. It then\nanalyzes, and occasionally corrects, shortcomings of the proposed initial\nformat and shows the interest that a generic tracer may bring to develop\nportable applications or to standardization efforts, in particular in the field\nof constraints."}, "authors": ["Pierre Deransart"], "author_detail": {"name": "Pierre Deransart"}, "author": "Pierre Deransart", "links": [{"href": "http://arxiv.org/abs/1105.6210v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1105.6210v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1105.6210v1", "affiliation": "INRIA Rocquencourt", "arxiv_url": "http://arxiv.org/abs/1105.6210v1", "arxiv_comment": null, "journal_reference": null, "doi": null, "fulltext": "Generic Traces and Constraints,\nGenTra4CP revisited\n\narXiv:1105.6210v1 [cs.LO] 31 May 2011\n\nPierre Deransart\nInria Rocquencourt, BP 105, 78153 Le Chesnay Cedex, France\nPierre.Deransart@inria.fr\n\nAbstract. The generic trace format GenTra4CP has been defined in\n2004 with the goal of becoming a standard trace format for the observation of constraint solvers over finite domains. It has not been used\nsince. This paper defines the concept of generic trace formally, based on\nsimple transformations of traces. It then analyzes, and occasionally corrects, shortcomings of the proposed initial format and shows the interest\nthat a generic tracer may bring to develop portable applications or to\nstandardization efforts, in particular in the field of constraints.\n\nKeywords: Generic Trace, Constraints, Observational Semantics, Formal Specification, Portability, Standardization\n\n1\n\nIntroduction\n\nFollowing the RNTL OADymPPaC project [9], a generic trace format, called\nGenTra4CP (Generic Trace for CP), has been proposed in 2004 in order to specify traces of CSP(FD) resolution. One of the objective was to allow the development of portable powerful tools for solvers analysis. This format was designed\nas a kind of standard, consisting of a precise syntax of trace events including an\nXML DTD, and an operational semantics, called observational semantics, which\nis a partial operational semantics applicable to a set of finite domains solvers.\nSuch \"standard\" conforming tracers were implemented in four solvers. Several tools for analysis of resolution and search strategies were developed in four\ndifferent environments, just using the generic trace GenTra4CP. They have been\nused with success after a minimal customization work for each of them. However, at that time, no formal characterization of the generic nature of the trace\nformat has been given. Even if the implementation of the tools starting from a\nwell defined generic trace could be realized without difficulty, and even if there\nwas obtained a considerable gain in portability, it was virtually impossible to\nassess in advance the effort of adaptation needed for a solver to use the tools.\nMoreover it was not always possible to figure out exactly what some tool was actually observing. GenTra4CP format has been used only in the project in which\nit has been defined.\n\n\f2\n\nDeransart P.\n\nThis paper attempts to overcome these limits, by defining formally the concept of generic trace. It analyzes formally the nature of the generic format GenTra4CP and its limitations that could have made difficult its broader use. It also\nshows the interest that a generic tracer approach may bring for standardization\nefforts and portability of applications, in particular for constraints, in proposing\nan approach of trace based semantics grounded on a partial operational semantics.\nAfter an introductory section on operational semantics of traces, the Section 3\nintroduces some simple relations between traces in order to formalize the concept\nof generic trace, and to provide a proof method of compliance of a particular\nprocess trace with the generic one. The Section 4 explains the generic approach\nand its interest for portability. The Section 5 applies this approach to the case\nof GenTra4CP verifying the compliance of a particular solver. The formal description of the GenTra4CP trace format is borrowed from [9] and from [6] for\nthe solver. This allows a better understanding of the strengths and limitations\nof this approach as introduced in 2004. We can then establish a possible link\nbetween the efforts of constraints standardization, and the specification method\nbased on generic trace.\n\n2\n\nPreliminaries\n\nA trace object consists of an initial state s0 followed by an ordered finite or\ninfinite sequence of trace events, denoted < s0 , e >. T is a set of traces. A prefix\n(finite, of size t) of a trace T = < s0 , en > (finite or infinite, here of size n \u2265 t)\nis a partial trace Ut =< s0 , et > which corresponds to the t first events of T , with\nan initial state at the beginning. A prefix consisting of just an initial state is of\nsize 0. The set of all the prefixes of T is denoted P ref (T ), with T \u2286 P ref (T ).\nEvery trace can be decomposed into segments containing trace events only,\nexcept prefixes which start with a state. An associative operator of concatenation\nmay be used to denote sequences concatenations. The neutral element is \u01eb (empty\nsequence). A trace may describe state transitions, such that a segment may also\nbe represented as sTt st where s is the state in which the sequence Tt starts and\nst the state reached after the last trace event in the sequence. A segment (or\nprefix) of size 0 is either an empty sequence or a state.\nA domain of traces over T , DT T , is a set whose elements are sets of all\nprefixes of one or more traces of T . An element is prefix closed. Such a set is\nclosed by union and intersection, and, two included elements are such that the\nsmaller contains all the prefixes of some traces of the largest. A trace domain\nis a complete lattice denoted DTT (\u2286, \u22a5, \u22a4, \u222a, \u2229) where \u22a5 is the empty set and\n\u22a4 = P ref (T ).\nTraces are used to represent the evolution of systems by describing the evolution of their state. We will distinguish two kinds of traces:\n\u2013 the virtual traces (T v ) whose events have the form e = (r, s) where r is a\ntype of action associated with a state transition and s, called virtual state,\n\n\fConstraints and Traces\n\n3\n\nthe new state reached by the transition and described by a set of parameters.\nVirtual trace corresponds to sequences of states of an observed system.\n\u2013 the actual traces (T w ) whose events have the form e = (a) where a is an\nactual state described by a set of attributes. Actual traces corresponds to\nsequences of events produced by a tracer of an observed system. Thy usually\nencode states changes in a synthetic manner.\nWe give here a simplified but sufficient definition of observational semantics.\nMore general definitions can be found in [2].\nDefinition 1 (Observational Semantics).\nAn observational semantics consists of < S, R, A, T, E, I, S0 >, where\n\u2013\n\u2013\n\u2013\n\u2013\n\nS: domain of virtual states,\nR: finite set of action types, set of identifiers labeling the transitions.\nA: domain of actual states,\nT : state transition function T : R x S \u2192 S, denoted T (r, s) = s\u2032 or T (r, s, s\u2032 )\nif it is a relation,\n\u2013 El : local trace extraction function El : S \u00d7 R \u00d7 S \u2192 A,\n\u2013 Il : local trace reconstruction function Il : S \u00d7 A \u2192 R \u00d7 S,\n\u2013 S0 \u2286 S, set of initial states.\n\nThe extraction and reconstruction functions can be extended into functions\nE (resp. I) between sets of virtual and actual traces, and must verify the relation\nof faithfulness, I = E \u22121 . Local and extended functions satisfy the properties:\nE(s0 e1 ...ei ...) = s0 El (s0 , r1 , s1 )...El (si\u22121 , ri , si )... with El (si\u22121 , ri , si ) = ai ,\nand\nI(s0 a1 ...ai ...) = s0 Il (s0 , a1)...Il (si , ai+1 )... with Il (si\u22121 , ai ) = (ri , si ).\nThe local and transition functions may be represented by rules as illustrated\nby the Figure 1.\nThe observational semantics of an observed process can be considered as\nan abstraction of some refined operational semantics [1]. This relation will be\nexpressed here as a relation between domains of traces. Such a relation may\nbe expressed either between virtual or actual traces. Due to the faithfulness\nproperty, the abstraction function Dw on actual traces verifies with Dv , the\nabstraction function on virtual traces, the following relations: Dv = Ec \u25e6 Dw \u25e6 Id\nand Dw = Ic \u25e6 Dv \u25e6 Ed .\nIn the following it will be assumed that the faithfulness property is satisfied, whatever is the abstraction level of the trace description. In this case, the\nextraction function is deducible from the reconstruction one and reciprocally.\nTherefore it is sufficient to specify the transition function with the extraction\nonly or with the reconstruction. In practice, only actual traces are manipulated\nby the users, but thanks to the faithfulness property, for validation purposes,\nthe virtual trace may be used.\n\n\f4\n\nDeransart P.\n\uf8fc\n\uf8f1\n\uf8fd\n\uf8f2 remove \u2206cv ), a wake up c\n< D(v), Se , A >\n\u2032\n(c, a) \u2208 A, A = A \u2212 {(c, a)}\nreduce\nc\n\u2032\n\uf8fe\n< D(v) \u2212 \u2206v , Se \u222a \u0101, A > \uf8f3\nv \u2208 var(c), generate \u0101\nreduce\n\nreduce\n\n< D(v), Se , A\u2032 \u222a {(c, a)} > \u2192 < D\u2032 (v), Se\u2032 , A\u2032 >\n{}\n[reduce, c, v, (Se\u2032 \u2212 Se ), (D(v) \u2212 D\u2032 (v)), a]\n\n[reduce, c, v, \u0101, \u2206cv , a]\n{}\n< D(v), Se , A > \u2192 < D(v) \u2212 \u2206cv , Se \u222a \u0101, A \u2212 (c, a) >\n\nFig. 1. Example of description of reduce in the OS of GenTra4CP (Section 5) with\ntransition rule, extraction and reconstruction. Computations are specified on the right\nside\n\n3\n\nAbstraction relations: subtraces and derivations\n\nWe introduce simple transformations on traces: subtraces and derivations. As it\nis sufficient to describe transformations on the virtual traces, they are described\nusing one part of their description, namely < S, R, T, S0 > only.\nSubtraces are obtained by considering a subset of parameters.\nDefinition 2 (Subtrace).\nGiven a set of virtual traces T defined by < S, R, T, S0 >, if S \u2032 \u2286 S is defined\non a subset of parameters which do not depend1 on any other parameter of S\u2212S \u2032 ,\nR\u2032 \u2286 R is a subset of action types which use or modify these parameters only\nsuch that no other action type of R\u2212R\u2032 modifies them, S0\u2032 is the restriction of S0\nto S \u2032 , and T \u2032 the restriction of T to S \u2032 and R\u2032 , then the set of traces T \u2032 defined\nby < S \u2032 , R\u2032 , T \u2032 , S0\u2032 > is a (parametric) subtrace of T , denoted SubP (T , T \u2032 ).\nNote: it is possible that S \u2032 \u2286 S and R\u2032 = R (S \u2212 S \u2032 contains redundant parameters, i.e. which depend only on the other parameters and thus may be removed).\nDefinition 3. (Derivation field and derived trace)\nGiven two sets of traces Tc and Td , where Tc and Td are said respectively\nconcrete and derived, Td is a derivation field of Tc by D if there exists a mapping\nD : P ref (Tc ) \u2192 P ref (Td ), called a derivation, such that for all finite derived\nprefixes td of size n and for all concrete prefix tc such that D(tc ) = td , there exists\nan increasing chain of concrete prefixes [t0c , t1c , ..., tic , ..., tcn\u22121 , tc ] (not necessarily\ncontiguous), such that\n\u2013 D(t0c ) \u2208 S0,d ,\n\u2013 \u2200i > 0 if D(tic ) = tid with tid prefix of td made of the i first events, then\ni+1\nD(ti+1\nc ) = td .\nIf D is surjective, the set Td is called derived trace by D of Tc , noted DrvD (Tc , Td ).\n1\n\nA parameter p depends on p\u2032 iff p\u2032 is used in the computation of p in some transition.\n\n\fConstraints and Traces\n\n5\n\nAs defined, D is a partial function. It can be made total by considering that\nall elements of S0,c have an image in S0,d and that the image of each prefix\nbetween tic and ti+1\nis D(tic ).\nc\nt_d\n\nt'_d\n\ns d\n0\n\ns_d\n\ns'_d\nr_d\n\nt_c\ns0 c\n\n0\ns_c\n\ns'_c\n\ns_c\nt'_c\n\nFig. 2. Derivation (dashed arrow correspond to the totalized derivation), tx denotes a\nprefix\n\nThis approach puts emphasis on traces without considering the way they\nhave been produced or the way they are specified. The main idea is that a trace\ntransformation is the result of a computation on likely full prefixes of concrete\ntraces, represented by de derivation D.\nProperty 1.\nGiven two derivations D1 and D2 , if D1 is surjective or if D2 is total, D1 \u25e6 D2\nis a derivation.\nA parametric subtrace (definition 2) is a derived trace.\nThe following establishes a method of proof that two sets of traces specified\nby transition relations are related by a derivation.\nDefinition 4. (Simulable Trace)\nGiven two sets of traces Tc (concrete) and Td (derived), respectively defined\nwith < Sc , Rc , Tc , S0,c > and < Sd , Rd , Td , S0,d >, Tc is simulable in Td if Rc and\nRd are in a one-one mapping h, and if there exists an application d : Sc \u2192 Sd\nsuch that:\n\u2013 \u2200s0 \u2208 S0,c , d(s0 ) \u2208 S0,d .\n\u2013 \u2200rc \u2208 Rc , sc , s\u2032c \u2208 Sc , Tc (sc , rc , s\u2032c ) \u21d2 \u2203sd , s\u2032d \u2208 Sd , d(sc ) = sd \u2227 d(s\u2032c ) =\ns\u2032d \u2227 Td (sd , h(rc ), s\u2032d ).\nTheorem 1.\nGiven two sets of traces Tc (concrete) and Td (derived), such that Tc is simulable in Td , then Td is a derivation field for Tc and the corresponding derivation\nis total.\nCorollary 1.\nGiven two sets of traces T and T \u2032 such that there exists a parametric subtrace\nof T simulable in T \u2032 , then T \u2032 is a derivation field for T .\n\n\f6\n\nDeransart P.\n\n4\n\nGeneric Trace\n\nThe idea of generic trace meets the needs of specification and portability. It is\nintended to specify a process or an algorithm by its observable behavior, i.e.\nthe trace of abstracted operations that it is expected to implement. The level of\ndescription must be general enough to include family of processes, and the level\nof granularity must be sufficiently refined to be used by a family of applications.\nThis may be the case for example for applications such as monitoring, debugging,\nvisualization tools, or any application using the generic trace.\nDefinition 5 (Generic Trace (GT)).\nGiven a family of processes p \u2208 P , each of them equipped to produce traces\nTp , a set of traces Tg is generic if, for each process p in the family, there exists\na derivation Dp of its traces which is a parametric subtrace of Tg , that is:\n\u2200p \u2208 P, \u2203 T such that DrvDp (Tp , T ) \u2227 SubP (Tg , T ).\nThree questions are then worth posing:\n\u2013 How to ensure that the trace produced by some process is compliant with\nthe GT?\n\u2013 Can the GT be used in application development, with the guarantee that\nthe application will work with any compliant process?\n\u2013 Can the GT be extended to handle more processes in such a way that existing\napplications will still work?\nHere are some possible answers.\nCompliance to the Generic Trace\nA trace of a process is compliant w.r.t. the GT if it satisfies the definition 5,\ni.e. there exists a subtrace of the GT which is a derivation of a subtrace of those\nof the process. It is thus possible either to implement straightforwardly the GT\nas it is (in this case the process produces exactly the GT), or to prove that the\ntraces a process p may generate verifies \u2203T \u2032 , DrvDp (Tp , T \u2032 ) \u2227 Subp (Tg , T \u2032 ).\nBuilding tools with the Generic Trace\nThe interest of a generic trace is that it facilitates the development of tools\nthat can be used with all compliant processes. The development is made considering that the tool uses at least a sub-GT covering sufficiently many processes.\nThus it is possible to adapt the tool to the process p by applying to the trace\ngenerated by the process (without any modification) the derivation Dp to get a\nGT. This can be done at le level of the process (process can use any tool) or at\nthe level of the tool (tool can be run with this particular process). The Figure 3\nillustrates these two ways to adapt processes with compliant tracer and tools.\nThe fact that the GT has a formal specification makes it possible to realize\na prototype (executable specification) which shall be itself a new compliant process. It is thus possible to use such a prototype to develop and test tools. This\ndevelopment method guarantees that any tool made on the top of the GT will\nbe able to work with any compliant processes.\n\n\fConstraints and Traces\n\n7\n\nProcess p\n\nDp\nMI\n\nTp\n\nTg\n\nApi\n\nApi\n\nFig. 3. Use of a Generic Trace: process or application adaptation\n\nGeneric Trace extensions\nAs long as an extension of the GT preserves the fact that a process is compliant w.r.t. a subtrace of the extended GT, they still are compliant w.r.t. the\nextended GT. It is sufficient to ensure that any GT extension preserves the parametric subtraces. This guarantees that the compliant processes will continue to\nbe usable by tools using the original GT.\n\n5\n\nThe Generic Trace GenTra4CP\n\nIn the final document [9], the generic trace GenTra4CP is defined with an observations semantics whose transition function is defined with a subset of parameters. Thus only a generic subtrace has a formal semantics. The other parameters\nare described informally by the description of other attributes of the actual trace.\nTheir syntax is fixed by a DTD XML and informal explanations are provided\nfor each new attribute. We recall here the semantics as originally presented in\n[9] (section 3.3.1)2\nBeginning of Citation:\nDefinition 6. (Solver State)\nA solver state is a 8-tuple: S = (V, C, D, A, E, R, Sc , Se )\nwhere: V is the set of declared variables; C is the set of declared constraints;\nD is the function that assigns to each variable in V its domain (a set of values\nin the finite set D); A is the set of active pairs of the form (constraint, solver\nevent 3 ); E is the set of solved constraints; R is the set of unsatisfiable (or\nrejected) constraints. Sc is the set of sleeping constraints; Se is the set of solver\nevents to propagate (\"sleeping events\").\n2\n3\n\nHere one uses n instead of \u03bd to denote the current node of the choice-tree.\nThis work inherits from two areas, constraint solving and debugging, which both use\nthe word \"event\" in correlated but different meanings: a solver event is produced\nby the solver and has to be propagated (e.g. the update of the domain bounds of a\nvariable); a trace event corresponds to an execution step which is worth reporting\nabout.\n\n\f8\n\nDeransart P.\n\nnew variable\nnew constraint\npost, remove\nrestore\nchoice point\nback to\nsolution, failure\n\nControl\nv, Dv,i\nc\nc\nv, \u2206v\nn\nn, n\u2032\nn\n\nPropagation\nc, v, \u0101,\n\u2206cv , a\nsuspend, c\nsolved\nreject\nc, a\nawake\nc, a\nschedule c, a\nreduce\n\nTable 1. Attributes of the actual trace of GenTra4CP\n\nA, Sc , E and R are used to describe four specific states of a constraint during\nthe propagation stage: active, sleeping, solved or rejected.\nThe store of constraints is the set of all constraints taken into account. The\nstore is called \u03c3 in the following and defined as the partition \u03c3 = {c | \u2203(c, a) \u2208\nA} \u222a Sc \u222a E \u222a R. All the constraints in \u03c3 are defined, thus \u03c3 \u2286 C. The set\nof variables involved in the constraint c is denoted by var(c). The predicate\nf alse(c, D) (resp. solved(c, D)) holds when the constraint c is considered as\nunsatisfiable (resp. solved: it is universally true and does not influence further\nreductions any more) by the domains in D.\nThe search is often described as the construction of a search-tree.\nDefinition 7. (Search-Tree State)\nThe search-tree is formalized by a set of ordered labeled nodes N representing\na tree, and a function \u03a3 which assigns to each node a solver state. The nodes in\nN are ordered by the construction. Three kinds of nodes are defined and characterized by three predicates: failure leave (f ailed(S)), solution leave (solution(S)),\nand choice-point node (choice-point(S)). The last visited node is called current\nnode and is denoted n. The usual notion of depth is associated to the searchtree: the depth is increased by one between a node and its children. The function\n\u03b4 assigns to a node n its depth \u03b4(n).Therefore, the state of the search-tree is a\nquadruple: T = (N , \u03a3, \u03b4, n).\nIn the initial solver state, n0 denotes the root of the search-tree and all the sets\nthat are part of S are empty.\nEnd of Citation\nThe remaining description consists of the description of each event type of the\nactual trace (called in [6] \"generic trace schema\") by introducing other attributes\n(some of them are redundant like external and internal constraint identifier). One\nillustrates the methodology of GT construction by analyzing one \"implementation\" of the GT as presented in [6]. In this paper three \"specializations\" of the\nGT are detailed for three solvers (GNU-Prolog, Choco and PaLM). They consist\nof a description of the operational semantics of each solver by their transition\nfunction. We show here that the proposed OS for PaLM [5] is compliant. Among\n\n\fConstraints and Traces\n\n9\n\n\u001b\n\u001a\n< V, D >\nv 6\u2208 V,\nD(v) = Dv,i\n< V \u222a {v}, D \u222a {(v, Dv,i )} >\n\u001b\n\u001a\n<C>\nc 6\u2208 C,\nnew constraint\nvar(c) \u2286 V\n< C \u222a {c} >\n\u001b\n\u001a\n<A>\nc \u2208 C,\npost\nc 6\u2208 \u03c3\n< A \u222a {(c, \u22a5)} >\n\u001b\n\u001a\n< N , \u03a3, S >\nch-pt(S),\nchoice point\nn\u2208\n/N\n< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\u001b\n\u001a\n< S, \u03bd >\nn 6= \u03bd, n \u2208 N ,\nback to\nch-pt(S)\n< \u03a3(n), n >\n\u001b\n\u001a\n< N , \u03a3, S >\nsol(S),\nsolution\nn\u2208\n/N\n< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\u001a\n\u001b\n< N , \u03a3, S >\nf lr(S),\nfailure\nn\u2208\n/N\n< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\b\n<\u03c3>\nc\u2208\u03c3\nremove\n< \u03c3 \u2212 {c} >\n\u001b\n\u001a\n< D(v) >\nv \u2208 V,\nrestore\n\u2206v \u2229 D(v) = \u2205, \u2206v \u2286 Dv,i\n< D(v) \u222a \u2206v >\n\nnew variable\n\nFig. 4. OS of GenTra4CP (control, without the parameter \u03b4)\n\nthe three experimented solvers, PaLM has a clearly different semantics. The\ntransition part of the OS is depicted in the figures 4 and 5.\nIn order to show that the OS (trace semantics) of PaLM is compliant, one\nneed the following properties of the GT:\n(G1) sol(S) \u21d2 R = \u2205\n(G2) f lr(S) \u21d4 R 6= \u2205\n(G3) (evtype = reduce) \u21d2 R = \u2205\n(G4) (evtype = awake) \u21d2 (R = \u2205 \u2227 A = \u2205)\n(G5) (evtype = schedule) \u21d2 (R = \u2205 \u2227 A = \u2205)\nOne admits:\n(P1) dependence(c, a) \u21d4 awcond(c, a)\n(P2) select(a) \u21d2 \u2203c \u2208 C action(c, a)\n(P3) \u2203v \u2208 var(()c), D(v) = \u2205 \u21d2 f alse(c, D)\nTheorem 2.\nThe GT restricted to all events depicted in the Figures 4 and 5 but back to and\nsolved, is a parametric subtrace of GenTra4CP, derived from the trace specified\nfor PaLM (Figures 6 and 7).\n\n\f10\n\nDeransart P.\n\uf8fc\n\uf8f1 \u2032\n\uf8f2 D (v) = D\u2032 (v) \u2212 \u2206cv , supprime \u2206cv , \uf8fd\n< D(v), Se , A >\n(c, a) \u2208 A, v \u2208 var(c), Red. gn. \u0101,\nreduce\n\uf8fe\n< D\u2032 (v), Se\u2032 , A\u2032 > \uf8f3 \u2032\nA = A \u2212 (c, a), Se\u2032 = Se \u222a \u0101\n< A, Sc >\n{(c, a) \u2208 A}\n< A \u2212 {(c, a)}, Sc \u222a {c} >\n\u001b\n\u001a\n< A, E >\n(c, a) \u2208 A,\nsolved\nsolved(c, D)\n< A \u2212 {(c, a)}, E \u222a {c} >\n\u001a\n\u001b\n< A, R >\n(c, a) \u2208 A,\nreject\nf alse(c, D)\n< A \u2212 {(c, a)}, R \u222a {c} >\n\u001b\n\u001a\n< A, Sc >\nc \u2208 Sc , a \u2208 Se \u222a {\u22a5},\nawake\nawcond(c, a)\n< A \u222a {(c, a)}, Sc \u2212 {c} >\n\u001b\n\u001a\n< Sc , Se >\nc \u2208 Sc , e \u2208 Se ,\nschedule\naction(c, a)\n< Sc\u2032 , Se\u2032 >\nsuspend\n\nFig. 5. OS of GenTra4CP (propagation)\nnew variable, new constraint\n\nidem GenTra4CP\n\npost , choice point idem GenTra4CP\nsolution\n\n< N , \u03a3, S >\n< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\n\u001a\n\nsol(S),\nn\u2208\n/N\n\n\u001b\n\nfailure\n\n< N, \u03a3 >\n< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\n\u001a\n\nn\u2208\n/ N,\nR 6= \u2205\n\n\u001b\n\nremove idem GenTra4CP\n\uf8fc\n\uf8f1\n\uf8f2 v \u2208 V, Rv \u2286 {d \u2208 D|E (v, d) \u2229 \u03c3 6= \u2205}, \uf8fd\n< D(v), Qt , E >\nE = {E (v, d)|d \u2208 Rv },\nrestore\n\uf8fe\n< D(v) \u222a Rv , Qt \u222a \u0101, E \u2212 E > \uf8f3\n\u0101 actions de restauration de D(v)\nFig. 6. OS of PaLM [6] (control)\n\n6\n\nGeneric Trace and Constraints Specification\n\nThis approach of semantics can be applied to constraints specification. The question then is whether it exists a generic trace covering all the constraints that one\nwishes to describe, i.e. covering different types of constraints (single, global,\n...), different domains ( FD, intervals, ...), different classes of solvers (CSP, SAT,\nrules, such as CHR), different levels (algorithms, modules, modeling) or different\naspects (language, interaction, interfaces, ...) as well.\nWe limit ourselves here to the CSP case. Each constraint has a declarative\nsemantics defined by the relation it represents on its domains. The GT can thus\nprovide a description of the possible effects of each constraint separately or in\na network, regardless the particular algorithm it implements. In this sense such\nsemantics is a kind of minimal description of what we should be able to observe\n\n\fConstraints and Traces\n\n11\n\n\uf8fc\n\uf8f1\nv \u2208 var(c), R = \u2205, A = {(c, a)},\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8fd\n\uf8f2\nca\n< D(v), Qt , E >\n\u2206v 6= \u2205 set of inconsistent values for v,\n\u001b\n\u001a\nreduce\nca\nca\nC \u2286 \u03c3 explains the removal of \u2206v from D(v), \uf8f4\n\uf8f4\n< D(v) \u2212 \u2206v , Qt \u222a {\u0101},\n\uf8f4\n\uf8f4\n\uf8fe\n\uf8f3\nThe reduction generates \u0101\nE \u222a {(v, d, C) | d \u2208 \u2206cva } >\n\n< A, Sc >\n{A = {(c, a)}}\n< \u2205, Sc \u222a {c} >\n\b\n< A, R >\nreject\nA = {(c, a)}, v \u2208 var(c), D(v) = \u2205\n< \u2205, R \u222a {c} >\n\u001a\n\u001b\n< Sc , A >\nA = \u2205, c \u2208 Sc , R = \u2205,\nawake\na \u2208 Qh \u222a {\u22a5}, dependence(c, a)\n< Sc \u2212 {c}, {(c, a)} >\n\b\n< Qh , Qt >\nschedule\nselect(a), A = \u2205, a \u2208 Qt , R = \u2205Sc 6= \u2205\n< {a}, Qt \u2212 {a} >\nsuspend\n\nFig. 7. OS of PaLM [6] (propagation)\n\nof the behavior of a constraints set. It can be used to define any kind of interfaces,\nparticularly for problem modeling.\nIn practice, as is what has been done for GenTra4CP, one should start with\na definition of an actual trace whose meaning can be given by a reconstruction function. It should be completed by an OS as large as possible such that\nparameters relevant to potential interfaces and applications are fully described.\nWe illustrate this approach of a generic semantics with a simple resolution example, showing the two traces obtained with GNU-Prolog and PaLM\nfor this example. Both solvers have been instrumented to produce the generic\ntrace for CSP(FD), and their traces can be \"understood\" using the OS of the\nFigure 8. Both traces (Figure 9) correspond to the resolution of (GNU-Prolog\nsyntax) fd element var(I,[2,5,7],A), (A#=I ; A#=2) which admits one solution only4 . The declarative semantics of this constraint (all variables are finite\ndomain) can be expressed as: fd element var(I, L, V) (L liste) constrains V\nto be equal to the Iith element of L. Thas is to say all triples such that i \u2208 I,\nu \u2208 L(i), v \u2208 V and u = v are valid. The interval [a-b] denotes from a to b and\n[a,b], a and b. One may observe5 that the traces are different, so, in particular:\n\u2013 the domain of I is not the same for GNU ([1-3]) and for PaLM ([0-2]);\n\u2013 the order and the values of the values removal are not the same, as the choice\nof variables to consider;\n\u2013 search spaces are different;\n\u2013 a specific variable occurs in the trace of PaLM (v-1).\n4\n\n5\n\nPaLM produces shortcuts such that the sequence reduce suspend schedule awake is\ndisplayed as reduce awake. Such shortcut does not have any semantics in GenTra4CP\n(it could be adapted). This shows only that the PaLM OS given in [6] was not actually\ncompliant to the GT.\nGenTra4CP produces traces in XML, readable but verbose. A more concise representation has been adopted here.\n\n\f12\n\nDeransart P.\n[new variable, v, Dv,i ]\n{}\n< V, D >\u2192< V \u222a {v}, D \u222a {(v, Dv,i )} >\n\nnew variable\n\nnew constraint\npost\nchoice point\nreduce\n\n[new constraint, c]\n{}\n< C >\u2192< C \u222a {c} >\n\n[post, c]\n{}\n< A >\u2192< A \u222a {(c, \u22a5)} >\n\n[choice point, n]\n{}\n< N , \u03a3, S >\u2192< N \u222a {n}, \u03a3 \u222a {(n, S)}, n >\n\n[reduce, c, v, \u0101, \u2206cv , a]\n{}\n< D(v), Se , A >\u2192< D(v) \u2212 \u2206cv , Se \u222a \u0101, A \u2212 (c, a) >\nsuspend\n\n[suspend, c, a]\n{}\n< A, Sc >\u2192< A \u2212 {(c, a)}, Sc \u222a {c} >\n\nawake\n\n[awake, c, a]\n{}\n< A, Sc >\u2192< A \u222a {(c, a)}, Sc \u2212 {c} >\n\nFig. 8. OS of GenTra4CP (reconstruction)\n\nThese variations are irrelevant when comparing the respective semantics (renaming, extra variable) and from both actual traces one may reconstruct the\ncorresponding virtual ones. However some variations should be examined and\nfixed like the limit values of I, or some specific attributes.\n\n7\n\nDiscussion\n\nThe semantics of traces presented here corresponds to the \"Observable Semantics\" of Lucas [8] or the partial trace semantics of Cousot [1]. The parameters of\nthe virtual states are, as expressed by Lucas, \"syntactic objects used to represent\nthe conduct of operational mechanisms\". The traces are abstract representations\nof process semantics which allow to take into account the sole details we want to\nconsider as common to a set of processes. The choice to relate two forms of trace\n(virtual and actual) corresponds to the need to reconcile different pragmatic approaches: formal specification of semantics more or less abstract, and empirical\nmanipulations of traces like in trace-based systems [10]. We established here a\nparticular method to demonstrate compliance of a process trace with regards to\na generic trace. This approach allows to establish formal relations with the trace\ntheory [3] too.\nWe have shown here that the definition of the trace GenTra4CP can be well\ndefined in such a theoretical framework, and we have characterized by relatively\nsimple transformations (parametric subtrace, similarity and derivation) the formal linkages between the observed processes and the generic trace. This analysis\nrevealed some insufficiencies in the formal definition of GenTra4CP as the lack\nof formal verification of particular traces solver compliance. Simonis & al [11]\n\n\fConstraints and Traces\n1[0]choice point node(0)\n2[1]newVariable v1 [0-mx]\n3[1]newVariable v2 [0-mx]\n4[1]newConstraint c1\nfd_element([v1,[2,5,7],v2])\n5[1]post c1\n6[1]reduce c1 v1 [0,4-mx]\n7[1]reduce c1 v2\n[0-1,3-4,6,8-mx]\n8[1]suspend c1\n9[1]choice point node(1)\n10[2]newConstraint c4\nx_eq_y([v2,v1])\n11[2]post c4\n12[2]reduce c4 v2 [5,7]\n13[2]reduce c4 v1 [1,3]\n14[2]suspend c4\n15[2]schedule v2 dom\n16[2]awake c1\n17[2]reject c1\n18[2]failure node(2)\n...\n\n13\n\n0[0]newVariable v0 I [0-mx]\n1[0]newVariable v1 A [0-mx]\n2[0]newConstraint c0\nelement(I,[2,5,7],A)\n3[0]post c0\n4[0]suspend c0\n5[0]awake c0\n6[0]reduce c0 v0 [3-mx] max\n7[0]reduce c0 v1 [0,1] min\n8[0]reduce c0 v1 [8-mx] max\n9[0]suspend c0\n10[0]newConstraint c1 eq(I,A)\n11[0]post c1\n12[0]suspend c1\n13[0]awake c0 (v0,max)\n14[0]reduce c0 v1 [2-7] empty\n15[0]reject c0 empty\n16[0]failure\n17[0]newVariable v-1 I [0-1]\n18[0]reduce c2 v-1 [0,1] empty\n...\n\nFig. 9. Partial actual trace of GNU-Prolog and PaLM with the given example. The\nsecond attribute is the choice-tree depth\n\nnote that the generic trace GenTra4CP contains too many details with a too sophisticated specification. This is certainly true if the objective is just to analyze\nthe evolution of some problem variables and some aspects of the search. In this\ncase the need of trace information is limited and it is less work to implement\ndirectly the capture of the needed information rather than implementing a full\ngeneric trace format. But it is different if the objective is to create a generic\ninterface between solvers and many more applications. Our study shows also\nthat GenTra4CP probably contains too many optional details with no clear semantics, such that implementers feel free not to implement many of them, or\nto implement them with just specific implementation dependent semantics. A\nmore demanding approach, but which may be more useful, could be to specify\nformally more attributes of the generic trace.\nMoreover, as it has been observed in the Section 4, it is the task of the\ndeveloper of a solver to implement a generic (sub)trace or to adapt the tools\nwhich have been developed on the basis of the generic trace. The investment to\nmake is measured by the gap between the developed process trace and the generic\ntrace (formally a derivation, Figure 3). It may seem easier to implement an adhoc trace systematically, rather than to implement once a compliant tracer, or\nto adapt a tool each time needed. Langevine and Ducass\u00e9 have shown [7] that a\ngeneric approach could have more advantages than drawbacks, but it is similar\nto a standardization effort.\nSuch an effort can only result from the action of a large community, and not\nfrom a small group as in the case of GenTra4CP. The project of standard [4]\nfocuses mainly on the definition of a Java interface that includes in particular the\nmajor types of variables, unary constraints, some binary and global constraints,\nas some strategies to search for solutions. But the question of the semantics\n\n\f14\n\nDeransart P.\n\ncannot be ignored. If the declarative semantics of simple constraints poses little\nproblem of specification, it is not the same for the operational semantics, whose\naccuracy depends on potential applications developed with constraint problems.\nThe approach presented here, based on a generic trace semantics, may be a\nway since it provides a framework for specifying outcomes and side effects of\nconstraint, revealing for example constraints interactions independently from\nspecific implementations.\n\n8\n\nConclusion\n\nGenTra4CP has been an innovative approach using a partial trace semantics to\nhandle both problems of specifying constraint solvers (on finite domains) and of\nportable analysis tools. Such an effort was similar to a standardization effort,\nbut with no effective dissemination because of its limits (small group who made\nit, some technical gaps and restricted to one constraints domain).\nWe have introduced a simple formal framework based on trace theory and\nabstract interpretation to explain the method of generic trace construction, and\nto show the potential value of this approach to specify a partial semantics of\nconstraints resolution.\nThe realization of a generic trace for a significant set of simple or global constraints certainly represents a considerable amount of efforts. It seems however\nthat such an approach could not only allow the portability of potential applications, but also contribute to the semantics of knowledge representation systems\nwhich combine several methods like constraints and rules.\n\nReferences\n1. Cousot, P., Cousot, R.: Systematic design of program transformation frameworks\nby abstract interpretation. In: Proc. of POPL 2002. pp. 178\u2013190 (2002)\n2. Deransart, P.: Towards a Trace Meta-Theory (Mar 2011), working document\nhttp://hal.inria.fr/ (mainly in French)\n3. Diekert, V., Rozenberg, G.: The Book of Traces. World Scientific Publishing, Singapore (1995)\n4. Feldman, J.: JSR-331, Java Constraint Programming API. Tr, Java Community\nProcess, Cork Constraint Computation Centre (2011), {\\tthttp://www.jcp.org}\n5. Jussien, N., Barichard, V.: The PaLM system: explanation-based constraint programming. In: Proceedings of TRICS: Techniques foR Implementing Constraint\nprogramming Systems, a post-conference workshop of CP 2000. pp. 118\u2013133. Singapore (Sep 2000), {http://www.emn.fr/jussien/publications/jussien-WCP00.\npdf}\n6. Langevine, L., Deransart, P., Ducass\u00e9, M.: A generic trace schema for the portability of cp(fd) debugging tools. In: Apt, K., Fages, F., Rossi, F., Szeredi, P., Vancza,\nJ. (eds.) Recent Advances in Constraints. No. 3010 in LNAI, Springer Verlag (May\n2004)\n7. Langevine, L., Ducass\u00e9, M.: Design and implementation of a tracer driver: Easy\nand efficient dynamic analyses of constraint logic programs. Theory and Practice\n\n\fConstraints and Traces\n\n8.\n\n9.\n10.\n\n11.\n\n15\n\nof Logic Programming, Cambridge University Press 8(5-6) (Sep-Nov 2008), http:\n//arxiv.org/abs/0804.4116\nLucas, S.: Observable Semantics and Dynamic Analysis of Computational Processes. Tech. Rep. LIX/RR/00/02, Laboratoire d'Informatique LIX (2000), http:\n//users.dsic.upv.es/\\verb.~ .slucas\nOADymPPaC: Tools for dynamic analysis and debugging of constraint programs,\nfrench RNTL project (2001-2004) http://contraintes.inria.fr/OADymPPaC\nSettouti, L.S.: Modeled Trace Based Systems: Model and Languages for the Use\nof Traces of Interactions. Ph.D. thesis, Universit\u00e9 Claude Bernard - Lyon I (Jan\n2011)\nSimonis, H., Davern, P., Feldman, J., Mehta, D., Quesada, L., Carlsson, M.: A\nGeneric Visualization Platform for CP. In: Petrie, K. (ed.) Proceedings of the 16th\nInternational Conference on Principles and Practice of Constraint Programming.\nSt Andrews, Scotland (Sep 2010)\n\n\f16\n\nDeransart P.\n\nANNEX: Proofs\n8.1\n\nProof of theorem 2\n\nOne shows that a parametric subtrace of PaLM is simulable by a parametric\nsubtrace of GenTra4CP.\nOne considers the GT GenTra4CP, restricted to all the events of the Figures 4 and 5 but back to and solved. Ignoring back to does not affect the searchtree construction but only its visiting strategy, and ignoring solved corresponds\nto removing the parameter E in the solver state. Furthermore the parameter\ncorresponding to the explanations can be ignored, as it is not formalized in the\nOS of GenTra4CP.\nAccording to the definition 2, the restriction to the subset of considered\nevents is a parametric subtrace of GenTra4CP.\nThe subtrace of PaLM to be considered consists just in ignoring the explanations. This does not restrict the set of action types (definition 2).\nIn GenTra4CP and the considered subtrace, the control part Tg uses actually 4 parameters: N , \u03a3, \u03b4, \u03bd, and the propagation part Sg 8 parameters:\nV, C, D, A, E, R, Sc , Se , in total 12 parameters.\nIn PaLM, the control part Tp uses 5 parameters: N , \u03a3, \u03b4, \u03bd, Qt, and the\npropagation part Sp 9 parameters: V, C, D, A, R, Sc , Qh , Qt , E; in total 13 parameters (Qt is common). There are some differences:\n\u2013 E, the subset of the \"constraint store\", containing the valid constraints, is\nirrelevant in PaLM, as no satisfiability test is realized in PaLM (no \"entailment\").\n\u2013 The set Se of the current events in PaLM is a queue (Se = Qh \u222a Qt ) whose\nhead Qh (a singleton) contains the selected current event.\n\u2013 The state of the PaLM solver contains an additional parameter E, the explanation function which serves to store the what is called the \"explanations\".\nE is a partial function: E : V \u00d7 D \u2212\u2192 P(\u03c3)6 which assigns to each value\nremoval (v, d) (v \u2208 V, d \u2208 D(v)) a set of non relaxed constraints which explains this removal. This partial function is updated by the events reduce and\nrestore.\n\u2013 A, in PaLM, has at most one element.\nThus one shows that the PaLM subtrace is simulable in the subtrace \"PaLM\"\nof GenTra4CP.\nOne uses the theorem 1. One defines the application d between the modified\nstates Tp \u00d7 Sp and Tg \u00d7 Sg , that is: (one omits \u03b4 which is deducible directly from\nN)\nN , \u03a3, \u03bd, V, C, D, A, R, Sc, Qh , Qt and\nN , \u03a3, \u03bd, V, C, D, A, R, Sc, Se\n6\n\nP(\u03c3): powerset of the store \u03c3 (instance of the constraints which are in A, Sc and R\nfor PaLM).\n\n\fConstraints and Traces\n\n17\n\nas follows: identity for the 9 first parameters of PaLM N , \u03a3, \u03bd, V, C, D, A, R, Sc,\nthen Qh \u222a Qt = Se .\nThe action types have the same names ans their set is restricted to those in\nthe Figures 6 and 7.\nThe initial states T0,p \u00d7 S0,p and T0,g \u00d7 S0,g to be considered are:\n{rcp }, (rcp , S0,p ), rcp , \u2205p , \u2205p , \u2205p , \u2205p , \u2205p , \u2205p , \u2205p , \u2205p and\n{rcg }, (rcg , S0,p ), rcg , \u2205g , \u2205g , \u2205g , \u2205g , \u2205g , \u2205g , \u2205g , \u2205g\nnew variable, new constraint, post, choice point and remove are in correspondence\nas the transition rules are the same, as their modified parameters as well.\nFor solution and failure, it is the same provided the properties (G1) and (G2)\nhold.\nThe case of restore is more complex. But, if one ignores the explanations and\ntake for \u2206v , Rv (\u2206v = Rv ) for the same variable v, the conditions associated to\nthe event of Gentra4CP are deducible from the explanations properties (restitution of the removed values, then inexistent in the current domain of v). But one\nhas to justify the update of Se in the transition rule of GenTra4CP.\nreduce. To \u2206cva it corresponds \u2206cv (set of inconsistent values) of the GT.\nBy (G3) the properties R = \u2205 correspond. Finally as d(Qh \u222a Qt ) = Se , then\nd(Qh \u222a Qt \u222a \u0101) = Se \u222a \u0101.\nsuspend. In the corresponding initial states (c, a) \u2208 A, and A\u2032 = A \u2212 {(c, a)}\nin the final states.\nreject. Uses (P3) for the initial states, and the final states are in correspondance.\nawake. Uses (P1) and (G4).\nschedule. Uses (P2) and (G5). Sc and Se are invariants in the GT.\n\n\f"}