{"id": "http://arxiv.org/abs/0705.1904v1", "guidislink": true, "updated": "2007-05-14T10:43:22Z", "updated_parsed": [2007, 5, 14, 10, 43, 22, 0, 134, 0], "published": "2007-05-14T10:43:22Z", "published_parsed": [2007, 5, 14, 10, 43, 22, 0, 134, 0], "title": "Loss Tolerant Linear Optical Quantum Memory By Measurement Based Quantum\n  Computing", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0705.0390%2C0705.1229%2C0705.0706%2C0705.3366%2C0705.1101%2C0705.2441%2C0705.1904%2C0705.1554%2C0705.3520%2C0705.4080%2C0705.0886%2C0705.4115%2C0705.2187%2C0705.2588%2C0705.3482%2C0705.3464%2C0705.3055%2C0705.4514%2C0705.3666%2C0705.0227%2C0705.4183%2C0705.4660%2C0705.0028%2C0705.2091%2C0705.0295%2C0705.1853%2C0705.0564%2C0705.3080%2C0705.0979%2C0705.3158%2C0705.4226%2C0705.3461%2C0705.0232%2C0705.1930%2C0705.4432%2C0705.1721%2C0705.0926%2C0705.4195%2C0705.0256%2C0705.4086%2C0705.4564%2C0705.3597%2C0705.0317%2C0705.4033%2C0705.4166%2C0705.1206%2C0705.2932%2C0705.1416%2C0705.3565%2C0705.3562%2C0705.3312%2C0705.2241%2C0705.1393%2C0705.1388%2C0705.0815%2C0705.4143%2C0705.0291%2C0705.3319%2C0705.0749%2C0705.1616%2C0705.3936%2C0705.3049%2C0705.4528%2C0705.3506%2C0705.2947%2C0705.0715%2C0705.0897%2C0705.4051%2C0705.3020%2C0705.2820%2C0705.0241%2C0705.1630%2C0705.2735%2C0705.0065%2C0705.2056%2C0705.3779%2C0705.0433%2C0705.3242%2C0705.0805%2C0705.1222%2C0705.0602%2C0705.2900%2C0705.2024%2C0705.3677%2C0705.1525%2C0705.1863%2C0705.3205%2C0705.3894%2C0705.3683%2C0705.2652%2C0705.2497%2C0705.0617%2C0705.2728%2C0705.1163%2C0705.3101%2C0705.3195%2C0705.1883%2C0705.2329%2C0705.2842%2C0705.0208%2C0705.0631&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Loss Tolerant Linear Optical Quantum Memory By Measurement Based Quantum\n  Computing"}, "summary": "We give a scheme for loss tolerantly building a linear optical quantum memory\nwhich itself is tolerant to qubit loss. We use the encoding recently introduced\nin [Phys. Rev. Lett. 97, 120501, (2006)] and give a method for efficiently\nachieving this. The entire approach resides within the \"One-way\" model for\nquantum computing. Our results suggest that it is possible to build a loss\ntolerant quantum memory, such that if the requirement is to keep the data\nstored over arbitrarily long times then this is possible with only polynomially\nincreasing resources and logarithmically increasing individual photon life\ntimes.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0705.0390%2C0705.1229%2C0705.0706%2C0705.3366%2C0705.1101%2C0705.2441%2C0705.1904%2C0705.1554%2C0705.3520%2C0705.4080%2C0705.0886%2C0705.4115%2C0705.2187%2C0705.2588%2C0705.3482%2C0705.3464%2C0705.3055%2C0705.4514%2C0705.3666%2C0705.0227%2C0705.4183%2C0705.4660%2C0705.0028%2C0705.2091%2C0705.0295%2C0705.1853%2C0705.0564%2C0705.3080%2C0705.0979%2C0705.3158%2C0705.4226%2C0705.3461%2C0705.0232%2C0705.1930%2C0705.4432%2C0705.1721%2C0705.0926%2C0705.4195%2C0705.0256%2C0705.4086%2C0705.4564%2C0705.3597%2C0705.0317%2C0705.4033%2C0705.4166%2C0705.1206%2C0705.2932%2C0705.1416%2C0705.3565%2C0705.3562%2C0705.3312%2C0705.2241%2C0705.1393%2C0705.1388%2C0705.0815%2C0705.4143%2C0705.0291%2C0705.3319%2C0705.0749%2C0705.1616%2C0705.3936%2C0705.3049%2C0705.4528%2C0705.3506%2C0705.2947%2C0705.0715%2C0705.0897%2C0705.4051%2C0705.3020%2C0705.2820%2C0705.0241%2C0705.1630%2C0705.2735%2C0705.0065%2C0705.2056%2C0705.3779%2C0705.0433%2C0705.3242%2C0705.0805%2C0705.1222%2C0705.0602%2C0705.2900%2C0705.2024%2C0705.3677%2C0705.1525%2C0705.1863%2C0705.3205%2C0705.3894%2C0705.3683%2C0705.2652%2C0705.2497%2C0705.0617%2C0705.2728%2C0705.1163%2C0705.3101%2C0705.3195%2C0705.1883%2C0705.2329%2C0705.2842%2C0705.0208%2C0705.0631&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We give a scheme for loss tolerantly building a linear optical quantum memory\nwhich itself is tolerant to qubit loss. We use the encoding recently introduced\nin [Phys. Rev. Lett. 97, 120501, (2006)] and give a method for efficiently\nachieving this. The entire approach resides within the \"One-way\" model for\nquantum computing. Our results suggest that it is possible to build a loss\ntolerant quantum memory, such that if the requirement is to keep the data\nstored over arbitrarily long times then this is possible with only polynomially\nincreasing resources and logarithmically increasing individual photon life\ntimes."}, "authors": ["Michael Varnava", "Daniel Browne", "Terry Rudolph"], "author_detail": {"name": "Terry Rudolph"}, "author": "Terry Rudolph", "links": [{"title": "doi", "href": "http://dx.doi.org/10.1088/1367-2630/9/6/203", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/0705.1904v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0705.1904v1", "rel": "related", "type": "application/pdf"}], "arxiv_comment": "20 pages, 10 figures. to appear in New Journal of Physics Focus Issue\n  on \"Measurement-based quantum information processing\"", "arxiv_primary_category": {"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "quant-ph", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0705.1904v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0705.1904v1", "journal_reference": "New J. Phys. 9 203 (2007)", "doi": "10.1088/1367-2630/9/6/203", "fulltext": "arXiv:0705.1904v1 [quant-ph] 14 May 2007\n\nLoss Tolerant Linear Optical Quantum Memory By\nMeasurement Based Quantum Computing\nMichael Varnava\nOptics Section, Blackett Laboratory, Imperial College London,\nLondon, SW7 2BZ, United Kingdom\n\nDaniel E. Browne\nDepartments of Materials and Physics, University of Oxford,\nParks Road, Oxford, OX1 3PH, United Kingdom\n\nTerry Rudolph\nOptics Section, Blackett Laboratory, Imperial College London,\nLondon, SW7 2BZ, United Kingdom\nInstitute for Mathematical Sciences, Imperial College London,\nLondon, SW7 2BW, United Kingdom\nAbstract. We give a scheme for loss tolerantly building a linear optical quantum\nmemory which itself is tolerant to qubit loss. We use the encoding recently introduced\nin [1] and give a method for efficiently achieving this. The entire approach resides\nwithin the \"one-way\" model for quantum computing [2]. Our results suggest that\nit is possible to build a loss tolerant quantum memory, such that if the requirement\nis to keep the data stored over arbitrarily long times then this is possible with only\npolynomially increasing resources and logarithmically increasing individual photon lifetimes.\n\n\f2\n1. Introduction\nLinear optics is a promising candidate for quantum computing. Photons make\nexcellent qubits. They are very versatile, mobile and have long decoherence times\nallowing for data to be confidently stored in them. Logic gates for linear optical\nquantum computation (LOQC) can be built using interferometric linear optical elements\n(e.g. phase shifters and polarizing beam splitters), photon detectors and photon\nsources in a scalable manner, as shown by [3]. Alternative approaches to LOQC\nusing measurement based computation [4, 5, 6] considerably reduce the overhead\n(in extra modes, photons detectors and phase stable circuitry) necessary for scalable\ncomputation. In measurement-based quantum computation, single qubit measurements\nalone on entangled multi-qubit states called cluster-states, or graph-states, implement\nthe computation. These schemes provided a recipe for efficiently generating cluster\nstates of arbitrary size using conditional linear optics and photo-detection. However, in\ntheir initial forms they only succeed if all errors can be ignored.\nA cluster state is a multi-qubit entangled state represented graphically by a graph,\nwhere the n vertices of the graph correspond to qubits prepared in state |+i, and the\nbonds denote the application of a certain entangling logic gate between the connected\nqubits. If we denote by E(i) the set of edges on this underlying graph connected to\nvertex i, we can compactly describe such a state in terms of it's \"stabilizer generators\",\na set of operators of the form:\nY\nXi\nZj ,\n(1)\nj\u2208E(i)\n\nunder which the state is invariant. An operational interpretation of the stabilizer\noperators is a prediction of correlations in the measurement outcomes of certain sets\nof measurements.\nAn important property of cluster states is that the application of parity\nmeasurements between qubits not connected on the graph implements a \"fusion\noperation\" [6], whereby the resultant state is a cluster state which has inherited the\ngraph of the previous state except that the two nodes representing the measured qubits\nhave been \"fused\" into a single vertex. The fusion operation allows one to combine\ndisjoint cluster states and, in particular, to construct large cluster states from smaller\nones. The fusion operation (and it's linear optical realisation) is the main tool which\nwill be utilised to build up the entangled states which will be employed in this paper.\nOne of the major challenges for implementing LOQC is photon loss. Photons will\nonly have a finite lifetime, while for quantum computation quantum information must\nremain coherent over arbitrarily long times. Thus a scalable coherent quantum memory\nis an important step on the way to developing scalable LOQC. Various proposals exist\nfor single photon memory involve storing the photon in optical fibre loops [7] or in\ncold atomic clouds [8]. Our goal is to show that given lossy, single-photon memory\ndevices, inefficient detectors and inefficient single photon sources, a memory capable of\nstoring a photonic state indefinitely can be constructed. The individual photon memory\n\n\f3\nstorage times need only increase logarithmically with the total time required to keep\ndata qubits in memory. Furthermore, this can act as the basis for a gate-based approach\nto linear optical quantum computation, which would allow the adoption of fault-tolerant\napproaches to correct other non-loss errors [9].\nIn [1] a protocol for loss-tolerant quantum computation was proposed. At the\nheart of this scheme was the realisation, that tree-shaped cluster states can be used as\nan encoding, each \"tree\" replacing a logical qubit in the un-encoded cluster state. With\nthis encoding, single qubit losses of up to 50% can be efficiently suppressed to yield an\neffective loss rate for logical qubits which is arbitrarily close to zero. In this article we\ndescribe a construction procedure for efficiently and loss tolerantly creating the encoded\nlogical cluster states used for both computation and memory devices in a linear optical\nsetting and give a full account of the resources required.\nThere are two key techniques at the heart the linear optical memory we propose.\nThe first is the use of specialized cluster states we term \"hypertrees\". These states\nare formed from multiple loss tolerant tree clusters [1] fused together. A nice property\nof such states is that they allow (at the level of logical qubits) controlled-phase gates\nto be implemented with arbitrary success probability, something which is not possible\nvia linear optics and measurement on un-encoded photonic qubits; thus large encoded\ncluster states can be constructed, or logic gates can be implemented directly [10]. We\nexpect this technique to be of use and significance beyond its particular application\nhere.\nThe second technique is the fact that for the purposes of using continual\nteleportation through cluster states to keep a photon alive, only Pauli measurements\nare required. This is useful because it allows for a great amount of parallelization\nsince Pauli measurements do not need to be adapted based on the outcome of other\nmeasurements. The measurements can be implemented simultaneously which helps to\nrelax the requirements of the individual photon memory, in terms of the amount of\ntime individual photons need to be stored for. The loss tolerant properties of the treestructures employed allow us to attain a higher threshold than other recent proposals\nfor linear optical based memory [11].\nWe point out that here we only address detected losses (erasures), since these\nform the dominant errors we should expect within LOQC. Other work has addressed\nLOQC within the context of undetected errors, see e.g.[12, 13]. Furthermore, the neardeterministic logic gates this scheme allows on the level of encoded qubits could allow\nthe implementation of error-correction schemes for a wider variety of errors [9].\nThe paper is structured as follows: First we give a brief outline of the loss-tolerant\napproaches in [1]. We then give a resource efficient strategy for creating the trees used\nin the encoding. After this, we introduce a scheme for joining tree-encoded qubits in\nan asymptotically deterministic way by employing \"hypertree\" structures. Later on\nwe will give an account of how one can build the loss tolerant quantum memory with\nthe properties claimed earlier. A full resource count will be provided throughout to\ndemonstrate that the scheme introduced is resource efficient.\n\n\f4\n2. A resource for loss-tolerant computation\nIn [1] a protocol is outlined in which cluster states with a tree-structure are used to\nencode qubits to enable loss-tolerant measurement-based quantum computation. An\nexample of a tree-cluster state a state is shown in Figure 1. Tree cluster states are\nfully specified by their branching parameters, {b0 , b1 ...bm }; for example bi equal to the\nnumber of branches coming down from each qubit in level i. When each qubit of a\nlogical cluster state is encoded by a tree cluster state, then a plethora of alternative\nmeasurement patterns become available for implementing the desired logical operation;\nnamely the measurement of the original single qubit in some arbitrary basis.\n\nLevel 0\nLevel 1\nLevel 2\n\nb0 = 2\nb1 = 2\nb2 = 2\n\nLevel 3\nFigure 1. A tree cluster state with branching parameters: {b0 , b1 ...bm } = {2, 2, 2} .\n\nThe key idea is that one can actively change this measurement pattern as one\ngoes along to adapt for lost qubits detected on the way. At instances where qubit\nmeasurements fail, then the special quantum correlations present on the tree cluster\nstates can be exploited to allow the outcome of measurements on the lost qubits to be\ninferred by measuring other qubits on the tree, which due to the entanglement in the\nstate will be correlated with the lost outcome. The logical operation can thus proceed\nwith an alternative measurement pattern which is still available.\nIn [1] we showed that provided the trees have sufficient branching, independent\nqubit loss errors at rate \u01eb can be tolerated for any \u01eb < 0.5. More precisely, with only\na polylogarithmic scaling of the number of qubits, Q, required to be present on a tree,\nthe effective loss rate, \u03b5eff , is exponentially rapidly reduced to zero. More recently [14]\nwe showed that this threshold for \u01eb can be translated into an LOQC architecture with\nthe requirement that the product of the detector efficiency, \u03b7D , and the single photon\nsource efficiency, \u03b7S , has to be greater than 2/3.\n3. Creating the Tree Clusters efficiently.\nThe special tree cluster states introduced in [1] are fully specified by the branching\nparameters b0 to bm as they are traversed from the top to the bottom levels. We review\nbriefly in this section an efficient strategy for building these trees using redundantly\nencoded \"2-trees\" as the primitive building block and fusing them together into larger\ncluster states using the Type-II fusion gate. Type-II fusion is a variant of the fusion\noperation which can be employed when (at least) one of the qubits acted upon is\n\"redundantly encoded\". Redundant encoding is the simplest form of coding one could\n\n\f5\nimagine. The logical state |0i is represented by n-qubits in state |0i, i.e. |0i\u2297n and |1i\nis represented by |1i\u2297n . It is straight-forward to confirm that a Bell-state projection\nbetween such a pair of qubits acts as a parity measurement [15] - realising a fusion\noperation. A Type-II gate is a linear optical realisation of such a Bell-measurement. It\nis effected by the combination of a polarizing beamsplitter oriented at 45\u25e6 , followed by\nnumber-resolving and polarization-resolving detectors on both output modes. Here we\nwill use a slightly modified version of the gate by inserting a 45\u25e6 polarization rotator\non each of the two spatial modes prior to the beamsplitter. For the case where two\nphotons are detected at the same detector, the gate fails and the effect is to measure\nthe input qubits in the Z basis (instead of in the X basis as in the original version of\nthe gate proposed in [6]). The gate also fails when, less than 2 photons are detected in\ntotal by the gate (because of loss, detector inefficiencies etc.). The gate is only deemed\n\"successful\" (i.e. the desired fusion operation is implemented) when one and only one\nphoton is detected in each output spatial mode.\nIn the ideal case, where we assume no qubit loss is present and perfect sources and\ndetectors are available, the success probability rate for the linear optical Type-II gate\nacting on photons (which are in a locally maximally mixed state - as is the case for\ncluster state photons) is 50%. In a more realistic scenario, however, the actual success\nrate, PII , for the Type-II gate is compromised by the detection efficiencies \u03b7D of the two\ndetectors and the independent loss probability \u01eb of the two photons present in the gate.\nSince both photons must be present and both detectors must detect a photon then PII\n2\n(1\u2212\u01eb)2 \u03b7D\n.\nis reduced to\n2\nGenerally we define an \"n-tree\" as consisting of a central redundantly encoded\nqubit (in 2 physical qubits with logical bases |00i and |11i), to which n node qubits\nare connected on the graph. The example of Figure 2 shows a 2-tree. The strategy we\n\nRedundantly encoded qubit\n\"node\" qubit\nFigure 2. A 2-tree is a 3 qubit cluster state with a centrally redundantly encoded\nlogical qubit which branches out to 2 \"node\" qubits.\n\nfollow is to build the trees from bottom to top adding levels of qubits in the following\nway: First we fuse 2-trees together to form bm -trees. This is achieved through a series\nof post-selection steps. First we post-select upon successful fusion attempts to create\na resource of 4-trees from joining 2-trees together. Then we fuse 4-trees together and\ncreate a resource of 8-trees subject to successful type-II fusions and so on. Generally\nwe fuse m-trees with n-trees and upon successful outcomes on the Type-II detectors\nwe obtain (m + n)-trees (see Figure 3). The expected number of 2l\u22121 -trees required to\ncreate a 2l -tree is equal to 2/PII . Thus the expected number of 2-trees required to build\na single 2l -tree is [2/PII ]l\u22121 . Furthermore, it can readily be seen that in order to create\n\n\f6\n\nm nodes\n\nn nodes\n\nm+n nodes\n\nFigure 3. Successfully Type-II fusing an n-tree with an m-tree creates an n+m-tree.\nThe 2 photons used by the Type-II gate are indicated by the green box.\n\na bm -tree such that 2l\u22121 \u2264 bm \u2264 2l , then on average the number of 2-trees required is\n\u2264 [2/PII ]log2 (bm ) =poly(bm ). In this way we can efficiently create the lowest level of the\ndesired trees with the branching parameter needed to tolerate the given loss rate.\nThere are two steps involved for each additional level we would like to add. First\nwe use 2 successful bm -trees created earlier and fuse them together with a 2-tree in\nthe fashion shown in Figure 4(a) which uses two Type-II gates. Upon successfully\nperforming the gates the resulting cluster state is the one shown on Figure 4(b). This\n(a )\n\n(b)\n\n(c)\n\n(d)\n\nFigure 4. Adding a new level requires 2 steps. 1: (a) \u2192 (b) First fuse a 2-tree with 2\nof the existing trees to add a new higher level. 2: (c)\u2192 (d) Fuse states created in (b)\ntogether to increase the branching at the added higher level.\n\nis now a tree with branching parameters {b0 , b1 } = {2, bm }. The second step is to\nfuse these trees together as shown in Figure 4(c) to increase the top level branching\nfrom 2 to bm\u22121 . We can now increase the branching parameter on the top level from\n2 to bm\u22121 by combining these tree clusters together, much as we combined the initial\n2-trees. To complete the first step, the expected number of 2-trees required in order\nto create a single tree with branching parameters {2, bm } is (2poly(bm ) + 1) [1/PII ]2 .\nTo complete the second step, the expected number of trees with branching parameters\n{2, bm } required in order to create a single tree with branching parameters {bm\u22121 , bm } is\n\n\f7\n\u2264 [2/PII ]log2 (bm\u22121 ) . Therefore the overall expected cost in 2-trees required to create one\nsuch tree is \u2264 [1/PII ]2 poly(bm\u22121 )poly(bm ). This suggests that the extra added level with\nbranching parameter bm\u22121 incurs an increasing factor [1/PII ]2 poly(bm\u22121 ) in the 2-trees\noverhead. Iterating the process in order to add all required levels suggests that in order\nto create one tree cluster state with the full branching parameter profile {b0 , b1 ...bm } (as\nrequired in [1]) then the expected number of 2-trees required satisfies:\n\u00152m Y\n\u0014\nm\n1\npoly (bi ) .\n(2)\nhN2\u2212trees i \u2264\nPII\ni=0\nThe overall conclusion is that the expected number of qubits consumed in order to build\na tree containing Q qubits is polynomial in Q, since m \u2264 log2 (Q).\n4. From trees to \"hypertrees\".\nIn this section, we shall introduce a new cluster state structure which we call a\n\"hypertree\". In comparison to the tree-clusters introduced in [1], these have useful\nextra properties which we shall describe below. An example of a hypertree can be\nseen in Figure 5. Hypertrees are similar to the original trees, the only differences\nbeing the addition of an extra higher level. We assume that two of the qubits have\nbeen successfully measured in the X basis. The hypertree state is the state after these\nmeasurements have been performed. We retain them to simplify the states description.\nIn practice, one would generate the post-X-measurement hypertree state directly.\n\nX\nX\n\ntree encoded qubit\nnode qubits\n\ntrees attached to\nnode qubits\nFigure 5. A hypertree consists of node, tree-encoded qubits (used in Type-II fusions\nfor joining hypertrees) which are attached on a central (circled) tree encoded qubit\nintended for a logical cluster state.\n\nEach hypertree must be thought of as being a single, tree-encoded, logical qubit\nwhich is directly linked to a number of node qubits. Each of these node qubits are the\nroot of a further tree structure. These node-qubits will be used as the input of Type-II\nfusion gates to join together logical tree-encoded qubits (directly linked with them within\ntheir hypertrees) into larger computation-specific, tree-encoded cluster states. These\nnode qubits serve the same role as the leaf node qubits introduced by [13] however\nthe trees attached to these node qubits allow them to be measured indirectly and\nloss-tolerantly allowing one to recover from failures of the fusion gate. An alternative\n\n\f8\ndescription of the hypertree structures (as redundantly encoded qubits which are further\ntree encoded) was presented in [14].\nAs we shall see later, the node qubits provide a number of different alternatives\nwhereby one can attempt to join two logical qubits together. At most one and only\none Type-II gate is required to succeed between the node qubits of any two distinct\nhypertrees in order for the logical tree-encoded qubits to be successfully joined together.\nThis entire process is analogous to a logical Controlled-Phase (CZ) gate performed\nbetween the logical qubits. This is an essential step in creating the computation-specific,\ntree-encoded cluster state to be used by a computation. Further on we will see that\nthe reason for going through the intermediate steps of first building hypertrees and\nthen Type-II fusing their node qubits together in order to build computation-specific\ncluster states is that it allows us to join logical tree-encoded qubits together in a neardeterministic fashion by using the probabilistic Type-II fusion gates; and that this is\npossible with just polynomial resource overheads.\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nFigure 6. Two hypertrees can be joined together by Type-II fusing together their\nnode qubits. Only one Type-II is required to succeed. The overall effect is to create a\nCZ bond between the 2 tree-encoded qubits present in the original hypertrees if indeed\nat least one of the Type-II gates succeeds.\n\nIn Figure 6 we show how two hypertrees can be linked together using Type-II gates.\nTo see why it is we only require one Type-II gate to succeed we need to closely examine\nall the possible outcomes a Type-II gate can give and explain how they can be dealt\nwith. A Type-II gate has 3 distinct sets of outcomes: Either (a) only one or no photons\nwill be detected (because of loss or detector inefficiency) or (b) both photons will be\ndetected at the same detector or (c) both photons will be detected, one at each separate\ndetector. From these possibilities only (c) is accepted as the correct outcome. The\noutcomes (a) and (b) would be catastrophic if encoded qubits are not used. However,\n\n\f9\nthe fact that here there is a tree joined on every node photon means that we can execute\nspecific measurement patterns on those trees to rectify any of the possible outcomes with\narbitrary success probability. In particular, if outcome (a) occurs and the measured\nqubits are lost, then they can be indirectly and loss tolerantly measured in the Z-basis\nby measuring qubits in their attached tree as was discussed in considerable detail in [1].\nIf outcome (b) occurs then this has the effect of measuring the node qubits in the Z\nbasis. This is the least damaging result for an unsuccessful outcome, as it simply removes\nthe node qubits from the two hypertrees. This is precisely the reason for using the\nmodified version of the Type-II gate mentioned earlier, as in cluster state computation\nthe effect of Z measurements is to remove the measured qubits from the cluster state.\nNote that measuring the remainder of the connected tree can be advantageous since the\nextra measurements can provide additional information as to what the Z measurement\noutcome on the node qubits should be. Obtaining many such \"votes\" for a given outcome\nand applying a majority voting over these results can greatly suppress logical errors such\nas depolarisation [16, 17] although a full discussion of this effect is beyond the scope of\nthis article.\n\n(a )\n\n(b)\n\n(c)\n\nZ\n\nZ\n\nZ\n\nZ\n\nZ\n\nZ\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nFigure 7. (a) A Type-II gate is implemented between two node photons of two distinct\nhypertrees. (b) The resulting state after the successful Type-II outcome. (c) Resulting\nstate after measuring the undesired qubits in the Z basis. This is now a state whereby\nthe two logical qubits are successfully linked by a CZ bond.\n\nFinally, if outcome (c) occurs then we know that the gate has been successfully\nimplemented. Figure 7 shows explicitly an example of a successful Type-II gate. Once\nthe successful outcome is received then there are a number of new bonds created between\nthe two hypertrees as it is shown on Figure 7(b). Of all these new bonds, only the direct\nbond between the two logical qubits is required. Any of the other bonds emerging from\nthe qubits, that used to be in the first level of the trees attached onto the original\nnode qubits from either hypertree, must now be removed. This can be achieved by\nmeasuring all these qubits in the Z basis. Note that these Z measurements can again be\n\n\f10\nimplemented with a success probability arbitrarily close to unity, because they can also\nbe effected indirectly. Remember that these measurements are effected on qubits each\nof which was at the top level of a tree. Thus the Z measurements can also be effected\nindirectly by following measurement patterns on the lower levels of these trees in the\nfashion explained by [1].\nIt is clear, therefore, that regardless of which Type-II fusion outcome occurs there is\na specific measurement pattern that can be followed to deal with it. The purpose of these\nhypertrees is to (asymptotically) deterministically join tree-encoded qubits together\nusing lossy and probabilistic Type-II gates. At least one Type-II gate must succeed in\norder to be able to join two logical qubits together. As such it is expected that the higher\nthe number of node qubits present in hypertrees, the higher the effective probability for\nat least one Type-II fusion gate to succeed. We now analyse in a little more detail the\nrequirements for resource efficiency.\nThe computation-specific cluster states, used in the one way model for quantum\ncomputing [2], can be thought of as being created in two steps. First the qubits are\ninitiated in the |+i state and then the bonds present in the cluster state are formed\nby effecting controlled-phase gates between pairs of qubits. Suppose we would like to\nbuild a computation-specific cluster state formed by tree-encoded logical qubits. Such a\ncluster state can be built with arbitrary success probability by first initiating hypertrees\nand then fusing those together. Recall that hypertrees consist of tree-encoded logical\nqubits attached to node photons (which in turn have a tree attached on them). We\nshowed above that Type-II fusing node qubits of two distinct hypertrees has the effect\nof forming a direct CZ bond between the tree-encoded logical qubits present in these\nhypertrees. More importantly is that the probability with which this bond is effected\ncan be increased dramatically, simply by allowing for a large number of node qubits to\nbe available on each of the hypertrees containing the logical qubits. This is because that\nwould allow for the possibility of a large number of Type-II attempts to be implemented\nbetween the node qubits of the two hypertrees. Since the requirement is just one of\nthose fusion attempts needs to succeed, the effective success probability for joining the\nlogical hypertrees together is increased.\nAssume w.l.o.g that any logical qubit in the above computational cluster state\nmust be bonded to n other logical qubits. Further assume that for any such bond we\nwould like to allow for a maximum of k Type-II fusion attempts to be performed. This\nsuggests that we would want to use hypertrees which have kn node photons. To build\nsuch hypertrees would require an expected number of [1/PII ]2 poly(kn). To see this\nremember that hypertrees are in effect identical to the regular trees with an additional\nhigher level with branching factor kn.\nOn the other hand, the probability for successfully joining 2 tree-encoded logical\nqubits together (using their hypertrees) is given by:\ni\nh\n2k\n.\n(3)\nPCZ = 1 \u2212 (1 \u2212 PII )k Ptree\nHere Ptree is the probability for successfully implementing the necessary measurement\n\n\f11\npattern on the tree attached to a node photon as soon as the result of the TypeII fusion gate involving the node photon becomes available. There are 2k such node\n2k\nphotons involved with every attempt to fuse 2 hypertrees together and the Ptree\nfactor\nis present in the expression for PCZ above because all measurement patterns that have\nto be followed on the trees attached on these 2k node photons must succeed in order\nfor the successful fusion of the hypertrees.\nThe objective is to check whether\nPCZ cani approach unity with efficient resource\nh\nscaling. Consider first the factor 1 \u2212 (1 \u2212 PII )k in the expression for PCZ . The success\nprobability for performing a Type-II gate, PII is a fixed, physical parameter of the\nexperimental setup; thus one can choose a value for k to compensate for any value of\nPII efficiently. Here what we mean by hefficiently is that\ni even with a very modest linear\nk\nincrease of the value of k the factor 1 \u2212 (1 \u2212 PII ) increases and approaches unity\nexponentially fast no matter how small PII is.\nHowever, this linear increase in the value of k will have a noticeable effect on the\n2k\nsecond factor in the expression for PCZ given by Ptree\n. In [1] we showed with numerical\nanalysis that Ptree is related to Q, the number of physical qubits present in a tree encoded\nlogical qubit, by the expression:\n\u0013\n\u0012\n1\n, where c \u2248 4.5.\n(4)\nlog (Q) = c log log\n1 \u2212 Ptree\n\u0001\nRearranging gives: Ptree = 1 \u2212 exp \u2212Q1/c thus:\n\u0001\n2k\nPtree\n\u2243 1 \u2212 2k exp \u2212Q1/c ,\n(5)\n\u0001\nis a good approximation since 1 \u226b exp \u2212Q1/c even for very modest values of Q.\n2k\nFrom this we can deduce that Ptree\nis linearly decreasing with k, but the effect can\n2k\nbe over-compensated by the choice of Q since Ptree\nis exponentially dependent on Q1/c .\nBy linearly increasing Q1/c , one can over-compensate the effect of the previously chosen\n2k\nvalue for k and still have Ptree\napproaching unity exponentially fast.\nWe conclude therefore, that PCZ can approach unity exponentially fast with just\nlinearly increasing k and polynomially increasing Q with respect to PCZ . This is an\nefficient resource scaling as the number of qubits present on a hypertree with say nk\nnode qubits, contains nk(Q + 1) physical qubits in total. Hence the overall resource\nscaling is polynomial with highest degree equal to c + 1 with respect to PCZ .\n5. A loss Tolerant Quantum memory\nUsing the hypertrees introduced above one can create linear clusters of tree-encoded\nqubits. Such linear clusters and measurements in the X basis can then be used as a\nloss tolerant quantum memory for the one way model for quantum computing. The\nmemory we propose works in a teleportation-type approach. As can be seen on Figure\n8, the main idea is to join a data qubit with a linear cluster of 2 qubits. Subject to\nsuccessfully achieving this, one can proceed by measuring the original data qubit and\n\n\f12\n\nX\n\nX\n\nFigure 8. The quantum memory proposed works in a teleportation approach. First\nthe tree-encoded data qubit (red) which is in an arbitrary state \u03b1 |0i + \u03b2 |1i is joined\non a tree-encoded linear cluster. By performing logical X measurements on the data\nqubit and the next on its right teleports the state on the qubit furthest to the right.\n\nthe first qubit of the former 2-qubit linear cluster in the X basis. Subject to successfully\nimplementing these steps, the state of the original data qubit has now been teleported\nto the last qubit, (formerly the second qubit of the 2-qubit linear cluster). One can of\ncourse iterate this process for as long as necessary to store the data qubit. This in fact is\nexactly analogous to joining a longer linear cluster in the first place and performing an\neven number of X measurements (see Figure 9); the effect is to teleport the data qubit\nthrough a longer cluster, but equally it can be argued that the the effect is to store the\ndata qubit for a longer period of time. One can deduce that the method proposed here\nX\n\nX\n\nX\n\nFigure 9. Teleporting a data qubit through a longer tree-encoded linear cluster.\n\nis resource efficient way for constructing a quantum memory. In the previous section\nwe showed that with just polynomially increasing resources, one can perform logical\nCZ-gates between tree encoded qubits with exponentially increasing success probability,\nP CZ. In addition, the results of [1] indicate that the effective success probability, Ptree ,\nfor performing a measurement on a tree encoded qubit, can be exponentially increased\ntowards unity by polynomially increasing Q. These two are the operations required for\nthe proposed memory.\nSuppose we wish to create a memory that stores qubits for a time \u03c4mem with an\noverall success probability Pmem . The method we will actively create and operate the\nmemory would be as follows:\n\n\f13\n\n1.\n2.\n3.\n4.\n\nCreate a new hypertree.\nPerform a logical CZ-gate between the data qubit and the new hypertree.\nMeasure original data qubit in X basis.\nLabel the remaining logical qubit as the new data qubit and repeat from 1.\n\nSuppose also that the time it takes for one cycle (steps 1 to 4 to complete) is \u03c4q . Note\nthat the overall success probability for performing one cycle is given by PCZ Ptree . In\nother words it is the probability of successfully joining the newly created hypertree to\nthe data qubit followed by successfully measuring the original data qubit in the X-basis.\nThis would suggest that:\nPmem = (PCZ Ptree )\n\n\u03c4mem\n\u03c4q\n\n,\n\n(6)\n\ntimes in order to store a data qubit for a\nas we would need to repeat the cycle \u03c4mem\n\u03c4q\nperiod of \u03c4mem . (Incidentally the number of cycles has to be even in order to perform\nthe identity gate which is what in effect the memory gate actually is in this setting,\nhowever this feature does not affect the resource scaling calculations that follow.)\nBy substituting Eqn. (3) for PCZ the expression for the memory success probability\nbecomes:\n\u0015\n\u0013\n\u0013\n\u0015\u0014\n\u0012\n\u0014\n\u0012\n\u0001\n\u03c4mem\n\u03c4mem\nk\n1/c\n(7)\n(1 \u2212 PII )\nexp \u2212Q\n1 \u2212 (2k + 1)\nPmem \u2248 1 \u2212\n\u03c4q\n\u03c4q\nWith a bit of thought one can see that k and Q1/c scale logarithmically with \u03c4mem . To\nsee this suppose we need to find k \u2032 such that:\n\u0012\n\u0013\n\u2032\n\u03c4mem\n(8)\n(1 \u2212 PII )k = (1 \u2212 PII )k .\n\u03c4q\nTaking logarithms on both sides gives:\nh\ni\nlog \u03c4mem\n\u03c4q\nk\u2032 = k \u2212\n.\n(9)\nlog [1 \u2212 PII ]\nSimilarly, suppose we wish to find Q\u2032 such that:\n\u0013\n\u0012\n\u0001\n\u0001\n\u03c4mem\nexp \u2212Q\u20321/c = exp \u2212Q1/c .\n(10)\n\u03c4q\nTaking logarithms on both sides gives:\n\u0014\n\u0015\n\u03c4mem\n\u20321/c\n1/c\nQ\n= Q + log\n.\n(11)\n\u03c4q\n\nClearly by logarithmically increasing both k and Q1/c with respect to the memory time,\n\u03c4mem , has the effect of increasing the memory success probability to:\nPmem = (PCZ Ptree )\n\n\u03c4mem\n\u03c4q\n\n\u2192 PCZ Ptree .\n\n(12)\n\nSuch a memory will require \u03c4mem /\u03c4q hypertrees in order to store a data qubit for a\n\u0011h \u0010\n\u0011i2\n\u0010\n\u03c4mem\nlog\n. The\ntime \u03c4mem . Thus overall, resources scale proportionally to \u03c4mem\n\u03c4q\n\u03c4q\n\n\f14\nresource scaling here, is with regards to the total time \u03c4mem with which the qubit is\nrequired to be stored. With regards to the success probability rate, Pmem , by which\nthe data stored is stored over \u03c4mem , the results of the previous section for the resource\nscaling with respect to PCZ imply that Pmem can increase exponentially fast towards\nunity with similar polynomially increasing resources. Pmem differs from PCZ by a mere\nfactor of Ptree (after considering the resource scaling with respect to the \u03c4mem ) suggesting\nthat the resource scaling with respect to Pmem would be polynomial with degree c + 1\nwhich is very similar to the resource scaling with respect to PCZ discussed in the previous\nsection.\nAs we now explain, the fidelity of the quantum memory we are proposing can be\ndefined as the success probability of the memory. This of course is only true under the\nassumptions we made throughout this article namely that the only source of error is loss\ndue to imperfect detectors, imperfect single photon sources and lossy components. We\nalso assume that no dark counts occur at the detectors and that the single photon sources\ndo never emit 2-photon states. Under this model, the Type-II gates filter out all possible\noutcomes by discarding any input states that gave rise to an erroneous outcome as soon\nas such outcomes become known. Conversely this suggests that whenever a hypertree\nis postselected subject to successful outcomes on all the Type-II gates involved in its\npreparation then such a state may be regarded as being prepared perfectly.\nThe (yet) unmeasured qubits of the hypertree may not all, have been present during\nthe preparation of the state and thus may not have acquired the relevant entangling\nbonds intended by the Type-II gates. Such lost qubits would inevitably fail to be\ndetected when their measurement is attempted and the protocol proposed in [1] can\ndeal with such instances. However the important point to note is that the Type-II gates\nhave the property of taking imperfect source states at the input (i.e states with lost\nphotons prior to the input of the Type-II gate, but no loss from the pair of photons\noperating the gate) and producing output states (supposing the correct Type-II gate\noutcome) which are identical to states that are produced by perfect input states which\nundergone loss of the same qubits only after the action of the Type-II gate. In other\nwords if we were to model loss by a beamsplitter of reflectivity \u03b7 placed at each input\nspatial mode of a Type-II gate, we find that we can commute the two beamsplitters\nto the two output spatial modes of the gate prior to the detectors. This is specifically\ntrue whenever the Type-II gate is operated by at most one photon in each of the input\nmodes which is indeed always the case in the construction of the memory. The property\nof the Type-II gate just described implies that the fidelity of the states created using\nthis approach are only affected by loss. Thus the probability by which a memory can\nsucceed also gives the fidelity of the physical quantum state constituting the memory.\n6. For how long do the memory photons need to be stored?\nWe will give an estimate on the maximum time, \u03c4max , individual photons in the memory\nresource need to be stored for in terms of the time, \u03c4II , it takes for a Type-II gate\n\n\f15\nand associated classical feed-forward to complete (essentially the number of steps in the\nprotocol). In order to simplify the derivation we are also assuming that \u03c4II is the time\nrequired to perform single qubit measurements and the associated classical feed-forward,\nalthough it must be appreciated that in reality such measurements could take slightly\nmore time that the Type-II gates. However the vast majority of the time steps involved\nin the building process of the quantum memory only involve Type-II fusion gates for\nthe creation and joining of the hypertrees. Thus if the time required to perform single\nqubit measurements is comparable with \u03c4II , it should not make a significant difference\nin the estimate derived for \u03c4max . In giving this estimate, we make the assumption\nthroughout that the resources for implementing parallel computations are available in\nevery step. \u03c4max is thus the time it takes from the moment individual un-entangled\nphotons are produced until they are finally measured as part of the linear clusters used\nin the memory.\nWe estimate this time to be\n\" m\n#\nX\n\u03c4max =\nlog2 (bi ) + m + log2 (kn) + C \u03c4II ,\n(13)\ni=0\n\nwhere bi are the branching parameters and m is the maximum depth of the trees cluster\nstates introduced in [1] and C is a constant \u223c 5 \u2212 8.\nTo derive this expression for \u03c4max we count first the time steps required to build\n2-trees out of un-entangled photons, then the number of time steps it takes to build\ntrees out of 2-trees, then the time it takes to build trees into hypertrees and lastly\nthe time it takes to implement all the Type-II fusion gates along with the single photon\nmeasurements, to join together tree encoded qubits as linear logical clusters and measure\nthe logical qubits.\nThe time it takes to build 2-trees from un-entangled photons is equal to 2\u03c4II . One\n\u03c4II time step is required to build the intermediate three photon GHZ states, and another\n\u03c4II is required to fuse those into 2-trees.\nTo see what the total time is to build the trees introduced in [1] using 2-trees we\nneed to note first the number of \u03c4II time steps required in order to increase the branching\nat any level from 2 to bi (see Figure 4 step 2). At each \u03c4II time step we attempt fusion\ngates in order to join trees together to double the top level branching by post selecting\nthe successful Type-II fusion gate outcomes. Thus it takes approximately log2 (bi ) \u03c4II\ntime steps to increase the branching to bi . To add a higher level on the existing sub-trees\nwith branching equal to 2 (see Figure 4 step 1) requires one \u03c4II time step. Thus overall\nm\nP\nthe number of \u03c4II time steps required to build trees from 2-trees is\nlog2 (bi ) + m.\ni=0\n\nTo build trees into hypertrees essentially means that we want to add an additional\nhigher level with branching equal to kn. Thus by following the same logic this can be\nachieved by log2 (kn) extra \u03c4II time steps.\nIn order to implement fusion gates on hypertrees in order to join their tree-encoded\nlogical qubits into tree-encoded linear clusters (as required by the proposed memory\ngate), requires merely 3 \u03c4II time steps. This is because all the Type-II gates can be\n\n\f16\nimplemented simultaneously in one \u03c4II time step. Provided at that least one of these\ngates is successful (which occurs with near unit probability) the desired fusion between\nthe encoded logical qubits can be engineered by choosing appropriate measurement\npatterns for the subtrees attached to these node qubits. Whatever the outcomes\nof each of these gates will be, the measurement pattern that dictates what would\nhas to be performed on the trees attached to each of the node photons on all the\nhypertrees involved, would be known as soon as the fusion outcome is registered. These\nmeasurement patterns would take at most 2 \u03c4II time steps to complete. This is because\nnormally we can attempt to measure in one \u03c4II time step all the qubits in level 0 of\nthe trees [1] attached on every node photon. Then, subject to whether or not the\nmeasurements on this level succeed or fail because of loss, this would define a distinct\nmeasurement pattern that must be implemented on all the remaining qubits of the\nlower levels of the tree. This measurement pattern gives the basis in which each of the\nremaining qubits in the trees attached to the node qubits has to be measured. The\nmeasurement bases of these patterns are all Pauli measurements and are not dependent\nupon the patterns of loss within them. Therefore this entire set can be measured in one\ntime step.\nThe last thing remaining is to perform the logical X measurements on the\ndata qubit, and the adjacently joined qubit from the linear cluster (see Figure 8),\nremembering that both these are tree encoded. In order to implement the logical X\nmeasurements would require a set of many physical measurements [1]. However all these\nmeasurements can be performed in two \u03c4II time steps. First we attempt X measurements\non all of the physical qubits at level 0 of the trees in both of these logical qubits. As\nbefore, depending on whether or not loss occurs in the measurements defines a distinct\nmeasurement pattern that can be implemented on all the remaining qubits of the tree.\nThis again can be implemented in one further \u03c4II time step because all the measurements\nare again of Pauli observables.\nNote that the expression for \u03c4max is logarithmically dependent on the branching\nparameters of the trees and hypertrees used for the encoding and creation of the logical\ncluster states. This suggests that if there are enough resources available to allow for any\noperations to be performed in parallel this loss tolerant quantum memory is very fast,\nrelying on qubits which do not have to be stored over long times.\n7. Individual photon memory\nIn the previous sections we assumed that photons not used by a Type-II fusion gate\nduring the creation of the quantum memory can be perfectly stored until the memory is\ncreated. Of course, this assumption is not reasonable in a laboratory implementation.\nSuppose that P\u03c4II is the probability of successfully storing a photon not used in a\nType-II for a time \u03c4II . Further assume the pessimistic scenario where every photon (used\nin the building process of the quantum memory we are proposing) had to survive for the\nmaximum time \u03c4max . This would suggest that the probability of successfully storing any\n\n\f17\nphoton would be (P\u03c4II )\u03c4max /\u03c4II . Here we make the assumption that the individual photon\nmemory is similar in form to the cyclical quantum memory for photons proposed in [7]\n(i.e. the rate of photon loss during storage is constant). In other words the probability\nof storing the photon degrades by a factor of P\u03c4II for every \u03c4II time-step the photon is\nstored.\nIn [1] it was shown that it is possible to perform universal quantum computing\nusing tree encoded qubits, provided that the probability of successfully detecting the\nphysical qubits on the trees is greater than 50%. This implies that:\n(1 \u2212 \u01eb)\u03b7D (P\u03c4II )\u03c4max /\u03c4II \u2265 1/2\n\n(14)\n\nIf the above inequality is satisfied, then it is possible to build a quantum memory which is\nable to store data with arbitrary success probability over arbitrarily long times whereby\nthe resource scalings involved are of the form described in the earlier sections of this\narticle. The only implication of properly considering memory errors in the derivation\nof the 2-trees resource scaling is that the degree of the polynomial dependence on the\ntree branching parameters will change. Properly considering memory errors effectively\n(2\u03c4\n/\u03c4 )\nreduces the success rate of the Type-II fusion gate by (at worse) a factor of P\u03c4II max II\nas such errors can be absorbed in the Type-II fusion gate as loss errors. This in effect\nwould increase the degree of the polynomial dependence the 2-trees overhead has on the\ntree branching parameters (see Section 3). On the other hand the proper consideration\nof the memory errors during the building process of the quantum memory has no effect\non the derivation of \u03c4max , the maximum time individual photons need to be stored for\nin the process of building and using the quantum memory proposed in this article.\nLet us give an example with some sensible values of the various parameters involved,\nto give an idea as to what the expectations are for P\u03c4II . Suppose that the detector\nefficiency, \u03b7D , and the source efficiency, \u03b7S , are both 95%. Further assume that we\n(\u03c4\n/\u03c4 )\nhave P\u03c4IImax II = 85%. This means that the loss rate of the initial 3-qubit GHZ states\n(and all the subsequent trees produced using Type-II gates) using the linear optics\ncircuit proposed by [14] would be approximately 30%. Further suppose that we desire\nto implement a loss tolerant quantum memory gate which will have an effective success\nprobability: Pmem \u2265 99.99%. This probability is the combined probability of successfully\njoining an encoded 2-linear cluster to a single data qubit, and being able to perform the\ntwo logical X measurements. To achieve this, it would suffice to create trees that have\na success probability of 99.999% for performing a single qubit measurement on a tree\nencoded qubit [1] and to create the hypertrees involved with enough node photons such\nthat the effective success probability for joining two of them together would be 99.999%.\n(This is because [99.999%]5 \u2265 99.99%).\nThe trees that can suppress a loss rate of 30% to an effective success probability\nof 99.999% for performing the single qubit measurement on tree encoded qubits have\nbranching parameters {11, 23, 22, 4, 1} (data from [1]). Each Type-II gate will succeed\n(\u03c4\n/\u03c4 )\nwith probability \u2265 PII (0.85)2 \u2243 14.5% with the values of \u03b7D , \u03b7S and P\u03c4IImax II given\nabove. Thus k, the number of node photons that have to be present to boost the\n\n\f18\neffective probability of joining hypertrees together, PCZ , to 99.999% is \u223c 74. The\nnumber of bonds each hypertree forms with other hypertrees, n, is equal to 2 since we\nare only building linear cluster states for the needs of the proposed memory (c.f. in a\nlinear cluster state each qubit is at most connected to 2 other qubits).\nSubstituting these values in the expression for \u03c4max we find that the number of \u03c4II\ntime steps which are required for the memory 2-qubit linear cluster are \u223c 25. Therefore\nwe require that:\nP\u03c425\n= 0.85 \u21d2 P\u03c4II = 0.993\nII\n\n(15)\n\nTherefore in this specific example we demonstrated that logical qubits can be stored\nfor a time of 25\u03c4II with a success probability of \u2265 99.99% provided that individual\nphotons can be stored for a time \u03c4II with probability of 99.3% (assuming of course the\nvalues given for the detector and source efficiencies as well). Comparing with technology\n\n1.0\n\n0.8\n6.9\n\n10\n\n6.4\n\n10\n\n5.9\n\n10\n\n0.6\n\nPmem\n\n1\n\n0.4\n\n0.2\n\n0.0\n\n0\n\n1000\n\n2000\n\nNo. of\n\n3000\n\n4000\n\n5000\n\ntime steps\n\nFigure 10. Graph showing how Pmem varies with storage time when the treeencoded memory is implemented. The legend gives the number of qubits present in\nthe hypertrees for making up the tree-encoded, memory cluster states for each curve.\n\nwhich is currently available we see that the value of P\u03c4II derived above is a bit demanding,\nsome 2 orders of magnitude away from what is currently possible. For example the\ncyclical quantum memory for photons proposed in [7] has a cycle time of 13.3ns during\nwhich the probability of successfully storing the the photon is 81%. More recently in [18]\nit was shown that gate operation times with active feed-forward take \u223c 150ns. Setting\n\u03c4II to 150ns shows that individual photon memory times should improve by at least an\n\n\f19\norder of magnitude in storage times and at least an order of magnitude in the success\nprobability rate in order to be able to implement the proposed quantum memory.\nIn Fig. 10 we show how Pmem can be affected by simply varying the resources used\nin the tree encoded memory should this value of P\u03c4II be achieved. In each of the plots we\nassume that the probability for storing an individual photon over time \u03c4II is taken to be\n99.3% and observe how Pmem varies when the number of qubits present in hypertrees is\nincreased. As we can see from Fig. 10 for the case when no encoding is used, Pmem drops\nto zero very rapidly in a time less than 1000\u03c4II . However by increasing the number of\nqubits used in hypertrees one can actively reduce the rate by which Pmem decays. As\nlong as Eqn. (14) is satisfied, then the decay rate can in principle be reduced arbitrarily\nclose to zero.\n8. Conclusion\nIn this article we showed that it is possible to loss tolerantly create a quantum memory\nbased on a teleportation-type method which itself is tolerant to photon loss. The method\nexploits the fact that successive pairs of measurements of qubits in the X-basis in linear\ncluster states have the effect of performing the identity gate. We demonstrated that\nthe success probability with which data qubits can be stored with can approach unity\nexponentially fast by polynomially increasing the resource overhead with respect to the\nsuccess probability. We also showed that the resources only need to scale polynomially\nwith respect to the time we wish to keep a qubit stored.\nIn addition we showed that the maximum time required to store photons in order\nto create an elementary unit of the the loss tolerant memory - namely the 2-qubit linear\ncluster state - is logarithmically dependent on the resources required. Strictly speaking,\nthis can indeed destroy the threshold result, however, from a practical point of view,\nthis is a mild limitation since it only affects storage for extremely long times.\nIn the scheme for the quantum memory we are proposing, we introduced special\ncluster state structures (we called them hypertrees) which allow the probabilistic TypeII gates to be used to perform logical CZ-gates amongst tree-encoded qubits in a neardeterministic fashion. Since it is straightforward to convert parity measurements to\nentangling gates (see e.g. [10, 15]), this raises the possibility of using these gates to\nimplement an additional layer of encoding for tolerance to more general errors, while\nretaining the much relaxed loss threshold that our protocol provides.\nAcknowledgments\nThis research was supported by DTO-funded U.S. Army Research Office Contract No.\nW911NF-05-0397, Merton College, Oxford and the Engineering and Physical Sciences\nResearch Council (EPSRC) and the EPSRC's QIPIRC.\n\n\f20\nReferences\n[1] M. Varnava, D.E. Browne and T. Rudolph, Phys. Rev. Lett. 97, 120501 (2006).\n[2] R. Raussendorf and H. J. Briegel, Phys. Rev. Lett. 86, 5188-5191 (2001); R. Raussendorf,\nD.E. Browne and H.J. Briegel, Phys. Rev. A 68, 022312 (2003).\n[3] E. Knill, R. Laflamme, G. J. Milburn, Nature (London) 409, 46 (2001).\n[4] N. Yoran and B. Reznik, Phys. Rev. Lett. 91, 037903 (2003).\n[5] M.A. Nielsen, Phys. Rev. Lett. 93 040503 (2004).\n[6] D.E. Browne and T. Rudolph, Phys. Rev. Lett. 95 10501 (2005).\n[7] T. B. Pittman and J. D. Franson, Phys. Rev. A 66, 062302 (2002).\n[8] B. Julsgaard, J. Sherson, J. I. Cirac, J. Fiurasek and E. S. Polzik, 432, 482-486, (2004).\n[9] R. Raussendorf, J. Harrington, K. Goyal, Annals of Physics 321, 2242 (2006); R. Raussendorf and\nJ. Harrington, quant-ph/0610082.\n[10] C. W. J. Beenakker, D. P. DiVincenzo, C. Emary and M. Kindermann, Phys. Rev. Lett. 93, 020501\n(2004).\n[11] T. C. Ralph, A. J. F. Hayes, and A. Gilchrist, Phys. Rev. Lett. 95, 100501 (2005).\n[12] P. Aliferis and B. M. Terhal, Quant. Inf. Comp. 7, 139 (2007).\n[13] M.A. Nielsen, Henry L. Haselgrove and C.M. Dawson, Phys. Rev. Lett. 96, 020501 (2006); Phys.\nRev. A 73, 052306, (2006).\n[14] M. Varnava, D.E. Browne and T. Rudolph, quant-ph/0702044,(2006).\n[15] T. B. Pittman, B. C. Jacobs, and J. D. Franson, Phys. Rev. A 64, 062311 (2001).\n[16] P. P. Rohde, T. C. Ralph and W. J. Munro, Phys Rev A. 75, 010302(R), (2007).\n[17] M. Varnava, D.E. Browne and T. Rudolph, in preparation.\n[18] R. Prevedel et al, Nature 445, 65-69, (2007).\n\n\f"}