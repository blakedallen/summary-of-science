{"id": "http://arxiv.org/abs/1006.0404v1", "guidislink": true, "updated": "2010-06-02T14:30:55Z", "updated_parsed": [2010, 6, 2, 14, 30, 55, 2, 153, 0], "published": "2010-06-02T14:30:55Z", "published_parsed": [2010, 6, 2, 14, 30, 55, 2, 153, 0], "title": "Computational Complexity of Iterated Maps on the Interval (Extended\n  Abstract)", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1006.3430%2C1006.0710%2C1006.2881%2C1006.0243%2C1006.2960%2C1006.4660%2C1006.0588%2C1006.2809%2C1006.2233%2C1006.4822%2C1006.4680%2C1006.4502%2C1006.2677%2C1006.1530%2C1006.1472%2C1006.2871%2C1006.3768%2C1006.0404%2C1006.5624%2C1006.5724%2C1006.0460%2C1006.1691%2C1006.1857%2C1006.0489%2C1006.2484%2C1006.5643%2C1006.4737%2C1006.0327%2C1006.4685%2C1006.3195%2C1006.0541%2C1006.4670%2C1006.5437%2C1006.5939%2C1006.1100%2C1006.2269%2C1006.0717%2C1006.5343%2C1006.4119%2C1006.5519%2C1006.0397%2C1006.4664%2C1006.1952%2C1006.3062%2C1006.1259%2C1006.0051%2C1006.3219%2C1006.3964%2C1006.0131%2C1006.5140%2C1006.2541%2C1006.2904%2C1006.3608%2C1006.3187%2C1006.4081%2C1006.2213%2C1006.5943%2C1006.4259%2C1006.2868%2C1006.3288%2C1006.0339%2C1006.4310%2C1006.4450%2C1006.5539%2C1006.4193%2C1006.5937%2C1006.0633%2C1006.2722%2C1006.3668%2C1006.3747%2C1006.2419%2C1006.5681%2C1006.2745%2C1006.3432%2C1006.1504%2C1006.0065%2C1006.5592%2C1006.0427%2C1006.3627%2C1006.5838%2C1006.0933%2C1006.0505%2C1006.5531%2C1006.1536%2C1006.5389%2C1006.3256%2C1006.3027%2C1006.1776%2C1006.4881%2C1006.4761%2C1006.1659%2C1006.1962%2C1006.3176%2C1006.0271%2C1006.3083%2C1006.1015%2C1006.1833%2C1006.0475%2C1006.4927%2C1006.2590%2C1006.1078&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Computational Complexity of Iterated Maps on the Interval (Extended\n  Abstract)"}, "summary": "The exact computation of orbits of discrete dynamical systems on the interval\nis considered. Therefore, a multiple-precision floating point approach based on\nerror analysis is chosen and a general algorithm is presented. The correctness\nof the algorithm is shown and the computational complexity is analyzed. As a\nmain result, the computational complexity measure considered here is related to\nthe Ljapunow exponent of the dynamical system under consideration.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=1006.3430%2C1006.0710%2C1006.2881%2C1006.0243%2C1006.2960%2C1006.4660%2C1006.0588%2C1006.2809%2C1006.2233%2C1006.4822%2C1006.4680%2C1006.4502%2C1006.2677%2C1006.1530%2C1006.1472%2C1006.2871%2C1006.3768%2C1006.0404%2C1006.5624%2C1006.5724%2C1006.0460%2C1006.1691%2C1006.1857%2C1006.0489%2C1006.2484%2C1006.5643%2C1006.4737%2C1006.0327%2C1006.4685%2C1006.3195%2C1006.0541%2C1006.4670%2C1006.5437%2C1006.5939%2C1006.1100%2C1006.2269%2C1006.0717%2C1006.5343%2C1006.4119%2C1006.5519%2C1006.0397%2C1006.4664%2C1006.1952%2C1006.3062%2C1006.1259%2C1006.0051%2C1006.3219%2C1006.3964%2C1006.0131%2C1006.5140%2C1006.2541%2C1006.2904%2C1006.3608%2C1006.3187%2C1006.4081%2C1006.2213%2C1006.5943%2C1006.4259%2C1006.2868%2C1006.3288%2C1006.0339%2C1006.4310%2C1006.4450%2C1006.5539%2C1006.4193%2C1006.5937%2C1006.0633%2C1006.2722%2C1006.3668%2C1006.3747%2C1006.2419%2C1006.5681%2C1006.2745%2C1006.3432%2C1006.1504%2C1006.0065%2C1006.5592%2C1006.0427%2C1006.3627%2C1006.5838%2C1006.0933%2C1006.0505%2C1006.5531%2C1006.1536%2C1006.5389%2C1006.3256%2C1006.3027%2C1006.1776%2C1006.4881%2C1006.4761%2C1006.1659%2C1006.1962%2C1006.3176%2C1006.0271%2C1006.3083%2C1006.1015%2C1006.1833%2C1006.0475%2C1006.4927%2C1006.2590%2C1006.1078&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "The exact computation of orbits of discrete dynamical systems on the interval\nis considered. Therefore, a multiple-precision floating point approach based on\nerror analysis is chosen and a general algorithm is presented. The correctness\nof the algorithm is shown and the computational complexity is analyzed. As a\nmain result, the computational complexity measure considered here is related to\nthe Ljapunow exponent of the dynamical system under consideration."}, "authors": ["Christoph Spandl"], "author_detail": {"name": "Christoph Spandl"}, "author": "Christoph Spandl", "links": [{"title": "doi", "href": "http://dx.doi.org/10.4204/EPTCS.24.18", "rel": "related", "type": "text/html"}, {"href": "http://arxiv.org/abs/1006.0404v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/1006.0404v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.MS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.MS", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/1006.0404v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/1006.0404v1", "arxiv_comment": null, "journal_reference": "EPTCS 24, 2010, pp. 139-150", "doi": "10.4204/EPTCS.24.18", "fulltext": "Computational Complexity of Iterated Maps on the Interval\n(Extended Abstract)\nChristoph Spandl\nInstitut f\u00fcr Theoretische Informatik, Mathematik und Operations Research\nUniversit\u00e4t der Bundeswehr M\u00fcnchen\nD-85577 Neubiberg, Germany\nchristoph.spandl@unibw.de\n\nThe exact computation of orbits of discrete dynamical systems on the interval is considered. Therefore, a multiple-precision floating point approach based on error analysis is chosen and a general\nalgorithm is presented. The correctness of the algorithm is shown and the computational complexity\nis analyzed. As a main result, the computational complexity measure considered here is related to\nthe Ljapunow exponent of the dynamical system under consideration.\n\n1\n\nIntroduction\n\nConsider a discrete dynamical system (D, f ) on some compact interval D \u2286 R, called the phase space,\ngiven by a function f : D \u2192 D, a recursion relation xn+1 = f (xn ) and an initial value x0 \u2208 D. The sequence\n(xn )n of iterates is called the orbit of the dynamical system in phase space corresponding to the initial\nvalue x0 . If such a dynamical system is implemented, that is a computer program is written for calculating\na finite initial segment of the orbit for given x0 , care has to be taken in choosing the appropriate data\nstructure for representing real numbers. Traditionally, IEEE 754 double floating point numbers [10]\nare used. However, if the dynamical system shows chaotic behavior, a problem arises. The finite and\nconstant length of the mantissa of a double variable causes round off errors which are magnified after\neach iteration step. Only after a few iterations, the error is so big that the computed values are actually\nuseless [12]. To put things right, a rigorous method for computations with real numbers has to be used.\nIn [2], this issue is addressed for the logistic map which is also consiedred as a starting point in the next\nsection. There, the exact real arithmetic in the form of centered intervals with bounded error terms is\nused as described in [3]. However, the notation used in [2, 3] is an algebraic one based on arbitrary large\nintegers. On the other hand, the aim of the present paper is to keep the notation as close as possible to\nthe standard in scientific computing but being precise in the sense of exact real arithmetic. This has as\na consequence first that the basic data type is not an integer as considered in [2, 3], but a floating point\nnumber with a definite mantissa length. Second, the type of error considered here is the relative error as\nis standard in floating point arithmetic - in contrast to the absolute error considered in [2, 3]. In practice,\na multiple precision floating point library providing floating point numbers with arbitrary high mantissa\nlength have to be used. In the following, it is analyzed how the needed mantissa length behaves in\nmultiple-precision computations of iterates of discrete dynamical systems. The mantissa length needed\nfor floating point numbers such that any computed point of the orbit has a specified and guaranteed\naccuracy is examined. Therefore, a precise mathematical framework for floating point computations\nhas to be established. The main result shows that the ratio of mantissa length to iteration length in\nthe limit of iteration length to infinity is related to the Ljapunow exponent. Comparing, in [2] only\nthe logistic map is considered explicitly and the connection to the Ljapunow exponent is not stated,\nX. Zheng and N. Zhong (Eds.)\nComputability and Complexity in Analysis (CCA 2010)\nEPTCS 24, 2010, pp. 139\u2013150, doi:10.4204/EPTCS.24.18\n\nc Christoph Spandl\nThis work is licensed under the\nCreative Commons Attribution License.\n\n\f140\n\nComputational Complexity of Iterated Maps on the Interval\n\nbut observed numerically. In the present paper, this connection is shown mathematically for a general\ndiscrete dynamical system (D, f ). This result also gives some advice for economically designing exact\nalgorithms simulating one-dimensional discrete dynamical systems.\n\n2\n\nRoundoff Error, Error Propagation and Dynamic Behavior\n\nIn this section, the discrete dynamical system (D, f \u03bc ) with D = [0, 1] and f \u03bc : D \u2192 D, f \u03bc (x) := \u03bc x(1 \u2212 x)\nfor some control parameter \u03bc \u2208 (0, 4] is investigated. In the literature, the recursion relation xn+1 =\nf \u03bc (xn ) is called the logistic equation [5]. When implementing the logistic equation on a real computer\nand demanding to obtain exact values for the orbit (xn )n , the analysis of roundoff errors and of error\npropagation requires some care. This is due to the fact that for some values of \u03bc the dynamics is highly\nchaotic and therefore inaccuracies are magnified exponentially in time [6, 9].\nIn the following, for a given initial value x0 , the true orbit is denoted by (xn )n , whereas the really\ncomputed orbit, suffering from roundoff errors and error propagation, is denoted by (x\u0302n )n . Note that\neven x\u03020 may differ form x0 since the conversion to a floating point number may cause the very first\nroundoff error. One goal of this section is to give a rigorous estimation of the total error in dependence\nof the iteration step n.\nCalculating the orbit (x\u0302n )n , two types of error are present. First, error propagation due to the iteration\nscheme and second the roundoff error caused by the calculation of f \u03bc . Now, let x\u0302n for some n \u2208 N be\ngiven. Then the true error after one iteration step is x\u0302n+1 \u2212 xn+1 . Since in reality not f \u03bc (x\u0302n ) is calculated\nbut some erroneous approximation f\u02c6\u03bc (x\u0302n ), the true error can be written as x\u0302n+1 \u2212 xn+1 = f\u02c6\u03bc (x\u0302n ) \u2212 f \u03bc (xn ).\nHence, the true error can be written as a sum\nx\u0302n+1 \u2212 xn+1 = ( f \u03bc (x\u0302n ) \u2212 f \u03bc (xn )) + ( f\u02c6\u03bc (x\u0302n ) \u2212 f \u03bc (x\u0302n ))\n\n(1)\n\nof two terms. The first term describes solely the error propagation while the second term gives exactly\nthe newly produced error due to the approximate calculation of f \u03bc .\nTo handle the exact values of both errors computationally, interval arithmetic can be used [1]. Interval\narithmetic can be seen in the setting here as a special case of the computational model of TTE [16], which\ngives a precise notion for describing computations over the real numbers. Another strongly related model,\nwhich in some sense reflects the situation here more adequate is the Feasible Real RAM model [4]. For\nthe sake of simplicity however, an interval setting is used here. For any time step n, let the phase point\nxn together with its error be represented by two floating point numbers xln and xun (xun \u2265 xln ) with given\nmantissa length mn forming an interval [xln , xun ]. The interval is an enclosure of the real value xn , that is\nxn \u2208 [xln , xun ]. It is straightforward to transform the interval to a floating point value x\u0302n of mantissa length\nmn by setting\n\u0013\n\u0012 l\nx + xun\n(2)\nx\u0302n := gl n\n2\nwhere gl(.) performs the rounding to nearest floating point number. The absolute error en := |x\u0302n \u2212 xn | of\nx\u0302n can be estimated via the interval length dn := xun \u2212 xln by\n1\nen \u2264 dn + rn\n2\n\n(3)\n\nwhere rn is an error introduced by the rounding operation gl(.) in Equation 2. An upper bound on rn will\nbe discussed later, for now it suffices to say that in general it is small compared to dn .\n\n\fChristoph Spandl\n\n141\n\nFor doing an error analysis of the logistic equation analytically, some idealizing assumptions are\nmade. First, the value of \u03bc is assumed to be given with such a high precision that no interval representation is needed. Second, only the error propagation is considered caused by the initial error due to\nrounding x0 to some floating point number of mantissa length m. Third, the value of rn in Equation 3 is\nneglected. The recursion relation then reads in natural interval extension\nxln+1 = \u03bc xln (1 \u2212 xun )\nxun+1 = \u03bc xun (1 \u2212 xln )\nwith the interval length dn given by the recursion relation\ndn+1 = xun+1 \u2212 xln+1 = \u03bc (xun \u2212 xun xln \u2212 xln + xun xln )\n= \u03bc dn\nwith the obvious solution dn = \u03bc n d0 . Finally the absolute error en of x\u0302n according to Equation 2 can be\nbounded from above by\n1\n1\n(4)\nen \u2264 dn = \u03bc n d0 .\n2\n2\nNote that the above analysis only holds if the natural interval extension for f \u03bc is derived from the formula\n\u03bc x(1\u2212 x). If it is derived from the formula f \u03bc (x) = \u03bc (x\u2212 x2 ) or f \u03bc (x) = \u03bc4 \u2212 \u03bc (x\u2212 21 )2 , the mathematical\nanalysis is more difficult. However, the problems described in the following also appear, but in some\ndifferent form.\nThe aim now is to calculate, for given N \u2208 N, p \u2208 Z and mantissa length m, the orbit up to time N\nwith relative error 10\u2212p . That is, for (x\u0302n )0\u2264n\u2264N should hold\nen = |x\u0302n \u2212 xn | \u2264 10\u2212p xn \u2264 10\u2212p .\n\n(5)\n\nThe ideal assumptions require the somewhat unreal setting that the mantissa length has to be set to some\nfinite, but big enough value m for representing x0 and a virtually infinite value m\u221e for doing the iteration.\nFinally, some upper bound on d0 is needed. The value of d0 is given as the roundoff error by representing\nx0 as a floating point number of mantissa length m. For that, the well known estimate\nd0 \u2264 2\u2212m+1 x0 \u2264 2\u2212m+1\n\n(6)\n\nexists. Combining (5), (4) and (6) gives as a sufficient condition\n\n\u03bc n * 2\u2212m \u2264 10\u2212p\n\n(7)\n\nfor n = 0, . . . , N.\nThe minimal m, fulfilling the precision requirement (5) on the relative error of xn , which depends\non x0 , N and p, is denoted by mmin (x0 , N, p). So, the sufficient condition (7) gives an upper bound on\nmmin (x0 , N, p) by\nmmin (x0 , N, p) \u2264 \u2308p * ld(10) + N * max(0, ld(\u03bc ))\u2309\n(8)\nwhere ld(.) is the logarithm to base 2. At that stage, a central quantity of this work is introduced which\nis a kind of complexity measure. The loss of significance rate \u03c3 (x, p), which may depend on the initial\nvalue x = x0 and the precision p is defined by\n\n\u03c3 (x, p) := lim sup\nN\u2192\u221e\n\nmmin (x, N, p)\n.\nN\n\n\f142\n\nComputational Complexity of Iterated Maps on the Interval\n\nThis quantity describes the limiting amount of significant mantissa length being lost at each iteration\nstep. Significant means here the part of the places being exact. A general treatment of this complexity\nmeasure is given in the next section. Roughly speaking, \u2308\u03c3 (x0 , p)N + p * ld(10)\u2309 is the mantissa length\nfor any floating point number needed in an algorithm doing the iteration starting with x0 and calculating\nup to xN , if the output should be precise up to p decimal places. Formula 8 gives an upper bound for the\nloss of significance rate by \u03c3 (x, p) \u2264 max(0, ld(\u03bc )).\nIt is interesting to see whether the upper bound calculated analytically, which needed strong idealizations, is in the region of the real value. So, the logistic equation was implemented using a multipleprecision interval library. For that purpose, the interval library MPFI [15] based on the multiple-precision\nfloating point number library MPFR [8], both written in C, was used. For each control parameter \u03bc\nranging from 0.005 to 4 and a step size of 0.005, the orbit for initial condition 0.22 was calculated up\nto N = 2000. For each \u03bc , the minimum mantissa length mmin needed to guarantee en \u2264 10\u22126 xn for\nn = 0, . . . , N was searched. Then, \u03c3est := mmin /N was calculated. The result shows that \u03c3est exceeds the\nanalytical bound max(0, ld(\u03bc )) only slightly. So, the above made ideal assumptions seem to be valid.\nIn [12], the logistic equation was also investigated for \u03bc = 3.75 using the exact real arithmetic package\niRRAM based on the Feasible Real RAM model [4]. In the paper, also the precision needed to guarantee the exactness of the first 6 decimal places are reported up to N = 100000. The values are in full\nagreement with the simulation results performed here.\nHence, for \u03bc > 1, the interval length dn increases exponentially in time n. This result should be\ninterpreted in terms of the dynamical behavior of the logistic equation. So, at this point is worth having\nan analytical look at the behavior of the dynamical system. Despite the fact that these results are well\nknown [9, 7], they are reviewed here for the sake of self containment. First, the equation possesses in\nthe range D = [0, 1] exactly one fixed point xo = 0 if \u03bc \u2208 (0, 1] and exactly two fixed points xo = 0 and\nx(\u03bc ) = 1 \u2212 \u03bc1 if \u03bc \u2208 (1, 4]. Since f \u03bc\u2032 (0) = \u03bc and f \u03bc\u2032 (x(\u03bc ) ) = 2 \u2212 \u03bc , xo is a stable fixed point (an attractor,\n| f \u03bc\u2032 (xo )| < 1) for \u03bc \u2208 (0, 1) and an unstable fixed point (a repeller, | f \u03bc\u2032 (xo )| > 1) for \u03bc \u2208 (1, 4]. If \u03bc = 1,\nthe only fixed point xo is hyperbolic (| f1\u2032 (xo )| = 1) and a bifurcation occurs at that value of the control\nparameter \u03bc . If \u03bc \u2208 (1, 3), xo becomes unstable and the newly occurring fixed point x(\u03bc ) is stable. Finally,\nlimn\u2192\u221e f \u03bcn (x) = x(\u03bc ) for \u03bc > 1 and limn\u2192\u221e f \u03bcn (x) = xo if \u03bc \u2264 1 holds for all x \u2208 (0, 1). If \u03bc \u2208 (0, 1), this\nis a direct consequence of the contraction mapping principle. If \u03bc = 1, observe that f1 (x) < x holds for\nall x \u2208 (0, 1). Hence, any sequence ( f1n (x))n , x \u2208 (0, 1), is strictly decreasing and bounded from below.\nSo it converges to the only fixed point xo . For the case \u03bc \u2208 (1, 3), the interested reader is referred to the\nliterature: [7], Proposition 5.3. At \u03bc = 3 a second bifurcation occurs and for \u03bc > 3 the system goes into a\nregion of periodic behavior with period doubling bifurcations. Finally, for some \u03bc < 4, chaotic behavior\nis reached.\nThis analysis shows that in the parameter range \u03bc \u2208 (0, 3), the orbit converges to the stable fixed point\nfor any initial value x0 \u2208 (0, 1). Furthermore, there exists some closed interval I \u2286 D, which depends\non \u03bc , containing the stable fixed point such that f \u03bc (I) \u2286 I holds and f \u03bc is a contraction on I. The\ninterval computation using a natural interval extension of the recursion formula \u03bc x(1 \u2212 x), on the other\nhand, is not very compatible with this picture. While for \u03bc \u2208 (0, 1), the results are in agreement with\nthe dynamical analysis, the calculations for \u03bc \u2208 (1, 3) are not handled very well by interval arithmetic\nsince the interval approach would suggest an exponential divergence of initially nearby orbits which is\nnot true in reality. The reason is that the natural interval approach implicitly, due to the dependency\nproblem, takes account only of the global behavior of f \u03bc in the form of the global Lipschitz constant\nmax{| f \u03bc\u2032 (x)| : x \u2208 D} = \u03bc . However, the local Lipschitz constant max{| f \u03bc\u2032 (x)| : x \u2208 [xln , xun ]} governs the\nreal error propagation at time step n and also describes the dynamic behavior. This notion can be made\n\n\fChristoph Spandl\n\n143\n\nprecise and finally leads to a more efficient algorithm for computing orbits.\nLet us return to Equation 1. The true error is the sum of the error propagation (first term) according\nto the iteration and the roundoff error due to the computation of f \u03bc (second term). The first term of\nEquation 1 can be handled using the mean value theorem, | f \u03bc (x\u0302n ) \u2212 f \u03bc (xn )| = | f \u03bc\u2032 (yn )| * |x\u0302n \u2212 xn | with\nyn \u2208 [x\u0302n \u2212 en , x\u0302n + en ]. This gives directly the bound\n| f \u03bc (x\u0302n ) \u2212 f \u03bc (xn )| \u2264 sup(| f \u03bc\u2032 ([x\u0302n \u2212 en , x\u0302n + en ])|)en .\nThe second term can be estimated the following way. As discussed in [17], the roundoff error produced\nin calculating f \u03bc can be estimated by\n| f\u02c6\u03bc (x\u0302) \u2212 f \u03bc (x\u0302)| \u2264 1.06K2\u2212m | f \u03bc (x\u0302)|\nwhere K is the number of rounding operations performed in computing f\u02c6\u03bc and m is the mantissa length\nof x\u0302. In the case considered here, K = 4 follows since there are 3 arithmetic operations and the rounding\nof \u03bc . It is further crucial to mention that the factor 1.06 is only valid if K \u2264 0.1 * 2m holds so that the\nmantissa length must not be chosen too small. Using the fact that f \u03bc (x) \u2264 \u03bc4 holds and f \u03bc (x) < x if\n\u03bc \u2264 1, the unknown value | f \u03bc (x\u0302)| can be eliminated. This calculation shows that there exists a recursive\nequation on an upper bound en on en for all n:\nen+1 = L(x\u0302n , en )en + 1.06K2\u2212m E\u03bc (x\u0302n ),\n\ne0 = 2\u2212m\n\n(9)\n\nwith L(x, e) := sup(| f \u03bc\u2032 ([x \u2212 e, x + e])|) and\nE\u03bc (x) :=\n\n(\n\nx\n\u03bc\n4\n\nif \u03bc \u2264 1\n.\nif \u03bc > 1\n\nThe idea is now not to calculate intervals, but pairs of values x\u0302n and corresponding guaranteed error\nbounds en . The difference to the interval concept is not to compute the errors implicitly, so that only\nglobal behavior can be taken into account, but to compute them explicitly and independent of the values\nof interest. It should be mentioned that the approach described here is compatible with an interval\napproach using special centered forms, namely mean value forms [14]. However, the approach here\nexplicitly devises values and errors, describes an automated error analysis, whereas an interval approach\nprimarily does not disclose any error. Furthermore, also the iRRAM package permits a more elaborate\nway for computing the iteration, based on a similar algorithm as described above [13]. The rounded\nvalues x\u0302n are calculated as usual in floating point arithmetic except that multiple-precision floats are used.\nThe guaranteed error bounds are also calculated using floating point according to (9), where interval\narithmetic is used for calculating L. Only standard precision is needed for calculating the error bounds.\nImplementing this improved algorithm using MPFR and MPFI, the setting as given in the interval case\nproduces the following result. In the parameter range \u03bc \u2208 (0, 3), the dynamic behavior is reflected very\nwell. Furthermore, in the range \u03bc \u2208 [3, 4], the curve suggests a relation between the loss of significance\nrate and the Ljapunow exponent \u03bb (x) for the logistic map (for a curve of the Ljapunow exponent of the\nlogistic map see [5]): \u03c3 (x) = max(0, \u03bb (x))/ ln(2) for all \u03bc \u2208 (0, 4]. To be complete, the definition of the\nLjapunow exponent reads\nDefinition 2.1. Let (D, f ) be a dynamical system, D \u2286 R compact and f : D \u2192 D continuously differentiable on the interior of D. Then the Ljapunow exponent at x is defined by\n1 n\u22121\n\u2211 ln f \u2032 ( f k (x))\nn\u2192\u221e n\nk=0\n\n\u03bb (x) := lim\nif the limit exists.\n\n(10)\n\n\f144\n\nComputational Complexity of Iterated Maps on the Interval\nThe Ljapunow exponent may depend on x. However, the following properties hold:\n\n(a) If (D, f ) has an invariant measure \u03c1 , then the limit in Equation 10 exists \u03c1 -almost everywhere.\n(b) Furthermore, if \u03c1 is ergodic then \u03bb (x) is \u03c1 -almost everywhere constant and equal to\nZ\n\nD\n\nln f \u2032 (x) \u03c1 (dx).\n\nThese properties are a direct consequence of the Birkhoff ergodic theorem, see [11], Theorem 4.1.2 and\nCorollary 4.1.9.\n\n3\n\nThe General Algorithm and its Complexity\n\nLet D be a compact real interval and f : D \u2192 D a self mapping. In the following, f is assumed to be\ncontinuous on D, continuously differentiable on the interior of D and f \u2032 is bounded. Furthermore, f and\nf \u2032 are assumed to be computationally feasible. The precise definition of \"computationally feasible\" is\ngiven below.\nIn this section, a general algorithm for computing the iteration\nxn+1 = f (xn ),\n\nx0 \u2208 D\n\n(11)\n\nis presented. To be more precise, for given N \u2208 N and p \u2208 Z, this algorithm computes a finite part of\nthe orbit, (xn )0\u2264n\u2264N , exact in the sense that the relative error at each point xn does not exceed 10\u2212p .\nThe correctness of the algorithm and its computational feasibility is shown. Finally, its complexity is\nexamined.\n\n3.1 Syntax, Semantics and the Algorithm\nThe set of all computationally accessible real numbers are the floating point numbers of arbitrary mantissa length denoted by R\u0302. In the following, by a floating point number any real number is meant which\ncan be expressed by normalized scientific notation. Hence, the set R\u0302 \u2286 R of all floating point numbers is countable infinite and therefore a natural basis for standard computability considerations. Let\nx\u0302 \u2208 R\u0302 be some floating point number, then x\u0302 has as an essential property, its mantissa length denoted by\nx\u0302.m. Any real number x is represented in an algorithm concerning real computation by a pair [x] \u2208 R\u03022\nconsisting of a floating point number [x]. f l approximating x and an upper bound on the relative error,\n[x].err \u2265 0, also being a floating point number. Furthermore, the inequality |[x]. f l \u2212 x| \u2264 [x].err holds.\nThe pair [x] is called a finite precision representation of x. Although [x].err has the property mantissa\nlength, it is irrelevant in what follows. So, the mantissa length of [x].err can be assumed to be some\nbig enough constant value. Analogously, a function f : D \u2192 D, D \u2286 R, is called computationally feasible if a pair [ f ] exists of a computable (partial) function [ f ]. f l : R\u0302 \u2192 R\u0302 approximating f on D and a\ncomputable (partial) function [ f ].er f : R\u03022 \u2192 R\u0302 giving an upper bound on the absolute error of [ f ]. f l in\nthe sense |[ f ]. f l([x]. f l) \u2212 f (x)| \u2264 [ f ].er f ([x]). Here, a partial function f\u02c6 : R\u0302 \u2192 R\u0302 is called computable\nif f\u02c6 is computable as a string function over some finite alphabet where the floating point numbers are\ninterpreted as finite strings. Finally, computability over integers, computability of functions with mixed\narguments and computable predicates are defined in a standard way.\nThe algorithm with the above described specification reads\n\n\fChristoph Spandl\n\n145\n\n1 Input parameter: x\u03020 , N, p\n2 Initialize mantissa length m \u2190 m0\n3 do\n4\nInitialize value and error [x] \u2190 gl(x\u03020 , m)\n5\nfor n = 0 to N do\n6\nIf prec([x], p) is true then\n7\nIf not printed print n, [x]. f l, [x].err\n8\nelse break\n9\n[x] \u2190 [ f ]([x])\n10\nend for\n11\n[x]. f l.m \u2190 [x]. f l.m + 1\n12 while prec([x], p) is false\nTo initialize [x], a rounding function gl : R\u0302 \u00d7 N \u2192 R\u03022 is needed where gl(x\u03020 , m0 ). f l is a floating point\nnumber of mantissa length m0 being the exactly rounded value of x\u03020 to some rounding convention.\nClearly, gl(x\u03020 , m0 ).err is an upper bound on the absolute rounding error, e.g. gl(x\u03020 , m0 ).err = 21 ul p(x\u03020 )\nif the rounding mode is to nearest. The predicate prec : R\u03022 \u00d7 Z \u2192 {true, false} is a test whether the\nrelative error of [x], |[x]. f l \u2212 x|/|x| if x 6= 0, is bounded by 10\u2212p . The semantics reads: If [x] \u2208 R\u03022 is a\nfinite precision representation of x \u2208 R and prec([x], p) = true holds, then |[x]. f l \u2212 x| \u2264 10\u2212p |x| follows.\nIn the following, some abbreviations are used occasionally. The floating point numbers and functions\nare indicated by a hat: x\u0302 := [x]. f l and f\u02c6 := [ f ]. f l. An over-bar indicates an error bound: e := [x].err and\ner f := [ f ].er f . Hence, [x] is equivalent to (x\u0302, e) and [ f ] is equivalent to ( f\u02c6, er f ).\nFinally a remark on optimization. The algorithm is not optimized in the performance. Otherwise,\nin Line 10 something like m \u2190 2m should be used. Here, the aim is to find the minimal m to guarantee\nsome given upper bound on the relative error of xn .\n\n3.2 Feasibility and Correctness\nIt is clear, that the rounding function gl is computationally feasible. So lets begin with the predicate prec.\nProposition 3.1. The computationally feasible formula\n(\ntrue if e \u2264\nprec((x\u0302, e), p) :=\nfalse else\n\n10\u2212p\n1+10\u2212p |x\u0302|\n\n(12)\n\nfulfills the above described semantics.\nProof. Let (x\u0302, e) be a finite precision representation of x. So, if e \u2264 10\u2212p |x| holds, then also |x\u0302 \u2212 x| \u2264\n10\u2212p |x| holds. If (x\u0302 \u2212 e)(x\u0302 + e) \u2265 0, then |x\u0302| \u2212 e \u2264 |x| holds. Hence, if (x\u0302 \u2212 e)(x\u0302 + e) \u2265 0 and e \u2264\n10\u2212p\n10\u2212p (|x\u0302| \u2212 e) holds, then also |x\u0302 \u2212 x| \u2264 10\u2212p |x|. Finally, if e \u2264 1+10\n\u2212p |x\u0302| holds, then also (x\u0302 \u2212 e)(x\u0302 + e) \u2265\n0.\nFormula 12 only uses the accessible floating point values x\u0302 and e, basic arithmetics and finite tests.\nHence, this formula is computationally feasible.\nNote that the definition of the predicate this way also gives true in the singular case where x\u0302 = 0 and\ne = 0 and hence x = 0.\nAn algorithm for computing f\u02c6 is by assumption possible. To derive an algorithm for computing er f\non the absolute error, return to Equations 1 and 9.\n\n\fComputational Complexity of Iterated Maps on the Interval\n\n146\n\nProposition 3.2. Assume that f\u02c6(x\u0302) computes f (x\u0302) up to a correctly rounded last bit in mantissa according to rounding convention. Then there exists a constant K > 0 such that the absolute error of f (x) of\nthe computation [ f ]([x]) is bounded from above by\nL(x\u0302, e) * e +\n\nK2\u2212m \u02c6\n| f (x\u0302)|\n1 \u2212 K2\u2212m\n\n(13)\n\nif K2\u2212m < 1. Here, L(x\u0302, e) := sup(| f \u2032 ([x\u0302 \u2212 e, x\u0302 + e])|) and m is the mantissa length of x\u0302: x\u0302.m.\nFurthermore, this bound is computable.\nProof. Using Equation 1 and following the calculations leading to equation 9, | f\u02c6(x\u0302) \u2212 f (x)| \u2264 L(x\u0302, e) *\ne + | f\u02c6(x\u0302) \u2212 f (x\u0302)| follows. According to the assumption on f\u02c6, | f\u02c6(x\u0302) \u2212 f (x\u0302)| \u2264 K2\u2212m | f (x\u0302)| holds, with\na value K \u2208 {1, 2} depending on the rounding convention. However, f (x\u0302) is unknown, only f\u02c6(x\u0302) is\naccessible. To overcome this, set f\u02c6(x\u0302) \u2212 f (x\u0302) = \u03b4 f (x\u0302) with |\u03b4 | \u2264 K2\u2212m . Since |\u03b4 | < 1 holds, resolve to\nf (x\u0302) = 1+1 \u03b4 f\u02c6(x\u0302). Hence,\n| f\u02c6(x\u0302) \u2212 f (x\u0302)| =\n\n\u03b4\nK2\u2212m \u02c6\n* | f\u02c6(x\u0302)| \u2264\n| f (x\u0302)|\n1+\u03b4\n1 \u2212 K2\u2212m\n\nfollows. Since an upper bound on L(x\u0302, e) can be computed using global optimization techniques, e.g.\nwith interval arithmetic, the above described bound is computable.\nTo summarize, the mathematical iteration (11) is performed in the algorithm by iterating a value x\u0302n\napproximating xn with an upper bound on its absolute error en according to\nx\u0302n+1 = f\u02c6(x\u0302n )\nen+1 = L(x\u0302n , en )en +\n\nx\u03020 = gl(x0 , m)\nK2\u2212m\n1 \u2212 K2\u2212m\n\n|x\u0302n+1 |\n\ne0 =\n\nK2\u2212m\n1 \u2212 K2\u2212m\n\n(14)\n|x\u03020 |\n\n(15)\n\nwhere L(x\u0302n , en ) is computable upper bound on L(x\u0302n , en ) as described in the preceding proposition. This\nis Line 9 in the inner for-loop of the algorithm which is executed with successively increasing mantissa length m, controlled by the outer do-while-loop. Finally, it has to be shown that this outer loop\neventually terminates. Therefore, two more propositions are needed.\nProposition 3.3. Let x 6= 0 be a real number and ([x]m )m\u2265m0 a sequence of finite precision representations of x with increasing mantissa length ([x]m ). f l.m \u2265 m such that limm\u2192\u221e ([x]m ).err = 0 holds and\nconsequently limm\u2192\u221e ([x]m ). f l = x. Then limm\u2192\u221e prec([x]m , p) = true follows for all p \u2208 Z.\nProof. Since x 6= 0 there exists some M \u2208 N such that 0 < 12 |x| \u2264 |([x]m ). f l| and ([x]m ).err \u2264\nholds for all m \u2265 M. Then, prec([x]m , p) = true holds for all m \u2265 M.\n\n10\u2212p\n2(1+10\u2212p ) |x|\n\nThe next proposition makes the link to Line 9 in the algorithm.\nProposition 3.4. Let xn be the n-th element of the orbit of Equation 11 and ([xn ]m )m\u2265m0 a sequence given\naccording to the recursion equations (14) and (15) with increasing mantissa length ([xn ]m ). f l.m \u2265 m.\nThen limm\u2192\u221e ([xn ]m ).err = 0 holds and consequently limm\u2192\u221e ([xn ]m ). f l = xn .\nProof. Let L := sup( f \u2032 (D)) and L \u2265 L be some computationally accessible value using some global\nK2\u2212m\noptimization technique. Then Equation 15 leads to en+1 \u2264 Len + 1\u2212K2\n\u2212m M where M \u2265 sup{|x| : x \u2208 D}\nn\n\n\u2212m\n\nk\n\nn\u22121\nK2\nsuch that |x\u0302n | \u2264 M holds for all n. Iteration gives en \u2264 L e0 + 1\u2212K2\n\u2212m M \u2211k=0 L \u2264\nHence, for n fixed, limm\u2192\u221e ([xn ]m ).err = 0 follows.\n\nk\nn\nK2\u2212m\n1\u2212K2\u2212m M \u2211k=0 L .\n\n\fChristoph Spandl\n\n147\n\nThese two propositions finish the correctness proof of the algorithm. They show that, if xn 6= 0 for\nn = 0, . . . , N, the outer loop eventually terminates for any p \u2208 Z.\n\n3.3 Computational Complexity\nAfter having presented the preliminary work, the main issue of the paper is addressed - the computational\ncomplexity of the presented algorithm. The complexity measure of interest here is the loss of significance\nrate already introduced informally in the last section. Here is the formal definition.\nDefinition 3.1. The minimal mantissa length, for which the described algorithm eventually halts is denoted by mmin (x0 , N, p), where x0 , N and p are the corresponding input parameters. Then, the loss of\nsignificance rate \u03c3 : R\u0302 \u2229 D \u00d7 Z \u2192 R is defined by\n\n\u03c3 (x, p) := lim sup\nN\u2192\u221e\n\nmmin (x, N, p)\n.\nN\n\n(16)\n\nHowever, to achieve bounds on the loss of significance rate, a technical difficulty has to be circumvented. Therefore, one more assumption on the dynamical system (D, f ), additional to the ones already\nmentioned in the beginning of this section, has to be made.\nAssumption 3.1. The dynamical system (D, f ) is assumed to have the properties already mentioned in\nthe beginning of this section and additionally 0 6\u2208 D.\nIt was already seen in the last subsection that xn = 0 makes difficulties such that it cannot be proven\nthat the algorithm eventually halts. However, the restriction 0 6\u2208 D is no loss of generality. If all other\nconditions are fulfilled except that D contains zero, consider the following dynamical system (D\u0303, f \u0303)\ninstead. Choose some M > min(D) and set D\u0303 := {x + M | x \u2208 D} as well as f \u0303(x) := f (x \u2212 M) + M for\nall x \u2208 D\u0303. Then (D\u0303, f \u0303) fulfills all required properties. Furthermore f \u0303\u2032 (x) = f \u2032 (x \u2212 M) holds and therefore\nthere is no substantial difference in the complexity analysis of the algorithm between the original system\nand the modified system.\nFirst, the boundedness of \u03c3 (x) is shown.\nProposition 3.5. Let (D, f ) be as in Assumption 3.1 and mmin (x0 , N, p) as in Definition 3.1. Then, for\ngiven p \u2208 Z, there exist some C1 ,C2 \u2265 0, dependent of f , such that mmin (x0 , N, p) \u2264 C1 N +C2 holds for\nall N \u2208 N, x \u2208 R\u0302 \u2229 D.\nProof. According to the requirements made on (D, f ), there are some constants L > 0 and M > 0 such\nK2\u2212m\nthat en+1 \u2264 Len + 1\u2212K2\n\u2212m M holds for all n \u2208 N and all mantissa lengths m. Without loss of generality\nassume L 6= 1, otherwise set L > 1. Analogous to the treatment in the proof of Proposition 3.4, iteration\nK2\u2212m\nN\nK2\u2212m\nLN+1 \u22121\nn\ngives eN \u2264 1\u2212K2\n\u2212m M \u2211n=0 L = 1\u2212K2\u2212m M L\u22121 . Since there exists some B > 0 with B \u2264 |x\u0302n | for all\nn, eN /|x\u0302N | \u2264 eN /B \u2264 C2\u2212m LN+1 follows with C := MK/(B(1 \u2212 K2\u2212m0 )(L \u2212 1)) where m0 is the initial\n10\u2212p\nmantissa length, Line 2 in the algorithm. Then, if C2\u2212m LN+1 \u2264 1+10\n\u2212p holds, prec((x\u0302n , en ), p) = true\nfor all n = 0, . . . , N. This leads to mmin (x0 , N, p) \u2264\nmax(0, ld(L))N + max(m0 , ld(L) + ld(C) + p * ld(10) + ld(1 + 10\u2212p )).\nCorollary 3.1. Let (D, f ) be as in Assumption 3.1 and \u03c3 (x, p) the loss of significance rate. Then, for\ngiven p \u2208 Z, there exists some constant C \u2265 0 such that \u03c3 (x, p) \u2264 C holds for all x \u2208 R\u0302 \u2229 D.\nThe treatment has now come to a stage that the main statements of this paper can be formulated.\nA lower and an upper bound for the loss of significance rate is given. Furthermore, these bounds are\nstrongly related to the Ljapunow exponent \u03bb (x) defined in the previous section.\n\n\fComputational Complexity of Iterated Maps on the Interval\n\n148\n\nTheorem 3.1. Let (D, f ) be as in Assumption 3.1, \u03c3 (x, p) the loss of significance rate and \u03bb (x) the\nLjapunow exponent of (D, f ). Then \u03c3 (x, p) \u2265 \u03bb (x)/ln(2) holds for all x \u2208 R\u0302 \u2229 D, p \u2208 Z if \u03bb (x) exists.\nProof. First there are two constants B, M > 0 such that |x\u0302n | \u2265 B and |x\u0302n | \u2264 M holds for all n. According\nN\u22121 \u2032\nBK2\u2212m\nto Equation 15 and Proposition 3.2, en+1 \u2265 | f \u2032 (xn )|en holds. Iteration gives eN \u2265 1\u2212K2\n\u2212m \u220fn=0 | f (xn )|.\nN\u22121 \u2032\nBK2\u2212m\nHence, |x\u0302eNN | \u2265 M(1\u2212K2\n\u2212m ) \u220fn=0 | f (xn )| follows. A necessary condition for the algorithm to terminate is\n\u2212p\n\nN\u22121\n\u2212m N\u22121 | f \u2032 (x )| \u2264 10\n\u2032\ntherefore BK\n\u220fn=0\nn\nM 2\n1+10\u2212p which gives mmin (x0 , N, p) \u2265 \u2211n=0 ld(| f (xk )|) + p * ld(10) +\nBK\nld( M ) + ld(1 + 10\u2212p ). Following the definitions of the loss of significance rate and the Ljapunow exponent, \u03c3 (x0 , p) \u2265 \u03bb (x0 )/ ln(2) follows.\n\nBefore a realistic upper bound on the loss of significance rate can be presented, one more definition\nis needed.\nDefinition 3.2. Let \u03b1 > 0 then define a function \u03b7\u03b1 : (0, \u221e) \u2192 R by\n(\nln(x) if x \u2265 \u03b1\n\u03b7\u03b1 (x) :=\n.\nln(\u03b1 ) if x < \u03b1\nFurthermore, for any \u03b1 > 0 define\n\n\u03bb \u03b1 (x) := lim sup\nn\u2192\u221e\n\n1 n\u22121\n\u2211 \u03b7\u03b1 (| f \u2032 ( f k (x))|)\nn k=0\n\nProposition 3.6. For all \u03b1 > 0 there exists some constant C \u2265 0 such that \u03bb \u03b1 (x) \u2264 C holds for all x \u2208 D.\nFurthermore, if the Ljapunow exponent \u03bb (x) exists, \u03bb (x) \u2264 \u03bb \u03b1 (x) holds.\n\u2032 k\nProof. Let L be the Lipschitz constant of f and \u03b1 > 0. Then for all n \u2208 N, n1 \u2211n\u22121\nk=0 \u03b7\u03b1 (| f ( f (x))|) \u2264\n1 n\u22121\n\u2032\nk\nln(max(\u03b1 , L)) holds. Hence it follows lim supn\u2192\u221e n \u2211k=0 \u03b7\u03b1 (| f ( f (x))|) \u2264 ln(max(\u03b1 , L)). The second\nassertion follows from the fact that ln(x) \u2264 \u03b7\u03b1 (x) holds for all x > 0, \u03b1 > 0.\n\nProposition 3.7. Let x \u2208 D be given. If \u03bb (x) exists, then also the limit\nlim \u03bb \u03b1 (x) =: \u03bb (x)\n\n\u03b1 \u05810\n\n(17)\n\nexists and \u03bb (x) \u2265 \u03bb (x).\nProof. Since ln(x) \u2264 \u03b7\u03b1 (x) \u2264 \u03b7\u03b2 (x) holds for all x > 0, 0 < \u03b1 \u2264 \u03b2 , also \u03bb (x) \u2264 \u03bb \u03b1 (x) \u2264 \u03bb \u03b2 (x) follows.\nSo if \u03b1 converges in a monotonic decreasing way to 0, \u03b1 \u0581 0, the assertion follows.\nTheorem 3.2. Let (D, f ) be as in Assumption 3.1, \u03c3 (x, p) the loss of significance rate and \u03bb (x) as\nin (17). Let x \u2208 R\u0302 \u2229 D be given, then for any \u03b5 > 0 there is some p0 \u2208 Z such that for all p \u2265 p0 ,\n\u03c3 (x, p) \u2264 \u03bb (x)/ln(2) + \u03b5 holds if \u03bb (x) exists.\nThe proof is similar to the proof of Theorem 3.1 and can be found in the full version of this article\n[18].\n\n\fChristoph Spandl\n\n4\n\n149\n\nConclusions\n\nIn this paper, two main issues are addressed. First it is shown that a mathematically precise treatment\nof multiple-precision floating point computability is not hard to do. Furthermore this treatment is in a\nmanner which is familiar to people working in the field of numerical analysis or scientific computing and\nalso for theoretical computer scientists. Furthermore, the formalism does not only allow exact answers\nconcerning the existence of a computationally feasible algorithm, but is also allows a treatment of its\ncomplexity. As a consequence, the described algorithm is formulated not only in an exact and guaranteed\nway, but also enables a motivated reader the real implementation and gives a practical performance\nanalysis.\nSecond, the results show that the Ljapunow exponent, a central quantity in dynamical systems theory,\nalso finds its way into complexity theory, a branch in theoretical computer science. In dynamical systems\ntheory, the Ljapunow exponent describes the rate of divergence of initially infinitesimal nearby points.\nFor two points having a small but finite initial separation, the Ljapunow exponent has only relevance for\nshort time scales [6]. The reason is that due to the boundedness of D, any two different orbits cannot\nseparate arbitrarily far away. However, the loss of significance rate shows that the Ljapunow exponent\nhas on long time scales not only an asymptotic significance but also a concrete practical one.\n\nAcknowledgments\nThe author wishes to express his gratitude to Peter Hertling for helpful discussions and comments.\n\nReferences\n[1] G\u00f6tz Alefeld & J\u00fcrgen Herzberger (1983): Introduction to Interval Computations. Academic Press, New\nYork.\n[2] Jens Blanck (2005): Efficient exact computation of iterated maps. The Journal of Logic and Algebraic\nProgramming 64, pp. 41\u201359.\n[3] Jens Blanck (2006): Exacr real arithmetic using centred intervals and bounded error terms. The Journal of\nLogic and Algebraic Programming 66, pp. 50\u201367.\n[4] Vasco Brattka & Peter Hertling (1998): Feasible real random access machines. Journal of Complexity 14(4),\npp. 490\u2013526.\n[5] Pierre Collet & Jean-Pierre Eckmann (1980): Iterated Maps on the Interval as Dynamical Systems. Progress\nin Physics. Birkh\u00e4user, Boston, Massachusetts.\n[6] Pierre Collet & Jean-Pierre Eckmann (2006): Concepts and Results in Chaotic Dynamics. Theoretical and\nMathematical Physics. Springer-Verlag, Berlin, Heidelberg.\n[7] Robert L. Devaney (1989): An Introduction to Chaotic Dynamical Systems. Addison-Wesley, Redwood City,\nCalifornia, 2nd edition.\n[8] Laurent Fousse, Guillaume Hanrot, Vincent Lef\u00e8vre, Patrick P\u00e9lissier & Paul Zimmermann (2007): MPFR:\nA Multiple-Precision Binary Floating-Point Library with Correct Rounding. ACM Transactions on Mathematical Software 33(2), pp. 13:1\u201313:15. Available at http://doi.acm.org/10.1145/1236463.1236468.\n[9] Morris W. Hirsch, Stephen Smale & Robert L. Devaney (2004): Differential Equations, Dynamical Systems\nand an Introduction to Chaos. Elsevier Academic Press, Amsterdam.\n[10] IEEE 1987 (1987): IEEE Standard 754-1985 for Binary Floating-Point Arithmetic. IEEE, New York.\n[11] Anatole Katok & Boris Hasselblatt (1995): Introduction to the Modern Theory of Dynamical Systems. Cambridge University Press, Cambridge New York Melbourne.\n\n\f150\n\nComputational Complexity of Iterated Maps on the Interval\n\n[12] Norbert Th. M\u00fcller (2001): The iRRAM: Exact Arithmetic in C++. In: Jens Blanck, Vasco Brattka & Peter\nHertling, editors: Computability and Complexity in Analysis, Lecture Notes in Computer Science 2064,\nSpringer, Berlin, pp. 222\u2013252. 4th International Workshop, CCA 2000, Swansea, UK, September 2000.\n[13] Norbert\nTh.\nM\u00fcller:\nPrivate\ncommunication.\nSee\nalso\nhttp://www.cc.kyoto-su.ac.jp/~yasugi/page/Kakenhi/mueller.pdf.\n\nthe\n\ntutorial\n\nat\n\n[14] Helmut Ratschek & Jon Rokne (1984): Computer Methods for the Range of Functions. Ellis Horwood\nLimited, Chichester.\n[15] N. Revol & F. Rouillier (2005): Motivations for an Arbitrary Precision Interval Arithmetic and the MPFI\nLibrary. Reliable Computing 11(4), pp. 275\u2013290.\n[16] Klaus Weihrauch (2000): Computable Analysis. Springer-Verlag, Berlin Heidelberg New York.\n[17] James H. Wilkinson (1963): Rounding Errors in Algebraic Processes. Prentice-Hall, Englewood Cliffs, N.J.\n[18] Available at http://arxiv.org/abs/1003.6036.\n\n\f"}