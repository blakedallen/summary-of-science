{"id": "http://arxiv.org/abs/0801.4040v2", "guidislink": true, "updated": "2016-03-04T23:57:26Z", "updated_parsed": [2016, 3, 4, 23, 57, 26, 4, 64, 0], "published": "2008-01-25T22:31:41Z", "published_parsed": [2008, 1, 25, 22, 31, 41, 4, 25, 0], "title": "Carry Propagation in Multiplication by Constants", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0801.4571%2C0801.0545%2C0801.0759%2C0801.0045%2C0801.1143%2C0801.4078%2C0801.1297%2C0801.4617%2C0801.3714%2C0801.0349%2C0801.2411%2C0801.0913%2C0801.2524%2C0801.0272%2C0801.2290%2C0801.0542%2C0801.1532%2C0801.2421%2C0801.0579%2C0801.4881%2C0801.1428%2C0801.0389%2C0801.1433%2C0801.2553%2C0801.3902%2C0801.1602%2C0801.1036%2C0801.2885%2C0801.2416%2C0801.4265%2C0801.4638%2C0801.3276%2C0801.3972%2C0801.1597%2C0801.3253%2C0801.2937%2C0801.3326%2C0801.4339%2C0801.1537%2C0801.3050%2C0801.1848%2C0801.3575%2C0801.0825%2C0801.2641%2C0801.4610%2C0801.1718%2C0801.2690%2C0801.3499%2C0801.4827%2C0801.2126%2C0801.4599%2C0801.4649%2C0801.3979%2C0801.4525%2C0801.3927%2C0801.1140%2C0801.4364%2C0801.1818%2C0801.2907%2C0801.2314%2C0801.3206%2C0801.1929%2C0801.3145%2C0801.0990%2C0801.1374%2C0801.2967%2C0801.4544%2C0801.1476%2C0801.4542%2C0801.3523%2C0801.3704%2C0801.2646%2C0801.2464%2C0801.2219%2C0801.4299%2C0801.2509%2C0801.4691%2C0801.2458%2C0801.1139%2C0801.4654%2C0801.4861%2C0801.4040%2C0801.0877%2C0801.4606%2C0801.1423%2C0801.2350%2C0801.0864%2C0801.2282%2C0801.2004%2C0801.3773%2C0801.4735%2C0801.0439%2C0801.2707%2C0801.1873%2C0801.3811%2C0801.3250%2C0801.2998%2C0801.2499%2C0801.0446%2C0801.4014%2C0801.1790&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Carry Propagation in Multiplication by Constants"}, "summary": "Suppose that a random n-bit number V is multiplied by an odd constant M,\ngreater than or equal to 3, by adding shifted versions of the number V\ncorresponding to the 1s in the binary representation of the constant M. Suppose\nfurther that the additions are performed by carry-save adders until the number\nof summands is reduced to two, at which time the final addition is performed by\na carry-propagate adder. We show that in this situation the distribution of the\nlength of the longest carry-propagation chain in the final addition is the same\n(up to terms tending to 0 as n tends to infinity) as when two independent n-bit\nnumbers are added, and in particular the mean and variance are the same (again\nup to terms tending to 0). This result applies to all possible orders of\nperforming the carry-save additions.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0801.4571%2C0801.0545%2C0801.0759%2C0801.0045%2C0801.1143%2C0801.4078%2C0801.1297%2C0801.4617%2C0801.3714%2C0801.0349%2C0801.2411%2C0801.0913%2C0801.2524%2C0801.0272%2C0801.2290%2C0801.0542%2C0801.1532%2C0801.2421%2C0801.0579%2C0801.4881%2C0801.1428%2C0801.0389%2C0801.1433%2C0801.2553%2C0801.3902%2C0801.1602%2C0801.1036%2C0801.2885%2C0801.2416%2C0801.4265%2C0801.4638%2C0801.3276%2C0801.3972%2C0801.1597%2C0801.3253%2C0801.2937%2C0801.3326%2C0801.4339%2C0801.1537%2C0801.3050%2C0801.1848%2C0801.3575%2C0801.0825%2C0801.2641%2C0801.4610%2C0801.1718%2C0801.2690%2C0801.3499%2C0801.4827%2C0801.2126%2C0801.4599%2C0801.4649%2C0801.3979%2C0801.4525%2C0801.3927%2C0801.1140%2C0801.4364%2C0801.1818%2C0801.2907%2C0801.2314%2C0801.3206%2C0801.1929%2C0801.3145%2C0801.0990%2C0801.1374%2C0801.2967%2C0801.4544%2C0801.1476%2C0801.4542%2C0801.3523%2C0801.3704%2C0801.2646%2C0801.2464%2C0801.2219%2C0801.4299%2C0801.2509%2C0801.4691%2C0801.2458%2C0801.1139%2C0801.4654%2C0801.4861%2C0801.4040%2C0801.0877%2C0801.4606%2C0801.1423%2C0801.2350%2C0801.0864%2C0801.2282%2C0801.2004%2C0801.3773%2C0801.4735%2C0801.0439%2C0801.2707%2C0801.1873%2C0801.3811%2C0801.3250%2C0801.2998%2C0801.2499%2C0801.0446%2C0801.4014%2C0801.1790&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Suppose that a random n-bit number V is multiplied by an odd constant M,\ngreater than or equal to 3, by adding shifted versions of the number V\ncorresponding to the 1s in the binary representation of the constant M. Suppose\nfurther that the additions are performed by carry-save adders until the number\nof summands is reduced to two, at which time the final addition is performed by\na carry-propagate adder. We show that in this situation the distribution of the\nlength of the longest carry-propagation chain in the final addition is the same\n(up to terms tending to 0 as n tends to infinity) as when two independent n-bit\nnumbers are added, and in particular the mean and variance are the same (again\nup to terms tending to 0). This result applies to all possible orders of\nperforming the carry-save additions."}, "authors": ["Alice Izsak", "Nicholas Pippenger"], "author_detail": {"name": "Nicholas Pippenger"}, "author": "Nicholas Pippenger", "links": [{"href": "http://arxiv.org/abs/0801.4040v2", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0801.4040v2", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "math.PR", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "math.PR", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "68W40, 68W10", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0801.4040v2", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/0801.4040v2", "arxiv_comment": null, "journal_reference": "ACM Transactions on Algorithms (TALG) 7.4 (2011): 54", "doi": null, "fulltext": "izsak.tex\n\narXiv:0801.4040v2 [math.PR] 4 Mar 2016\n\nCarry Propagation in Multiplication by Constants\n\nAlice Izsak\naizsak@gmail.com\nDepartment of Computer Science\nUniversity of British Columbia\n2366 Main Mall\nVancouver, BC V6T 1Z4\nCANADA\n\nNicholas Pippenger\nnjp@math.hmc.edu\nDepartment of Mathematics\nHarvey Mudd College\n1250 Dartmouth Avenue\nClaremont, CA 91711\n\nAbstract: Suppose that a random n-bit number V is multiplied by an odd constant M \u2265 3, by adding\nshifted versions of the number V corresponding to the 1s in the binary representation of the constant M .\nSuppose further that the additions are performed by carry-save adders until the number of summands is\nreduced to two, at which time the final addition is performed by a carry-propagate adder. We show that\nin this situation the distribution of the length of the longest carry-propagation chain in the final addition is\nthe same (up to terms tending to 0 as n \u2192 \u221e) as when two independent n-bit numbers are added, and in\nparticular the mean and variance are the same (again up to terms tending to 0). This result applies to all\npossible orders of performing the carry-save additions. It also applies if the constant multiplier is recoded to\nreduce the number of operations by allowing subtractions as well as additions, corresponding to occurrences\nof a \"negative unit\" 1 = \u22121 in a representation of M .\n\n\f1. Introduction\nLet X and Y be random n-bit integers that are independent and uniformly distributed in [0, 2n \u2212 1].\nIf they are added in the usual way, starting at their rightmost end and proceeding to the left, their may be\nvarious \"carry-propagation chains\". A carry-propagation chain is a sequence of k \u2265 1 consecutive positions\nin the binary representations of X and Y in which the rightmost position generates a carry (because both\nX and Y contain 1s in these positions), and the remaining k \u2212 1 positions to the left propagate this carry\n(because one, but not the other, of X and Y contains a 1 in each of these positions). Let the random variable\nCn denote the length of the longest carry-propagation chain. (Note that the longest carry-propagation chain\nis not necessarily the longest sequence of consecutive carries: the addition of the binary numbers 0101 and\n1111 gives rise to two carry-propagation chains, each of length two, not to one of length four.) The length\nof the longest carry-propagation chain is of interest because it governs the execution of certain parallel\nimplementations of addition (see Claus [C] and Knuth [K]).\nThe distribution of Cn has been investigated since the early days of electronic computing. The investigation was begun in the famous report of Burks, Goldstein and von Neumann [B] in 1946, where it was shown\nthat Ex(Cn ) \u2264 log2 n + 1. The next step was taken by Claus [C], who showed that Ex(Cn ) \u2265 log2 n \u2212 2.\nKnuth [K] showed that\nk+1\n\nPr(Cn \u2265 k) = 1 \u2212 e\u2212n/2\n\n+O\n\n\u0012\n\n(log n)3\nn\n\n\u0013\n\n(1.1)\n\n(where the constant in the O-term is independent of k as well as n), and that this implies\n3\nEx(Cn ) = log2 n + \u03b3 log2 e \u2212 \u2212 \u03a6(log2 n) + O\n2\n\n\u0012\n\n(log n)4\nn\n\n\u0013\n\n,\n\n(1.2)\n\nwhere \u03b3 = 0, 5772 . . . is Euler's constant, e = 2.718 . . . is the base of natural logarithms, and \u03a6(\u03bd) is a periodic\nR1\nfunction of \u03bd with period 1 and average 0 (that is, 0 \u03a6(\u03bd) d\u03bd = 0) satisfying |\u03a6(\u03bd)| \u2264 1.573 . . . \u00d7 10\u22126 for\nall \u03bd \u2208 [0, 1). Pippenger [P] gave an elementary derivation of (1.1), and showed that it also implies\nVar(Cn ) =\n\n\u03c02\n1\n(log2 e)2 +\n+ \u03c9 + \u03a8(\u03bd) + O\n6\n12\n\n\u0012\n\n(log n)5\nn\n\n\u0013\n\n,\n\n(1.3)\n\nwhere \u03c0 = 3.14159 . . . is the circular ratio, \u03c9 = 1.2374 . . . \u00d7 10\u221212 is a constant, and \u03a8(\u03bd) is a periodic\nfunction of \u03bd with period 1 and average 0 satisfying |\u03a8(\u03bd)| \u2264 5.3573 . . . \u00d7 10\u22126 for all \u03bd \u2208 [0, 1).\nIn Section 2 we shall present a new analysis of the addition problem that yields results similar to those\nabove, but with weaker error bounds. Specifically, we shall show that\n\u0012\n\nlog n\nn1/3\n\n\u0013\n\n.\n\n3\n\u2212 \u03a6(log2 n) + O\n2\n\n\u0012\n\n(log n)2\nn1/3\n\nk+1\n\nPr(Cn \u2265 k) = 1 \u2212 e\u2212n/2\n\n+O\n\nThis implies\nEx(Cn ) = log2 n + \u03b3 log2 e \u2212\nand\n\n1\n\u03c02\n(log2 e)2 +\n+ \u03c9 + \u03a8(\u03bd) + O\nVar(Cn ) =\n6\n12\n\n\u0012\n\n(log n)3\nn1/3\n\n(1.4)\n\n\u0013\n\n\u0013\n\n(1.5)\n\n(1.6)\n\nin the same way that (1.1) implies (1.2) and (1.3). The weaker error bounds are a result of our choice\nto present our new argument in its simplest form; these bounds could be improved by elaboration of the\n1\n\n\fargument (but, as Knuth [K] points out, so could those of (1.1\u20133)). Our motivation, however, for presenting\nthis new analysis is that it can be extended to obtain the results claimed in the abstract, which we shall now\ndescribe in more detail.\nWe shall investigate the length of the longest carry propagation chain that occurs when a random n-bit\ninteger V , uniformly distributed in [0, 2n \u2212 1], is multiplied by a fixed constant M . The simplest case of our\nproblem is M = 3. In this case, the product Z = M * V is obtained by adding V to the number 2V that\nis obtained by shifting V one position to the left. The two random numbers being added in this case are\nnot independent, but Izsak [I] has shown that the length of the longest carry-propagation chain nevertheless\nsatisfies the estimate (1.1). More generally, we may consider the case M = 2d + 1 (where d \u2265 1), for which\nthe product Z = M * V is obtained by adding V to the number 2d V that is obtained by shifting V to the\nleft d positions. Izsak [I] has shown that again the estimate (1.1) applies (where now the constant in the\nO-term may depend on d, but not on k or n).\nWe shall consider a further generalization in which M has two or more 1s in its binary representation.\nP\nSuppose that the binary representation of M is M = 0\u2264j\u2264d mj 2j (with mj \u2208 {0, 1}) and that c (where\n2 \u2264 c \u2264 d + 1) of the digits m0 , m1 , . . . , md are 1s (so that the remaining d + 1 \u2212 c are 0s). We may assume\nwithout loss of generality that md = 1 (since otherwise we could reduce the value of d) and that m0 = 1\n(since the carries that occur when multiplying by 2M will just be shifted versions of those that occur when\nP\nmultiplying by M ). Let s1 = 0 < s2 < * * * < sc = d be the positions of the 1-bits, so M = 1\u2264i\u2264c 2si . For\n1 \u2264 i \u2264 c, let Wi = 2si V be obtained by shifting V to the left si positions. The product Z = M * V will be\nP\nobtained by adding these c numbers: Z = 1\u2264i\u2264c Wi .\nWhen c = 3, we can form the sum Z = W1 + W2 + W3 in two stages as follows. The first stage will\n\nperform a \"carry-save addition\", which takes the three numbers W1 , W2 and W3 and inputs and produces\nas outputs two numbers X and Y having the same sum: X + Y = W1 + W2 + W3 . There are of course\nmany pairs of numbers X and Y that satisfy this condition. The details of carry-save addition, including the\nspecification of the numbers X and Y that will be produced, will be given later. For now we merely observe\nthat in carry-save addition, all carries propagate one position to the left, and in a parallel implementation,\nall carries propagate simultaneously, so that a carry-save addition contributes a fixed delay to the parallel\nexecution time. Thus our analysis will not deal with carries in this stage. The second stage will perform a\nconventional \"carry-propagate addition\" to obtain the final product Z as the sum of X and Y . This addition\nis analogous to those considered in previous paragraphs, and it is the carry-propagation chains in this stage\nthat will be the focus of our analysis. We will obtain the estimate (1.4).\nWhen c \u2265 4, we can use c\u22122 carry-save additions to reduce the c numbers W1 , W2 , . . . Wc to two numbers\nX and Y in the first stage, then add these two numbers with a carry-propagate addition in the second stage\nto obtain Z as before. In this case, however, there is an additional complication: there is more than one way\nto use c \u2212 2 carry-save additions to reduce c numbers to two numbers. At one extreme, one can sum W1 ,\nW2 and W3 with the first cary-save addition, then proceed similarly with the resulting (c \u2212 3) + 2 = c \u2212 1\nnumbers, and so forth. The numbers X and Y are thus obtained after c\u22122 carry-save additions, each (except\nfor the first)of which depends for at least one of its inputs on the its predecessor, so that these carry-save\nadditions contribute c \u2212 2 fixed delays to the parallel execution time. At the other extreme, one can use\n\u230ac/3\u230b carry-save additions in parallel to combine 3 \u230ac/3\u230b numbers, producing 2 \u230ac/3\u230b numbers having the\nsame sum, then proceed similarly with the resulting (c \u2212 3 \u230ac/3\u230b) + 2 \u230ac/3\u230b = c \u2212 \u230ac/3\u230b numbers, and so forth.\nAs Wallace [W] has observed, these c \u2212 2 carry-save additions contribute only log3/2 c + O(1) fixed delays to\n2\n\n\fthe parallel execution time. Our result, which is that the estimate (1.4) again holds for the carry-propagate\naddition in the second stage, applies equally to all of the ways of performing the carry-save addition in the\nfirst stage.\nFinally, we shall consider a further generalization in which the number of carry-save additions is reduced\nby using subtractions as well as additions. For example, if M = 7, we can represent M in \"extended binary\"\nas 1001 rather than 111, where the \"negative unit\" 1 = \u22121 means that the corresponding power of 2 should\nbe subtracted rather than added. The product Z = 7V can then be computed by immediately performing a\ncarry-propagate addition of 8V and \u2212V , rather than by first performing a carry-save addition to combine 4V ,\n2V and V , and then performing a carry-propagate addition on the results. (As this example shows, it may\nbe necessary to increase d by one when using an extended binary representation. But this merely increases\nthe largest shift length, which does not affect the parallel execution time. The goal is to reduce the number\nc of summands, which can affect the parallel execution time.) In general, we will want to find the extended\nP\ni\nbinary representation of M (that is, M =\n0\u2264i\u2264d mi 2 with mi \u2208 {\u22121, 0, 1}, md = 1 and m0 = \u00b11)\n\nthat minimizes the the number of non-zero digits mi = \u00b11. One representation that accomplishes this\nminimization is the \"canonical\" representation, described by Lehman [L1, L2], Tocher [T] and Reitwiesner\n[R]. But non-canonical representations may tie the canonical one in achieving the minimum (for example,\nthe conventional 11 ties the canonical 101 in representing 3), so there may again be more than one optimal\nrepresentation. Our result, the estimate (1.4), again holds for all extended representations, optimal and\nnon-optimal.\nAll of our results reinforce one point: the randomness in one uniformly distributed number V is sufficient\nto produce the distribution (1.4); the full power of the independence of X and Y in forming their sum is not\n\nneeded. In Section 3, we shall give a specification at the bit level of the algorithms that were specified above\nat the level of operations on numbers, and describe the features, common to all these algorithms, that will\nbe used in the subsequent analysis. In Section 4, we shall give the proof of (1.4) based, on these common\nfeatures.\n\n2. A New Analysis of Addition\nIn this section, we shall prove (1.4) for the addition of two independent random numbers. The analyses\nof Knuth [K] and Pippenger [P] of (1.1) proceed by deriving a recurrence for the probability that the\naddition of two random n-bit numbers yields a carry propagation chain of length at least k, then solving\nthis recurrence for the asymptotic behavior of this probability. Our new analysis is based on the observation\nk+1\nthat the main term 1 \u2212 e\u2212n/2\nin (1.1) and (1.4) is the probability that a Poisson-distributed random\nvariable with mean n/2k+1 has value at least one. There are approximately n (actually n \u2212 k + 1) places\nat which a carry-propagation chain of length k can occur, and the probability that such a chain occurs at a\ngiven place is 1/2k+1 . If all these possible occurrences were independent, we could derive the desired result\nfrom the Poisson approximation to binomial distribution. They are not independent, but the effects of their\ndependence can be analyzed far enough to yield the estimate (1.4). (This analysis is an application of the\n\"Poisson paradigm\" described by Alon and Spencer [A].)\nA set of k consecutive bit positions will be called a k-block. There are n \u2212 k + 1 distinct k-blocks. A\nk-block will be said to be active if its rightmost position generates a carry and each of the remaining k \u2212 1\npositions propagates a carry. The event \"Cn \u2265 k\" is clearly equivalent to the event \"there is at least one\nactive k-block\", which we shall denote En,k . To estimate Pr[En,k ], we shall use the following principles.\n3\n\n\f(A-1) The probability that a given k-block is active is 1/2k+1 .\n(A-2) If a set of k-blocks includes two that overlap, then they cannot all be active. If no two overlap,\nthen they are independent.\nWe shall show that (1.4) follows from these two principles. Let\nk1 = \u23082 log2 n\u2309.\nFor k > k1 , we have Pr[En,k ] \u2264 (n \u2212 k + 1)/2k+1 = O(1/n) by (A-1) and Markov's inequality. We also have\nk+1\n\n1 \u2212 en/2\n\n= O(1/n) by the power series ex = 1 + O(x), valid for x \u2192 0. Thus we have (1.4) for k > k1 .\n\nFor k \u2264 k1 , we shall estimate Pr[En,k ] using inclusion-exclusion, using (A-1) and (A-2). We have\nPr[En,k ] =\n\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\u22121\n\n2(k+1)j\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\n=1\u2212\n,\nj\n2(k+1)j\nj\u22650\nj\n\nj\u22651\n\nsince there are just\n\nn\u2212j(k\u22121)\nj\n\n\u0001\n\nways to choose j non-overlapping k-blocks in the n bit-positions. Let\n\u0016\n\u0012\nk0 = log2\n\nso that\n\n(2.1)\n\n3n\n2 log n \u2212 6 log log n\n\n\u0013\u0017\n\n,\n\n2\nn\n1\nlog n \u2212 log log n \u2264 k0 +1 \u2264 log n \u2212 2 log log n,\n3\n2\n3\n\u0012\n\u0013\nk0 +1\nlog\nn\ne\u2212n/2\n=O\nn1/3\n\nand\nk0 +1\n\nen/2\n\n=O\n\n\u0012\n\nn2/3\n(log n)2\n\n\u0013\n\n.\n\nWe shall begin by assuming k \u2265 k0 (as well as k \u2264 k1 ). Let\n\u0006\n\u0007\nj0 = (2e2 /3) log n .\nWe shall break the sum in (2.1) at j0 :\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nPr[En,k ] = 1 \u2212\n\u2212\n.\nj\nj\n2(k+1)j j>j\n2(k+1)j\n0\u2264j\u2264j0\n\n(2.2)\n\n0\n\nWe bound the magnitude of the second sum in (2.2) by using\n\nn\u2212j(k\u22121)\nj\n\n\u0001\n\n\u2264\n\nn\nj\n\n\u0001\n\n\u2264 (en/j)j , which yields\n\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nX \u0012 en \u0013j\n\u2264\nj\nj2k+1\n2(k+1)j\nj>j\nj>j\n0\n\n0\n\nX \u0012 1 \u0013j\ne\nj>j0\n\u0012\n\u0013\n1\n=O\n.\nn2e2 /3\n\u2264\n\n4\n\n(2.3)\n\n\fFor the first sum in (2.2), we estimate the binomial coefficient by\n\u0001\u0001\nj\n(n /j!) 1 + O (log n)3 /n :\n\nn\u2212j(k\u22121)\nj\n\n\u0001\n\n\u0001j\n= (nj /j!) 1 + O(jk/n) =\n\n\u0013\u0013\n\u0012\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nX 1 \u0012 \u2212n \u0013j \u0012\n(log n)3\n.\n=\n1+O\nj\nj! 2(k+1)\nn\n2(k+1)j\n\n0\u2264j\u2264j0\n\n0\u2264j\u2264j0\n\nThe presence of the O-term in the summand prevents us from exploiting cancellation, so to obtain an error\nbound for the sum we consider the magnitudes of the summands:\n\uf8f6\n\uf8eb\n\uf8f6\n\uf8eb\n\u0010 n \u0011j\n3 X\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nX 1 \u0012 \u2212n \u0013j\n1\n(log\nn)\n\uf8f8+O\uf8ed\n\uf8f8\n=\uf8ed\n(k+1)j\nj! 2(k+1)\nn\nj! 2(k+1)\nj\n2\n0\u2264j\u2264j0\n0\u2264j\u2264j0\n0\u2264j\u2264j0\n\uf8eb\n\uf8f6\n\u0012\n\u0013\n\u0013\n\u0012\nj\nX 1\n\u2212n\n(log n)3 n/2k+1\n\uf8ed\n\uf8f8\ne\n=\n+O\nj! 2(k+1)\nn\n0\u2264j\u2264j0\n\uf8f6\n\uf8eb\n\u0013\n\u0012\nX 1 \u0012 \u2212n \u0013j\nlog n\n\uf8f8\n\uf8ed\n.\n+O\n=\nj! 2(k+1)\nn1/3\n0\u2264j\u2264j\n0\n\nExtending the sum from j \u2264 j0 to j < \u221e yields\n\uf8f6\n\uf8eb\n\u0013\n\u0012\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\nX 1 \u0012 \u2212n \u0013j\nk+1\n\uf8f8 + O log n .\n\uf8ede\u2212n/2\n=\n\u2212\nj\nj! 2(k+1)\n2(k+1)j\nn1/3\nj>j\n0\u2264j\u2264j\n0\n\n0\n\nWe bound the magnitude of this sum just as we did that of the second sum in (2.2), to obtain\n\u0012\n\u0013\n\u0012\n\u0013\nX \u0012n \u2212 j(k \u2212 1)\u0013 (\u22121)j\n1\nlog n\n\u2212n/2k+1\n=\ne\n+\nO\n+\nO\nj\n2(k+1)j\nn2e2 /3\nn1/3\n0\u2264j\u2264j0\n\u0013\n\u0012\nlog n\n\u2212n/2k+1\n.\n=e\n+O\nn1/3\n\n(2.4)\n\nSubstituting (2.3) and (2.4) in (2.2), we obtain (1.4) for k0 \u2264 k \u2264 k1 .\nFinally, we consider k < k0 . We use the fact that Pr[En,k ] is a non-increasing function of k, so that\n1 \u2265 Pr[En,k ] \u2265 Pr[En,k0 ] = 1 \u2212 e\n\n\u2212n/2k0 +1\n\n+O\n\n\u0012\n\nlog n\nn1/3\n\n\u0013\n\n=1+O\n\n\u0012\n\nlog n\nn1/3\n\n\u0013\n\n.\n\nThis yields (1.4) for the remaining values of k.\n\n3. The Algorithm for Multiplication\nIn this section we shall describe in more detail the algorithm presented in the Introduction. It will be\nmost convenient to describe these algorithms in the language of hardware, implemented as circuits built from\ngates interconnected by wires, but this is of course equivalent to a description in the language of software\nfor a parallel computer, such as that used by Claus [C] and Knuth [K].\nP\n\nTo begin, let us assume that M is given its unique conventional binary representation M =\nj\n0\u2264j\u2264d mj 2 , in which all digits m0 = 1, m1 , . . . , md = 1 are either 0 or 1. As before, let s1 = 0 <\n\ns2 < * * * < sc = d denote the positions of the 1s. Our first step will be to specify the encodings of the\n5\n\n\fnumbers W1 , W2 , . . . , Wc as sequences of bits. The input V =\n\nP\n\n0\u2264l\u2264n\u22121 vl 2\nn\n\nl\n\nwill be received using n bits\n\nv0 , v1 , . . . , vn\u22121 as usual. Since V is an n-bit number (in the range [0, 2 \u2212 1]) and M is a (d + 1)-bit\nnumber (in the range [0, 2d+1 \u2212 1]), their product Z = M * V is an (n + d + 1)-bit number (in the range\n\u0002\n\u0003\n0, (2n \u2212 1)(2d+1 \u2212 1) \u2286 [0, 2n+d+1 \u2212 1]). Thus it will suffice to represent all numbers produced during the\nexecution of the algorithms (the output Z and all intermediate results) using n + d + 1 bits, and to perform\nall additions (both carry-save and carry-propagate) modulo 2n+d+1 . Thus we shall represent each Wi (for\nP\n1 \u2264 i \u2264 c) by the n + d + 1 bits in its conventional binary representation: Wi = 0\u2264l\u2264n+d wi,l 2l . Since\nWi = 2si V , we have wi,l = vl\u2212si if si \u2264 l \u2264 n \u2212 1 + si , and wi,l = 0 if 0 \u2264 l \u2264 si \u2212 1 or n + si \u2264 l \u2264 n + d.\n\nIn the first stage of the algorithm, we reduce the c summands W1 , W2 , . . . , Wc to two summand X and\nY by means of carry-save adders. Each carry-save adder consists of n + d + 1 \"full adders\", one for each\nposition in the numbers being added. A full adder is a pair of gates that takes three input signals (say f , g\nand h) and produces two output signals. The sum output is the parity (that is, the sum f \u2295 g \u2295 h modulo\n2) of the three inputs. The carry output is the majority ((f \u2227 g) \u2228 (f \u2227 h) \u2228 (g \u2227 h)) of the three inputs.\nThe parity and majority are symmetric functions of the three inputs, so when specifying what signals should\nbe fed into a full adder, we do not need to specify which signal goes into which input. The n + d + 1 full\nP\nP\nadders in a carry-save adder reduce three summands (say F = 0\u2264l\u2264n+d fl 2l , G = 0\u2264l\u2264n+d gl 2l and\nP\nP\nP\nH = 0\u2264l\u2264n+d hl 2l ) to two summands (say A = 0\u2264l\u2264n+d al 2l and B = 0\u2264l\u2264n+d bl 2l ) as follows. The\n\nsignals fl , gl and hl are fed into the inputs of the full adder in position l (for 0 \u2264 l \u2264 n+ d). The sum outputs\n\nof the full adders become the bits of the summand A: al = parity(fl , gl , hl ) for 0 \u2264 l \u2264 n + d. Finally, the\ncarry outputs of the full adders become, after being shifted left one position, the bits of the summand B:\nbl l + 1 = majority(fl , gl , hl ) for 0 \u2264 l \u2264 n + d \u2212 1 (the carry output from the full adder in the leftmost\nposition is ignored) and b0 = 0 (a 0 bit is shifted into the rightmost position of B).\nAfter the c summands W1 , W2 , . . . , Wc have been reduced to two summands X and Y by c\u22122 full adders\nin the first stage, the summands X any Y are added by a carry-propagate adder in the second stage. Like\na carry-save adder, a carry-propagate adder can be built from n + d + 1 full adders, one for each position in\nthe numbers being added. Two of the inputs of the full adder in position l (for 0 \u2264 l \u2264 n + d) are provided\nP\nP\nby the appropriate bits xl and yl of the numbers X = 0\u2264l\u2264n+d xl 2l and Y = 0\u2264l\u2264n+d yl 2l . But in this\ncase the third input of the full adder in position l is fed from the carry output of the full adder in position\nl \u2212 1 for 1 \u2264 l \u2264 n + d, and is fed the constant 0 for l = 0 (the carry output from the full adder in position\nn + d is ignored). The n + d + 1 bits of the final product Z are then produced at the sum outputs of the full\nadders.\nThis description of a carry-propagate adder gives an adequate picture of the production of the outputs,\nbut it is not convenient for the analysis of the longest carry propagation chain, for which we must distinguish\nbetween between the generation of carries and their propagation, rather than merely their production. To\nmake the generation and propagation of carries more explicit, we will replace the full adders in the second\nstage by \"half adders\". A half adder is obtained from a full adder by substituting the constant 0 for one\nof its three inputs. The resulting device consists of a pair of gates, one of which computes the sum output\nas the parity (that is, the \"exclusive-OR\") of the two remaining inputs, and the other of which computes\nthe carry output as the conjunction (that is, the \"AND\") of the inputs. If we replace each full adder in the\nsecond stage with a half adder, then the carry output of each half adder will indicate whether a carry is\ngenerated at that position (that is, whether both xl and yl are 1s for that value of l), and the sum output\n\n6\n\n\fwill indicate whether a carry would be propagated by that position (that is, whether exactly one of xl and\nyl is a 1).\nWe conclude this section with a discussion of how to adapt the algorithm presented above for a recoded\nmultiplier, in which some of the digits mj (0 \u2264 j \u2264 d \u2212 1) may be 1 = \u22121. (We note that since M is positive,\nwe must have md = 1.) We could do this by changing the adder that incorporates the contribution Wj into\na subtracter, but this might require analysis of subtraction, rather than addition, in the second stage (if\nm0 = 1). It will be more convenient to preserve the structure of the adders in both stages, and to alter the\ndefinition of the Wj (0 \u2264 j \u2264 d) to be a positive integers whose sum is congruent to M * V modulo 2n+d . To\ndo this, we make the following changes for each j (0 \u2264 j \u2264 d \u2212 1) such that mj = 1:\n(a) Change the leftmost d \u2212 sj bits wj,n+d\u22121 , . . . , wj,n+sj of Wj from 0s to 1s.\n(b) Change the n bits wj,n+sj \u22121 , . . . , wj,sj of Wj from vn\u22121 , . . . , v0 to their complements \u00acvn\u22121 , . . . , \u00acv0 .\n(c) Change the bit wj+1,sj of Wj+1,sj from 0 to 1.\nThese changes result in a contribution congruent to mj 2sj V modulo 2n+d , since changes (a) and (b) form\n2sj times the 1s complement of V , and change (c) converts the 1s complement to the 2's complement.\n\n4. The Analysis of Multiplication\nWe begin by deriving the principles, analogous to (A-1) and (A-2), that will allow us to analyze multiplication. A k-block is a sequence of contiguous bit positions among the n + d positions of numbers modulo\n2n+d . Thus there are just n + d \u2212 k \u2212 1 distinct k-blocks, with the rightmost position of the rightmost k-block\nbeing position 0, and the leftmost position of the leftmost k-block being position n + d \u2212 k. We shall say\nthat a k-block is active if, in the final addition in the second stage, its rightmost position generates a carry\nand its remaining k \u2212 1 positions propagate a carry. Whether or not a k-block is active depends on the input\nbits not only in its k positions, but also in up to d positions to its right. These d or fewer positions will be\ncalled the extension of the k-block, and the k-block together with its extension will be called an \u2040extended\nk-block. (The d rightmost k-blocks will have fewer than d positions in their extensions, since there are fewer\nthan d positions to their right.)\nThe inputs to the final addition are computed by circuits composed of three-input parity and majority\ngates, one-input inverters, and zero-input constant gates. Furthermore, constant gates occur only in the\ncircuits computing the rightmost d and leftmost d positions (positions 0 through d \u2212 1 and positions n\nthrough n + d \u2212 1). A k-block will be called marginal if it r its extension overlap the rightmost or leftmost\nd positions. Thus there are 3d marginal k-blocks. A k-block will be called central if it is not marginal.\n(M-1) The probability that a central k-block is active is 1/2k+1 .\nSuppose the rightmost position of the k-block is position l (2d \u2264 l \u2264 n \u2212 d \u2212 k). For the rightmost\nposition to generate a carry, the values of both xl and yl must be 1. The value of yl depends on the inputs\nvl\u22121 , . . . , vl\u2212d , and it is computed from them by a circuit composed of three-input parity and majority\ngates and one-input inverters. These gates compute self-dual Boolean functions: if the arguments of a\nself-dual function are complemented, then the value of the function is also complemented. The class of\nself-dual functions is closed under composition, so yl is a self-dual function of the inputs vl\u22121 , . . . , vl\u2212d . If\nthe arguments of a self-dual function are independent unbiassed bits, then the value of the function is also\n7\n\n\fan unbiassed bit. Thus the probability that yl = 1 is 1/2. The value of xl depends on the input vl as well\nas the d inputs to its right, and we have\nxl = vl \u2295 \u03c6(vl\u22121 , . . . , vl\u2212d ),\nwhere \u03c6 is some d-adic Boolean function. Since vl is an unbiassed bit independent of vl\u22121 , . . . , vl\u2212d , xl is an\nunbiassed bit independent of yl . Thus the probability that position l generates a carry is 1/4.\nFor each of the remaining k\u22121 positions of the k-block to propagate a carry, we must have xl+1 \u2295yl+j = 1\nfor 1 \u2264 j \u2264 k \u2212 1. As between xl+1 and yl+j = 1, only xl+1 depends on vl+j and, as above, we have\nxl+j = vl+j \u2295 \u03c6(vl+j\u22121 , . . . , vl+j\u2212d ).\nThus each xj is an unbiassed bit independent of the bits to its right, so the probability of each of the\nremaining k \u2212 1 bits propagating a carry is 1/2k\u22121 , and the probability that a central k-block is active is\n(1/4)(1/2k\u22121 ) = 1/2k+1 .\n(M-2) The probability that a marginal k-block is active is at most 2d /2k .\nThe analysis of (M-1) applies to the k \u2212 d or more positions of the k-block that do not overlap the\nrightmost 2d or leftmost d positions.\nWe shall say that two k-blocks are strongly non-overlapping if they, together with their extensions, are\nnon-overlapping, and that they are weakly overlapping if they are non-overlapping, but one overlaps the\nextension of the other.\n(M-3) If two k-blocks are overlapping, they cannot both be active.\nThis holds because at each position, generating a carry and propagating a carry are exclusive events.\n(M-4) If a k-block B lies to the right of, and is strongly non-overlapping, a k-block A then the event that\nB is active is independent of the event that A is active.\nThis holds because the activities of strongly non-overlapping k-blocks depend on disjoint sets of inputs.\n(M-5) If a k-block B overlaps the extension of a k-block A, but does not overlap A itself, then the\nprobability that B is active, given that A is active, is at most 2d /2k+1 .\nThe analysis of (M-1) applies to the k \u2212 d or more rightmost positions of B that do not overlap A or\nits extension.\nWe shall show that (1.4) follows from these five principles. As before, we let\nk1 = \u23082 log2 n\u2309.\nThen (1.4) follows for k > k1 , since from (M-1), (M-2) and Markov's inequality, Pr(En,k ) is O(1/n), as is\nk+1\n\n1 \u2212 e\u2212n/2\n\n.\n\nFor k \u2264 k1 , we again let\n\n\u0016\n\u0012\nk0 = log2\n\n3n\n2 log n \u2212 6 log log n\n8\n\n\u0013\u0017\n\n,\n\n\fand begin by assuming that k \u2265 k0 (as well as k \u2264 k1 ). Using (M-2) and Markov's inequality, the probability\nthat any marginal k-block is active is at most 3d2d /2k = O(log n/n). Thus we may ignore marginal k-blocks,\n\u2032\nand turn our attention to estimating the probability of the event En,k\nthat some central k-block is active.\nFor this, we shall again use inclusion-exclusion:\n\u2032\nPr(En,k\n)=\n\nX\n\nX\n\n(\u22121)j\u22121 Pr(B1 , . . . , Bj all active ),\n\n(4.1)\n\nj\u22651 B1 ,...,Bj\n\nwhere the sum is over all lists (B1 , . . . , Bj ) of j central k-blocks, with Bi+1 to the right of Bi for 1 \u2264 i \u2264 j \u22121.\nBy (M-3), we may also assume that B1 , . . . , Bj are pairwise non-overlapping.\nWe shall partition the contributions to the double sum in (4.1) into two parts,\n\u2032\n) = \u03a3i + \u03a3ii ,\nPr(En,k\n\nwhere Sii denotes the sum of the contributions from lists B1 , . . . , Bj that are pairwise strongly nonoverlapping, and \u03a3ii denotes the sum of the contributions from lists B1 , . . . , Bj for which at least one pair\nBi , Bi+1 of successive k-blocks is weakly overlapping. The contributions to \u03a3i will be completely analogous\nto those in the analysis of addition. For the contributions to \u03a3ii , we shall need to analyze the effects of weak\noverlaps, but in this case it will suffice to consider only the magnitudes of the contributions, without making\nany attempt to exploit cancellations.\nFor \u03a3i , the only difference from the analysis of addition is that now the extended k-blocks each have\nlength k + d, and the number of positions into which j of them must fit is now n \u2212 2d. Thus the binomial\ncoefficient that counts the number of ways that j strongly non-overlapping central k-blocks can be chosen is\n\u0001\n(n\u22122d)\u2212j(k+d\u22121)\n. Since this quantity still satisfies the estimates\nj\n\u0012\n\u0012\n\u0013\u0013\n\u0012\n\u0013\n(log n)3\nnj\n(n \u2212 2d) \u2212 j(k + d \u2212 1)\n1+O\n=\nj!\nn\nj\nfor j \u2264 j0 , where again\n\u0006\n\u0007\nj0 = (2e2 /3) log n ,\n\nand\n\u0012\n\n\u0013\n\u0012 \u0013j\nnj\n(n \u2212 2d) \u2212 j(k + d \u2212 1)\nen\n\u2264\n\u2264\nj\nj!\nj\n\nfor all j, we can use (M-1) in the analysis of Section 2 to show that\n\u0013\n\u0012\nlog n\n\u2212n/2k+1\n.\n\u03a3i = 1 \u2212 e\n+O\nn1/3\nTurning to \u03a3ii , we abandon any attempt to exploit cancellation among the terms, and merely sum\nbounds on their magnitudes. We have\nX X \u0012j \u2212 1\u0013\n|\u03a3ii | \u2264\nl\nl\u22651 j\u2265l+1\n\nX\n\n1\u2264f1 ,...,fl \u2264d\n\n\u0013j\u2212l \u0012 d \u0013l\n\u0012\n\u0013\u0012\n2\n(n \u2212 2d) \u2212 (j \u2212 l)(k + d \u2212 1) + g\n1\n,\n2k+1\n2k+1\nj\u2212l\n\nwhere g = f1 +* * *+fl . Here l denotes he number of values of i (1 \u2264 i \u2264 j \u22121) such that Bi+1 overlaps the ex\u0001\ntension of Bi , the binomial coefficient j\u22121\ncounts the number of ways in which these values of i may be chol\n\u0001\nsen, the parameters f1 , . . . , fl denote the amounts of overlap, the binomial coefficient (n\u22122d)\u2212(j\u2212l)(k+d\u22121)+g\nj\u2212l\n9\n\n\fcounts the number of ways in which the j \u2212 l k-blocks or weakly overlapping sequences of k-blocks may be\nchosen, the factor (1/2k+1 )j\u2212l denotes the probability, following (M-1) and (M-4), that the j \u2212 l k-blocks\nthat do not overlap the extension of a k-block to their left are all active, and the factor (2d /2k+1 )l bounds\nthe probability, following (M-5), that the remaining l k-blocks are all active. Since the innermost sum has\n\u0001\nn\nat most dl terms, each with g \u2264 ld, the innermost binomial coefficient is at most j\u2212l\n\u2264 nj\u2212l /(j \u2212 l)! and\n\nwe obtain\n\n|\u03a3ii | \u2264\n\n\u0010 n \u0011j\u2212l\nX \u0012 d2d \u0013l X \u0012j \u2212 1\u0013 1\nk+1\n2\n(j \u2212 l)! 2k+1\nl\nl\u22651\n\n=\n\nj\u2265l+1\n\nX\u0012\nl\u22651\n\n\u0013l X \u0012\n\u0013\nm + l \u2212 1 1 \u0010 n \u0011m\nd2d\n,\n2k+1\nm! 2k+1\nl\nm\u22651\n\nwhere we have made the substitution m = j \u2212 l. We shall show below that\nX \u0012m + l \u2212 1\u0013 xm\n\u2264 (4x)l ex\nl\nm!\n\n(4.2)\n\nm\u22651\n\nk+1\n\nfor x \u2265 1 and l \u2265 1. Since n/2k+1 \u2265 (1/3) log n \u2212 log log n \u2265 1 and en/2\nsufficiently large n and k \u2265 k0 , we obtain\n\n\u0001\n= O n2/3 /(log n)2 for all\n\nX \u0012 d2d \u0013l \u0012 4n \u0013l\nk+1\nen/2\n|\u03a3ii | \u2264\n2k+1\n2k+1\nl\u22651\n\u0012\n\u0013\n1\n=O\n.\nn1/3\nIt remains to prove (4.2). We have\nX \u0012m + l \u2212 1\u0013 xm\nx dl X xm+l\u22121\n=\nm!\nl! dxl\nm!\nl\nm\u22651\n\nm\u22651\n\nx dl l\u22121 X xm\n=\nx\nl! dxl\nm!\nm\u22651\n\nl\n\nx d\nxl\u22121 (ex \u2212 1)\nl! dxl\n\u0013 \u0012 l\u2212s\n\u0013\n\u0012 \u0013\u0012 s\nx X l\nd\nd\nl\u22121\nx\n=\nx\n(e \u2212 1)\nl!\ndxs\ndxl\u2212s\ns\n0\u2264s\u2264l\n\u0012 \u0013\u0012\n\u0013\nl\nl\u22121\nx X\ns! xl\u22121\u2212s ex .\n=\nl!\ns\ns\n=\n\n0\u2264s\u2264l\u22121\n\nSince x \u2265 1, we have xl\u22121\u2212s \u2264 xl\u22121 . Using the further inequalities s! \u2264 l! and\nX \u0012 l \u0013\u0012l \u2212 1\u0013\nX \u0012 l \u0013\u0012 l \u0013\n\u2264\ns\ns\ns s\n0\u2264s\u2264l\u22121\n0\u2264s\u2264l\n\u0012 \u0013\n2l\n=\nl\n\u2264 4l ,\nwe obtain (4.2). This competes the proof of (1.4) for k0 \u2264 k \u2264 k1 .\n10\n\n\f\u2032\nFinally, we must consider k < k0 . Again as in the analysis of addition, the fact that Pr[En,k\n] is a\n\nnon-increasing function of k, together with the bound (1.4) for k = k0 yields (1.4) for the remaining values\nof k.\n\n5. Conclusion\nIn this paper we have shown that the distribution of the length of the longest carry propagation chain\ncan be analyzed using what Alon and Spencer [A] have called the \"Poisson paradigm\". We have also show\nthat this method of analysis can be used to show that a particular algorithm for multiplication of a random\ninteger by a fixed constant has, to within terms tending to zero as n \u2192 \u221e, the same distribution for the\nlength of the longest carry chain in the final addition. This algorithm is characterized by shifting over zeros\nin the multiplier, and by the use of a carry-save adder to incorporate the contributions for all but the last\ntwo non-zero digits of the multiplier. We should point out that our analysis does not appear to be applicable\nto either of two natural variants of this algorithm: one in which zeros are not shifted over, but cause a\ncontribution of zero to be added using a carry-save adder (for in this case we cannot appeal to self-duality in\nthe computation of the final summands), and one in which a carry-propagate adder is used for all additions\n(in which case it does not matter whether or not zeros are shifted over, for in this case the outputs of each\nadder depend on an unbounded number of input bits to their right). It remains an open question whether\nthe result of this paper applies to either or both of these variants. An apparently even more challenging\nproblem is to determine whether or not the result of this paper applies to the algorithm considered here\nwhen the multiplier is not a fixed integer, but is rather a random integer with the same distribution as, but\nindependent of, the multiplicand.\n\n6. Acknowledgment\nThe research reported here was supported in part by NSF Grant CCF 0430656.\n\n7. References\n[A] N. Alon and J. H. Spencer, The Probabilistic Method, (Second Ed.) John Wiley & Sons, 2000.\n[B] A. W. Burks, H. H. Goldstein and J. von Neumann, \"Preliminary Discussion of the Logical Design of\nan Electronic Computing Instrument\", in: A. H. Taub (Ed.), Collected Works of John von Neumann,\nMacmillan, 1963, v. 5, pp. 34\u201379.\n[C] V. Claus, \"Die mittlere Additionsdauer eines Paralleladdierwerks\", Acta Informatica, 2 (1973) 283\u2013291.\n[I] A. Izsak, Special Cases of Carry Propagation, B. S. Thesis, Department of Mathematics, Harvey Mudd\nCollege, 2007.\n[K] D. E. Knuth, \"The Average Time for Carry Propagation\", Nederl. Akad. Wettensch. Indag. Math., 40\n(1978) 238\u2013242 (reprinted in D. E. Knuth, Selected Papers on Analysis of Algorithms, Center for the\nStudy of Language and Information, Stanford University, 2000).\n[L1] M. Lehman, \"High-Speed Digital Multiplication\", IRE Trans. Electronic Computers, 6 (1957) 204\u2013205.\n[L2] M. Lehman, \"Short-Cut Multiplication and Division in Automatic Binary Digital Computers\", Proc.\nIEE, 105 B (1958) 496\u2013504.\n\n11\n\n\f[P] N. Pippenger, \"Analysis of Carry Propagation in Addition: An Elementary Approach\", J. Algorithms,\n42 (2002) 317\u2013333.\n[R] G. W. Reitwiesner, \"Binary Arithmetic\", Advances in Computers, 1 (1960) 232\u2013308.\n[T] K. D. Tocher, \"Techniques of Multiplication and Division for Automatic Binary Computers\", Quart. J.\nMech. Appl. Math., 11 (1958) 364\u2013384.\n[W] C. S. Wallace, \"A Suggestion for a Fast Multiplier\", IEEE Trans. Computers, 13:2 (1964) 14\u201317.\n\n12\n\n\f"}