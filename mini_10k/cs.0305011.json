{"id": "http://arxiv.org/abs/cs/0305011v1", "guidislink": true, "updated": "2003-05-15T10:46:00Z", "updated_parsed": [2003, 5, 15, 10, 46, 0, 3, 135, 0], "published": "2003-05-15T10:46:00Z", "published_parsed": [2003, 5, 15, 10, 46, 0, 3, 135, 0], "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary\n  Affine Logic", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0506002%2Ccs%2F0506017%2Ccs%2F0506036%2Ccs%2F0506032%2Ccs%2F0506054%2Ccs%2F0506018%2Ccs%2F0506059%2Ccs%2F0506013%2Ccs%2F0506035%2Ccs%2F0506007%2Ccs%2F0506022%2Ccs%2F0506100%2Ccs%2F0506027%2Ccs%2F0506038%2Ccs%2F0506037%2Ccs%2F0506103%2Ccs%2F0506039%2Ccs%2F0506062%2Ccs%2F0506065%2Ccs%2F0506006%2Ccs%2F0506021%2Ccs%2F0506019%2Ccs%2F0506051%2Ccs%2F0506001%2Ccs%2F0506044%2Ccs%2F0506020%2Ccs%2F0506034%2Ccs%2F0506076%2Ccs%2F0506011%2Ccs%2F0506008%2Ccs%2F0506053%2Ccs%2F0506033%2Ccs%2F0305041%2Ccs%2F0305049%2Ccs%2F0305023%2Ccs%2F0305060%2Ccs%2F0305014%2Ccs%2F0305040%2Ccs%2F0305002%2Ccs%2F0305044%2Ccs%2F0305004%2Ccs%2F0305012%2Ccs%2F0305033%2Ccs%2F0305024%2Ccs%2F0305021%2Ccs%2F0305054%2Ccs%2F0305055%2Ccs%2F0305027%2Ccs%2F0305048%2Ccs%2F0305047%2Ccs%2F0305052%2Ccs%2F0305022%2Ccs%2F0305007%2Ccs%2F0305059%2Ccs%2F0305010%2Ccs%2F0305030%2Ccs%2F0305063%2Ccs%2F0305026%2Ccs%2F0305051%2Ccs%2F0305061%2Ccs%2F0305062%2Ccs%2F0305005%2Ccs%2F0305058%2Ccs%2F0305008%2Ccs%2F0305001%2Ccs%2F0305006%2Ccs%2F0305009%2Ccs%2F0305016%2Ccs%2F0305056%2Ccs%2F0305018%2Ccs%2F0305029%2Ccs%2F0305028%2Ccs%2F0305019%2Ccs%2F0305037%2Ccs%2F0305032%2Ccs%2F0305053%2Ccs%2F0305017%2Ccs%2F0305035%2Ccs%2F0305045%2Ccs%2F0305036%2Ccs%2F0305050%2Ccs%2F0305064%2Ccs%2F0305034%2Ccs%2F0305057%2Ccs%2F0305066%2Ccs%2F0305046%2Ccs%2F0305020%2Ccs%2F0305065%2Ccs%2F0305042%2Ccs%2F0305038%2Ccs%2F0305011%2Ccs%2F0305003%2Ccs%2F0305039%2Ccs%2F0305031%2Ccs%2F0305013%2Ccs%2F0305015%2Ccs%2F0305025%2Ccs%2F0207066%2Ccs%2F0207070%2Ccs%2F0207087%2Ccs%2F0207020&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary\n  Affine Logic"}, "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=cs%2F0506002%2Ccs%2F0506017%2Ccs%2F0506036%2Ccs%2F0506032%2Ccs%2F0506054%2Ccs%2F0506018%2Ccs%2F0506059%2Ccs%2F0506013%2Ccs%2F0506035%2Ccs%2F0506007%2Ccs%2F0506022%2Ccs%2F0506100%2Ccs%2F0506027%2Ccs%2F0506038%2Ccs%2F0506037%2Ccs%2F0506103%2Ccs%2F0506039%2Ccs%2F0506062%2Ccs%2F0506065%2Ccs%2F0506006%2Ccs%2F0506021%2Ccs%2F0506019%2Ccs%2F0506051%2Ccs%2F0506001%2Ccs%2F0506044%2Ccs%2F0506020%2Ccs%2F0506034%2Ccs%2F0506076%2Ccs%2F0506011%2Ccs%2F0506008%2Ccs%2F0506053%2Ccs%2F0506033%2Ccs%2F0305041%2Ccs%2F0305049%2Ccs%2F0305023%2Ccs%2F0305060%2Ccs%2F0305014%2Ccs%2F0305040%2Ccs%2F0305002%2Ccs%2F0305044%2Ccs%2F0305004%2Ccs%2F0305012%2Ccs%2F0305033%2Ccs%2F0305024%2Ccs%2F0305021%2Ccs%2F0305054%2Ccs%2F0305055%2Ccs%2F0305027%2Ccs%2F0305048%2Ccs%2F0305047%2Ccs%2F0305052%2Ccs%2F0305022%2Ccs%2F0305007%2Ccs%2F0305059%2Ccs%2F0305010%2Ccs%2F0305030%2Ccs%2F0305063%2Ccs%2F0305026%2Ccs%2F0305051%2Ccs%2F0305061%2Ccs%2F0305062%2Ccs%2F0305005%2Ccs%2F0305058%2Ccs%2F0305008%2Ccs%2F0305001%2Ccs%2F0305006%2Ccs%2F0305009%2Ccs%2F0305016%2Ccs%2F0305056%2Ccs%2F0305018%2Ccs%2F0305029%2Ccs%2F0305028%2Ccs%2F0305019%2Ccs%2F0305037%2Ccs%2F0305032%2Ccs%2F0305053%2Ccs%2F0305017%2Ccs%2F0305035%2Ccs%2F0305045%2Ccs%2F0305036%2Ccs%2F0305050%2Ccs%2F0305064%2Ccs%2F0305034%2Ccs%2F0305057%2Ccs%2F0305066%2Ccs%2F0305046%2Ccs%2F0305020%2Ccs%2F0305065%2Ccs%2F0305042%2Ccs%2F0305038%2Ccs%2F0305011%2Ccs%2F0305003%2Ccs%2F0305039%2Ccs%2F0305031%2Ccs%2F0305013%2Ccs%2F0305015%2Ccs%2F0305025%2Ccs%2F0207066%2Ccs%2F0207070%2Ccs%2F0207087%2Ccs%2F0207020&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."}, "authors": ["Paolo Coppola", "Simone Martini"], "author_detail": {"name": "Simone Martini"}, "author": "Simone Martini", "links": [{"href": "http://arxiv.org/abs/cs/0305011v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/cs/0305011v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.LO", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "F.4.1: D.3", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/cs/0305011v1", "affiliation": "None", "arxiv_url": "http://arxiv.org/abs/cs/0305011v1", "arxiv_comment": null, "journal_reference": "ACM Transactions on Computational Logic, vol 7 (2006) pp. 219 -\n  260.", "doi": null, "fulltext": "arXiv:cs/0305011v1 [cs.LO] 15 May 2003\n\nOptimizing Optimal Reduction:\nA Type Inference Algorithm for Elementary\nAffine Logic\nPaolo Coppola\nUniversit\u00e0 di Udine - Dip. di Matematica e Informatica\nSimone Martini\nUniversit\u00e0 di Bologna - Dip. di Scienze dell'Informazione\nJune 14, 2018\n\nIntroduction\nThe optimal reduction of \u03bb-terms ([L\u00e9v80]; see [AG98] for a comprehensive account and references) is a graph-based technique for normalization in which a\nredex is never duplicated. To achieve this goal, the syntax tree of the term is\ntransformed into a graph, with an explicit node (fan) expressing the sharing\nof two common subterms (these subterms are always variables in the initial\ntranslation of a \u03bb-term). Giving correct reduction rules for these sharing graphs\nis a surprisingly difficult problem, first solved in [Kat90, Lam90]. One of the\nmain issues is to decide how to reduce two meeting fans, for which a complex\nmachinery and new nodes have to be added (the oracle). There is large class\nof (typed) terms, however, for which this decision is very simple, namely those\n\u03bb-terms whose sharing graph is a proof-net of Elementary Logic, both in the\nLinear [Gir98] (ELL) and the Affine [Asp98] (EAL) flavor. This fact was first\nobserved in [Asp98] and then exploited in [ACM00] to obtain a certain complexity result on optimal reduction, where (following [Mai92]) we also showed that\nthese EAL-typed \u03bb-terms are powerful enough to encode arbitrary computations\nof elementary time-bounded Turing machines. We did not know, however, of\nany systematic way to derive EAL-types for \u03bb-terms, a crucial issue if we want\nto exploit in an optimal reducer the added benefits of this class of terms. This\nis what we present in this paper.\nMain contribution of the paper is a type inference algorithm (Section 2),\nassigning EAL-types (formulas) to type-free \u03bb-terms (more precisely: to sharing\ngraphs corresponding to type-free \u03bb-terms). We will see in Section 1 that a\ntyping inference for a \u03bb-term M in EAL consists of a skeleton \u2013 given by the\nassignment of a type to M in the simple type discipline \u2013 together with a box\nassignment , essential because EAL allows contraction only on boxed terms. The\n1\n\n\falgorithm tries to introduce all possible boxes by collecting integer linear constraints during the exploration of the syntax tree of M . At the end, the integer\nsolutions (if any) to the constraints give specific box assignments (i.e., EALderivations) for M . Correctness and completeness of the algorithm are proved\nwith respect to a natural deduction system for EAL, introduced in Section 3.1\ntogether with terms annotating the derivations.\nThe technique used in the paper, with minor modifications, can be used\nto obtain linear logic derivations as decorations of intuitionistic derivations,\nsubsuming some of the results of [DJS95, Sch94]. In this way we may obtain\nlinear derivations with a minimal number of boxes. We tackle this issue in\nSection 4.1.\nA preliminary version of this work has already been published [CM01]. Besides giving more elaborated examples and technical details, several results are\nnew. We prove that all EAL types can be obtained by applying the algorithm on\nthe simple principal type schema; as a corollary, we may state the decidability\nof the type inference problem for EAL. We show how to use our technique to\ndecorate full linear logic proofs. We show how the algorithm could be extended\nto allow arbitrary contractions.\nIn [CR03], the existence of a notion of principal type schema for EAL is\ninvestigated and established. Baillot [Bai02] gives a type-checking algorithm\nfor Light Affine Logic, but it applies only to lambda terms in normal form.\nIn [Bai03] the same author proves the decidability of LAL type inference problem\nfor lambda-calculus following the approach proposed in [CR03].\n\n1\n\nElementary Affine Logic\n\nElementary Affine Logic [Asp98] is a system with unrestricted weakening, where\ncontraction is allowed only for modal formulas. There is only one exponential\nrule for the modality ! (of-course, or bang), which is introduced at once on\nboth sides of the turnstile. The system is presented in Figure 1, where also\n\u03bb-terms are added to the rules. We denote with M {N/x} the usual notion of\nsubstitution of N for the free occurrences of x in M . In the contexts (or bases)\n(\u0393, \u2206, etc.) a variable can occur only once (they are linear ). Observe that,\naccording to most literature on optimal reduction, we always write parenthesis\naround an application and we assume that the scope of a \u03bb is the minimal\nsubterm following the dot; as a consequence, a term like (\u03bbx.M N ) should be\nparsed as ((\u03bbx.M )N ). Cut-elimination may be proved for EAL in a standard\nway.\nGiven the sharing graph of a type-free \u03bb-term, we are interested in finding\na derivation of a type for it, according to Figure 1. (There is a subtle point in\nthis notion, which is relevant for the completeness of our algorithm and which\nwe will discuss at the end of this section. For the time being we may remain\ninformal).\nA simple inspection of the rules of EAL shows that any \u03bb-term with an EAL\ntype has also a simple type. Indeed, the simple type (and the corresponding\n\n2\n\n\fx:A\u22a2x:A\n\n\u0393 \u22a2 N : A x : A, \u2206 \u22a2 M : B\ncut\n\u0393, \u2206 \u22a2 M {N/x} : B\n\nax\n\n\u0393, x1 :!A, x2 :!A \u22a2 M : B\ncontr\n\u0393, z :!A \u22a2 M {z/x1, z/x2 } : B\n\n\u0393\u22a2M :B\nweak\n\u0393, x : A \u22a2 M : B\n\n\u0393 \u22a2 N : A x : B, \u2206 \u22a2 M : C\n\u22b8L\n\u0393, f : A \u22b8 B, \u2206 \u22a2 M {(f N )/x} : C\n\n\u0393, x : A \u22a2 M : B\n\u22b8R\n\u0393 \u22a2 \u03bbx.M : A \u22b8 B\n\nx1 : A1 , . . . , xn : An \u22a2 M : B\n!\nx1 :!A1 , . . . , xn :!An \u22a2 M :!B\n\nFigure 1: (Implicational) Elementary Affine Logic\n\nderivation) is obtained by forgetting the exponentials, which must be present in\nan EAL derivation because of contraction. Therefore, in looking for an EALtype for a \u03bb-term M , we can start from a simple type derivation for M and try\nto decorate this derivation (i.e., add !-rules) to turn it into an EAL-derivation.\nOur algorithm implements this simple idea:\n1. we find all \"maximal decorations\";\n2. these decorations correspond to well formed derivations only if certain\nlinear constraints admit (integral) solutions.\nWe informally present the main point with an example on the term two \u2261\n\u03bbxy.(x(x y)). One simple type derivation for two (expressed as a sequent derivation) is:\nw:\u03b1\u22a2w:\u03b1\n\ny:\u03b1\u22a2y:\u03b1\n\nx:\u03b1\u2192\u03b1,y:\u03b1\u22a2(x y):\u03b1\n\nz:\u03b1\u22a2z:\u03b1\n\nx:\u03b1\u2192\u03b1,x:\u03b1\u2192\u03b1,y:\u03b1\u22a2(x(x y)):\u03b1\nx:\u03b1\u2192\u03b1,x:\u03b1\u2192\u03b1\u22a2\u03bby.(x(x y)):\u03b1\u2192\u03b1\nx:\u03b1\u2192\u03b1\u22a2\u03bby.(x(x y)):\u03b1\u2192\u03b1\n\u22a2\u03bbxy.(x(x y)):(\u03b1\u2192\u03b1)\u2192\u03b1\u2192\u03b1\n\nIf we change every \u2192 in \u22b8, the previous derivation can be viewed as the\nskeleton of an EAL derivation. To obtain a full EAL derivation (if any), we need\nto decorate this skeleton with exponentials, and to check that the contraction\nis performed only on exponential formulas.\nWe first produce a maximal decoration of the skeleton, interleaving n !-rules\nafter each logical rule. For instance\nw:\u03b1\u22a2w:\u03b1\n\ny:\u03b1\u22a2y:\u03b1\n\nx:\u03b1\u22b8\u03b1,y:\u03b1\u22a2(x y):\u03b1\n\n3\n\n\fbecomes\nw:\u03b1\u22a2w:\u03b1\n\ny:\u03b1\u22a2y:\u03b1\n\n!n 1\n\n!n1 w:\u03b1\u22a2!n1 w:\u03b1\n\n!n 2\n\n!n2 y:\u03b1\u22a2!n2 y:\u03b1\n\nx:!n2 \u03b1\u22b8!n1 \u03b1,y:!n2 \u03b1\u22a2(x y):!n1 \u03b1\n\nwhere n1 and n2 are fresh variables. We obtain in this way a meta-derivation\nrepresenting all EAL derivations with n1 , n2 \u2208 IN.\nContinuing to decorate the skeleton of two (i.e., to interleave !-rules) we\nobtain\nw:\u03b1\u22a2w:\u03b1\nw:!n1 \u03b1\u22a2w:!n1 \u03b1\n\n!n 1\n\ny:\u03b1\u22a2y:\u03b1\ny:!n2 \u03b1\u22a2y:!n2 \u03b1\n\n!n 2\n\nx:!n2 \u03b1\u22b8!n1 \u03b1,y:!n2 \u03b1\u22a2(x y):!n1 \u03b1\nx:!\n\nn3\n\n(!n2 \u03b1\u22b8!n1 \u03b1),y:!n2 +n3 \u03b1\u22a2(x y):!n1 +n3 \u03b1\n\nz:\u03b1\u22a2z:\u03b1\n\n!n 3\n\nz:!n4 \u03b1\u22a2z:!n4 \u03b1\n\n!n 4\n\nx:!n1 +n3 \u03b1\u22b8!n4 \u03b1,x:!n3 (!n2 \u03b1\u22b8!n1 \u03b1),y:!n2 +n3 \u03b1\u22a2(x(x y)):!n4 \u03b1\nx:!\n\nn5\n\n(!\n\nn1 +n3\n\n\u03b1\u22b8!n4 \u03b1),x:!n3 +n5 (!n2 \u03b1\u22b8!n1 \u03b1),y:!n2 +n3 +n5 \u03b1\u22a2(x(x y)):!n4 +n5 \u03b1\n\n!n 5\n\nx:!n5 (!n1 +n3 \u03b1\u22b8!n4 \u03b1),x:!n3 +n5 (!n2 \u03b1\u22b8!n1 \u03b1)\u22a2\u03bby.(x(x y)):!n2 +n3 +n5 \u03b1\u22b8!n4 +n5 \u03b1\nx:!n5 +n6 (!n1 +n3 \u03b1\u22b8!n4 \u03b1),x:!n3 +n5 +n6 (!n2 \u03b1\u22b8!n1 \u03b1)\u22a2\u03bby.(x(x y)):!n6 (!n2 +n3 +n5 \u03b1\u22b8!n4 +n5 \u03b1)\n\n!n 6\n\nx:!n5 +n6 (!n1 +n3 \u03b1\u22b8!n4 \u03b1)\u22a2\u03bby.(x(x y)):!n6 (!n2 +n3 +n5 \u03b1\u22b8!n4 +n5 \u03b1)\n\nThe last rule-contraction-is correct in EAL iff the types of x are unifiable\nand banged. In other words iff the following constraints are satisfied:\nn1 ,n2 ,n3 ,n4 ,n5 ,n6 \u2208IN\n\n\u2227\n\nn5 =n3 +n5\n\n\u2227\n\nn1 +n3 =n2\n\n\u2227\n\nn4 =n1\n\n\u2227\n\nn5 +n6 \u22651.\n\nThe second, third and fourth of these constraints come from unification; the\nlast one from the fact that contraction is allowed only on exponential formulas.\nThese constraints are equivalent to\nn1 ,n5 ,n6 \u2208IN\n\n\u2227\n\nn3 =0\n\n\u2227\n\nn1 =n2 =n4\n\n\u2227\n\nn5 +n6 \u22651.\n\nSince clearly these constraints admit solutions, we conclude the decoration procedure obtaining\n..\n.\nx:!n5 +n6 (!n1 \u03b1\u22b8!n1 \u03b1)\u22a2\u03bby.(x(x y)):!n6 (!n1 +n5 \u03b1\u22b8!n1 +n5 \u03b1)\n\u22a2\u03bbxy.(x(x y)):!n5 +n6 (!n1 \u03b1\u22b8!n1 \u03b1)\u22b8!n6 (!n1 +n5 \u03b1\u22b8!n1 +n5 \u03b1)\n\nThus two has EAL types !n5 +n6 (!n1 \u03b1 \u22b8!n1 \u03b1) \u22b8!n6 (!n1 +n5 \u03b1 \u22b8!n1 +n5 \u03b1), for any\nn1 , n5 , n6 solutions of\nn1 ,n5 ,n6 \u2208IN\n\n\u2227\n\nn5 +n6 \u22651.\n\nWhile simple and appealing, the technique of maximal decoration cannot\nbe applied directly. The first problem is that sequent derivations are too constrained. There are many different (simple type) derivations for the same \u03bbterm, depending on the position of (\u22b8 L) rules, contractions, cuts, etc. Given\na \u03bb-term, we should therefore produce all possible derivations, and then decorate them. The problem stems from the fact that sequent derivations are not\n4\n\n\fdriven by the syntax of the term. In fact, the standard simple type inference\nalgorithm does not use a sequent-style presentation, but a natural deduction\none, which is naturally syntax-driven. This is the solution we also follow in this\npaper - we decorate the \u03bb-term. Unfortunately, it is well known (see Prawitz's\nclassical essay [Pra65]) that natural deduction for modal systems behave badly,\nsince the obvious formulation for the modal rule (the one coinciding with rule !\nof the sequent presentation) does not enjoy a substitution lemma. As a result,\nthere are EAL type inferences which cannot be obtained directly as decoration\nof simple type derivations in natural deduction. Consider, for instance, the following simple type derivation (in the obvious natural deduction presentation of\nimplicational logic) for M = \u03bbx y k.(x y) : (A \u2192 B) \u2192 A \u2192 (C \u2192 B):\nx : A \u2192 B \u22a2 x : A \u2192 B y : A, k : C \u22a2 y : A\nx : A \u2192 B, y : A, k : C \u22a2 (x y) : B\nx : A \u2192 B, y : A \u22a2 \u03bbk.(x y) : C \u2192 B\nx : A \u2192 B \u22a2 \u03bby k.(x y) : A \u2192 (C \u2192 B)\n\u22a2 \u03bbx y k.(x y) : (A \u2192 B) \u2192 A \u2192 (C \u2192 B)\nIt is not difficult to see that in the system of Figure 1 there is a derivation\nestablishing \u22a2 M : (A \u22b8!B) \u22b8 A \u22b8!(C \u22b8 B). But no interleaving of ! rules\ninto the derivation above can give this conclusion.\nIndeed, to guarantee a substitution lemma, the modal rule for EAL in natural\ndeduction must be formulated:\n\u22061 \u22a2!A1\n\n. . . \u2206n \u22a2!An A1 , . . . , An \u22a2 B\nbox\n\u22061 , . . . , \u2206n , \u22a2 !B\n\nThis rule, given a derivation of A1 , . . . , An \u22a2 B (i.e., a \u03bb-term M with the\nassignment of the type B from the basis A1 , . . . , An ): (i) \"builds a box\" around\nM ; (ii) allows the substitution of arbitrary terms for the free variables of M .\nOur algorithm will start from a simple type derivation in natural deduction\nfor a term M (i.e., the syntax tree of the term decorated with simple types)\nand will try to insert (all possible) boxes around (suitable) subterms. We will\nsometimes use a graphical representation of this process. As an example, Figure 2 shows the decoration of the syntax tree of two we obtained in Section 1.\nWe are finally in the position to introduce formally the notion of EAL-typing\nfor \u03bb-terms. Recall that our main goal is to mechanically check whether a pure\n\u03bb-term could be optimally reduced without the need of the oracle. While we\nlack a general characterization of this class of terms, we know that it contains\nany sharing graph coding the skeleton of a sequent proof in EAL. We already\nobserved, however, that a single \u03bb-term may correspond to more than one (sequent or natural deduction) proof. The position of the contraction is especially\nrelevant in this context. Indeed, consider the term M = \u03bbz x w.((x z) (x z) w).\nAmong the (infinite) EAL sequent derivations having M as a skeleton consider\n\n5\n\n\f!n5 +n6 (!n1 +n3 \u22b8!n4 ) \u22b8!n6 (!n2 +n3 +n5 \u22b8!n4 +n5 )\n\n\u03bbx\n!n6 (!n2 +n3 +n5 \u22b8!n4 +n5 )\n!n2 +n3 +n5 \u22b8!n4 +n5\n\n\u03bby\n!n4 +n5\n!n 4\n\n@\n!n1 +n3 \u22b8!n4\n\n!n1 +n3\n!n 1\n\n!n2 \u22b8!n1\n!n3 (!n2 \u22b8!n1 )\n\n@\n\n!n 2\n!n2 +n3\n\n!n5 (!n1 +n3 \u22b8!n4) !n3 +n5(!n2 \u22b8!n1)\n\n!n2 +n3 +n5\n\ny\n!n5 +n6 (!n1 +n3 \u22b8!n4)\n\nx\n\nx\n\n!n3 +n5 +n6 (!n2 \u22b8!n1 )\n\nFigure 2: Meta EAL type derivation of two.\n\nthe following two fragments:\n..\n.\nz1 : a, z2 : a, x1 : a \u22b8 (b \u22b8 b), x2 : a \u22b8 (b \u22b8 b), w : b \u22a2 ((x1 z1 ) ((x2 z2 ) w)) : b\n!\nz1 :!a, z2 :!a, x1 :!(a \u22b8 (b \u22b8 b)), x2 :!(a \u22b8 (b \u22b8 b)), w :!b \u22a2 ((x1 z1 ) ((x2 z2 ) w)) :!b\ncontr, contr\nz :!a, x :!(a \u22b8 (b \u22b8 b)), w :!b \u22a2 ((x z) ((x z) w)) :!b\n\u22b8R\nz :!a, x :!(a \u22b8 (b \u22b8 b)) \u22a2 \u03bbw.((x z) ((x z) w)) : (!b \u22b8!b)\n(1)\nand\n..\n.\nk1 , k2 : b \u22b8 b \u22a2 \u03bbw.(k1 (k2 w)) : b \u22b8 b)\n!\nk1 , k2 :!(b \u22b8 b) \u22a2 \u03bbw.(k1 (k2 w)) :!(b \u22b8 b)\ncontr\nz:a\u22a2z:a\nk :!(b \u22b8 b) \u22a2 \u03bbw.(k (k w)) :!(b \u22b8 b)\n\u22b8L\nz : a, x : a \u22b8!(b \u22b8 b) \u22a2 \u03bbw.((x z) ((x z) w)) :!(b \u22b8 b)\n\n(2)\n\nIf we display these derivations as annotated syntax tree with explicit fan nodes\nfor contraction (that is, as sharing graphs), we obtain Figure 3 for the derivation (1), and Figure 4 for (2).\nBoth graphs are legal EAL sharing graphs, but only the first is a possible\ninitial translation of M as a sharing graph, since in initial translations the\nfan nodes are used to share (contract) only variables, before abstracting them.\nAlthough our technique could be extended to cope with arbitrary contractions\n(see Section 4), we present it as a type inference algorithm for initial translations\nof type-free \u03bb-terms, according to our original aim to use it as a tool in an\noptimal reducer. This is the motivation for the following notion.\nDefinition 1. A type-free \u03bb-term M has EAL type A from the basis \u0393 (write:\n\u0393 \u22a2EAL M : A) iff there is a derivation of \u0393 \u22a2 M : A in the system of Fig6\n\n\f\u03bbz\n\u03bbx\n\u03bbw\n@\n@\n@\n\n@\n\nw\n!(!a \u22b8 (b \u22b8 b))\nx\n\nz\n\nFigure 3: One decoration of \u03bbz x w.((x z) ((x z) w)): the fan faces a lambda.\n\n\u03bbz\n\u03bbx\n\u03bbw\n@\n@\n\nw\n@\n\na \u22b8!(b \u22b8 b)\nx\n\nz\n\nFigure 4: Another decoration of \u03bbz x w.((x z) ((x z) w)): the fan faces an\napplication.\n\n7\n\n\fure 1 whose corresponding sharing graph does not have any fan node facing an\napplication node.\nRemark 1. It is possible to formulate the previous definition directly in terms\nof sequent derivations, without any reference to the notion of sharing graph. It\ncould be proved that \u0393 \u22a2EAL M : A iff there is a sequent derivation of \u0393 \u22a2 M : A\nwhere all contractions either are immediately followed by \u22b8 R, or are at the end\nof the derivation. However, the \"only if \" part is not trivial. In going from a sequent derivation to a sharing graph, in fact, we loose any information regarding\nthe position of cuts and (to some extent) of \u22b8 L. Therefore, given a term M\nfor which \u0393 \u22a2EAL M : A (that is, given a sharing graph that could be decorated\nwith EAL-types and boxes) there are many sequent derivations corresponding to\nthe skeleton coded by this sharing graph. Not all these derivations satisfy the\nconstraint expressed by the \"only if \" part. It can be shown, however, that among\nthese derivations there is one in which the constraint is satisfied. This could be\nobtained by using the notion of canonical form of an EAL derivation, introduced\nand exploited in [CR03].\nRemark 2. There exist simply typeable terms without any EAL type. For\ninstance the \u03bb-term\n(\u03bbn.(n \u03bby.(n \u03bbz.y)) \u03bbx.(x (x y)))\nhas a simple type, but no EAL decoration (see Appendix A for an analysis).\n\n2\n\nType inference\n\nThe type inference algorithm is given as a set of inference rules, specifying several\nfunctions. The complete set of rules is given in Section 2.2; the properties of the\nalgorithm will be stated and proved in Section 3. We start in the next section\nwith the detailed discussion of an example, which will also introduce the various\nrules and the problems they have to face.\n\n2.1\n\nExample of type inference\n\nA class of types for an EAL-typeable term can be seen as a decoration of a\nsimple type with a suitable number of boxes.\nDefinition 2. A general EAL-type \u0398 is generated by the following grammar:\n\u0398 ::=!n1 +***+nk o|!n1 +***+nk (\u0398 \u22b8 \u0398)\nwhere k \u2265 0 and n1 , . . . , nk are variables ranging on IN.\nWe shall illustrate our algorithm on the term (\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) :\no \u2192 o, whose simple type derivation in natural deduction is given in Figure 5\n(I\u03b1 stands for \u03b1 \u2192 \u03b1).\n\n8\n\n\fz : Io \u22a2 z : Io\nn : IIo \u2192 Io \u22a2 n : IIo \u2192 Io \u22a2 \u03bbz.z : IIo\nw:o\u22a2w:o\nx : IIo \u22a2 x : IIo \u22a2 \u03bbw.w : Io\ny:o\u22a2y:o\nn : IIo \u2192 Io \u22a2 (n \u03bbz.z) : Io\nx : IIo \u22a2 x : IIo\nn : IIo \u2192 Io , y : o \u22a2 ((n \u03bbz.z) y) : o\nx : IIo \u22a2 (x \u03bbw.w) : Io\nn : IIo \u2192 Io \u22a2 \u03bby.((n \u03bbz.z) y) : Io\nx : IIo \u22a2 (x (x \u03bbw.w)) : Io\n\u22a2 \u03bbn.\u03bby.((n \u03bbz.z) y) : (IIo \u2192 Io ) \u2192 Io\n\u22a2 \u03bbx.(x (x \u03bbw.w)) : IIo \u2192 Io\n\u22a2 (\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) : o \u2192 o\n\nFigure 5: Simple type derivation of (\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) : o \u2192 o\nThe algorithm searches for the leftmost innermost subterm for which there\nis no assignment of an EAL-type yet. In this case, it is the variable\nn : (((o \u2192 o) \u2192 (o \u2192 o)) \u2192 (o \u2192 o)) .\nIts most general EAL-type is obtained from its simple type by adding pi modalities wherever possible. This is the r\u00f4le of the function P:\nP(o) =!p o\nP(\u03c3) = \u0398 P(\u03c4 ) = \u0393\n.\nP(\u03c3 \u2192 \u03c4 ) =!p (\u0398 \u22b8 \u0393)\n\n(3)\n\n(4)\n\nThe main function of the algorithm-the type synthesis function S-may now\nbe applied. In the case of a variable x of simple type \u03c3 the rule is:\nP(\u03c3) = \u0398\nS(x : \u03c3) = h\u0398, {x : \u0398}, \u2205, \u2205i\n\n(5)\n\nObserve that, given a term M of simple type \u03c3, S(M : \u03c3) returns a quadruple:\nhgeneral EAL-type, base1 {xi : \u0398i }i of pairs (variable:general EAL-type), set\nof linear constraints, critical points2 i.\nIn our example we obtain:\nn :!p1 (!p2 (!p3 (!p4 o \u22b8!p5 o) \u22b8!p6 (!p7 o \u22b8!p8 o)) \u22b8!p9 (!p10 o \u22b8!p11 o))\n\n(6)\n\nfor any pi \u2208 IN, 1 \u2264 i \u2264 11. In the following we will not explicit the \"\u2208 IN\" for\nany variable we will introduce, being this constraint implicated by Definition 2.\nNotation 1. We will write (n \u22b8 m) instead of (!n o \u22b8!m o), for a better reading.\nAnalogously, z : (o \u2192 o) is typed\nz : p12 (p13 \u22b8 p14 )\n\n(7)\n\nIt is now the turn of the subterm \u03bbz.z. The type synthesis rule for an abstraction\n\u03bbx.M , where x occurs in M , takes the following steps:\n1A\n\nbase here is a multiset where multiple copies of x : \u0398 may be present.\nwill discuss critical points in a moment.\n\n2 We\n\n9\n\n\f1. infer the EAL-type for M ;\n2. add all possible boxes around M (function B, which will be described\nlater); the algorithm tries to build all possible decorations3 that in the\ncase of an abstraction \u03bbx.M are the decorations of all subterms of M ,\nalready build by inductive hypothesis, plus all possible box-decorations of\nthe whole M , performed at this stage of the inference by function B, plus\nall possible box decorations of \u03bbx.M , eventually performed at the next\nstep of the inference procedure;\n3. contract all the types of abstracted variable x (function C, which will be\ndescribed later).\nThe rule is the following:\nC(\u0398\n\uf8f1\n\uf8fc\n\uf8fc\n\uf8eb 1 , . . . , \u0398h ) = A3 \uf8f1\n\uf8f6\n+\n*\n\uf8f4\n\uf8f4\n\uf8f2sl1 (x)\uf8f4\n\uf8f2x : \u03981\uf8f4\n\uf8fd\n\uf8fd\n\uf8ec\n\uf8f7\n.\n.\n.\n..\nB \uf8edM, B1 , \u03931 , cpts \u222a\n, \u0393, A2\n, A1 \uf8f8 = B \u222a\n\uf8f4 . \uf8fe\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f3\n\uf8f3\n\uf8fe\nslk (x)\nx : \u0398h\nS(M : \u03c4 ) = h\u03931 , B1 , A1 , cpts \u222a {sl1 (x), . . . , slk (x)}i\n\u001d\n\u001c\n\u001a\nA2\n, cpts\nS(\u03bbx.M : \u03c3 \u2192 \u03c4 ) = \u03981 \u22b8 \u0393, B,\nA3\n\n(8)\n\nIn our example, there is only one occurrence of z and therefore the contraction\nfunction C is called with only one type and does not produce any constraint.\nAlso the boxing function B produce no result, being called on a variable, i.e., it\nacts as the identity returning a triple with the same base, type and (empty, in\nthis case) set of constraints:\nB(z, {z : p12 (p13 o \u22b8 p14 o)}, p12 (p13 o \u22b8 p14 o), \u2205, \u2205) =\nh{z : p12 (p13 o \u22b8 p14 o)}, p12 (p13 o \u22b8 p14 o), \u2205i.\nThe r\u00f4le of cpts and sl will be discussed in the context of the critical points,\nbelow. Coming back to our example, for \u03bbz.z : ((o \u2192 o) \u2192 (o \u2192 o)) we infer\nthe EAL-type\n\u03bbz.z : p12 (p13 \u22b8 p14 ) \u22b8 p12 (p13 \u22b8 p14 )\n(9)\nWhen the algorithm infers the EAL-type for (n \u03bbz.z) : (o \u2192 o), it:\n1. adds all possible boxes around the argument \u03bbz.z with the boxing function,\nthat in this case adds b1 boxes around \u03bbz.z returning a triple with the same\nbase, b1 banged type and unmodified set of (again empty) constraints:\nB(\u03bbz.z, \u2205, p12 (p13 \u22b8 p14 ) \u22b8 p12 (p13 \u22b8 p14 ), \u2205, \u2205) =\n= h\u2205, b1 (p12 (p13 \u22b8 p14 ) \u22b8 p12 (p13 \u22b8 p14 )), \u2205i\n3 More precisely it builds all possible decorations without exponential cuts and with some\nother properties listed in Theorem 3. Decorations of these kinds are sufficient for the completeness of the algorithm.\n\n10\n\n\fb1\n\n@\n\n\u03bbz\nn\nz\nFigure 6: Decoration of (n \u03bbz.z).\n\n2. imposes the EAL-type of n to be functional, i.e., the constraint\np1 = 0\n\n(10)\n\n3. unifies the EAL-type of the boxed \u03bbz.z with the argument part of the\nEAL-type of n:\n\u0012\n\u0013\nb1 (p12 (p13 \u22b8 p14 ) \u22b8 p12 (p13 \u22b8 p14 )),\nU\n.\np2 (p3 (p4 \u22b8 p5 ) \u22b8 p6 (p7 \u22b8 p8 ))\nObserve that the implicational structure of the types is already correct,\nsince we start from a simple type derivation. Therefore, unification only\nproduces a set of constraints on the variables used to indicate boxes. In\nour example, we get the constraints:\n\uf8f1\n= p2\n\uf8f4\n\uf8f4 b1\n\uf8f4\n\uf8f1\n\uf8f4\np\n= p3\n\uf8f4\n12\n\uf8f4\nb 1 = p2\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\uf8f2 p13 = p4\np3 = p6 = p12\np14 = p5\n(11)\n\u21d4\np4 = p7 = p13\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\np\n=\np\n\uf8f3\n\uf8f4\n12\n6\n\uf8f4\np5 = p8 = p14.\n\uf8f4\n\uf8f4\np13 = p7\n\uf8f4\n\uf8f4\n\uf8f3\np14 = p8\n\nThe type synthesis rule4 for an application, provided that M and N are not\napplications themselves, is:\n\n4 We\n\nU (\u03981 , \u03983 ) = A4\nB(N, B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS(N : \u03c3) = h\u03982 , B2P, A2 , cpts2 i\nS(M : \u03c3 \u2192 \u03c4 ) = h! ni (\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\nA1\n\uf8f4\n+\n*\n\uf8f4\n\uf8f2\nA3\nS((M N ) : \u03c4 ) = \u0393, B1 \u222a B3 ,\n, cpts1 \u22d2 cpts2\nA4\n\uf8f4\n\uf8f4\n\uf8f3 P\nni = 0\n\nwill explain \u22d2 later.\n\n11\n\n(12)\n\n\fFigure 6 shows the decoration obtained so far:\nn : b1 (p3 (p4 \u22b8 p5 ) \u22b8 p3 (p4 \u22b8 p5 )) \u22b8 p9 (p10 \u22b8 p11 ) \u22a2 (n \u03bbz.z) : p9 (p10 \u22b8 p11 ).\n(13)\nNext step is the inference of a general EAL-type p15 for y : o. Then the\nalgorithm starts to process ((n \u03bbz.z) y) : o. As before, the algorithm\n1. applies B to the argument y (a void operation here, since the boxing\nfunction does nothing for variables);\n2. imposes the EAL-type of (n \u03bbz.z) to be functional:\np9 = 0.\n\n(14)\n\n3. unifies the EAL-types, to make type-correct the application:\nU (p10 , p15 ) =\n\np10 = p15.\n\n(15)\n\nHowever, the present case is more delicate than the application we treated\nbefore, since the function part is already an application. Two consecutive\napplications in ((n \u03bbz.z) y) indicates that more than one decoration is\npossible. Indeed, there can be several derivations building the same term,\nthat can be differently decorated. The issue is better appreciated if we\nlook ahead for a moment and we consider the term \u03bby.((n \u03bbz.z) y). There\nare two (simple) sequent derivations for this term, both starting with the\nterm (x y) : o, for x : o \u2192 o, y : o. The first derivation, via a left \u2192-rule,\nobtains ((n \u03bbz.z) y) : o; then it bounds y, giving \u03bby.((n \u03bbz.z) y) : o \u2192\n(o \u2192 o). The second derivation permutes the rules: it starts by binding\ny, obtaining \u03bby.(x y) and only at this point substitutes (n \u03bbz.z) for x,\nvia the left \u2192-rule. When we add boxes to the two derivations, we see\nthis is a critical situation. Indeed, in the first derivation we may box\n(x y), then ((n \u03bbz.z) y) and finally \u03bby.((n \u03bbz.z) y). In the second, we box\n(x y), then \u03bby.(x y) and finally the whole term. The two (incompatible)\ndecorations are depicted in the two bottom trees of Figure 10. The critical\nedge-where the boxing radically differs-is the root of the subtree for\n((n \u03bbz.z) y), corresponding to the x that is substituted for in the left\n\u2192-rule. Let us then resume the discussion of the type inference for this\nterm. At this stage we collect the critical point, marked with a star in\nFigure 7, indicating the presence of two possible derivations. When, in\nthe future, it will be possible to add boxes, for example b2 in Figure 7\nduring the type inference of \u03bby.((n \u03bbz.z) y), the algorithm will consider\nthe critical point as one of the closing points of such boxes, c1 in Figure 7,\neventually modifying the constraint in Equation (14) that impose type of\n(n \u03bbz.z) to be functional and not exponential. Indeed, for completeness,\nthe algorithm must take into account all possible derivations. When there\nwill be more than one critical point, at every stage of the type inference,\nwhen it is possible to apply a ! rule, the algorithm will compute all possible\n12\n\n\f\u03bby\n\nb2\n\n@\n\nc1\ny\n\nb1\n\n@\n\n\u03bbz\nn\nz\n\nFigure 7: Critical point in the decoration of \u03bby.((n \u03bbz.z)y).\n\nFigure 8: Combinations of two critical points.\n\ncombinations of the critical points (see Figure 8, showing a schematic\nexample with two critical points) eventually modifying some constraints.\nWe call slices 5 such combinations of critical points; they are the data\nmaintained by the algorithm and indicated in the rules as cpts. The task\nof combining the two lists of slices collected during the type inference of\nthe function and argument part of an application is performed by \u22d2, whose\nrules are given in Section 2.2.4.\nDefinition 3. The list of free variable occurrences of a lambda term M\nis defined in the following way:\n(a) FVO(x) = [x];\n(b) FVO(\u03bbx.M ) = FVO(M ) \u2212 x;\n(c) FVO((M1 M2 )) = FVO(M1 ) :: FVO(M2 ) (the concatenation of lists).\n5 We thank Philippe Dague for useful discussions and suggestions on the calculation of\ncritical points.\n\n13\n\n\fDefinition 4. A slice is a set of pairs (constraint, list of free variable\noccurrences) as in the following6 :\n\b\nsl = (Aj1 , [y11 , . . . , y1h ]), . . . , (Ajk , [yk1 , . . . , ykh ])\n\nA slice corresponds to a combination of critical points.\n\nIn our example the algorithm collects the slice (p9 = 0, [n]). Notice that\na slice partitions the set of free variable occurrences in a derivation: it\nmarks the set of variable occurrences whose types should not be modified\nwhen the box is added. This is the intuitive meaning of the set of free\nvariable occurrences in the data structure we use.\nNotation 2.\n\u2022 sl(x) indicates a slice having x as an element of every\nlist of variables in it.\n\u2022 x \u2208 sl if and only if there exists one element of sl whose list of\nvariables contains x.\n\u2022 Aj \u2208 sl if and only if there exists one element of sl whose constraint\nis Aj .\n\u2022 Being Aj the constraint \u00b1nj1 \u00b1 * * * \u00b1 njk = 0, Aj \u2212 n corresponds to\nthe constraint \u00b1nj1 \u00b1 * * * \u00b1 njk \u2212 n = 0.\nThe general type inference rule for the application we are considering now,\ni.e., ((M1 M2 ) N ) when N is not an application, is the following:\nP\ncpts = (cpts1 \u222a {( ni = 0, FVO((M1 M2 )))}) \u22d2 cpts2\nU (\u03981 , \u03983 ) = A4\nB(N, B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS(N : \u03c3) = h\u03982 , B2 , A2 , cpts\ni\nP 2\nS((M1 M2 ) : \u03c3 \u2192 \u03c4 ) = h! ni (\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\n(16)\nA1\n\uf8f4\n+\n*\n\uf8f4\n\uf8f2\nA3\n, cpts\nS((M1 M2 ) N ) : \u03c4 ) = \u0393, B1 \u222a B3 ,\n\uf8f4 P A4\n\uf8f4\n\uf8f3\nni = 0\nIn the example case we obtain:\n\uf8f1\n\uf8fc\n\uf8f2 n : b1 (p3 (p4 \u22b8 p5 ) \u22b8 p3 (p4 \u22b8 p5 ))\n\uf8fd\n\u22b8 p9 (p10 \u22b8 p11 ),\n\u22a2 ((n \u03bbz.z) y) : p11\n\uf8f3\n\uf8fe\ny : p10\n(17)\nand critical points cpts = {(p9 = 0, [n])}.\n\nTyping \u03bby.((n \u03bbz.z) y) : o \u2192 o involves rule (8), the same we used for \u03bbz.z,\nbut now the boxing procedure B is called on a subterm that is not a single\nvariable. The complete set of rules for B is the following:\nB(x, B, \u0393, cpts, A) = hB, \u0393, Ai\n6 Aj\n\nmeans the j-th row of the matrix A, i.e., the j-th constraint.\n\n14\n\n(18)\n\n\fBoxing of a variable produces no changes in the base, type and set of constraints.\nB(B, \u0393, cpts, A) = hB1 , \u03931 , A1 i\nB(M, B, \u0393, cpts, A) = h!b B1 , !b \u03931 , A1 i\n\n(19)\n\nB takes care of the list of critical points, by adding boxes \"inside\" the term as\nin Figure 8; at the end, B adds b boxes \"around\" the term.\nB(B, \u0393, \u2205, A) = hB, \u0393, Ai\n\n(20)\n\nB with no critical points produces no changes.\nB (B1\u001a\n, !c \u0393, cpts,\n\u001a c A2 ) = hB, \u2206, A1 i \u001b\n! \u0398i\nxi \u2208\n/ sl\nB1 = xi :\n\u0398\nx\n\u2208\nsl \u0013 i\ni\ni\n\u0012\u001a j\nA\nAj \u2208\n/ sl\nA2 =\nAj \u2212 c\nAj \u2208 sl j\nB({xi : \u0398i }i , \u0393, {sl} \u222a cpts, A) = hB, \u2206, A1 i\n\n(21)\n\nTherefore, rule (8) gives in our case:\nS(\u03bby.((n \u03bbz.z) y) : o \u2192 o) =\nb2 + c1 + p10 \u22b8 b2 + c1 + p11 ,\n{n : b2 (b1 (p3 (p4 \u22b8 p5 )\uf8f1\u22b8 p3 (p4 \u22b8 p5 )) \u22b8 p9 (p10 \u22b8 p11 ))} ,\n+\n*\n..\n\uf8f4\n\uf8f4\n.\n\uf8f2\n\uf8f4\n\uf8f4\n\uf8f3\n\np 9 \u2212 c1 = 0 ,\n..\n.\n\n(22)\n\n{(p9 \u2212 c1 = 0, [n])}\nwhere p9 \u2212 c1 = 0 is the unique constraint (Equation (14)) modified by B.\nThe decoration obtained is shown in Figure 7. Observe that, at this stage, the\npresence of incompatible derivations does not show up yet. It will be taken into\naccount as soon as we will try to box a superterm of the one we just processed.\nIf \u03bby.((n \u03bbz.z) y) would be the whole term, on the contrary, an additional call\nto the function B would be performed, see the rule (60) for function S .\nWhen the algorithm processes \u03bbn.\u03bby.((n \u03bbz.z) y) : (((o \u2192 o) \u2192 (o \u2192 o)) \u2192\n(o \u2192 o)) \u2192 (o \u2192 o) it applies again rule (8). It adds c2 boxes passing through\n\n15\n\n\f\u03bbn\nb3\nc2\n\n\u03bby\n\nb2\n\n@\n\nc1\ny\n\nb1\n\n@\n\n\u03bbz\nn\nz\n\nFigure 9:\n\nthe critical point and b3 boxes around the term, obtaining:\nS(\u03bbn.\u03bby.((n \u03bbz.z) y) : (((o \u2192 o) \u2192 (o \u2192 o)) \u2192 (o \u2192 o)) \u2192 (o \u2192 o)) =\n\n*\n\nb3 + b2 (b1 (p3 (p4 \u22b8 p5 ) \u22b8 p3 (p4 \u22b8 p5 )) \u22b8 p9 (p10 \u22b8 p11 ))\n,\n\u22b8 b3 + c2 (b2 + c1 + p10 \u22b8 b2 + c1 + p11 )\n\u2205,\n+\n\uf8f1\n..\n\uf8f4\n\uf8f4\n.\n\uf8f2\np 9 \u2212 c1 \u2212 c2 = 0 ,\n\uf8f4\n\uf8f4\n..\n\uf8f3\n.\n\u2205\n\n(23)\n\nwhere p9 \u2212 c1 \u2212 c2 = 0 is the unique constraints modified at this stage of the\ntype synthesis.\nThe critical point (p9 \u2212 c2 \u2212 c2 = 0, [n]) is removed. In fact, to bound n,\nthe substitution of n(\u03bbz.z) for x has to be already performed. It does not make\nsense to derive first \u03bbn.\u03bby.(x y), add boxes, and then substitute n(\u03bbz.z) for x,\nsince this would be a free-variable catching substitution.\nFigure 9 shows the decoration obtained. Notice that boxes c2 and b2 belong\nto the two incompatible EAL-derivations we already discussed before. The algorithm maintains at the same time these derivations guaranteeing (see Lemma 9)\nthat if the final solution instantiates two incompatible derivations, we can always calculate an equivalent EAL-derivation (Figure 10 shows the two possible\nderivations for our example).\nGoing on with the type synthesis, the algorithm starts processing the leftmost occurrence of x in (x (x \u03bbw.w)). We use superscripts (1) and (2) to\ndiscriminate the right and left occurrence, respectively. For the leftmost-\nx(2) : (o \u2192 o) \u2192 (o \u2192 o)-we infer the EAL-type\np16 (p17 (p18 \u22b8 p19 ) \u22b8 p20 (p21 \u22b8 p22 ));\n16\n\n(24)\n\n\f\u03bbn\nb3\nc2\n\n\u03bby\n\nb2\n\n@\n\nc1\ny\n\nb1\n\n@\n\n\u03bbz\nn\nz\n\nc2 \u2264 b2\n\nb2 \u2264 c2\n\n\u03bbn\n\nb3 + c2\n\n\u03bbn\n\nb3 + b2\n\n@\n\n@\n\nc1 + c2\n\nc1 + b2\ny\n\ny\nb1\n\n@\n\nc2 \u2212 b2\n\n\u03bby\n\n\u03bby\n\nb2 \u2212 c2\n\nb1\n\n@\n\n\u03bbz\n\n\u03bbz\nn\n\nn\n\nz\n\nz\n\nFigure 10: Superimposed derivations.\n\nanalogously, for the rightmost x(1) : (o \u2192 o) \u2192 (o \u2192 o) we get the EAL-type\np23 (p24 (p25 \u22b8 p26 ) \u22b8 p27 (p28 \u22b8 p29 )).\n\n(25)\n\nThe EAL-type of w : o is p30 and then \u03bbw.w : o \u2192 o is typeable in EAL with\ntype p30 \u22b8 p30 .\nThe innermost application (x(1) \u03bbw.w) is typed p27 (p28 \u22b8 p29 ), once we\nhave imposed\np23 = 0,\n(26)\nwe have boxed \u03bbw.w with b4 boxes, and we have unified the types\nU (p24 (p25 \u22b8 p26 ), b4 (p30 \u22b8 p30 )) =\n\n\u001a\n\nb4 = p24\np25 = p26 = p30 .\n\n(27)\n\nWhen the algorithm processes (x(2) (x(1) \u03bbw.w)), it adds b5 boxes around the\nargument, imposes\np16 = 0\n(28)\nand unifies the types\n\nU (p17 (p18 \u22b8 p19 ), b5 + p27 (p28\n\n\uf8f1\n\uf8f4\n\uf8f2 p17 = b5 + p27\np18 = p28\n\u22b8 p29 )) =\n\uf8f4\n\uf8f3 p19 = p29 .\n\n17\n\n(29)\n\n\f@\n\nb5\n(2)\n\nx\n\nb4\n\n@\n(1)\n\nx\n\n\u03bbw\nw\n\nFigure 11:\n\nMoreover, the presence of two consecutive applications makes the algorithm\ncollect a new critical point (p17 = b5 + p27 , [x(1) ]). The derivation obtained is:\n\u001a (1)\n\u001b\nx : b5 (b4 (p25 \u22b8 p25 ) \u22b8 p27 (p18 \u22b8 p19 )),\n\u22a2 (x(2) (x(1) \u03bbw.w)) : p20 (p21 \u22b8 p22 )\nx(2) : p17 (p18 \u22b8 p19 ) \u22b8 p20 (p21 \u22b8 p22 )\n(30)\nand its decoration is shown in Figure 11.\nFor the type inference of \u03bbx.(x(2) (x(1) \u03bbw.w)) : ((o \u2192 o) \u2192 (o \u2192 o)) \u2192\n(o \u2192 o), the algorithm applies the usual rule for abstractions seen above (8),\nbut in this case there are two instances of the bound variable x. Here comes to\nwork the function C, whose rules are the following.\n\nC(\u0398) = \u2205\nU (!n1 +***+nh \u03981 , \u03982 , . . . , \u0398k ) = A\n\u001a\nn1 + * * * + nh \u2265 1\nn\n+***+n\n1\nh\nC(!\n\u03981 , . . . , \u0398k ) =\nA\n\n(31)\n\n(32)\n\nTherefore the contraction of k general EAL-types is obtained by unification and\nthe constraint that the contracted types have at least one \"!\" (since in EAL\ncontraction is allowed only for exponential formulas).\nComing back to our example, the algorithm adds c3 boxes passing through\nthe critical point and b6 boxes around the body of the abstraction. The B\nfunction modifies the first constraint in Equation (29):\np17 = b5 + p27 \u2212 c3 .\n\n18\n\n(33)\n\n\fb6\n\n\u03bbx\nc3\n\n@\n\nb5\n(2)\n\nx\n\nb4\n\n@\n(1)\n\nx\n\n\u03bbw\nw\n\nFigure 12:\n\nThen the algorithm contracts the types of x:\n\u0012\n\u0013\nb6 + b5 (b4 (p25 \u22b8 p25 ) \u22b8 p27 (p18 \u22b8 p19 )),\nC\n=\nb6 + c3 (p17 (p18 \u22b8 p19 ) \u22b8 p20 (p21 \u22b8 p22 ))\n\uf8f1\nb6 + b + 5 \u2265 1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2 b 5 = c3\nb4 = p17\n=\n\uf8f4\n\uf8f4\np18 = p19 = p21 = p22 = p25\n\uf8f4\n\uf8f4\n\uf8f3\np20 = p27\n\n(34)\n\nFinally it removes the critical point (p17 = b5 + p27 \u2212 c3 , [x(1) ]).\nThe derivation obtained, whose decoration is shown in Figure 12, is:\n\u22a2 \u03bbx.(x (x \u03bbw.w)) : b6 + b5 (b4 (p18 \u22b8 p18 ) \u22b8 p20 (p18 \u22b8 p18 ))\n\u22b8 b6 + b5 + p20 (p18 \u22b8 p18 ). (35)\nThe algorithm process now the whole term (\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) :\no \u2192 o. It adds b7 boxes around the argument of the application and unifies the\nEAL-types for the correct application:\n\u0012\n\u0013\nb3 + b2 (b1 (p3 (p4 \u22b8 p5 ) \u22b8 p3 (p4 \u22b8 p5 )) \u22b8 p9 (p10 \u22b8 p11 ),\nU\n=\nb7 (b6 + b5 (b4 (p18 \u22b8 p18 ) \u22b8 p20 (p18 \u22b8 p18 )) \u22b8 b6 + b5 + p20 (p18 \u22b8 p18 )\n\uf8f1\nb7 = b3 + b2\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2 b1 = b6 + b5\nb4 = p3 = p20\n=\n(36)\n\uf8f4\n\uf8f4\np\n=\np\n=\np\n=\np\n=\np\n\uf8f4\n4\n5\n10\n11\n18\n\uf8f4\n\uf8f3\np9 = b6 + b5 + p20\n\nSince this is the complete term, the final step of the algorithm is a single call\nto the function S , which in this case simply adds b8 boxes around the term.\nTherefore, the simply typed lambda term\n(\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) : o \u2192 o\n19\n\n(37)\n\n\fb8\n@\n\nb7\n\u03bbx\n\u03bbn\n\nc3\n\nb3\n\nb6\n\n@\n\nb5\nc2\n\n\u03bby\n\nb2\n\nx(2)\n\n@\n\nx(1)\n\n@\n\nb4\n\u03bbw\n\nc1\ny\n\nw\n\nb1\n\n@\n\n\u03bbz\nn\nz\n\nFigure 13: Final superimposed decoration.\n\nhas EAL-type\n!b8 +b3 +c2 (!b2 +c1 +p4 o \u22b8!b2 +c1 +p4 o)\n\n(38)\n\nfor any p1 , . . . , p30 , b1 , . . . , b8 , c1 , c2 , c3 \u2208 IN solutions of the set of constrains7 in\nequations (10)\u2013(36):\n\uf8f1\nb6 + b5 \u2265 1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\nb\n\uf8f4\n7 = b3 + b2\n\uf8f4\n\uf8f4\n\uf8f4\nb\n\uf8f4\n1 = p2 = b 6 + b 5\n\uf8f4\n\uf8f4\n\uf8f4\nb\n\uf8f4\n5 = c3\n\uf8f4\n\uf8f2\np1 = p16 = p23 = 0\n(39)\np 9 = c1 + c2 = b 6 + b 5 + b 4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\np17 = b5 + p27 \u2212 c3\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\nb4 = p3 = p6 = p12 = p17 = p20 = p24 = p27\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\np4 = p5 = p7 = p8 = p10 = p11 = p13 = p14 = p15 = p18\n\uf8f4\n\uf8f4\n\uf8f3\np4 = p19 = p21 = p22 = p25 = p26 = p28 = p29 = p30 .\n\nThe final decoration is shown in Figure 13. Considering the set of constraints\nin Equation (39) and the incompatibility of c2 and b2 stated above, the simply\ntyped term\n(\u03bbn.\u03bby.((n \u03bbz.z) y) \u03bbx.(x (x \u03bbw.w))) : o \u2192 o\ncan be typed in EAL either:\n1. for any n1 , . . . , n6 \u2208 IN, n1 \u2265 1 with EAL-type !n3 +n5 (!n1 +n2 +n4 +n6 o \u22b8\n!n1 +n2 +n4 +n6 o) and decoration shown in Figure 14, or\n2. for any m1 , . . . , m7 \u2208 IN, m1 \u2265 1 \u2227 m2 + m3 = m1 + m5 with EAL-type\n!m3 +m4 +m6 (!m2 +m7 o \u22b8!m2 +m7 o) and decoration shown in Figure 15.\n7 We\n\nhave boxed the constraints which were not modified by B until the end of the type\n\n20\n\n\fn5\n@\n\nn2 + n3\n\u03bbx\n\u03bbn\nn3\n\u03bby\n\nn2\n\nx(2)\n\n@\n\nx(1)\n\n@\n\nn1 + n4\n\nn1\n\n@\n\nn4\n\u03bbw\nw\n\ny\nn1\n\n@\n\n\u03bbz\nn\nz\n\nFigure 14: Final decoration.\n\nm6\n@\n\nm4\n\u03bbx\n\u03bbn\n\nm1\n\n@\n\nm4\nm3\n\n\u03bby\n\nx(2)\n\n@\n\nx(1)\n\n@\n\nm5\n\u03bbw\n\nm2\ny\n\nw\n\nm1\n\n@\n\n\u03bbz\nn\nz\n\nFigure 15: Another possible final decoration.\n\n21\n\n\f2.2\n\nThe full algorithm\n\nWe define in this section the formal rules for the algorithm. An almost complete\ntrace of its application to a simply typed term with no EAL type can be found\nin the Appendix.\nDefinition 5. (Type Synthesis Algorithm) Given a simply typeable lambda term\nM : \u03c3, the type synthesis algorithm S (M : \u03c3) returns a triple h\u0398, B, Ai, where\n\u0398 is a general EAL-type, B is a base ( i.e., a multi-set of pairs variable, general\nEAL-type) and A is a set of linear constraints.\nIn the following n, n1 , n2 are always fresh variables, o is the base type. Moreover, we consider !n1 (!n2 \u0398) syntactically equivalent to !n1 +n2 \u0398.\nNotation 3. Given a set of linear constraints A and a solution X of A, for any\ngeneral EAL-type \u0398 and for any base B = {x1 : \u03981 , . . . , xn : \u0398n }, we denote\nwith X(\u0398) the instantiation of \u0398 with X and with X(B) the instantiation of B\nwith X, i.e., X(B) = {x1 : X(\u03981 ), . . . , xn : X(\u0398n )}.\n2.2.1\n\nUnification: U\n\nUnification takes a set of h \u2265 2 general EAL-types having the same underlying\nintuitionistic shape and returns a set of linear equations A such that for any\nsolution X of A, the instantiations of the h general EAL-types are syntactically\nidentical.\n\uf8f1 P\nP\nni1 \u2212 ni2 = 0\n\uf8f4\n\uf8f2\nP\nP\n..\nU (! ni1 o, . . .! nih o) =\n.\n\uf8f4\nP\n\uf8f3 P\nnih\u22121 \u2212 nih = 0\nU (\u039811 , . . . , \u03981h ) = A1\n\uf8eb\n\n2.2.2\n\nP\n\n\uf8f6\n\n\uf8f1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\n! ni1 (\u039811 \u22b8 \u039821 ),\n\uf8f7\n\uf8ec ..\nU \uf8ed .,\n\uf8f8=\n\uf8f4\nP\n\uf8f4\nnih\n\uf8f4\n\uf8f4\n!\n(\u03981h \u22b8 \u03982h )\n\uf8f4\n\uf8f3\n\nU (\u039821 , . . . , \u03982h ) = A2\nP\nP\nni1 \u2212 ni2 = 0\n..\n.P\nP\nnih\u22121 \u2212 nih = 0\nA1\nA2\n\n(40)\n\n(41)\n\nContraction (C) and Type Processing (P)\n\nContraction in EAL is allowed only for exponential formulas. Thus, given k general EAL-types, C returns the same set of constraints of U with the additional\ninference process in the exposition above.\nstraints (39).\n\nThey are now all collected in the set of con-\n\n22\n\n\fconstraint that the number of external ! must be greater than zero.\nC(\u0398) = \u2205\nU (!n1 +***+nh \u03981 , \u03982 , . . . , \u0398k ) = A\n\u001a\nn1 + * * * + nh \u2265 1\nn\n+***+n\n1\nh\nC(!\n\u03981 , . . . , \u0398k ) =\nA\n\n(42)\n\n(43)\n\nGiven a simple type \u03c4 , P returns the most general EAL-type whose cancellation\nis \u03c4 , obtained by adding everywhere p exponentials (every p is a fresh variable).\nP(o) =!p o\nP(\u03c3) = \u0398 P(\u03c4 ) = \u0393\nP(\u03c3 \u2192 \u03c4 ) =!p (\u0398 \u22b8 \u0393)\n2.2.3\n\n(44)\n\n(45)\n\nBoxing: B and B\n\nThe boxing procedure B superimposes all boxes due to the presence of critical\npoints. Recall the notion of slice (Definition 4) and Notation 2. B has no effect\nif there is no critical point:\nB(B, \u0393, \u2205, A) = hB, \u0393, Ai\n\n(46)\n\nFor any slice sl, B adds c boxes around the subterm above the critical points\nbelonging to sl:\nB (B1\u001a\n, !c \u0393, cpts,\n\u001a c A2 ) = hB, \u2206, A1 i \u001b\n! \u0398i\nxi \u2208\n/ sl\nB1 = xi :\n\u0398\nx\n\u2208\nsl \u0013 i\ni\ni\n\u0012\u001a j\nj\nA\nA \u2208\n/ sl\nA2 =\nAj \u2212 c\nAj \u2208 sl j\n\nB({xi : \u0398i }i , \u0393, {sl} \u222a cpts, A) = hB, \u2206, A1 i\n\n(47)\n\nFunction B is the wrapper for B. It calls B and then adds b external boxes:\nB(x, B, \u0393, cpts, A) = hB, \u0393, Ai\nB(B, \u0393, cpts, A) = hB1 , \u03931 , A1 i\nB(M, B, \u0393, cpts, A) = h!b B1 , !b \u03931 , A1 i\n\n(48)\n\n(49)\n\nProposition 1. Let b, c1 , . . . , ck be the fresh variables introduced by B(M, B, \u0393, cpts, A) =\nh!b B1 , !b \u03931 , A1 i and let X be a solution of A, then\n23\n\n\f1. X1 = (X, b = 0, c1 = 0, . . . , ck = 0) is a solution of A1 ;\n2. X1 (\u03931 ) = X(\u0393);\n3. X1 (B1 ) = X(B).\nProof.\n1. By Equation (47), for every variable ci introduced by B, there is a\nconstraint \u00b1ni1 \u00b1* * *\u00b1niki = 0 that is changed in \u00b1ni1 \u00b1* * *\u00b1niki \u2212ci = 0,\nhence trivially, if the first one is solvable, then the second one is solvable\ntoo imposing ci = 0. Moreover, by Equation (49), b is not added to the\nset of constraint, hence the thesis.\n2. By Equation (47) \u03931 =!c1 +***+ck \u0393.\n3. By Equation (47) if B = {xi : \u0398i }i then B1 = {xi :!\nJi \u2286 {1, . . . , k}.\n\n2.2.4\n\nP\n\nj\u2208Ji\n\ncj\n\n\u0398i }i where\n\nProduct union: \u22d2\n\nProduct union computes all possible combinations of critical points. It is the\nculprit for the exponential complexity of the algorithm.\n\u2205 \u22d2 cpts = cpts \u22d2 \u2205 = cpts\n\uf8f1 \uf8fc \uf8f1 \uf8fc\n\uf8f4\n\uf8f2sl21\uf8f4\n\uf8fd \uf8f4\n\uf8f2sl12\uf8f4\n\uf8fd\n..\n..\n\u22d2\n= cpts\n\uf8f4 . \uf8fe\n\uf8f4 \uf8f3\n\uf8f4 . \uf8f4\n\uf8f3\n\uf8fe\nsln1\nsln2\n\n2.2.5\n\n\uf8f1 \uf8fc \uf8f1 \uf8fc\n\uf8f4\n\uf8f2sl11\uf8f4\n\uf8fd \uf8f4\n\uf8f2sl12\uf8f4\n\uf8fd\n..\n..\n\u22d2\n= {sl11 , sl11 \u222a sl12 , . . . , sl11 \u222a sln2 } \u222a cpts\n.\n.\n\uf8f4\n\uf8f3 \uf8f4\n\uf8fe \uf8f4\n\uf8f3 \uf8f4\n\uf8fe\nsln1\nsln2\n\n(50)\n\n(51)\n\nType synthesis: S\n\nS is the main function of the algorithm. It is defined by cases on the structure\nof the \u03bb-term. Its main cases have already been discussed in Section 2.1. Define\n\u00acapp(M ) iff the term M is not an application.\nVariable case, see equation (5):\nP(\u03c3) = \u0398\nS(x : \u03c3) = h\u0398, {x : \u0398}, \u2205, \u2205i\n\n24\n\n(52)\n\n\fFirst abstraction case: in \u03bbx.M , x \u2208 FV(M ), see equation (8):\nh \u2265 1 x \u2208 FV(M )\nC(\u0398\n\uf8fc\n\uf8f1\n\uf8fc\n\uf8f6\n\uf8eb 1 , . . . , \u0398h ) = A3 \uf8f1\n+\n*\n\uf8f4\n\uf8f4\n\uf8fd\n\uf8f2x : \u03981\uf8f4\n\uf8fd\n\uf8f2sl1 (x)\uf8f4\n\uf8f7\n\uf8ec\n.\n.\n..\n..\n, \u0393, A2\n, A1 \uf8f8 = B \u222a\nB \uf8edM, B1 , \u03931 , cpts \u222a\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8fe\n\uf8f3\n\uf8fe\n\uf8f3\nx : \u0398h\nslk (x)\nS(M : \u03c4 ) = h\u03931 , B1 , A1 , cpts \u222a {sl1 (x), . . . , slk (x)}i\n\u001c\n\u001a\n\u001d\nA2\nS(\u03bbx.M : \u03c3 \u2192 \u03c4 ) = \u03981 \u22b8 \u0393, B,\n, cpts\nA3\n\n(53)\n\nSecond abstraction case: in \u03bbx.M , x \u2208\n/ FV(M ) and M is an application:\nx\u2208\n/ FV((M1 M2 ))P\ncpts = cpts1 \u222a {( ni \u2212 n = 0, FVO(M1 M2 ))}\nP(\u03c3) = \u0398\nP\nB ((M1 M2 ), B1 , \u03931 , cpts1 , A1 ) = B, ! ni \u0393, A\nS((M1 M2 ) : \u03c4 ) = h\u03931 , B1 , A1 , cpts1 i\n\u001c\n\u001a\n\u001d\nA\nS(\u03bbx.(M1 M2 ) : \u03c3 \u2192 \u03c4 ) = \u0398 \u22b8!n \u0393, B, P\n, cpts\nni \u2212 n = 0\n\n(54)\n\nThird abstraction case: in \u03bbx.M , x \u2208\n/ FV(M ) and M is not an application:\n\u00acapp(M )\nx\u2208\n/ FV(M )\nP(\u03c3) = \u0398\nB (M, B1 , \u03931 , cpts, A1 ) = hB, \u0393, Ai\nS(M : \u03c4 ) = h\u03931 , B1 , A1 , cptsi\nS(\u03bbx.M : \u03c3 \u2192 \u03c4 ) = h\u0398 \u22b8 \u0393, B, A, cptsi\n\n(55)\n\nFirst application case: in (M N ), neither M nor N are applications, see equation (12):\n\u00acapp(M ) \u2227 \u00acapp(N )\nU (\u03981 , \u03983 ) = A4\nB(N, B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS(N : \u03c3) = h\u03982 , B2P, A2 , cpts2 i\nS(M : \u03c3 \u2192 \u03c4 ) = h! ni (\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\nA1\n\uf8f4\n+\n*\n\uf8f4\n\uf8f2\nA3\n, cpts1 \u22d2 cpts2\nS((M N ) : \u03c4 ) = \u0393, B1 \u222a B3 ,\n\uf8f4 P A4\n\uf8f4\n\uf8f3\nni = 0\n\n25\n\n(56)\n\n\fSecond application case: in (M N ), M is not an application:\n\u00acapp(M )\n\u0001\ncpts = cpts1 \u22d2 cpts2 \u222a {(A14 , FVO((N1 N2 )))}\nU (\u03983 , \u03981 ) = A4\nB((N1 N2 ), B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS((N1 N2 ) : \u03c3) = h\u0398\n, B2 , A2 , cpts2 i\nP2\nS(M : \u03c3 \u2192 \u03c4 ) = h! ni (\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\nA1\n\uf8f4\n+\n*\n\uf8f4\n\uf8f2\nA3\n, cpts\nS((M (N1 N2 )) : \u03c4 ) = \u0393, B1 \u222a B3 ,\n\uf8f4 P A4\n\uf8f4\n\uf8f3\nni = 0\n\n(57)\n\n\u00acapp(N )\nP\ncpts = (cpts1 \u222a {( ni = 0, FVO((M1 M2 )))}) \u22d2 cpts2\nU (\u03981 , \u03983 ) = A4\nB(N, B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS(N : \u03c3) = h\u03982 , B2 , A2 , cpts\ni\nP 2\nni\nS((M1 M2 ) : \u03c3 \u2192 \u03c4 ) = h!\n(\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\nA1\n\uf8f4\n*\n+\n\uf8f4\n\uf8f2\nA3\nS((M1 M2 ) N ) : \u03c4 ) = \u0393, B1 \u222a B3 ,\n, cpts\nA4\n\uf8f4\n\uf8f4\n\uf8f3 P\nni = 0\n\n(58)\n\nNotice that A14 indicates the equality constraints between the outermost number\nof ! in the type of (N1 N2 ) and in the function part of the type of M .\nThird application case: in (M N ), N is not an application, see equation (16):\n\nFourth application case: in (M N ), both M and N are applications:\n1\ncpts4 = cpts2 \u222a {(A\nP4 , FVO((N1 N2 )))}\ncpts3 = cpts1 \u222a {( ni = 0, FVO((M1 M2 )))}\nU (\u03983 , \u03981 ) = A4\nB((N1 N2 ), B2 , \u03982 , cpts2 , A2 ) = hB3 , \u03983 , A3 i\nS((N1 N2 ) : \u03c3) = h\u03982 , B2P\n, A2 , cpts2 i\nS((M1 M2 ) : \u03c3 \u2192 \u03c4 ) = h! ni (\u03981 \u22b8 \u0393), B1 , A1 , cpts1 i\n\uf8f1\n(59)\nA1\n\uf8f4\n+\n*\n\uf8f4\n\uf8f2\nA3\n, cpts3 \u22d2 cpts4\nS((M1 M2 ) (N1 N2 )) : \u03c4 ) = \u0393, B1 \u222a B3 ,\nA4\n\uf8f4\n\uf8f4\nP\n\uf8f3\nni = 0\n\n2.2.6\n\nType synthesis algorithm: S\n\nS is the top level call for the algorithm. It passes the call to S, takes its result,\nboxes the term, forgets the critical points and eventually contracts the common\n\n26\n\n\fvariables in the base.\n.\uf8f1\n..\nC(\u03981h , . . . , \u0398kh )\uf8fc= Ah\n*\uf8f4x1 : \u039811 , . . . , x1 : \u0398k1 ,\uf8f4\n+\n\uf8f2\n\uf8fd\n.\n\u2032\n..\nB(M, B1 , \u03981 , cpts, A ) =\n, \u0398, A\n\uf8f4\n\uf8f4\n\uf8f3\n\uf8fe\nxh : \u03981h , . . . , xh : \u0398kh\nS(M : \u03c3) = h\u03981 , B1 , A\u2032 , cptsi\n\uf8f1\nA +\n\uf8f4\n\uf8f4\n*\n\uf8f4\n\uf8f2 A1\nS (M : \u03c3) = \u0398, {x1 : \u039811 , x2 : \u039812 , . . . , xh : \u03981h } ,\n..\n\uf8f4\n.\n\uf8f4\n\uf8f4\n\uf8f3\nAh\nC(\u039811 , . . . , \u0398k1 ) = A1\n\n3\n\n(60)\n\nProperties of the type inference algorithm\n\nWe will prove in this section that our algorithm S is complete with respect\nto the notion of \u0393 \u22a2EAL M : A introduced in Definition 1. Correctness and\ncompleteness of S are much simpler if, instead of EAL, we formulate proofs and\nresults with reference to an equivalent natural deduction formulation, discussed\nin the following subsection. Before, we state the obvious fact that our algorithm\ndoes not loop, since any rule S decreases the structural size of the \u03bb-term M ,\nany rule U decreases the size of the type \u0398 and any rule B and \u22d2 decreases\nthe size of the set of critical points cpts.\nProposition 2 (Termination). Let M be a simply typed term and let \u03c3 its\nsimple type. S (M : \u03c3) always terminates with a triple h\u0398, B, Ai.\nThe algorithm is exponential in the size of the \u03bb-term, because to investigate\nall possible derivations we need to (try to) box all possible combinations of\ncritical points (see the clauses for the product union, \u22d2, in Section 2.2.4), that\nare roughly bounded by the size of the term.\n\n3.1\n\nNEAL\n\nThe natural deduction calculus (NEAL) for EAL in given in Figure 16, after [Asp98, BBdPH93, Rov98].\nLemma 1 (Weakening). If \u0393 \u22a2NEAL A then B, \u0393 \u22a2NEAL A.\nTo annotate NEAL derivations, we use terms generated by the following\ngrammar (elementary affine terms \u039bEA ):\n\u0003\n\u0002\nM ::= x | \u03bbx.M | (M M ) | ! (M ) M /x, . . . , M /x | [M ]M=x,x\n\u0003\n\u0002\nObserve that in ! (M ) M /x, . . . , M /x , the [M /x] is a kind of explicit substitution. To define ordinary substitution, define first the set of free variables of a\nterm M , FV(M ), inductively as follows:\n\n27\n\n\f\u0393, A \u22a2NEAL A\n\nax\n\n\u0393, A \u22a2NEAL B\n(\u22b8 I)\n\u0393 \u22a2NEAL A \u22b8 B\n\n\u0393 \u22a2NEAL !A \u2206, !A, !A \u22a2NEAL B\ncontr\n\u0393, \u2206 \u22a2NEAL B\n\u0393 \u22a2NEAL A \u22b8 B \u2206 \u22a2NEAL A\n(\u22b8 E)\n\u0393, \u2206 \u22a2NEAL B\n\n\u22061 \u22a2NEAL !A1 * * * \u2206n \u22a2NEAL !An A1 , . . . , An \u22a2NEAL B\n!\n\u0393, \u22061 , . . . , \u2206n \u22a2NEAL !B\nFigure 16: Natural Elementary Affine Logic in sequent style notation\n\n\u2022 FV(x) = {x}\n\u2022 FV(\u03bbx.M ) = FV(M ) r {x}\n\u2022 FV(M1 M2 ) = FV(M1 ) \u222a FV(M2 )\n\u0003\n\u0002\nSn\n\u2022 FV(! (M ) M1 /x1 , . . . , Mn /xn ) = i=1 FV(Mi ) \u222a FV(M ) r {x1 , . . . , xn }\n\n\u2022 FV([M ]N =x1 ,x2 ) = (FV(M ) r {x1 , x2 }) \u222a FV(N )\n\nOrdinary substitution N {M/x} of a term M for the free occurrences of x in\nN , is defined in the obvious way:\n1. x{M/x} = M ;\n2. y{M/x} = y if y 6= x;\n3. \u03bbx.N {M/x} = \u03bbx.N ;\n4. \u03bby.N {M/x} = \u03bbz.(N {z/y}{M/x}) where z is a fresh variable;\n5. (N P ){M/x} = (N {M/x} P {M/x});\n\u0003\n\u0002\n6. ! (N ) P1 /x1 , . . . , Pn /xn {M/x} =\n\u0003\n\u0002\n! (N {y1 /x1 } * * * {yn /xn }{M/x}) P1 {M/x} /y1 , . . . , Pn {M/x} /yn\nif x \u2208\n/ {x1 , . . . , xn }, where y1 , . . . , yn are all fresh variables;\n\u0003\n\u0003\n\u0002\n\u0002\n7. ! (N ) P1 /x1 , . . . , Pn /xn {M/x} =! (N ) P1 {M/x} /x1 , . . . , Pn {M/x} /xn\nif \u2203i s.t. xi = x;\n8. [N ]P =y,z {M/x} = [N {y \u2032 /y}{z \u2032/z}{M/x}]P {M/x}=y\u2032,z\u2032 if x \u2208\n/ {y, z}, where\ny \u2032 , z \u2032 are fresh variables;\n9. [N ]P =y,z {M/x} = [N ]P {M/x}=y,z if x \u2208 {y, z}.\nElementary terms may be mapped to \u03bb-terms, by forgetting the exponential\nstructure:\n28\n\n\f\u0393, x : A \u22a2NEAL x : A\n\nax\n\n\u0393 \u22a2NEAL M :!A \u2206, x :!A, y :!A \u22a2NEAL N : B\ncontr\n\u0393, \u2206 \u22a2NEAL [N ]M=x,y : B\n\n\u0393, x : A \u22a2NEAL M : B\n(\u22b8 I)\n\u0393 \u22a2NEAL \u03bbx.M : A \u22b8 B\n\n\u0393 \u22a2NEAL M : A \u22b8 B \u2206 \u22a2NEAL N : A\n(\u22b8 E)\n\u0393, \u2206 \u22a2NEAL (M N ) : B\n\n\u22061 \u22a2NEAL M1 :!A1 * * * \u2206n \u22a2NEAL Mn :!An x1 : A1 , . . . , xn : An \u22a2NEAL N : B\n\u0003\n\u0002\n!\n\u0393, \u22061 , . . . , \u2206n \u22a2NEAL ! (N ) M1 /x1 , . . . , Mn /xn :!B\n\nFigure 17: Term Assignment System for Natural Elementary Affine Logic\n\n\u2022 x\u2217 = x\n\u2022 (\u03bbx.M )\u2217 = \u03bbx.M \u2217\n\u2022 (M1 M2 )\u2217 = (M1\u2217 M2\u2217 )\n\u0003\n\u0002\n\u2022 (! (M ) M1 /x1 , . . . , Mn /xn )\u2217 = M \u2217 {M1\u2217 /x1 , . . . , Mn\u2217 /xn }\n\n\u2022 ([M ]N =x1 ,x2 )\u2217 = M \u2217 {N \u2217 /x1 , N \u2217 /x2 }\n\nDefinition 6. (Legal elementary terms) The elementary terms are legal under\nthe following conditions:\n1. x is legal;\n2. \u03bbx.M is legal iff M is legal;\n3. (M1 M2 ) is legal iff M1 and M2 are both legal and FV(M1 ) \u2229 FV(M2 ) = \u2205;\n\u0003\n\u0002\n4. ! (M ) M1 /x1 , . . . , Mn /xn is legal iff M and Mi are legal for any i 1 \u2264\ni \u2264 n and FV(M ) = {x1 , . . . , xn } and (i 6= j \u21d2 FV(Mi ) \u2229 FV(Mj ) = \u2205);\n5. [M ]N =x,y is legal iff M and N are both legal and FV(M ) \u2229 FV(N ) = \u2205.\nProposition 3. If M is a legal term, then every free variable x \u2208 FV(M ) is\nlinear in M .\nProof. By trivial induction on the structure of M using definitions of legal terms\nand FV.\nNote 1. From now on we will consider only legal terms.\nNotation 4. Let \u0393 = {x1 : A1 , . . . , xn : An } be a basis. dom(\u0393) = {x1 , . . . , xn };\n\u0393(xi ) = Ai ; \u0393 \u21be V = {x : A|x \u2208 V \u2227 A = \u0393(x)}.\nThe term assignment system is shown in Figure 17, where all bases in the\npremises of the contraction, \u22b8 elimination and !-rule, have domains with empty\nintersection.\n29\n\n\fLemma 2.\n1. If \u0393 \u22a2NEAL M : A then FV(M ) \u2286 dom(\u0393);\n2. if \u0393 \u22a2NEAL M : A then \u0393 \u21be FV(M ) \u22a2NEAL M : A.\nLemma 3 (Substitution). If \u0393, x : A \u22a2NEAL M : B and \u2206 \u22a2NEAL N : A and\ndom(\u0393) \u2229 dom(\u2206) = \u2205 then \u0393, \u2206 \u22a2NEAL M {N/x} : B.\nProof. Recalling that both M and N are legal terms, by easy induction on the\nstructure of M .\nTheorem 1 (Equivalence). \u0393 \u22a2EAL A if and only if \u0393 \u22a2N EAL A.\nProof. (if) By induction, using the cut rule. It is also possible to prove, by an\neasy inspection of the cut-elimination theorem for EAL, that it is possible\nto eliminate just the exponential cuts, leaving the logical ones.\n(only if) The only interesting case is (\u22b8 L). The proof is identical to the case of\nintuitionistic logic.\nLemma 4 (Unique Derivation). For any legal term M and formula A, if\nthere is a valid derivation of the form \u0393 \u22a2NEAL M : A, then such derivation is\nunique (up to weakening).\nA notion of reduction is needed to state and obtain completeness of the type\ninference algorithm. We define two logical reductions (\u2192\u03b2 and \u2192dup ) corresponding to the elimination of principal cuts in EAL. The other five reductions\nare permutation rules, allowing contraction to be moved out of a term.\n\u2192\u03b2\n\n(\u03bbx.M N )\n\nM {N/x}\n\n[N ]!(M)[M1 /x1 ,...,Mn /xn ]=x,y\n[[N {\n\n!(M)\n\nh\n\nx\u20321\n\n/x1 ,...,\n\nx\u2032n\n\n/xn\n\n\u2192dup\ni\n\nh \u2032\ni\n\u2032\n! M \u2032 ) y1 /y1 ,...,yn /yn\n\n/x}{ (\n\n/y}]M1 =x\u20321 ,y1\u2032 * * * ]Mn =x\u2032n ,yn\u2032\n\nP1\nPm\n\u2192!\u2212!\n!(M )[M1 /x1 , * * * ,!(N )[ /y1 ,..., /ym ] /xi , * * * ,Mn /xn ]\n!(M {N/xi })[M1 /x1 , * * * ,P1 /y1 , * * * ,Pm /ym , * * *Mn /xn ]\n\n([M ]M1 =x1 ,x2 N )\n\n\u2192@\u2212c\n\n[(M {x\u20321 /x1 , x\u20322 /x2 } N )]M1 =x\u20321 ,x\u20322\n\n(M [N ]N1 =x1 ,x2 )\n\n\u2192@\u2212c\n\n[(M N {x\u20321 /x1 , x\u20322 /x2 })]N1 =x\u20321 ,x\u20322\n\n\u2192!\u2212c\n!(M )[M1 /x1 , * * * ,[Mi ]N =y,z /xi , * * * ,Mn /xn ]\n\u2032\n\u2032\n[!(M )[M1 /x1 , * * * ,Mi {y /y,z /z} /xi , * * * ,Mn /xn ]]N =y\u2032 ,z\u2032\n[M ][N ]P =y1 ,y2 =x1 ,x2\n\u03bbx.[M ]N =y,z\n\n\u2192\u03bb\u2212c\n\n\u2192c\u2212c\n\n[[M ]N {y1\u2032 /y1 ,y2\u2032 /y2 }=x1 ,x2 ]P =y1\u2032 ,y2\u2032\n\n[\u03bbx.M ]N =y,z where x \u2208\n/ FV(N )\n30\n\n\fwhere M \u2032 in the \u2192dup -rule is obtained from M replacing all its free variables\nwith fresh ones (xi is replaced with yi ); x\u20321 and x\u20322 in the \u2192@\u2212c -rule, y \u2032 and z \u2032\nin the \u2192!\u2212c -rule and y1\u2032 , y2\u2032 in the \u2192c\u2212c -rule are fresh variables.\nDefinition 7. The reduction relation on legal terms\nis defined as the reflexive\nand transitive closure of the union of \u2192\u03b2 , \u2192dup , \u2192!\u2212! , \u2192@\u2212c , \u2192!\u2212c , \u2192c\u2212c , \u2192\u03bb\u2212c .\nProposition 4. Let M\n\nN and M be a legal term, then N is a legal term.\n\nProposition 5. Let M\u2192r N where r is not \u2192\u03b2 , then M \u2217 = N \u2217 .\nLemma 5. Let M be a well typed term in {dup, !\u2212!, @ \u2212 c, ! \u2212 c, c \u2212 c, \u03bb \u2212 c}normal form, then\n1. if R = [N ]P =x,y is a subterm of M , then either P = (P1 P2 ) or P is a\nvariable;\n\u0003\n\u0002\n2. if R =! (N ) P1 /x1 , . . . , Pk /xk is a subterm of M , then for any i \u2208 {1, . . . , k}\neither Pi = (Qi Si ) or Pi is a variable.\nTheorem 2 (Subject Reduction). Let \u0393 \u22a2NEAL M : A and M\n\u0393 \u22a2NEAL N : A.\n\n3.2\n\nN , then\n\nProperties of the Type Inference Algorithm\n\nThe following Lemma states that any slice in the set of critical points bars the\nrest of the term.\nLemma 6. Let S(M : \u03c3) = h\u0398, B, A, cptsi. For any slice sl in cpts, sl =\n{cpt1 , . . . , cptk }, for every path from the root of the syntax tree of M to any\nleaf, there exists at most one cpti in the path.\nProof. By induction on M . The unique interesting case is M = (M1 M2 ). The\nthesis holds by inductive hypothesis and by a simple inspection of rules for S\nand for the product union.\nThe following lemma illustrates the relation between the set of critical points\ncalculated by the algorithm for a given term M and a particular class of decompositions of M .\nLemma 7. Let S(M : \u03c3) = h\u0398, B, A, cptsi.\n1. \u2200{cpt1 , . . . , cptk } = sl \u2208 cpts there exist P, (N11 N21 ), . . . , (N1k N2k ) such\nthat P is not a variable, x1 , . . . , xk \u2208 FV(P ) and M = P {(N11 N21 )/x1 , . . . , (N1k N2k )/xk };\n2. \u2200P, (N11 N21 ), . . . , (N1k N2k ) such that P is not a variable, x1 , . . . , xk \u2208\nFV(P ) and M = P {(N11 N21 )/x1 , . . . , (N1k N2k )/xk }, there exists {cpt1 , . . . , cptk } =\nsl \u2208 cpts such that cpti is the critical point at the root of (N1i N2i ).\nProof. By structural induction on M .\n\n31\n\n\f1. If M is a variable, the thesis trivially holds being cpts = \u2205. If M = \u03bbx.M \u2032 ,\neither sl consists of a single critical point corresponding to the root of M \u2032 ,\nthen P = \u03bbx.y, or sl is a slice of M \u2032 , then by inductive hypothesis there\nexists P \u2032 s.t. the thesis holds for M \u2032 . We take P = \u03bbx.P \u2032 . Finally if\nM = (M1 M2 ), if in sl there is a critical point cpti corresponding to the\nroot of M1 then by Lemma 6 all the other critical points in sl belong to\nM2 or there is only one critical point corresponding to the root of M2 . In\nthe first case by inductive hypothesis there exists P2 s.t. the thesis holds\nfor M2 and sl without cpti . Then we take P = (y P2 ). The other cases\nare analogous.\n2. If M is a variable then 6 \u2203P and the thesis trivially holds. If M = \u03bbx.M \u2032\nthen P = \u03bbx.P \u2032 . If P \u2032 is a variable, then the slice to consider is the one\ncontaining only the critical point corresponding to the root of M \u2032 . Such\na slice has been added to cpts in the rule for S(\u03bbx.(M1 M2 ) : \u03c3) where\nx \u2208\n/ FV((M1 M2 )). Otherwise the thesis holds by inductive hypothesis.\nFinally if M = (M1 M2 ), then P = (P1 P2 ). If both P1 and P2 are not a\nvariable, then by inductive hypothesis there exists sl1 and sl2 . Then the\nthesis holds by definition of product union. The other cases are analogous.\n\nConsider the length L(M ) of an EAL-term M defined inductively:\nL(x) = 0\nL(\u03bbx.M ) = 1 + L(M )\nL((M N )) = 1 + L(M ) + L(N )\nn\nX\n\u0003\n\u0002\nL(Mi )\nL(! (M ) M1 /x1 , . . . , Mn /xn ) = L(M ) +\ni=1\n\nL([M ]N =x,y ) = L(M ) + L(N ).\n\nDefinition 8. An EAL-term M is simple if and only if\n1. M has no subterm of the form [M1 ]M2 =x,y where (M2 )\u2217 is not a variable,\n2. L(M ) = L((M )\u2217 )\nFact 1. A simple EAL-term contracts at most variables.\nDefinition 9. The set of candidate EAL-terms is the set of all EAL-terms P\nsuch that\n1. P is in {!\u2212!, @ \u2212 c, ! \u2212 c, c \u2212 c, \u03bb \u2212 c, dup}-normal form;\n2. P is simple;\n3. if [R]Q=x,y is a subterm of P , then x, y \u2208 FV(R);\n\u0003\n\u0002\n4. if ! (R) Q1 /x1 , . . . , Qk /xk is a subterm of P , then R is not a variable.\n32\n\n\fDefinition 10. Given a general EAL-type \u0398 we define its erasure \u0398 as the\nsimple type obtained by \u0398 erasing all the exponentials \"!\" and changing \u22b8 into\n\u2192.\nLemma 8. For any \u0398 general EAL-type there exists X s.t. X(P(\u0398)) = \u0398.\nTheorem 3 (Completeness). Let \u0393 \u22a2NEAL P : \u03a8 and let P be a candidate\nEAL-term. Let S (P \u2217 : \u03a8) = h\u0398, B, Ai, then there exists X integer solution of\nA such that X(B) \u2286 \u0393, \u03a8 = X(\u0398) and X(B) \u22a2NEAL P : X(\u0398).\nProof. By induction on P .\n\u2022 If \u0393, x : \u03a8 \u22a2NEAL x : \u03a8 then S(x : \u03a8) = hP(\u03a8), {x : P(\u03a8)}, \u2205i and\nthe thesis holds by Lemma 8 being any X solution of the empty set of\nconstraints.\n\u2022 If the type derivation ends with\n\u0393 \u22a2NEAL x :!\u03a6 \u2206, y :!\u03a6, z :!\u03a6 \u22a2NEAL N : \u03a8\n\u0393, \u2206 \u22a2NEAL [N ]x=y,z : \u03a8\nthen the thesis holds by inductive hypothesis on \u2206, y :!\u03a6, z :!\u03a6 \u22a2NEAL N : \u03a8.\n\u2022 If P is an abstraction then the type derivation is\n\u0393, x : \u03a8 \u22a2NEAL M : \u03a6\n\u0393 \u22a2NEAL \u03bbx.M : \u03a8 \u22b8 \u03a6\nThe thesis holds by inductive hypothesis. Notice that the solution X\ninstantiates all variables introduced by the B call of the rule for S to 0.\nIt is easy to see looking at the rules for B that if in the solution X there\nis one variable introduced by B that is not set to zero, then the type is\nexponential and \u03a8 \u22b8 \u03a6 is not.\n\u2022 If P is an application\n\u0393 \u22a2NEAL M : \u03a6 \u22b8 \u03a8 \u2206 \u22a2NEAL N : \u03a6\n\u0393, \u2206 \u22a2NEAL (M N ) : \u03a8\nBy inductive hypothesis there are solutions X1 for M and X2 for N . Now,\nby the same considerations of the previous point, X1 sets\nP all variables\nintroduced by the last B call to 0. Thus the constraint\nnj = 0 of the\nrule for S is satisfied. Moreover X1 , X2 satisfies the constraints for the\nunification of types, because they are identical by hypothesis. Hence the\nthesis holds.\n\u2022 Finally, if the derivation is\n\u22061 \u22a2NEAL M1 :!\u03a61 * * * \u2206n \u22a2NEAL Mn :!\u03a6n x1 : \u03a61 , . . . , xn : \u03a6n \u22a2NEAL N : \u03a8\n\u0003\n\u0002\n\u0393, \u22061 , . . . , \u2206n \u22a2NEAL ! (N ) M1 /x1 , . . . , Mn /xn :!\u03a8\n33\n\n\fthen by Lemma 5 either Mi is a variable or an application. If all Mi\nare variables, then the thesis holds getting the solution of the inductive\nhypothesis and increasing the variable b introduced by B by one.\nIf there is an Mi that is an application, then by Lemma 7 there is a\ncritical point collected by the algorithm at the root of Mi . Then we take\nas solution X the union of the solutions obtained by inductive hypothesis\nwith the variable introduced by B for the critical point corresponding to\nMi increased by one.\n\nIn the statement of the previous theorem, the request on the {!\u2212!, @ \u2212 c, ! \u2212\nc, c\u2212c, \u03bb\u2212c, dup}-normal form is not a loss of generality, for the subject reduction\nlemma and Proposition 5. By Lemma 5, the only restriction induced by the\nrequest of contracting at most variable is the exclusion of elementary terms with\nsubterms of the form [R](Q1 Q2 )=x,y or !(R)[P1 /x1 , * * * , (Q1 Q2 ) /x, * * * , Pn /xn ]\nwith [S]x=y,z subterm of R. Recalling the discussion at the end of Section 1, we\nsee that these terms, in a sense, \"contract too much\" - in the sharing graph of\nthe corresponding \u03bb-term P \u2217 , there would be fan nodes corresponding to nonvariable contractions. We also do not take into account elementary affine terms\nwith \"false contractions\". This is not a limitation by Lemma 1 and Theorem 2.\nFinally we discard term such !(x)[M/x]. Again this is not a limitation, in fact\n(!(x)[M/x])\u2217 = M \u2217 and \u0393 \u22a2NEAL !(x)[M/x] :!\u03a8 if and only if \u0393 \u22a2NEAL M :!\u03a8.\nNotation 5. We use\n\u0393 \u22a2 M :!n A x : A \u22a2 N : B\n\u0393 \u22a2!n (N )[M /x] :!n B\nas a shorthand for\nx1 :!A \u22a2 x1 :!A x : A \u22a2 N : B\nx1 :!A \u22a2!(N )[x1 /x] :!B\n..\n..\nn\u22121\nn\u22121\nn\u22121\nz }| {\nz}|{\nz}|{\nxn\u22121\nx1\n: ! * * *! : A \u22a2 !(* * *!( N )[ /x] * * * )[\n/xn\u22122 ] : ! * * *! B\nx2 :!!A \u22a2 x2 :!!A\n\nn\n\nz}|{\n\u0393 \u22a2 M : ! * * *! A\n\nxn\u22121\n\nn\n\nn\n\nz }| {\nz}|{\n\u0393 \u22a2 !(* * *!( N )[x1 /x] * * * )[M /xn\u22121 ] : ! * * *! B\n\nLemma 9 (Superimposing of derivations). Let S (M : \u03c3) = h\u0398, B, Ai and\nlet A be solvable. If there is a solution X1 of A that instantiates two boxes\nbelonging to two superimposed derivations that are not compatible, then there\nexists another solution X2 where all the instantiated boxes belong to the same\nderivation.\nMoreover X1 (\u0398) = X2 (\u0398) and X1 (B) = X2 (B).\n\n34\n\n\f!n1 +n2 \u03b32\n\u22b8 \u03b32 @\n\u03b3 = \u03b31\n@\n\n\u03b3)\n\nn1\n!\n\u03b1\u22b8\n\n\u03b3)\n\u22b8\n(\u03b2 @\n\u03b1\n\nn1 + n2\nn2\nn1\n\n\u03b31\n@\n\n\u03b2\n\n\u22b8\n(\u03b2\nn1\n!\n\n@\n@\n@\n\n!n2 (\u03b1\u22b8!n1 (\u03b2\u22b8 \u03b3))\nx0\n\nx1\n\nx2\n\nx3\n\nx4\n\nx5\n\nx6\n\nx7\n\nFigure 18: Boxes as levels.\n\nProof. The proof of the lemma can be easily understood if we follow the intuition\nexplained below with an example.\nWe may think of boxes as levels; boxing a subterm can then be seen as\nraising that subterm, as in Figure 18, where also some types label the edges\nof the syntax tree of a simple term. In particular, the edge starting from the\n@-node and ending in x0 has label !n2 (\u03b1 \u22b8!n1 (\u03b2 \u22b8 \u03b3)) at level 0 (nearest to x0 )\nand has label (\u03b1 \u22b8!n1 (\u03b2 \u22b8 \u03b3)) at level n2 . This is the graphical counterpart\nof the !-rule\n. . . , x0 : T, . . . \u22a2 . . . n\n! 2\n. . . , x0 :!n2 T, . . . \u22a2 . . .\nThe complete decoration of Figure 18 can be produced in NEAL in two ways:\nby the instantiation of\n!n2 ((((x0 x1 )y)((x4 x5 )w))) [(x2 x3 )/y, (x6 x7 )/w]\nand8\n!n1 (((z(x2 x3 ))((x4 x5 )w))) [(x0 x1 )/z, (x6 x7 )/w],\nwhich are boxes belonging to two different derivations. Graphically such an\ninstantiation can be represented as in the first row of Figure 19, where incompatibility is evident by the fact that the boxes are not well stacked, in particular\nthe rectangular one covers a hole. To have a correct EAL-derivation it is necessary to find the equivalent, well stacked configuration (that corresponds to the\nsubsequent application of boxes from the topmost to the bottommost).\nThe procedure by which we find the well stacked box configuration is visualized in Figure 19. The reader may imagine the boxes subject to gravity (the\npassage from the first to the second row of Figure 19) and able to fuse each\nother when they are at the same level (the little square in the third row fuse\nwith the solid at its left in the passage from the third to the fourth row).\nThe \"gravity operator\" corresponds to finding the minimal common subterm\nof all the superimposed derivations and it is useful for finding the correct order of\n8 The correct legal terms should have all free variable inside the square brackets.\nWe omit to write variables when they are just renamed, for readability reasons (compare the first elementary term above with the (fussy) correct one\n!n2 ((((x0 x1 )y)((x4 x5 )w))) [x\u20320 /x0 , x\u20321 /x1 , (x2 x3 )/y, x\u20324 /x4 , x\u20325 /x5 , (x6 x7 )/w]).\n\n35\n\n\f+\n\n=\n\n=\n\n=\n\n=\n\n+\n\n=\n\n=\n\n+\n\n+\n\n=\n\n+\n\n=\n\n=\n\nFigure 19: Equivalences of boxes.\n\napplication of the ! rule. The \"fusion operator\" corresponds to the elimination\nof a cut between two exponential formulas. Moreover, the final configuration of\nFigure 19 corresponds to a particular solution of the set of constraints produced\nby the type synthesis algorithm, that instantiates the following boxes:\n\u0001\n!n1 !n2 \u2212n1 (!n1 (((z y)((x4 x5 )w))) [(x0 x1 )/z]) [(x2 x3 )/y] (x6 x7 )/w]\n\nFinally, notice that during the procedure all types labeling the boundary\nedges of the lambda-term never changes, i.e., the instantiations of the term\ntype (the label of the topmost edge) and the base types (the labels of the edges\nat the bottom) remain unchanged.\nNow let S(M : \u03c3) = h\u0398, B, Ai and let X be the solution that instantiates\nk overlapping-thus incompatible-boxes. Consider the boxed syntax tree of\nM and associate to any node its level, i.e., the number of boxes containing the\nnode. Notice that if there is a wire connecting tho nodes a of level l and b of\nlevel l + k, then the type labeling the wire is !k \u03a8 near a and \u03a8 near b, i.e., the\nsum of level and number of exponentials for types labeling the syntax tree is an\ninvariant. We break the boxes using the following procedure: starting from the\nroot of the syntax tree of M , we are at level i = 0; we proceed with a breath\nfirst visit and whenever encounter a node of level l 6= i we close i boxes, open l\nboxes and set i to l.\nAt the end of the procedure described above there are no more overlapping\nboxes, but it could be happen that there is a variable x not in the same boxes of\nits binding lambda node. Such configuration of boxes is not correct. However\nthe level of the variable and lambda node is the same because the procedure of\nbreaking boxes does not change level of nodes. Moreover all nodes belonging\nto the path from the lambda node to the variable have level higher or equal to\nthe level of the variable since they all were initially in the same box and some\n36\n\n\fk\n\nM\nh\n\nN\n\nP\n\nQ\n\nk\n\nk\u2212h\n\nM\nh\u2212k\n\nN\n\nh\n\nP\n\nQ\n\nM\nN\n\nP\n\nQ\n\nk<=h\n\nk>h\n\nFigure 20: Fusion of boxes.\nof them were eventually also in some overlapping boxes that increase the level.\nHence we can fuse boxes until variable and corresponding binder are in the same\nbox. The fusion operation is shown in Figure 20 and described by the following\nequation:\n!k (M {!\n\nh\u2212k\n\n(N )[Q /z]\n\n/x})[P /y] if k \u2264 h\n\n\u0580\n!k (M )[P /y, !\n\nh\n\n(N )[Q /z]\n\n/x]\n\u0581\n!h (!k\u2212h (M )[N /x])[Q /z, P /y] if k > h\n\nAfter all fusions are performed, all variables are in the same boxes of their\nlambda binders and there are no more overlapping boxes, thus the decoration\nobtained corresponds to an EAL-derivation. By completeness exists X2 solution\ncorresponding to such decoration. Moreover types labeling the syntax tree are\nunchanged by the transformations applied, hence the thesis.\nTheorem 4 (Soundness). Let S (M : \u03c3) = h\u0398, B, Ai. For every X integer solution of A, there exists P candidate EAL-term such that P \u2217 = M and\nX(B) \u22a2NEAL P : X(\u0398).\nProof. By induction on the structure of M , using the superimposing lemma.\nWe first need a definition:\nDefinition 11. A syntax tree T is correctly decorated if the edges of the graph\nare labeled according to Figure 21 (in the rightmost picture, \u0398 is inside n boxes).\nMoreover all edges connecting a variable x occurring multiple, are labeled with\nthe same type !n \u0393. In the case the variable is abstracted, the type label of variable\nis syntactically identical to the argument part of the type label of the edge at the\nroot of the abstraction.\n37\n\n\f\u0393\u22b8\u0398\n\n\u0398\n\n\u03bbx\n\n\u0393\u22b8\u0398\n\n\u0398\n\n\u0398\nn\n\n@\n\n!n \u0398\n\n\u0393\n\nFigure 21: Type labels for decorated syntax trees.\nGiven a correctly decorated syntax tree, and an instantiation X for the\ngeneral EAL-types labeling its edges such that the number of exponentials for\ntypes of multiple variables is greater than 1, it is easy to build the corresponding\nNEAL derivation, using the Curry-Howard isomorphism and eventually applying a contraction before the \u22b8 introduction for binded variables and at the end\nof the derivation for free variables.\nThus, in order to prove soundness of our algorithm, it is sufficient to prove\nby structural induction on M that we can build a correctly decorated syntax\ntree. If the solution taken into account instantiates two overlapping boxes we\nuse Lemma 9. Hence without loss of generality we can consider X such that\nall boxes are compatible. The only interesting part of the proof is the checking\n\u0398 \u22b8!n \u0393\n\u03bbk\nc\n\n!\n\nP\n\nni \u2212c\n\n!\n\nP\n\nni\n\n@\nM1\nn=\n\n\u0393\n\n!\n\nP\n\nni1\n\n\u0398\u20321 \u22b8 \u0393\n\n@\n\nni2 \u2212c\n\n!\n\n\u0393\n\nni \u2212 c\n\nN1\nP\n\nni1 =\n\nP\n\nP\n\nni2\n\n@\n\n\u03981 \u22b8 \u0393\n\n\u0398\u20323\n\u0398\u20323\n\n!\n\nP\n\nni\n\nN2\n\nni2 \u2212 c\n\nFigure 22: Decorations given by B.\n\nN\n\n(\u03981 \u22b8 \u0393)\n@\n\n@\n\nc\n\nM\n\nM2\nP\n\n!\n\nP\n\nM1\n\nc\nM2\nP\n\nni \u2212 c = 0\n\nof rules for B. In Figure 22 it is shown how build a correctly decorated syntax\ntree when the solution X instantiates a box passing through a critical point (all\nthree cases of critical points are depicted).\nFinally we need to prove that P is a candidate EAL-term. Points 2 and 3\nof Definition 9 hold by construction of the NEAL derivation from the correctly\ndecorated syntax tree, which also guarantees that P is in {@ \u2212 c, ! \u2212 c, c \u2212 c, \u03bb \u2212\nc, dup}-normal form. Point 4 holds by definition of B, and P is in !-!-normal\nform by the superimposing lemma.\nTheorem 5 (Main theorem). Let M be a simply typeable \u03bb-term. For any\nbasis \u0393 and EAL formula C:\n\n38\n\n\f\u0393 \u22a2EAL M : C iff S (M : C) = h\u0398, B, Ai and A admits an integral solution X\nsuch that X(B) \u2286 \u0393 and C = X(\u0398).\nProof. (\u21d2) \u0393 \u22a2EAL M : C is established by a sharing graph where no fan node\nfaces the root of a subgraph. It is ready to see that the corresponding EAL-term\nis a candidate EAL-term. Theorem 3 allows to conclude.\n(\u21d0) By Theorem 4, there is an EAL-term P such that P \u2217 = M and\nX(B) \u22a2NEAL P : X(\u0398). The NEAL-term P codes a sharing graph establishing X(B) \u22a2EAL P \u2217 : X(\u0398).\nLemma 10. Let M be a simply typeable \u03bb-term; let \u03c3 be its principal type\nschema, and let \u03c4 be any other type for M . If S (M : \u03c4 ) = h\u0398, B, Ai and A\nadmits a solution X, then S (M : \u03c3) = h\u0398\u2032 , B \u2032 , A\u2032 i and there exists X \u2032 solution\nof A\u2032 .\nProof. We have to show that it is not the case that A admits a solution and A\u2032 is\nunsolvable. Constraints are added only by contraction (43) or unification (41).\nThe former constraints depend only on the structure of the syntax tree of the\nterm and hence they are not affected by the type change. As for the latter,\nchanging \u03c4 into \u03c3 makes some unification constraints disappear. In fact, it is\npossible to decompose \u0398 in \u0398\u2032 {x1 \u2192 \u03a31 , . . . , xn \u2192 \u03a3n }. When the algorithm\nsynthesizes M : \u03c3, all unification constraints in A regarding \u03a31 . . . \u03a3n disappear,\nand we obtain A\u2032 (up to renaming). In order to prove that A\u2032 is A minus the set\nof unification constraints produced by \u03a31 . . . \u03a3n , it is sufficient to inspect the\ndefinitions of P and U . As the solution space has increased, it is not possible\nthat A\u2032 has no solution.\nCorollary 1. Let M be a simply typeable \u03bb-term and let \u03c3 be its principal type\nschema. For any basis \u0393 and EAL formula C: \u0393 \u22a2EAL M : C iff S (M : \u03c3) =\nh\u0398, B, Ai, A admits an integral solution X and there exists a substitution S\nfrom type variables to EAL-types such that S(X(B)) \u2286 \u0393 and S(X(\u0398)) = C.\nThe corollary gives a weak notion of principal type for EAL. Any EAL type\nof a term arises as an instance of a solution of the constraints obtained for its\nsimple principal type schema. The result, however, does not say anything on\nthe structure of these !-decorated instances. The study of a general notion of\nprincipal schema for EAL is the subject of [CR03]. On the other hand, the\ncorollary is enough to establish the decidability of type inference.\nTheorem 6. It is decidable whether, given a type-free \u03bb-term M , there exist\nan EAL formula C and a basis \u0393 such that \u0393 \u22a2EAL M : C.\n\n4\n\nConclusions\n\nWe have presented an algorithm for assigning EAL types to type-free, pure \u03bbterms, obtained as the (technically non trivial) elaboration of the idea of \"box\ndecoration\" of a simple type derivation. The algorithm is shown complete with\n\n39\n\n\frespect to the notion of EAL types introduced in Definition 1. If we change\nthe constraints collected by the algorithm, the same technique can be used to\nobtain linear logic derivations. Or, we may use the algorithm to infer types for\na more liberal notion of EAL-typeability.\n\n4.1\n\nLinear decorations of intuitionistic derivations\n\nThe problem to obtain linear logic derivations from intuitionistic derivations has\nbeen thoroughly studied [DJS95, Sch94, Rov92]. Our linear constraints method\ncan be used to obtain a variety of such decorations.\nThe implicational fragment of linear logic can be obtained from EAL by\nadding the rules:\n\u0393, A \u22a2 B\n\u0393, !A \u22a2 B\n\u01eb\n\u03b4\n\u0393, !A \u22a2 B\n\u0393, !!A \u22a2 B\nIntroduce now the rule (d + b)\n\u0393, !x A \u22a2 B\n\u0393, !x\u2212(d+b) A \u22a2 B\n\n(d + b)\n\n\uf8f1\nx\u22650\n\uf8f4\n\uf8f4\n\uf8f2\nd+b\u2264x\u22121\nd\n\u22650\n\uf8f4\n\uf8f4\n\uf8f3\n\u22121 \u2264 b \u2264 0,\n\nwhich acts as a multiple \u03b4 rule, except when d = 0 and b = \u22121. In this case it is\nthe same of an \u01eb rule. It is easy to prove that \u0393 \u22a2LL B iff \u0393 \u22a2LL\u2212{\u03b4,\u01eb}\u222a(d+b) B.\nExtend now the maximal decoration method as follows. After each logical rule,\ninterleave n !-rules, and then, for each formula A in the context , add one (di +bi )\nrule and ei \u01eb-rules. For example\nA, B \u22a2 C\nA\u22a2B\u22b8C\nbecomes\n\nA, B \u22a2 C\n!\n! A, !n B \u22a2!n C\nn\n\n!n\u2212(d1 +b1 ) A, !n B \u22a2!n C\n\n(b + d)\n\n!n\u2212(d1 +b1 )+e1 A, !n B \u22a2!n C\n\n\u01eb\n\n!n\u2212(d1 +b1 )+e1 A, !n\u2212(d2 +b2 ) B \u22a2!n C\n\n(b + d)\n\n!n\u2212(d1 +b1 )+e1 A, !n\u2212(d2 +b2 )+e2 B \u22a2!n C\n\n\u01eb\n\n!n\u2212(d1 +b1 )+e1 A \u22a2!n\u2212(d2 +b2 )+e2 B \u22b8!n C\nDuring the type inference, the set of constraints obtained from unification and\ncontraction is augmented by the constraints of rules (di +bi ). It is not difficult to\nsee that any solution of the set of constraints collected by the algorithm gives a\nlinear logic derivation having the original intuitionistic derivation as a skeleton.\nNotice that the meta-derivations obtained by the above procedure represents\na set of LL derivations complete for the provability of LL formulas. In fact, the\n\n40\n\n\fFigure 23: Box fusion for arbitrary contractions.\nunique derivations of LL that are not direct instances of the previous metaderivations are those where exponential rules are applied in a different order.\nHowever, it is easy to see that the rules under discussion may be freely permuted.\nFor example, if \u0393 \u22a2LL B with an application of !-rule followed by an \u01eb-rule, then\n\u0393 \u22a2LL B with inverted order of exponential rules (the proof is similar for the\nother cases).\nThe use of linear constraints allows now the use of linear programming techniques to obtainP\ndecorations\nP properties. By minimizing the obP with specific\njective function i ni + j (dj + bj ) + k ek , we obtain decorations using a\nminimal numberP\nof boxes. Or, we\nP may minimize only the use of \u01eb and \u03b4 rules,\n(d\n+\nb\n)\n+\nif we minimize\nj\nk ek . In the language of optimal reduction,\nj j\nthese are decorations introducing a minimal number of brackets and croissants,\nand are thus the natural candidates to be used as initial translations for those\n\u03bb-terms which does not have an EAL type.\n\n4.2\n\nArbitrary contractions\n\nInstead of using Definition 1, we may would like an algorithm complete with\nrespect to the notion given directly by Figure 1, that is, allowing arbitrary contractions (and not only variable contractions) in the sharing graphs. Proceed as\nfollows. Given a generic sharing graph, first decompose it into several subgraphs\nwith the property that no fan faces a subgraph; than readback them, obtaining\na set of lambda-terms. For example, the graph of Figure 4 of Section 1 can\nbe decomposed in \u03bbz.\u03bbx.\u03bbw.(k k w) and (x z). After the decomposition, call\nthe type synthesis algorithm separately on every subterm, calculate the suitable\nunification constraints with U , collect all the constraints in a single system, and\nsolve it.\nThis procedure computes all possible decorations, except those boxes that\nsurround more than one subterm. However, the proof of the superimposing\nlemma allows to conclude that there is a decoration with a box around more\nthan one subterm if and only if there exists a decoration with boxes only around\na single subterm, with the same type (see Figure 23 for a graphical intuition).\n\n41\n\n\fAcknowledgments\nWe are happy to thank Harry Mairson, for extended comments and criticism on\nprevious versions of the paper; and Simona Ronchi della Rocca, for the many\ndiscussions, suggestions, and comments.\n\nReferences\n[ACM00]\n\nAndrea Asperti, Paolo Coppola, and Simone Martini. (Optimal)\nduplication is not elementary recursive. In Proceedings of the 27th\nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POLP-00), pages 96\u2013107, N.Y., January 19\u201321\n2000. ACM Press.\n\n[AG98]\n\nAndrea Asperti and Stefano Guerrini. The Optimal Implementation of Functional Programming Languages, volume 45 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1998.\n\n[Asp98]\n\nAndrea Asperti. Light affine logic. In IEEE Computer Society,\neditor, Proc. of Symposium on Logic in Computer Science, pages\n300\u2013308, Indianapolis, Indiana, 1998.\n\n[Bai02]\n\nPatrick Baillot. Checking Polynomial Time Complexity with\nTypes. In Proc. of 2nd IFIP International Conference on Theoretical Computer Science (TCS 2002), volume 223 of IFIP Conference\nProceedings, pages 370\u2013382, Montr\u00e9al, Qu\u00e9bec, Canada, aug 2002.\n\n[Bai03]\n\nPatrick Baillot. Type inference for polynomial time complexity via\nconstraints on words. Technical report, Laboratoire d'Informatique\nde Paris Nord, Universit\u00e9 Paris 13, Institut Galil\u00e9e, 2003.\n\n[BBdPH93] Nick Benton, Gavin Bierman, Valeria de Paiva, and Martin Hyland.\nA term calculus for intuitionistic linear logic. In M. Benzen and\nJ.F. Groote, editors, Typed Lambda Calculus and Applications. Int.\nConference on Typed Lambda Calculus and Applications, TLCA'93,\nvolume 664 of Lecture Notes in Computer Science, pages 75\u201390,\nMarch 1993.\n[CM01]\n\nPaolo Coppola and Simone Martini. Typing Lambda Terms in Elementary Logic with Linear Constraints. In Samson Abramsky,\neditor, Proc. of Typed Lambda Calculi and Applications, 5th International Conference, TLCA 2001, volume 2044 of Lecture Notes in\nComputer Science, pages 76\u201390. Springer, May 2001.\n\n[CR03]\n\nP. Coppola and S. Ronchi Della Rocca. Principal Typing in Elementary Affine Logic. In Proc. of Typed Lambda Calculi and Ap-\n\n42\n\n\fplications, 6th International Conference, TLCA 2003, 2003. To\nappear.\n[DJS95]\n\nVincent Danos, Jean-Baptiste Joinet, and Harold Schellinx. On\nthe linear decoration of intuitionistic derivations. In Archive for\nMathematical Logic, volume 33, pages 387\u2013412, 1995.\n\n[Gir98]\n\nJean-Yves Girard. Light linear logic. Information and Computation, 204(2):143\u2013175, 1998.\n\n[Kat90]\n\nVinod K. Kathail. Optimal Interpreters for Lambda-calculus Based\nFunctional Programming Languages. PhD thesis, MIT, May 1990.\n\n[Lam90]\n\nJ. Lamping. An algorithm for optimal lambda calculus reduction.\nIn ACM, editor, POPL '90. Proceedings of the seventeenth annual\nACM symposium on Principles of programming languages, January\n17\u201319, 1990, San Francisco, CA, pages 16\u201330, New York, NY, USA,\n1990. ACM Press.\n\n[L\u00e9v80]\n\nJean-Jacques L\u00e9vy. Optimal reductions in the lambda-calculus. In\nJonathan P. Seldin and J. Roger Hindley, editors, To H. B. Curry:\nEssays on Combinatory Logic, Lambda Calculus and Formalism,\npages 159\u2013191. Academic Press, London, 1980.\n\n[Mai92]\n\nHarry G. Mairson. A simple proof of a theorem of Statman. Theoretical Computer Science, 103(2):387\u2013394, September 1992.\n\n[Pra65]\n\nDag Prawitz. Natural Deduction. Almqvist & Wiksell, 1965.\n\n[Rov92]\n\nL. Roversi. A compiler from Curry-typed \u03bb-terms to linear-\u03bb-terms.\nIn Theoretical Computer Science: Proceedings of the Fourth Italian\nConference, pages 330 \u2013 344, L'Aquila (Italy), October 1992. World\nScientific.\n\n[Rov98]\n\nLuca Roversi. A Polymorphic Language which is Typable and Polystep. In Proceedings of the Asian Computing Science Conference\n(ASIAN'98), volume 1538 of Lecture Notes in Computer Science,\npages 43 \u2013 60, Manila (The Philippines), December 1998. Springer\nVerlag.\n\n[Sch94]\n\nHarold Schellinx. The Noble Art of Linear Decorating. PhD thesis, Institute for Logic, Language and Computation, University of\nAmsterdam, 1994.\n\nA\n\nAppendix\n\nWe have already observed that the simply typed lambda term\n(\u03bbn.(n \u03bby.(n \u03bbz.y)) \u03bbx.(x (x y))) : o\n43\n\n\fis not typeable in EAL. If one knows optimal reduction [AG98] , this can be\nseen in a simple way, writing the term as a sharing graph and reducing it in the\nabstract algorithm by matching fans by labels (see Figure 24 where the redexes\nfired at every step are indicated by a dashed oval). The sharing graph in normal\nform is a cycle, that is a sharing graph which does not correspond to any \u03bb-term\n(least to say to y, which is the normal form of the given term). This means that\nthe oracle is needed for the reduction of this term, and hence it cannot have a\ntype in EAL.\n\n@\n\n@\n\u03bb\n\n\u03bb\n\n\u03bb\n\n@\n\n\u25e6\nA\n\n\u25e6\nB\n\nA \u22c6\n\n\u03bb\n\n\u03bb\n\n\u25e6\n\n\u2297\n\n\u03bb\n\n@\n@\n\n\u2297\n\n\u25e6\n\n@\ny\n\n\u22c6\n\n\u25e6 A\n\u22c6\n\nA\n\n\u25e6\n\n@\nA\n\n\u25e6\n\u25e6\n\n\u22c6\u25e6 A \u22c6\n\nA\n\n\u22c6\n\n@\n\n@\n\u25e6\n\n@\n\u25e6\n\ny\n\nA\n\nB \u22c6\u25e6 B \u22c6\n\n@\n\u22c6\n\nB\n\n\u22c6\n\n\u03bb\n\u25e6\n@\n\n\u03bb\n\n\u03bb\n\n\u22c6\n\n\u22c6\n\nA\n\n\u25e6\n@\n\n\u22c6\n\nB\n\n\u25e6\nB\n\n\u2297\n\n\u25e6\n\nB\n\n\u25e6\n\n\u22c6\n\nB\n\n\u22c6\n\nA\n\n\u22c6\n@\n\n@\n\u25e6\n\nA\n\n\u22c6\n\n@\n\n\u25e6\nB \u22c6\n\n\u03bb\n\n\u03bb\n\u2297\n\ny\n\n\u03bb\n\n\u22c6\n\nA\n\n\u25e6\n\ny\n\n\u2297\n\n@\n@\n\n\u03bb\n\u03bb\n\n\u25e6\n\n\u25e6\n\n\u22c6\n\nB\n\n\u03bb\n\n@\n\ny\n\n\u03bb\nB\n\n\u2297\n\u22c6\n\n\u22c6\n\u2297\n\u2297\n\u22c6 A \u25e6\n\n@\n\u2297\n\u25e6\n\nB\n\n\u22c6\n\nA\n\n\u25e6\n\ny\n\u25e6 B\n\n\u22c6\n\nFigure 24: Incorrect reduction of (\u03bbn.(n \u03bby.(n \u03bbz.y)) \u03bbx.(x (x y))).\n\n44\n\n\u03bb\n\u2297\n\nA \u22c6\n\n@\n\n\u03bb\n\n\u25e6\n\n@\n\n\u03bb\n\n\u22c6\n\ny\n\n\u22c6\n\n@\n\u25e6\n\n\u03bb\n\n@\n\n@\n@\n\u03bb\n\n@\n\ny\n\n\fWe can give a formal proof, by calling the type inference algorithm on such\na term. The following is a trace of the execution, where each box delimits the\ncall and return of a single type inference rule:\nS(\u03bbn.(n \u03bby.(n \u03bbz.y)) \u03bbx.(x (x y))) : o)\nS(\u03bbn.(n \u03bby.(n \u03bbz.y)) : ((o \u2192 o) \u2192 o) \u2192 o)\nS((n \u03bby.(n \u03bbz.y)) : o)\nS(n : (o \u2192 o) \u2192 o)\nP((o \u2192 o) \u2192 o) = p1 (p2 (p3 \u22b8 p4 ) \u22b8 p5 )\n= hp1 (p2 (p3 \u22b8 p4 ) \u22b8 p5 ), {n : p1 (p2 (p3 \u22b8 p4 ) \u22b8 p5 )}, \u2205, \u2205i\nS(\u03bby.(n\u03bbz.y) : o \u2192 o)\nS((n \u03bbz.y) : o)\nS(n : (o \u2192 o) \u2192 o)\nP((o \u2192 o) \u2192 o) = p6 (p7 (p8 \u22b8 p9 ) \u22b8 p10 )\n= hp6 (p7 (p8 \u22b8 p9 ) \u22b8 p10 ), {n : p6 (p7 (p8 \u22b8 p9 ) \u22b8 p10 )}, \u2205, \u2205i\nS(\u03bbz.y : o \u2192 o)\nS(y : o)\nP(o) = p11\n= hp11 , {y : p11 }, \u2205, \u2205i\nB(y, {y : p11 }, p11 , \u2205, \u2205) = h{y : p11 }, p11 , \u2205i\nP(\u03b1) = p12\n= hp12 \u22b8 p11 , {y : p11 }, \u2205, \u2205i\nB(\u03bbz.y, {y : p11 }, p12 \u22b8 p11 , \u2205, \u2205)\nB({y : p11 }, p12 \u22b8 p11 , \u2205, \u2205) = h{y : p11 }, p12 \u22b8 p11 , \u2205i\n= h{y : b1 + p11 }, b1 (p12 \u22b8 p11 ), \u2205i\n\uf8f1\n\uf8f2 p7 = b 1\nU (p7 (p8 \u22b8 p9 ), b1 (p12 \u22b8 p11 )) =\np8 = p12\n\uf8f3\np9 = p11\n\uf8f1\np7 = b 1\n\uf8f4\n*\n+\n\uf8f4\n\uf8f2\np8 = p12\n= p10 , {n : p6 (p7 (p8 \u22b8 p9 ) \u22b8 p10 ), y : b1 + p11 },\n,\u2205\np9 = p11\n\uf8f4\n\uf8f4\n\uf8f3\np6 = 0\n= hp10 , {n : b1 (p8 \u22b8 p9 ) \u22b8 p10 , y : b1 + p9 }, \u2205, \u2205i\nB((n \u03bbz.y), {n : b1 (p8 \u22b8 p9 ) \u22b8 p10 , y : b1 + p9 }, p10 , \u2205, \u2205)\n= h{n : b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 ), y : b2 + b1 + p9 }, b2 + p10 , \u2205i\nC(b2 + b1 + p9 ) = \u2205\n= hb2 + b1 + p9 \u22b8 b2 + p10 , {n : b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )}, \u2205, \u2205i\nB(\u03bby.(n \u03bbz.y), {n : b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )}, b2 + b1 + p9 \u22b8 b2 + p10 , \u2205, \u2205)\n= h{n : b3 + b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )}, b3 (b2 + b\uf8f1\n1 + p9 \u22b8 b2 + p10 ), \u2205i\n\uf8f2 p2 = b 3\np3 = b 2 + b 1 + p9\nU (p2 (p3 \u22b8 p4 ), b3 (b2 + b1 + p9 \u22b8 b2 + p10 )) =\n\uf8f3\np4 = b2 + p10\n\n45\n\n\f\uf8f1\np2 = b 3\n+\n\uf8f4\n\u001b \uf8f4\n\uf8f2\np3 = b 2 + b 1 + p9\nn : p1 (p2 (p3 \u22b8 p4 ) \u22b8 p5 ),\n= p5 ,\n,\n,\u2205\np4 = b2 + p10\nn : b3 + b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )\n\uf8f4\n\uf8f4\n\uf8f3\np\u001b1 = 0 \u001d\n\u001c \u001a\nn : b3 (b2 + b1 + p9 \u22b8 b2 + p10 ) \u22b8 p5 ,\n= p5 ,\n, \u2205, \u2205\nn : b3 + \u001a\nb2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )\n\u0012\n\u001b\n\u0013\nn : b3 (b2 + b1 + p9 \u22b8 b2 + p10 ) \u22b8 p5 ,\nB (n \u03bby.(n \u03bbz.y)),\n, p5 , \u2205, \u2205\nn : b3 + b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10\n\u001c\u001a\n\u001b)\n\u001d\nn : b4 (b3 (b2 + b1 + p9 \u22b8 b2 + p10 ) \u22b8 p5 ),\n=\n, b 4 + p5 , \u2205\nn : b4 + b3 + b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 )\nC(b4 (b3 (b2 + b1 + p9 \u22b8 b2 + p10 ) \uf8f1\n\u22b8 p5 ), b4 + b3 + b2 (b1 (p8 \u22b8 p9 ) \u22b8 p10 ))\n\uf8f1\n\uf8f4\n\uf8f4 b4 \u2265 1\nb4 \u2265 1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4 b4 = b4 + b3 + b2\n\uf8f4 b3 = 0\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\uf8f2 b2 = 0\nb3 = b1\n=\nb1 = 0\n=\nb 2 + b 1 + p9 = p8\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4 b2 + p10 = p9\n\uf8f4 p8 = p5\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f3\n\uf8f4\n\uf8f4 p9 = p5\np5 = p10\n\uf8f3\np10 = p5\n= hb4 ((p5 \u22b8 p5 ) \u22b8 p5 ) \u22b8 b4 + p5 , \u2205, {b4 \u2265 1}, \u2205i\nS(\u03bbx.(x (x y)) : (o \u2192 o) \u2192 o)\nS((x (x y)) : o)\nS(x : o \u2192 o)\n= hp1 (p2 \u22b8 p3 ), {x : p1 (p2 \u22b8 p3 )}, \u2205, \u2205i\nS((x y) : o)\nS(x : o \u2192 o)\n= hp4 (p6 \u22b8 p7 ), {x : p4 (p6 \u22b8 p7 )}, \u2205, \u2205i\nS(y : o)\n= hp8 , {y : p8 }, \u2205, \u2205i\nU (p6 , p8 ) = {p6 = p8 }\n= hp7 , {x : p6 \u22b8 p7 , y : p6 }, \u2205, \u2205i\nB((x y), {x : p6 \u22b8 p7 , y : p6 }, p7 , \u2205, \u2205)\n= h{x : b1 (p6 \u22b8 p7 ), y : b1 + p6 }, b1 + p7 , \u2205i\nU (b1 +\u001a\u0012\np7 , p2 ) = {b1 + p7 \u2212\u001ap2 = 0}\n\u001b\u0013\u001b\nx : b1 (p6 \u22b8 p7 ),\ncpts =\nb1 + p7 \u2212 p2 = 0,\n\uf8fc y : b 1 + p6\n* \uf8f1\n+\nx\n:\np\n\u22b8\np\n,\n\uf8f2\n\uf8fd\n2\n3\nx : b1 (p6 \u22b8 p7 ),\n= p3 ,\n, {b1 + p7 \u2212 p2 = 0}, cpts\n\uf8f3\n\uf8fe\ny\n:\nb\n+\np\n6\n\uf8f11\n\uf8fc\n\uf8eb\n\uf8f6\n\uf8f2 x : p2 \u22b8 p3 ,\n\uf8fd\nx : b1 (p6 \u22b8 p7 ),\nB\uf8ed(x (x y)),\n, p3 , cpts, {b1 + p7 \u2212 p2 = 0}\uf8f8\n\uf8f3\n\uf8fe\ny\n:\nb\n+\np\n1\n6\uf8fc\n\uf8eb\uf8f1\n\uf8f6\n\uf8f2 x : p2 \u22b8 p3 ,\n\uf8fd\nB \uf8ed x : b1 (p6 \u22b8 p7 ),\n, p3 , cpts, {b1 + p7 \u2212 p2 = 0}\uf8f8\n\uf8f3\n\uf8fe\ny : b 1 + p6\n*\n\n\u001a\n\n46\n\n\f\uf8fc\n*\uf8f1\n+\n\uf8f2 x : b2 (p2 \u22b8 p3 ), \uf8fd\nx : b1 (p6 \u22b8 p7 ),\n=\n, b2 + p3 , {b1 + p7 \u2212 p2 \u2212 b2 = 0}\n\uf8f3\n\uf8fe\ny\n:\nb\n+\np\n1\n6\n\uf8fc\n*\uf8f1\n+\n\uf8f2 x : b3 + b2 (p2 \u22b8 p3 ), \uf8fd\nx : b3 + b1 (p6 \u22b8 p7 ),\n=\n, b3 + b2 + p3 , {b1 + p7 \u2212 p2 \u2212 b2 = 0}\n\uf8f3\n\uf8fe\ny : b 3 + b 1 + p6\n\uf8f1\n\uf8f1\nb3 + b2 \u2265 1\nb3 + b2 \u2265 1\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2\n\uf8f2\nb2 = b1\nb3 + b2 = b3 + b1\n=\nC(b3 + b2 (p2 \u22b8 p3 ), b3 + b1 (p6 \u22b8 p7 )) =\np\np\n=\np\n\uf8f4\n\uf8f4\n2\n6\n\uf8f4 2 = p6\n\uf8f4\n\uf8f3\n\uf8f3\np3 = p7\np3 = p7\nb\uf8f13 + b2 (p2 \u22b8 p3 ) \u22b8 b3 + b2 + p3 , {y : b3 + b1 + p6 },\nb 1 + p7 \u2212 p2 \u2212 b 2 = 0\n+\n* \uf8f4\n\uf8f4\n\uf8f4\n\uf8f4\n\uf8f2 b3 + b2 \u2265 1\n=\nb2 = b1\n,\n\u2205\n\uf8f4\n\uf8f4\np\n=\np\n\uf8f4\n2\n6\n\uf8f4\n\uf8f3\np3 = p7\n= hb3 + b1 (p2 \u22b8 p2 ) \u22b8 b3 + b1 + p2 , {y : b3 + b1 + p2 }, {b3 + b1 \u2265 1}, \u2205i\nB(\u03bbx.(x (x y)), {y : b3 + b1 + p2 }, b3 + b1 (p2 \u22b8 p2 ) \u22b8 b3 + b1 + p2 , \u2205, {b3 + b1 \u2265 1})\n= h{y : b2 + b3 + b1 + p2 }, b2 (b3 + b1 (p2 \u22b8 p2 ) \u22b8 b3 + b1 + p2 ), {b3 + b1 \u2265 1}i\nU (b4\uf8f1\n((p5 \u22b8 p5 ) \u22b8 p5 , b2 (b3 +\uf8f1b1 (p2 \u22b8 p2 ) \u22b8 b3 + b1 + p2 ))\n\uf8f2 b4 = b2\n\uf8f2 b4 = b2\np5 = p2\np5 = p2\n=\n=\n\uf8f3\n\uf8f3\np5 = b 3 + b 1 + p2\nb3 + b1 = 0\n\nNotice that the last constraint b3 + b1 = 0 is incompatible with the previous\nb3 + b1 \u2265 1 hence the set of solutions is empty.\n\n47\n\n\f"}