{"id": "http://arxiv.org/abs/0902.1871v1", "guidislink": true, "updated": "2009-02-11T12:46:17Z", "updated_parsed": [2009, 2, 11, 12, 46, 17, 2, 42, 0], "published": "2009-02-11T12:46:17Z", "published_parsed": [2009, 2, 11, 12, 46, 17, 2, 42, 0], "title": "Abstraction and Refinement in Static Model-Checking", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0902.2769%2C0902.4454%2C0902.2347%2C0902.4396%2C0902.1471%2C0902.1939%2C0902.3687%2C0902.2866%2C0902.4773%2C0902.4349%2C0902.0098%2C0902.4851%2C0902.2262%2C0902.2228%2C0902.4373%2C0902.3668%2C0902.0003%2C0902.4632%2C0902.3901%2C0902.2129%2C0902.2230%2C0902.1904%2C0902.0898%2C0902.1949%2C0902.1466%2C0902.3929%2C0902.3349%2C0902.3482%2C0902.3029%2C0902.2931%2C0902.2220%2C0902.3007%2C0902.3177%2C0902.0520%2C0902.2084%2C0902.3157%2C0902.1798%2C0902.2193%2C0902.0569%2C0902.1075%2C0902.4043%2C0902.3170%2C0902.4532%2C0902.2772%2C0902.0308%2C0902.1621%2C0902.2094%2C0902.1618%2C0902.1486%2C0902.1303%2C0902.1671%2C0902.1678%2C0902.3022%2C0902.2453%2C0902.4104%2C0902.0721%2C0902.1848%2C0902.3179%2C0902.0923%2C0902.4277%2C0902.2475%2C0902.1871%2C0902.2656%2C0902.0477%2C0902.1203%2C0902.4691%2C0902.1776%2C0902.3232%2C0902.1421%2C0902.4791%2C0902.1246%2C0902.4322%2C0902.3333%2C0902.1236%2C0902.4732%2C0902.0445%2C0902.3433%2C0902.0173%2C0902.4860%2C0902.0451%2C0902.0340%2C0902.3415%2C0902.4884%2C0902.2281%2C0902.3430%2C0902.4590%2C0902.3238%2C0902.4679%2C0902.1462%2C0902.0032%2C0902.1287%2C0902.3262%2C0902.0295%2C0902.0928%2C0902.0921%2C0902.0214%2C0902.1866%2C0902.4666%2C0902.4650%2C0902.4481%2C0902.1319&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "Abstraction and Refinement in Static Model-Checking"}, "summary": "interpretation is a general methodology for building static analyses of\nprograms. It was introduced by P. and R. Cousot in \\cite{cc}. We present, in\nthis paper, an application of a generic abstract interpretation to domain of\nmodel-checking. Dynamic checking are usually easier to use, because the concept\nare establishe d and wide well know. But they are usually limited to systems\nwhose states space is finite. In an other part, certain faults cannot be\ndetected dynamically, even by keeping track of the history of the states\nspace.Indeed, the classical problem of finding the right test cases is far from\ntrivial and limit the abilities of dynamic checkers further. Static checking\nhave the advantage that they work on a more abstract level than dynamic checker\nand can verify system properties for all inputs. Problem, it is hard to\nguarantee that a violation of a modeled property corresponds to a fault in the\nconcrete system. We propose an approach, in which we generate counter-examples\ndynamically using the abstract interpretation techniques.", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=&id_list=0902.2769%2C0902.4454%2C0902.2347%2C0902.4396%2C0902.1471%2C0902.1939%2C0902.3687%2C0902.2866%2C0902.4773%2C0902.4349%2C0902.0098%2C0902.4851%2C0902.2262%2C0902.2228%2C0902.4373%2C0902.3668%2C0902.0003%2C0902.4632%2C0902.3901%2C0902.2129%2C0902.2230%2C0902.1904%2C0902.0898%2C0902.1949%2C0902.1466%2C0902.3929%2C0902.3349%2C0902.3482%2C0902.3029%2C0902.2931%2C0902.2220%2C0902.3007%2C0902.3177%2C0902.0520%2C0902.2084%2C0902.3157%2C0902.1798%2C0902.2193%2C0902.0569%2C0902.1075%2C0902.4043%2C0902.3170%2C0902.4532%2C0902.2772%2C0902.0308%2C0902.1621%2C0902.2094%2C0902.1618%2C0902.1486%2C0902.1303%2C0902.1671%2C0902.1678%2C0902.3022%2C0902.2453%2C0902.4104%2C0902.0721%2C0902.1848%2C0902.3179%2C0902.0923%2C0902.4277%2C0902.2475%2C0902.1871%2C0902.2656%2C0902.0477%2C0902.1203%2C0902.4691%2C0902.1776%2C0902.3232%2C0902.1421%2C0902.4791%2C0902.1246%2C0902.4322%2C0902.3333%2C0902.1236%2C0902.4732%2C0902.0445%2C0902.3433%2C0902.0173%2C0902.4860%2C0902.0451%2C0902.0340%2C0902.3415%2C0902.4884%2C0902.2281%2C0902.3430%2C0902.4590%2C0902.3238%2C0902.4679%2C0902.1462%2C0902.0032%2C0902.1287%2C0902.3262%2C0902.0295%2C0902.0928%2C0902.0921%2C0902.0214%2C0902.1866%2C0902.4666%2C0902.4650%2C0902.4481%2C0902.1319&start=0&max_results=1000&sortBy=relevance&sortOrder=descending", "value": "interpretation is a general methodology for building static analyses of\nprograms. It was introduced by P. and R. Cousot in \\cite{cc}. We present, in\nthis paper, an application of a generic abstract interpretation to domain of\nmodel-checking. Dynamic checking are usually easier to use, because the concept\nare establishe d and wide well know. But they are usually limited to systems\nwhose states space is finite. In an other part, certain faults cannot be\ndetected dynamically, even by keeping track of the history of the states\nspace.Indeed, the classical problem of finding the right test cases is far from\ntrivial and limit the abilities of dynamic checkers further. Static checking\nhave the advantage that they work on a more abstract level than dynamic checker\nand can verify system properties for all inputs. Problem, it is hard to\nguarantee that a violation of a modeled property corresponds to a fault in the\nconcrete system. We propose an approach, in which we generate counter-examples\ndynamically using the abstract interpretation techniques."}, "authors": ["Kaninda Musumbu"], "author_detail": {"name": "Kaninda Musumbu"}, "author": "Kaninda Musumbu", "links": [{"href": "http://arxiv.org/abs/0902.1871v1", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/0902.1871v1", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.DS", "scheme": "http://arxiv.org/schemas/atom", "label": null}, {"term": "cs.SC", "scheme": "http://arxiv.org/schemas/atom", "label": null}], "pdf_url": "http://arxiv.org/pdf/0902.1871v1", "affiliation": "LaBRI", "arxiv_url": "http://arxiv.org/abs/0902.1871v1", "arxiv_comment": null, "journal_reference": "IEEE-Computer Society International Conference on Computer Science\n  and Information Technology, ICCSIT-2008 (2008) 107 - 112", "doi": null, "fulltext": "Abstraction and Refinement in Static Model-Checking\n\narXiv:0902.1871v1 [cs.DS] 11 Feb 2009\n\nKaninda Musumbu\nLaBRI (UMR 5800 du CNRS),\nUniversit\u00e9 Bordeaux 1, France\n351, cours de la Lib\u00e9ration, F-33.405 TALENCE Cedex\ne-mail: musumbu@labri.fr\nAbstract- Abstract interpretation is a general methodology\nfor building static analyses of programs. It was introduced by P.\nand R. Cousot in [3]. We present, in this paper, an application of\na generic abstract interpretation to domain of model-checking.\nDynamic checking are usually easier to use, because the concept\nare established and wide well know. But they are usually limited\nto systems whose states space is finite. In an other part, certain\nfaults cannot be detected dynamically, even by keeping track\nof the history of the states space.Indeed, the classical problem\nof finding the right test cases is far from trivial and limit\nthe abilities of dynamic checkers further. Static checking have\nthe advantage that they work on a more abstract level than\ndynamic checker and can verify system properties for all inputs.\nProblem, it is hard to guarantee that a violation of a modeled\nproperty corresponds to a fault in the concrete system. We\npropose an approach, in which we generate counter-examples\ndynamically using the abstract interpretation techniques.\n\na) Keywords: static analysis, model-checking, abstract\ninterpetation, refinement\nI. I NTRODUCTION\nBeing given that the number of state of a model believes\nin an exponential way with the number of variables and\ncomponents of the system, the model-checking became complicated to treat in an automatic way. In order to make this\nwork realizable, it is necessary to reduce the sizes of these\nmodels with an aim of reaching time and reasonable memory\ncapacities. The techniques of reduction seek to suppress\nthe harmful effects of the combative explosion. When the\ngraphs of behavior comprise several million or milliards of\nstates and transitions, the physical limits of the memory are\nquickly reached. It is then necessary to resort to techniques\ncompressions of the graphs of behavior. Most known is based\non the BDD (Binary Decision Diagrams). At the enumeration\ntime, to decide if a reached state was already met requires\nto traverse the explored part of the graph. This subgraph,\nwhich does not cease growing bigger, must be arranged\nin the read-write memory. The limits of this memory are\nquickly exceeded and the implementation of algorithms of\npagination know a considerable fall of performances. The\nmethods of abstraction make it possible to eliminate the\nproliferation from different states(ones from the other) by\npossibly unimportant details within sight of the properties\nto be checked. It is essential that the small-scale model\npreserve sufficient information to produce the same results\nas the models of origin and to preserve the same properties\nthat one wishes to check. These two exigences must be\nconsidered with attention at the time of the generation of a\n\nabstract model starting from a concrete model. To conceive a\n\"good\" method of reduction consists to produce a reduction\nrelation verifying three criteria: an important reduction ratio,\na relation of strong preservation and an easy deduction of\nthe relation of reduction starting from the description of the\nsystem, the ideal being the construction of the reduced graph\ndirectly starting from the description. The way whose details\nof the abstraction will be selected for the checking can be\nmade in an automatic or manual way. The manual technique\nincludes abstract interpretations selected by the user. The\nabstractions considered generally preserve the properties in\na weak way, which means that they are only preserved\nabstracted model with the concrete model. Thus, if one can\nguarantee that a property is checked, that is different with\nits negation. The abstract interpretation is a methodology\naiming at defining, analyzes and justifier your techniques\nof approximate computation of properties of systems in [3].\nWhatever the semantics may be used. It then consists in\nplacing the analysis not in the concrete domain but in a\nabstract domain, (simplified and limited) which conserves the\nsearch properties, the major disadvantage is that the results\nare in general less precise and that one needs accommodate\napproximations of the properties. In our paper, we present a\ntechnique of abstraction called abstraction by predicate of a\nrefinement to reduce the generality and the minimality of the\nanalysis, thus a violation of a property detected on one of\nabstract path has a strong probability of existing on a path of\nthe concrete model. Analysis is made at the global state space\nlevel: traversal algorithm (similar to the one used to build\nthe state space) is used to check out deadlock, livelock or\ndivergent states. Example pathes starting from the initial state\nand leading to a deadlock, livelock or divergent state can be\nextracted. To this end, we have to collect during the search of\nthese special states the intermediate state sets reached before\nthem. verication is based on bisimulation minimizations and\ncomparisons .\n\nII. G ENERALITY\n\nSmall Example: The rule of Signs\n\n\f\u223c\n\n\u00d7\n\n+\n\n0\n\n+\n\n+\n\n0\n\n\u2212\n\n0\n\n0\n\n0\n\n0\n\n\u2212\n\n\u2212\n\n0\n\n+\n\nD. Semantics\n\n\u2212\n\nIts definition has two view points:\n\u2022 Theoretical associates a meaning to objects handled by\nthe programs.\n\u2022 Piratical associates a program a semantic function (\nstomata).\n\u03c4\n< P, e >\u2212\u2192< P \u2032 , e\u2032 >\nP = \u03c4 .P \u2032 and e\u2032 = \u03c4 (e)\n\nSuch that the following diagram commutates\n\n\u03c4 is a transition related. Note:\n\n\u223c\n\nSgn \u00d7 Sgn\n\n\u00d7\n\n\u2732 Sgn\n\n\u03c4 [P](e0 ) = cal\n\n\u273b\n\n\u03b1\n\nInt \u00d7 Int\n\n\u03b3\n\u2744\n\n\u00d7\n\n\u2732 Int\n\nConsistency (soundness):\n\u223c\n\n\u2200x, y \u2208 Int : X \u00d7 y \u2208 \u03b3 (\u03b1 (x) \u00d7 \u03b1 (y))\n\nA. Definition\nAbstract Interpretation is a general methodologies for\nautomatic analysis of the run-time properties of system..\nThe problem is that the exact analysis may be very expensive, sometimes through decidable properties may be NPcomplete. The idea is to find a decidable approximation\nwhich is soundness and calculable.\nB. Mathematical theory of Abstract Interpretation\nOften, AI refers to the concept of connection galoisienne\na 4-tuple (C, A, \u03b1 , \u03b3 ) where C and A are complete lattices ,\n\u03b3 : A \u2192 C and \u03b1 : C \u2192 A are monotonous functions\nsuch as:\n\u2200\u03b2 \u2208 a : \u03b1 (\u03b3 (\u03b2 )) = \u03b2 ,\n\u2200C \u2208 C : \u03b3 (\u03b1 (c)) \u2265 C.\nImpossible into practice of generating and analyzing all\npossible traces of execution for a given program .\nC. Motivation\nAbstract interpretation is based on three fundamental ideas\n:\nabstract domain, abstract operators and point fixes computation Abstract domain and abstract operators are used to\ncarry out a program on abstract values. Computation of the\nfixed point: directs the process on abstract values (define\nin a certain way the semantics of the program) Objective:\nTo obtain information on the execution and the results of\nprogram. Provided that the abstract domain and operators\nsatisfy certain constraints.\n\n\u2022\n\nif cal =< , en > then the results of the program are the\nvalues of variables in the last state.\nDenotational\n\n\u03c4 : (D \u2212\u2192 D) \u2212\u2192 (D \u2212\u2192 D)\n\u03c4 = \u03bb f .\u03bb x.( if p(x) then x else f (h(x)) fi\nwhere p is a predicate , h any function. Example\nF91McCarthy:\n\n\u03c4 = \u03bb f .\u03bb x.( if x > 100 then x \u2212 10 else f ( f (x + 11) fi\n1) Abstract Domain: : Any program P handles data which\nbelong to a Ds domain says standard. To make abstract\ninterpretation will consist in choosing an abstraction of data\nDabs First Approach\n\n\u03b8 = {x1 \u2190 t1 , . . . , xn \u2190 tn }\n\u03b2 approximates \u03b8 iff\n\u03b2 = {x1 \u2190 prop(t1 ), . . . , xn \u2190 prop(tn )}\nthis define concretes semantics\nMore often no-calculable.\nConstruction process P can be consider like a partial function\nof\nn\nP : Dm\ns \u2212\u2192 Ds , n, m0\nExample: function of McCarty known as function91\nF91(x) = if x > 100 then x \u2212 10 else F91(F91(x + 11))\nint F91(int x)\nint F;\nif (x >100) f =x-10;\nelse f=F95(F95(x+11));\nreturn F;\nint F91McCarthy(void){\nint x;\nscanf(&x);\nprintf(\"value of F91 of %d = %d \",\nx, F95(x));\nexit(0);\n}\n\n\fNote:: There is not a proof of termination of F91McCarthy,\n\u2200X \u2208 Z\nThe idea is to replace Z by its power set P(Z ).\nWe get the following definition:\nF91(X) = {x \u2212 10 : x > 100 \u2227 x \u2208 X \u2286 Z}\u222a\nF91(F91({x + 11 : x \u2264 100 \u2227 x \u2208 X \u2286 Z}))\nIt is easy to show that F91(C1 ) = C2 verifies the condition:\n\u2200x \u2208 C1 \u2203y \u2208 C2 : y = f (x)\nNote:: the calculation of such function is too expensive\nfor simple value, the definition of the operations on a such\ndomain is too complex.\n\n\u2200Ii , I j \u2208 Da : Ii = [s..t], I j = [s\u2032 ..t \u2032 ] \u21d2\nIi \u222a I j = lub(Ii , I j ) = [min(s)..max(t, you)],\nThe abstract calculus:\nFa 91([\u2212\u221e.. + \u221e]) = [91, +\u221e] \u222a Fa91(Fa 91([\u2212\u221e.., 111]))\nFa 91([\u2212\u221e..111]) = [91, 101] \u222a Fa91(Fa91([\u2212\u221e.., 111]))\nNote:: The set of functions of Da \u2212\u2192 Da can be provided\nwith an order f \u2264 G iff \u2200I \u2208 Da : f (I) \u2286 g(I)\nThe fixpoints calculus: it is useful at the time of the\nrecursive calls, to ensure the termination while proceeding\nby successive approximations.\nc) Complete lattice:\na lattice iff \u2203\u22a5 \u2208 D and \u2203\u22a4 \u2208 D\n\u2022 complete iff\n\u2013 \u2200X \u2286 D\u2203U \u2208 D : \u2200X \u2208 Xx \u2264 U and\n\u2013 \u2200X \u2286 D\u2203L \u2208 D : \u2200X \u2208 Xx \u2265 L\nIt is obvious thats (D, \u2264) satisfy this conditions.\nd) Monotonicity and continuity: Let A be a complete\nlattice with a partial order \u2264 and T : A \u2212\u2192 A a transformation\n\u2022 T is monotonous iff \u2200X, y \u2208 a : X \u2264 y \u21d2 T (x) \u2264 T (y)\n\u2022 T is continuous iff \u2200X \u2286 a : T (lub(X)) = lub(T (X))\nThe transformation that we consider is a functional from a\nset of function in i ts self.\n\u2022\n\nSecond Approach\nTo choose \"a good\" system of representation of properties\n\n\u03b2 = {x1 \u2190 \u03b1 (prop(t1 )), . . . , xn \u2190 \u03b1 (prop(tn ))}\nChoice of an (judicious) approximation of each element of\nP(Z ) by an interval [min..max]\nDabs = {[s..t] : s,t \u2208 Z \u222a {\u2212\u221e, +\u221e}}\nwe define an order on Dabs , noted \u2286 : [s..t] \u2286 [s\u2032 .t \u2032 ] iff s \u2265 s\u2032\nt \u2264 t\u2032\na) Lemma:: (Dabs , \u2286), is a lattice whose lower bound\nis [] and the upper bound is [\u2212\u221e, +\u221e]. Abstraction and\nconcretization function:\n\n\u03b1 : C \u2212\u2192 A : C \u2192 \u03b1 (c) = [min(c)..max(c)]\n\u03b3 : A \u2212\u2192 C : a \u2192 \u03b3 (a) = [s, s + 1...,t \u2212 1,t]\nwith a = [s..t] such that they verifying the constraints of\ncoherence:\n\u2200c \u2208 C : \u03b3 (\u03b1 (c)) \u2287 c\u2200a \u2208 A : \u03b1 (\u03b3 (a)) = a.\nb) Remark:\n\u2022 an equivalent abstract of a program carries out the same\nstandard operations that the original except that the\ndomains are different.\n\u2022 for a real Pascal, C or Java programs, the work of rewrite\nwould be too tiresome. In fact one defines abstracted\noperators, the abstract interpretor uses those to carry\nout calculations on the abstract data by interpreting the\nprogram to be analyzed.\n\u2022 In practice each operator or function of the language\nmust have an abstract equivalent. The quality required\nis their consistency, their coherency with respect to their\nequivalent concrete operator. For the reason of performance, one requires the efficiency and convergence to\nguarantee a termination and acceptable computing time.\nAbstract version of the F91 function:\nFa 91([s..t]) = [max(91, s \u2212 10)..(t \u2212 10)]\u222a\nFa 91(Fa 91([(s + 11)..min(t + 11, 111)]))\n\nT : (Da \u2212\u2192 Da ) \u2212\u2192 (Da \u2212\u2192 Da )\n(T Fa 91)([s..t]) = [max(91, s \u2212 10)..(t \u2212 10)]\u222a\nFa 91(Fa91([(s + 11)..min(t + 11, 111)]))\ne) Lemma:: T is continuous and monotonous:\n\u2022 \u2200Ii , I j \u2208 Da : Ii \u2264 I j \u21d2 f (Ii ) \u2264 f (I j )\n\u2022 \u2200I1 \u2286 I2 \u2286 ... \u2286 In \u2286 ... \u21d2 f (\u222ai=1...\u221e Ii ) = \u222ai=1...\u221e f (Ii )\nTheorem Let f ([s..t]), the computing fixpoint consist of T\nto f ([s..t]).\n\u2022 If the constraints on the domain and the operators are\nsatisfied:\nthen any fixpoint of T is a correct approximation of the\nfunction f\n\u2022 the smallest fixpoint of T exists and constitutes the best\napproximation of f\n\u2022 the smallest fixpoint of T coincide with the limit of an\nincreasing\n\u2022 the smallest fixpoint of T coincide with the limit of an\nincreasing sequence of approximation: f0 \u2264 f1 \u2264 f2 \u2264\nf0 ... \u2264 fn \u2264 ...\nsuch as: f0 (I) = \u22a5 \u2200I \u2208 Da\nfk+1 = T ( fk >) \u2200k \u2265 0\n2) Fixpoint Approach: Fixpoint Approach is based on\nthe monotonicity (continuity) of the transformation of the\ntuples set representing the pre and post condition for all\npredicate. Termination of the algorithm in the case of an\ninfinite abstract domain, it did not guarantee. Which is the\ncase if one makes an infinity different recursive call. One can\nlimit oneself to abstract fields finished in certain cases that\ncan averrer genant itself or unacceptable. A possible solution,\nwould be to replace an infinite sequence of approximation\nby a number of the approximate values.\n\n\fa) Approach Widening/Narrowing: Suppose the abstract semantics of the program given by a function fP :\nDabs \u2212\u2192 Dabs . The analysis proceeds as follows:\n1) Widening: calculation of sequences limit X built by:\nx0 = \u22a5\nxi+1 = xi and fP (xi )) \u2291 xi\nelsexi \u25bd fP (xi )\n\u2022 Narrowing to improve the result obtained by the\nwidening: by\ncalculating the sequences limit of Y built by:\ny0 = \u2294X\nyi+1 = and fP (yi ) = yi thenyi\nelse yi \u25b3 fP (yi ))\nb) Properties:\n1) Widening: \u25bd : l \u00d7 L \u2212\u2192 L \u2200X,Y \u2208 L : X \u2291 Y \u25bd Y\nand Y \u2291 X \u25bdY\n\u2192 X \u2294Y \u2286 X \u25bdY\n\u22a5\u25bdX = X \u25bd\u22a5 = X\n2) Narrowing \u25b3 : l \u00d7 L \u2212\u2192 L\n\u2200X,Y \u2208 L : Y \u2291 X \u21d2 Y \u2286 X \u25b3Y \u2291 X\nc) Widening applied to the intervals:\n[l0 , u0 ] \u25bd [l1 , u1 ] = [ and l1 u0 then + \u221eelseu0 ]\nExample instead of making the recursive call with\nFa 91([\u2212\u221e..111]) one will do it with Fa 91([\u2212\u221e.. + \u221e]). But\na loss of precision would be introduced. This will allow to\nspeed up the computation of the fixpoint.\nIII. R EFINEMENT\nd) Motivation: The abstract interpretation framework\nestablishes a methodology based on rigorous semantics for\nconstructing abstraction that overapproximate the behavior\nof the program, so that every behavior in the program is\ncovered by a corresponding abstract execution. Thus, the\nabstract behavior can be exhautively checked for an invatiant\nin temporal logic. Refinement guided by counterexample\nconsist on approximation of the set of sates that lie on a path\nfrom initial state to a bad state which is successsively refine\nthat is done by forward or backward passes. This process is\nrepeated until the fixpoint is reached. If the the resulting set\nof state is empty then the property is proven. Otherwise, yhe\nmethode does not guaranties that the contreexample trace is\ngenuine.\nA. Preliminaries\nDefinition 3.1:\nTheorem 3.1: Cousot77\nLet S = (Q, Qinit , \u2211, \u2192) a system representing the semantics\nof program. The system SA = (QA , QAinit , \u2211, \u2192A ) is an abstraction of S \u21d0\u21d2 there exists a Galois connexion:\n\u03b1 : P(Q) 7\u2212\u2192 P(QA ), \u03b3 : P(QA ) 7\u2212\u2192 P(Q)\nsuch that\n\u2022 Qinit \u2286 \u03b3 (QA\ninit )\n\u03c4\n\n\u03c4A\n\n\u2200\u03c4 \u2208 \u2211, \u2200QAi \u2286 QA .post[\u2192](\u03b3 (QAi )) \u2286 \u03b3 (post[\u2192\n](\u03b3 (QAi ))\nDefinition 3.2: Predicat Abstraction Graf&Saidi97\n\n\u2022\n\ne)\nAbstract State:\nLet Prog = (V , T =\n{\u03c41 , . . . , \u03c4n }, Init) and \u03c61 , . . . , \u03c6k predicates over the\nProg's variables\nwe define an abstraction SA = (QA , QAinit , \u2211, \u2192A ) as\nfollowing:\n\u2022 QA = Bk , QA is the valuations' set of k boolean\nvariables,\nany subset QA can be represented by a boolean expression over the variables B1 , . . . , Bk\n\u2022 SA as the form ProgA = (V A , T A = {\u03c41A , . . . , \u03c4nA }, Init A )\nf) Abstract transition: Let T A , be an abstract transition, it must satisfy the condition of the definition of abstract\nprogram , s.t. all transition \u03c4 , post[\u03c4 A ](PB ), where \u03c4 A is\nthe abstract transition corresponding to \u03c4 , have to represent\nall concrete states q\u2032 which are successors by \u03c4 of concrete\nstate q represented by PB . We must show :: post[\u03c4 ](\u03b3 (PB )) \u21d2\n\u2032\n\u03b3 (PB ),\nB. Algorithmic checking of refining\nThis model-checking needs methodological and correctness conditions:\n1) Methodological conditions:\n\u2022 New actions and variables will be introduced by refining\n\u2022 the variables of refine system and abstract system must\nbe linked by a \"collage\" invariant.\n\u2022\n\n2) Correctness conditions::\n\u2022 simulation of the refine system by the abstract\n\u2022 no cycle between the new action\n\u2022 no new deadlock\n\nFig. 1.\n\nSimulation with old actions\n\nIt is a question of carrying out an iteratif calculation of\nthe simulation of T S2 by T S1 cfr figures 1 and 2 where\ntransisition \u03b1 is replace by \u03c4 . The algorithm terminates when\nthe fixpoint is reached.\nTheorem 3.2: \u2022 If P1 is property satisfied by T S1 and\nT S2 refines T S1 then\nT S1 |= P1 , \u22a2 T S2 \u2286 T S1\nT S2 |= P1\n\n\fFig. 3.\n\nFig. 2.\n\n\u2022\n\nExample of predicate abstraction\n\nSimulation with new actions\n\nIf P1 is property satisfied by T S1 and T S2 refines T S1\nand if P2 is a reformulation of P1 then\n\nT S1 |= P1 , \u22a2 T S2 \u2286 T S1\nT S2 |= P2\nDefinition 3.3: : Let K, K' two systems (resp concrete\nand abstract). we call false-counterexample or negative-false\na false universal property in K' but true in K We say that\nthe counterexample specified in K' cannot be reproduced in\nK\na) Corollary: If K' is too small, it is very probable that\nit appears the negative one. If K' is too large, then the checking is not possible the refinement guided by counterexample\nis thus a natural approach to solve this problem by using\na adaptive algorithm which gradually creates an abstraction\nfunction by the analysis of false-negative:\nb) Pseudo Algorithm:\n\nFig. 4.\n\nabstraction too coarse\n\nguaranteed the value of against example which perhaps\ndistorted by approximation coarse. Heuristics is employed\nto determine the subset of the reachable states since the\ninitial states. If an equivalence is found, it really acts of an\nerror which can be deferred like a bug, one speaks about\npositive-false. Abstraction by Predicate : the checking of\nprogram by abstraction of closed predicate is a technique\nof checking of program by abstract interpretation where the\nabstract domain is composed of the set of guard relating to\n1. Initialization:\nthe states and the transitions from the system. This domain\ngenerate a first abstraction function;\ncan be generated automatically and checked by a theorems2. Model-Checking:\nprover. Like, the set of predicates is always finished, it can\ncheck the model.\nbe coded by a vector of Boolean, which makes it possible on\nif the checking is a success:\nthe other hand to use the model-checker for calculations of\nthen\nfixpoint.Si, the domain is very large, one can use a chaotic\nthe specification is correct and\niterator and to use a widening if it is necessary of speed up\nthe algorithm terminates\nthe convergence. The termination and reachability decidable\nelse\nin this case. The one limitation of this technique of checking\ngenerate a counterexample from the abstract model\nby predicate abstraction is that the processes of refinement,\nverify if this counterexample is a negative-false\nwhich primarily consists in calculating the weakest invariant,\nif It is a success then terminate\nare extremely slow. This obligates the users to require at least\nelse refine the abstract function such that\nthe atomic predicate necessary to the proof. This fact the\nthe negative-false can be avoid\nhuman intervention which specific is given must be repeated\ngoto step 2.\nfor different programs even if they are very similarities. and\nit\nIV. S UMMARY\nV. C ONCLUSION AND F UTURE W ORK\nIt is thus a question of starting by carrying out an\napproximation of a way which carries out initial state in a\nbad condition. Then, a refinement \"forwards\" or \"backward\"\nis carried out, and this process is to repeat until a fixpoint is\nmet. If the resulting set of states is empty then the property is\nprove, since one no bad condition is reachable, else, nothing\n\nIt has been shown that static checker can cover a large\nnumber of potential faults, their automatic usage is still\nfar from realistic. However, as a verification step prior to\ntesting or code review, static checkers, can already enhance\nthe software development process today. Several techniques\n\n\fFig. 5.\n\nExample of refinement\n\nlike Altarica, B or CSP2B were proposed to specify and\ncheck reactive systems by using hierarchic development\nby refinement. In this case, the systems design is realized\ngradually by increasing the systems design to each step of\nthe specification from a very abstract sight of the system until\nits implementation. For us, a system implements (refines)\nanother system if all the traces of execution of the most\ndetailed system are too traces of the most abstract ( modulo\nthe introduction of details during refinement). The checking\nof the system thus will use refinement to model the initial\nsystem in a more precise way, if the model-checker provides\na erroneous result consequence of coarse approximation at\nthe time of the abstraction.\nR EFERENCES\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n[8]\n[9]\n\nAndr\u00e9 Arnold, G\u00e9rald Point, Alain Griffault Antoine Rauzy: The\nAltarRica Formalisme for describing concurrent systems. Nov. 1999,\nFundamental Informatica Volume 40 issue 2-3, Publisher: IOS Press,\nEdmound Clarke Contreexemple-guided abstraction refinement. In\n10Th International Symposium on Temporal Representation and Reasonning and Fourt International Confernce on Temporal Logic, 2003.\nP. Cousot, R. Cousot Abstract Interpretation: A Unified Lattice Model\nfor Static Analysis of Programs by Construction of Approximation of\nFixpoints, POPL 1977, Sigact Sigplan, pp 238\u2013252.\nT. Kanamori, T. Kawamura Analysing success patterns of Logic\nPrograms by Abstract Hybrid Interpretation, Technical report, ICOT,\n1987.\nB. Le Charlier, K. Musumbu, P. Van Hentenryck A generic abstract\nInterpretation algorithm and its complexity analysis, In Proc ICLP 91,\nJune 91.\nD. Knuth Semantics of context-free languages; Math. Systems Theory\n2 (1968), pp 127-145, 5th ICLP\u2013SLP 88;tutorial No 2.\nT. Henzinger, R.Jhala, R.Majumdar, G. Sutre Lazy abstraction ;\nTechnical report University of California and LaBRI, 2002.\nDavid D\u00e9harde Interprtation abstraite: introduction et applications\nl'analyse statique et la vrification de modles; Technical report LORIA,\n2002\nT. Ball, A. Podelski, S. Rajammani Boolean and cartesian abstractionfor model checking C programs. ; Technical report LORIA,Microsoft Corporation, 2000.\n\n\f\f\f\f"}