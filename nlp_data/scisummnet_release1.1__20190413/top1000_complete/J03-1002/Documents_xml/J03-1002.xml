<PAPER>
  <S sid="0">A Systematic Comparison Of Various Statistical Alignment Models</S>
  <ABSTRACT>
    <S sid="1" ssid="1">We present and compare various methods for computing word alignments using statistical or heuristic models.</S>
    <S sid="2" ssid="2">We consider the five alignment models presented in Brown, Della Pietra, Della Pietra, and Mercer (1993), the hidden Markov alignment model, smoothing techniques, and refinements.</S>
    <S sid="3" ssid="3">These statistical models are compared with two heuristic models based on the Dice coefficient.</S>
    <S sid="4" ssid="4">We present different methodsfor combining word alignments to perform a symmetrization of directed statistical alignment models.</S>
    <S sid="5" ssid="5">As evaluation criterion, we use the quality of the resulting Viterbi alignment compared to a manually produced reference alignment.</S>
    <S sid="6" ssid="6">We evaluate the models on the German-English Verbmobil task and the French-English Hansards task.</S>
    <S sid="7" ssid="7">We perform a detailed analysis of various design decisions of our statistical alignment system and evaluate these on training corpora of various sizes.</S>
    <S sid="8" ssid="8">An important result is that refined alignment models with a first-order dependence and a fertility model yield significantly better results than simple heuristic models.</S>
    <S sid="9" ssid="9">In the Appendix, we present an efficient training algorithm for the alignment models presented.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="10" ssid="1">We present and compare various methods for computing word alignments using statistical or heuristic models.</S>
    <S sid="11" ssid="2">We consider the five alignment models presented in Brown, Della Pietra, Della Pietra, and Mercer (1993), the hidden Markov alignment model, smoothing techniques, and refinements.</S>
    <S sid="12" ssid="3">These statistical models are compared with two heuristic models based on the Dice coefficient.</S>
    <S sid="13" ssid="4">We present different methodsfor combining word alignments to perform a symmetrization of directed statistical alignment models.</S>
    <S sid="14" ssid="5">As evaluation criterion, we use the quality of the resulting Viterbi alignment compared to a manually produced reference alignment.</S>
    <S sid="15" ssid="6">We evaluate the models on the German-English Verbmobil task and the French-English Hansards task.</S>
    <S sid="16" ssid="7">We perform a detailed analysis of various design decisions of our statistical alignment system and evaluate these on training corpora of various sizes.</S>
    <S sid="17" ssid="8">An important result is that refined alignment models with a first-order dependence and a fertility model yield significantly better results than simple heuristic models.</S>
    <S sid="18" ssid="9">In the Appendix, we present an efficient training algorithm for the alignment models presented.</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="19" ssid="1">We address in this article the problem of finding the word alignment of a bilingual sentence-aligned corpus by using language-independent statistical methods.</S>
    <S sid="20" ssid="2">There is a vast literature on this topic, and many different systems have been suggested to solve this problem.</S>
    <S sid="21" ssid="3">Our work follows and extends the methods introduced by Brown, Della Pietra, Della Pietra, and Mercer (1993) by using refined statistical models for the translation process.</S>
    <S sid="22" ssid="4">The basic idea of this approach is to develop a model of the translation process with the word alignment as a hidden variable of this process, to apply statistical estimation theory to compute the &#8220;optimal&#8221; model parameters, and to perform alignment search to compute the best word alignment.</S>
    <S sid="23" ssid="5">So far, refined statistical alignment models have in general been rarely used.</S>
    <S sid="24" ssid="6">One reason for this is the high complexity of these models, which makes them difficult to understand, implement, and tune.</S>
    <S sid="25" ssid="7">Instead, heuristic models are usually used.</S>
    <S sid="26" ssid="8">In heuristic models, the word alignments are computed by analyzing some association score metric of a link between a source language word and a target language word.</S>
    <S sid="27" ssid="9">These models are relatively easy to implement.</S>
    <S sid="28" ssid="10">In this article, we focus on consistent statistical alignment models suggested in the literature, but we also describe a heuristic association metric.</S>
    <S sid="29" ssid="11">By providing a detailed description and a systematic evaluation of these alignment models, we give the reader various criteria for deciding which model to use for a given task.</S>
    <S sid="30" ssid="12">Example of a word alignment (VERBMOBIL task).</S>
    <S sid="31" ssid="13">We propose to measure the quality of an alignment model by comparing the quality of the most probable alignment, the Viterbi alignment, with a manually produced reference alignment.</S>
    <S sid="32" ssid="14">This has the advantage of enabling an automatic evaluation to be performed.</S>
    <S sid="33" ssid="15">In addition, we shall show that this quality measure is a precise and reliable evaluation criterion that is well suited to guide designing and training statistical alignment models.</S>
    <S sid="34" ssid="16">The software used to train the statistical alignment models described in this article is publicly available (Och 2000).</S>
    <S sid="35" ssid="17">We follow Brown, Della Pietra, Della Pietra, and Mercer (1993) to define alignment as an object for indicating the corresponding words in a parallel text.</S>
    <S sid="36" ssid="18">Figure 1 shows an example.</S>
    <S sid="37" ssid="19">Very often, it is difficult for a human to judge which words in a given target string correspond to which words in its source string.</S>
    <S sid="38" ssid="20">Especially problematic is the alignment of words within idiomatic expressions, free translations, and missing function words.</S>
    <S sid="39" ssid="21">The problem is that the notion of &#8220;correspondence&#8221; between words is subjective.</S>
    <S sid="40" ssid="22">It is important to keep this in mind in the evaluation of word alignment quality.</S>
    <S sid="41" ssid="23">We shall deal with this problem in Section 5.</S>
    <S sid="42" ssid="24">The alignment between two word strings can be quite complicated.</S>
    <S sid="43" ssid="25">Often, an alignment includes effects such as reorderings, omissions, insertions, and word-tophrase alignments.</S>
    <S sid="44" ssid="26">Therefore, we need a very general representation of alignment.</S>
    <S sid="45" ssid="27">Formally, we use the following definition for alignment in this article.</S>
    <S sid="46" ssid="28">We are given a source (French) stringf1J = f1, ... , fj,.</S>
    <S sid="47" ssid="29">.</S>
    <S sid="48" ssid="30">.</S>
    <S sid="49" ssid="31">, fJ and a target language (English) string eI1 = e1,.</S>
    <S sid="50" ssid="32">.</S>
    <S sid="51" ssid="33">.</S>
    <S sid="52" ssid="34">, ei, ... , eI that have to be aligned.</S>
    <S sid="53" ssid="35">We define an alignment between the two word strings as a subset of the Cartesian product of the word positions; that is, an Modeling the alignment as an arbitrary relation between source and target language positions is quite general.</S>
    <S sid="54" ssid="36">The development of alignment models that are able to deal with this general representation, however, is hard.</S>
    <S sid="55" ssid="37">Typically, the alignment models presented in the literature impose additional constraints on the alignment representation.</S>
    <S sid="56" ssid="38">Typically, the alignment representation is restricted in a way such that each source word is assigned to exactly one target word.</S>
    <S sid="57" ssid="39">Alignment models restricted in this way are similar to the concept of hidden Markov models (HMMs) in speech recognition.</S>
    <S sid="58" ssid="40">The alignment mapping in such models consists of associations j &#8594; i = aj from source position j to target position i = aj.</S>
    <S sid="59" ssid="41">The alignment aJ1 = a1, ... , aj, ... , aJ may contain alignments aj = 0 with the &#8220;empty&#8221; word e0 to account for source words that are not aligned with any target word.</S>
    <S sid="60" ssid="42">Constructed in such a way, the alignment is not a relation between source and target language positions, but only a mapping from source to target language positions.</S>
    <S sid="61" ssid="43">In Melamed (2000), a further simplification is performed that enforces a one-to-one alignment for nonempty words.</S>
    <S sid="62" ssid="44">This means that the alignment mapping aJ1 must be injective for all word positions aj &gt; 0.</S>
    <S sid="63" ssid="45">Note that many translation phenomena cannot be handled using restricted alignment representations such as this one.</S>
    <S sid="64" ssid="46">Especially, methods such as Melamed&#8217;s are in principle not able to achieve a 100% recall.</S>
    <S sid="65" ssid="47">The problem can be reduced through corpus preprocessing steps that perform grouping and splitting of words.</S>
    <S sid="66" ssid="48">Some papers report improvements in the alignment quality of statistical methods when linguistic knowledge is used (Ker and Chang 1997; Huang and Choi 2000).</S>
    <S sid="67" ssid="49">In these methods, the linguistic knowledge is used mainly to filter out incorrect alignments.</S>
    <S sid="68" ssid="50">In this work, we shall avoid making explicit assumptions concerning the language used.</S>
    <S sid="69" ssid="51">By avoiding these assumptions, we expect our approach to be applicable to almost every language pair.</S>
    <S sid="70" ssid="52">The only assumptions we make are that the parallel text is segmented into aligned sentences and that the sentences are segmented into words.</S>
    <S sid="71" ssid="53">Obviously, there are additional implicit assumptions in the models that are needed to obtain a good alignment quality.</S>
    <S sid="72" ssid="54">For example, in languages with a very rich morphology, such as Finnish, a trivial segmentation produces a high number of words that occur only once, and every learning method suffers from a significant data sparseness problem.</S>
    <S sid="73" ssid="55">There are numerous applications for word alignments in natural language processing.</S>
    <S sid="74" ssid="56">These applications crucially depend on the quality of the word alignment (Och and Ney 2000; Yarowsky and Wicentowski 2000).</S>
    <S sid="75" ssid="57">An obvious application for word alignment methods is the automatic extraction of bilingual lexica and terminology from corpora (Smadja, McKeown, and Hatzivassiloglou 1996; Melamed 2000).</S>
    <S sid="76" ssid="58">Statistical alignment models are often the basis of single-word-based statistical machine translation systems (Berger et al. 1994; Wu 1996; Wang and Waibel 1998; Nie&#223;en et al.</S>
    <S sid="77" ssid="59">1998; Garc&#180;&#305;a-Varea, Casacuberta, and Ney 1998; Och, Ueffing, and Ney 2001; Germann et al. 2001).</S>
    <S sid="78" ssid="60">In addition, these models are the starting point for refined phrase-based statistical (Och and Weber 1998; Och, Tillmann, and Ney 1999) or example-based translation systems (Brown 1997).</S>
    <S sid="79" ssid="61">In such systems, the quality of the machine translation output directly depends on the quality of the initial word alignment (Och and Ney 2000).</S>
    <S sid="80" ssid="62">Another application of word alignments is in the field of word sense disambiguation (Diab 2000).</S>
    <S sid="81" ssid="63">In Yarowsky, Ngai, and Wicentowski (2001), word alignment is used to transfer text analysis tools such as morphologic analyzers or part-of-speech taggers from a language, such as English, for which many tools already exist to languages for which such resources are scarce.</S>
    <S sid="82" ssid="64">In Section 2, we review various statistical alignment models and heuristic models.</S>
    <S sid="83" ssid="65">We present a new statistical alignment model, a log-linear combination of the best models of Vogel, Ney, and Tillmann (1996) and Brown, Della Pietra, Della Pietra, and Mercer (1993).</S>
    <S sid="84" ssid="66">In Section 3, we describe the training of the alignment models and present a new training schedule that yields significantly better results.</S>
    <S sid="85" ssid="67">In addition, we describe how to deal with overfitting, deficient models, and very small or very large training corpora.</S>
    <S sid="86" ssid="68">In Section 4, we present some heuristic methods for improving alignment quality by performing a symmetrization of word alignments.</S>
    <S sid="87" ssid="69">In Section 5, we describe an evaluation methodology for word alignment methods dealing with the ambiguities associated with the word alignment annotation based on generalized precision and recall measures.</S>
    <S sid="88" ssid="70">In Section 6, we present a systematic comparison of the various statistical alignment models with regard to alignment quality and translation quality.</S>
    <S sid="89" ssid="71">We assess the effect of training corpora of various sizes and the use of a conventional bilingual dictionary.</S>
    <S sid="90" ssid="72">In the literature, it is often claimed that the refined alignment models of Brown, Della Pietra, Della Pietra, and Mercer (1993) are not suitable for small corpora because of data sparseness problems.</S>
    <S sid="91" ssid="73">We show that this is not the case if these models are parametrized suitably.</S>
    <S sid="92" ssid="74">In the Appendix, we describe some methods for efficient training of fertility-based alignment models.</S>
  </SECTION>
  <SECTION title="2. Review of Alignment Models" number="3">
    <S sid="93" ssid="1">We distinguish between two general approaches to computing word alignments: statistical alignment models and heuristic models.</S>
    <S sid="94" ssid="2">In the following, we describe both types of models and compare them from a theoretical viewpoint.</S>
    <S sid="95" ssid="3">The notational convention we employ is as follows.</S>
    <S sid="96" ssid="4">We use the symbol Pr(&#183;) to denote general probability distributions with (almost) no specific assumptions.</S>
    <S sid="97" ssid="5">In contrast, for model-based probability distributions, we use the generic symbol p(&#183;).</S>
    <S sid="98" ssid="6">2.1.1 Statistical Alignment Models.</S>
    <S sid="99" ssid="7">In statistical machine translation, we try to model the translation probability Pr(f1 J  |eI1), which describes the relationship between a source language string fJ1 and a target language string eI1.</S>
    <S sid="100" ssid="8">In (statistical) alignment models Pr(fJ1,aJ1  |eI1), a &#8220;hidden&#8221; alignment aJ1 is introduced that describes a mapping from a source position j to a target position aj.</S>
    <S sid="101" ssid="9">The relationship between the translation model and the alignment model is given by The alignment aJ 1 may contain alignments aj = 0 with the empty word e0 to account for source words that are not aligned with any target word.</S>
    <S sid="102" ssid="10">In general, the statistical model depends on a set of unknown parameters &#952; that is learned from training data.</S>
    <S sid="103" ssid="11">To express the dependence of the model on the parameter set, we use the following notation: The art of statistical modeling is to develop specific statistical models that capture the relevant properties of the considered problem domain.</S>
    <S sid="104" ssid="12">In our case, the statistical alignment model has to describe the relationship between a source language string and a target language string adequately.</S>
    <S sid="105" ssid="13">To train the unknown parameters &#952;, we are given a parallel training corpus consisting of S sentence pairs {(fs, es) : s = 1, ... , S}.</S>
    <S sid="106" ssid="14">For each sentence pair (fs, es), the alignment variable is denoted by a = aJ1.</S>
    <S sid="107" ssid="15">The unknown parameters &#952; are determined by maximizing the likelihood on the parallel training corpus: Typically, for the kinds of models we describe here, the expectation maximization (EM) algorithm (Dempster, Laird, and Rubin 1977) or some approximate EM algorithm is used to perform this maximization.</S>
    <S sid="108" ssid="16">To avoid a common misunderstanding, however, note that the use of the EM algorithm is not essential for the statistical approach, but only a useful tool for solving this parameter estimation problem.</S>
    <S sid="109" ssid="17">Although for a given sentence pair there is a large number of alignments, we can always find a best alignment: The alignment &#710;aJ1 is also called the Viterbi alignment of the sentence pair(f J 1,eI 1).</S>
    <S sid="110" ssid="18">(For the sake of simplicity, we shall drop the index &#952; if it is not explicitly needed.)</S>
    <S sid="111" ssid="19">Later in the article, we evaluate the quality of this Viterbi alignment by comparing it to a manually produced reference alignment.</S>
    <S sid="112" ssid="20">The parameters of the statistical alignment models are optimized with respect to a maximum-likelihood criterion, which is not necessarily directly related to alignment quality.</S>
    <S sid="113" ssid="21">Such an approach, however, requires training with manually defined alignments, which is not done in the research presented in this article.</S>
    <S sid="114" ssid="22">Experimental evidence shows (Section 6) that the statistical alignment models using this parameter estimation technique do indeed obtain a good alignment quality.</S>
    <S sid="115" ssid="23">In this paper, we use Models 1 through 5 described in Brown, Della Pietra, Della Pietra, and Mercer (1993), the hidden Markov alignment model described in Vogel, Ney, and Tillmann (1996) and Och and Ney (2000), and a new alignment model, which we call Model 6.</S>
    <S sid="116" ssid="24">All these models use a different decomposition of the probability Pr(fJ1,aJ1  |eI1).</S>
    <S sid="117" ssid="25">2.1.2 Heuristic Models.</S>
    <S sid="118" ssid="26">Considerably simpler methods for obtaining word alignments use a function of the similarity between the types of the two languages (Smadja, McKeown, and Hatzivassiloglou 1996; Ker and Chang 1997; Melamed 2000).</S>
    <S sid="119" ssid="27">Frequently, variations of the Dice coefficient (Dice 1945) are used as this similarity function.</S>
    <S sid="120" ssid="28">For each sentence pair, a matrix including the association scores between every word at every position is then obtained: C(e,f) denotes the co-occurrence count of e and f in the parallel training corpus.</S>
    <S sid="121" ssid="29">C(e) and C(f) denote the count of e in the target sentences and the count off in the source sentences, respectively.</S>
    <S sid="122" ssid="30">From this association score matrix, the word alignment is then obtained by applying suitable heuristics.</S>
    <S sid="123" ssid="31">One method is to choose as alignment aj = i for position j the word with the largest association score: A refinement of this method is the competitive linking algorithm (Melamed 2000).</S>
    <S sid="124" ssid="32">In a first step, the highest-ranking word position (i, j) is aligned.</S>
    <S sid="125" ssid="33">Then, the corresponding row and column are removed from the association score matrix.</S>
    <S sid="126" ssid="34">This procedure is iteratively repeated until every source or target language word is aligned.</S>
    <S sid="127" ssid="35">The advantage of this approach is that indirect associations (i.e., words that co-occur often but are not translations of each other) occur less often.</S>
    <S sid="128" ssid="36">The resulting alignment contains only one-to-one alignments and typically has a higher precision than the heuristic model defined in equation (7). tage of the heuristic models is their simplicity.</S>
    <S sid="129" ssid="37">They are very easy to implement and understand.</S>
    <S sid="130" ssid="38">Therefore, variants of the heuristic models described above are widely used in the word alignment literature.</S>
    <S sid="131" ssid="39">One problem with heuristic models is that the use of a specific similarity function seems to be completely arbitrary.</S>
    <S sid="132" ssid="40">The literature contains a large variety of different scoring functions, some including empirically adjusted parameters.</S>
    <S sid="133" ssid="41">As we show in Section 6, the Dice coefficient results in a worse alignment quality than the statistical models.</S>
    <S sid="134" ssid="42">In our view, the approach of using statistical alignment models is more coherent.</S>
    <S sid="135" ssid="43">The general principle for coming up with an association score between words results from statistical estimation theory, and the parameters of the models are adjusted such that the likelihood of the models on the training corpus is maximized.</S>
    <S sid="136" ssid="44">2.2.1 Hidden Markov Alignment Model.</S>
    <S sid="137" ssid="45">The alignment model Pr(fJ1,aJ 1  |eI1) can be structured without loss of generality as follows: dependence for the alignments aj and that the lexicon probability depends only on the word at position aj: Later in the article, we describe a refinement with a dependence on eaj&#8722;1 in the alignment model.</S>
    <S sid="138" ssid="46">Putting everything together and assuming a simple length model with the alignment probability p(i  |it, I) and the translation probability p(f  |e).</S>
    <S sid="139" ssid="47">To make the alignment parameters independent of absolute word positions, we assume that the alignment probabilities p(i  |i',I) depend only on the jump width (i &#8722; i').</S>
    <S sid="140" ssid="48">Using a set of non-negative parameters {c(i &#8722; i')}, we can write the alignment probabilities in the form This form ensures that the alignment probabilities satisfy the normalization constraint for each conditioning word position it, it = 1, ... , I.</S>
    <S sid="141" ssid="49">This model is also referred to as a homogeneous HMM (Vogel, Ney, and Tillmann 1996).</S>
    <S sid="142" ssid="50">A similar idea was suggested by Dagan, Church, and Gale (1993).</S>
    <S sid="143" ssid="51">In the original formulation of the hidden Markov alignment model, there is no empty word that generates source words having no directly aligned target word.</S>
    <S sid="144" ssid="52">We introduce the empty word by extending the HMM network by I empty words e2I I+1.</S>
    <S sid="145" ssid="53">The target word ei has a corresponding empty word ei+I (i.e., the position of the empty word encodes the previously visited target word).</S>
    <S sid="146" ssid="54">We enforce the following constraints on the transitions in the HMM network (i &#8804; I, it &#8804; I) involving the empty word e0:1 The parameter p0 is the probability of a transition to the empty word, which has to be optimized on held-out data.</S>
    <S sid="147" ssid="55">In our experiments, we set p0 = 0.2.</S>
    <S sid="148" ssid="56">Whereas the HMM is based on first-order dependencies p(i = aj  |aj&#8722;1,I) for the alignment distribution, Models 1 and 2 use zero-order dependencies p(i = aj  |j, I, J): Hence, the word order does not affect the alignment probability.</S>
    <S sid="149" ssid="57">To reduce the number of alignment parameters, we ignore the dependence on J in the alignment model and use a distribution p(aj  |j, I) instead of p(aj  |j, I, J).</S>
    <S sid="150" ssid="58">In the following, we give a short description of the fertility-based alignment models of Brown, Della Pietra, Della Pietra, and Mercer (1993).</S>
    <S sid="151" ssid="59">A gentle introduction can be found in Knight (1999b).</S>
    <S sid="152" ssid="60">The fertility-based alignment models (Models 3, 4, and 5) (Brown, Della Pietra, Della Pietra, and Mercer 1993) have a significantly more complicated structure than the simple Models 1 and 2.</S>
    <S sid="153" ssid="61">The fertility Oi of a word ei in position i is defined as the number of aligned source words: The fertility-based alignment models contain a probability p(O  |e) that the target word e is aligned to O words.</S>
    <S sid="154" ssid="62">By including this probability, it is possible to explicitly describe the fact that for instance the German word &#168;ubermorgen produces four English words (the day after tomorrow).</S>
    <S sid="155" ssid="63">In particular, the fertility O = 0 is used for prepositions or articles that have no direct counterpart in the other language.</S>
    <S sid="156" ssid="64">To describe the fertility-based alignment models in more detail, we introduce, as an alternative alignment representation, the inverted alignments, which define a mapping from target to source positions rather than the other way around.</S>
    <S sid="157" ssid="65">We allow several positions in the source language to be covered; that is, we consider alignments B of the form An important constraint for the inverted alignment is that all positions of the source sentence must be covered exactly once; that is, the Bi have to form a partition of the set {1, ... , j, ... ,J}.</S>
    <S sid="158" ssid="66">The number of words Oi = |Bi |is the fertility of the word ei.</S>
    <S sid="159" ssid="67">In the following, Bik refers to the kth element of Bi in ascending order.</S>
    <S sid="160" ssid="68">The inverted alignments BI0 are a different way to represent normal alignments aJ1.</S>
    <S sid="161" ssid="69">The set B0 contains the positions of all source words that are aligned with the empty word.</S>
    <S sid="162" ssid="70">Fertility-based alignment models use the following decomposition and assumptions:2 As might be seen from this equation, we have tacitly assumed that the set B0 of words aligned with the empty word is generated only after the nonempty positions have We obtain an (inverted) zero-order alignment model p(j  |i, J).</S>
    <S sid="163" ssid="71">&#8226; In Model 4, every word is dependent on the previous aligned word and on the word classes of the surrounding words.</S>
    <S sid="164" ssid="72">First, we describe the dependence of alignment positions.</S>
    <S sid="165" ssid="73">(The dependence on word classes is for now ignored and will be introduced later.)</S>
    <S sid="166" ssid="74">We have two (inverted) first-order alignment models: p=1(&#8710;j  |&#183; &#183; &#183;) and p&gt;1(&#8710;j  |&#183; &#183; &#183;).</S>
    <S sid="167" ssid="75">The difference between this model and the first-order alignment model in the HMM lies in the fact that here we now have a dependence along the j-axis instead of a dependence along the i-axis.</S>
    <S sid="168" ssid="76">The model p=1(&#8710;j  |&#183; &#183; &#183;) is used to position the first word of a set Bi, and the model p&gt;1(&#8710;j  |&#183; &#183; &#183;) is used to position the remaining words from left to right: The function i &#8594; i' = p(i) gives the largest value i' &lt; i for which |Bi, |&gt; 0.</S>
    <S sid="169" ssid="77">The symbol BP(i) denotes the average of all elements in BP(i).</S>
    <S sid="170" ssid="78">Models 3, 4, and 5 define the probability p(B0  |BI1) as uniformly distributed for the O0! possibilities given the number of words aligned with the empty word O0 = |B0|.</S>
    <S sid="171" ssid="79">Assuming a binomial distribution for the number of words aligned with the empty word, we obtain the following distribution for B0: The free parameter p1 is associated with the number of words that are aligned with the empty word.</S>
    <S sid="172" ssid="80">There are O0! ways to order the O0 words produced by the empty word, and hence, the alignment model of the empty word is nondeficient.</S>
    <S sid="173" ssid="81">As we will see in Section 3.2, this creates problems for Models 3 and 4.</S>
    <S sid="174" ssid="82">Therefore, we modify Models 3 and 4 slightly by replacing 00! in equation (27) with J&#966;0: As a result of this modification, the alignment models for both nonempty words and the empty word are deficient.</S>
    <S sid="175" ssid="83">2.3.1 Model 6.</S>
    <S sid="176" ssid="84">As we shall see, the alignment models with a first-order dependence (HMM, Models 4 and 5) produce significantly better results than the other alignment models.</S>
    <S sid="177" ssid="85">The HMM predicts the distance between subsequent source language positions, whereas Model 4 predicts the distance between subsequent target language positions.</S>
    <S sid="178" ssid="86">This implies that the HMM makes use of locality in the source language, whereas Model 4 makes use of locality in the target language.</S>
    <S sid="179" ssid="87">We expect to achieve better alignment quality by using a model that takes into account both types of dependencies.</S>
    <S sid="180" ssid="88">Therefore, we combine HMM and Model 4 in a log-linear way and call the resulting model Model 6: Here, the interpolation parameter &#945; is employed to weigh Model 4 relative to the hidden Markov alignment model.</S>
    <S sid="181" ssid="89">In our experiments, we use Model 4 instead of Model 5, as it is significantly more efficient in training and obtains better results.</S>
    <S sid="182" ssid="90">In general, we can perform a log-linear combination of several models pk(f,a  |e), k=1,...,Kby The interpolation parameters &#945;k are determined in such a way that the alignment quality on held-out data is optimized.</S>
    <S sid="183" ssid="91">We use a log-linear combination instead of the simpler linear combination because the values of Pr(f,a  |e) typically differ by orders of magnitude for HMM and Model 4.</S>
    <S sid="184" ssid="92">In such a case, we expect the log-linear combination to be better than a linear combination.</S>
    <S sid="185" ssid="93">5, it is straightforward to extend the alignment parameters to include a dependence on the word classes of the surrounding words (Och and Ney 2000).</S>
    <S sid="186" ssid="94">In the hidden Markov alignment model, we allow for a dependence of the position aj on the class of the preceding target word C(eaj&#8722;1): p(aj  |aj&#8722;1,I,C(eaj&#8722;1)).</S>
    <S sid="187" ssid="95">Similarly, we can include dependencies on source and target word classes in Models 4 and 5 (Brown, Della Pietra, Della Pietra, and Mercer 1993).</S>
    <S sid="188" ssid="96">The categorization of the words into classes (here: 50 classes) is performed automatically by using the statistical learning procedure described in Kneser and Ney (1993).</S>
    <S sid="189" ssid="97">2.3.3 Overview of Models.</S>
    <S sid="190" ssid="98">The main differences among the statistical alignment models lie in the alignment model they employ (zero-order or first-order), the fertility model they employ, and the presence or absence of deficiency.</S>
    <S sid="191" ssid="99">In addition, the models differ with regard to the efficiency of the E-step in the EM algorithm (Section 3.1).</S>
    <S sid="192" ssid="100">Table 1 offers an overview of the properties of the various alignment models.</S>
    <S sid="193" ssid="101">Overview of the alignment models.</S>
    <S sid="194" ssid="102">Model Alignment model Fertility model E-step Deficient Model 1 uniform no exact no Model 2 zero-order no exact no HMM first-order no exact no Model 3 zero-order yes approximative yes Model 4 first-order yes approximative yes Model 5 first-order yes approximative no Model 6 first-order yes approximative yes We now develop an algorithm to compute the Viterbi alignment for each alignment model.</S>
    <S sid="195" ssid="103">Although there exist simple polynomial algorithms for the baseline Models 1 and 2, we are unaware of any efficient algorithm for computing the Viterbi alignment for the fertility-based alignment models.</S>
    <S sid="196" ssid="104">For Model 2 (also for Model 1 as a special case), we obtain Hence, the maximization over the (I+1)J different alignments decomposes into J maximizations of (I + 1) lexicon probabilities.</S>
    <S sid="197" ssid="105">Similarly, the Viterbi alignment for Model 2 can be computed with a complexity of O(I &#183; J).</S>
    <S sid="198" ssid="106">Finding the optimal alignment for the HMM is more complicated than for Model 1 or Model 2.</S>
    <S sid="199" ssid="107">Using a dynamic programming approach, it is possible to obtain the Viterbi alignment for the HMM with a complexity of O(I2 &#183;J) (Vogel, Ney, and Tillmann 1996).</S>
    <S sid="200" ssid="108">For the refined alignment models, however, namely, Models 3, 4, 5, and 6, maximization over all alignments cannot be efficiently carried out.</S>
    <S sid="201" ssid="109">The corresponding search problem is NP-complete (Knight 1990a).</S>
    <S sid="202" ssid="110">For short sentences, a possible solution could be an A* search algorithm (Och, Ueffing, and Ney 2001).</S>
    <S sid="203" ssid="111">In the work presented here, we use a more efficient greedy search algorithm for the best alignment, as suggested in Brown, Della Pietra, Della Pietra, and Mercer (1993).</S>
    <S sid="204" ssid="112">The basic idea is to compute the Viterbi alignment of a simple model (such as Model 2 or HMM).</S>
    <S sid="205" ssid="113">This alignment is then iteratively improved with respect to the alignment probability of the refined alignment model.</S>
    <S sid="206" ssid="114">(For further details on the greedy search algorithm, see Brown, Della Pietra, Della Pietra, and Mercer [1993].)</S>
    <S sid="207" ssid="115">In the Appendix, we present methods for performing an efficient computation of this pseudo-Viterbi alignment.</S>
  </SECTION>
  <SECTION title="3." number="4">
    <S sid="208" ssid="1">In this section, we describe our approach to determining the model parameters 0.</S>
    <S sid="209" ssid="2">Every model has a specific set of free parameters.</S>
    <S sid="210" ssid="3">For example, the parameters 0 for Model 4 consist of lexicon, alignment, and fertility parameters: To train the model parameters 0, we use a maximum-likelihood approach, as described in equation (4), by applying the EM algorithm (Baum 1972).</S>
    <S sid="211" ssid="4">The different models are trained in succession on the same data; the final parameter values of a simpler model serve as the starting point for a more complex model.</S>
    <S sid="212" ssid="5">In the E-step of Model 1, the lexicon parameter counts for one sentence pair (e, f) are calculated: Here, N(e, f) is the training corpus count of the sentence pair (f, e).</S>
    <S sid="213" ssid="6">In the M-step, the lexicon parameters are computed: Similarly, the alignment and fertility probabilities can be estimated for all other alignment models (Brown, Della Pietra, Della Pietra, and Mercer 1993).</S>
    <S sid="214" ssid="7">When bootstrapping from a simpler model to a more complex model, the simpler model is used to weigh the alignments, and the counts are accumulated for the parameters of the more complex model.</S>
    <S sid="215" ssid="8">In principle, the sum over all (I+ 1)J alignments has to be calculated in the E-step.</S>
    <S sid="216" ssid="9">Evaluating this sum by explicitly enumerating all alignments would be infeasible.</S>
    <S sid="217" ssid="10">Fortunately, Models 1 and 2 and HMM have a particularly simple mathematical form such that the EM algorithm can be implemented efficiently (i.e., in the E-step, it is possible to efficiently evaluate all alignments).</S>
    <S sid="218" ssid="11">For the HMM, this is referred to as the Baum-Welch algorithm (Baum 1972).</S>
    <S sid="219" ssid="12">Since we know of no efficient way to avoid the explicit summation over all alignments in the EM algorithm in the fertility-based alignment models, the counts are collected only over a subset of promising alignments.</S>
    <S sid="220" ssid="13">For Models 3 to 6, we perform the count collection only over a small number of good alignments.</S>
    <S sid="221" ssid="14">To keep the training fast, we consider only a small fraction of all alignments.</S>
    <S sid="222" ssid="15">We compare three different methods for using subsets of varying sizes: In Section 6, we show that by using the HMM instead of Model 2 in bootstrapping the fertility-based alignment models, the alignment quality can be significantly improved.</S>
    <S sid="223" ssid="16">In the Appendix, we present an efficient training algorithm of the fertilitybased alignment models.</S>
    <S sid="224" ssid="17">When using the EM algorithm on the standard versions of Models 3 and 4, we observe that during the EM iterations more and more words are aligned with the empty word.</S>
    <S sid="225" ssid="18">This results in a poor alignment quality, because too many words are aligned to the empty word.</S>
    <S sid="226" ssid="19">This progressive increase in the number of words aligned with the empty word does not occur when the other alignment models are used.</S>
    <S sid="227" ssid="20">We believe that this is due to the deficiency of Model 3 and Model 4.</S>
    <S sid="228" ssid="21">The use of the EM algorithm guarantees that the likelihood increases for each iteration.</S>
    <S sid="229" ssid="22">This holds for both deficient and nondeficient models.</S>
    <S sid="230" ssid="23">For deficient models, however, as the amount of deficiency in the model is reduced, the likelihood increases.</S>
    <S sid="231" ssid="24">In Models 3 and 4 as defined in Brown, Della Pietra, Della Pietra, and Mercer (1993), the alignment model for nonempty words is deficient, but the alignment model for the empty word is nondeficient.</S>
    <S sid="232" ssid="25">Hence, the EM algorithm can increase likelihood by simply aligning more and more words with the empty word.3 Therefore, we modify Models 3 and 4 slightly, such that the empty word also has a deficient alignment model.</S>
    <S sid="233" ssid="26">The alignment probability is set to p(j  |i, J) = 1/J for each source word aligned with the empty word.</S>
    <S sid="234" ssid="27">Another remedy, adopted in Och and Ney (2000), is to choose a value for the parameter p1 of the empty-word fertility and keep it fixed.</S>
    <S sid="235" ssid="28">To overcome the problem of overfitting on the training data and to enable the models to cope better with rare words, we smooth the alignment and fertility probabilities.</S>
    <S sid="236" ssid="29">For the alignment probabilities of the HMM (and similarly for Models 4 and 5), we perform an interpolation with a uniform distribution p(i  |j,I) = 1/I using an interpolation parameter &#945;: For the fertility probabilities, we assume that there is a dependence on the number of letters g(e) of e and estimate a fertility distribution p(&#966;  |g) using the EM algorithm.</S>
    <S sid="237" ssid="30">Typically, longer words have a higher fertility.</S>
    <S sid="238" ssid="31">By making this assumption, the model can learn that the longer words usually have a higher fertility than shorter words.</S>
    <S sid="239" ssid="32">Using an interpolation parameter &#946;, the fertility distribution is then computed as &#65533; p'(&#966;  |e)&#946;0 (e)) &#183; p(&#966;  |e) + 0 (e) &#183; p(&#966;  |g(e)) (38) Here, n(e) denotes the frequency of e in the training corpus.</S>
    <S sid="240" ssid="33">This linear interpolation ensures that for frequent words (i.e., n(e) &#187; &#946;), the specific distribution p(&#966;  |e) dominates, and that for rare words (i.e., n(e) &#171; &#946;), the general distribution p(&#966;  |g(e)) dominates.</S>
    <S sid="241" ssid="34">The interpolation parameters &#945; and &#946; are determined in such a way that the alignment quality on held-out data is optimized.</S>
    <S sid="242" ssid="35">A conventional bilingual dictionary can be considered an additional knowledge source that can be used in training.</S>
    <S sid="243" ssid="36">We assume that the dictionary is a list of word strings (e, f).</S>
    <S sid="244" ssid="37">The entries for each language can be a single word or an entire phrase.</S>
    <S sid="245" ssid="38">To integrate a dictionary into the EM algorithm, we compare two different methods: In this section, A(e) is an additional parameter describing the size of the sample that is used to estimate the model p(f  |e).</S>
    <S sid="246" ssid="39">This count is then used instead of N(e, f) in the EM algorithm as shown in equation (35).</S>
    <S sid="247" ssid="40">As a result, only dictionary entries that indeed occur in the training corpus have a large effect in training.</S>
    <S sid="248" ssid="41">The motivation behind this is to avoid a deterioration of the alignment as a result of out-of-domain dictionary entries.</S>
    <S sid="249" ssid="42">Every entry in the dictionary that does co-occur in the training corpus can be assumed correct and should therefore obtain a high count.</S>
    <S sid="250" ssid="43">We set &#181;&#8722; = 0.</S>
  </SECTION>
  <SECTION title="4." number="5">
    <S sid="251" ssid="1">In this section, we describe various methods for performing a symmetrization of our directed statistical alignment models by applying a heuristic postprocessing step that combines the alignments in both translation directions (source to target, target to source).</S>
    <S sid="252" ssid="2">The baseline alignment model does not allow a source word to be aligned with more than one target word.</S>
    <S sid="253" ssid="3">Therefore, lexical correspondences like that of the German compound word Zahnarzttermin with the English dentist&#8217;s appointment cause problems, because a single source word must be mapped to two or more target words.</S>
    <S sid="254" ssid="4">Therefore, the resulting Viterbi alignment of the standard alignment models has a systematic loss in recall.</S>
    <S sid="255" ssid="5">To solve this problem, we perform training in both translation directions (source to target, target to source).</S>
    <S sid="256" ssid="6">As a result, we obtain two alignments aJ1 and bI1 for each pair of sentences in the training corpus.</S>
    <S sid="257" ssid="7">Let A1 = {(aj, j)  |aj &gt; 01 and A2 = {(i, bi)  |bi &gt; 01 denote the sets of alignments in the two Viterbi alignments.</S>
    <S sid="258" ssid="8">To increase the quality of the alignments, we combine A1 and A2 into one alignment matrix A using the following combination methods: determined.</S>
    <S sid="259" ssid="9">The elements of this intersection result from both Viterbi alignments and are therefore very reliable.</S>
    <S sid="260" ssid="10">Then, we extend the alignment A iteratively by adding alignments (i, j) occurring only in the alignment A1 or in the alignment A2 if neither fj nor ei has an alignment in A, or if both of the following conditions hold: Obviously, the intersection of the two alignments yields an alignment consisting of only one-to-one alignments with a higher precision and a lower recall than either one separately.</S>
    <S sid="261" ssid="11">The union of the two alignments yields a higher recall and a lower precision of the combined alignment than either one separately.</S>
    <S sid="262" ssid="12">Whether a higher precision or a higher recall is preferred depends on the final application for which the word alignment is intended.</S>
    <S sid="263" ssid="13">In applications such as statistical machine translation (Och, Tillmann, and Ney 1999), a higher recall is more important (Och and Ney 2000), so an alignment union would probably be chosen.</S>
    <S sid="264" ssid="14">In lexicography applications, we might be interested in alignments with a very high precision obtained by performing an alignment intersection.</S>
  </SECTION>
  <SECTION title="5." number="6">
    <S sid="265" ssid="1">In the following, we present an annotation scheme for single-word-based alignments and a corresponding evaluation criterion.</S>
    <S sid="266" ssid="2">It is well known that manually performing a word alignment is a complicated and ambiguous task (Melamed 1998).</S>
    <S sid="267" ssid="3">Therefore, in performing the alignments for the research presented here, we use an annotation scheme that explicitly allows for ambiguous alignments.</S>
    <S sid="268" ssid="4">The persons conducting the annotation are asked to specify alignments of two different kinds: an S (sure) alignment, for alignments that are unambiguous, and a P (possible) alignment, for ambiguous alignments.</S>
    <S sid="269" ssid="5">The P label is used especially to align words within idiomatic expressions and free translations and missing function words (S &#8838; P).</S>
    <S sid="270" ssid="6">The reference alignment thus obtained may contain many-to-one and one-to-many relationships.</S>
    <S sid="271" ssid="7">Figure 2 shows an example of a manually aligned sentence with S and P labels.</S>
    <S sid="272" ssid="8">The quality of an alignment A = {(j, aj)  |aj &gt; 0} is then computed by appropriately redefined precision and recall measures: and the following alignment error rate (AER), which is derived from the well-known F-measure: A manual alignment with S (filled squares) and P (unfilled squares) connections.</S>
    <S sid="273" ssid="9">These definitions of precision, recall and the AER are based on the assumption that a recall error can occur only if an S alignment is not found and a precision error can occur only if the found alignment is not even P. The set of sentence pairs for which the manual alignment is produced is randomly selected from the training corpus.</S>
    <S sid="274" ssid="10">It should be emphasized that all the training of the models is performed in a completely unsupervised way (i.e., no manual alignments are used).</S>
    <S sid="275" ssid="11">From this point of view, there is no need to have a test corpus separate from the training corpus.</S>
    <S sid="276" ssid="12">Typically, the annotation is performed by two human annotators, producing sets S1, P1, S2, P2.</S>
    <S sid="277" ssid="13">To increase the quality of the resulting reference alignment, the annotators are presented with the mutual errors and asked to improve their alignments where possible.</S>
    <S sid="278" ssid="14">(Mutual errors of the two annotators A and B are the errors in the alignment of annotator A if we assume the alignment of annotator B as reference and the errors in the alignment of annotator B if we assume the alignment of annotator A as reference.)</S>
    <S sid="279" ssid="15">From these alignments, we finally generate a reference alignment that contains only those S connections on which both annotators agree and all P connections from both annotators.</S>
    <S sid="280" ssid="16">This can be accomplished by forming the intersection of the sure alignments (S = S1&#8745;S2) and the union of the possible alignments (P = P1&#8746;P2), respectively.</S>
    <S sid="281" ssid="17">By generating the reference alignment in this way, we obtain an alignment error rate of 0 percent when we compare the S alignments of every single annotator with the combined reference alignment.</S>
  </SECTION>
  <SECTION title="6." number="7">
    <S sid="282" ssid="1">We present in this section results of experiments involving the Verbmobil and Hansards tasks.</S>
    <S sid="283" ssid="2">The Verbmobil task (Wahlster 2000) is a (German-English) speech translation task in the domain of appointment scheduling, travel planning, and hotel reservation.</S>
    <S sid="284" ssid="3">The bilingual sentences used in training are correct transcriptions of spoken dialogues.</S>
    <S sid="285" ssid="4">However, they include spontaneous speech effects such as hesitations, false starts, and ungrammatical phrases.</S>
    <S sid="286" ssid="5">The French-English Hansards task consists of the debates in the Canadian parliament.</S>
    <S sid="287" ssid="6">This task has a very large vocabulary of about 100,000 French words and 80,000 English words.4 Statistics for the two corpora are shown in Tables 2 and 3.</S>
    <S sid="288" ssid="7">The number of running words and the vocabularies are based on full-form words and the punctuation marks.</S>
    <S sid="289" ssid="8">We produced smaller training corpora by randomly choosing 500, 2,000 and 8,000 sentences from the Verbmobil task and 500, 8,000, and 128,000 sentences from the Hansards task.</S>
    <S sid="290" ssid="9">For both tasks, we manually aligned a randomly chosen subset of the training corpus.</S>
    <S sid="291" ssid="10">From this subset of the corpus, the first 100 sentences are used as the development corpus to optimize the model parameters that are not trained via the EM algorithm (e.g., the smoothing parameters).</S>
    <S sid="292" ssid="11">The remaining sentences are used as the test corpus.</S>
    <S sid="293" ssid="12">The sequence of models used and the number of training iterations used for each model is referred to in the following as the training scheme.</S>
    <S sid="294" ssid="13">Our standard training scheme on Verbmobil is 15H5334363.</S>
    <S sid="295" ssid="14">This notation indicates that five iterations of Model 1, five iterations of HMM, three iterations of Model 3, three iterations of Model 4, and three iterations of Model 6 are performed.</S>
    <S sid="296" ssid="15">On Hansards, we use 15H10334363.</S>
    <S sid="297" ssid="16">This training scheme typically gives very good results and does not lead to overfitting.</S>
    <S sid="298" ssid="17">We use the slightly modified versions of Model 3 and Model 4 described in Section 3.2 and smooth the fertility and the alignment parameters.</S>
    <S sid="299" ssid="18">In the E-step of the EM algorithm for the fertility-based alignment models, we use the Viterbi alignment and its neighborhood.</S>
    <S sid="300" ssid="19">Unless stated otherwise, no bilingual dictionary is used in training.</S>
    <S sid="301" ssid="20">Tables 4 and 5 compare the alignment quality achieved using various models and training schemes.</S>
    <S sid="302" ssid="21">In general, we observe that the refined models (Models 4, 5, and 6) yield significantly better results than the simple Model 1 or Dice coefficient.</S>
    <S sid="303" ssid="22">Typically, the best results are obtained with Model 6.</S>
    <S sid="304" ssid="23">This holds across a wide range of sizes for the training corpus, from an extremely small training corpus of only 500 sentences up to a training corpus of 1.5 million sentences.</S>
    <S sid="305" ssid="24">The improvement that results from using a larger training corpus is more significant, however, if more refined models are used.</S>
    <S sid="306" ssid="25">Interestingly, even on a tiny corpus of only 500 sentences, alignment error rates under 30% are achieved for all models, and the best models have error rates somewhat under 20%.</S>
    <S sid="307" ssid="26">We observe that the alignment quality obtained with a specific model heavily depends on the training scheme that is used to bootstrap the model.</S>
    <S sid="308" ssid="27">Comparison of alignment error rate (in percent) for Model 1 and Dice coefficient (left: 34K Verbmobil task, right: 128K Hansards task).</S>
    <S sid="309" ssid="28">We pointed out in Section 2 that from a theoretical viewpoint, the main advantage of statistical alignment models in comparison to heuristic models is the well-founded mathematical theory that underlies their parameter estimation.</S>
    <S sid="310" ssid="29">Tables 4 and 5 show that the statistical alignment models significantly outperform the heuristic Dice coefficient and the heuristic Dice coefficient with competitive linking (Dice+C).</S>
    <S sid="311" ssid="30">Even the simple Model 1 achieves better results than the two Dice coefficient models.</S>
    <S sid="312" ssid="31">It is instructive to analyze the alignment quality obtained in the EM training of Model 1.</S>
    <S sid="313" ssid="32">Figure 3 shows the alignment quality over the iteration numbers of Model 1.</S>
    <S sid="314" ssid="33">We see that the first iteration of Model 1 achieves significantly worse results than the Dice coefficient, but by only the second iteration, Model 1 gives better results than the Dice coefficient.</S>
    <S sid="315" ssid="34">An important result of these experiments is that the hidden Markov alignment model achieves significantly better results than Model 2.</S>
    <S sid="316" ssid="35">We attribute this to the fact that the HMM is a homogeneous first-order alignment model, and such models are able to better represent the locality and monotonicity properties of natural languages.</S>
    <S sid="317" ssid="36">Both models have the important property of allowing an efficient implementation of the EM algorithm (Section 3).</S>
    <S sid="318" ssid="37">On the largest Verbmobil task, the HMM achieves an improvement of 3.8% over Model 2.</S>
    <S sid="319" ssid="38">On the largest Hansards task, the improvement is 8.7%.</S>
    <S sid="320" ssid="39">Interestingly, this advantage continues to hold after bootstrapping more refined models.</S>
    <S sid="321" ssid="40">On Model 4, the improvement is 1.4% and 4.8%, respectively.</S>
    <S sid="322" ssid="41">We conclude that it is important to bootstrap the refined alignment models with good initial parameters.</S>
    <S sid="323" ssid="42">Obviously, if we use Model 2 for bootstrapping, we eventually obtain a poor local optimum.</S>
    <S sid="324" ssid="43">In Tables 6 and 7, we compare the results obtained by using different numbers of alignments in the training of the fertility-based alignment models.</S>
    <S sid="325" ssid="44">We compare the three different approaches described in Section 3: using only the Viterbi alignment, using in addition the neighborhood of the Viterbi alignment, and using the pegged alignments.</S>
    <S sid="326" ssid="45">To reduce the training time, we restrict the number of pegged alignments by using only those in which Pr(f, a I e) is not much smaller than the probability of the Viterbi alignment.</S>
    <S sid="327" ssid="46">This reduces the training time drastically.</S>
    <S sid="328" ssid="47">For the large Hansards corpus, however, there still is an unacceptably large training time.</S>
    <S sid="329" ssid="48">Therefore, we report the results for only up to 128,000 training sentences.</S>
    <S sid="330" ssid="49">The effect of pegging strongly depends on the quality of the starting point used for training the fertility-based alignment models.</S>
    <S sid="331" ssid="50">If we use Model 2 as the starting point, we observe a significant improvement when we use the neighborhood alignments and the pegged alignments.</S>
    <S sid="332" ssid="51">If we use only the Viterbi alignment, the results are significantly worse than using additionally the neighborhood of the Viterbi alignment.</S>
    <S sid="333" ssid="52">If we use HMM as the starting point, we observe a much smaller effect.</S>
    <S sid="334" ssid="53">We conclude that using more alignments in training is a way to avoid a poor local optimum.</S>
    <S sid="335" ssid="54">Table 8 shows the computing time for performing one iteration of the EM algorithm.</S>
    <S sid="336" ssid="55">Using a larger set of alignments increases the training time for Model 4 and Model 5 significantly.</S>
    <S sid="337" ssid="56">Since using the pegging alignments yields only a moderate improvement in performance, all following results are obtained by using the neighborhood of the Viterbi alignment without pegging.</S>
    <S sid="338" ssid="57">Tables 9 and 10 show the effect on the alignment error rate of smoothing the alignment and fertility probabilities.</S>
    <S sid="339" ssid="58">We observe a significant improvement when we smooth the alignment probabilities and a minor improvement when we smooth the fertility probabilities.</S>
    <S sid="340" ssid="59">An analysis of the alignments shows that smoothing the fertility probabilities significantly reduces the frequently occurring problem of rare words forming &#8220;garbage collectors&#8221; in that they tend to align with too many words in the other language (Brown, Della Pietra, Della Pietra, Goldsmith, et al. 1993).</S>
    <S sid="341" ssid="60">Without smoothing, we observe early overfitting: The alignment error rate increases after the second iteration of HMM, as shown in Figure 4.</S>
    <S sid="342" ssid="61">On the Verbmobil task, the best alignment error rate is obtained in the second iteration.</S>
    <S sid="343" ssid="62">On the Hansards task, the best alignment error rate is obtained in the sixth iteration.</S>
    <S sid="344" ssid="63">In iterations subsequent to the second on the Verbmobil task and the sixth on the Hansards task, the alignment error rate increases significantly.</S>
    <S sid="345" ssid="64">With smoothing of the alignment paramOverfitting on the training data with the hidden Markov alignment model using various smoothing parameters (top: 34K Verbmobil task, bottom: 128K Hansards task). eters, we obtain a lower alignment error rate, overfitting occurs later in the process, and its effect is smaller.</S>
    <S sid="346" ssid="65">Tables 11 and 12 show the effects of including a dependence on word classes in the alignment model, as described in Section 2.3.</S>
    <S sid="347" ssid="66">The word classes are always trained on the same subset of the training corpus as is used for the training of the alignment models.</S>
    <S sid="348" ssid="67">We observe no significant improvement in performance as a result of including dependence on word classes when a small training corpus is used.</S>
    <S sid="349" ssid="68">A possible reason for this lack of improvement is that either the word classes themselves or the resulting large number of alignment parameters cannot be estimated reliably using a small training corpus.</S>
    <S sid="350" ssid="69">When a large training corpus is used, however, there is a clear improvement in performance on both the Verbmobil and the Hansards tasks.</S>
    <S sid="351" ssid="70">Tables 13 and 14 show the effect of using a conventional bilingual dictionary in training on the Verbmobil and Hansards tasks, respectively.</S>
    <S sid="352" ssid="71">We compare the two methods for using the dictionary described in Section 3.4.</S>
    <S sid="353" ssid="72">We observe that the method with a fixed threshold of &#181;+ = 16 gives the best results.</S>
    <S sid="354" ssid="73">The method with a varying &#181; gives worse results, but this method has one fewer parameter to be optimized on held-out data.</S>
    <S sid="355" ssid="74">On small corpora, there is an improvement of up to 6.7% on the Verbmobil task and 3.2% on the Hansards task, but when a larger training corpus is used, the improvements are reduced to 1.1% and 0.4%, respectively.</S>
    <S sid="356" ssid="75">Interestingly, the amount of the overall improvement contributed by the use of a conventional dictionary is small compared to the improvement achieved through the use of better alignment models.</S>
    <S sid="357" ssid="76">In this section, we compare the results obtained using different translation directions and using the symmetrization methods described in Section 4.</S>
    <S sid="358" ssid="77">Tables 15 and 16 show precision, recall, and alignment error rate for the last iteration of Model 6 for both translation directions.</S>
    <S sid="359" ssid="78">In this experiment, we use the conventional dictionary as well.</S>
    <S sid="360" ssid="79">Particularly for the Verbmobil task, with the language pair German-English, we observe that for German as the source language the alignment error rate is much higher than for English as source language.</S>
    <S sid="361" ssid="80">A possible reason for this difference in the alignment error rates is that the baseline alignment representation as a vector aJ1 does not allow German word compounds (which occur frequently) to be aligned with more than one English word.</S>
    <S sid="362" ssid="81">The effect of merging alignments by forming the intersection, the union, or the refined combination of the Viterbi alignments in both translation directions is shown in Tables 17 and 18.</S>
    <S sid="363" ssid="82">Figure 5 shows the corresponding precision/recall graphs.</S>
    <S sid="364" ssid="83">By using the refined combination, we can increase precision and recall on the Hansards task.</S>
    <S sid="365" ssid="84">The lowest alignment error rate on the Hansards task is obtained by using the intersection method.</S>
    <S sid="366" ssid="85">By forming a union or intersection of the alignments, we can obtain very high recall or precision values on both the Hansards task and the Verbmobil task.</S>
    <S sid="367" ssid="86">Alignment models similar to those studied in this article have been used as a starting point for refined phrase-based statistical machine translation systems (Alshawi, Bangalore, and Douglas 1998; Och, Tillmann, and Ney 1999; Ney et al. 2000).</S>
    <S sid="368" ssid="87">In Och and Ney (2000), the overall result of the experimental evaluation has been that an improved alignment quality yields an improved subjective quality of the statistical machine translation system as well.</S>
  </SECTION>
  <SECTION title="7." number="8">
    <S sid="369" ssid="1">In this article, we have discussed in detail various statistical and heuristic word alignment models and described various modifications and extensions to models known in the literature.</S>
    <S sid="370" ssid="2">We have developed a new statistical alignment model (Model 6) that has yielded the best results among all the models we considered in the experiments we have conducted.</S>
    <S sid="371" ssid="3">We have presented two methods for including a conventional bilingual dictionary in training and described heuristic symmetrization algorithms that combine alignments in both translation directions possible between two languages, producing an alignment with a higher precision, a higher recall, or an improved alignment error rate.</S>
    <S sid="372" ssid="4">We have suggested measuring the quality of an alignment model using the quality of the Viterbi alignment compared to that achieved in a manually produced reference alignment.</S>
    <S sid="373" ssid="5">This quality measure has the advantage of automatic evaluation.</S>
    <S sid="374" ssid="6">To produce the reference alignment, we have used a refined annotation scheme that reduces the problems and ambiguities associated with the manual construction of a word alignment.</S>
    <S sid="375" ssid="7">We have performed various experiments to assess the effect of different alignment models, training schemes, and knowledge sources.</S>
    <S sid="376" ssid="8">The key results of these experiments are as follows: Further improvements in alignments are expected to be produced through the adoption of cognates (Simard, Foster, and Isabelle 1992) and from statistical alignment models based on word groups rather than single words (Och, Tillmann, and Ney 1999).</S>
    <S sid="377" ssid="9">The use of models that explicitly deal with the hierarchical structures of natural language is very promising (Wu 1996; Yamada and Knight 2001).</S>
    <S sid="378" ssid="10">We plan to develop structured models for the lexicon, alignment, and fertility probabilities using maximum-entropy models.</S>
    <S sid="379" ssid="11">This is expected to allow an easy integration of more dependencies, such as in a second-order alignment model, without running into the problem of the number of alignment parameters getting unmanageably large.</S>
    <S sid="380" ssid="12">Furthermore, it will be important to verify the applicability of the statistical alignment models examined in this article to less similar language pairs such as ChineseEnglish and Japanese-English.</S>
  </SECTION>
  <SECTION title="Appendix: Efficient Training of Fertility-Based Alignment Models" number="9">
    <S sid="381" ssid="1">In this Appendix, we describe some methods for efficient training of fertility-based alignment models.</S>
    <S sid="382" ssid="2">The core idea is to enumerate only a small subset of good alignments in the E-step of the EM algorithm instead of enumerating all (I + 1)J alignments.</S>
    <S sid="383" ssid="3">This small subset of alignments is the set of neighboring alignments of the best alignment that can be found by a greedy search algorithm.</S>
    <S sid="384" ssid="4">We use two operators to transform alignments: The move operator m[i,j](a) changes aj := i, and the swap operator s[j1,j2](a) exchanges aj1 and aj2.</S>
    <S sid="385" ssid="5">The neighborhood N(a) of an alignment a is then defined as the set of all alignments that differ by one move or one swap from alignment a: For one step of the greedy search algorithm, we define the following hill-climbing operator (for Model 3), which yields for an alignment a the most probable alignment b(a) in the neighborhood N(a): Similarly, we define a hill-climbing operator for the other alignment models.</S>
    <S sid="386" ssid="6">A straightforward count collection procedure for a sentence pair (f,e) following the description in Brown, Della Pietra, Della Pietra, and Mercer (1993) is as follows:5 (d) Increase the counts for p1: A major part of the time in this procedure is spent on calculating the probability Pr(a'  |e, f) of an alignment a'.</S>
    <S sid="387" ssid="7">In general, this takes about (I + J) operations.</S>
    <S sid="388" ssid="8">Brown, Della Pietra, Della Pietra, and Mercer (1993) describe a method for obtaining Pr(a' | e, f) incrementally from Pr(a  |e, f) if alignment a differs only by moves or swaps from alignment a'.</S>
    <S sid="389" ssid="9">This method results in a constant number of operations that is sufficient to calculate the score of a move or the score of a swap.</S>
  </SECTION>
  <SECTION title="Refined Implementation: Fast Hill Climbing" number="10">
    <S sid="390" ssid="1">Analyzing the training program reveals that most of the time is spent on the computation of the costs of moves and swaps.</S>
    <S sid="391" ssid="2">To reduce the number of operations required in such computation, these values are cached in two matrices.</S>
    <S sid="392" ssid="3">We use one matrix for the scores of a move aj := i: and an additional matrix for the scores of a swap of aj and aj&#65533;: During the hill climbing, it is sufficient, after making a move or a swap, to update only those rows or columns in the matrix that are affected by the move or swap.</S>
    <S sid="393" ssid="4">For example, when performing a move aj := i, it is necessary to Similar updates have to be performed after a swap.</S>
    <S sid="394" ssid="5">In the count collection (step 3), it is possible to use the same matrices as obtained in the last hill-climbing step.</S>
    <S sid="395" ssid="6">By restricting in this way the number of matrix entries that need to be updated, it is possible to reduce the number of operations in hill climbing by about one order of magnitude.</S>
    <S sid="396" ssid="7">The straightforward algorithm given for performing the count collection has the disadvantage of requiring that all alignments in the neighborhood of alignment a be enumerated explicitly.</S>
    <S sid="397" ssid="8">In addition, it is necessary to perform a loop over all targets and a loop over all source positions to update the lexicon/alignment and the fertility counts.</S>
    <S sid="398" ssid="9">To perform the count collection in an efficient way, we use the fact that the alignments in the neighborhood N(a) are very similar.</S>
    <S sid="399" ssid="10">This allows the sharing of many operations in the count collection process.</S>
    <S sid="400" ssid="11">To efficiently obtain the alignment and lexicon probability counts, we introduce the following auxiliary quantities that use the move and swap matrices that are available after performing the hill climbing described above: For the alignment counts c(j  |i; e, f) and the lexicon counts c(f  |e; e, f), we have To obtain the fertility probability counts and the count for p1 efficiently, we introduce the following auxiliary quantities: These quantities do not depend on swaps, since a swap does not change the fertilities of an alignment.</S>
    <S sid="401" ssid="12">For the fertility counts, we have: Using the auxiliary quantities, a count collection algorithm can be formulated that requires about O(max(I, J)2) operations.</S>
    <S sid="402" ssid="13">This is one order of magnitude faster than the straightforward algorithm described above.</S>
    <S sid="403" ssid="14">In practice, we observe that the resulting training is 10&#8211;20 times faster.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="11">
    <S sid="404" ssid="1">This work has been partially supported as part of the Verbmobil project (contract number 01 IV 701 T4) by the German Federal Ministry of Education, Science, Research and Technology and as part of the EuTrans project (project number 30268) by the European Union.</S>
    <S sid="405" ssid="2">In addition, this work has been partially supported by the National Science Foundation under grant no.</S>
    <S sid="406" ssid="3">IIS-9820687 through the 1999 Workshop on Language Engineering, Center for Language and Speech Processing, Johns Hopkins University.</S>
    <S sid="407" ssid="4">All work for this paper was done at RWTH Aachen.</S>
  </SECTION>
</PAPER>
