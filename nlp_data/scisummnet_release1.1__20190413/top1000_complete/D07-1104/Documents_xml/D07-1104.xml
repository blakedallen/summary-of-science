<PAPER>
	<S sid="0">Hierarchical Phrase-Based Translation with Suffix Arrays</S><ABSTRACT>
		<S sid="1" ssid="1">A major engineering challenge in statistical machine translation systems is the efficient representation of extremely large translationrulesets.</S>
		<S sid="2" ssid="2">In phrase-based models, this prob lem can be addressed by storing the training data in memory and using a suffix array asan efficient index to quickly lookup and extract rules on the fly.</S>
		<S sid="3" ssid="3">Hierarchical phrasebased translation introduces the added wrin kle of source phrases with gaps.</S>
		<S sid="4" ssid="4">Lookup algorithms used for contiguous phrases nolonger apply and the best approximate pat tern matching algorithms are much too slow, taking several minutes per sentence.</S>
		<S sid="5" ssid="5">Wedescribe new lookup algorithms for hierar chical phrase-based translation that reduce the empirical computation time by nearly two orders of magnitude, making on-the-fly lookup feasible for source phrases with gaps.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number="1">
			<S sid="6" ssid="6">Current statistical machine translation systems rely on very large rule sets.</S>
			<S sid="7" ssid="7">In phrase-based systems, rules are extracted from parallel corpora containingtens or hundreds of millions of words.</S>
			<S sid="8" ssid="8">This can result in millions of rules using even the most conser vative extraction heuristics.</S>
			<S sid="9" ssid="9">Efficient algorithms for rule storage and access are necessary for practical decoding algorithms.</S>
			<S sid="10" ssid="10">They are crucial to keeping up with the ever-increasing size of parallel corpora, as well as the introduction of new data sources such as web-mined and comparable corpora.</S>
			<S sid="11" ssid="11">Until recently, most approaches to this probleminvolved substantial tradeoffs.</S>
			<S sid="12" ssid="12">The common practice of test set filtering renders systems impracti cal for all but batch processing.</S>
			<S sid="13" ssid="13">Tight restrictions on phrase length curtail the power of phrase-basedmodels.</S>
			<S sid="14" ssid="14">However, some promising engineering so lutions are emerging.</S>
			<S sid="15" ssid="15">Zens and Ney (2007) use a disk-based prefix tree, enabling efficient access to phrase tables much too large to fit in main memory.</S>
			<S sid="16" ssid="16">An alternative approach introduced independently by both Callison-Burch et al (2005) and Zhang and Vogel (2005) is to store the training data itself inmemory, and use a suffix array as an efficient in dex to look up, extract, and score phrase pairs on the fly.</S>
			<S sid="17" ssid="17">We believe that the latter approach has several important applications (?7).So far, these techniques have focused on phrase based models using contiguous phrases (Koehn et al., 2003; Och and Ney, 2004).</S>
			<S sid="18" ssid="18">Some recent models permit discontiguous phrases (Chiang, 2007; Quirket al, 2005; Simard et al, 2005).</S>
			<S sid="19" ssid="19">Of particular in terest to us is the hierarchical phrase-based model ofChiang (2007), which has been shown to be supe rior to phrase-based models.</S>
			<S sid="20" ssid="20">The ruleset extractedby this model is a superset of the ruleset in an equivalent phrase-based model, and it is an order of magnitude larger.</S>
			<S sid="21" ssid="21">This makes efficient rule representa tion even more critical.</S>
			<S sid="22" ssid="22">We tackle the problem using the online rule extraction method of Callison-Burch et al (2005) and Zhang and Vogel (2005).</S>
			<S sid="23" ssid="23">The problem statement for our work is: Given an input sentence, efficiently find all hierarchical phrase-based translation rules for that sentence in the training corpus.</S>
			<S sid="24" ssid="24">976 We first review suffix arrays (?2) and hierarchicalphrase-based translation (?3).</S>
			<S sid="25" ssid="25">We show that the obvious approach using state-of-the-art pattern match ing algorithms is hopelessly inefficient (?4).</S>
			<S sid="26" ssid="26">We then describe a series of algorithms to address thisinefficiency (?5).</S>
			<S sid="27" ssid="27">Our algorithms reduce computa tion time by two orders of magnitude, making the approach feasible (?6).</S>
			<S sid="28" ssid="28">We close with a discussion that describes several applications of our work (?7).</S>
	</SECTION>
	<SECTION title="Suffix Arrays. " number="2">
			<S sid="29" ssid="1">A suffix array is a data structure representing all suf fixes of a corpus in lexicographical order (Manber and Myers, 1993).</S>
			<S sid="30" ssid="2">Formally, for a text T , the ith suffix of T is the substring of the text beginning atposition i and continuing to the end of T . This suf fix can be uniquely identified by the index i of itsfirst word.</S>
			<S sid="31" ssid="3">The suffix array SAT of T is a permuta tion of [1, |T |] arranged by the lexicographical order of the corresponding suffixes.</S>
			<S sid="32" ssid="4">This representationenables fast lookup of any contiguous substring us ing binary search.</S>
			<S sid="33" ssid="5">Specifically, all occurrences of a length-m substring can be found in O(m + log |T |) time (Manber and Myers, 1993).</S>
			<S sid="34" ssid="6">1 Callison-Burch et al (2005) and Zhang and Vogel (2005) use suffix arrays as follows.</S>
			<S sid="35" ssid="7">1.</S>
			<S sid="36" ssid="8">Load the source training text F , the suffix array.</S>
			<S sid="37" ssid="9">SAF , the target training text E, and the align ment A into memory.</S>
			<S sid="38" ssid="10">2.</S>
			<S sid="39" ssid="11">For each input sentence, look up each substring.</S>
			<S sid="40" ssid="12">(phrase) f?</S>
			<S sid="41" ssid="13">of the sentence in the suffix array.</S>
			<S sid="42" ssid="14">aligned phrase e?</S>
			<S sid="43" ssid="15">using the phrase extraction method of Koehn et al (2003).</S>
			<S sid="44" ssid="16">4.</S>
			<S sid="45" ssid="17">Compute the relative frequency score p(e?|f?) of.</S>
			<S sid="46" ssid="18">each pair using the count of the extracted pair and the marginal count of f?</S>
			<S sid="47" ssid="19">5.</S>
			<S sid="48" ssid="20">Compute the lexical weighting score of the.</S>
			<S sid="49" ssid="21">phrase pair using the alignment that gives the best score.</S>
			<S sid="50" ssid="22">1Abouelhoda et al (2004) show that lookup can be done in optimal O(m) time using some auxiliaray data structures.</S>
			<S sid="51" ssid="23">Forour purposes O(m + log |T |) is practical, since for the 27M word corpus used to carry out our experiments, log |T | ? 25.</S>
			<S sid="52" ssid="24">6.</S>
			<S sid="53" ssid="25">Use the scored rules to translate the input sen-.</S>
			<S sid="54" ssid="26">tence with a standard decoding algorithm.</S>
			<S sid="55" ssid="27">A difficulty with this approach is step 3, which canbe quite slow.</S>
			<S sid="56" ssid="28">Its complexity is linear in the num ber of occurrences of the source phrase f?</S>
			<S sid="57" ssid="29">Both Callison-Burch et al (2005) and Zhang and Vogel (2005) solve this with sampling.</S>
			<S sid="58" ssid="30">If a source phraseappears more than k times, they sample only k oc currences for rule extraction.</S>
			<S sid="59" ssid="31">Both papers reportthat translation performance is nearly identical to ex tracting all possible phrases when k = 100.</S>
			<S sid="60" ssid="32">2</S>
	</SECTION>
	<SECTION title="Hierarchical Phrase-Based Translation. " number="3">
			<S sid="61" ssid="1">We consider the hierarchical translation model ofChiang (2007).</S>
			<S sid="62" ssid="2">Formally, this model is a syn chronous context-free grammar.</S>
			<S sid="63" ssid="3">The lexicalizedtranslation rules of the grammar may contain a sin gle nonterminal symbol, denoted X . We will use a, b, c and d to denote terminal symbols, and u, v, andw to denote (possibly empty) sequences of these ter minals.</S>
			<S sid="64" ssid="4">We will additionally use ? and ? to denote(possibly empty) sequences containing both termi nals and nonterminals.</S>
			<S sid="65" ssid="5">A translation rule is written X ? ?/?.</S>
			<S sid="66" ssid="6">This rule states that a span of the input matching ? is replacedby ? in translation.</S>
			<S sid="67" ssid="7">We require that ? and ? con tain an equal number (possibly zero) of coindexed nonterminals.</S>
			<S sid="68" ssid="8">An example rule with coindexes is X ? uX 1 vX 2w/u ?X 2 v ?X 1w ?.</S>
			<S sid="69" ssid="9">When discussing only the source side of such rules, we will leave out the coindexes.</S>
			<S sid="70" ssid="10">For instance, the source side of the above rule will be written uXvXw.</S>
			<S sid="71" ssid="11">3 For the purposes of this paper, we adhere to therestrictions described by Chiang (2007) for rules ex tracted from the training data.</S>
			<S sid="72" ssid="12">Rules can contain at most two nonterminals.</S>
			<S sid="73" ssid="13">Rules can contain at most five terminals.</S>
			<S sid="74" ssid="14">Rules can span at most ten words.</S>
			<S sid="75" ssid="15">2A sample size of 100 is actually quite small for many phrases, some of which occur tens or hundreds of thousands of times.</S>
			<S sid="76" ssid="16">It is perhaps surprising that such a small sample size works as well as the full data.</S>
			<S sid="77" ssid="17">However, recent work by Och (2005) and Federico and Bertoldi (2006) has shown that the statistics used by phrase-based systems are not very precise.</S>
			<S sid="78" ssid="18">3In the canonical representation of the grammar, source-sidecoindexes are always in sorted order, making them unambigu ous.</S>
			<S sid="79" ssid="19">977 ? Nonterminals must span at least two words.</S>
			<S sid="80" ssid="20">Adjacent nonterminals are disallowed in the source side of a rule.</S>
			<S sid="81" ssid="21">Expressed more economically, we say that our goal is to search for source phrases in the form u, uXv, or uXvXw, where 1 ? |uvw| ? 5, and |v| &gt; 0 in the final case.</S>
			<S sid="82" ssid="22">Note that the model also allows rules in the form Xu, uX , XuX , XuXv, and uXvX . However, these rules are lexically identical to other rules, and thus will match the same locations in the source text.</S>
	</SECTION>
	<SECTION title="The Collocation Problem. " number="4">
			<S sid="83" ssid="1">On-the-fly lookup using suffix arrays involves an added complication when the rules are in form uXv or uXvXw.</S>
			<S sid="84" ssid="2">Binary search enables fast lookup of contiguous substrings.</S>
			<S sid="85" ssid="3">However, it cannot be used for discontiguous substrings.</S>
			<S sid="86" ssid="4">Consider the rule aXbXc.</S>
			<S sid="87" ssid="5">If we search for this rule in the followinglogical suffix array fragment, we will find the bold faced matches.</S>
			<S sid="88" ssid="6">... a c a c b a d c a d ... a c a d b a a d b d ... a d d b a a d a b c ... a d d b d a a b b a ... a d d b d d c a a a ...</S>
			<S sid="89" ssid="7">Even though these suffixes are in lexicographicalorder, matching suffixes are interspersed with non matching suffixes.</S>
			<S sid="90" ssid="8">We will need another algorithmto find the source rules containing at least oneX surrounded by nonempty sequences of terminal sym bols.</S>
			<S sid="91" ssid="9">4.1 Baseline Approach.</S>
			<S sid="92" ssid="10">In the pattern-matching literature, words spanned by the nonterminal symbols of Chiang?s grammar are called don?t cares and a nonterminal symbol in a query pattern that matches a sequence of don?t caresis called a variable length gap.</S>
			<S sid="93" ssid="11">The search prob lem for patterns containing these gaps is a variant of approximate pattern matching, which has receivedsubstantial attention (Navarro, 2001).</S>
			<S sid="94" ssid="12">The best algo rithm for pattern matching with variable-length gaps in a suffix array is a recent algorithm by Rahman et al (2006).</S>
			<S sid="95" ssid="13">It works on a pattern w1Xw2X...wI consisting of I contiguous substrings w1, w2, ...wI ,each separated by a gap.</S>
			<S sid="96" ssid="14">The algorithm is straight forward.</S>
			<S sid="97" ssid="15">After identifying all ni occurrences of each wi in O(|wi| + log |T |) time, collocations thatmeet the gap constraints are computed using an ef ficient data structure called a stratified tree (van Emde Boas et al, 1977).</S>
			<S sid="98" ssid="16">4 Although we refer the reader to the source text for a full description of this data structure, its salient characteristic is that it implements priority queue operations insert and next-element in O(log log |T |) time.</S>
			<S sid="99" ssid="17">Therefore, thetotal running time for an algorithm to find all con tiguous subpatterns and compute their collocations is O( ?I i=1 [|wi|+ log|T |+ ni log log |T |]).</S>
			<S sid="100" ssid="18">We can improve on the algorithm of Rahman et al.</S>
			<S sid="101" ssid="19">(2006) using a variation on the idea of hashing.</S>
			<S sid="102" ssid="20">We exploit the fact that our large text is actually acollection of relatively short sentences, and that col located patterns must occur in the same sentence in order to be considered a rule.</S>
			<S sid="103" ssid="21">Therefore, we can use the sentence id of each subpattern occurrence as a kind of hash key.</S>
			<S sid="104" ssid="22">We create a hash table whosesize is exactly the number of sentences in our train ing corpus.</S>
			<S sid="105" ssid="23">Each location of the partially matched pattern w1X...Xwi is inserted into the hash bucket with the matching sentence id. To find collocated patterns wi+1, we probe the hash table with each of the ni+1 locations for that subpattern.</S>
			<S sid="106" ssid="24">When amatch is found, we compare the element with all el ements in the bucket to see if it is within the windowimposed by the phrase length constraints.</S>
			<S sid="107" ssid="25">Theoreti cally, the worst case for this algorithm occurs when all elements of both sets resolve to the same hash bucket, and we must compare all elements of one set with all elements of the other set.</S>
			<S sid="108" ssid="26">This leads to a worst case complexity of O( ?I i=1 [|wi|+ log|T |] +?Ii=1 ni).</S>
			<S sid="109" ssid="27">However, for real language data the per formance for sets of any significant size will be O( ?I i=1 [|wi|+ log|T |+ ni]), since most patterns will occur once in any given sentence.</S>
			<S sid="110" ssid="28">4.2 Analysis.</S>
			<S sid="111" ssid="29">It is instructive to compare this with the complex ity for contiguous phrases.</S>
			<S sid="112" ssid="30">In that case, total lookup time is O(|w| + log|T |) for a contiguous pattern w. 4Often known in the literature as a van Emde Boas tree or van Emde Boas priority queue.</S>
			<S sid="113" ssid="31">978 The crucial difference between the contiguous and discontiguous case is the added term ?I i=1 ni.</S>
			<S sid="114" ssid="32">Foreven moderately frequent subpatterns this term dom inates complexity.</S>
			<S sid="115" ssid="33">To make matters concrete, consider the training corpus used in our experiments (?6), which contains27M source words.</S>
			<S sid="116" ssid="34">The three most frequent uni grams occur 1.48M, 1.16M and 688K times ? thefirst two occur on average more than once per sen tence.</S>
			<S sid="117" ssid="35">In the worst case, looking up a contiguous phrase containing any number and combination ofthese unigrams requires no more than 25 compari son operations.</S>
			<S sid="118" ssid="36">In contrast, the worst case scenario for a pattern with a single gap, bookended on either side by the most frequent word, requires over two million operations using our baseline algorithm and over thirteen million using the algorithm of Rahman et al (2006).</S>
			<S sid="119" ssid="37">A single frequent word in an input sentence is enough to cause noticeable slowdowns, since it can appear in up to 530 hierarchical rules.To analyze the cost empirically, we ran our base line algorithm on the first 50 sentences of the NIST Chinese-English 2003 test set and measured the CPU time taken to compute collocations.</S>
			<S sid="120" ssid="38">We foundthat, on average, it took 2241.25 seconds (?37 min utes) per sentence just to compute all of the needed collocations.</S>
			<S sid="121" ssid="39">By comparison, decoding time persentence is roughly 10 seconds with moderately ag gressive pruning, using the Python implementation of Chiang (2007).</S>
	</SECTION>
	<SECTION title="Solving the Collocation Problem. " number="5">
			<S sid="122" ssid="1">Clearly, looking up patterns in this way is not prac tical.</S>
			<S sid="123" ssid="2">To analyze the problem, we measured the amount of CPU time per computation.</S>
			<S sid="124" ssid="3">Cumulative lookup time was dominated by a very small fraction of the computations (Fig.</S>
			<S sid="125" ssid="4">1).</S>
			<S sid="126" ssid="5">As expected, further analysis showed that these expensive computations all involved one or more very frequent subpatterns.</S>
			<S sid="127" ssid="6">In the worst cases a single collocation took severalseconds to compute.</S>
			<S sid="128" ssid="7">However, there is a silver lining.</S>
			<S sid="129" ssid="8">Patterns follow a Zipf distribution, so the number of pattern types that cause the problem is actu ally quite small.</S>
			<S sid="130" ssid="9">The vast majority of patterns arerare.</S>
			<S sid="131" ssid="10">Therefore, our solution focuses on computa tions where one or more of the component patternsis frequent.</S>
			<S sid="132" ssid="11">Assume that we are computing a collo Computations (ranked by time) C u m u l a t i v e T i m e ( s ) 300K 150K Figure 1: Ranked computations vs. cumulative time.</S>
			<S sid="133" ssid="12">A small fraction of all computations account for most of the computational time.</S>
			<S sid="134" ssid="13">cation of pattern w1X...Xwi and pattern wi+1, and we know all locations of each.</S>
			<S sid="135" ssid="14">There are three cases.</S>
			<S sid="136" ssid="15">If both patterns are frequent, we resort to a precomputed intersection (?5.1).</S>
			<S sid="137" ssid="16">We were notaware of any algorithms to substantially im prove the efficiency of this computation when it is requested on the fly, but precomputation can be done in a single pass over the text at decoder startup.</S>
			<S sid="138" ssid="17">If one pattern is frequent and the other is rare,we use an algorithm whose complexity is de pendent mainly on the frequency of the rare pattern (?5.2).</S>
			<S sid="139" ssid="18">It can also be used for pairs of rare patterns when one pattern is much rarer than the other.</S>
			<S sid="140" ssid="19">If both patterns are rare, no special algorithms are needed.</S>
			<S sid="141" ssid="20">Any linear algorithm will suffice.</S>
			<S sid="142" ssid="21">However, for reasons described in ?5.3, our other collocation algorithms depend on sorted sets, so we use a merge algorithm.Finally, in order to cut down on the number of un necessary computations, we use an efficient method to enumerate the phrases to lookup (?5.4).</S>
			<S sid="143" ssid="22">This method also forms the basis of various caching strategies for additional speedups.</S>
			<S sid="144" ssid="23">We analyze the memory use of our algorithms in ?5.5.</S>
			<S sid="145" ssid="24">5.1 Precomputation.</S>
			<S sid="146" ssid="25">Precomputation of the most expensive collocationscan be done in a single pass over the text.</S>
			<S sid="147" ssid="26">As in put, our algorithm requires the identities of the k 979 most frequent contiguous patterns.</S>
			<S sid="148" ssid="27">5 It then iterates over the corpus.</S>
			<S sid="149" ssid="28">Whenever a pattern from the list is seen, we push a tuple consisting of its identity and current location onto a queue.</S>
			<S sid="150" ssid="29">Whenever the oldest item on the queue falls outside the maximum phrase length window with respect to the current position,we compute that item?s collocation with all succeed ing patterns (subject to pattern length constraints) and pop it from the queue.</S>
			<S sid="151" ssid="30">We repeat this step for every item that falls outside the window.</S>
			<S sid="152" ssid="31">At the end of each sentence, we compute collocations for any remaining items in the queue and then empty it.</S>
			<S sid="153" ssid="32">Our precomputation includes the most frequent n-gram subpatterns.</S>
			<S sid="154" ssid="33">Most of these are unigrams, but in our experiments we found 5-grams among the 1000 most frequent patterns.</S>
			<S sid="155" ssid="34">We precompute the locations of source phrase uXv for any pair u and v that both appear on this list.</S>
			<S sid="156" ssid="35">There is alsoa small number of patterns uXv that are very frequent.</S>
			<S sid="157" ssid="36">We cannot easily obtain a list of these in ad vance, but we observe that they always consist of apair u and v of patterns from near the top of the frequency list.</S>
			<S sid="158" ssid="37">Therefore we also precompute the loca tions uXvXw of patterns in which both u and v are among these super-frequent patterns (all unigrams), treating this as the collocation of the frequent pattern uXv and frequent pattern w. We also compute the analagous case for u and vXw.</S>
			<S sid="159" ssid="38">5.2 Fast Intersection.</S>
			<S sid="160" ssid="39">For collocations of frequent and rare patterns, we use a fast set intersection method for sorted sets called double binary search (Baeza-Yates, 2004).</S>
			<S sid="161" ssid="40">6 It is based on the intuition that if one set in a pair of sorted sets is much smaller than the other, thenwe can compute their intersection efficiently by per forming a binary search in the larger data set D for each element of the smaller query set Q. Double binary search takes this idea a step further.It performs a binary search in D for the median ele ment of Q. Whether or not the element is found, the 5These can be identified using a single traversal over alongest common prefix (LCP) array, an auxiliary data struc ture of the suffix array, described by Manber and Myers (1993).</S>
			<S sid="162" ssid="41">Since we don?t need the LCP array at runtime, we chose to do this computation once offline.</S>
			<S sid="163" ssid="42">6Minor modifications are required since we are computing collocation rather than intersection.</S>
			<S sid="164" ssid="43">Due to space constraints, details and proof of correctness are available in Lopez (2007a).</S>
			<S sid="165" ssid="44">search divides both sets into two pairs of smaller sets that can be processed recursively.</S>
			<S sid="166" ssid="45">Detailed analysis and empirical results on an information retrieval task are reported in Baeza-Yates (2004) and Baeza-Yates and Salinger (2005).</S>
			<S sid="167" ssid="46">If |Q| log |D| &lt; |D| then theperformance is guaranteed to be sublinear.</S>
			<S sid="168" ssid="47">In practice it is often sublinear even if |Q| log |D| is somewhat larger than |D|.</S>
			<S sid="169" ssid="48">In our implementation we sim ply check for the condition ?|Q| log |D| &lt; |D| to decide whether we should use double binary search or the merge algorithm.</S>
			<S sid="170" ssid="49">This check is applied in the recursive cases as well as for the initial inputs.</S>
			<S sid="171" ssid="50">Thevariable ? can be adjusted for performance.</S>
			<S sid="172" ssid="51">We de termined experimentally that a good value for this parameter is 0.3.</S>
			<S sid="173" ssid="52">5.3 Obtaining Sorted Sets.</S>
			<S sid="174" ssid="53">Double binary search requires that its input sets be in sorted order.</S>
			<S sid="175" ssid="54">However, the suffix array returnsmatchings in lexicographical order, not numeric or der.</S>
			<S sid="176" ssid="55">The algorithm of Rahman et al (2006) deals with this problem by inserting the unordered items into a stratified tree.</S>
			<S sid="177" ssid="56">This requires O(n log log |T |) time for n items.</S>
			<S sid="178" ssid="57">If we used the same strategy, our algorithm would no longer be sublinear.An alternative is to precompute all n-gram occur rences in order and store them in an inverted index.</S>
			<S sid="179" ssid="58">This can be done in one pass over the data.</S>
			<S sid="180" ssid="59">7 This approach requires a separate inverted index for each n, up to the maximum n used by the model.</S>
			<S sid="181" ssid="60">The memory cost is one length-|T | array per index.</S>
			<S sid="182" ssid="61">In order to avoid the full n|T | cost in memory, our implementation uses a mixed strategy.</S>
			<S sid="183" ssid="62">We keep a precomputed inverted index only for unigrams.For bigrams and larger n-grams, we generate the in dex on the fly using stratified trees.</S>
			<S sid="184" ssid="63">This results in a superlinear algorithm for intersection.</S>
			<S sid="185" ssid="64">However,we can exploit the fact that we must compute col locations multiple times for each input n-gram by caching the sorted set after we create it (The cachingstrategy is described in ?5.4).</S>
			<S sid="186" ssid="65">Subsequent computations involving this n-gram can then be done in lin ear or sublinear time.</S>
			<S sid="187" ssid="66">Therefore, the cost of building the inverted index on the fly is amortized over a large number of computations.</S>
			<S sid="188" ssid="67">7We combine this step with the other precomputations that require a pass over the data, thereby removing a redundant O(|T |) term from the startup cost.</S>
			<S sid="189" ssid="68">980 5.4 Efficient Enumeration.</S>
			<S sid="190" ssid="69">A major difference between contiguous phrase based models and hierarchical phrase-based models is the number of rules that potentially apply to an input sentence.</S>
			<S sid="191" ssid="70">To make this concrete, on our data, with an average of 29 words per sentence, there were on average 133 contiguous phrases of length 5 orless that applied.</S>
			<S sid="192" ssid="71">By comparison, there were on av erage 7557 hierarchical phrases containing up to 5words.</S>
			<S sid="193" ssid="72">These patterns are obviously highly overlap ping and we employ an algorithm to exploit this fact.We first describe a baseline algorithm used for con tiguous phrases (?5.4.1).</S>
			<S sid="194" ssid="73">We then introduce some improvements (?5.4.2) and describe a data structureused by the algorithm (?5.4.3).</S>
			<S sid="195" ssid="74">Finally, we dis cuss some special cases for discontiguous phrases (?5.4.4).</S>
			<S sid="196" ssid="75">5.4.1 The Zhang-Vogel AlgorithmZhang and Vogel (2005) present a clever algorithm for contiguous phrase searches in a suffix ar ray.</S>
			<S sid="197" ssid="76">It exploits the fact that for eachm-length source phrase that we want to look up, we will also want to look up its (m? 1)-length prefix.</S>
			<S sid="198" ssid="77">They observe that the region of the suffix array containing all suffixes prefixed by ua is a subset of the region containingthe suffixes prefixed by u. Therefore, if we enumer ate the phrases of our sentence in such a way that we always search for u before searching for ua, wecan restrict the binary search for ua to the range con taining the suffixes prefixed by u. If the search for u fails, we do not need to search for ua at all.</S>
			<S sid="199" ssid="78">They show that this approach leads to some time savings for phrase search, although the gains are relatively modest since the search for contiguous phrases is not very expensive to begin with.</S>
			<S sid="200" ssid="79">However, the potential savings in the discontiguous case are much greater.</S>
			<S sid="201" ssid="80">5.4.2 Improvements and Extensions We can improve on the Zhang-Vogel algorithm.</S>
			<S sid="202" ssid="81">An m-length contiguous phrase aub depends not only on the existence of its prefix au, but also on the existence of its suffix ub.</S>
			<S sid="203" ssid="82">In the contiguous case, we cannot use this information to restrict the starting range of the binary search, but we can check for the existence of ub to decide whether we even need to search for aub at all.</S>
			<S sid="204" ssid="83">This can help us avoid searches that are guaranteed to be fruitless.</S>
			<S sid="205" ssid="84">Now consider the discontiguous case.</S>
			<S sid="206" ssid="85">As in the analogous contiguous case, a phrase a?b will onlyexist in the text if its maximal prefix a?</S>
			<S sid="207" ssid="86">and maxi mal suffix ?b both exist in the corpus and overlap at specific positions.</S>
			<S sid="208" ssid="87">8 Searching for a?b is potentially very expensive, so we put all available information to work.</S>
			<S sid="209" ssid="88">Before searching, we require that both a?and ?b exist.</S>
			<S sid="210" ssid="89">Additionally, we compute the location of a?b using the locations of both maximal sub phrases.</S>
			<S sid="211" ssid="90">To see why the latter optimization is useful, consider a phrase abXcd.</S>
			<S sid="212" ssid="91">In our baseline algorithm, we would search for ab and cd, and then perform a computation to see whether these subphrases were collocated within an elastic window.</S>
			<S sid="213" ssid="92">However, if weinstead use abXc and bXcd as the basis of the com putation, we gain two advantages.</S>
			<S sid="214" ssid="93">First, the number elements of each set is likely to be smaller then in the former case.</S>
			<S sid="215" ssid="94">Second, the computation becomes simpler, because we now only need to check to see whether the patterns exactly overlap with a starting offset of one, rather than checking within a window of locations.We can improve efficiency even further if we con sider cases where the same substring occurs morethan once within the same sentence, or even in mul tiple sentences.</S>
			<S sid="216" ssid="95">If the computation required to look up a phrase is expensive, we would like to performthe lookup only once.</S>
			<S sid="217" ssid="96">This requires some mecha nism for caching.</S>
			<S sid="218" ssid="97">Depending on the situation, we might want to cache only certain subsets of phrases, based on their frequency or difficulty to compute.We would also like the flexibility to combine on the-fly lookups with a partially precomputed phrase table, as in the online/offline mixture of Zhang and Vogel (2005).We need a data structure that provides this flex ibility, in addition to providing fast access to both the maximal prefix and maximal suffix of any phrase that we might consider.</S>
			<S sid="219" ssid="98">5.4.3 Prefix Trees and Suffix Links Our search optimizations are easily captured in a prefix tree data structure augmented with suffix links.Formally, a prefix tree is an unminimized determin istic finite-state automaton that recognizes all of thepatterns in some set.</S>
			<S sid="220" ssid="99">Each node in the tree repre8Except when ? = X , in which case a and b must be collo cated within a window defined by the phrase length constraints.</S>
			<S sid="221" ssid="100">981 ab b c cX X (1)(2) (3) d (4) d a b b c cX X (1)(2) (3) d (4) d a b b c cX X (1)(2) (3) d (4) d a b b c cX X (1)(2) (3) d (4) d X e a c d Case 1 Case 2 Figure 2: Illustration of prefix tree construction showing a partial prefix tree, including suffix links.</S>
			<S sid="222" ssid="101">Suppose we are interested in pattern abXcd, represented by node (1).</S>
			<S sid="223" ssid="102">Its prefix is represented by node (2), and node (2)?s suffix is represented by node (3).</S>
			<S sid="224" ssid="103">Therefore, node (1)?s suffix is represented by the node pointed to by the d-edge from node (3), which is node (4).</S>
			<S sid="225" ssid="104">There are two cases.</S>
			<S sid="226" ssid="105">In case 1, node (4) is inactive, so we can mark node (1) inactive and stop.</S>
			<S sid="227" ssid="106">In case 2, node (4) is active, so we compute the collocation of abXc and bXcd with information stored at nodes (2) and (4), using either a precomputed intersection, double binary search, or merge, depending on the size of the sets.</S>
			<S sid="228" ssid="107">If the result is empty, we mark the node inactive.</S>
			<S sid="229" ssid="108">Otherwise, we store the results at node (1) and add its successor patterns to the frontier for the next iteration.</S>
			<S sid="230" ssid="109">This includes all patterns containing exactly one more terminal symbol than the current pattern.</S>
			<S sid="231" ssid="110">sents the prefix of a unique pattern from the set that is specified by the concatenation of the edge labels along the path from the root to that node.</S>
			<S sid="232" ssid="111">A suffix link is a pointer from a node representing path a?</S>
			<S sid="233" ssid="112">to the node representing path ?.</S>
			<S sid="234" ssid="113">We will use this data structure to record the set of patterns that we have searched for and to cache information for those that were found successfully.</S>
			<S sid="235" ssid="114">Our algorithm generates the tree breadth-search along a frontier.</S>
			<S sid="236" ssid="115">In the mth iteration we only searchfor patterns containingm terminal symbols.</S>
			<S sid="237" ssid="116">Regardless of whether we find a particular pattern, we cre ate a node for it in the tree.</S>
			<S sid="238" ssid="117">If the pattern was found in the corpus, its node is marked active.</S>
			<S sid="239" ssid="118">Otherwise, it is marked inactive.</S>
			<S sid="240" ssid="119">For found patterns, we storeeither the endpoints of the suffix array range con taining the phrase (if it is contiguous), or the list oflocations at which the phrase is found (if it is dis contiguous).</S>
			<S sid="241" ssid="120">We can also store the extracted rules.</S>
			<S sid="242" ssid="121">9 Whenever a pattern is successfully found, we add all patterns with m + 1 terminals that are prefixed by it 9Conveniently, the implementation of Chiang (2007) uses aprefix tree grammar encoding, as described in Klein and Manning (2001).</S>
			<S sid="243" ssid="122">Our implementation decorates this tree with addi tional information required by our algorithms.</S>
			<S sid="244" ssid="123">to the frontier for processing in the next iteration.To search for a pattern, we use location infor mation from its parent node, which represents its maximal prefix.</S>
			<S sid="245" ssid="124">Assuming that the node representsphrase ?b, we find the node representing its max imal suffix by following the b-edge from the node pointed to by its parent node?s suffix link.</S>
			<S sid="246" ssid="125">If the node pointed to by this suffix link is inactive, we can mark the node inactive without running a search.</S>
			<S sid="247" ssid="126">When a node is marked inactive, we discontinue search for phrases that are prefixed by the path it represents.</S>
			<S sid="248" ssid="127">The algorithm is illustrated in Figure 2.</S>
			<S sid="249" ssid="128">5.4.4 Special Cases for Phrases with GapsA few subtleties arise in the extraction of hierarchical patterns.</S>
			<S sid="250" ssid="129">Gaps are allowed to occur at the be ginning or end of a phrase.</S>
			<S sid="251" ssid="130">For instance, we mayhave a source phrase Xu or uX or even XuX . Al though each of these phrases requires its own path in the prefix tree, they are lexically identical to phrase u. An analogous situation occurs with the patterns XuXv, uXvX , and uXv.</S>
			<S sid="252" ssid="131">There are two cases that we are concerned with.</S>
			<S sid="253" ssid="132">The first case consists of all patterns prefixed with X . The paths to nodes representing these patterns 982 will all contain the X-edge originating at the rootnode.</S>
			<S sid="254" ssid="133">All of these paths form the shadow subtree.</S>
			<S sid="255" ssid="134">Path construction in this subtree proceeds dif ferently.</S>
			<S sid="256" ssid="135">Because they are lexically identical to theirsuffixes, they are automatically extended if their suffix paths are active, and they inherit location infor mation of their suffixes.</S>
			<S sid="257" ssid="136">The second case consists of all patterns suffixedwith X . Whenever we successfully find a new pat tern ?, we automatically extend it with an X edge,provided that ?X is allowed by the model con straints.</S>
			<S sid="258" ssid="137">The node pointed to by this edge inheritsits location information from its parent node (repre senting the maximal prefix ?).</S>
			<S sid="259" ssid="138">Note that both special cases occur for patterns in the form XuX . 5.5 Memory Requirements.</S>
			<S sid="260" ssid="139">As shown in Callison-Burch et al (2005), we must keep an array for the source text F , its suffix array,the target text E, and alignment A in memory.</S>
			<S sid="261" ssid="140">As suming that A and E are roughly the size of F , thecost is 4|T |.</S>
			<S sid="262" ssid="141">If we assume that all data use vocabu laries that can be represented using 32-bit integers, then our 27M word corpus can easily be represented in around 500MB of memory.</S>
			<S sid="263" ssid="142">Adding the inverted index for unigrams increases this by 20%.</S>
			<S sid="264" ssid="143">The main additional cost in memory comes from the storage of the precomputed collocations.</S>
			<S sid="265" ssid="144">This is dependentboth on the corpus size and the number of colloca tions that we choose to precompute.</S>
			<S sid="266" ssid="145">Using detailed timing data from our experiments we were able to simulate the memory-speed tradeoff (Fig.</S>
			<S sid="267" ssid="146">3).</S>
			<S sid="268" ssid="147">If we include a trigram model trained on our bitext and the Chinese Gigaword corpus, the overall storage costs for our system are approximately 2GB.</S>
	</SECTION>
	<SECTION title="Experiments. " number="6">
			<S sid="269" ssid="1">All of our experiments were performed on ChineseEnglish in the news domain.</S>
			<S sid="270" ssid="2">We used a large train ing set consisting of over 1 million sentences from various newswire corpora.</S>
			<S sid="271" ssid="3">This corpus is roughly the same as the one used for large-scale experiments by Chiang et al (2005).</S>
			<S sid="272" ssid="4">To generate alignments,we used GIZA++ (Och and Ney, 2003).</S>
			<S sid="273" ssid="5">We symmetrized bidirectional alignments using the grow diag-final heuristic (Koehn et al, 2003).</S>
			<S sid="274" ssid="6">0 0 0 1000 0 Number of frequent subpatterns Insert text here 41 sec/sent 41 seconds 405 sec/sent 0 MB.</S>
			<S sid="275" ssid="7">725MB Figure 3: Effect of precomputation on memory useand processing time.</S>
			<S sid="276" ssid="8">Here we show only the mem ory requirements of the precomputed collocations.</S>
			<S sid="277" ssid="9">We used the first 50 sentences of the NIST 2003test set to compute timing results.</S>
			<S sid="278" ssid="10">All of our algo rithms were implemented in Python 2.4.</S>
			<S sid="279" ssid="11">10 Timingresults are reported for machines with 8GB of mem ory and 4 3GHz Xeon processors running Red Hat linux 2.6.9.</S>
			<S sid="280" ssid="12">In order to understand the contributions of various improvements, we also ran the system with with various ablations.</S>
			<S sid="281" ssid="13">In the default setting, the prefix tree is constructed for each sentence to guide phrase lookup, and then discarded.</S>
			<S sid="282" ssid="14">To showthe effect of caching we also ran the algorithm without discarding the prefix tree between sentences, re sulting in full inter-sentence caching.</S>
			<S sid="283" ssid="15">The results are shown in Table 1.</S>
			<S sid="284" ssid="16">11It is clear from the results that each of the op timizations is needed to sufficiently reduce lookuptime to practical levels.</S>
			<S sid="285" ssid="17">Although this is still rela tively slow, it is much closer to the decoding time of 10 seconds per sentence than the baseline.</S>
			<S sid="286" ssid="18">10Python is an interpreted language and our implementations do not use any optimization features.</S>
			<S sid="287" ssid="19">It is therefore reasonable to think that a more efficient reimplementation would result in across-the-board speedups.11The results shown here do not include the startup time re quired to load the data structures into memory.</S>
			<S sid="288" ssid="20">In our Python implementation this takes several minutes, which in principle should be amortized over the cost for each sentence.</S>
			<S sid="289" ssid="21">However,just as Zens and Ney (2007) do for phrase tables, we could com pile our data structures into binary memory-mapped files, whichcan be read into memory in a matter of seconds.</S>
			<S sid="290" ssid="22">We are cur rently investigating this option in a C reimplementation.</S>
			<S sid="291" ssid="23">983 Algorithms Secs/Sent Collocations Baseline 2241.25 325548 Prefix Tree 1578.77 69994 Prefix Tree + precomputation 696.35 69994 Prefix Tree + double binary 405.02 69994 Prefix Tree + precomputation + double binary 40.77 69994 Prefix Tree with full caching + precomputation + double binary 30.70 67712 Table 1: Timing results and number of collocations computed for various combinations of algorithms.</S>
			<S sid="292" ssid="24">The runs using precomputation use the 1000 most frequent patterns.</S>
	</SECTION>
	<SECTION title="Conclusions and Future Work. " number="7">
			<S sid="293" ssid="1">Our work solves a seemingly intractable problemand opens up a number of intriguing potential ap plications.</S>
			<S sid="294" ssid="2">Both Callison-Burch et al (2005) and Zhang and Vogel (2005) use suffix arrays to relax the length constraints on phrase-based models.</S>
			<S sid="295" ssid="3">Ourwork enables this in hierarchical phrase-based models.</S>
			<S sid="296" ssid="4">However, we are interested in additional appli cations.</S>
			<S sid="297" ssid="5">Recent work in discriminative learning for manynatural language tasks, such as part-of-speech tagging and information extraction, has shown that feature engineering plays a critical role in these approaches.</S>
			<S sid="298" ssid="6">However, in machine translation most fea tures can still be traced back to the IBM Models of 15 years ago (Lopez, 2007b).</S>
			<S sid="299" ssid="7">Recently, Lopez and Resnik (2006) showed that most of the features used in standard phrase-based models do not help very much.</S>
			<S sid="300" ssid="8">Our algorithms enable us to look up phrasepairs in context, which will allow us to compute interesting contextual features that can be used in discriminative learning algorithms to improve transla tion accuracy.</S>
			<S sid="301" ssid="9">Essentially, we can use the training data itself as an indirect representation of whateverfeatures we might want to compute.</S>
			<S sid="302" ssid="10">This is not pos sible with table-based architectures.Most of the data structures and algorithms discussed in this paper are widely used in bioinformatics, including suffix arrays, prefix trees, and suf fix links (Gusfield, 1997).</S>
			<S sid="303" ssid="11">As discussed in ?4.1, our problem is a variant of the approximate patternmatching problem.</S>
			<S sid="304" ssid="12">A major application of approx imate pattern matching in bioinformatics is queryprocessing in protein databases for purposes of se quencing, phylogeny, and motif identification.Current MT models, including hierarchical mod els, translate by breaking the input sentence intosmall pieces and translating them largely independently.</S>
			<S sid="305" ssid="13">Using approximate pattern matching algo rithms, we imagine that machine translation could be treated very much like search in a protein database.</S>
			<S sid="306" ssid="14">In this scenario, the goal is to select training sentences that match the input sentence as closely as possible, under some evaluation function that accounts for both matching and mismatched sequences, as well as possibly other data features.</S>
			<S sid="307" ssid="15">Once we have found the closest sentences we cantranslate the matched portions in their entirety, re placing mismatches with appropriate word, phrase, or hierarchical phrase translations as needed.</S>
			<S sid="308" ssid="16">This model would bring statistical machine translation closer to convergence with so-called example-based translation, following current trends (Marcu, 2001;Och, 2002).</S>
			<S sid="309" ssid="17">We intend to explore these ideas in fu ture work.</S>
			<S sid="310" ssid="18">AcknowledgementsI would like to thank Philip Resnik for encour agement, thoughtful discussions and wise counsel; David Chiang for providing the source code for his translation system; and Nitin Madnani, Smaranda Muresan and the anonymous reviewers for very helpful comments on earlier drafts of this paper.</S>
			<S sid="311" ssid="19">Any errors are my own.</S>
			<S sid="312" ssid="20">This research was supported in part by ONR MURI Contract FCPO.810548265 and the GALE program of the Defense AdvancedResearch Projects Agency, Contract No.</S>
			<S sid="313" ssid="21">HR0011 06-2-001.</S>
			<S sid="314" ssid="22">Any opinions, findings, conclusions or recommendations expressed in this paper are those of the author and do not necessarily reflect the view of DARPA.</S>
			<S sid="315" ssid="23">984</S>
	</SECTION>
</PAPER>
