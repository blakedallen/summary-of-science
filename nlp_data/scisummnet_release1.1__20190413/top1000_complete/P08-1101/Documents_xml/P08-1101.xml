<PAPER>
  <S sid="0">Joint Word Segmentation and POS Tagging Using a Single Perceptron</S>
  <ABSTRACT>
    <S sid="1" ssid="1">Chinese word segmentation is a preliminary step.</S>
    <S sid="2" ssid="2">To avoid error propagation and improve segmentation by utilizing segmentation and tagging can be performed simultaneously.</S>
    <S sid="3" ssid="3">A challenge for this joint approach is the large combined search space, which makes efficient decoding very hard.</S>
    <S sid="4" ssid="4">Recent research has explored integration of segmentation and tagging, by decoding under restricted versions of the full combined search space.</S>
    <S sid="5" ssid="5">In this paper, propose a joint segmentation and tagging model that does not impose any hard constraints on the interaction between word and Fast decoding is achieved by using a novel multiple-beam search algorithm.</S>
    <S sid="6" ssid="6">The system uses a discriminative statistical model, trained using the generalized perceptron algorithm.</S>
    <S sid="7" ssid="7">The joint model gives an error reduction in segmentation accuracy of an error reduction in tagging acof compared to the traditional pipeline approach.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="8" ssid="1">Since Chinese sentences do not contain explicitly marked word boundaries, word segmentation is a necessary step before POS tagging can be performed.</S>
    <S sid="9" ssid="2">Typically, a Chinese POS tagger takes segmented inputs, which are produced by a separate word segmentor.</S>
    <S sid="10" ssid="3">This two-step approach, however, has an obvious flaw of error propagation, since word segmentation errors cannot be corrected by the POS tagger.</S>
    <S sid="11" ssid="4">A better approach would be to utilize POS information to improve word segmentation.</S>
    <S sid="12" ssid="5">For example, the POS-word pattern &#8220;number word&#8221; + &#8220;^ (a common measure word)&#8221; can help in segmenting the character sequence &#8220;&#65533;^A&#8221; into the word sequence &#8220;&#65533; (one) ^ (measure word) A (person)&#8221; instead of &#8220;&#65533; (one) ^A (personal; adj)&#8221;.</S>
    <S sid="13" ssid="6">Moreover, the comparatively rare POS pattern &#8220;number word&#8221; + &#8220;number word&#8221; can help to prevent segmenting a long number word into two words.</S>
    <S sid="14" ssid="7">In order to avoid error propagation and make use of POS information for word segmentation, segmentation and POS tagging can be viewed as a single task: given a raw Chinese input sentence, the joint POS tagger considers all possible segmented and tagged sequences, and chooses the overall best output.</S>
    <S sid="15" ssid="8">A major challenge for such a joint system is the large search space faced by the decoder.</S>
    <S sid="16" ssid="9">For a sentence with n characters, the number of possible output sequences is O(2n&#8722;1 &#183; Tn), where T is the size of the tag set.</S>
    <S sid="17" ssid="10">Due to the nature of the combined candidate items, decoding can be inefficient even with dynamic programming.</S>
    <S sid="18" ssid="11">Recent research on Chinese POS tagging has started to investigate joint segmentation and tagging, reporting accuracy improvements over the pipeline approach.</S>
    <S sid="19" ssid="12">Various decoding approaches have been used to reduce the combined search space.</S>
    <S sid="20" ssid="13">Ng and Low (2004) mapped the joint segmentation and POS tagging task into a single character sequence tagging problem.</S>
    <S sid="21" ssid="14">Two types of tags are assigned to each character to represent its segmentation and POS.</S>
    <S sid="22" ssid="15">For example, the tag &#8220;b NN&#8221; indicates a character at the beginning of a noun.</S>
    <S sid="23" ssid="16">Using this method, POS features are allowed to interact with segmentation.</S>
    <S sid="24" ssid="17">Since tagging is restricted to characters, the search space is reduced to O((4T)'), and beam search decoding is effective with a small beam size.</S>
    <S sid="25" ssid="18">However, the disadvantage of this model is the difficulty in incorporating whole word information into POS tagging.</S>
    <S sid="26" ssid="19">For example, the standard &#8220;word + POS tag&#8221; feature is not explicitly applicable.</S>
    <S sid="27" ssid="20">Shi and Wang (2007) introduced POS information to segmentation by reranking.</S>
    <S sid="28" ssid="21">N-best segmentation outputs are passed to a separately-trained POS tagger, and the best output is selected using the overall POSsegmentation probability score.</S>
    <S sid="29" ssid="22">In this system, the decoding for word segmentation and POS tagging are still performed separately, and exact inference for both is possible.</S>
    <S sid="30" ssid="23">However, the interaction between POS and segmentation is restricted by reranking: POS information is used to improve segmentation only for the N segmentor outputs.</S>
    <S sid="31" ssid="24">In this paper, we propose a novel joint model for Chinese word segmentation and POS tagging, which does not limiting the interaction between segmentation and POS information in reducing the combined search space.</S>
    <S sid="32" ssid="25">Instead, a novel multiple beam search algorithm is used to do decoding efficiently.</S>
    <S sid="33" ssid="26">Candidate ranking is based on a discriminative joint model, with features being extracted from segmented words and POS tags simultaneously.</S>
    <S sid="34" ssid="27">The training is performed by a single generalized perceptron (Collins, 2002).</S>
    <S sid="35" ssid="28">In experiments with the Chinese Treebank data, the joint model gave an error reduction of 14.6% in segmentation accuracy and 12.2% in the overall segmentation and tagging accuracy, compared to the traditional pipeline approach.</S>
    <S sid="36" ssid="29">In addition, the overall results are comparable to the best systems in the literature, which exploit knowledge outside the training data, even though our system is fully data-driven.</S>
    <S sid="37" ssid="30">Different methods have been proposed to reduce error propagation between pipelined tasks, both in general (Sutton et al., 2004; Daum&#180;e III and Marcu, 2005; Finkel et al., 2006) and for specific problems such as language modeling and utterance classification (Saraclar and Roark, 2005) and labeling and chunking (Shimizu and Haas, 2006).</S>
    <S sid="38" ssid="31">Though our model is built specifically for Chinese word segmentation and POS tagging, the idea of using the perceptron model to solve multiple tasks simultaneously can be generalized to other tasks.</S>
  </SECTION>
  <SECTION title="2 The Baseline System" number="2">
    <S sid="39" ssid="1">We built a two-stage baseline system, using the perceptron segmentation model from our previous work (Zhang and Clark, 2007) and the perceptron POS tagging model from Collins (2002).</S>
    <S sid="40" ssid="2">We use baseline system to refer to the system which performs segmentation first, followed by POS tagging (using the single-best segmentation); baseline segmentor to refer to the segmentor from (Zhang and Clark, 2007) which performs segmentation only; and baseline POStagger to refer to the Collins tagger which performs POS tagging only (given segmentation).</S>
    <S sid="41" ssid="3">The features used by the baseline segmentor are shown in Table 1.</S>
    <S sid="42" ssid="4">The features used by the POS tagger, some of which are different to those from Collins (2002) and are specific to Chinese, are shown in Table 2.</S>
    <S sid="43" ssid="5">The word segmentation features are extracted from word bigrams, capturing word, word length and character information in the context.</S>
    <S sid="44" ssid="6">The word length features are normalized, with those more than 15 being treated as 15.</S>
    <S sid="45" ssid="7">The POS tagging features are based on contextual information from the tag trigram, as well as the neighboring three-word window.</S>
    <S sid="46" ssid="8">To reduce overfitting and increase the decoding speed, templates 4, 5, 6 and 7 only include words with less than 3 characters.</S>
    <S sid="47" ssid="9">Like the baseline segmentor, the baseline tagger also normalizes word length features.</S>
    <S sid="48" ssid="10">Templates 15 and 16 in Table 2 are inspired by the CTBMorph feature templates in Tseng et al. (2005), which gave the most accuracy improvement in their experiments.</S>
    <S sid="49" ssid="11">Here the category of a character is the set of tags seen on the character during training.</S>
    <S sid="50" ssid="12">Other morphological features from Tseng et al. (2005) are not used because they require extra web corpora besides the training data.</S>
    <S sid="51" ssid="13">During training, the baseline POS tagger stores special word-tag pairs into a tag dictionary (Ratnaparkhi, 1996).</S>
    <S sid="52" ssid="14">Such information is used by the decoder to prune unlikely tags.</S>
    <S sid="53" ssid="15">For each word occurring more than N times in the training data, the decoder can only assign a tag the word has been seen with in the training data.</S>
    <S sid="54" ssid="16">This method led to improvement in the decoding speed as well as the output accuracy for English POS tagging (Ratnaparkhi, 1996).</S>
    <S sid="55" ssid="17">Besides tags for frequent words, our baseline POS tagger also uses the tag dictionary to store closed-set tags (Xia, 2000) &#8211; those associated only with a limited number of Chinese words.</S>
  </SECTION>
  <SECTION title="3 Joint Segmentation and Tagging Model" number="3">
    <S sid="56" ssid="1">In this section, we build a joint word segmentation and POS tagging model that uses exactly the same source of information as the baseline system, by applying the feature templates from the baseline word segmentor and POS tagger.</S>
    <S sid="57" ssid="2">No extra knowledge is used by the joint model.</S>
    <S sid="58" ssid="3">However, because word segmentation and POS tagging are performed simultaneously, POS information participates in word segmentation.</S>
    <S sid="59" ssid="4">We formulate joint word segmentation and POS tagging as a single problem, which maps a raw Chinese sentence to a segmented and POS tagged output.</S>
    <S sid="60" ssid="5">Given an input sentence x, the output F(x) satisfies: where GEN(x) represents the set of possible outputs for x.</S>
    <S sid="61" ssid="6">Score(y) is computed by a feature-based linear model.</S>
    <S sid="62" ssid="7">Denoting the global feature vector for the tagged sentence y with 4b(y), we have: where w&#65533; is the parameter vector in the model.</S>
    <S sid="63" ssid="8">Each element in w&#65533; gives a weight to its corresponding element in 4b(y), which is the count of a particular feature over the whole sentence y.</S>
    <S sid="64" ssid="9">We calculate the w&#65533; value by supervised learning, using the averaged perceptron algorithm (Collins, 2002), given in Figure 1.</S>
    <S sid="65" ssid="10">1 We take the union of feature templates from the baseline segmentor (Table 1) and POS tagger (Table 2) as the feature templates for the joint system.</S>
    <S sid="66" ssid="11">All features are treated equally and processed together according to the linear model, regardless of whether they are from the baseline segmentor or tagger.</S>
    <S sid="67" ssid="12">In fact, most features from the baseline POS tagger, when used in the joint model, represent segmentation patterns as well.</S>
    <S sid="68" ssid="13">For example, the aforementioned pattern &#8220;number word&#8221; + &#8220;^&#8221;, which is Inputs: training examples (xi, yi) Initialization: set w&#65533; = 0 Algorithm: for t = 1..T, i = 1..N calculate zi = arg maxyEGEN(xi) &#934;(y) - w&#65533; if zi =&#65533; yi useful only for the POS &#8220;number word&#8221; in the baseline tagger, is also an effective indicator of the segmentation of the two words (especially &#8220;^&#8221;) in the joint model.</S>
    <S sid="69" ssid="14">One of the main challenges for the joint segmentation and POS tagging system is the decoding algorithm.</S>
    <S sid="70" ssid="15">The speed and accuracy of the decoder is important for the perceptron learning algorithm, but the system faces a very large search space of combined candidates.</S>
    <S sid="71" ssid="16">Given the linear model and feature templates, exact inference is very hard even with dynamic programming.</S>
    <S sid="72" ssid="17">Experiments with the standard beam-search decoder described in (Zhang and Clark, 2007) resulted in low accuracy.</S>
    <S sid="73" ssid="18">This beam search algorithm processes an input sentence incrementally.</S>
    <S sid="74" ssid="19">At each stage, the incoming character is combined with existing partial candidates in all possible ways to generate new partial candidates.</S>
    <S sid="75" ssid="20">An agenda is used to control the search space, keeping only the B best partial candidates ending with the current character.</S>
    <S sid="76" ssid="21">The algorithm is simple and efficient, with a linear time complexity of O(BTn), where n is the size of input sentence, and T is the size of the tag set (T = 1 for pure word segmentation).</S>
    <S sid="77" ssid="22">It worked well for word segmentation alone (Zhang and Clark, 2007), even with an agenda size as small as 8, and a simple beam search algorithm also works well for POS tagging (Ratnaparkhi, 1996).</S>
    <S sid="78" ssid="23">However, when applied to the joint model, it resulted in a reduction in segmentation accuracy (compared to the baseline segmentor) even with B as large as 1024.</S>
    <S sid="79" ssid="24">One possible cause of the poor performance of the standard beam search method is the combined nature of the candidates in the search space.</S>
    <S sid="80" ssid="25">In the baseInput: raw sentence sent &#8211; a list of characters Variables: candidate sentence item &#8211; a list of (word, tag) pairs; maximum word-length record maxlen for each tag; the agenda list agendas; the tag dictionary tagdict; start index for current word; end index for current word Initialization: agendas[0] = [&#8220;&#8221;], agendas[i] = [] (i!</S>
    <S sid="81" ssid="26">= 0) Algorithm: for end index = 1 to sent.length: foreach tag: for start index = max(1, end index &#8722; maxlen[tag] + 1) to end index: word = sent[start index..end index] if (word, tag) consistent with tagdict: for item E agendas[start index &#8722; 1]: line POS tagger, candidates in the beam are tagged sequences ending with the current word, which can be compared directly with each other.</S>
    <S sid="82" ssid="27">However, for the joint problem, candidates in the beam are segmented and tagged sequences up to the current character, where the last word can be a complete word or a partial word.</S>
    <S sid="83" ssid="28">A problem arises in whether to give POS tags to incomplete words.</S>
    <S sid="84" ssid="29">If partial words are given POS tags, it is likely that some partial words are &#8220;justified&#8221; as complete words by the current POS information.</S>
    <S sid="85" ssid="30">On the other hand, if partial words are not given POS tag features, the correct segmentation for long words can be lost during partial candidate comparison (since many short completed words with POS tags are likely to be preferred to a long incomplete word with no POS tag features).2 Another possible cause is the exponential growth in the number of possible candidates with increasing sentence size.</S>
    <S sid="86" ssid="31">The number increases from O(Tn) for the baseline POS tagger to O(2n&#8722;'Tn) for the joint system.</S>
    <S sid="87" ssid="32">As a result, for an incremental decoding algorithm, the number of possible candidates increases exponentially with the current word or character index.</S>
    <S sid="88" ssid="33">In the POS tagging problem, a new incoming word enlarges the number of possible candidates by a factor of T (the size of the tag set).</S>
    <S sid="89" ssid="34">For the joint problem, however, the enlarging factor becomes 2T with each incoming character.</S>
    <S sid="90" ssid="35">The speed of search space expansion is much faster, but the number of candidates is still controlled by a single, fixed-size beam at any stage.</S>
    <S sid="91" ssid="36">If we assume that the beam is not large enough for all the candidates at at each stage, then, from the newly generated candidates, the baseline POS tagger can keep 1/T for the next processing stage, while the joint model can keep only 1/2T, and has to discard the rest.</S>
    <S sid="92" ssid="37">Therefore, even when the candidate comparison standard is ignored, we can still see that the chance for the overall best candidate to fall out of the beam is largely increased.</S>
    <S sid="93" ssid="38">Since the search space growth is exponential, increasing the fixed beam size is not effective in solving the problem.</S>
    <S sid="94" ssid="39">To solve the above problems, we developed a multiple beam search algorithm, which compares candidates only with complete tagged words, and enables the size of the search space to scale with the input size.</S>
    <S sid="95" ssid="40">The algorithm is shown in Figure 2.</S>
    <S sid="96" ssid="41">In this decoder, an agenda is assigned to each character in the input sentence, recording the B best segmented and tagged partial candidates ending with the character.</S>
    <S sid="97" ssid="42">The input sentence is still processed incrementally.</S>
    <S sid="98" ssid="43">However, now when a character is processed, existing partial candidates ending with any previous characters are available.</S>
    <S sid="99" ssid="44">Therefore, the decoder enumerates all possible tagged words ending with the current character, and combines each word with the partial candidates ending with its previous character.</S>
    <S sid="100" ssid="45">All input characters are processed in the same way, and the final output is the best candidate in the final agenda.</S>
    <S sid="101" ssid="46">The time complexity of the algorithm is O(WTBn), with W being the maximum word size, T being the total number of POS tags and n the number of characters in the input.</S>
    <S sid="102" ssid="47">It is also linear in the input size.</S>
    <S sid="103" ssid="48">Moreover, the decoding algorithm gives competent accuracy with a small agenda size of B = 16.</S>
    <S sid="104" ssid="49">To further limit the search space, two optimizations are used.</S>
    <S sid="105" ssid="50">First, the maximum word length for each tag is recorded and used by the decoder to prune unlikely candidates.</S>
    <S sid="106" ssid="51">Because the majority of tags only apply to words with length 1 or 2, this method has a strong effect.</S>
    <S sid="107" ssid="52">Development tests showed that it improves the speed significantly, while having a very small negative influence on the accuracy.</S>
    <S sid="108" ssid="53">Second, like the baseline POS tagger, the tag dictionary is used for Chinese closed set tags and the tags for frequent words.</S>
    <S sid="109" ssid="54">To words outside the tag dictionary, the decoder still tries to assign every possible tag.</S>
    <S sid="110" ssid="55">Apart from features, the decoder maintains other types of information, including the tag dictionary, the word frequency counts used when building the tag dictionary, the maximum word lengths by tag, and the character categories.</S>
    <S sid="111" ssid="56">The above data can be collected by scanning the corpus before training starts.</S>
    <S sid="112" ssid="57">However, in both the baseline tagger and the joint POS tagger, they are updated incrementally during the perceptron training process, consistent with online learning.3 The online updating of word frequencies, maximum word lengths and character categories is straightforward.</S>
    <S sid="113" ssid="58">For the online updating of the tag dictionary, however, the decision for frequent words must be made dynamically because the word frequencies keep changing.</S>
    <S sid="114" ssid="59">This is done by caching the number of occurrences of the current most frequent word M, and taking all words currently above the threshold M/5000 + 5 as frequent words.</S>
    <S sid="115" ssid="60">5000 is a rough figure to control the number of frequent words, set according to Zipf&#8217;s law.</S>
    <S sid="116" ssid="61">The parameter 5 is used to force all tags to be enumerated before a word is seen more than 5 times.</S>
  </SECTION>
  <SECTION title="4 Related Work" number="4">
    <S sid="117" ssid="1">Ng and Low (2004) and Shi and Wang (2007) were described in the Introduction.</S>
    <S sid="118" ssid="2">Both models reduced the large search space by imposing strong restrictions on the form of search candidates.</S>
    <S sid="119" ssid="3">In particular, Ng and Low (2004) used character-based POS tagging, which prevents some important POS tagging features such as word + POS tag; Shi and Wang (2007) used an N-best reranking approach, which limits the influence of POS tagging on segmentation to the N-best list.</S>
    <S sid="120" ssid="4">In comparison, our joint model does not impose any hard limitations on the interaction between segmentation and POS information.4 Fast decoding speed is achieved by using a novel multiple-beam search algorithm.</S>
    <S sid="121" ssid="5">Nakagawa and Uchimoto (2007) proposed a hybrid model for word segmentation and POS tagging using an HMM-based approach.</S>
    <S sid="122" ssid="6">Word information is used to process known-words, and character information is used for unknown words in a similar way to Ng and Low (2004).</S>
    <S sid="123" ssid="7">In comparison, our model handles character and word information simultaneously in a single perceptron model.</S>
  </SECTION>
  <SECTION title="5 Experiments" number="5">
    <S sid="124" ssid="1">The Chinese Treebank (CTB) 4 is used for the experiments.</S>
    <S sid="125" ssid="2">It is separated into two parts: CTB 3 (420K characters in 150K words / 10364 sentences) is used for the final 10-fold cross validation, and the rest (240K characters in 150K words / 4798 sentences) is used as training and test data for development.</S>
    <S sid="126" ssid="3">The standard F-scores are used to measure both the word segmentation accuracy and the overall segmentation and tagging accuracy, where the overall accuracy is TF = 2pr/(p + r), with the precision p being the percentage of correctly segmented and tagged words in the decoder output, and the recall r being the percentage of gold-standard tagged words that are correctly identified by the decoder.</S>
    <S sid="127" ssid="4">For direct comparison with Ng and Low (2004), the POS tagging accuracy is also calculated by the percentage of correct tags on each character.</S>
    <S sid="128" ssid="5">The learning curves of the baseline and joint models are shown in Figure 3, Figure 4 and Figure 5, respectively.</S>
    <S sid="129" ssid="6">These curves are used to show the convergence of perceptron and decide the number of training iterations for the test.</S>
    <S sid="130" ssid="7">It should be noticed that the accuracies from Figure 4 and Figure 5 are not comparable because gold-standard segmentation is used as the input for the baseline tagger.</S>
    <S sid="131" ssid="8">According to the figures, the number of training iterations for the baseline segmentor, POS tagger, and the joint system are set to 8, 6, and 7, respectively for the remaining experiments.</S>
    <S sid="132" ssid="9">There are many factors which can influence the accuracy of the joint model.</S>
    <S sid="133" ssid="10">Here we consider the special character category features and the effect of the tag dictionary.</S>
    <S sid="134" ssid="11">The character category features (templates 15 and 16 in Table 2) represent a Chinese character by all the tags associated with the character in the training data.</S>
    <S sid="135" ssid="12">They have been shown to improve the accuracy of a Chinese POS tagger (Tseng et al., 2005).</S>
    <S sid="136" ssid="13">In the joint model, these features also represent segmentation information, since they concern the starting and ending characters of a word.</S>
    <S sid="137" ssid="14">Development tests showed that the overall tagging F-score of the joint model increased from 84.54% to 84.93% using the character category features.</S>
    <S sid="138" ssid="15">In the development test, the use of the tag dictionary improves the decoding speed of the joint model, reducing the decoding time from 416 seconds to 256 seconds.</S>
    <S sid="139" ssid="16">The overall tagging accuracy also increased slightly, consistent with observations from the pure POS tagger.</S>
    <S sid="140" ssid="17">The error analysis for the development test is shown in Table 3.</S>
    <S sid="141" ssid="18">Here an error is counted when a word in the standard output is not produced by the decoder, due to incorrect segmentation or tag assignment.</S>
    <S sid="142" ssid="19">Statistics about the six most frequently mistaken tags are shown in the table, where each row presents the analysis of one tag from the standard output, and each column gives a wrongly assigned value.</S>
    <S sid="143" ssid="20">The column &#8220;Seg&#8221; represents segmentation errors.</S>
    <S sid="144" ssid="21">Each figure in the table shows the percentage of the corresponding error from all the errors.</S>
    <S sid="145" ssid="22">It can be seen from the table that the NN-VV and VV-NN mistakes were the most commonly made by the decoder, while the NR-NN mistakes are also frequent.</S>
    <S sid="146" ssid="23">These three types of errors significantly outnumber the rest, together contributing 14.92% of all the errors.</S>
    <S sid="147" ssid="24">Moreover, the most commonly mistaken tags are NN and VV, while among the most frequent tags in the corpus, PU, DEG and M had comparatively less errors.</S>
    <S sid="148" ssid="25">Lastly, segmentation errors contribute around half (51.47%) of all the errors.</S>
    <S sid="149" ssid="26">10-fold cross validation is performed to test the accuracy of the joint word segmentor and POS tagger, and to make comparisons with existing models in the literature.</S>
    <S sid="150" ssid="27">Following Ng and Low (2004), we partition the sentences in CTB 3, ordered by sentence ID, into 10 groups evenly.</S>
    <S sid="151" ssid="28">In the nth test, the nth group is used as the testing data.</S>
    <S sid="152" ssid="29">Table 4 shows the detailed results for the cross validation tests, each row representing one test.</S>
    <S sid="153" ssid="30">As can be seen from the table, the joint model outperforms the baseline system in each test.</S>
    <S sid="154" ssid="31">Table 5 shows the overall accuracies of the baseline and joint systems, and compares them to the relevant models in the literature.</S>
    <S sid="155" ssid="32">The accuracy of each model is shown in a row, where &#8220;Ng&#8221; represents the models from Ng and Low (2004) and &#8220;Shi&#8221; represents the models from Shi and Wang (2007).</S>
    <S sid="156" ssid="33">Each accuracy measure is shown in a column, including the segmentation F-score (SF), the overall tagging F-score (TF) and the tagging accuracy by characters (TA).</S>
    <S sid="157" ssid="34">As can be seen from the table, our joint model achieved the largest improvement over the baseline, reducing the segmentation error by 14.58% and the overall tagging error by 12.18%.</S>
    <S sid="158" ssid="35">The overall tagging accuracy of our joint model was comparable to but less than the joint model of Shi and Wang (2007).</S>
    <S sid="159" ssid="36">Despite the higher accuracy improvement from the baseline, the joint system did not give higher overall accuracy.</S>
    <S sid="160" ssid="37">One likely reason is that Shi and Wang (2007) included knowledge about special characters and semantic knowledge from web corpora (which may explain the higher baseline accuracy), while our system is completely data-driven.</S>
    <S sid="161" ssid="38">However, the comparison is indirect because our partitions of the CTB corpus are different.</S>
    <S sid="162" ssid="39">Shi and Wang (2007) also chunked the sentences before doing 10-fold cross validation, but used an uneven split.</S>
    <S sid="163" ssid="40">We chose to follow Ng and Low (2004) and split the sentences evenly to facilitate further comparison.</S>
    <S sid="164" ssid="41">Compared with Ng and Low (2004), our baseline model gave slightly better accuracy, consistent with our previous observations about the word segmentors (Zhang and Clark, 2007).</S>
    <S sid="165" ssid="42">Due to the large accuracy gain from the baseline, our joint model performed much better.</S>
    <S sid="166" ssid="43">In summary, when compared with existing joint word segmentation and POS tagging systems in the literature, our proposed model achieved the best accuracy boost from the cascaded baseline, and competent overall accuracy.</S>
  </SECTION>
  <SECTION title="6 Conclusion and Future Work" number="6">
    <S sid="167" ssid="1">We proposed a joint Chinese word segmentation and POS tagging model, which achieved a considerable reduction in error rate compared to a baseline twostage system.</S>
    <S sid="168" ssid="2">We used a single linear model for combined word segmentation and POS tagging, and chose the generalized perceptron algorithm for joint training. and beam search for efficient decoding.</S>
    <S sid="169" ssid="3">However, the application of beam search was far from trivial because of the size of the combined search space.</S>
    <S sid="170" ssid="4">Motivated by the question of what are the comparable partial hypotheses in the space, we developed a novel multiple beam search decoder which effectively explores the large search space.</S>
    <S sid="171" ssid="5">Similar techniques can potentially be applied to other problems involving joint inference in NLP.</S>
    <S sid="172" ssid="6">Other choices are available for the decoding of a joint linear model, such as exact inference with dynamic programming, provided that the range of features allows efficient processing.</S>
    <S sid="173" ssid="7">The baseline feature templates for Chinese segmentation and POS tagging, when added together, makes exact inference for the proposed joint model very hard.</S>
    <S sid="174" ssid="8">However, the accuracy loss from the beam decoder, as well as alternative decoding algorithms, are worth further exploration.</S>
    <S sid="175" ssid="9">The joint system takes features only from the baseline segmentor and the baseline POS tagger to allow a fair comparison.</S>
    <S sid="176" ssid="10">There may be additional features that are particularly useful to the joint system.</S>
    <S sid="177" ssid="11">Open features, such as knowledge of numbers and European letters, and relationships from semantic networks (Shi and Wang, 2007), have been reported to improve the accuracy of segmentation and POS tagging.</S>
    <S sid="178" ssid="12">Therefore, given the flexibility of the feature-based linear model, an obvious next step is the study of open features in the joint segmentor and POS tagger.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="7">
    <S sid="179" ssid="1">We thank Hwee-Tou Ng and Mengqiu Wang for their helpful discussions and sharing of experimental data, and the anonymous reviewers for their suggestions.</S>
    <S sid="180" ssid="2">This work is supported by the ORS and Clarendon Fund.</S>
  </SECTION>
</PAPER>
