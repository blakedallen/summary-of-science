<PAPER>
  <S sid="0">Knowledge-Free Induction Of Morphology Using Latent Semantic Analysis</S>
  <ABSTRACT>
    <S sid="1" ssid="1">Morphology induction is a subproblem of important tasks like automatic learning of machine-readable dictionaries and grammar induction.</S>
    <S sid="2" ssid="2">Previous morphology induction approaches have relied solely on statistics of hypothesized stems and affixes to choose which affixes to consider legitimate.</S>
    <S sid="3" ssid="3">Relying on stemand-affix statistics rather than semantic knowledge leads to a number of problems, such as the inappropriate use of valid affixes (&amp;quot;ally&amp;quot; stemming to &amp;quot;all&amp;quot;).</S>
    <S sid="4" ssid="4">We introduce a semantic-based algorithm for learning morphology which only proposes affixes when the stem and stem-plusaffix are sufficiently similar semantically.</S>
    <S sid="5" ssid="5">We implement our approach using Latent Semantic Analysis and show that our semantics-only approach provides morphology induction results that rival a current state-of-the-art system.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="6" ssid="1">Computational morphological analyzers have existed in various languages for years and it has been said that &amp;quot;the quest for an efficient method for the analysis and generation of word-forms is no longer an academic research topic&amp;quot; (Karlsson and Karttunen, 1997).</S>
    <S sid="7" ssid="2">However, development of these analyzers typically begins with human intervention requiring time spans from days to weeks.</S>
    <S sid="8" ssid="3">If it were possible to build such analyzers automatically without human knowledge, significant development time could be saved.</S>
    <S sid="9" ssid="4">On a larger scale, consider the task of inducing machine-readable dictionaries (MRDs) using no human-provided information (&amp;quot;knowledge-free&amp;quot;).</S>
    <S sid="10" ssid="5">In building an MRD, &amp;quot;simply expanding the dictionary to encompass every word one is ever likely to encounter.. .fails to take advantage of regularities&amp;quot; (Sproat, 1992, p. xiii).</S>
    <S sid="11" ssid="6">Hence, automatic morphological analysis is also critical for selecting appropriate and non-redundant MRD headwords.</S>
    <S sid="12" ssid="7">For the reasons expressed above, we are interested in knowledge-free morphology induction.</S>
    <S sid="13" ssid="8">Thus, in this paper, we show how to automatically induce morphological relationships between words.</S>
    <S sid="14" ssid="9">Previous morphology induction approaches (Goldsmith, 1997, 2000; Mean, 1998; Gaussier, 1999) have focused on inflectional languages and have used statistics of hypothesized stems and affixes to choose which affixes to consider legitimate.</S>
    <S sid="15" ssid="10">Several problems can arise using only stem-and-affix statistics: (1) valid affixes may be applied inappropriately (&amp;quot;ally&amp;quot; stemming to &amp;quot;all&amp;quot;), (2) morphological ambiguity may arise (&amp;quot;rating&amp;quot; conflating with &amp;quot;rat&amp;quot; instead of &amp;quot;rate&amp;quot;), and (3) non-productive affixes may get accidentally pruned (the relationship between &amp;quot;dirty&amp;quot; and &amp;quot;dirt&amp;quot; may be lost).1 Some of these problems could be resolved if one could incorporate word semantics.</S>
    <S sid="16" ssid="11">For instance, &amp;quot;all&amp;quot; is not semantically similar to &amp;quot;ally,&amp;quot; so with knowledge of semantics, an algorithm could avoid conflating these two words.</S>
    <S sid="17" ssid="12">To maintain the &amp;quot;knowledge-free&amp;quot; paradigm, such semantics would need to be automatically induced.</S>
    <S sid="18" ssid="13">Latent Semantic Analysis (LSA) (Deerwester, et al., 1990); Landauer, et at., 1998) is a technique which automatically identifies semantic information from a corpus.</S>
    <S sid="19" ssid="14">We here show that incorporating LSA-based semantics alone into the morphology-induction process can provide results that rival a state-ofthe-art system based on stem-and-affix statistics (Goldsmith's Linguistica). lError examples are from Goldsmith's Linguistica Our algorithm automatically extracts potential affixes from an untagged corpus, identifies word pairs sharing the same proposed stem but having different affixes, and uses LSA to judge semantic relatedness between word pairs.</S>
    <S sid="20" ssid="15">This process serves to identify valid morphological relations.</S>
    <S sid="21" ssid="16">Though our algorithm could be applied to any inflectional language, we here restrict it to English in order to perform evaluations against the human-labeled CELEX database (Baayen, et al., 1993).</S>
  </SECTION>
  <SECTION title="2 Previous work" number="2">
    <S sid="22" ssid="1">Existing induction algorithms all focus on identifying prefixes, suffixes, and word stems in inflectional languages (avoiding infixes and other language types like concatenative or agglutinative languages (Sproat, 1992)).</S>
    <S sid="23" ssid="2">They also observe high frequency occurrences of some word endings or beginnings, perform statistics thereon, and propose that some of these appendages are valid morphemes.</S>
    <S sid="24" ssid="3">However, these algorithms differ in specifics.</S>
    <S sid="25" ssid="4">DeJean (1998) uses an approach derived from Harris (1951) where word-splitting occurs if the number of distinct letters that follows a given sequence of characters surpasses a threshold.</S>
    <S sid="26" ssid="5">He uses these hypothesized affixes to resegment words and thereby identify additional affixes that were initially overlooked.</S>
    <S sid="27" ssid="6">His overall goal is different from ours: he primarily seeks an affix inventory.</S>
    <S sid="28" ssid="7">Goldsmith (1997) tries cutting each word in exactly one place based on probability and lengths of hypothesized stems and affixes.</S>
    <S sid="29" ssid="8">He applies the EM algorithm to eliminate inappropriate parses.</S>
    <S sid="30" ssid="9">He collects the possible suffixes for each stem calling these a signature which aid in determining word classes.</S>
    <S sid="31" ssid="10">Goldsmith (2000) later incorporates minimum description length to identify stemming characteristics that most compress the data, but his algorithm otherwise remains similar in nature.</S>
    <S sid="32" ssid="11">Goldsmith's algorithm is practically knowledge-free, though he incorporates capitalization removal and some word segmentation.</S>
    <S sid="33" ssid="12">Gaussier (1999) begins with an inflectional lexicon and seeks to find derivational morphology.</S>
    <S sid="34" ssid="13">The words and parts of speech from his inflectional lexicon serve for building relational families of words and identifying sets of word pairs and suffixes therefrom.</S>
    <S sid="35" ssid="14">Gaussier splits words based on p-similarity &#8212; words that agree in exactly the first p characters.</S>
    <S sid="36" ssid="15">He also builds a probabilistic model which indicates that the probability of two words being morphological variants is based upon the probability of their respective changes in orthography and morphosynt act ics .</S>
  </SECTION>
  <SECTION title="3 Current approach" number="3">
    <S sid="37" ssid="1">Our algorithm also focuses on inflectional languages.</S>
    <S sid="38" ssid="2">However, with the exception of word segmentation, we provide it no human information and we consider only the impact of semantics.</S>
    <S sid="39" ssid="3">Our approach (see Figure 1) can be decomposed into four components: (1) initially selecting candidate affixes, (2) identifying affixes which are potential morphological variants of each other, (3) computing semantic vectors for words possessing these candidate affixes, and (4) selecting as valid morphological variants those words with similar semantic vectors.</S>
    <S sid="40" ssid="4">To select candidate affixes, we, like Gaussier, identify p-similar words.</S>
    <S sid="41" ssid="5">We insert words into a trie (Figure 2) and extract potential affixes by observing those places in the trie where branching occurs.</S>
    <S sid="42" ssid="6">Figure 2's hypothesized suffixes are NULL, &amp;quot;s,&amp;quot; &amp;quot;ed,&amp;quot; &amp;quot;es,&amp;quot; &amp;quot;ing,&amp;quot; &amp;quot;e,&amp;quot; and &amp;quot;eful.&amp;quot; We retain only the K most-frequent candidate affixes for subsequent processing.</S>
    <S sid="43" ssid="7">The value for K needs to be large enough to account for the number of expected regular affixes in any given language as well as some of the more frequent irregular affixes.</S>
    <S sid="44" ssid="8">We arbitrarily chose K to be 200 in our system.</S>
    <S sid="45" ssid="9">(It should also be mentioned that we can identify potential prefixes by inserting words into the trie in reversed order.</S>
    <S sid="46" ssid="10">This prefix mode can additionally serve for identifying capitalization.)</S>
    <S sid="47" ssid="11">Stage 3 Stage 4 ind wo-r\ pairs that are possible morphoWe next identify pairs of candidate affixes that descend from a common ancestor node in the trie.</S>
    <S sid="48" ssid="12">For example, (&amp;quot;s&amp;quot;, NULL) constitutes such a pair from Figure 2.</S>
    <S sid="49" ssid="13">We call these pairs rules.</S>
    <S sid="50" ssid="14">Two words sharing the same root and the same affix rule, such as &amp;quot;cars&amp;quot; and &amp;quot;car,&amp;quot; form what we call a pair of potential morphological variants (PPMVs).</S>
    <S sid="51" ssid="15">We define the ruleset of a given rule to be the set of all PPM Vs that have that rule in common.</S>
    <S sid="52" ssid="16">For instance, from Figure 2, the ruleset for (&amp;quot;s&amp;quot;, NULL) would be the pairs &amp;quot;cars/car&amp;quot; and &amp;quot;cares/care.&amp;quot; Our algorithm establishes a list which identifies the rulesets for every hypothesized rule extracted from the data and then it must proceed to determine which rulesets or PPM Vs describe true morphological relationships.</S>
    <S sid="53" ssid="17">Deerwester, et al. (1990) showed that it is possible to find significant semantic relationships between words and documents in a corpus with virtually no human intervention (with the possible exception of a human-built stop word list).</S>
    <S sid="54" ssid="18">This is typically done by applying singular value decomposition (SVD) to a matrix, M, where each entry M(i,j) contains the frequency of word i as seen in document j of the corpus.</S>
    <S sid="55" ssid="19">This methodology is referred to as Latent Semantic Analysis (LSA) and is well-described in the literature (Landauer, et al., 1998; Manning and Schiitze, 1999).</S>
    <S sid="56" ssid="20">SVDs seek to decompose a matrix A into the product of three matrices U, D, and VT where U and VT are orthogonal matrices and D is a diagonal matrix containing the singular values (squared eigenvalues) of A.</S>
    <S sid="57" ssid="21">Since SVD's can be performed which identify singular values by descending order of size (Berry, et al., 1993), LSA truncates after finding the k largest singular values.</S>
    <S sid="58" ssid="22">This corresponds to projecting the vector representation of each word into a k-dimensional subspace whose axes form k (latent) semantic directions.</S>
    <S sid="59" ssid="23">These projections are precisely the rows of the matrix product UkDk.</S>
    <S sid="60" ssid="24">A typical k is 300, which is the value we used.</S>
    <S sid="61" ssid="25">However, we have altered the algorithm somewhat to fit our needs.</S>
    <S sid="62" ssid="26">First, to stay as close to the knowledge-free scenario as possible, we neither apply a stopword list nor remove capitalization.</S>
    <S sid="63" ssid="27">Secondly, since SVDs are more designed to work on normally-distributed data (Manning and Schiitze, 1999, p. 565), we operate on Zscores rather than counts.</S>
    <S sid="64" ssid="28">Lastly, instead of generating a term-document matrix, we build a term-term matrix.</S>
    <S sid="65" ssid="29">Schiitze (1993) achieved excellent performance at classifying words into quasi-partof-speech classes by building and performing an SVD on an Nx4N term-term matrix, M(i,Np+j).</S>
    <S sid="66" ssid="30">The indices i and j represent the top N highest frequency words.</S>
    <S sid="67" ssid="31">The p values range from 0 to 3 representing whether the word indexed by j is positionally offset from the word indexed by i by -2, -1, +1, or +2, respectively.</S>
    <S sid="68" ssid="32">For example, if &amp;quot;the&amp;quot; and &amp;quot;people&amp;quot; were respectively the 1st and 100th highest frequency words, then upon seeing the phrase &amp;quot;the people,&amp;quot; Schiitze's approach would increment the counts of M(1,2N+100) and M(100,N+1).</S>
    <S sid="69" ssid="33">We used Schfitze's general framework but tailored it to identify local semantic information.</S>
    <S sid="70" ssid="34">We built an Nx2N matrix and our p values correspond to those words whose offsets from word i are in the intervals [-50,-1] and [1,50], respectively.</S>
    <S sid="71" ssid="35">We also reserve the Nth position as a catch-all position to account for all words that are not in the top (N-1).</S>
    <S sid="72" ssid="36">An important issue to resolve is how large should N be.</S>
    <S sid="73" ssid="37">We would like to be able to incorporate semantics for an arbitrarily large number of words and LSA quickly becomes impractical on large sets.</S>
    <S sid="74" ssid="38">Fortunately, it is possible to build a matrix with a smaller value of N (say, 2500), perform an SVD thereon, and then fold in remaining terms (Manning and Schaze, 1999, p. 563).</S>
    <S sid="75" ssid="39">Since the U and V matrices of an SVD are orthogonal matrices, then UUT=VVT=I.</S>
    <S sid="76" ssid="40">This implies that AV=UD.</S>
    <S sid="77" ssid="41">This means that for a new word, w, one can build a vector a which identifies how w relates to the top N words according to the p different conditions described above.</S>
    <S sid="78" ssid="42">For example, if w were one of the top N words, then a would simply represent w's particular row from the A matrix.</S>
    <S sid="79" ssid="43">The product aw= avk is the projection of 6T into the k-dimensional latent semantic space.</S>
    <S sid="80" ssid="44">By storing an index to the words of the corpus as well as a sorted list of these words, one can efficiently build a set of semantic vectors which includes each word of interest.</S>
    <S sid="81" ssid="45">Morphologically-related words frequently share similar semantics, so we want to see how well semantic vectors of PPMVs correlate.</S>
    <S sid="82" ssid="46">If we know how PPMVs correlate in comparison to other word pairs from their same rulesets, we can actually determine the semantic-based probability that the variants are legitimate.</S>
    <S sid="83" ssid="47">In this section, we identify a measure for correlating PPMVs and illustrate how ruleset-based statistics help identify legitimate PPMVs.</S>
    <S sid="84" ssid="48">The cosine of the angle between two vectors v1 and v2 is given by, We want to determine the correlation between each of the words of every PPMV.</S>
    <S sid="85" ssid="49">We use what we call a normalized cosine score (NCS) as a correlation.</S>
    <S sid="86" ssid="50">To obtain a NCS, we first calculate the cosine between each semantic vector, nw, and the semantic vectors from 200 randomly chosen words.</S>
    <S sid="87" ssid="51">By this means we obtain w's correlation mean (p,w) and standard deviation (cru,).</S>
    <S sid="88" ssid="52">If v is one of w's variants, then we define the NCS between nw and Itv to be By considering NCSs for all word pairs coupled under a particular rule, we can determine semantic-based probabilities that indicate which PPMVs are legitimate.</S>
    <S sid="89" ssid="53">We expect random NCSs to be normally-distributed according to .A.r(0,1).</S>
    <S sid="90" ssid="54">Given that a particular ruleset contains nR PPMVs, we can therefore approximate the number (nT), mean (AT) and standard deviation (o-T) of true correlations.</S>
    <S sid="91" ssid="55">If we define (I, z(t, a) to be iy e&#8212;( .x)2dx, then we can compute the probability that the particular correlation is legitimate: It is possible that a rule can be hypothesized at the trie stage that is true under only certain conditions.</S>
    <S sid="92" ssid="56">A prime example of such a rule is (&amp;quot;es&amp;quot;, NULL).</S>
    <S sid="93" ssid="57">Observe from Table 1 that the word &amp;quot;cares&amp;quot; poorly correlates with &amp;quot;car.&amp;quot; Yet, it is true that &amp;quot;-es&amp;quot; is a valid suffix for the words &amp;quot;flashes,&amp;quot; &amp;quot;catches,&amp;quot; &amp;quot;kisses,&amp;quot; and many other words where the &amp;quot;-es&amp;quot; is preceded by a voiceless sibilant.</S>
    <S sid="94" ssid="58">Hence, there is merit to considering subrules that arise while performing analysis on a particular rule.</S>
    <S sid="95" ssid="59">For instance, while evaluating the (&amp;quot;es&amp;quot;, NULL) rule, it is desirable to also consider potential subrules such as (&amp;quot;ches&amp;quot;, &amp;quot;ch&amp;quot;) and (&amp;quot;tes&amp;quot;, &amp;quot;t&amp;quot;).</S>
    <S sid="96" ssid="60">One might expect that the average NCS for the (&amp;quot;ches&amp;quot;, &amp;quot;ch&amp;quot;) subrule might be higher than the overall rule (&amp;quot;es&amp;quot;, NULL) whereas the opposite will likely be true for (&amp;quot;tes&amp;quot;, &amp;quot;t&amp;quot;).</S>
    <S sid="97" ssid="61">Table 2 confirms this.</S>
  </SECTION>
  <SECTION title="4 Results" number="4">
    <S sid="98" ssid="1">We compare our algorithm to Goldsmith's Linguistica (2000) by using CELEX's (Baayen, et al., 1993) suffixes as a gold standard.</S>
    <S sid="99" ssid="2">CELEX is a hand-tagged, morphologicallyanalyzed database of English words.</S>
    <S sid="100" ssid="3">CELEX has limited coverage of the words from our data set (where our data consists of over eight million words from random subcollections of TREC data (Voorhees, et a1,1997/8)), so we only considered words with frequencies of 10 or more.</S>
    <S sid="101" ssid="4">Morphological relationships can be represented graphically as directed graphs (see Figure 3, where three separate graphs are depicted).</S>
    <S sid="102" ssid="5">Developing a scoring algorithm to compare directed graphs is likely to be prone to disagreements.</S>
    <S sid="103" ssid="6">Therefore, we score only the vertex sets of directed graphs.</S>
    <S sid="104" ssid="7">We will refer to these vertex sets as conflation sets.</S>
    <S sid="105" ssid="8">For example, concern's conflation set contains itself as well as &amp;quot;concerned,&amp;quot; &amp;quot;concerns,&amp;quot; and &amp;quot;concerning&amp;quot; (or, in shorthand notation, the set is fa,b,c,d1).</S>
    <S sid="106" ssid="9">To evaluate an algorithm, we sum the number of correct (C), inserted (I) , and deleted (D) words it predicts for each hypothesized conflation set.</S>
    <S sid="107" ssid="10">If Xu, represents word w's conflation set according to the algorithm, and if Yw represents its CELEX-based conflation set, then However, in making these computations, we disregard any CELEX words that are not in the algorithm's data set and vice versa.</S>
    <S sid="108" ssid="11">For example, suppose two algorithms were being compared on a data set where all the words from Figure 3 were available except &amp;quot;concerting&amp;quot; and &amp;quot;concertos.&amp;quot; Suppose further that one algorithm proposed that { a,b,c,d,e,f,g,i} formed a single conflation set whereas the other algorithm proposed the three sets { a,b,c,d},{e,g,i}, and {f}.</S>
    <S sid="109" ssid="12">Then Table 3 illustrates how the two algorithms would be scored.</S>
    <S sid="110" ssid="13">To explain Table 3, consider algorithm one's entries for 'a.'</S>
    <S sid="111" ssid="14">Algorithm one had proposed that Xa=fa,b,c,d,e,f,g,il when in reality, = Ya={ a,b,c,d}.</S>
    <S sid="112" ssid="15">Since IX,, n Ya I = 4 and IYak4, then CA=4/ 4.</S>
    <S sid="113" ssid="16">The remaining values of the table can be computed accordingly.</S>
    <S sid="114" ssid="17">Using the values from Table 3, we can also compute precision, recall, and F-Score.</S>
    <S sid="115" ssid="18">Precision is defined to be C/(C+/), recall is C/(C+D), and F-Score is the product of precision and recall divided by the average of the two.</S>
    <S sid="116" ssid="19">For the first algorithm, the precision, recall, and F-Score would have respectively been 1/3, 1, and 1/2.</S>
    <S sid="117" ssid="20">In the second algorithm, these numbers would have been 5/7, 5/6, and 10/13.</S>
    <S sid="118" ssid="21">Table 4 uses the above scoring mechanism to compare between Linguistica and our system (at various probability thresholds).</S>
    <S sid="119" ssid="22">Note that since Linguistica removes capitalization, it will have a different total word count than our system.</S>
  </SECTION>
  <SECTION title="5 Conclusions" number="5">
    <S sid="120" ssid="1">These results suggest that semantics and LSA can play a key part in knowledge-free morphology induction.</S>
    <S sid="121" ssid="2">Semantics alone worked at least as well as Goldsmith's frequency-based approach.</S>
    <S sid="122" ssid="3">Yet we believe that semantics-based and frequency-based approaches play complementary roles.</S>
    <S sid="123" ssid="4">In current work, we are examining how to combine these two approaches.</S>
  </SECTION>
</PAPER>
