<PAPER>
  <S sid="0" ssid="0">The Importance of Syntactic Parsing and Inference in Semantic Role Labeling Vasin Punyakanok??</S>
  <S sid="1" ssid="1">BBN Technologies Dan Roth??</S>
  <S sid="2" ssid="2">University of Illinois at Urbana-Champaign Wen-tau Yih??</S>
  <S sid="3" ssid="3">Microsoft Research We present a general framework for semantic role labeling.</S>
  <S sid="4" ssid="4">The framework combines a machine- learning technique with an integer linear programming?based inference procedure, which in- corporates linguistic and structural constraints into a global decision process.</S>
  <S sid="5" ssid="5">Within this framework, we study the role of syntactic parsing information in semantic role labeling.</S>
  <S sid="6" ssid="6">We show that full syntactic parsing information is, by far, most relevant in identifying the argument, especially, in the very first stage?the pruning stage.</S>
  <S sid="7" ssid="7">Surprisingly, the quality of the pruning stage cannot be solely determined based on its recall and precision.</S>
  <S sid="8" ssid="8">Instead, it depends on the characteristics of the output candidates that determine the difficulty of the downstream prob- lems.</S>
  <S sid="9" ssid="9">Motivated by this observation, we propose an effective and simple approach of combining different semantic role labeling systems through joint inference, which significantly improves its performance.</S>
  <S sid="10" ssid="10">Our system has been evaluated in the CoNLL-2005 shared task on semantic role labeling, and achieves the highest F1 score among 19 participants.</S>
  <S sid="11" ssid="11">Introduction Semantic parsing of sentences is believed to be an important task on the road to natural language understanding, and has immediate applications in tasks such as informa- tion extraction and question answering.</S>
  <S sid="12" ssid="12">Semantic Role Labeling (SRL) is a shallow semantic parsing task, in which for each predicate in a sentence, the goal is to identify all constituents that fill a semantic role, and to determine their roles (Agent, Patient, Instrument, etc.)</S>
  <S sid="13" ssid="13">and their adjuncts (Locative, Temporal, Manner, etc.).</S>
  <S sid="14" ssid="14">10 Moulton St., Cambridge, MA 02138, USA.</S>
  <S sid="15" ssid="15">E-mail: vpunyaka@bbn.com.</S>
  <S sid="16" ssid="16">Department of Computer Science, University of Illinois at Urbana-Champaign, 201 N. Goodwin Ave., Urbana, IL 61801, USA.</S>
  <S sid="17" ssid="17">E-mail: danr@uiuc.edu.</S>
  <S sid="18" ssid="18">One Microsoft Way, Redmond, WA 98052, USA.</S>
  <S sid="19" ssid="19">E-mail: scottyih@microsoft.com.</S>
  <S sid="20" ssid="20">Most of the work was done when these authors were at the University of Illinois at Urbana-Champaign.</S>
  <S sid="21" ssid="21">Submission received: 15 July 2006; revised submission received: 3 May 2007; accepted for publication: 19 June 2007. ?</S>
  <S sid="22" ssid="22">2008 Association for Computational Linguistics Computational Linguistics Volume 34, Number 2 The PropBank project (Kingsbury and Palmer 2002; Palmer, Gildea, and Kingsbury 2005), which provides a large human-annotated corpus of verb predicates and their ar- guments, has enabled researchers to apply machine learning techniques to develop SRL systems (Gildea and Palmer 2002; Chen and Rambow 2003; Gildea and Hockenmaier 2003; Pradhan et al.</S>
  <S sid="23" ssid="23">2003; Surdeanu et al.</S>
  <S sid="24" ssid="24">2003; Pradhan et al.</S>
  <S sid="25" ssid="25">2004; Xue and Palmer 2004; Koomen et al.</S>
  <S sid="26" ssid="26">However, most systems rely heavily on full syntactic parse trees.</S>
  <S sid="27" ssid="27">Therefore, the overall performance of the system is largely determined by the quality of the automatic syntactic parsers of which the state of the art (Collins 1999; Charniak 2001) is still far from perfect.</S>
  <S sid="28" ssid="28">Alternatively, shallow syntactic parsers (i.e., chunkers and clausers), although they do not provide as much information as a full syntactic parser, have been shown to be more robust in their specific tasks (Li and Roth 2001).</S>
  <S sid="29" ssid="29">This raises the very natural and interesting question of quantifying the importance of full parsing information to semantic parsing and whether it is possible to use only shallow syntactic information to build an outstanding SRL system.</S>
  <S sid="30" ssid="30">Although PropBank is built by adding semantic annotations to the constituents in the Penn Treebank syntactic parse trees, it is not clear how important syntactic parsing is for an SRL system.</S>
  <S sid="31" ssid="31">To the best of our knowledge, this problem was first addressed by Gildea and Palmer (2002).</S>
  <S sid="32" ssid="32">In their attempt to use limited syntactic information, the parser they used was very shallow?clauses were not available and only chunks were used.</S>
  <S sid="33" ssid="33">Moreover, the pruning stage there was very strict?only chunks were considered as argument candidates.</S>
  <S sid="34" ssid="34">This results in over 60% of the actual arguments being ignored.</S>
  <S sid="35" ssid="35">Consequently, the overall recall in their approach was very low.</S>
  <S sid="36" ssid="36">The use of only shallow parsing information in an SRL system has largely been ignored until the recent CoNLL-2004 shared task competition (Carreras and Ma`rquez 2004).</S>
  <S sid="37" ssid="37">In that competition, participants were restricted to using only shallow parsing information, which included part-of-speech tags, chunks, and clauses (the definitions of chunks and clauses can be found in Tjong Kim Sang and Buchholz [2000] and Carreras et al.</S>
  <S sid="38" ssid="38">[2002], respectively).</S>
  <S sid="39" ssid="39">As a result, the performance of the best shallow parsing?</S>
  <S sid="40" ssid="40">based system (Hacioglu et al.</S>
  <S sid="41" ssid="41">2004) in the competition is about 10 points in F1 below the best system that uses full parsing information (Koomen et al.</S>
  <S sid="42" ssid="42">However, this is not the outcome of a true and fair quantitative comparison.</S>
  <S sid="43" ssid="43">The CoNLL-2004 shared task used only a subset of the data for training, which potentially makes the problem harder.</S>
  <S sid="44" ssid="44">Furthermore, an SRL system is usually complicated and consists of several stages.</S>
  <S sid="45" ssid="45">It was still unclear howmuch syntactic information helps and precisely where it helps the most.</S>
  <S sid="46" ssid="46">The goal of this paper is threefold.</S>
  <S sid="47" ssid="47">First, we describe an architecture for an SRL system that incorporates a level of global inference on top of the relatively common processing steps.</S>
  <S sid="48" ssid="48">This inference step allows us to incorporate structural and linguistic constraints over the possible outcomes of the argument classifier in an easy way.</S>
  <S sid="49" ssid="49">The inference procedure is formalized via an Integer Linear Programming framework and is shown to yield state-of-the-art results on this task.</S>
  <S sid="50" ssid="50">Second, we provide a fair com- parison between SRL systems that use full parse trees and systems that only use shal- low syntactic information.</S>
  <S sid="51" ssid="51">As with our full syntactic parse?based SRL system (Koomen et al.</S>
  <S sid="52" ssid="52">2005), our shallow parsing?based SRL system is based on the system that achieves very competitive results and was one of the top systems in the CoNLL-2004 shared task competition (Carreras and Ma`rquez 2004).</S>
  <S sid="53" ssid="53">This comparison brings forward a care- ful analysis of the significance of full parsing information in the SRL task, and provides an understanding of the stages in the process in which this information makes the most difference.</S>
  <S sid="54" ssid="54">Finally, to relieve the dependency of the SRL system on the quality of 258 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL automatic parsers, we suggest a way to improve semantic role labeling significantly by developing a global inference algorithm, which is used to combine several SRL systems based on different state-of-the-art full parsers.</S>
  <S sid="55" ssid="55">The combination process is done through a joint inference stage, which takes the output of each individual system as input and generates the best predictions, subject to various structural and linguistic constraints.</S>
  <S sid="56" ssid="56">The underlying system architecture can largely affect the outcome of our study.</S>
  <S sid="57" ssid="57">Therefore, to make the conclusions of our experimental study as applicable as possible to general SRL systems, the architecture of our SRL system follows the most widely used two-step design.</S>
  <S sid="58" ssid="58">In the first step, the system is trained to identify argument candi- dates for a given verb predicate.</S>
  <S sid="59" ssid="59">In the second step, the system classifies the argument candidates into their types.</S>
  <S sid="60" ssid="60">In addition, it is also a simple procedure to prune obvious non-candidates before the first step, and to use post-processing inference to fix incon- sistent predictions after the second step.</S>
  <S sid="61" ssid="61">These two additional steps are also employed by our system.</S>
  <S sid="62" ssid="62">Our study of shallow and full syntactic information?based SRL systems was done by comparing their impact at each stage of the process.</S>
  <S sid="63" ssid="63">Specifically, our goal is to investi- gate at what stage full parsing information is most helpful relative to a shallow parsing?</S>
  <S sid="64" ssid="64">Therefore, our experiments were designed so that the compared systems are as similar as possible, and the addition of the full parse tree?based features is the only difference.</S>
  <S sid="65" ssid="65">The most interesting result of this comparison is that although each step of the shallow parsing information?based system exhibits very good performance, the overall performance is significantly inferior to the system that uses full parsing information.</S>
  <S sid="66" ssid="66">Our explanation is that chaining multiple processing stages to produce the final SRL analysis is crucial to understanding this analysis.</S>
  <S sid="67" ssid="67">Specifically, the quality of the information passed from one stage to the other is a decisive issue, and it is not necessarily judged simply by considering the F-measure.</S>
  <S sid="68" ssid="68">We conclude that, for the system architecture used in our study, the significance of full parsing information comes into play mostly at the pruning stage, where the candidates to be processed later are determined.</S>
  <S sid="69" ssid="69">In addition, we produce a state-of-the-art SRL system by combining different SRL systems based on two automatic full parsers (Collins 1999; Charniak 2001), which achieves the best result in the CoNLL-2005 shared task (Carreras and Ma`rquez 2005).</S>
  <S sid="70" ssid="70">The rest of this paper is organized as follows.</S>
  <S sid="71" ssid="71">Section 2 introduces the task of semantic role labeling in more detail.</S>
  <S sid="72" ssid="72">Section 3 describes the four-stage architecture of our SRL system, which includes pruning, argument identification, argument classifi- cation, and inference.</S>
  <S sid="73" ssid="73">The features used for building the classifiers and the learning algorithm applied are also explained there.</S>
  <S sid="74" ssid="74">Section 4 explains why and where full parsing information contributes to SRL by conducting a series of carefully designed experiments.</S>
  <S sid="75" ssid="75">Inspired by the result, we examine the effect of inference in a single system and propose an approach that combines different SRL systems based on joint inference in Section 5.</S>
  <S sid="76" ssid="76">Section 6 presents the empirical evaluation of our system in the CoNLL- 2005 shared task competition.</S>
  <S sid="77" ssid="77">After that, we discuss the related work in Section 7 and conclude this paper in Section 8.</S>
  <S sid="78" ssid="78">The Semantic Role Labeling (SRL) Task The goal of the semantic role labeling task is to discover the predicate?argument struc- ture of each predicate in a given input sentence.</S>
  <S sid="79" ssid="79">In this work, we focus only on the verb predicate.</S>
  <S sid="80" ssid="80">For example, given a sentence I left my pearls to my daughter-in-law in my will, 259 Computational Linguistics Volume 34, Number 2 the goal is to identify the different arguments of the verb predicate left and produce the output: [A0 I] [V left ] [A1 my pearls] [A2 to my daughter-in-law] [AM-LOC in my will].</S>
  <S sid="81" ssid="81">Here A0 represents the leaver, A1 represents the thing left, A2 represents the beneficiary, AM-LOC is an adjunct indicating the location of the action, and V determines the boundaries of the predicate, which is important when a predicate contains many words, for example, a phrasal verb.</S>
  <S sid="82" ssid="82">In addition, each argument can be mapped to a constituent in its corresponding full syntactic parse tree.</S>
  <S sid="83" ssid="83">Following the definition of the PropBank and CoNLL-2004 and 2005 shared tasks, there are six different types of arguments labeled as A0?A5 and AA.</S>
  <S sid="84" ssid="84">These labels have different semantics for each verb and each of its senses as specified in the PropBank Frame files.</S>
  <S sid="85" ssid="85">In addition, there are also 13 types of adjuncts labeled as AM-adj where adj specifies the adjunct type.</S>
  <S sid="86" ssid="86">For simplicity in our presentation, we will also refer to these adjuncts as arguments.</S>
  <S sid="87" ssid="87">In some cases, an argument may span over different parts of a sentence; the label C-arg is then used to specify the continuity of the arguments, as shown in this example: [A1 The pearls] , [A0 I] [V said] , [C-A1 were left to my daughter-in-law].</S>
  <S sid="88" ssid="88">In some other cases, an argumentmight be a relative pronoun that in fact refers to the ac- tual agent outside the clause.</S>
  <S sid="89" ssid="89">In this case, the actual agent is labeled as the appropriate argument type, arg, while the relative pronoun is instead labeled as R-arg.</S>
  <S sid="90" ssid="90">For example, [A1 The pearls] [R-A1 which] [A0 I] [V left] [A2 to my daughter-in-law] are fake.</S>
  <S sid="91" ssid="91">Because each verb may have different senses producing different semantic roles for the same labels, the task of discovering the complete set of semantic roles should involve not only identifying these labels, but also the underlying sense for a given verb.</S>
  <S sid="92" ssid="92">However, as in all current SRL work, this article focuses only on identifying the boundaries and the labels of the arguments, and ignores the verb sense disambiguation problem.</S>
  <S sid="93" ssid="93">The distribution of these argument labels is fairly unbalanced.</S>
  <S sid="94" ssid="94">In the official release of PropBank I, core arguments (A0?A5 and AA) occupy 71.26% of the arguments, where the largest parts are A0 (25.39%) and A1 (35.19%).</S>
  <S sid="95" ssid="95">The rest mostly consists of adjunct arguments (24.90%).</S>
  <S sid="96" ssid="96">The continued (C-arg) and referential (R-arg) arguments are rela- tively few, occupying 1.22% and 2.63%, respectively.</S>
  <S sid="97" ssid="97">For more information on PropBank and the semantic role labeling task, readers can refer to Kingsbury and Palmer (2002) and Carreras and Ma`rquez (2004, 2005).</S>
  <S sid="98" ssid="98">Note that the semantic arguments of the same verb do not overlap.</S>
  <S sid="99" ssid="99">We define over- lapping arguments to be those that share some of their parts.</S>
  <S sid="100" ssid="100">An argument is considered embedded in another argument if the second argument completely covers the first one.</S>
  <S sid="101" ssid="101">Arguments are exclusively overlapping if they are overlapping but are not embedded.</S>
  <S sid="102" ssid="102">SRL System Architecture Adhering to the most common architecture for SRL systems, our SRL system consists of four stages: pruning, argument identification, argument classification, and inference.</S>
  <S sid="103" ssid="103">In particular, the goal of pruning and argument identification is to identify argument candidates for a given verb predicate.</S>
  <S sid="104" ssid="104">In the first three stages, however, decisions are independently made for each argument, and information across arguments is not 260 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL incorporated.</S>
  <S sid="105" ssid="105">The final inference stage allows us to use this type of information along with linguistic and structural constraints in order to make consistent global predictions.</S>
  <S sid="106" ssid="106">This system architecture remains unchanged when used for studying the impor- tance of syntactic parsing in SRL, although different information and features are used.</S>
  <S sid="107" ssid="107">Throughout this article, when full parsing information is available, we assume that the system is presented with the full phrase-structure parse tree as defined in the Penn Treebank (Marcus, Marcinkiewicz, and Santorini 1993) but without trace and functional tags.</S>
  <S sid="108" ssid="108">On the other hand, when only shallow parsing information is available, the full parse tree is reduced to only the chunks and the clause constituents.</S>
  <S sid="109" ssid="109">A chunk is a phrase containing syntactically related words.</S>
  <S sid="110" ssid="110">Roughly speaking, chunks are obtained by projecting the full parse tree onto a flat tree; hence, they are closely related to the base phrases.</S>
  <S sid="111" ssid="111">Chunks were not directly defined as part of the standard annotation of the treebank, but, rather, their definition was introduced in the CoNLL-2000 shared task on text chunking (Tjong Kim Sang and Buchholz 2000), which aimed to discover such phrases in order to facilitate full parsing.</S>
  <S sid="112" ssid="112">A clause, on the other hand, is the clausal constituent as defined by the treebank standard.</S>
  <S sid="113" ssid="113">An example of chunks and clauses is shown in Figure 1.</S>
  <S sid="114" ssid="114">3.1 Pruning When the full parse tree of a sentence is available, only the constituents in the parse tree are considered as argument candidates.</S>
  <S sid="115" ssid="115">Our system exploits the heuristic rules introduced by Xue and Palmer (2004) to filter out simple constituents that are very unlikely to be arguments.</S>
  <S sid="116" ssid="116">This pruning method is a recursive process starting from the target verb.</S>
  <S sid="117" ssid="117">It first returns the siblings of the verb as candidates; then it moves to the parent of the verb, and collects the siblings again.</S>
  <S sid="118" ssid="118">The process goes on until it reaches the root.</S>
  <S sid="119" ssid="119">In addition, if a constituent is a PP (prepositional phrase), its children are also collected.</S>
  <S sid="120" ssid="120">For example, in Figure 1, if the predicate (target verb) is assume, the pruning heuristic will output: [PP by John Smith who has been elected deputy chairman], [NP John Smith who has been elected deputy chairman], [VB be], [MD will], and [NP His duties].</S>
  <S sid="121" ssid="121">3.2 Argument Identification The argument identification stage utilizes binary classification to identify whether a candidate is an argument or not.</S>
  <S sid="122" ssid="122">When full parsing is available, we train and apply the binary classifiers on the constituents supplied by the pruning stage.</S>
  <S sid="123" ssid="123">When only shallow parsing is available, the system does not have a pruning stage, and also does not have constituents to begin with.</S>
  <S sid="124" ssid="124">Therefore, conceptually, the system has to consider all possible subsequences (i.e., consecutive words) in a sentence as potential argument candidates.</S>
  <S sid="125" ssid="125">We avoid this by using a learning scheme that utilizes two classifiers, one to predict the beginnings of possible arguments, and the other the ends.</S>
  <S sid="126" ssid="126">The predictions are combined to form argument candidates.</S>
  <S sid="127" ssid="127">However, we can employ a simple heuristic to filter out some candidates that are obviously not arguments.</S>
  <S sid="128" ssid="128">The final predication includes those that do not violate the following constraints.</S>
  <S sid="129" ssid="129">Arguments cannot overlap with the predicate.</S>
  <S sid="130" ssid="130">If a predicate is outside a clause, its arguments cannot be embedded in that clause.</S>
  <S sid="131" ssid="131">Arguments cannot exclusively overlap with the clauses.</S>
  <S sid="132" ssid="132">261 Computational Linguistics Volume 34, Number 2 Figure 1 An example of a parse tree and its predicate?argument structure.</S>
  <S sid="133" ssid="133">The first constraint comes from the definition of this task that the predicate simply cannot take itself or any constituents that contain itself as arguments.</S>
  <S sid="134" ssid="134">The other two constraints are due to the fact that a clause can be treated as a unit that has its own verb?argument structure.</S>
  <S sid="135" ssid="135">If a verb predicate is outside a clause, then its argument can only be the whole clause, but may not be embedded in or exclusively overlap with the clause.</S>
  <S sid="136" ssid="136">For the argument identification classifier, the features used in full parsing and shallow parsing settings are all binary features, which are described subsequently.</S>
  <S sid="137" ssid="137">3.2.1 Features Used When Full Parsing is Available.</S>
  <S sid="138" ssid="138">Most of the features used in our system are common features for the SRL task.</S>
  <S sid="139" ssid="139">The creation of PropBank was inspired by the works of Levin (1993) and Levin and Hovav (1996), which discuss the relation between syntactic and semantic information.</S>
  <S sid="140" ssid="140">Following this philosophy, the features aim to indicate the properties of the predicate, the constituent which is an argument candidate, and the relationship between them through the available syntactic infor- mation.</S>
  <S sid="141" ssid="141">We explain these features herein.</S>
  <S sid="142" ssid="142">For further discussion of these features, we 262 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL refer the readers to the article by Gildea and Jurafsky (2002), which introduced these features.</S>
  <S sid="143" ssid="143"></S>
  <S sid="144" ssid="144"></S>
  <S sid="145" ssid="145"></S>
  <S sid="146" ssid="146"></S>
  <S sid="147" ssid="147">We use the rules introduced by Collins (1999) to extract this feature.</S>
  <S sid="148" ssid="148"></S>
  <S sid="149" ssid="149"></S>
  <S sid="150" ssid="150">For example, in Figure 1, if the predicate is assume and the constituent is [S who has been elected deputy chairman], the path is S?NP?PP?VP?VBN, where ?</S>
  <S sid="151" ssid="151">indicate the traversal direction in the path.</S>
  <S sid="152" ssid="152"></S>
  <S sid="153" ssid="153">It records the immediate structure in the parse tree that expands to its parent.</S>
  <S sid="154" ssid="154">As an example, if the predicate is elect in Figure 1, its subcategorization is VP?</S>
  <S sid="155" ssid="155">(VBN)-NP while the subcategorization of the predicate assume is VP?(VBN)-PP.</S>
  <S sid="156" ssid="156">Parentheses indicate the position of the predicate.</S>
  <S sid="157" ssid="157">Generally speaking, we consider only the arguments that correspond to some con- stituents in parse trees.</S>
  <S sid="158" ssid="158">However, in some cases, we need to consider an argument that does not exactly correspond to a constituent, for example, in our experiment in Sec- tion 4.2 where the gold-standard boundaries are used with the parse trees generated by an automatic parse.</S>
  <S sid="159" ssid="159">In such cases, if the information on the constituent, such as phrase type, needs to be extracted, the deepest constituent that covers the whole argument will be used.</S>
  <S sid="160" ssid="160">For example, in Figure 1, the phrase type for by John Smith is PP, and its path feature to the predicate assume is PP?VP?VBN.</S>
  <S sid="161" ssid="161">We also use the following additional features.</S>
  <S sid="162" ssid="162">These features have been shown to be useful for the systems by exploiting other information in the absence of the full parse tree information (Punyakanok et al.</S>
  <S sid="163" ssid="163">2004), and, hence, can be helpful in conjunction with the features extracted from a full parse tree.</S>
  <S sid="164" ssid="164">They also aim to encode the properties of the predicate, the constituent to be classified, and their relationship in the sentence.</S>
  <S sid="165" ssid="165"></S>
  <S sid="166" ssid="166"></S>
  <S sid="167" ssid="167">Note that a 263 Computational Linguistics Volume 34, Number 2 verb may inhabit many classes and we collect all of these classes as features, regardless of the context-specific sense which we do not attempt to resolve.</S>
  <S sid="168" ssid="168"></S>
  <S sid="169" ssid="169"></S>
  <S sid="170" ssid="170">?exclusively overlaps,?</S>
  <S sid="171" ssid="171">or ?is embedded in?</S>
  <S sid="172" ssid="172">a chunk with its type.</S>
  <S sid="173" ssid="173">For instance, in Figure 1, if the constituents are [NP His duties], [PP by John Smith], and [VBN elected], then their chunk features are ?is-NP,?</S>
  <S sid="174" ssid="174">?embed-PP &amp; embed-NP,?</S>
  <S sid="175" ssid="175">and ?embedded-in-VP,?</S>
  <S sid="176" ssid="176"></S>
  <S sid="177" ssid="177">For example, in Figure 1 the chunk sequence from [NP His duties] to the predicate elect is VP-PP-NP-NP-VP.</S>
  <S sid="178" ssid="178"></S>
  <S sid="179" ssid="179"></S>
  <S sid="180" ssid="180">In addition, we label the clause with the type of chunk that immediately precedes the clause.</S>
  <S sid="181" ssid="181">This is a simple rule to distinguish the type of clause based on the intuition that a subordinate clause often modifies the part of the sentence immediately before it.</S>
  <S sid="182" ssid="182">Figure 2 shows the pseudo-parse tree of the parse tree in Figure 1.</S>
  <S sid="183" ssid="183">By disregarding the chunks, there are four configurations?</S>
  <S sid="184" ssid="184">?target constituent and predicate are siblings,?</S>
  <S sid="185" ssid="185">?target constituent?s parent is an ancestor of predicate,?</S>
  <S sid="186" ssid="186">?predicate?s parent is an ancestor of target word,?</S>
  <S sid="187" ssid="187">or ?otherwise.?</S>
  <S sid="188" ssid="188">This feature can be viewed as a generalization of the Path feature described earlier.</S>
  <S sid="189" ssid="189"></S>
  <S sid="190" ssid="190"></S>
  <S sid="191" ssid="191"></S>
  <S sid="192" ssid="192">The rules of the NEG and MOD features are used in a baseline SRL system developed by Erik Tjong Kim Sang (Carreras and Ma`rquez 2004).</S>
  <S sid="193" ssid="193">Figure 2 The pseudo-parse tree generated from the parse tree in Figure 1.</S>
  <S sid="194" ssid="194">264 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL In addition, we also use the conjunctions of features which conjoin any two features into a new feature.</S>
  <S sid="195" ssid="195">For example, the conjunction of the predicate and path features for the predicate assume and the constituent [S who has been elected deputy chairman] in Figure 1 is (S?NP?PP?VP?VBN, assume).</S>
  <S sid="196" ssid="196">3.2.2 Features Used When Only Shallow Parsing is Available.</S>
  <S sid="197" ssid="197">Most features used here are similar to those used by the systemwith full parsing information.</S>
  <S sid="198" ssid="198">However, for features that need full parse trees in their extraction procedures, we either try to mimic them with some heuristic rules or discard them.</S>
  <S sid="199" ssid="199">The details of these features are as follows.</S>
  <S sid="200" ssid="200"></S>
  <S sid="201" ssid="201"></S>
  <S sid="202" ssid="202"></S>
  <S sid="203" ssid="203">This aims to approximate the Path features extracted from the full parse tree.</S>
  <S sid="204" ssid="204"></S>
  <S sid="205" ssid="205">This aims to approximate the Subcategorization feature extracted from the full parse tree.</S>
  <S sid="206" ssid="206">3.3 Argument Classification This stage assigns labels to the argument candidates identified in the previous stage.</S>
  <S sid="207" ssid="207">A multi-class classifier is trained to predict the types of the argument candidates.</S>
  <S sid="208" ssid="208">In addition, to reduce the excessive candidates mistakenly output by the previous stage, the classifier can also label an argument as ?null?</S>
  <S sid="209" ssid="209">(meaning ?not an argument?)</S>
  <S sid="210" ssid="210">to dis- card it.</S>
  <S sid="211" ssid="211">The features used here are the same as those used in the argument identification stage.</S>
  <S sid="212" ssid="212">However, when full parsing is available, an additional feature introduced by Xue and Palmer (2004) is used.</S>
  <S sid="213" ssid="213"></S>
  <S sid="214" ssid="214">The learning algorithm used for training the argument classifier and argument iden- tifier is a variation of the Winnow update rule incorporated in SNoW (Roth 1998; Carlson et al.</S>
  <S sid="215" ssid="215">1999), a multi-class classifier that is tailored for large scale learning tasks.</S>
  <S sid="216" ssid="216">SNoW learns a sparse network of linear functions, in which the targets (argument border predictions or argument type predictions, in this case) are represented as linear functions over a common feature space; multi-class decisions are done via a winner- take-all mechanism.</S>
  <S sid="217" ssid="217">It improves the basic Winnow multiplicative update rule with a regularization term, which has the effect of separating the data with a large margin separator (Dagan, Karov, and Roth 1997; Grove and Roth 2001; Zhang, Damerau, and Johnson 2002) and voted (averaged) weight vector (Freund and Schapire 1999; Golding and Roth 1999).</S>
  <S sid="218" ssid="218">265 Computational Linguistics Volume 34, Number 2 The softmax function (Bishop 1995) is used to convert raw activation to conditional probabilities.</S>
  <S sid="219" ssid="219">If there are n classes and the raw activation of class i is acti, the posterior estimation for class i is Prob(i) = e acti ?</S>
  <S sid="220" ssid="220">1?j?n e actj Note that in training this classifier, unless specified otherwise, the argument can- didates used to generate the training examples are obtained from the output of the argument identifier, not directly from the gold-standard corpus.</S>
  <S sid="221" ssid="221">In this case, we au- tomatically obtain the necessary examples to learn for class ?null.?</S>
  <S sid="222" ssid="222">3.4 Inference In the previous stages, decisions were always made for each argument independently, ignoring the global information across arguments in the final output.</S>
  <S sid="223" ssid="223">The purpose of the inference stage is to incorporate such information, including both linguistic and structural knowledge, such as ?arguments do not overlap?</S>
  <S sid="224" ssid="224">or ?each verb takes at most one argument of each type.?</S>
  <S sid="225" ssid="225">This knowledge is useful to resolve any incon- sistencies of argument classification in order to generate final legitimate predictions.</S>
  <S sid="226" ssid="226">We design an inference procedure that is formalized as a constrained optimization problem, represented as an integer linear program (Roth and Yih 2004).</S>
  <S sid="227" ssid="227">It takes as input the argument classifiers?</S>
  <S sid="228" ssid="228">confidence scores for each type of argument, along with a list of constraints.</S>
  <S sid="229" ssid="229">The output is the optimal solution that maximizes the lin- ear sum of the confidence scores, subject to the constraints that encode the domain knowledge.</S>
  <S sid="230" ssid="230">The inference stage can be naturally extended to combine the output of several different SRL systems, as we will show in Section 5.</S>
  <S sid="231" ssid="231">In this section we first introduce the constraints and formalize the inference problem for the semantic role labeling task.</S>
  <S sid="232" ssid="232">We then demonstrate how we apply integer linear programming (ILP) to generate the global label assignment.</S>
  <S sid="233" ssid="233">3.4.1 Constraints over Argument Labeling.</S>
  <S sid="234" ssid="234">Formally, the argument classifiers attempt to assign labels to a set of arguments, S1:M, indexed from 1 toM.</S>
  <S sid="235" ssid="235">Each argument Si can take any label from a set of argument labels, P , and the indexed set of arguments can take a set of labels, c1:M ?</S>
  <S sid="236" ssid="236">If we assume that the classifiers return a score score(Si = ci) that corresponds to the likelihood of argument Si being labeled ci then, given a sentence, the unaltered inference task is solved by maximizing the overall score of the arguments, c?1:M = argmax c1:M?PM score(S1:M = c1:M) = argmax c1:M?PM M ?</S>
  <S sid="237" ssid="237">i=1 score(Si = ci) (1) In the presence of global constraints derived from linguistic information and struc- tural considerations, our system seeks to output a legitimate labeling that maximizes this score.</S>
  <S sid="238" ssid="238">Specifically, it can be thought of as if the solution space is limited through the use of a filter function, F , which eliminates many argument labelings from consideration.</S>
  <S sid="239" ssid="239">266 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Here, we are concerned with global constraints as well as constraints on the arguments.</S>
  <S sid="240" ssid="240">Therefore, the final labeling becomes c?1:M = argmax c1:M?F (PM ) M ?</S>
  <S sid="241" ssid="241">i=1 score(Si = ci) (2) When the confidence scores correspond to the conditional probabilities estimated by the argument classifiers, the value of the objective function represents the expected number of correct argument predictions.</S>
  <S sid="242" ssid="242">Hence, the solution of Equation (2) is the one that maximizes this expected value among all legitimate outputs.</S>
  <S sid="243" ssid="243">The filter function used considers the following constraints:1 1.</S>
  <S sid="244" ssid="244">Arguments cannot overlap with the predicate.</S>
  <S sid="245" ssid="245">Arguments cannot exclusively overlap with the clauses.</S>
  <S sid="246" ssid="246">If a predicate is outside a clause, its arguments cannot be embedded in that clause.</S>
  <S sid="247" ssid="247">No overlapping or embedding arguments.</S>
  <S sid="248" ssid="248">This constraint holds because semantic arguments are labeled on non-embedding constituents in the syntactic parse tree.</S>
  <S sid="249" ssid="249">In addition, as defined in the CoNLL-2004 and 2005 shared tasks, the legitimate output of an SRL system must satisfy this constraint.</S>
  <S sid="250" ssid="250">No duplicate argument classes for core arguments, such as A0?A5 and AA.</S>
  <S sid="251" ssid="251">The only exception is when there is a conjunction in the sentence.</S>
  <S sid="252" ssid="252">For example, [A0 I] [V left ] [A1 my pearls] [A2 to my daughter] and [A1 my gold] [A2 to my son].</S>
  <S sid="253" ssid="253">Despite this exception, we treat it as a hard constraint because it almost always holds.</S>
  <S sid="254" ssid="254">If there is an R-arg argument, then there has to be an arg argument.</S>
  <S sid="255" ssid="255">That is, if an argument is a reference to some other argument arg, then this referenced argument must exist in the sentence.</S>
  <S sid="256" ssid="256">This constraint is directly derived from the definition of R-arg arguments.</S>
  <S sid="257" ssid="257">If there is a C-arg argument, then there has to be an arg argument; in addition, the C-arg argument must occur after arg.</S>
  <S sid="258" ssid="258">This is stricter than the previous rule because the order of appearance also needs to be considered.</S>
  <S sid="259" ssid="259">Similarly, this constraint is directly derived from the definition of C-arg arguments.</S>
  <S sid="260" ssid="260">Given the predicate, some argument classes are illegal (e.g., predicate stalk can take only A0 or A1).</S>
  <S sid="261" ssid="261">This information can be found in PropBank Frames.</S>
  <S sid="262" ssid="262">1 There are other constraints such as ?exactly one V argument per class,?</S>
  <S sid="263" ssid="263">or ?V?A1?C-V pattern?</S>
  <S sid="264" ssid="264">as introduced by Punyakanok et al.</S>
  <S sid="265" ssid="265">However, we did not find them particularly helpful in our experiments.</S>
  <S sid="266" ssid="266">Therefore, we exclude those constraints in the presentation here.</S>
  <S sid="267" ssid="267">267 Computational Linguistics Volume 34, Number 2 This constraint comes from the fact that different predicates take different types and numbers of arguments.</S>
  <S sid="268" ssid="268">By checking the PropBank Frame file of the target verb, we can exclude some core argument labels.</S>
  <S sid="269" ssid="269">Note that constraints 1, 2, and 3 are actually implemented in the argument identifi- cation stage (see Section 3.2).</S>
  <S sid="270" ssid="270">In addition, they need to be explicitly enforced only when full parsing information is not available because the output of the pruning heuristics never violates these constraints.</S>
  <S sid="271" ssid="271">The optimization problem (Equation (2)) can be solved using an ILP solver by reformulating the constraints as linear (in)equalities over the indicator variables that represent the truth value of statements of the form [argument i takes label j], as described in detail next.</S>
  <S sid="272" ssid="272">3.4.2 Using Integer Linear Programming.</S>
  <S sid="273" ssid="273">As discussed previously, a collection of po- tential arguments is not necessarily a valid semantic labeling because it may not satisfy all of the constraints.</S>
  <S sid="274" ssid="274">We enforce a legitimate solution using the following inference algorithm.</S>
  <S sid="275" ssid="275">In our context, inference is the process of finding the best (ac- cording to Equation (1)) valid semantic labels that satisfy all of the specified con- straints.</S>
  <S sid="276" ssid="276">We take a similar approach to the one previously used for entity/relation recognition (Roth and Yih 2004), and model this inference procedure as solving an ILP problem.</S>
  <S sid="277" ssid="277">An integer linear program is a linear program with integral variables.</S>
  <S sid="278" ssid="278">That is, the cost function and the (in)equality constraints are all linear in terms of the variables.</S>
  <S sid="279" ssid="279">The only difference in an integer linear program is that the variables can only take integers as their values.</S>
  <S sid="280" ssid="280">In our inference problem, the variables are in fact binary.</S>
  <S sid="281" ssid="281">A general binary integer linear programming problem can be stated as follows.</S>
  <S sid="282" ssid="282">Given a cost vector p ?</S>
  <S sid="283" ssid="283">d, a collection of variables u = (u1, .</S>
  <S sid="284" ssid="284">,ud) and cost ma- trices C1 ?</S>
  <S sid="285" ssid="285">d , where c1 and c2 are the numbers of inequality and equality constraints and d is the number of binary variables, the ILP solution u?</S>
  <S sid="286" ssid="286">is the vector that maximizes the cost function, u?</S>
  <S sid="287" ssid="287">u subject to C1u ?</S>
  <S sid="288" ssid="288">b1, and C2u = b2 where b1 ?</S>
  <S sid="289" ssid="289">c2 , and for all u ?</S>
  <S sid="290" ssid="290">{0, 1}d. To solve the problem of Equation (2) in this setting, we first reformulate the original cost function ?M i=1 score(S i = ci) as a linear function over several binary vari- ables, and then represent the filter function F using linear inequalities and equalities.</S>
  <S sid="291" ssid="291">We set up a bijection from the semantic labeling to the variable set u.</S>
  <S sid="292" ssid="292">This is done by setting u to be a set of indicator variables that correspond to the labels assigned to ar- guments.</S>
  <S sid="293" ssid="293">Specifically, let uic = [S i = c] be the indicator variable that represents whether 268 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL or not the argument type c is assigned to Si, and let pic = score(S i = c).</S>
  <S sid="294" ssid="294">Equation (1) can then be written as an ILP cost function as argmax uic?{0,1}:?i?</S>
  <S sid="295" ssid="295">c?P picuic subject to ?</S>
  <S sid="296" ssid="296">c?P uic = 1 ?i ?</S>
  <S sid="297" ssid="297">[1,M] which means that each argument can take only one type.</S>
  <S sid="298" ssid="298">Note that this new constraint comes from the variable transformation, and is not one of the constraints used in the filter function F .</S>
  <S sid="299" ssid="299">Of the constraints listed earlier, constraints 1 through 3 can be evaluated on a per- argument basis and, for the sake of efficiency, arguments that violate these constraints are eliminated even before being given to the argument classifier.</S>
  <S sid="300" ssid="300">Next, we show how to transform the constraints in the filter function into the form of linear (in)equalities over u and use them in this ILP setting.</S>
  <S sid="301" ssid="301">For a more complete example of this ILP formulation, please see Appendix A. Constraint 4: No overlapping or embedding.</S>
  <S sid="302" ssid="302">If arguments Sj1 , .</S>
  <S sid="303" ssid="303">,Sjk cover the same word in a sentence, then this constraint ensures that at most one of the arguments is assigned to an argument type.</S>
  <S sid="304" ssid="304">In other words, at least k?</S>
  <S sid="305" ssid="305">1 arguments will be the special class null.</S>
  <S sid="306" ssid="306">If the special class null is represented by the symbol ?, then for every set of such arguments, the following linear equality represents this constraint.</S>
  <S sid="307" ssid="307">1 Constraint 5: No duplicate argument classes.</S>
  <S sid="308" ssid="308">Within the same clause, several types of arguments cannot appear more than once.</S>
  <S sid="309" ssid="309">For example, a predicate can only take one A0.</S>
  <S sid="310" ssid="310">This constraint can be represented using the following inequality.</S>
  <S sid="311" ssid="311">1 Constraint 6: R-arg arguments.</S>
  <S sid="312" ssid="312">Suppose the referenced argument type is A0 and the referential type is R-A0.</S>
  <S sid="313" ssid="313">The linear inequalities that represent this constraint are: ?m ?</S>
  <S sid="314" ssid="314">umR-A0 If there are ?</S>
  <S sid="315" ssid="315">referential types, then the total number of inequalities needed is ?M.</S>
  <S sid="316" ssid="316">Constraint 7: C-arg arguments.</S>
  <S sid="317" ssid="317">This constraint is similar to the reference argument con- straints.</S>
  <S sid="318" ssid="318">The difference is that the continued argument arg has to occur before C-arg.</S>
  <S sid="319" ssid="319">269 Computational Linguistics Volume 34, Number 2 Assume that the argument pair is A0 and C-A0, and arguments are sorted by their beginning positions, i.e., if i &lt; k, the position of the beginning of Sjk is not before that of the beginning of Sji .</S>
  <S sid="320" ssid="320">The linear inequalities that represent this constraint are: ?m ?</S>
  <S sid="321" ssid="321">ujmC-A0 Constraint 8: Illegal argument types.</S>
  <S sid="322" ssid="322">Given a specific verb, some argument types should never occur.</S>
  <S sid="323" ssid="323">For example, most verbs do not have arguments A5.</S>
  <S sid="324" ssid="324">This constraint is represented by summing all the corresponding indicator variables to be 0.</S>
  <S sid="325" ssid="325">i=1 uiA5 = 0 Using ILP to solve this inference problem enjoys several advantages.</S>
  <S sid="326" ssid="326">Linear con- straints are very general, and are able to represent any Boolean constraint (Gue?ret, Prins, and Sevaux 2002).</S>
  <S sid="327" ssid="327">Table 1 summarizes the transformations of common constraints (most are Boolean), which are revised from Gue?ret, Prins, and Sevaux (2002), and can be used for constructing complicated rules.</S>
  <S sid="328" ssid="328">Previous approaches usually rely on dynamic programming to resolve non- overlapping/embedding constraints (i.e., Constraint 4) when the constraint structure is sequential.</S>
  <S sid="329" ssid="329">However, they are not able to handle more expressive constraints such as those that take long-distance dependencies and counting dependencies into account (Roth and Yih 2005).</S>
  <S sid="330" ssid="330">The ILP approach, on the other hand, is flexible enough to handle more expressive and general constraints.</S>
  <S sid="331" ssid="331">Although solving an ILP problem is NP-hard in the worst case, with the help of today?s numerical packages, this problem can usually be solved very quickly in practice.</S>
  <S sid="332" ssid="332">For instance, in our experiments it only took about 10 minutes to solve the inference problem for 4,305 sentences, using Table 1 Rules of mapping constraints to linear (in)equalities for Boolean variables.</S>
  <S sid="333" ssid="333">Original constraint Linear form exactly k of x1, x2, ?</S>
  <S sid="334" ssid="334">, xn x1 + x2 + ?</S>
  <S sid="335" ssid="335">?+ xn = k at most k of x1, x2, ?</S>
  <S sid="336" ssid="336">, xn x1 + x2 + ?</S>
  <S sid="337" ssid="337">k at least k of x1, x2, ?</S>
  <S sid="338" ssid="338">, xn x1 + x2 + ?</S>
  <S sid="339" ssid="339">at least k of x1, x2, ?</S>
  <S sid="340" ssid="340">?+ xn)/k At least k of x1, x2, ?</S>
  <S sid="341" ssid="341">1)) 270 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Xpress-MP (2004) running on a Pentium-III 800 MHz machine.</S>
  <S sid="342" ssid="342">Note that ordinary search methods (e.g., beam search) are not necessarily faster than solving an ILP problem and do not guarantee the optimal solution.</S>
  <S sid="343" ssid="343">The Importance of Syntactic Parsing We experimentally study the significance of syntactic parsing by observing the effects of using full parsing and shallow parsing information at each stage of an SRL system.</S>
  <S sid="344" ssid="344">We first describe, in Section 4.1, how we prepare the data.</S>
  <S sid="345" ssid="345">The comparison of full parsing and shallow parsing on the first three stages of the process is presented in the reverse order (Sections 4.2, 4.3, 4.4).</S>
  <S sid="346" ssid="346">Note that in the following sections, in addition to the performance comparison at various stages, we present also the overall system performance for the different scenarios.</S>
  <S sid="347" ssid="347">In all cases, the overall system performance is derived after the inference stage.</S>
  <S sid="348" ssid="348">4.1 Experimental Setting We use PropBank Sections 02 through 21 as training data, Section 23 as testing, and Section 24 as a validation set when necessary.</S>
  <S sid="349" ssid="349">In order to apply the standard CoNLL shared task evaluation script, our system conforms to both the input and output format defined in the shared task.</S>
  <S sid="350" ssid="350">The goal of the experiments in this section is to understand the effective contribu- tion of full parsing information versus shallow parsing information (i.e., using only the part-of-speech tags, chunks, and clauses).</S>
  <S sid="351" ssid="351">In addition, we also compare performance when using the correct (gold-standard) data versus using automatic parse data.</S>
  <S sid="352" ssid="352">The performance is measured in terms of precision, recall, and the F1 measure.</S>
  <S sid="353" ssid="353">Note that all the numbers reported here do not take into account the V arguments as it is quite trivial to predict V and, hence, this gives overoptimistic overall performance if included.</S>
  <S sid="354" ssid="354">When doing the comparison, we also compute the 95% confidence interval of F1 us- ing the bootstrap resampling method (Noreen 1989), and the difference is considered significant if the compared F1 lies outside this interval.</S>
  <S sid="355" ssid="355">The automatic full parse trees are derived using Charniak?s parser (2001) (version 0.4).</S>
  <S sid="356" ssid="356">In automatic shallow parsing, the information is generated by different state-of-the-art components, including a POS tagger (Even-Zohar and Roth 2001), a chunker (Punyakanok and Roth 2001), and a clauser (Carreras, Ma`rquez, and Castro 2005).</S>
  <S sid="357" ssid="357">4.2 Argument Classification To evaluate the performance gap between full parsing and shallow parsing in argument classification, we assume the argument boundaries are known, and only train classifiers to classify the labels of these arguments.</S>
  <S sid="358" ssid="358">In this stage, the only difference between the uses of full parsing and shallow parsing information is the construction of phrase type, head word, POS tag of the head word, path, subcategorization, and syntactic frame features.</S>
  <S sid="359" ssid="359">As described in Section 3.2.2, most of these features can be approximated using chunks and clauses, with the exception of the syntactic frame feature.</S>
  <S sid="360" ssid="360">It is unclear how this feature can be mimicked because it relies on the internal structure of a full parse tree.</S>
  <S sid="361" ssid="361">Therefore, it does not have a corresponding feature in the shallow parsing case.</S>
  <S sid="362" ssid="362">Table 2 reports the experimental results of argument classification when argument boundaries are known.</S>
  <S sid="363" ssid="363">In this case, because the argument classifier of our SRL system does not overpredict or miss any arguments, we do not need to train with a null class, 271 Computational Linguistics Volume 34, Number 2 Table 2 The accuracy of argument classification when argument boundaries are known.</S>
  <S sid="364" ssid="364">Full Parsing Shallow Parsing Gold 91.50 ?</S>
  <S sid="365" ssid="365">0.45 Auto 90.32 ?</S>
  <S sid="366" ssid="366">0.50 and we can simply measure the performance using accuracy instead of F1.</S>
  <S sid="367" ssid="367">The training examples include 90,352 propositions with a total of 332,381 arguments.</S>
  <S sid="368" ssid="368">The test data contain 5,246 propositions and 19,511 arguments.</S>
  <S sid="369" ssid="369">As shown in the table, although the full-parsing features are more helpful than the shallow-parsing features, the perfor- mance gap is quite small (0.75% on gold-standard data and 0.61% with the automatic parsers).</S>
  <S sid="370" ssid="370">The rather small difference in the performance between argument classifiers using full parsing and shallow parsing information almost disappears when their output is processed by the inference stage.</S>
  <S sid="371" ssid="371">Table 3 shows the final results in recall, precision, and F1, when the argument boundaries are known.</S>
  <S sid="372" ssid="372">In all cases, the differences in F1 between the full parsing?based and the shallow parsing?based systems are not statistically significant.</S>
  <S sid="373" ssid="373">When the argument boundaries are known, the performance of the full parsing?based SRL system is about the same as the shallow parsing?based SRL system.</S>
  <S sid="374" ssid="374">4.3 Argument Identification Argument identification is an important stage that effectively reduces the number of argument candidates after the pruning stage.</S>
  <S sid="375" ssid="375">Given an argument candidate, an argu- ment identifier is a binary classifier that decides whether or not the candidate should be considered as an argument.</S>
  <S sid="376" ssid="376">To evaluate the influence of full parsing information in this stage, the candidate list used here is the outputs of the pruning heuristic applied on the gold-standard parse trees.</S>
  <S sid="377" ssid="377">The heuristic results in a total number of 323,155 positive and 686,887 negative examples in the training set, and 18,988 positive and 39,585 negative examples in the test set.</S>
  <S sid="378" ssid="378">Similar to the argument classification stage, the only difference between full parsing?</S>
  <S sid="379" ssid="379">and shallow parsing?based systems is in the construction of some features.</S>
  <S sid="380" ssid="380">Specifically, phrase type, head word, POS tag of the head word, path, and subcategorization features are approximated using chunks and clauses when the binary classifier is trained using shallow parsing information.</S>
  <S sid="381" ssid="381">Table 4 reports the performance of the argument identifier on the test set using the direct predictions of the trained binary classifier.</S>
  <S sid="382" ssid="382">The recall and precision of the Table 3 The overall system performance when argument boundaries are known.</S>
  <S sid="383" ssid="383">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 91.58 91.90 91.74 ?</S>
  <S sid="384" ssid="384">0.51 91.14 91.48 91.31 ?</S>
  <S sid="385" ssid="385">0.51 Auto 90.71 91.14 90.93 ?</S>
  <S sid="386" ssid="386">0.53 90.50 90.88 90.69 ?</S>
  <S sid="387" ssid="387">0.53 272 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Table 4 The performance of argument identification after pruning (based on the gold standard full parse trees).</S>
  <S sid="388" ssid="388">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 96.53 93.57 95.03 ?</S>
  <S sid="389" ssid="389">0.32 93.66 91.72 92.68 ?</S>
  <S sid="390" ssid="390">0.38 Auto 94.68 90.60 92.59 ?</S>
  <S sid="391" ssid="391">0.39 92.31 88.36 90.29 ?</S>
  <S sid="392" ssid="392">0.43 full parsing?based system are around 2 to 3 percentage points higher than the shallow parsing?based system on the gold-standard data.</S>
  <S sid="393" ssid="393">As a result, the F1 score is 2.5 percent- age points higher.</S>
  <S sid="394" ssid="394">The performance on automatic parse data is unsurprisingly lower but the difference between the full parsing?</S>
  <S sid="395" ssid="395">and the shallow parsing?based systems is as observed previously.</S>
  <S sid="396" ssid="396">In terms of filtering efficiency, around 25% of the examples are predicted as positive.</S>
  <S sid="397" ssid="397">In other words, both argument identifiers filter out around 75% of the argument candidates after pruning.</S>
  <S sid="398" ssid="398">Because the recall in the argument identification stage sets the upper-bound the recall in argument classification, the threshold that determines when examples are predicted to be positive is usually lowered to allow more positive predictions.</S>
  <S sid="399" ssid="399">That is, a candidate is predicted as positive when its probability estimation is larger than the threshold.</S>
  <S sid="400" ssid="400">Table 5 shows the performance of the argument identifiers when the threshold is 0.1.2 Because argument identification is just an intermediate step in a complete system, a more realistic evaluation method is to see how each final system performs.</S>
  <S sid="401" ssid="401">Using an argument identifier with threshold = 0.1 (i.e., Table 5), Table 6 reports the final results in recall, precision, and F1.</S>
  <S sid="402" ssid="402">The F1 difference is 1.5 points when using the gold-standard data.</S>
  <S sid="403" ssid="403">However, when automatic parsers are used, the shallow parsing?based system is, in fact, slightly better; although the difference is not statistically significant.</S>
  <S sid="404" ssid="404">This may be due to the fact that chunk and clause predictions are very important here, and shallow parsers are more accurate in chunk or clause predictions than a full parser (Li and Roth 2001).</S>
  <S sid="405" ssid="405">Full parsing information helps in argument identification.</S>
  <S sid="406" ssid="406">However, when the automatic parsers are used, using the full parsing information may not have better overall results compared to using shallow parsing.</S>
  <S sid="407" ssid="407">4.4 Pruning As shown in the previous two sections, the overall performance gaps of full parsing and shallow parsing are small.</S>
  <S sid="408" ssid="408">When automatic parsers are used, the difference is less than 1 point in F1 or accuracy.</S>
  <S sid="409" ssid="409">Therefore, we conclude that themain contribution of full parsing is in the pruning stage.</S>
  <S sid="410" ssid="410">Because the shallow parsing system does not have enough in- formation for the pruning heuristics, we train two word-based classifiers to replace the pruning stage.</S>
  <S sid="411" ssid="411">One classifier is trained to predict whether a given word is the start (S) of 2 The value was determined by experimenting with the complete system using automatic full parse trees, on the development set.</S>
  <S sid="412" ssid="412">In our tests, lowering the threshold in argument identification always leads to higher overall recall and lower overall precision.</S>
  <S sid="413" ssid="413">As a result, the gain in F1 is limited.</S>
  <S sid="414" ssid="414">273 Computational Linguistics Volume 34, Number 2 Table 5 The performance of argument identification after pruning (based on the gold-standard full parse trees) and with threshold = 0.1.</S>
  <S sid="415" ssid="415">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 92.13 95.62 93.84 ?</S>
  <S sid="416" ssid="416">0.37 88.54 94.81 91.57 ?</S>
  <S sid="417" ssid="417">0.42 Auto 89.48 94.14 91.75 ?</S>
  <S sid="418" ssid="418">0.41 86.14 93.21 89.54 ?</S>
  <S sid="419" ssid="419">0.47 Table 6 The overall system performance using the output from the pruning heuristics, applied on the gold-standard full parse trees.</S>
  <S sid="420" ssid="420">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 86.22 87.40 86.81 ?</S>
  <S sid="421" ssid="421">0.59 84.14 85.31 84.72 ?</S>
  <S sid="422" ssid="422">0.63 Auto 84.21 85.04 84.63 ?</S>
  <S sid="423" ssid="423">0.63 86.17 84.02 85.08 ?</S>
  <S sid="424" ssid="424">0.63 an argument; the other classifier is to predict the end (E) of an argument.</S>
  <S sid="425" ssid="425">If the product of probabilities of a pair of S and E predictions is larger than a predefined threshold, then this pair is considered as an argument candidate.</S>
  <S sid="426" ssid="426">The threshold used here was obtained by using the validation set.</S>
  <S sid="427" ssid="427">Both classifiers use very similar features to those used by the argument identifier as explained in Section 3.2, treating the target word as a constituent.</S>
  <S sid="428" ssid="428">Particularly, the features are predicate, POS tag of the predicate, voice, context words, POS tags of the context words, chunk pattern, clause relative position, and shallow-path.</S>
  <S sid="429" ssid="429">The headword and its POS tag are replaced by the target word and its POS tag.</S>
  <S sid="430" ssid="430">The comparison of using the classifiers and the heuristics is shown in Table 7.</S>
  <S sid="431" ssid="431">Even without the knowledge of the constituent boundaries, the classifiers seem surprisingly better than the pruning heuristics.</S>
  <S sid="432" ssid="432">Using either the gold-standard data set or the output of automatic parsers, the classifiers achieve higher F1 scores.</S>
  <S sid="433" ssid="433">One possible reason for this phenomenon is that the accuracy of the pruning strategy is limited by the number of agreements between the correct arguments and the constituents of the parse trees.</S>
  <S sid="434" ssid="434">Table 8 summarizes the statistics of the examples seen by both strategies.</S>
  <S sid="435" ssid="435">The pruning strategy needs to decide which are the potential arguments among all con- stituents.</S>
  <S sid="436" ssid="436">This strategy is upper-bounded by the number of correct arguments that agree with some constituent.</S>
  <S sid="437" ssid="437">On the other hand, the classifiers do not have this limitation.</S>
  <S sid="438" ssid="438">The number of examples they observe is the total number of words to be processed, and the positive examples are those arguments that are annotated as such in the data set.</S>
  <S sid="439" ssid="439">Table 7 The performance of pruning using heuristics and classifiers.</S>
  <S sid="440" ssid="440">Full Parsing Classifier Threshold = 0.04 Prec Rec F1 Prec Rec F1 Gold 25.94 97.27 40.96 ?</S>
  <S sid="441" ssid="441">0.51 29.58 97.18 45.35 ?</S>
  <S sid="442" ssid="442">0.83 Auto 22.79 86.08 36.04 ?</S>
  <S sid="443" ssid="443">0.52 24.68 94.80 39.17 ?</S>
  <S sid="444" ssid="444">0.79 274 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Table 8 Statistics of the training and test examples for the pruning stage.</S>
  <S sid="445" ssid="445">Words Arguments Constituents Agreements Gold Auto Gold Auto Train 2,575,665 332,381 4,664,954 4,263,831 327,603 319,768 Test 147,981 19,511 268,678 268,482 19,266 18,301 The Agreements column shows the number of arguments that match the boundaries of some constituents.</S>
  <S sid="446" ssid="446">Note that because each verb is processed independently, a sentence is processed once for each verb in the sentence.</S>
  <S sid="447" ssid="447">Therefore, the words and constituents in each sentence are counted as many times as the number of verbs to be processed.</S>
  <S sid="448" ssid="448">As before, in order to compare the systems that use full parsing and shallow parsing information, we need to see the impact on the overall performance.</S>
  <S sid="449" ssid="449">There- fore, we built two semantic role systems based on full parsing and shallow parsing information.</S>
  <S sid="450" ssid="450">The full parsing?based system follows the pruning, argument identifica- tion, argument classification, and inference stages, as described earlier.</S>
  <S sid="451" ssid="451">For the shallow parsing system, the pruning heuristic is replaced by the word-based pruning classi- fiers, and the remaining stages are designed to use only shallow parsing as described in previous sections.</S>
  <S sid="452" ssid="452">Table 9 shows the overall performance of the two evaluation systems.</S>
  <S sid="453" ssid="453">As indicated in the tables, the gap in F1 between full parsing and shallow parsing?</S>
  <S sid="454" ssid="454">based systems enlarges tomore than 11 points on the gold-standard data.</S>
  <S sid="455" ssid="455">At first glance, this result seems to contradict our conclusion in Section 4.3.</S>
  <S sid="456" ssid="456">After all, if the pruning stage of shallow parsing SRL system performs equally well or even better, the overall performance gap in F1 should be small.</S>
  <S sid="457" ssid="457">After we carefully examined the output of the word-based classifier, we realized that it filters out easy candidates, and leaves examples that are difficult to the later stages.</S>
  <S sid="458" ssid="458">Specifically, these argument candidates often overlap and differ only in one or twowords.</S>
  <S sid="459" ssid="459">On the other hand, the pruning heuristic based on full parsing never outputs overlapping candidates and consequently provides input that is easier for the next stage to handle.</S>
  <S sid="460" ssid="460">Indeed, the following argument identification stage turns out to be good in discriminating these non-overlapping candidates.</S>
  <S sid="461" ssid="461">The most crucial contribution of full parsing is in the pruning stage.</S>
  <S sid="462" ssid="462">The internal tree structure significantly helps in discriminating argument candidates, which makes the work done by the following stages easier.</S>
  <S sid="463" ssid="463">Table 9 The overall system performance.</S>
  <S sid="464" ssid="464">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 86.22 87.40 86.81 ?</S>
  <S sid="465" ssid="465">0.59 75.34 75.28 75.31 ?</S>
  <S sid="466" ssid="466">0.76 Auto 77.09 75.51 76.29 ?</S>
  <S sid="467" ssid="467">0.76 75.48 67.13 71.06 ?</S>
  <S sid="468" ssid="468">0.80 275 Computational Linguistics Volume 34, Number 2 5.</S>
  <S sid="469" ssid="469">The Effect of Inference Our inference procedure plays an important role in improving accuracy when the local predictions violate the constraints among argument labels.</S>
  <S sid="470" ssid="470">In this section, we first present the overall system performance when most constraints are not used.</S>
  <S sid="471" ssid="471">We then demonstrate how the inference procedure can be used to combine the output of several systems to yield better performance.</S>
  <S sid="472" ssid="472">5.1 Inference with Limited Constraints The inference stage in our system architecture provides a principled way to resolve conflicting local predictions.</S>
  <S sid="473" ssid="473">It is interesting to see whether this procedure improves the performance differently for the full parsing?</S>
  <S sid="474" ssid="474">vs. the shallow parsing?based system, as well as gold-standard vs. automatic parsing input.</S>
  <S sid="475" ssid="475">Table 10 shows the results of using only constraints 1, 2, 3, and 4.</S>
  <S sid="476" ssid="476">As mentioned previously, the first three constraints are handled before the argument classification stage.</S>
  <S sid="477" ssid="477">Constraint 4, which forbids overlapping or embedding arguments, is required in order to use the official CoNLL-2005 evaluation script and is therefore kept.</S>
  <S sid="478" ssid="478">By comparing Table 9 with Table 10, we can see that the effect of adding more constraints is quite consistent over the four settings.</S>
  <S sid="479" ssid="479">Precision is improved by 1 to 2 per- centage points but recall is decreased a little.</S>
  <S sid="480" ssid="480">As a result, the gain in F1 is about 0.5 to 1 point.</S>
  <S sid="481" ssid="481">It is not surprising to see this lower recall and higher precision phenomenon after the constraints described in Section 3.4.1 are examined.</S>
  <S sid="482" ssid="482">Most constraints punish false non-null output, but do not regulate false null predictions.</S>
  <S sid="483" ssid="483">For example, an assignment that has two A1 arguments clearly violates the non-duplication constraint.</S>
  <S sid="484" ssid="484">However, if an assignment has no predicted arguments at all, it still satisfies all the constraints.</S>
  <S sid="485" ssid="485">5.2 Joint Inference The empirical study in Section 4 indicates that the performance of an SRL system primarily depends on the very first stage?pruning, which is directly derived from the full parse trees.</S>
  <S sid="486" ssid="486">This also means that in practice the quality of the syntactic parser is decisive to the quality of the SRL system.</S>
  <S sid="487" ssid="487">To improve semantic role labeling, one possible way is to combine different SRL systems through a joint inference stage, given that the systems are derived using different full parse trees.</S>
  <S sid="488" ssid="488">To test this idea, we first build two SRL systems that use Collins?s parser (Collins 1999)3 and Charniak?s parser (Charniak 2001), respectively.</S>
  <S sid="489" ssid="489">In fact, these two parsers have noticeably different outputs.</S>
  <S sid="490" ssid="490">Applying the pruning heuristics on the output of Collins?s parser produces a list of candidates with 81.05% recall.</S>
  <S sid="491" ssid="491">Although this number is significantly lower than the 86.08% recall produced by Charniak?s parser, the union of the two candidate lists still significantly improves recall to 91.37%.</S>
  <S sid="492" ssid="492">We construct the two systems by implementing the first three stages, namely, pruning, argument identifi- cation, and argument classification.</S>
  <S sid="493" ssid="493">When a test sentence is given, a joint inference stage is used to resolve the inconsistency of the output of argument classification in these two systems.</S>
  <S sid="494" ssid="494">We first briefly review the objective function used in the inference procedure in- troduced in Section 3.4.</S>
  <S sid="495" ssid="495">Formally speaking, the argument classifiers attempt to assign 3 We use the Collins parser implemented by Bikel (2004).</S>
  <S sid="496" ssid="496">276 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Table 10 The impact of removing most constraints in overall system performance.</S>
  <S sid="497" ssid="497">Full Parsing Shallow Parsing Prec Rec F1 Prec Rec F1 Gold 85.07 87.50 86.27 ?</S>
  <S sid="498" ssid="498">0.58 73.19 75.63 74.39 ?</S>
  <S sid="499" ssid="499">0.75 Auto 75.88 75.81 75.84 ?</S>
  <S sid="500" ssid="500">0.75 73.56 67.45 70.37 ?</S>
  <S sid="501" ssid="501">0.80 labels to a set of arguments, S1:M, indexed from 1 toM.</S>
  <S sid="502" ssid="502">Each argument Si can take any label from a set of argument labels, P , and the indexed set of arguments can take a set of labels, c1:M ?</S>
  <S sid="503" ssid="503">If we assume that the argument classifier returns an estimated conditional probability distribution, Prob(Si = ci), then, given a sentence, the inference procedure seeks a global assignment that maximizes the objective function denoted by Equation (2), which can be rewritten as follows, c?1:M = argmax c1:M?F (PM ) M ?</S>
  <S sid="504" ssid="504">i=1 Prob(Si = ci) (3) where the linguistic and structural constraints are represented by the filter F .</S>
  <S sid="505" ssid="505">In other words, this objective function reflects the expected number of correct argument predic- tions, subject to the constraints.</S>
  <S sid="506" ssid="506">When there are two or more argument classifiers from different SRL systems, a joint inference procedure can take the output estimated probabilities for all these candidates as input, although some candidates may refer to the same phrases in the sentence.</S>
  <S sid="507" ssid="507">For example, Figure 3 shows the two candidate sets for a fragment of a sentence, ..., traders say, unable to cool the selling panic in both stocks and futures.</S>
  <S sid="508" ssid="508">In this example, system A has two argument candidates, a1 = traders and a4 = the selling panic in both stocks and futures; system B has three argument candidates, b1 = traders, b2 = the selling panic, and b3 = in both stocks and futures.</S>
  <S sid="509" ssid="509">A straightforward solution to the combination is to treat each argument produced by a system as a possible output.</S>
  <S sid="510" ssid="510">Each possible labeling of the argument is associated with a variable which is then used to set up the inference procedure.</S>
  <S sid="511" ssid="511">However, the final predictionwill be likely dominated by the system that producesmore candidates, which is system B in this example.</S>
  <S sid="512" ssid="512">The reason is that our objective function is the sum of the probabilities of all the candidate assignments.</S>
  <S sid="513" ssid="513">This bias can be corrected by the following observation.</S>
  <S sid="514" ssid="514">Although system A only has two candidates, a1 and a4, it can be treated as if it also has two additional phantom candidates, a2 and a3, where a2 and b2 refer to the same phrase, and so do a3 and b3.</S>
  <S sid="515" ssid="515">Similarly, system B has a phantom candidate b4 that corresponds to a4.</S>
  <S sid="516" ssid="516">Because systemA does not really generate a2 and a3, we can assume that these two phantom candidates are predicted by it as ?null?</S>
  <S sid="517" ssid="517">(i.e., not an argument).</S>
  <S sid="518" ssid="518">We assign the same prior distribution to each phantom candidate.</S>
  <S sid="519" ssid="519">In particular, the probability of the ?null?</S>
  <S sid="520" ssid="520">class is set to be 0.55 based on empirical tests, and the probabilities of the remaining classes are set based on their occurrence frequencies in the training data.</S>
  <S sid="521" ssid="521">Then, we treat each possible final argument output as a single unit.</S>
  <S sid="522" ssid="522">Each probability estimation by a system can be viewed as evidence in the final probability estimation and, therefore, we can simply average their estimation.</S>
  <S sid="523" ssid="523">Formally, let Si be the argument set 277 Computational Linguistics Volume 34, Number 2 Figure 3 The output of two SRL systems: system A has two candidates, a1 = traders and a4 = the selling panic in both stocks and futures; system B has three argument candidates, b1 = traders, b2 = the selling panic, and b3 = in both stocks and futures.</S>
  <S sid="524" ssid="524">In addition, we create two phantom candidates a2 and a3 for system A that correspond to b2 and b3 respectively, and b4 for system B that corresponds to a4.</S>
  <S sid="525" ssid="525">output by system i, and S = ?k i=1 Si be the set of all arguments where k is the number of systems; let N be the cardinality of S. Our augmented objective function is then: c?1:N = argmax c1:N?F (PN ) N ?</S>
  <S sid="526" ssid="526">i=1 Prob(Si = ci) (4) where Si ?</S>
  <S sid="527" ssid="527">S, and Prob(Si = ci) = 1 k k ?</S>
  <S sid="528" ssid="528">j=1 Probj(S i = ci) (5) where Probj is the probability output by system j.</S>
  <S sid="529" ssid="529">Note that we may also treat the individual systems differently by applying different priors (i.e., weights) on the estimated probabilities of the argument candidates.</S>
  <S sid="530" ssid="530">For example, if the performance of system A is much better than system B, then we may want to trust system A?s output more by multiplying the output probabilities by a larger weight.</S>
  <S sid="531" ssid="531">Table 11 reports the performance of two individual systems based on Collins?s parser and Charniak?s parser, as well as the joint system, where the two individual systems are equally weighted.</S>
  <S sid="532" ssid="532">The joint system based on this straightforward strategy significantly improves the performance compared to the two original SRL systems in both recall and precision, and thus achieves a much higher F1.</S>
  <S sid="533" ssid="533">Empirical Evaluation?CoNLL Shared Task 2005 In this section, we present the detailed evaluation of our SRL system, in the competi- tion on semantic role labeling?the CoNLL-2005 shared task (Carreras and Ma`rquez 278 Punyakanok, Roth, and Yih Importance of Parsing and Inference in SRL Table 11 The performance of individual and combined SRL systems.</S>
  <S sid="534" ssid="534">Prec Rec F1 Collins?</S>
  <S sid="535" ssid="535">parser 75.92 71.45 73.62 ?</S>
  <S sid="536" ssid="536">0.79 Charniak?s parser 77.09 75.51 76.29 ?</S>
  <S sid="537" ssid="537">0.76 Combined result 80.53 76.94 78.69 ?</S>
  <S sid="538" ssid="538">The setting of this shared task is basically the same as it was in 2004, with some extensions.</S>
  <S sid="539" ssid="539">First, it allows much richer syntactic information.</S>
  <S sid="540" ssid="540">In particular, full parse trees generated using Collins?s parser (Collins 1999) and Charniak?s parser (Charniak 2001) were provided.</S>
  <S sid="541" ssid="541">Second, the full parsing standard partition was used?</S>
  <S sid="542" ssid="542">the training set was enlarged and covered Sections 02?21, the development set was Section 24, and the test set was Section 23.</S>
  <S sid="543" ssid="543">Finally, in addition to the Wall Street Journal (WSJ) data, three sections of the Brown corpus were used to provide cross-corpora evaluation.</S>
  <S sid="544" ssid="544">The system we used to participate in the CoNLL-2005 shared task is an enhanced version of the system described in Sections 3 and 5.</S>
  <S sid="545" ssid="545">The main difference was that the joint-inference stage was extended to combine six basic SRL systems instead of two.</S>
  <S sid="546" ssid="546">Specifically for this implementation, we first trained two SRL systems that use Collins?s parser and Charniak?s parser, respectively, because of their noticeably dif- ferent outputs.</S>
  <S sid="547" ssid="547">In evaluation, we ran the system that was trained with Charniak?s parser five times, with the top-5 parse trees output by Charniak?s parser.</S>
  <S sid="548" ssid="548">Together we have six different outputs per predicate.</S>
  <S sid="549" ssid="549">For each parse tree output, we ran the first three stages, namely, pruning, argument identification, and argument classification.</S>
  <S sid="550" ssid="550">Then, a joint-inference stage, where each individual system is weighted equally, was used to resolve the inconsistency of the output of argument classification in these systems.</S>
  <S sid="551" ssid="551">Table 12 shows the overall results on the development set and different test sets; the detailed results on WSJ section 23 are shown in Table 13.</S>
  <S sid="552" ssid="552">Table 14 shows the results of individual systems and the improvement gained by the joint inference procedure on the development set.</S>
  <S sid="553" ssid="553">Our system reached the highest F1 scores on all the test sets and was the best system among the 19 participating teams.</S>
  <S sid="554" ssid="554">After the competition, we improved the system slightly by tuning the weights of the individual systems in the joint inference procedure, where the F1 scores onWSJ test section and the Brown test set are 79.59 points and 67.98 points, respectively.</S>
  <S sid="555" ssid="555">Table 12 Overall CoNLL-2005 shared task results.</S>
  <S sid="556" ssid="556">F1 Development 80.05 74.83 77.35 Test WSJ 82.28 76.78 79.44 Test Brown 73.38 62.93 67.75 Test WSJ+Brown 81.18 74.92 77.92 279 Computational Linguistics Volume 34, Number 2 Table 13 Detailed CoNLL-2005 shared task results on the WSJ test set.</S>
  <S sid="557" ssid="557">F1 Overall 82.28 76.78 79.44 A0 88.22 87.88 88.05 A1 82.25 77.69 79.91 A2 78.27 60.36 68.16 A3 82.73 52.60 64.31 A4 83.91 71.57 77.25 AM-ADV 63.82 56.13 59.73 AM-CAU 64.15 46.58 53.97 AM-DIR 57.89 38.82 46.48 AM-DIS 75.44 80.62 77.95 AM-EXT 68.18 46.88 55.56 AM-LOC 66.67 55.10 60.33 AM-MNR 66.79 53.20 59.22 AM-MOD 96.11 98.73 97.40 AM-NEG 97.40 97.83 97.61</S>
</PAPER>
