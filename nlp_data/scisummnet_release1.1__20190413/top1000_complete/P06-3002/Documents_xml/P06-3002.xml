<PAPER>
  <S sid="0">Unsupervised Part-Of-Speech Tagging Employing Efficient Graph Clustering</S>
  <ABSTRACT>
    <S sid="1" ssid="1">An unsupervised part-of-speech (POS) tagging system that relies on graph clustering methods is described.</S>
    <S sid="2" ssid="2">Unlike in current state-of-the-art approaches, the kind and number of different tags is generated by the method itself.</S>
    <S sid="3" ssid="3">We compute and merge two partitionings of word graphs: one based on context similarity of high frequency words, another on log-likelihood statistics for words of lower frequencies.</S>
    <S sid="4" ssid="4">Using the resulting word clusters as a lexicon, a Viterbi POS tagger is trained, which is refined by a morphological component.</S>
    <S sid="5" ssid="5">The approach is evaluated on three different languages by measuring agreement with existing taggers.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="6" ssid="1">Assigning syntactic categories to words is an important pre-processing step for most NLP applications.</S>
    <S sid="7" ssid="2">Essentially, two things are needed to construct a tagger: a lexicon that contains tags for words and a mechanism to assign tags to running words in a text.</S>
    <S sid="8" ssid="3">There are words whose tags depend on their use.</S>
    <S sid="9" ssid="4">Further, we also need to be able to tag previously unseen words.</S>
    <S sid="10" ssid="5">Lexical resources have to offer the possible tags, and our mechanism has to choose the appropriate tag based on the context.</S>
    <S sid="11" ssid="6">Given a sufficient amount of manually tagged text, several approaches have demonstrated the ability to learn the instance of a tagging mechanism from manually labelled data and apply it successfully to unseen data.</S>
    <S sid="12" ssid="7">Those highquality resources are typically unavailable for many languages and their creation is labourintensive.</S>
    <S sid="13" ssid="8">We will describe an alternative needing much less human intervention.</S>
    <S sid="14" ssid="9">In this work, steps are undertaken to derive a lexicon of syntactic categories from unstructured text without prior linguistic knowledge.</S>
    <S sid="15" ssid="10">We employ two different techniques, one for highand medium frequency terms, one for mediumand low frequency terms.</S>
    <S sid="16" ssid="11">The categories will be used for the tagging of the same text where the categories were derived from.</S>
    <S sid="17" ssid="12">In this way, domain- or language-specific categories are automatically discovered.</S>
    <S sid="18" ssid="13">There are a number of approaches to derive syntactic categories.</S>
    <S sid="19" ssid="14">All of them employ a syntactic version of Harris&#8217; distributional hypothesis: Words of similar parts of speech can be observed in the same syntactic contexts.</S>
    <S sid="20" ssid="15">Contexts in that sense are often restricted to the most frequent words.</S>
    <S sid="21" ssid="16">The words used to describe syntactic contexts will be called feature words in the remainder.</S>
    <S sid="22" ssid="17">Target words, as opposed to this, are the words that are to be grouped into syntactic clusters.</S>
    <S sid="23" ssid="18">The general methodology (Finch and Chater, 1992; Sch&#252;tze, 1995; inter al.) for inducing word class information can be outlined as follows: Throughout, feature words are the 150-250 words with the highest frequency.</S>
    <S sid="24" ssid="19">Contexts are the feature words appearing in the immediate neighbourhood of a word.</S>
    <S sid="25" ssid="20">The word&#8217;s global context is the sum of all its contexts.</S>
    <S sid="26" ssid="21">For clustering, a similarity measure has to be defined and a clustering algorithm has to be chosen.</S>
    <S sid="27" ssid="22">Finch and Chater (1992) use the Spearman Rank Correlation Coefficient and a hierarchical clustering, Sch&#252;tze (1995) uses the cosine between vector angles and Buckshot clustering.</S>
    <S sid="28" ssid="23">An extension to this generic scheme is presented in (Clark, 2003), where morphological Proceedings of the COLING/ACL 2006 Student Research Workshop, pages 7&#8211;12, Sydney, July 2006. c&#65533;2006 Association for Computational Linguistics information is used for determining the word class of rare words.</S>
    <S sid="29" ssid="24">Freitag (2004) does not sum up the contexts of each word in a context vector, but the most frequent instances of four-word windows are used in a co-clustering algorithm.</S>
    <S sid="30" ssid="25">Regarding syntactic ambiguity, most approaches do not deal with this issue while clustering, but try to resolve ambiguities at the later tagging stage.</S>
    <S sid="31" ssid="26">A severe problem with most clustering algorithms is that they are parameterised by the number of clusters.</S>
    <S sid="32" ssid="27">As there are as many different word class schemes as tag sets, and the exact amount of word classes is not agreed upon intra- and interlingually, inputting the number of desired clusters beforehand is clearly a drawback.</S>
    <S sid="33" ssid="28">In that way, the clustering algorithm is forced to split coherent clusters or to join incompatible sub-clusters.</S>
    <S sid="34" ssid="29">In contrast, unsupervised part-of-speech induction means the induction of the tag set, which implies finding the number of classes in an unguided way.</S>
    <S sid="35" ssid="30">This work constructs an unsupervised POS tagger from scratch.</S>
    <S sid="36" ssid="31">Input to our system is a considerable amount of unlabeled, monolingual text bar any POS information.</S>
    <S sid="37" ssid="32">In a first stage, we employ a clustering algorithm on distributional similarity, which groups a subset of the most frequent 10,000 words of a corpus into several hundred clusters (partitioning 1).</S>
    <S sid="38" ssid="33">Second, we use similarity scores on neighbouring co-occurrence profiles to obtain again several hundred clusters of medium- and low frequency words (partitioning 2).</S>
    <S sid="39" ssid="34">The combination of both partitionings yields a set of word forms belonging to the same derived syntactic category.</S>
    <S sid="40" ssid="35">To gain on text coverage, we add ambiguous high-frequency words that were discarded for partitioning 1 to the lexicon.</S>
    <S sid="41" ssid="36">Finally, we train a Viterbi tagger with this lexicon and augment it with an affix classifier for unknown words.</S>
    <S sid="42" ssid="37">The resulting taggers are evaluated against outputs of supervised taggers for various languages.</S>
  </SECTION>
  <SECTION title="2 Method" number="2">
    <S sid="43" ssid="1">The method employed here follows the coarse methodology as described in the introduction, but differs from other works in several respects.</S>
    <S sid="44" ssid="2">Although we use 4-word context windows and the top frequency words as features (as in Sch&#252;tze 1995), we transform the cosine similarity values between the vectors of our target words into a graph representation.</S>
    <S sid="45" ssid="3">Additionally, we provide a methdology to identify and incorporate POS-ambiguous words as well as low-frequency words into the lexicon.</S>
    <S sid="46" ssid="4">Let us consider a weighted, undirected graph G(V,E) (v&#8712;V vertices, (vi,vj,wij)&#8712;E edges with weights wij).</S>
    <S sid="47" ssid="5">Vertices represent entities (here: words); the weight of an edge between two vertices indicates their similarity.</S>
    <S sid="48" ssid="6">As the data here is collected in feature vectors, the question arises why it should be transformed into a graph representation.</S>
    <S sid="49" ssid="7">The reason is, that graph-clustering algorithms such as e.g.</S>
    <S sid="50" ssid="8">(van Dongen, 2000; Biemann 2006), find the number of clusters automatically1.</S>
    <S sid="51" ssid="9">Further, outliers are handled naturally in that framework, as they are represented as singleton nodes (without edges) and can be excluded from the clustering.</S>
    <S sid="52" ssid="10">A threshold s on similarity serves as a parameter to influence the number of non-singleton nodes in the resulting graph.</S>
    <S sid="53" ssid="11">For assigning classes, we use the Chinese Whispers (CW) graph-clustering algorithm, which has been proven useful in NLP applications as described in (Biemann 2006).</S>
    <S sid="54" ssid="12">It is time-linear with respect to the number of edges, making its application viable even for graphs with several million nodes and edges.</S>
    <S sid="55" ssid="13">Further, CW is parameter-free, operates locally and results in a partitioning of the graph, excluding singletons (i.e. nodes without edges).</S>
    <S sid="56" ssid="14">Partitioning 1: High and medium frequency words Four steps are executed in order to obtain partitioning 1: partitioning as one-member clusters.</S>
    <S sid="57" ssid="15">The graph construction in step 2 is conducted by adding an edge between two words a and b with weight w=1/(1-cos(a,b)), if w exceeds a similarity threshold s. The latter influences the number of words that actually end up in the graph and get clustered.</S>
    <S sid="58" ssid="16">It might be desired to cluster fewer words with higher confidence as opposed to running in the danger of joining two unrelated clusters because of too many ambiguous words that connect them.</S>
    <S sid="59" ssid="17">After step 3, we already have a partition of a subset of our target words.</S>
    <S sid="60" ssid="18">The distinctions are normally more fine-grained than existing tag sets.</S>
    <S sid="61" ssid="19">As feature words form the bulk of tokens in corpora, it is clearly desired to make sure that they appear in the final partitioning, although they might form word classes of their own2.</S>
    <S sid="62" ssid="20">This is done in step 4.</S>
    <S sid="63" ssid="21">We argue that assigning separate word classes for high frequency words is a more robust choice then trying to disambiguate them while tagging.</S>
    <S sid="64" ssid="22">Lexicon size for partitioning 1 is limited by the computational complexity of step 2, which is time-quadratic in the number of target words.</S>
    <S sid="65" ssid="23">For adding words with lower frequencies, we pursue another strategy.</S>
    <S sid="66" ssid="24">Partitioning 2: Medium and low frequency words As noted in (Dunning, 1993), log-likelihood statistics are able to capture word bi-gram regularities.</S>
    <S sid="67" ssid="25">Given a word, its neighbouring cooccurrences as ranked by the log-likelihood reflect the typical immediate contexts of the word.</S>
    <S sid="68" ssid="26">Regarding the highest ranked neighbours as the profile of the word, it is possible to assign similarity scores between two words A and B according to how many neighbours they share, i.e. to what extent the profiles of A and B overlap.</S>
    <S sid="69" ssid="27">This directly induces a graph, which can be again clustered by CW.</S>
    <S sid="70" ssid="28">This procedure is parametrised by a loglikelihood threshold and the minimum number of left and right neighbours A and B share in order to draw an edge between them in the resulting graph.</S>
    <S sid="71" ssid="29">For experiments, we chose a minimum log-likelihood of 3.84 (corresponding to statistical dependence on 5% level), and at least four shared neighbours of A and B on each side.</S>
    <S sid="72" ssid="30">Only words with a frequency rank higher than 2,000 are taken into account.</S>
    <S sid="73" ssid="31">Again, we obtain several hundred clusters, mostly of open word classes.</S>
    <S sid="74" ssid="32">For computing partitioning 2, an efficient algorithm like CW is crucial: the graphs 2 This might even be desired, e.g. for English not. as used for the experiments consisted of 52,857/691,241 (English), 85,827/702,349 (Finnish) and 137,951/1,493,571 (German) nodes/edges.</S>
    <S sid="75" ssid="33">The procedure to construct the graphs is faster than the method used for partitioning 1, as only words that share at least one neighbour have to be compared and therefore can handle more words with reasonable computing time.</S>
    <S sid="76" ssid="34">Combination of partitionings 1 and 2 Now, we have two partitionings of two different, yet overlapping frequency bands.</S>
    <S sid="77" ssid="35">A large portion of these 8,000 words in the overlapping region is present in both partitionings.</S>
    <S sid="78" ssid="36">Again, we construct a graph, containing the clusters of both partitionings as nodes; weights of edges are the number of common elements, if at least two elements are shared.</S>
    <S sid="79" ssid="37">And again, CW is used to cluster this graph of clusters.</S>
    <S sid="80" ssid="38">This results in fewer clusters than before for the following reason: While the granularities of partitionings 1 and 2 are both high, they capture different aspects as they are obtained from different sources.</S>
    <S sid="81" ssid="39">Nodes of large clusters (which usually consist of open word classes) have many edges to the other partitioning&#8217;s nodes, which in turn connect to yet other clusters of the same word class.</S>
    <S sid="82" ssid="40">Eventually, these clusters can be grouped into one.</S>
    <S sid="83" ssid="41">Clusters that are not included in the graph of clusters are treated differently, depending on their origin: clusters of partition 1 are added to the result, as they are believed to contain important closed word class groups.</S>
    <S sid="84" ssid="42">Dropouts from partitioning 2 are left out, as they mostly consist of small, yet semantically motivated word sets.</S>
    <S sid="85" ssid="43">Combining both partitionings in this way, we arrive at about 200-500 clusters that will be further used as a lexicon for tagging.</S>
    <S sid="86" ssid="44">A lexicon is constructed from the merged partitionings, which contains one possible tag (the cluster ID) per word.</S>
    <S sid="87" ssid="45">To increase text coverage, it is possible to include those words that dropped out in the distributional step for partitioning 1 into the lexicon.</S>
    <S sid="88" ssid="46">It is assumed that these words dropped out because of ambiguity.</S>
    <S sid="89" ssid="47">From a graph with a lower similarity threshold s (here: such that the graph contained 9,500 target words), we obtain the neighbourhoods of these words one at a time.</S>
    <S sid="90" ssid="48">The tags of those neighbours &#8211; if known &#8211; provide a distribution of possible tags for these words.</S>
    <S sid="91" ssid="49">Unlike in supervised scenarios, our task is not to train a tagger model from a small corpus of hand-tagged data, but from our clusters of derived syntactic categories and a considerably large, yet unlabeled corpus.</S>
  </SECTION>
  <SECTION title="Basic Trigram Model" number="3">
    <S sid="92" ssid="1">We decided to use a simple trigram model without re-estimation techniques.</S>
    <S sid="93" ssid="2">Adopting a standard POS-tagging framework, we maximize the probability of the joint occurrence of tokens (ti) and categories (ci) for a sequence of length n: The transition probability P(ci|ci-1,ci-2) is estimated from word trigrams in the corpus whose elements are all present in our lexicon.</S>
    <S sid="94" ssid="3">The last term of the product, namely P(ci|ti), is dependent on the lexicon3.</S>
    <S sid="95" ssid="4">If the lexicon does not contain (ti), then (ci) only depends on neighbouring categories.</S>
    <S sid="96" ssid="5">Words like these are called out-of-vocabulary (OOV) words.</S>
    <S sid="97" ssid="6">Morphologically motivated add-ons are used e.g. in (Clark, 2003) and (Freitag 2004) to guess a more appropriate category distribution based on a word&#8217;s suffix or its capitalization for OOV words.</S>
    <S sid="98" ssid="7">Here, we examine the effects of Compact Patricia Trie classifiers (CPT) trained on prefixes and suffixes.</S>
    <S sid="99" ssid="8">We use the implementation of (Witschel and Biemann, 2005).</S>
    <S sid="100" ssid="9">For OOV words, the category-wise product of both classifier&#8217;s distributions serve as probabilities P(ci|ti): Let w=ab=cd be a word, a be the longest common prefix of w that can be found in all lexicon words, and d be the longest common suffix of w that can be found in all lexicon words.</S>
    <S sid="101" ssid="10">Then</S>
  </SECTION>
  <SECTION title="3 Evaluation methodology" number="4">
    <S sid="102" ssid="1">We adopt the methodology of (Freitag 2004) and measure cluster-conditional tag perplexity PP as the average amount of uncertainty to predict the tags of a POS-tagged corpus, given the tagging with classes from the unsupervised method.</S>
    <S sid="103" ssid="2">Let be the mutual information between two random variables X and Y.</S>
    <S sid="104" ssid="3">Then the clusterconditional tag perplexity for a gold-standard tagging T and a tagging resulting from clusters C is computed as Minimum PP is 1.0, connoting a perfect congruence on gold standard tags.</S>
    <S sid="105" ssid="4">In the experiment section we report PP on lexicon words and OOV words separately.</S>
    <S sid="106" ssid="5">The objective is to minimize the total PP.</S>
  </SECTION>
  <SECTION title="4 Experiments" number="5">
    <S sid="107" ssid="1">For this study, we chose three corpora: the British National Corpus (BNC) for English, a 10 Million sentences newspaper corpus from Projekt Deutscher Wortschatz4 for German, and 3 million sentences from a Finnish web corpus (from the same source).</S>
    <S sid="108" ssid="2">Table 1 summarizes some characteristics. lang. sent. tok. tagger nr.</S>
    <S sid="109" ssid="3">200 10K tags cov. cov.</S>
    <S sid="110" ssid="4">CPTs do not only smoothly serve as a substitute lexicon component, they also realize capitalization, camel case and suffix endings naturally.</S>
    <S sid="111" ssid="5">Since a high coverage is reached with few words in English, a strategy that assigns only the most frequent words to sensible clusters will take us very far here.</S>
    <S sid="112" ssid="6">In the Finnish case, we can expect a high OOV rate, hampering performance of strategies that cannot cope well with low frequency or unseen words. value, we found the best performance averaged over all corpora.</S>
    <S sid="113" ssid="7">To put our results in perspective, we computed the following baselines on random samples of the same 1000 randomly chosen sentences that we used for evaluation: Table 2 summarizes the baselines.</S>
    <S sid="114" ssid="8">We give PP figures as well as tag-conditional cluster perplexity PPG (uncertainty to predict the clustering from the gold standard tags, inverse direction of PP): We measured the quality of the resulting taggers for combinations of several substeps: Figure 2 illustrates the influence of the similarity threshold s for O, OM and OMA for German &#8211; the other languages showed similar results.</S>
    <S sid="115" ssid="9">Varying s influences coverage on the 10,000 target words.</S>
    <S sid="116" ssid="10">When clustering very few words, tagging performance on these words reaches a PP as low as 1.25 but the high OOV rate impairs the total performance.</S>
    <S sid="117" ssid="11">Clustering too many words results in deterioration of results most words end up in one big partition.</S>
    <S sid="118" ssid="12">In the medium ranges, higher coverage and lower known PP compensate each other, optimal total PPs were observed at target coverages 4,0008,000.</S>
    <S sid="119" ssid="13">Adding ambiguous words results in a worse performance on lexicon words, yet improves overall performance, especially for high thresholds.</S>
    <S sid="120" ssid="14">For all further experiments we fixed the threshold in a way that partitioning 1 consisted of 5,000 words, so only half of the top 10,000 words are considered unambiguous.</S>
    <S sid="121" ssid="15">At this Fig 2.</S>
    <S sid="122" ssid="16">Influence of threshold s on tagger performance: cluster-conditional tag perplexity PP as a function of target word coverage. oov% is the fraction of non-lexicon words.</S>
    <S sid="123" ssid="17">Overall results are presented in table 3.</S>
    <S sid="124" ssid="18">The combined strategy TMA reaches the lowest PP for all languages.</S>
    <S sid="125" ssid="19">The morphology extension (M) always improves the OOV scores.</S>
    <S sid="126" ssid="20">Adding ambiguous words (A) hurts the lexicon performance, but largely reduces the OOV rate, which in turn leads to better overall performance.</S>
    <S sid="127" ssid="21">Combining both partitionings (T) does not always decrease the total PP a lot, but lowers the number of tags significantly.</S>
    <S sid="128" ssid="22">Finnish figures are generally worse than for the other languages, akin to higher baselines.</S>
    <S sid="129" ssid="23">The high OOV perplexities for English in experiment TM and TMA can be explained as follows: The smaller the OOV rate gets, the more likely it is that the corresponding words were also OOV in the gold standard tagger.</S>
    <S sid="130" ssid="24">A remedy would be to evaluate on hand-tagged data.</S>
    <S sid="131" ssid="25">Differences between languages are most obvious when comparing OMA and TM: whereas for English it pays off much more to add ambiguous words than to merge the two partitionings, it is the other way around in the German and Finnish experiments.</S>
    <S sid="132" ssid="26">To wrap up: all steps undertaken improve the performance, yet their influence's strength varies.</S>
    <S sid="133" ssid="27">As a flavour of our system's output, consider the example in table 4 that has been tagged by our English TMA model: as in the introductory example, &amp;quot;saw&amp;quot; is disambiguated correctly.</S>
    <S sid="134" ssid="28">We compare our results to (Freitag, 2004), as most other works use different evaluation techniques that are only indirectly measuring what we try to optimize here.</S>
    <S sid="135" ssid="29">Unfortunately, (Freitag 2004) does not provide a total PP score for his 200 tags.</S>
    <S sid="136" ssid="30">He experiments with an handtagged, clean English corpus we did not have access to (the Penn Treebank).</S>
    <S sid="137" ssid="31">Freitag reports a PP for known words of 1.57 for the top 5,000 words (91% corpus coverage, baseline 1 at 23.6), a PP for unknown words without morphological extension of 4.8.</S>
    <S sid="138" ssid="32">Using morphological features the unknown PP score is lowered to 4.0.</S>
    <S sid="139" ssid="33">When augmenting the lexicon with low frequency words via their distributional characteristics, a PP as low as 2.9 is obtained for the remaining 9% of tokens.</S>
    <S sid="140" ssid="34">His methodology, however, does not allow for class ambiguity in the lexicon, the low number of OOV words is handled by a Hidden Markov Model.</S>
  </SECTION>
  <SECTION title="5 Conclusion and further work" number="6">
    <S sid="141" ssid="1">We presented a graph-based approach to unsupervised POS tagging.</S>
    <S sid="142" ssid="2">To our knowledge, this is the first attempt to leave the decision on tag granularity to the tagger.</S>
    <S sid="143" ssid="3">We supported the claim of language-independence by validating the output of our system against supervised systems in three languages.</S>
    <S sid="144" ssid="4">The system is not very sensitive to parameter changes: the number of feature words, the frequency cutoffs, the log-likelihood threshold and all other parameters did not change overall performance considerably when altered in reasonable limits.</S>
    <S sid="145" ssid="5">In this way it was possbile to arrive at a one-size-fits-all configuration that allows the parameter-free unsupervised tagging of large corpora.</S>
    <S sid="146" ssid="6">To really judge the benefit of an unsupervised tagging system, it should be evaluated in an application-based way.</S>
    <S sid="147" ssid="7">Ideally, the application should tell us the granularity of our tagger: e.g. semantic class learners could greatly benefit from the high-granular word sets arising in both of our partitionings, which we endeavoured to lump into a coarser tagset here.</S>
  </SECTION>
</PAPER>
