<PAPER>
  <S sid="0">Deterministic Parsing Of Syntactic Non-Fluencies</S>
  <ABSTRACT>
    <S sid="1" ssid="1">128 24% 161 29% 47 9% 148 27% 32 6% 17 3% 11 2% 6.</S>
    <S sid="2" ssid="2">Discussion the rules for Fidditch are written as deterministic pattern-action rules of the same sort as the rules in the parsing grammar, their operation is in a sense isolable.</S>
    <S sid="3" ssid="3">The patterns of the self-correction rules are checked first, before any of the grammar rule patterns are checked, at each step in the parse.</S>
    <S sid="4" ssid="4">Despite this independence in terms of rule ordering, the operation of the self-corr,:ction component is closely tied to the grammar of the parser; for it is the parsing grammar that specifies what sort of constituents count as the same for copying. example, if the grammar did not treat a noun phrase when it is subject of a sentence, the self-correction rules could not properly resolve a sentence like People-a people from Kennsington the editing rules would never recognize that the same sort of element.</S>
    <S sid="5" ssid="5">(Note (13) treated as a Restart because lexical trigger is not present.)</S>
    <S sid="6" ssid="6">Thus, the observed pattern of self-correction introduces empirical constraints on the set of features that are available for syntactic rules.</S>
    <S sid="7" ssid="7">The self-correction rules impose constraints not only on what linguistic elements must count as the same, but also on what must count as different.</S>
    <S sid="8" ssid="8">For example, in sentence be recognized as different sorts of elements in the grammar for the AUX node to be correctly the grammar assigned the words exactly the same part of speech, then the Category C;.7y Editor necessarily apply, incorrectly expunging (14) Kid could-be a brain in school.</S>
    <S sid="9" ssid="9">It appears therefore that the pattern of self-corrections that occur represents a potentially rich source of evidence about the nature of syntactic categories. the patterns of self-correction count as about the nature of categories for the linguist, then this data must be equally available to the language learner.</S>
    <S sid="10" ssid="10">This would suggest that, far from being an impediment to language learning, non-fluencies may in fact facilitate language acquisition by highlighting equivalent classes. expunction of edit signal only surface copy category copy stack copy restart failures remaining unclear and ungrammatical 127 This raises the general question of how children can acquire a language in the face of unrestrained non-fluency.</S>
    <S sid="11" ssid="11">How can a language learner sort out the grammatical from the ungrammatical strings?</S>
    <S sid="12" ssid="12">(The non-fluencies of speech are of course but one aspect of the degeneracy of input that makes language acquisition a puzzle.)</S>
    <S sid="13" ssid="13">The self-correction system I have described suggests that many non-fluent strings can be resolved with little detailed linguistic knowledge.</S>
    <S sid="14" ssid="14">As Table 1 shows, about a quarter of the editing signals result in expunction of only non-linguistic material.</S>
    <S sid="15" ssid="15">This requires only an ability to distinguish linguistic from nonlinguistic stuff, and it introduces the idea that edit signals signal an expunction site.</S>
    <S sid="16" ssid="16">Almost a third are resolved by the Surface Copying rule, which can be viewed simply as an instance of the general non-linguistic rule that multiple instances of the same thing count as a single instance.</S>
    <S sid="17" ssid="17">The category copying rules are generalizations of simple copying, applied to a knowledge of linguistic categories.</S>
    <S sid="18" ssid="18">Making the transition from surface copies to category copies is aided by the fact that there is considerable overlap in coverage, defining a path of expanding generalization.</S>
    <S sid="19" ssid="19">Thus at the earliest stages of learning, only the simplest, non-linguistic self-correction rules would come into play, and gradually the more syntactically integrated would be acquired.</S>
    <S sid="20" ssid="20">Contrast this self-correction system to an approach that handles non-fluencies by some general problem solving routines, for example Granger (1982), who proposes reasoning from what a speaker might be expected to say.</S>
    <S sid="21" ssid="21">Besides the obvious inefficiencies of general problem solving approaches, it is worth giving special emphasis to the problem with learnability.</S>
    <S sid="22" ssid="22">A general problem solving approach depends crucially on evaluating the likelihood of possible deviations from the norms.</S>
    <S sid="23" ssid="23">But a language learner has by definition only partial and possibly incorrect knowledge of the syntax, and is therefore unable to consistently identify deviations from the grammatical system.</S>
    <S sid="24" ssid="24">With the editing system I describe, the learner need not have the ability to recognize deviations from grammatical norms, but merely the non-linguistic ability to recognize copies of the same thing. far, I have considered the selfcorrection component from the standpoint of parsing.</S>
    <S sid="25" ssid="25">However, it is clear that the origins are in the process of generation.</S>
    <S sid="26" ssid="26">The mechanism for editing self-corrections that I have proposed has as its essential operation expunging one two identical is unable to expunge a sequence of two elements.</S>
    <S sid="27" ssid="27">(The Surface Copy Editor might be viewed as a counterexample to this claim, but see below.)</S>
    <S sid="28" ssid="28">Consider expunction now from the standpoint of the generator.</S>
    <S sid="29" ssid="29">Suppose self-correction bears a one-to-one relationship to a possible action of the generator (initiated by some monitoring component) which could be called ABANDON CONSTRUCT X.</S>
    <S sid="30" ssid="30">And suppose that this action can be initiated at any time up until CONSTRUCT X is completed, when a signal is returned that the construction is complete.</S>
    <S sid="31" ssid="31">Further suppose that ABANDON CONSTRUCT X causes an editing signal.</S>
    <S sid="32" ssid="32">When the speaker decides in the middle of some linguistic element to abandon it and start again, an editing signal is produced.</S>
    <S sid="33" ssid="33">If this is an appropriate model, then the elements which are self-corrected should be exactly those elements that xist at some stage in the generation process.</S>
    <S sid="34" ssid="34">Thus, we should be able to find evidence for the units involved in generation by looking at the data of self-correction.</S>
    <S sid="35" ssid="35">And indeed, such evidence should be available to the language learner as well.</S>
    <S sid="36" ssid="36">Summary I have described the nature of self-corrected speech (which is a major source of spoken non-fluencies) and how it can be resolved by simple editing rules within the context of a deterministic parser.</S>
    <S sid="37" ssid="37">Two features are essential to the self-correction system: 1) every self-correction site (whether it results in the expunction of words or not) is marked by a phonetically identifiable signal placed at the right edge of the potential expunction site; and 2) the expunged part is the left-hand member of a pair of copies, one on each side of the editing signal.</S>
    <S sid="38" ssid="38">The copies may be of three types: 1) identical surface strings, which are edited by a matching rule that applies before syntactic analysis begins; 2) complete constituents, when two constituents of the same type appear in the parser's buffer; or 3) incomplete constituents, when the parser finds itself trying to complete a constituent of the same type as a constituent it has just completed.</S>
    <S sid="39" ssid="39">Whenever two such copies appear in such a configuration, and the first one ends with an editing signal, the first is expunged from further analysis.</S>
    <S sid="40" ssid="40">This editing system has been implemented as part of a deterministic parser, and tested on a wide range of sentences from transcribed speech.</S>
    <S sid="41" ssid="41">Further study of the self-correction system promises to provide insights into the units of production and the nature of linguistic categories.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="42" ssid="1">Bell Laboratories Murray Hill, New Jersey 07974 It is often remarked that natural language, used naturally, is unnaturally ungrammatical.</S>
    <S sid="43" ssid="2">&#8226; Spontaneous speech contains all manner of false starts, hesitations, and self-corrections that disrupt the well-formedness of strings.</S>
    <S sid="44" ssid="3">It is a mystery then, that despite this apparent wide deviation from grammatical norms, people have little difficulty understanding the non-fluent speech that is the essential medium of everyday life.</S>
    <S sid="45" ssid="4">And it is a still greater mystery that children can succeed in acquiring the grammar of a language on the basis of evidence provided by a mixed set of apparently grammatical and ungrammatical strings.</S>
    <S sid="46" ssid="5">In this paper I present a system of rules for resolving the non-fluencies of speech, implemented as part of a computational model of syntactic processing.</S>
    <S sid="47" ssid="6">The essential idea is that non-fluencies occur when a speaker corrects something that he or she has already said out loud.</S>
    <S sid="48" ssid="7">Since words once said cannot be unsaid, a speaker can only accomplish a self-correction by saying something additional -- namely the intended words.</S>
    <S sid="49" ssid="8">The intended words are supposed to substitute for the wrongly produced words.</S>
    <S sid="50" ssid="9">For example, in sentence (1), the speaker initially said / but meant we.</S>
    <S sid="51" ssid="10">The problem for the hearer, as for any natural language understanding system, is to determine what words are to be expunged from the actual words said to find the intended sentence.</S>
    <S sid="52" ssid="11">Labov (1966) provided the key to solving this problem when he noted that a phonetic signal (specifically, a markedly abrupt cut-off of the speech signal) always marks the site where self-correction takes place.</S>
    <S sid="53" ssid="12">Of course, finding the site of a self-correction is only half the problem; it remains to specify what should be removed.</S>
    <S sid="54" ssid="13">A first guess suggests that this must be a non-deterministic problem, requiring complex reasoning about what the speaker meant to say.</S>
    <S sid="55" ssid="14">Labov claimed that a simple set of rules operating on the surface string would specify exactly what should be changed, transforming nearly all non-fluent strings into fully grammatical sentences.</S>
    <S sid="56" ssid="15">The specific set of transformational rules Labov proposed were not formally adequate, in part because they were surface transformations which ignored syntactic constituenthood.</S>
    <S sid="57" ssid="16">But his work forms the basis of this current analysis.</S>
    <S sid="58" ssid="17">&#8226; This research was done for the roost part at the University of Pennsylvania. supported by the National Institute of Education under grants G78-0169 and G80-0163.</S>
    <S sid="59" ssid="18">Labov's claim was not of course that ungrammatical sentences are never produced in speech, for that clearly would be false.</S>
    <S sid="60" ssid="19">Rather, it seems that truly ungrammatical productions represent only a tiny fraction of the spoken output, and in the preponderance of cases, an apparent ungrammaticality can be resolved by simple editing rules.</S>
    <S sid="61" ssid="20">In order to make sense of non-fluent speech, it is essential that the various types of grammatical deviation be distinguished.</S>
    <S sid="62" ssid="21">This point has sometimes been missed, and fundamentally different kinds of deviation from standard grammaticality have been treated together because they all present the same sort of problem for a natural language understanding system.</S>
    <S sid="63" ssid="22">For example, Hayes and Mouradian (1981) mix together speaker-initiated self-corrections with fragmentary sentences of all sorts: people often leave out or repeat words or phrases, break off what they are saying and rephrase or replace it, speak in fragments, or otherwise use incorrect grammar (1981:231).</S>
    <S sid="64" ssid="23">Ultimately, it will be essential to distinguish between nonfluent productions on the one hand, and constructions that are fully grammatical though not yet understood, on the other.</S>
    <S sid="65" ssid="24">Although we may not know in detail the correct characterization of such processes as ellipsis and conjunction, they are without doubt fully productive grammatical processes.</S>
    <S sid="66" ssid="25">Without an understanding of the differences in the kinds of non-fluencies that occur, we are left with a kind cf grab bag of grammatical deviation that can never be analyzed except by some sort of general purpose mechanisms.</S>
    <S sid="67" ssid="26">In this paper, I want to characterize the subset of spoken non-fluencies that can be treated as self-corrections, and to describe how they are handled in the context of a deterministic parser.</S>
    <S sid="68" ssid="27">I assume that a system for dealing with self-corrections similar to the one I describe roust be a part of the competence of any natural language user.</S>
    <S sid="69" ssid="28">I will begin by discussing the range of non-fluencies that occur in speech.</S>
    <S sid="70" ssid="29">Then, after reviewing the notion of deterministic parsing, I will describe the model of parsing self-corrections in detail, and report results from a sample of 1500 sentences.</S>
    <S sid="71" ssid="30">Finally, I discuss some implications of this theory of self-correction, particularly for the problem of language acquisition.</S>
  </SECTION>
  <SECTION title="2." number="2">
    <S sid="72" ssid="1">Linguists have been of less help in describing the nature of spoken non-fluencies than might have been hoped; relatively little attention has been devoted to the actual performance of speakers, and studies that claim to be based on performance data seem to ignore the problem of nonfluencies.</S>
    <S sid="73" ssid="2">(Notable exceptions include Frornkin (1980), and Thompson (1980)).</S>
    <S sid="74" ssid="3">For the discussion of self-correction, I want to distinguish three types of non-fluencies that typically occur in speech.</S>
    <S sid="75" ssid="4">Sentence (2a) is an example of non-standard subject relative clauses that are common in speech.</S>
    <S sid="76" ssid="5">Sentence (2b), which seems to have two tensed &amp;quot;be&amp;quot; verbs in one clause is a productive sentence type that occurs regularly, though rarely, in all sorts of spoken discourse (see Kroch and Hindle 1981).</S>
    <S sid="77" ssid="6">I assume that a correct and complete grammar for a parser will have to deal with all grammatical processes, marginal as well as central.</S>
    <S sid="78" ssid="7">I have nothing further to say about unusual constructions here.</S>
    <S sid="79" ssid="8">2.</S>
    <S sid="80" ssid="9">True Ungrammaticalities.</S>
    <S sid="81" ssid="10">A small percentage of spoken utterances are truly ungrammatical.</S>
    <S sid="82" ssid="11">That is, they do not result from any regular grammatical process (however rare), nor are they instances of successful self-correction.</S>
    <S sid="83" ssid="12">Unexceptionable examples are hard to find, but the following give the flavor. focus of this paper.</S>
    <S sid="84" ssid="13">Self-corrected strings all have the characteristic that some extraneous material was apparently inserted, and that expunging some substring results in a well-formed syntactic structure, which is apparently consistent with the meaning that is intended.</S>
    <S sid="85" ssid="14">In the degenerate case, self-correction inserts non-lexical material, which the syntactic processor ignores, as in (4).</S>
    <S sid="86" ssid="15">The minimal non-lexical material that self-correction might insert is the editing signal itself.</S>
    <S sid="87" ssid="16">Other cases (examples 610 below) are only interpretable given the assumption that certain words, which are potentially part of the syntactic structure, are to be removed from the syntactic analysis.</S>
    <S sid="88" ssid="17">The status of the material that is corrected by selfcorrection and is expunged by the editing rules is somewhat odd.</S>
    <S sid="89" ssid="18">I use the term expunction to mean that it is removed from any further syntactic analysis.</S>
    <S sid="90" ssid="19">This does not mean however that a self-corrected string is unavailable for semantic processing.</S>
    <S sid="91" ssid="20">Although the self-corrected string is edited from the syntactic analysis, it is nevertheless available for semantic interpretation.</S>
    <S sid="92" ssid="21">Jefferson (1974) discusses the example (5) ... (thuh] [thiy] officer ... where the initial, self-corrected string (with the preconsonantal form of the rather than the pre-vocalic form) makes it clear that the speaker originally intended to refer to the police by some word other than officer.</S>
    <S sid="93" ssid="22">I should also note that the problems addressed by the self-correction component that I am concerned with are only part of the kind of deviance that occurs in natural language use.</S>
    <S sid="94" ssid="23">Many types of naturally occurring errors are not part of this system, for example, phonological and semantic errors.</S>
    <S sid="95" ssid="24">It is reasonable to hope that much of this dreck will be handled by similar subsystems.</S>
    <S sid="96" ssid="25">Of course, there will always remain errors that are outside of any system.</S>
    <S sid="97" ssid="26">But we expect that the apparent chaos is much more regular than it at first appears and that it can be modeled by the interaction of components that are themselves simple.</S>
    <S sid="98" ssid="27">In the following discussion, I use the terms self. correction and editing more or less interchangeably, though the two terms emphasize the generation and interpretation aspects of the same process.</S>
  </SECTION>
  <SECTION title="3." number="3">
    <S sid="99" ssid="1">The editing system that I will describe is implemented on top of a deterministic parser, called Fidditch. based on the processing principles proposed by Marcus (1980).</S>
    <S sid="100" ssid="2">It takes as input a sentence of standard words and returns a labeled bracketing that represents the syntactic structure as an annotated tree structure.</S>
    <S sid="101" ssid="3">Fidditch was 'designed to process transcripts of spontaneous speech, and to produce an analysis, partial if necessary, for a large corpus of interview transcripts.</S>
    <S sid="102" ssid="4">Because it is a deterministic parser, it produces only one analysis for each sentence.</S>
    <S sid="103" ssid="5">When Fidditch is unable to build larger constituents out of subphrases, it moves on to the next constituent of the sentence.</S>
    <S sid="104" ssid="6">In brief, the parsing process proceeds as follows.</S>
    <S sid="105" ssid="7">The words in a transcribed sentence (where sentence means one tensed clause together with all subordinate clauses) are assigned a lexical category (or set of lexical categories) on the basis of a 2000 word lexicon and a morphological analyzer.</S>
    <S sid="106" ssid="8">The lexicon contains, for each word, a list of possible lexical categories, subcategorization information, and in a few cases, information on compound words.</S>
    <S sid="107" ssid="9">For example, the entry for round states that it is a noun, verb, adjective or preposition, that as a verb it is subcategorized for the movable particles out and up and for NP, and that it may be part of the compound adjective/preposition round about.</S>
    <S sid="108" ssid="10">Once the lexical analysis is complete, The phrase structure tree is constructed on the basis of pattern-action rules using two internal data structures: 1) a push-down stack of incomplete nodes, and 2) a buffer of complete constituents, into which the grammar rules can look through a window of three constituents.</S>
    <S sid="109" ssid="11">The parser matches rule patterns to the configuration of the window and stack.</S>
    <S sid="110" ssid="12">Its basic actions include &#8212; starting to build a new node by pushing a category onto the stack &#8212; attaching the first element of the window to the stack &#8212; dropping subtrees from the stack into the first position in the window when they are complete.</S>
    <S sid="111" ssid="13">The parser proceeds deterministically in the sense that no aspect of the tree structure, once built may be altered by any rule.</S>
    <S sid="112" ssid="14">(See Marcus 1980 for a comprehensive discussion of this theory of parsing.)</S>
    <S sid="113" ssid="15">The self-correction rules specify how much, if anything, to expunge when an editing signal is detected.</S>
    <S sid="114" ssid="16">The rules depend crucially on being able to recognize an editing signal, for that marks the right edge of an expunction site.</S>
    <S sid="115" ssid="17">For the present discussion, I will assume little about the phonetic nature of the signal except that it is phonetically recognizable, and that, whatever their phonetic nature, all editing signals are, for the self-correction system, equivalent.</S>
    <S sid="116" ssid="18">Specifying the nature of the editing signal is, obviously, an area where further research is needed.</S>
    <S sid="117" ssid="19">The only action that the editing rules can perform is expunction, by which I mean removing an element from the view of the parser.</S>
    <S sid="118" ssid="20">The rules never replace one element with another or insert an element in the parser data structures.</S>
    <S sid="119" ssid="21">However, both replacements and insertions can be accomplished within the self-correction system by expunction of partially identical strings.</S>
    <S sid="120" ssid="22">For example, in The self-correction rules will expunge the I am which precedes the editing signal, thereby in effect replacing am with was and inserting really.</S>
    <S sid="121" ssid="23">Self-corrected strings can be viewed formally as having extra material inserted, but not involving either deletion or replacement of material.</S>
    <S sid="122" ssid="24">The linguistic system does seem to make use of both deletions and replacements in other subsystems of grammar however, namely in ellipsis and rank shift.</S>
    <S sid="123" ssid="25">As with the editing system, these are not errors but formal systems that interact with the central features of the syntax.</S>
    <S sid="124" ssid="26">True errors do of course occur involving all three logical possibilities (insertion, deletion, and replacement) but these are relatively rare.</S>
    <S sid="125" ssid="27">The self-correction rules have access to the internal data structures of the parser, and like the parser itself, they operate deterministically.</S>
    <S sid="126" ssid="28">The parser views the editing signal as occurring at the end of a constituent, because it marks the right edge of an expunged element.</S>
    <S sid="127" ssid="29">There are two types of editing rules in the system: expunction of copies, for which there are three rules, and lexically triggered restarts, for which there is one rule.</S>
    <S sid="128" ssid="30">The copying rules say that if you have two elements which are the same and they are separated by an editing signal, the first should be expunged from the structure.</S>
    <S sid="129" ssid="31">Obviously the trick here is to determine what counts as copies.</S>
    <S sid="130" ssid="32">There are three specific places where copy editing applies.</S>
    <S sid="131" ssid="33">SURFACE COPY EDITOR.</S>
    <S sid="132" ssid="34">This is essentially a nonsyntactic rule that matches the surface string on either side of the editing signal, and expunges the first copy.</S>
    <S sid="133" ssid="35">It applies to the surface string (i.e., for transcripts, the orthographic string) before any syntactic procc.&#8211;:&#8211;.6.</S>
    <S sid="134" ssid="36">For example, in (7), the underlined strings are expunged before parsing begins.</S>
    <S sid="135" ssid="37">(7a) Well if they'd-- if they'd had a knife / wou-- I wouldn't be here today.</S>
    <S sid="136" ssid="38">(7b) If they-- if they could do it.</S>
    <S sid="137" ssid="39">Typically, the Surface Copy Editor expunges a string of words that would later be analyzed as a constituent (or partial constituent), and would be expunged by the Category or the Stack Editors (as in 7a).</S>
    <S sid="138" ssid="40">However, the string that is expunged by the Surface Copy Editor need not be dominated by a single node; it can be a sequence of unrelated constituents.</S>
    <S sid="139" ssid="41">For example, in (7b) the parser will not analyze the first if they as an SBAR node since there is no AUX node to trigger the start of a sentence, and therefore, the words will not be expunged by either the Category or the Stack editor.</S>
    <S sid="140" ssid="42">Such cases where the Surface Copy Editor must apply are rare, and it may therefore be that there exists an optimal parser grammar that would make the Surface Copy Editor redundant; all strings would be edited by the syntactically based Category and Stack Copy rules.</S>
    <S sid="141" ssid="43">However, it seems that the Surface Copy Editor must exist at some stage in the process of syntactic acquisition.</S>
    <S sid="142" ssid="44">The overlap between it and the other rules may be essential in learning.</S>
    <S sid="143" ssid="45">CATEGORY COPY EDITOR.</S>
    <S sid="144" ssid="46">This copy editor matches syntactic constituents in the first two positions in the parser's buffer of complete constituents.</S>
    <S sid="145" ssid="47">When the first window position ends with an editing signal and the first and second constituents in the window are of the same type, the first is expunged.</S>
    <S sid="146" ssid="48">For example, in sentence (8) the first of two determiners separated by an editing signal is expunged and the first of two verbs is similarly expunged.</S>
    <S sid="147" ssid="49">(8) I was just that -- the kind of guy that didn't have-like to have people worrying.</S>
    <S sid="148" ssid="50">STACK COPY EDITOR.</S>
    <S sid="149" ssid="51">If the first constituent in the window is preceded by an editing signal, the Stack Copy Editor looks into the stack for a constituent of the same type, and expunges any copy it finds there along with all descendants.</S>
    <S sid="150" ssid="52">(In the current implementation, the Stack Copy Editor is allowed to look at successive nodes in the stack, back to the first COMP node or attention shifting boundary.</S>
    <S sid="151" ssid="53">If it finds a copy, it expunges that copy along with any nodes that are at a shallower level in the stack.</S>
    <S sid="152" ssid="54">If Fidditch were allowed to attach of incomplete constituents, the Stack Copy Editor could be implemented to delete the copy only, without searching through the stack.</S>
    <S sid="153" ssid="55">The specifics of the implementation seems not to matter for this discussion of the editing rules.)</S>
    <S sid="154" ssid="56">In sentence (9), the initial embedded sentence is expunged by the Stack Copy Editor.</S>
    <S sid="155" ssid="57">It will be useful to look a little more closely at the operation of the parser to see the editing rules at work.</S>
    <S sid="156" ssid="58">Sentence (10) includes three editing signals which trigger the copy editors.</S>
    <S sid="157" ssid="59">(note also that the complement of were is ellipted.)</S>
    <S sid="158" ssid="60">I will show a trace of the parser at each of these correction stages.</S>
    <S sid="159" ssid="61">The first editor that comes into play is the Surface Copy Editor, which searches for identical strings on either side of an editing signal, and expunges the first copy.</S>
    <S sid="160" ssid="62">This is done once for each sentence, before any lexical category assignments are made.</S>
    <S sid="161" ssid="63">Thus in effect, the Surface Copy Editor corresponds to a phonetic/phonological matching operation, although it is in fact an orthographic procedure because we are dealing with transcriptions.</S>
    <S sid="162" ssid="64">Obviously, a full understanding of the self-correction system calls for detailed phonetic/phonological investigations.</S>
    <S sid="163" ssid="65">After the Surface Copy Editor has applied, the string that the lexical analyzer sees is (11) rather than (10).</S>
    <S sid="164" ssid="66">Lexical assignments are made, and the parser proceeds to build the tree structures.</S>
    <S sid="165" ssid="67">After some processing, the configuration of the data structures is that shown in Figure 1.</S>
    <S sid="166" ssid="68">Before determining what next rule to apply, the two editing rules come into play, the Category Editor and the Stack Editor.</S>
    <S sid="167" ssid="69">At this pulse, the Stack Editor will apply because the first constituent in the window is the same (an AUX node) as the current active node, and the current node ends with an edit signal.</S>
    <S sid="168" ssid="70">As a result, the first window element is popped into another dimension, leaving the the parser data structures in the state shown in Figure 2.</S>
    <S sid="169" ssid="71">Parsing of the sentence proceeds, and eventually reaches the state shown in Figure 3. where the Stack Editor conditions are again met.</S>
    <S sid="170" ssid="72">The current active node and the first element in the window are both NPs, and the active node ends with an edit signal.</S>
    <S sid="171" ssid="73">This causes the current node to be expunged, leaving only a single NP node, the one in the window.</S>
    <S sid="172" ssid="74">The final analysis of the sentence, after some more processing is the tree shown in Figure 4.</S>
    <S sid="173" ssid="75">I should reemphasize that the status of the edited elements is special.</S>
    <S sid="174" ssid="76">The copy editing rules remove a constituent, no matter how large, from the view of the parser.</S>
    <S sid="175" ssid="77">The parser continues as if those words had not been said.</S>
    <S sid="176" ssid="78">Although the expunged constituents may be available for semantic interpretation, they do not form part of the main predication.</S>
    <S sid="177" ssid="79">A somewhat different sort of self-correction, less sensitive to syntactic structure and flagged not only by the editing signal but also by a lexical item, is the restart.</S>
    <S sid="178" ssid="80">A restart triggers the expunction of all words from the edit signal back to the beginning of the sentence.</S>
    <S sid="179" ssid="81">It is signaled by a standard edit signal followed by a specific lexical item drawn from a set including well, ok, see, you know, like 1 said, etc.</S>
    <S sid="180" ssid="82">For example, It seems likely that, in addition to the lexical signals, specific intonational signals may also be involved in restarts.</S>
  </SECTION>
  <SECTION title="5." number="4">
    <S sid="181" ssid="1">The editing system I have described has been applied to a corpus of over twenty hours of transcribed speech, in the process of using the parser to search for various syntactic constructions.</S>
    <S sid="182" ssid="2">Thc transcripts are of sociolinguistic interviews of the sort developed by Labov and designed to elicit unreflecting speech that approximates natural conversation .&#8226; They are conversational interviews covering a range of topics, and they typically include considerable non-fluency.</S>
    <S sid="183" ssid="3">(Over half the sentences in one 90 minute interview contained at least one non-fluency).</S>
    <S sid="184" ssid="4">The transcriptions are in standard orthography, with sentence boundaries indicated.</S>
    <S sid="185" ssid="5">The alternation of speakers' turns is indicated, but overlap is not.</S>
    <S sid="186" ssid="6">Editing signals, when noted by the transcriber, are indicated in the transcripts with a double dash.</S>
    <S sid="187" ssid="7">It is clear that this approach to transcription oniy imperfectly reflects the phonetics of editing signals; we can't be sure to what extent the editing signals in our transcripts represent facts about production and to what extent they represent facts about perception.</S>
    <S sid="188" ssid="8">Nevertheless, except for a general tendency toward underrepresentation, there seems to be no systematic bias in our transcriptions of the editing signals, and therefore our findings are not likely to be undone by a better understanding of the phonetics of self-correction.</S>
    <S sid="189" ssid="9">One major problem in analyzing the syntax of English is the multiple category membership of words.</S>
    <S sid="190" ssid="10">In general, most decisions about category membership can be made on the basis of local context.</S>
    <S sid="191" ssid="11">However, by its nature, selfcorrection disrupts the local context, and therefore the disambiguation of lexical categories becomes a more difficult problem.</S>
    <S sid="192" ssid="12">It is not clear whether the rules for category disambiguation extend across an editing signal or not.</S>
    <S sid="193" ssid="13">The results I present depend on a successful disambiguation of the syntactic categories, though the algorithm to accomplish this is not completely specified.</S>
    <S sid="194" ssid="14">Thus, to test the self-correction routines I have, where necessary, imposed the proper category assignment.</S>
    <S sid="195" ssid="15">Table 1 shows the result of this editing system in the parsing of the interview transcripts from one speaker.</S>
    <S sid="196" ssid="16">All in all this shows the editing system to be quite successful in resolving non-fluencies.</S>
  </SECTION>
  <SECTION title="6." number="5">
    <S sid="197" ssid="1">Although the editing rules for Fidditch are written as deterministic pattern-action rules of the same sort as the rules in the parsing grammar, their operation is in a sense isolable.</S>
    <S sid="198" ssid="2">The patterns of the self-correction rules are checked first, before any of the grammar rule patterns are checked, at each step in the parse.</S>
    <S sid="199" ssid="3">Despite this independence in terms of rule ordering, the operation of the self-corr,:ction component is closely tied to the grammar of the parser; for it is the parsing grammar that specifies what sort of constituents count as the same for copying.</S>
    <S sid="200" ssid="4">For example, if the grammar did not treat there as a noun phrase when it is subject of a sentence, the self-correction rules could not properly resolve a sentence like because the editing rules would never recognize that people and there are the same sort of element.</S>
    <S sid="201" ssid="5">(Note that (13) cannot be treated as a Restart because the lexical trigger is not present.)</S>
    <S sid="202" ssid="6">Thus, the observed pattern of self-correction introduces empirical constraints on the set of features that are available for syntactic rules.</S>
    <S sid="203" ssid="7">The self-correction rules impose constraints not only on what linguistic elements must count as the same, but also on what must count as different.</S>
    <S sid="204" ssid="8">For example, in sentence (14), could and be must be recognized as different sorts of elements in the grammar for the AUX node to be correctly resolved.</S>
    <S sid="205" ssid="9">If the grammar assigned the two words exactly the same part of speech, then the Category C;.7y Editor would necessarily apply, incorrectly expunging could.</S>
    <S sid="206" ssid="10">It appears therefore that the pattern of self-corrections that occur represents a potentially rich source of evidence about the nature of syntactic categories.</S>
    <S sid="207" ssid="11">Learnability.</S>
    <S sid="208" ssid="12">If the patterns of self-correction count as evidence about the nature of syntactic categories for the linguist, then this data must be equally available to the language learner.</S>
    <S sid="209" ssid="13">This would suggest that, far from being an impediment to language learning, non-fluencies may in fact facilitate language acquisition by highlighting equivalent classes.</S>
    <S sid="210" ssid="14">This raises the general question of how children can acquire a language in the face of unrestrained non-fluency.</S>
    <S sid="211" ssid="15">How can a language learner sort out the grammatical from the ungrammatical strings?</S>
    <S sid="212" ssid="16">(The non-fluencies of speech are of course but one aspect of the degeneracy of input that makes language acquisition a puzzle.)</S>
    <S sid="213" ssid="17">The self-correction system I have described suggests that many non-fluent strings can be resolved with little detailed linguistic knowledge.</S>
    <S sid="214" ssid="18">As Table 1 shows, about a quarter of the editing signals result in expunction of only non-linguistic material.</S>
    <S sid="215" ssid="19">This requires only an ability to distinguish linguistic from nonlinguistic stuff, and it introduces the idea that edit signals signal an expunction site.</S>
    <S sid="216" ssid="20">Almost a third are resolved by the Surface Copying rule, which can be viewed simply as an instance of the general non-linguistic rule that multiple instances of the same thing count as a single instance.</S>
    <S sid="217" ssid="21">The category copying rules are generalizations of simple copying, applied to a knowledge of linguistic categories.</S>
    <S sid="218" ssid="22">Making the transition from surface copies to category copies is aided by the fact that there is considerable overlap in coverage, defining a path of expanding generalization.</S>
    <S sid="219" ssid="23">Thus at the earliest stages of learning, only the simplest, non-linguistic self-correction rules would come into play, and gradually the more syntactically integrated would be acquired.</S>
    <S sid="220" ssid="24">Contrast this self-correction system to an approach that handles non-fluencies by some general problem solving routines, for example Granger (1982), who proposes reasoning from what a speaker might be expected to say.</S>
    <S sid="221" ssid="25">Besides the obvious inefficiencies of general problem solving approaches, it is worth giving special emphasis to the problem with learnability.</S>
    <S sid="222" ssid="26">A general problem solving approach depends crucially on evaluating the likelihood of possible deviations from the norms.</S>
    <S sid="223" ssid="27">But a language learner has by definition only partial and possibly incorrect knowledge of the syntax, and is therefore unable to consistently identify deviations from the grammatical system.</S>
    <S sid="224" ssid="28">With the editing system I describe, the learner need not have the ability to recognize deviations from grammatical norms, but merely the non-linguistic ability to recognize copies of the same thing.</S>
    <S sid="225" ssid="29">Generation.</S>
    <S sid="226" ssid="30">Thus far, I have considered the selfcorrection component from the standpoint of parsing.</S>
    <S sid="227" ssid="31">However, it is clear that the origins are in the process of generation.</S>
    <S sid="228" ssid="32">The mechanism for editing self-corrections that I have proposed has as its essential operation expunging one of two identical elements.</S>
    <S sid="229" ssid="33">It is unable to expunge a sequence of two elements.</S>
    <S sid="230" ssid="34">(The Surface Copy Editor might be viewed as a counterexample to this claim, but see below.)</S>
    <S sid="231" ssid="35">Consider expunction now from the standpoint of the generator.</S>
    <S sid="232" ssid="36">Suppose self-correction bears a one-to-one relationship to a possible action of the generator (initiated by some monitoring component) which could be called ABANDON CONSTRUCT X.</S>
    <S sid="233" ssid="37">And suppose that this action can be initiated at any time up until CONSTRUCT X is completed, when a signal is returned that the construction is complete.</S>
    <S sid="234" ssid="38">Further suppose that ABANDON CONSTRUCT X causes an editing signal.</S>
    <S sid="235" ssid="39">When the speaker decides in the middle of some linguistic element to abandon it and start again, an editing signal is produced.</S>
    <S sid="236" ssid="40">If this is an appropriate model, then the elements which are self-corrected should be exactly those elements that xist at some stage in the generation process.</S>
    <S sid="237" ssid="41">Thus, we should be able to find evidence for the units involved in generation by looking at the data of self-correction.</S>
    <S sid="238" ssid="42">And indeed, such evidence should be available to the language learner as well.</S>
  </SECTION>
  <SECTION title="Summary" number="6">
    <S sid="239" ssid="1">I have described the nature of self-corrected speech (which is a major source of spoken non-fluencies) and how it can be resolved by simple editing rules within the context of a deterministic parser.</S>
    <S sid="240" ssid="2">Two features are essential to the self-correction system: 1) every self-correction site (whether it results in the expunction of words or not) is marked by a phonetically identifiable signal placed at the right edge of the potential expunction site; and 2) the expunged part is the left-hand member of a pair of copies, one on each side of the editing signal.</S>
    <S sid="241" ssid="3">The copies may be of three types: 1) identical surface strings, which are edited by a matching rule that applies before syntactic analysis begins; 2) complete constituents, when two constituents of the same type appear in the parser's buffer; or 3) incomplete constituents, when the parser finds itself trying to complete a constituent of the same type as a constituent it has just completed.</S>
    <S sid="242" ssid="4">Whenever two such copies appear in such a configuration, and the first one ends with an editing signal, the first is expunged from further analysis.</S>
    <S sid="243" ssid="5">This editing system has been implemented as part of a deterministic parser, and tested on a wide range of sentences from transcribed speech.</S>
    <S sid="244" ssid="6">Further study of the self-correction system promises to provide insights into the units of production and the nature of linguistic categories.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="7">
    <S sid="245" ssid="1">My thanks to Tony Kroch, Mitch Marcus, and Ken Church for helpful comments on this work.</S>
  </SECTION>
</PAPER>
