<PAPER>
  <S sid="0">Experiments With A Multilanguage Non-Projective Dependency Parser</S>
  <ABSTRACT/>
  <SECTION title="1 Introduction" number="1">
    <S sid="1" ssid="1">Parsing natural language is an essential step in several applications that involve document analysis, e.g. knowledge extraction, question answering, summarization, filtering.</S>
    <S sid="2" ssid="2">The best performing systems at the TREC Question Answering track employ parsing for analyzing sentences in order to identify the query focus, to extract relations and to disambiguate meanings of words.</S>
    <S sid="3" ssid="3">These are often demanding applications, which need to handle large collections and to provide results in a fraction of a second.</S>
    <S sid="4" ssid="4">Dependency parsers are promising for these applications since a dependency tree provides predicate-argument relations which are convenient for use in the later stages.</S>
    <S sid="5" ssid="5">Recently statistical dependency parsing techniques have been proposed which are deterministic and/or linear (Yamada and Matsumoto, 2003; Nivre and Scholz, 2004).</S>
    <S sid="6" ssid="6">These parsers are based on learning the correct sequence of Shift/Reduce actions used to construct the dependency tree.</S>
    <S sid="7" ssid="7">Learning is based on techniques like SVM (Vapnik 1998) or Memory Based Learning (Daelemans 2003), which provide high accuracy but are often computationally expensive.</S>
    <S sid="8" ssid="8">Kudo and Matsumoto (2002) report a two week learning time on a Japanese corpus of about 8000 sentences with SVM.</S>
    <S sid="9" ssid="9">Using Maximum Entropy (Berger, et al. 1996) classifiers I built a parser that achieves a throughput of over 200 sentences per second, with a small loss in accuracy of about 23 %.</S>
    <S sid="10" ssid="10">The efficiency of Maximum Entropy classifiers seems to leave a large margin that can be exploited to regain accuracy by other means.</S>
    <S sid="11" ssid="11">I performed a series of experiments to determine whether increasing the number of features or combining several classifiers could allow regaining the best accuracy.</S>
    <S sid="12" ssid="12">An experiment cycle in our setting requires less than 15 minutes for a treebank of moderate size like the Portuguese treebank (Afonso et al., 2002) and this allows evaluating the effectiveness of adding/removing features that hopefully might apply also when using other learning techniques.</S>
    <S sid="13" ssid="13">I extended the Yamada-Matsumoto parser to handle labeled dependencies: I tried two approaches: using a single classifier to predict pairs of actions and labels and using two separate classifiers, one for actions and one for labels.</S>
    <S sid="14" ssid="14">Finally, I extended the repertoire of actions used by the parser, in order to handle non-projective relations.</S>
    <S sid="15" ssid="15">Tests on the PDT (B&#246;hmov&#224; et al., 2003) show that the added actions are sufficient to handle all cases of non-projectivity.</S>
    <S sid="16" ssid="16">However, since the cases of non-projectivity are quite rare in the corpus, the general learner is not supplied enough of them to learn how to classify them accurately, hence it may be worthwhile to exploit a second classifier trained specifically in handling nonprojective situations.</S>
    <S sid="17" ssid="17">The overall parsing algorithm is an inductive statistical parser, which extends the approach by Yamada and Matsumoto (2003), by adding six new reduce actions for handling non-projective relations and also performs dependency labeling.</S>
    <S sid="18" ssid="18">Parsing is deterministic and proceeds bottom-up.</S>
    <S sid="19" ssid="19">Labeling is integrated within a single processing step.</S>
    <S sid="20" ssid="20">Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 166&#8211;170, New York City, June 2006. c&#65533;2006 Association for Computational Linguistics The parser is modular: it can use several learning algorithms: Maximum Entropy, SVM, Winnow, Voted Perceptron, Memory Based Learning, as well as combinations thereof.</S>
    <S sid="21" ssid="21">The submitted runs used Maximum Entropy and I present accuracy and performance comparisons with other learning algorithms.</S>
    <S sid="22" ssid="22">No additional resources are used.</S>
    <S sid="23" ssid="23">No pre-processing or post-processing is used, except stemming for Danish, German and Swedish.</S>
  </SECTION>
  <SECTION title="2 Features" number="2">
    <S sid="24" ssid="1">LEMMA was used in features whenever available, otherwise the FORM was used.</S>
    <S sid="25" ssid="2">For Danish, German and Swedish the Snowball stemmer (Porter 2001) was used to generate a value for LEMMA.</S>
    <S sid="26" ssid="3">This use of stemming slightly improved both accuracy and performance.</S>
    <S sid="27" ssid="4">Only CPOSTAG were used.</S>
    <S sid="28" ssid="5">PHEAD/PDEPREL were not used.</S>
    <S sid="29" ssid="6">FEATS were used to extract a single token combining gender, number, person and case, through a language specific algorithm.</S>
    <S sid="30" ssid="7">The selection of features to be used in the parser is controlled by a number of parameters.</S>
    <S sid="31" ssid="8">For example, the parameter PosFeatures determines for which tokens the POS tag will be included in the context, PosLeftChi7dren determines how many left outermost children of a token to consider, PastActions tells how many previous actions to include as features.</S>
    <S sid="32" ssid="9">The settings used in the submitted runs are listed below and configure the parser for not using any word forms.</S>
    <S sid="33" ssid="10">Positive numbers refer to input tokens, negative ones to token on the stack.</S>
    <S sid="34" ssid="11">The context for POS tags consisted of 1 token left and 3 tokens to the right of the focus words, except for Czech and Chinese were 2 tokens to the left and 4 tokens to the right were used.</S>
    <S sid="35" ssid="12">These values were chosen by performing experiments on the training data, using 10% of the sentences as heldout data for development.</S>
  </SECTION>
  <SECTION title="3 Inductive Deterministic Parsing" number="3">
    <S sid="36" ssid="1">The parser constructs dependency trees employing a deterministic bottom-up algorithm which performs Shift/Reduce actions while analyzing input sentences in left-to-right order.</S>
    <S sid="37" ssid="2">Using a notation similar to (Nivre and Scholz, 2003), the state of the parser is represented by a quadruple (S, I, T, A), where S is the stack, I is the list of (remaining) input tokens, T is a stack of temporary tokens and A is the arc relation for the dependency graph.</S>
    <S sid="38" ssid="3">Given an input string W, the parser is initialized to ((), W, (), ()), and terminates when it reaches a configuration (S, (), (), A).</S>
    <S sid="39" ssid="4">The parser by Yamada and Matsumoto (2003) used the following actions: Shift in a configuration (S, n|I, T, A), pushes n to the stack, producing the configuration (n|S, I, T, A).</S>
    <S sid="40" ssid="5">Right1 in a configuration (s1|S, n|I, T, A), adds an arc from s1 to n and pops s1 from the stack, producing the configuration (S, n|I, T, A&#8746;{(s1, r, n)}).</S>
    <S sid="41" ssid="6">Left in a configuration (s1|S, n|I, T, A), adds an arc from n to s1, pops n from input, pops s1 from the stack and moves it back to I, producing the configuration (S, s1|I, T, A&#8746;{(n, r, s1)}).</S>
    <S sid="42" ssid="7">At each step the parser uses classifiers trained on treebank data in order to predict which action to perform and which dependency label to assign given the current configuration.</S>
  </SECTION>
  <SECTION title="4 Non-Projective Relations" number="4">
    <S sid="43" ssid="1">For handling non-projective relations, Nivre and Nilsson (2005) suggested applying a preprocessing step to a dependency parser, which consists in lifting non-projective arcs to their head repeatedly, until the tree becomes pseudo-projective.</S>
    <S sid="44" ssid="2">A post-processing step is then required to restore the arcs to the proper heads.</S>
    <S sid="45" ssid="3">I adopted a novel approach, which consists in adding six new parsing actions: Right2 in a configuration (s1|s2|S, n|I, T, A), adds an arc from s2 to n and removes s2 from the stack, producing the configuration (s1|S, n|I, T, Au{(s2, r, n)}).</S>
    <S sid="46" ssid="4">Left2 in a configuration (s1|s2|S, n|I, T, A), adds an arc from n to s2, pops n from input, pops s1 from the stack and moves it back to I, producing the configuration (s2|S, s1|I, T, Au{(n, r, s2)}).</S>
    <S sid="47" ssid="5">Right3 in a configuration (s1|s2|s3|S, n|I, T, A), adds an arc from s3 to n and removes s3 from the stack, producing the configuration (s1|s2|S, n|I, T, Au{(s3, r, n)}).</S>
    <S sid="48" ssid="6">Left3 in a configuration (s1|s2|s3|S, n|I, T, A), adds an arc from n to s3, pops n from input, pops s1 from the stack and moves it back to I, producing the configuration (s2|s3|S, s1|I, T, Au{(n, r, s3)}).</S>
    <S sid="49" ssid="7">Extract in a configuration (s1|s2|S, n|I, T, A), move s2 from the stack to the temporary stack, then Shift, producing the configuration (n|s1|S, I, s2|T, A).</S>
    <S sid="50" ssid="8">Insert in a configuration (S, I, s1|T, A), pops s1 from T and pushes it to the stack, producing the configuration (s1|S, I, T, A).</S>
    <S sid="51" ssid="9">The actions Right2 and Left2 are sufficient to handle almost all cases of non-projectivity: for instance the training data for Czech contain 28081 non-projective relations, of which 26346 can be handled by Left2/Right2, 1683 by Left3/Right3 and just 52 require Extract/Insert.</S>
    <S sid="52" ssid="10">Here is an example of non-projectivity that can be handled with Right2 (nejen --+ ale) and Left3 (fax --+ Vet&#353;inu): Vet&#353;inu techto pr&#237;stroju lze take pou&#382;&#237;vat nejen jako fax, ale soucasne ... V6t&#353;inu t6chto pf&#237;stroju lze take pou&#382;&#237;vat nejen jako fax , ale The remaining cases are handled with the last two actions: Extract is used to postpone the creation of a link, by saving the token in a temporary stack; Insert restores the token from the temporary stack and resumes normal processing. zou gemaakt moeten worden in This fragment in Dutch is dealt by performing an Extract in configuration (moeten|gemaakt|zou, worden|in, A) followed immediately by an Insert, leading to the following configuration, which can be handled by normal Shift/Reduce actions: zou moeten worden gemaakt in Another linguistic phenomenon is the anticipation of pronouns, like in this Portuguese fragment: Tudo a possive7 encontrar em o IX Sa7&#65533;o de Antiguidades, desde objectos de ouro e prata, moedas, ...</S>
    <S sid="53" ssid="11">The problem here is due to the pronoun Tudo (Anything), which is the object of encontrar (find), but which is also the head of desde (from) and its preceding comma.</S>
    <S sid="54" ssid="12">In order to be able to properly link desde to Tudo, it is necessary to postpone its processing; hence it is saved with Extract to the temporary stack and put back later in front of the comma with Insert.</S>
    <S sid="55" ssid="13">In fact the pair Extract/Insert behaves like a generalized Rightn/Leftn, when n is not known.</S>
    <S sid="56" ssid="14">As in the example, except for the case where n=2, it is difficult to predict the value of n, since there can be an arbitrary long sequence of tokens before reaching the position where the link can be inserted.</S>
  </SECTION>
  <SECTION title="5 Performance" number="5">
    <S sid="57" ssid="1">I used my own C++ implementation of Maximum Entropy, which is very fast both in learning and classification.</S>
    <S sid="58" ssid="2">On a 2.8 MHz Pentium Xeon PC, the learning time is about 15 minutes for Portuguese and 4 hours for Czech.</S>
    <S sid="59" ssid="3">Parsing is also very fast, with an average throughput of 200 sentences per second: Table 1 reports parse time for parsing each whole test set.</S>
    <S sid="60" ssid="4">Using Memory Based Learning increases considerably the parsing time, while as expected learning time is quite shorter.</S>
    <S sid="61" ssid="5">On the other hand MBL achieves an improvement up to 5% in accuracy, as shown in detail in Table 1.</S>
    <S sid="62" ssid="6">Shift/Reduce, one to decide which Reduce action and a third one to choose the dependency in case of Left/Right action For details on the CoNLL-X shared task and the measurements see (Buchholz, et al. 2006).</S>
  </SECTION>
  <SECTION title="6 Experiments" number="6">
    <S sid="63" ssid="1">I performed several experiments to tune the parser.</S>
    <S sid="64" ssid="2">I also tried alternative machine learning algorithms, including SVM, Winnow, Voted Perceptron.</S>
    <S sid="65" ssid="3">The use of SVM turned out quite impractical since the technique does not scale to the size of training data involved: training an SVM with such a large number of features was impossible for any of the larger corpora.</S>
    <S sid="66" ssid="4">For smaller ones, e.g.</S>
    <S sid="67" ssid="5">Portuguese, training required over 4 days but produced a bad model which could not be used (I tried both the TinySVM (Kudo 2002) and the LIBSVM (Chang and Lin 2001) implementations).</S>
    <S sid="68" ssid="6">Given the speed of the Maximum Entropy classifier, I explored whether increasing the number of features could improve accuracy.</S>
    <S sid="69" ssid="7">I experimented adding various features controlled by the parameters above: none appeared to be effective, except the addition of the previous action.</S>
    <S sid="70" ssid="8">The classifier returns both the action and the label to be assigned.</S>
    <S sid="71" ssid="9">Some experiments were carried out splitting the task among several specialized classifiers.</S>
    <S sid="72" ssid="10">I experimented with: 2. two classifiers: one to decide which action to perform and a second one to choose the dependency in case of Left/Right action None of these variants produced improvements in precision.</S>
    <S sid="73" ssid="11">Only a small improvement in labeled attachment score was noticed using the full, nonspecialized classifier to decide the action but discarding its suggestion for label and using a specialized classifier for labeling.</S>
    <S sid="74" ssid="12">However this was combined with a slight decrease in unlabeled attachment score, hence it was not considered worth the effort.</S>
  </SECTION>
  <SECTION title="7 Error Analysis" number="7">
    <S sid="75" ssid="1">The parser does not attempt to assign a dependency relation to the root.</S>
    <S sid="76" ssid="2">A simple correction of assigning a default value for each language gave an improvement in the LAS as shown in Table 1.</S>
    <S sid="77" ssid="3">Out of the 45 dependency relations that the parser had to assign to a sentence, the largest number of errors occurred assigning N&lt;PRED (62), ACC (46), PIV (43), CJT (40), N&lt; (34), P&lt; (30).</S>
    <S sid="78" ssid="4">The highest number of head error occurred at the CPOS tags PRP with 193 and V with 176.</S>
    <S sid="79" ssid="5">In particular just four prepositions (em, de, a, para) accounted for 120 head errors.</S>
    <S sid="80" ssid="6">Most of the errors occur near punctuations.</S>
    <S sid="81" ssid="7">Often this is due to the fact that commas introduce relative phrases or parenthetical phrases (e.g.</S>
    <S sid="82" ssid="8">&#8220;o suspeito, de 38 anos, que traba7ha&#8221;), that produce diversions in the flow.</S>
    <S sid="83" ssid="9">Since the parser makes decisions analyzing only a window of tokens of a limited size, it gets confused in creating attachments.</S>
    <S sid="84" ssid="10">I tried to add some global context features, to be able to distinguish these cases, in particular, a count of the number of punctuation marks seen so far, whether punctuation is present between the focus words.</S>
    <S sid="85" ssid="11">None of them helped improving precision and were not used in the submitted runs.</S>
    <S sid="86" ssid="12">Most current parsers for Czech do not perform well on Apos (apposition), Coord (coordination) and ExD (ellipses), but they are not very frequent.</S>
    <S sid="87" ssid="13">The largest number of errors occur on Obj (166), Adv (155), Sb (113), Atr (98).</S>
    <S sid="88" ssid="14">There is also often confusion among these: 33 times Obj instead of Adv, 32 Sb instead of Obj, 28 Atr instead of Adv.</S>
    <S sid="89" ssid="15">The high error rate of J (adjective) is expected, mainly due to coordination problems.</S>
    <S sid="90" ssid="16">The error of R (preposition) is also relatively high.</S>
    <S sid="91" ssid="17">Prepositions are problematic, but their error rate is higher than expected since they are, in terms of surface order, rather regular and close to the noun.</S>
    <S sid="92" ssid="18">It could be that the decision by the PDT to hang them as heads instead of children, causes a problem in attaching them.</S>
    <S sid="93" ssid="19">It seems that a post-processing may correct a significant portion of these errors.</S>
    <S sid="94" ssid="20">The labels ending with _Co, _Ap or _Pa are nodes who are members of the Coordination, Apposition or the Parenthetical relation, so it may be worth while omitting these suffixes in learning and restore them by post-processing.</S>
    <S sid="95" ssid="21">An experiment using as training corpus a subset consisting of just sentences which include nonprojective relations achieved a LAS of 65.28 % and UAS of 76.20 %, using MBL.</S>
    <S sid="96" ssid="22">Acknowledgments.</S>
    <S sid="97" ssid="23">Kiril Ribarov provided insightful comments on the results for Czech.</S>
    <S sid="98" ssid="24">The following treebanks were used for training the parser: (Afonso et al., 2002; Atalay et al., 2003; B&#246;hmov&#224; et al., 2003; Brants et al., 2002; Chen et al., 2003; Civit Torruella and Mart&#236; Anton&#236;n, 2002; D&#382;eroski et al., 2006; Haji&#231; et al., 2004; Kawata and Bartels, 2000; Kromann, 2003; Nilsson et al., 2005; Oflazer et al., 2003; Simov et al., 2005; van der Beek et al., 2002).</S>
  </SECTION>
</PAPER>
