<PAPER>
  <S sid="0">CCGbank: A Corpus of CCG Derivations and Dependency Structures Extracted from the Penn Treebank</S>
  <ABSTRACT>
    <S sid="1" ssid="1">article presents an algorithm for translating the Penn Treebank into a corpus of Combinatory Categorial Grammar (CCG) derivations augmented with local and long-range word&#8211;word dependencies.</S>
    <S sid="2" ssid="2">The resulting corpus, CCGbank, includes 99.4% of the sentences in the Penn Treebank.</S>
    <S sid="3" ssid="3">It is available from the Linguistic Data Consortium, and has been used to train widecoverage statistical parsers that obtain state-of-the-art rates of dependency recovery.</S>
    <S sid="4" ssid="4">In order to obtain linguistically adequate CCG analyses, and to eliminate noise and inconsistencies in the original annotation, an extensive analysis of the constructions and annotations in the Penn Treebank was called for, and a substantial number of changes to the Treebank were necessary.</S>
    <S sid="5" ssid="5">We discuss the implications of our findings for the extraction of other linguistically expressive grammars from the Treebank, and for the design offuture treebanks.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="6" ssid="1">This article presents an algorithm for translating the Penn Treebank into a corpus of Combinatory Categorial Grammar (CCG) derivations augmented with local and long-range word&#8211;word dependencies.</S>
    <S sid="7" ssid="2">The resulting corpus, CCGbank, includes 99.4% of the sentences in the Penn Treebank.</S>
    <S sid="8" ssid="3">It is available from the Linguistic Data Consortium, and has been used to train widecoverage statistical parsers that obtain state-of-the-art rates of dependency recovery.</S>
    <S sid="9" ssid="4">In order to obtain linguistically adequate CCG analyses, and to eliminate noise and inconsistencies in the original annotation, an extensive analysis of the constructions and annotations in the Penn Treebank was called for, and a substantial number of changes to the Treebank were necessary.</S>
    <S sid="10" ssid="5">We discuss the implications of our findings for the extraction of other linguistically expressive grammars from the Treebank, and for the design offuture treebanks.</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="11" ssid="1">In order to understand a newspaper article, or any other piece of text, it is necessary to construct a representation of its meaning that is amenable to some form of inference.</S>
    <S sid="12" ssid="2">This requires a syntactic representation which is transparent to the underlying semantics, making the local and long-range dependencies between heads, arguments, and modifiers explicit.</S>
    <S sid="13" ssid="3">It also requires a grammar that has sufficient coverage to deal with the vocabulary and the full range of constructions that arise in free text, together with a parsing model that can identify the correct analysis among the many alternatives that such a wide-coverage grammar will generate even for the simplest sentences.</S>
    <S sid="14" ssid="4">Given our current machine learning techniques, such parsing models typically need to be trained on relatively large treebanks&#8212;that is, text corpora hand-labeled with detailed syntactic structures.</S>
    <S sid="15" ssid="5">Because such annotation requires linguistic expertise, and is therefore difficult to produce, we are currently limited to at most a few treebanks per language.</S>
    <S sid="16" ssid="6">One of the largest and earliest such efforts is the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993; Marcus et al. 1994), which contains a one-million word subcorpus of Wall Street Journal text that has become the de facto standard training and test data for statistical parsers.</S>
    <S sid="17" ssid="7">Its annotation, which is based on generic phrasestructure grammar (with coindexed traces and other null elements indicating non-local dependencies) and function tags on nonterminal categories providing (a limited degree of) syntactic role information, is designed to facilitate the extraction of the underlying predicate&#8211;argument structure.</S>
    <S sid="18" ssid="8">Statistical parsing on the Penn Treebank has made great progress by focusing on the machine-learning or algorithmic aspects (Magerman 1994; Ratnaparkhi 1998; Collins 1999; Charniak 2000; Henderson 2004; McDonald, Crammer, and Pereira 2005).</S>
    <S sid="19" ssid="9">However, this has often resulted in parsing models and evaluation measures that are both based on reduced representations which simplify or ignore the linguistic information represented by function tags and null elements in the original Treebank.</S>
    <S sid="20" ssid="10">(One exception is Collins 1999, whose Model 2 includes a distinction between arguments and adjuncts, and whose Model 3 additionally captures wh-movement in relative clauses with a GPSG-like &#8220;slash-feature-passing&#8221; mechanism.)</S>
    <S sid="21" ssid="11">The reasons for this shift away from linguistic adequacy are easy to trace.</S>
    <S sid="22" ssid="12">The very healthy turn towards quantitative evaluation interacts with the fact that just about every dimension of linguistic variation exhibits a Zipfian distribution, where a very small proportion of the available alternatives accounts for most of the data.</S>
    <S sid="23" ssid="13">This creates a temptation to concentrate on capturing the few high-frequency cases at the top end of the distribution, and to ignore the &#8220;long tail&#8221; of rare events such as non-local dependencies.</S>
    <S sid="24" ssid="14">Despite the fact that these occur in a large number of sentences, they affect only a small number of words, and have thus a small impact on overall dependency recovery.</S>
    <S sid="25" ssid="15">Although there is now a sizable literature on trace and function-tag insertion algorithms (Blaheta and Charniak 2000; Johnson 2002; Campbell 2004), and integrated parsing with function tags or null elements (Dienes and Dubey 2003a, 2003b; Merlo and Musillo 2005; Gabbard, Kulick, and Marcus 2006), such approaches typically require additional pre- or postprocessing steps that are likely to add further noise and errors to the parser output.</S>
    <S sid="26" ssid="16">A completely integrated approach that is based on a syntactic representation which allows direct recovery of the underlying predicate&#8211;argument structure might therefore be preferable.</S>
    <S sid="27" ssid="17">Such representations are provided by grammar formalisms that are more expressive than simple phrase-structure grammar, like Lexical-Functional Grammar (LFG) (Kaplan and Bresnan 1982), Head-driven Phrase-Structure Grammar (HPSG) (Pollard and Sag 1994), Tree-Adjoining Grammar (TAG) (Joshi and Schabes 1992), Minimalist Program&#8211;related Grammars (Stabler 2004), or Combinatory Categorial Grammar (CCG) (Steedman 1996, 2000).</S>
    <S sid="28" ssid="18">However, until very recently, only handwritten grammars, which lack the wide coverage and robustness of Treebank parsers, were available for these formalisms (Butt et al. 1999; XTAG-group 1999; Copestake and Flickinger 2000; OpenCCG1 [White and Baldridge 2003; White 2006]).</S>
    <S sid="29" ssid="19">Because treebank annotation for individual formalisms is prohibitively expensive, there have been a number of efforts to extract TAGs, LFGs, and, more recently, HPSGs, from the Penn Treebank (Xia 1999; Chen and Vijay-Shanker 2000; Xia, Palmer, and Joshi 2000; Xia 2001; Cahill et al. 2002; Miyao, Ninomiya, and Tsujii 2004; O&#8217;Donovan et al.</S>
    <S sid="30" ssid="20">2005; Shen and Joshi 2005; Chen, Bangalore, and Vijay-Shanker 2006).</S>
    <S sid="31" ssid="21">Statistical parsers that are trained on these TAG and HPSG corpora have been presented by Chiang (2000) and Miyao and Tsujii (2005), whereas the LFG parsing system of Cahill et al. (2004) uses a postprocessing step on the output of a Treebank parser to recover predicate&#8211;argument dependencies.</S>
    <S sid="32" ssid="22">In this article we present an algorithmic method for obtaining a corpus of CCG derivations and dependency structures from the Penn Treebank, together with some observations that we believe carry wider implications for similar attempts with other grammar formalisms and corpora.</S>
    <S sid="33" ssid="23">Earlier versions of the resulting corpus, CCGbank, have already been used to build a number of wide-coverage statistical parsers (Clark, Hockenmaier, and Steedman 2002; Hockenmaier and Steedman 2002; Hockenmaier 2003b, 2003a; Clark and Curran 2004, 2007), which recover both local and long-range dependencies directly and in a single pass.</S>
    <S sid="34" ssid="24">CCG is a linguistically expressive, but efficiently parseable, lexicalized grammar formalism that was specifically designed to provide a base-generative account of coordinate and relativized constructions like the following: CCG directly captures the non-local dependencies involved in these and other constructions, including control and raising, via an enriched notion of syntactic types, without the need for syntactic movement, null elements, or traces.</S>
    <S sid="35" ssid="25">It also provides a &#8220;surface-compositional&#8221; syntax&#8211;semantics interface, in which monotonic rules of semantic composition are paired one-to-one with rules of syntactic composition.</S>
    <S sid="36" ssid="26">The corresponding predicate&#8211;argument structure or logical form can therefore be directly obtained from any derivation if the semantic interpretation of each lexical entry is known.</S>
    <S sid="37" ssid="27">In this article and in CCGbank, we approximate such semantic interpretations with dependency graphs that include most semantically relevant non-anaphoric local and long-range dependencies.</S>
    <S sid="38" ssid="28">Although certain decisions taken by the builders of the original Penn Treebank mean that the syntactic derivations that can be obtained from the Penn Treebank are not always semantically correct (as we will discuss), subsequent work by Bos et al. (2004) and Bos (2005) has demonstrated that the output of parsers trained on CCGbank can also be directly translated into logical forms such as Discourse Representation Theory structures (Kamp and Reyle 1993), which can then be used as input to a theorem prover in applications like question answering and textual entailment recognition.</S>
    <S sid="39" ssid="29">Translating the Treebank into this more demanding formalism has revealed certain sources of noise and inconsistency in the original annotation that have had to be corrected in order to permit induction of a linguistically correct grammar.</S>
    <S sid="40" ssid="30">Because of this preprocessing, the dependency structures in CCGbank are likely to be more consistent than those extracted directly from the Treebank via heuristics such as those given by Magerman (1994) and Collins (1999), and therefore may also be of immediate use for dependency-based approaches.</S>
    <S sid="41" ssid="31">However, the structure of certain constructions, such as compound nouns or fragments, is deliberately underspecified in the Penn Treebank.</S>
    <S sid="42" ssid="32">Although we have attempted to semi-automatically restore the missing structure wherever possible, in many cases this would have required additional manual annotation, going beyond the scope of our project.</S>
    <S sid="43" ssid="33">We suspect that these properties of the original Treebank will affect any similar attempt to extract dependency structures or grammars for other expressive formalisms.</S>
    <S sid="44" ssid="34">The Penn Treebank is the earliest (and still the largest) corpus of its kind; we hope that our experiences will extend its useful life, and help in the design of future treebanks.</S>
  </SECTION>
  <SECTION title="2." number="3">
    <S sid="45" ssid="1">Combinatory Categorial Grammar (CCG) was originally developed as a &#8220;near-contextfree&#8221; theory of natural language grammar, with a very free definition of derivational structure adapted to the analysis of coordination and unbounded dependency without movement or deletion transformations.</S>
    <S sid="46" ssid="2">It has been successfully applied to the analysis of coordination, relative clauses and related constructions, intonation structure, binding and control, and quantifier scope alternation, in a number of languages&#8212;see Steedman and Baldridge (2006) for a recent review.</S>
    <S sid="47" ssid="3">Extensions of CCG to other languages and word-orders are discussed by Hoffman (1995), Kang (1995), Bozsahin (1998), Komagata (1999), Steedman (2000), Trechsel (2000), Baldridge (2002), and C&#184; ak&#305;c&#305; (2005).</S>
    <S sid="48" ssid="4">The derivations in CCGbank follow the analyses of Steedman (1996, 2000), except where noted.</S>
    <S sid="49" ssid="5">Categorial Grammars are strongly lexicalized, in the sense that the grammar is entirely defined by a lexicon in which words (and other lexical items) are associated with one or more specific categories which completely define their syntactic behavior.</S>
    <S sid="50" ssid="6">The set of categories consists of basic categories (e.g., S, NP, PP) and complex categories of the form X/Y or X\Y, representing functors with (basic or complex) argument category Y and result category X. Functor categories of the form X/Y expect their argument Y to its right, whereas those of the form X\Y expect Y to their left.2 These functor categories encode subcategorization information, that is, the number and directionality of expected arguments.</S>
    <S sid="51" ssid="7">English intransitive verbs and verb phrases have the category S\NP: they take a (subject) NP to their left as argument and yield a sentence.</S>
    <S sid="52" ssid="8">English transitive verbs have the category (S\NP)/NP: they take an (object) NP to their right to yield a verb phrase (S\NP), which in turn takes a (subject) NP to its left to form a sentence S. Each syntactic category also has a corresponding semantic interpretation (here given as a A-expression).</S>
    <S sid="53" ssid="9">Hence, the lexical entry for ditransitive give can be written as follows:3 In our translation algorithm, we use simple word&#8211;word dependency structures to approximate the underlying semantic interpretation.</S>
    <S sid="54" ssid="10">A universal set of syntactic combinatory rules defines how constituents can be combined.</S>
    <S sid="55" ssid="11">All variants of categorial grammar since Ajdukiewicz (1935) and Bar-Hillel (1953) include function application, where a functor X/Y or X\Y is applied to an argument Y: These rules give rise to derivations like the following:4 This derivation is isomorphic to a traditional context-free derivation tree like the following (the semantics is omitted): CCG additionally introduces a set of rule schemata based on the combinators of combinatory logic (Curry and Feys 1958), which enable succinct analyses of extraction and coordination constructions.</S>
    <S sid="56" ssid="12">It is a distinctive property of CCG that all syntactic rules are purely type-driven, unlike traditional structure-dependent transformations.</S>
    <S sid="57" ssid="13">Composition and substitution allow two functors to combine into another functor, whereas type-raising is a unary rule that exchanges the roles of functor and argument: For example, the following is the derivation of a relative clause related to (4): We will see further examples of their use later.</S>
    <S sid="58" ssid="14">Such rules induce additional derivational ambiguity, even in canonical sentences like (4).</S>
    <S sid="59" ssid="15">However, our translation algorithm yields normal form derivations (Hepple and Morrill 1989; Wittenburg and Wall 1991; K&#168;onig 1994; Eisner 1996), which use composition and type-raising only when syntactically necessary.</S>
    <S sid="60" ssid="16">For coordination, we will use a binarized version of the following ternary rule schema:5 For further explanation and linguistics and computational motivation for this theory of grammar, the reader is directed to Steedman (1996, 2000).</S>
    <S sid="61" ssid="17">The syntactic derivations in CCGbank are accompanied with bilexical head-dependency structures, which are defined in terms of the lexical heads of functor categories and their arguments.</S>
    <S sid="62" ssid="18">The derivation in (6) corresponds to the following dependency structure, which includes the long-range dependency between give and money: The dependency structures in CCGbank are intended to include all non-anaphoric local and long-range dependencies relevant to determining semantic predicate&#8211;argument relations, and hence approximate more fine-grained semantic representations.</S>
    <S sid="63" ssid="19">In this, they differ crucially from the bilexical surface dependencies used by the parsing models of Collins (1999) and Charniak (2000) and returned by the dependency parser of McDonald, Crammer, and Pereira (2005).</S>
    <S sid="64" ssid="20">In order to obtain such non-local dependencies, certain types of lexical category such as relative pronouns or raising and control verbs require additional coindexation information (described subsequently).</S>
    <S sid="65" ssid="21">We believe that CCGbank&#8217;s extensive annotation of non-local predicate&#8211;argument dependencies is one of its most useful features for researchers using other expressive grammar formalisms, including LFG, HPSG, and TAG, facilitating comparisons in terms of error analyses of particular constructions or types of dependency, such as non-subject extracted relative clauses.</S>
    <S sid="66" ssid="22">Because these dependency structures provide a suitable approximation of the underlying semantics, and because each interpretation unambiguously corresponds to one dependency structure (but may be obtained from multiple, equivalent, derivations), we furthermore follow Lin (1998) and Carroll, Minnen, and Briscoe (1999) in regarding them as a fairer, and ultimately more useful, standard against which to evaluate the output of parsers trained on CCGbank than the syntactic derivations themselves.</S>
  </SECTION>
  <SECTION title="3." number="4">
    <S sid="67" ssid="1">The Wall Street Journal subcorpus of the Penn Treebank contains about 50,000 sentences, or 1 million words, annotated with part-of-speech tags and phrase-structure trees: These trees are relatively flat: modals and auxiliaries introduce a new VP level, whereas verb modifiers and arguments typically appear all at the same level, as sisters of the main verb.</S>
    <S sid="68" ssid="2">A similarly flat annotation style is adopted at the sentence level.</S>
    <S sid="69" ssid="3">NPs are flat as well, with all complex modifiers appearing at the same NP level, and compound nouns typically lacking any internal structure.</S>
    <S sid="70" ssid="4">The translation algorithm needs to identify syntactic heads, and has to distinguish between complements and modifiers.</S>
    <S sid="71" ssid="5">In the Treebank, this information is not explicit.</S>
    <S sid="72" ssid="6">Although some non-terminal nodes carry additional function tags, such as -SBJ (subject) or -TMP (temporal modifier), truly problematic cases such as prepositional phrases are often marked with tags such as -CLR (&#8220;closely related&#8221;) or -DIR (&#8220;direction&#8221;), which are not always reliable or consistent indicators that a constituent is a modifier or an argument.</S>
    <S sid="73" ssid="7">The Treebank uses various types of null elements and traces to encode non-local dependencies.</S>
    <S sid="74" ssid="8">These are essential for our algorithm since they make it possible to obtain correct CCG derivations for relative clauses, wh-questions, and coordinate constructions such as right node raising.</S>
    <S sid="75" ssid="9">Their treatment is discussed in Sections 6.2 and 6.3.</S>
  </SECTION>
  <SECTION title="4." number="5">
    <S sid="76" ssid="1">In order to obtain CCG derivations from the Penn Treebank, we need to define a mapping from phrase structure trees to CCG derivations, including a treatment of the null elements in the Treebank.</S>
    <S sid="77" ssid="2">We also need to modify the Treebank where its syntactic analyses differ from CCG, and clean up certain sources of noise that would otherwise result in incorrect CCG derivations.</S>
    <S sid="78" ssid="3">We will begin by ignoring null elements, and assume that Penn Treebank trees are entirely consistent with CCG analyses.</S>
    <S sid="79" ssid="4">The basic algorithm then consists of four steps: Similar algorithms for phrase-structure trees without traces or other null elements have been suggested by Buszkowski and Penn (1990) and Osborne and Briscoe (1998).</S>
    <S sid="80" ssid="5">We illustrate this basic algorithm using the previous example (9).</S>
    <S sid="81" ssid="6">Then we will extend this algorithm to deal with coordination, and introduce a modification to cope with the fact that certain word classes, such as participials, can act as modifiers of a large number of constituent types.</S>
    <S sid="82" ssid="7">Section 5 summarizes the most important preprocessing steps that were necessary to obtain the desired CCG analyses from the Treebank trees.</S>
    <S sid="83" ssid="8">Section 6 extends this basic algorithm to deal with the null elements in the Treebank.</S>
    <S sid="84" ssid="9">First, the constituent type of each node (head (h), complement (c), or adjunct (a)) is determined, using heuristics adapted from Magerman (1994) and Collins (1999), which take the label of a node and its parent into account.6 We assume that NP daughters of VPs are complements, unless they carry a function tag such as -LOC, -DIR, -TMP, and so on, but treat all PPs as adjuncts unless they carry the -CLR function tag.</S>
    <S sid="85" ssid="10">In our example, we therefore treat passing as transitive, even though it should subcategorize for the PP: This binarization process inserts dummy nodes into the tree such that all children to the left of the head branch off in a right-branching tree, and then all children to the right of the head branch off in a left-branching tree.7 We assign CCG categories to the nodes in this binary tree in the following manner: 4.3.1 The Root Node.</S>
    <S sid="86" ssid="11">The category of the root node is determined by the label of the root of the Treebank tree (e.g., {VP} &#8594; S\NP, {S, SINV, SQ} &#8594; S).8 If the root node has the category S, it typically carries a feature that distinguishes different types of sentences, such as declaratives (S[dcl]), wh-questions (S[wq]), yes&#8211;no questions (S[q]), or fragments (S[frg]).</S>
    <S sid="87" ssid="12">In our running example, the root is S[dcl], because its Treebank label is S, and its head word, the auxiliary, has the POS tag VBZ.</S>
    <S sid="88" ssid="13">4.3.2 Head and Complement.</S>
    <S sid="89" ssid="14">The category of a complement child is defined by a similar mapping from Treebank labels to categories, for example, {NP} &#8594; NP, {PP} &#8594; PP.9 The CCG category of the head is a function which takes the category of the complement as argument and returns the category of the parent node.</S>
    <S sid="90" ssid="15">The direction of the slash is given by the position of the complement relative to the head: The VP that is headed by the main verb passing is a complement of the auxiliary.</S>
    <S sid="91" ssid="16">Because the POS tag of passing is VBG, the CCG category of the complement VP is S[ng]\NP (present participle) and the lexical category of is is therefore (S[dcl]\NP)/(S[ng]\NP): is just passing the buck to young people Other VP features include [to] (to infinitival), [b] (bare infinitival), S[pt] (past participle), [pss] (passive), or [ng] (present participle).</S>
    <S sid="92" ssid="17">4.3.3 Head and Adjunct.</S>
    <S sid="93" ssid="18">According to the Treebank annotation and the assumptions of the algorithm, our example has two VP adjuncts: the adverb just, and, because of its -DIR function tag, the PP to young people.</S>
    <S sid="94" ssid="19">In both cases, the adjunct category depends on the category of the parent, and the category of the head child is copied from the parent: Given a parent category C, the category of an adjunct child is a unary functor C'/C' if the adjunct child is to the left of the head child (a premodifier), or C'\C' if it is to the right Function composition reduces the number of lexical categories of adjuncts. of the head (a postmodifier).</S>
    <S sid="95" ssid="20">In most cases, the category C' is equal to the parent category C without any features such as [dcl], [ng], and so forth, and the modifier combines with the head via simple function application.</S>
    <S sid="96" ssid="21">As shown in Figure 1, in many cases, a more elegant (and general) analysis can be obtained if we allow modifiers to compose with the head.</S>
    <S sid="97" ssid="22">For example, regularly has the category (S\NP)\(S\NP) in sentences such as I visit certain places regularly, because it modifies the verb phrase visit certain places, which has the category S[dcl]\NP.</S>
    <S sid="98" ssid="23">But in the corresponding relative clause places that I visit regularly or with heavy NP shift (I visit regularly certain places in Europe), regularly modifies visit, that is, a constituent with category (S[dcl]\NP)/NP.</S>
    <S sid="99" ssid="24">Without function composition, the category of regularly would have to be ((S\NP)/NP)\((S\NP)/NP), but (crossed) composition allows the ordinary category (S\NP)\(S\NP) to also work in this case.</S>
    <S sid="100" ssid="25">Therefore, if the parent (and head) category C is of the form X/$, the algorithm strips off all outermost forward arguments /$ (and syntactic features) from C to obtain C'.</S>
    <S sid="101" ssid="26">Similarly, if C is of the form X\$, all outermost backward arguments \$ (and syntactic features) are stripped off from C to obtain C'.</S>
    <S sid="102" ssid="27">4.3.4 Head and Punctuation Mark.</S>
    <S sid="103" ssid="28">With the exception of some dashes and parentheses (see Section 4), the category of a punctuation mark is identical to its POS tag, and the head has the same category as its parent.</S>
    <S sid="104" ssid="29">4.3.5 The Final Derivation.</S>
    <S sid="105" ssid="30">Figure 2 shows the complete CCG derivation of our example.</S>
    <S sid="106" ssid="31">The category assignment procedure corresponds to a top-down normal-form derivation, which almost always uses function application.</S>
    <S sid="107" ssid="32">In the basic case presented here, composition is only used to provide a uniform analysis of adjuncts.</S>
    <S sid="108" ssid="33">Long-range dependencies represented in the Penn Treebank by traces such as *T* and *RNR* require extensions to the basic algorithm, which result in derivations that make use of typeraising, composition, and (occasionally) substitution rules like those in (5) wherever syntactically necessary.</S>
    <S sid="109" ssid="34">We defer explanation of these rules until Section 6, which presents the constructions that motivate them.</S>
    <S sid="110" ssid="35">Finally, we need to obtain the word&#8211;word dependencies which approximate the underlying predicate&#8211;argument structure.</S>
    <S sid="111" ssid="36">This is done by a bottom-up procedure, which simply retraces the steps in the CCG derivation that we have now obtained.</S>
    <S sid="112" ssid="37">The CCG derivation with corresponding dependencies and dependency graph for example (9).</S>
    <S sid="113" ssid="38">All categories in CCGbank, including results and arguments of complex categories, are associated with a corresponding list of lexical heads.</S>
    <S sid="114" ssid="39">This list can be empty (in the case of yet uninstantiated arguments of functor categories), or it can consist of one or more tokens.</S>
    <S sid="115" ssid="40">Lexical categories have one lexical head, the word itself&#8212;for example, He for the first NP, and is for the (S[dcl]\NP)/(S[b]\NP).</S>
    <S sid="116" ssid="41">All dependencies are defined in terms of the heads of lexical functor categories and of their arguments.</S>
    <S sid="117" ssid="42">In order to distinguish the slots filled by different arguments, we number the arguments of complex lexical categories from left to right in the category notation (that is, from innermost to outermost argument in a purely applicative derivation), for example, (S[ng]\NP1)/NP2, or ((S[b]\NP1)/(S[to]\NP)2)/NP3.</S>
    <S sid="118" ssid="43">In lexical functor categories such as that of the auxiliary, (S[dcl]\NP)/(S[b]\NP), the lexical head of all result categories (S[dcl]\NP and S[dcl]) is identical to the lexical head of the entire category (i.e., is).</S>
    <S sid="119" ssid="44">But in functor categories that represent modifiers, such as the adverb (S\NP)/(S\NP), the head of the result (the modified verb phrase) comes from the argument (the unmodified verb phrase).</S>
    <S sid="120" ssid="45">We use indices on the categories to represent this information: (S\NP)i/(S\NP)i.</S>
    <S sid="121" ssid="46">In CCGbank, modifier categories are easily identified by the fact that they are of the form X|X or (X|X) |... (with  |either / or \), where X does not have any of the features described previously, such as [dcl], [b].</S>
    <S sid="122" ssid="47">Similarly, determiners (the) take a noun (N, buck) as argument to form a (non-bare) noun phrase whose lexical head comes from the noun: NP[nb]i/Ni.</S>
    <S sid="123" ssid="48">Thus, the lexical head of the noun phrase the buck is buck, not the.</S>
    <S sid="124" ssid="49">We also use this coindexation mechanism for lexical categories that project nonlocal dependencies.</S>
    <S sid="125" ssid="50">For instance, the category of the auxiliary, (S[dcl]\NP)/(S[ng]\NP), mediates a dependency between the subject (He) and the main verb (passing).</S>
    <S sid="126" ssid="51">Like all lexical categories of auxiliaries, modals and subject-raising verbs, the head of the subject NP is coindexed with the head of subject inside the VP argument: (S[dcl]\NPi)/(S[ng]\NPi).</S>
    <S sid="127" ssid="52">The set of categories that project such dependencies is not acquired automatically, but is given (as a list of category templates) to the algorithm which creates the actual dependency structures.</S>
    <S sid="128" ssid="53">A complete list of the lexical entries in sections 02&#8211;21 of the Treebank which use this coindexation mechanism to project nonlocal dependencies is given in the CCGbank manual (Hockenmaier and Steedman 2005).</S>
    <S sid="129" ssid="54">We believe that in practice this mechanism is largely correct, even though it is based on the (fundamentally flawed) assumption that all lexical categories that have the same syntactic type project the same dependencies.</S>
    <S sid="130" ssid="55">It may be possible to use the indices on the PRO-null elements (*-1) in the Treebank to identify and resolve ambiguous cases; we leave this to future research.10 Function application and composition typically result in the instantiation of the lexical head of an argument of some functor category, and therefore create new dependencies, whereas coordination creates a new category whose lexical head lists are concatenations of the head lists of the conjuncts.</S>
    <S sid="131" ssid="56">When the (S[ng]\NP1)/NP2 passing is combined with the NP the buck, the lexical head of the NP2 is instantiated with buck.</S>
    <S sid="132" ssid="57">Similarly, when the adverb just (S\NP1)/(S\NP)2 is applied to passing the buck, a dependency between just and passing is created: However, because (S\NP1)/(S\NP)2 is a modifier category, the head of the resulting S[ng]\NP is passing, not just (and no dependency is established between just and its NP1).</S>
    <S sid="133" ssid="58">In the next step, this S[ng]\NP is combined with the auxiliary (S[dcl]\NP1)/(S[ng]\NP)2.</S>
    <S sid="134" ssid="59">The NP in the (S[ng]\NP)2 argument of the auxiliary unifies with the (uninstantiated) NP1 argument of passing.</S>
    <S sid="135" ssid="60">Because the NP in the (S[ng]\NP)2 is also coindexed with the subject NP1 of the auxiliary, the NP of the resulting S[dcl]\NP now has two unfilled dependencies to the subject NP1 of is and passing.</S>
    <S sid="136" ssid="61">When the entire verb phrase is combined with the subject, He fills both slots: Figure 2 shows the resulting CCG derivation and the corresponding list of word&#8211; word dependencies for our example sentence.</S>
    <S sid="137" ssid="62">It is the latter structure that we claim approximates for present purposes the predicate&#8211;argument structure or interpretation of the sentence, and provides the gold standard against which parsers can be evaluated.</S>
    <S sid="138" ssid="63">In order to deal with coordination, both the tree binarization and the category assignment have to be modified.</S>
    <S sid="139" ssid="64">In CCGbank, coordination is represented by the following binary rule schemata, rather than the ternary rule (7)&#8212;compare to Steedman (1989):11 In order to obtain this analysis from Treebank trees, a separate node that spans only the conjuncts and the conjunction or punctuation marks (comma, semicolon) is inserted if necessary.</S>
    <S sid="140" ssid="65">Identifying the conjuncts often requires a considerable amount of preprocessing.</S>
    <S sid="141" ssid="66">These trees are then transformed into strictly right-branching binary trees.</S>
    <S sid="142" ssid="67">The dummy nodes inserted during binarization receive the same category as the conjuncts, but additionally carry a feature [conj]: An additional modification of the grammar is necessary to deal with &#8220;unlike coordinate phrases&#8221; (UCP), namely, coordinate constructions where the conjuncts do not belong to the same syntactic category: Such constructions are difficult for any formalism.</S>
    <S sid="143" ssid="68">This phenomenon could be handled elegantly with a feature hierarchy over categories as proposed by Copestake (2002), Villavicencio (2002), and McConville (2007).</S>
    <S sid="144" ssid="69">Because the induction of such a hierarchy was beyond the scope of our project, we modify our grammar slightly, and allow the algorithm to use instantiations of a special coordination rule schema, such as: This enables us to analyze the previous example as: In CCG, all language-specific information is associated with the lexical categories of words.</S>
    <S sid="145" ssid="70">There are many syntactic regularities associated with word classes, however, which may potentially generate a large number of lexical entries for each item in that class.</S>
    <S sid="146" ssid="71">One particularly frequent example of this is clausal adjuncts.</S>
    <S sid="147" ssid="72">Figure 3 illustrates how the basic algorithm described above leads to a proliferation of adjunct categories.</S>
    <S sid="148" ssid="73">For example, a past participle such as used would receive a different category in a reduced relative like Figure 3(a) from its standard category (S[pss]\NP)/(S[to]\NP).</S>
    <S sid="149" ssid="74">As a consequence, modifiers of used would also receive different categories depending on what occurrence of used they modify.</S>
    <S sid="150" ssid="75">This is undesirable, because we are only guaranteed to acquire a complete lexicon if we have seen all participles (and their possible modifiers) in all their possible surface positions.</S>
    <S sid="151" ssid="76">Similar regularities have been recognized and given a categorial analysis by Carpenter (1992), who advocates lexical rules to account for the use of predicatives as adjuncts.</S>
    <S sid="152" ssid="77">In a statistical model, the parameters for such lexical rules are difficult to estimate.</S>
    <S sid="153" ssid="78">We therefore follow the approach of Aone and Wittenburg (1990) and implement these type-changing Type-changing rules reduce the number of lexical category types required for complex adjuncts. operations in the derivational syntax, where these generalizations are captured in a few rules.</S>
    <S sid="154" ssid="79">If these rules apply recursively to their own output, they can generate an infinite set of category types, leading to a shift in generative power from context-free to recursively enumerable (Carpenter 1991, 1992).</S>
    <S sid="155" ssid="80">Like Aone and Wittenburg, we therefore consider only a finite number of instantiations of these type-changing rules, namely those which arise when we extend the category assignment procedure in the following way: For any sentential or verb phrase modifier (an adjunct with label S or SBAR with null complementizer, or VP) to which the original algorithm assigns category X|X, apply the following type-changing rule (given in bottom-up notation) in reverse: where S$ is the category that this constituent obtains if it is treated like a head node by the basic algorithm.</S>
    <S sid="156" ssid="81">S$ has the appropriate verbal features, and can be S\NP or S/NP.</S>
    <S sid="157" ssid="82">Some of the most common type-changing rules are the following, for various types of reduced relative modifier: Hockenmaier and Steedman CCGbank In order to obtain the correct predicate&#8211;argument structure, the heads of corresponding arguments in the input and output category are unified (as indicated by coindexation).</S>
    <S sid="158" ssid="83">In written English, certain types of NP-extraposition require a comma before or after the extraposed noun phrase: Factories booked $236.74 billion in orders in September, [NP nearly the same (18) as the $236.79 billion in August] Because any predicative noun phrase could be used in this manner, this construction is also potentially problematic for the coverage of our grammar and lexicon.</S>
    <S sid="159" ssid="84">However, the fact that a comma is required allows us to use a small number of binary type-changing rules (which do not project any dependencies), such as:</S>
  </SECTION>
  <SECTION title="5." number="6">
    <S sid="160" ssid="1">The translation algorithm presumes that the trees in the Penn Treebank map directly to the desired CCG derivations.</S>
    <S sid="161" ssid="2">However, this is not always the case, either because of noise in the Treebank annotation, differences in linguistic analysis, or because CCG, like any other expressive linguistic formalism, requires information that is not present in the Treebank analysis.</S>
    <S sid="162" ssid="3">Before translation, a number of preprocessing steps are therefore required.</S>
    <S sid="163" ssid="4">Disregarding the most common preprocessing step (the insertion of a noun level, which is required in virtually all sentences), preprocessing affects almost 43% of all sentences.</S>
    <S sid="164" ssid="5">Here we summarize the most important preprocessing steps for those constructions that do not involve non-local dependencies.</S>
    <S sid="165" ssid="6">Preprocessing steps required for constructions involving non-local dependencies (i.e., traces or null elements in the Treebank) are mentioned in Section 6.</S>
    <S sid="166" ssid="7">Remaining problems are discussed in Section 7.</S>
    <S sid="167" ssid="8">More detailed and complete descriptions can be found in the CCGbank manual.</S>
    <S sid="168" ssid="9">Annotation errors and inconsistencies in the Treebank affect the quality of any extracted grammar or lexicon.</S>
    <S sid="169" ssid="10">This is especially true for formalisms with an extended domain of locality, such as TAG or CCG, where a single elementary tree or lexical category may contain information that is distributed over a number of distinct phrase-structure rules.</S>
    <S sid="170" ssid="11">Part-of-Speech Tagging Errors.</S>
    <S sid="171" ssid="12">Ratnaparkhi (1996) estimates a POS tagging error rate of 3% in the Treebank.</S>
    <S sid="172" ssid="13">The translation algorithm is sensitive to these errors and inconsistencies, because POS tagging errors can lead to incorrect categories or to incorrect features on verbal categories (e.g., when a past participle is wrongly tagged as past tense).</S>
    <S sid="173" ssid="14">For instance, if a simple past tense form occurs in a verb phrase which itself is the daughter of a verb phrase whose head is an inflected verb, it is highly likely that it should be a past participle instead.</S>
    <S sid="174" ssid="15">Using the verb form itself and the surrounding context, we have attempted to correct such errors automatically.</S>
    <S sid="175" ssid="16">In 7% of all sentences, our algorithm modifies at least one POS tag.</S>
    <S sid="176" ssid="17">Quotation Marks.</S>
    <S sid="177" ssid="18">Although not strictly coming under the heading of noise, quotation marks cause a number of problems for the translation algorithm.</S>
    <S sid="178" ssid="19">Although it is tempting to analyze them similarly to parentheticals, quotations often span sentence boundaries, and consequently quotation marks appear to be unbalanced at the sentence level.</S>
    <S sid="179" ssid="20">We therefore decided to eliminate them during the preprocessing stage.</S>
    <S sid="180" ssid="21">Unlike a hand-written grammar, the grammar that is implicit in a treebank has to cover all constructions that occur in the corpus.</S>
    <S sid="181" ssid="22">Expressive formalisms such as CCG provide explicit analyses that contain detailed linguistic information.</S>
    <S sid="182" ssid="23">For example, CCG derivations assign a lexical head to every constituent and define explicit functor&#8211;argument relations between constituents.</S>
    <S sid="183" ssid="24">In a phrase-structure grammar, analyses can be much coarser, and may omit more fine-grained structures if they are assumed to be implicit in the given analysis.</S>
    <S sid="184" ssid="25">Furthermore, constructions that are difficult to analyze do not need to be given a detailed analysis.</S>
    <S sid="185" ssid="26">In both cases, the missing information has to be added before a Treebank tree can be translated into CCG.</S>
    <S sid="186" ssid="27">If the missing structure is implicit in the Treebank analysis, this step is relatively straightforward, but constructions such as parentheticals, multiword expressions, and fragments require careful reanalysis in order to avoid lexical coverage problems and overgeneration.</S>
    <S sid="187" ssid="28">Detecting Coordination.</S>
    <S sid="188" ssid="29">Although the Treebank does not explicitly indicate coordination, it can generally be inferred from the presence of a conjunction.</S>
    <S sid="189" ssid="30">However, in list-like nominal coordinations, the conjuncts are only separated by commas or semicolons, and may be difficult to distinguish from appositives.</S>
    <S sid="190" ssid="31">There are also a number of verb-phrase or sentential coordinations in the Treebank where shared arguments or modifiers simply appear at the same level as conjuncts and the conjunction:12 In CCG, the conjuncts and conjunction form a separate constituent.</S>
    <S sid="191" ssid="32">In 1.8% of all sentences, additional preprocessing is necessary to obtain this structure.</S>
    <S sid="192" ssid="33">Noun Phrases and Quantifier Phrases.</S>
    <S sid="193" ssid="34">In the Penn Treebank, non-recursive noun phrases have remarkably little internal structure: (NP (DT the) (NNP Dutch) (VBG publishing) (NN group)) (20) Some, but not all, of the structure that is required to obtain a linguistically adequate analysis can be inferred (semi-)automatically.</S>
    <S sid="194" ssid="35">The CCGbank grammar distinguishes noun phrases, NP, from nouns, N, and treats determiners (the) as functions from nouns Hockenmaier and Steedman CCGbank to noun phrases (NP[nb]/N).</S>
    <S sid="195" ssid="36">Therefore, we need to insert an additional noun level, which also includes the adjuncts Dutch and publishing, which receive both the category N/N: However, because nominal compounds in the Treebank have no internal bracketing, we always assume a right-branching analysis, and are therefore not able to obtain the correct dependencies for cases such as (lung cancer) deaths.</S>
    <S sid="196" ssid="37">QPs (&#8220;quantifier phrases&#8221;) are another type of constituent where the Treebank annotation lacks internal structure: We use a number of heuristics to identify the internal structure of these constituents&#8212; for example, to detect conjuncts and prepositions.</S>
    <S sid="197" ssid="38">The above example is then re-bracketed: Fragments.</S>
    <S sid="198" ssid="39">1.24% of the sentences in the Penn Treebank correspond to or contain fragmentary utterances (labeled FRAG), for which no proper analysis could be given: FRAGs are often difficult to analyze, and the annotation is not very consistent.</S>
    <S sid="199" ssid="40">The CCGbank manual lists heuristics that we used to infer additional structure.</S>
    <S sid="200" ssid="41">For example, if a node is labeled FRAG, and there is only one daughter (and potentially an end-of-sentence punctuation mark), as in the first example, we treat the tree as if it was labeled with the label of its daughter (NP in this case).</S>
    <S sid="201" ssid="42">Parentheticals.</S>
    <S sid="202" ssid="43">Parentheticals are insertions that are often enclosed in parentheses, or preceded by a dash.</S>
    <S sid="203" ssid="44">Unless the parenthetical element itself is of a type that could be a modifier by itself (e.g., a PP), we assume that the opening parenthesis or first dash takes the parenthetical element as argument and yields a modifier of the appropriate type: (NP (NP the third-highest) (PP-LOC in the developing world))) This results in the following derivation, which ignores the fact that parentheses are usually balanced (Nunberg 1990): &#8211; the third-highest in the developing world We use a similar treatment for other constituents that appear after colons and dashes, such as sentence-final appositives, or parentheticals that are not marked as PRN.</S>
    <S sid="204" ssid="45">Overall, these changes affect 8.7% of all sentences.</S>
    <S sid="205" ssid="46">Multi-Word Expressions.</S>
    <S sid="206" ssid="47">Under the assumption that every constituent has a lexical head that corresponds to an individual orthographic word, multi-word expressions require an analysis where one of the items subcategorizes for a specific syntactic type that can only correspond to the other lexical item.</S>
    <S sid="207" ssid="48">We only attempted an analysis for expressions that are either very frequent or where the multi-word expression has a different subcategorization behavior from the head word of the expression.</S>
    <S sid="208" ssid="49">This includes some closed-class items (described in the CCGbank manual), including connectives (e.g., as if, as though, because of ), comparatives (so ADJ that, too ADJ to, at least/most/... X), monetary expressions, and dates, affecting 23.8% of all sentences.</S>
    <S sid="209" ssid="50">Additionally, there are a number of constructions whose Treebank annotation differs from the standard CCG analysis for linguistic reasons.</S>
    <S sid="210" ssid="51">This includes small clauses, as well as pied-piping, subject extraction from embedded sentences and argument cluster coordination (discussed in Section 6).</S>
    <S sid="211" ssid="52">Small Clauses.</S>
    <S sid="212" ssid="53">The Treebank treats constructions such as the following as small clauses: Pollard and Sag (1992) and Steedman (1996) argue against this analysis on the basis of extractions like what does the country want forgiven, which suggest that these cases should rather be treated as involving two complements.</S>
    <S sid="213" ssid="54">We eliminate the small clause, and transform the trees such that the verb takes both NP children of the small clause as complements, thereby obtaining the lexical category ((S[dcl]\NP)/NP)/NP for makes.</S>
    <S sid="214" ssid="55">Because our current grammar treats predicative NPs like ordinary NPs, we are not able to express the relationship between it and supplier, or between pool and hostage.</S>
    <S sid="215" ssid="56">A correct analysis would assign a functor category S[nom]\NP (or perhaps NP[prd]\NP) to predicative NP arguments of verbs like makes, not only in these examples, but also in copular sentences and appositives.</S>
    <S sid="216" ssid="57">The other case where small clauses are used in the Treebank includes absolute with and though constructions (with the limit in effect).</S>
    <S sid="217" ssid="58">Here, we also assume that the subordinating conjunction takes the individual constituents in the small clause as complements, and with obtains therefore the category ((S/S)/PP)/NP.</S>
    <S sid="218" ssid="59">Again, a predicative analysis of the PP might be desirable in order to express the dependencies between limit and in effect.</S>
    <S sid="219" ssid="60">Eliminating small clauses affects 8.2% of sentences.</S>
  </SECTION>
  <SECTION title="6." number="7">
    <S sid="220" ssid="1">The treatment of non-local dependencies is one of the most important points of difference between grammar formalisms.</S>
    <S sid="221" ssid="2">The Treebank uses a large inventory of null element types and traces, including coindexation to represent long-range dependencies.</S>
    <S sid="222" ssid="3">Hockenmaier and Steedman CCGbank Because standard Treebank parsers use probabilistic versions of context-free grammar, they are generally trained and tested on a version of the Treebank in which these null elements and indices are deleted or ignored, or, in the case of Collin&#8217;s (1999) Model 3, only partially captured.</S>
    <S sid="223" ssid="4">Non-local dependencies are therefore difficult to recover from their output.</S>
    <S sid="224" ssid="5">In CCG, long-range dependencies are represented without null elements or traces, and coindexation is restricted to arguments of the same lexical functor category.</S>
    <S sid="225" ssid="6">Although this mechanism is less expressive than the potentially unrestricted coindexation used in the Treebank, it allows parsers to recover non-anaphoric long-range dependencies directly, without the need for further postprocessing or trace insertion.</S>
    <S sid="226" ssid="7">Passive.</S>
    <S sid="227" ssid="8">In the Treebank, the surface subject of a passive sentence is coindexed with a &#8727; null element in direct object position: Our translation algorithm uses the presence of the &#8727; null element to identify passive mode, but ignores it otherwise, assigning the CCG category S[pss]\NP to noted.13 The dependency between the subject and the participial is mediated through the lexical category of the copula, (S[dcl]\NPi)/(S[pss]\NPi) (with the standard semantics apax.px).14 In order to reduce lexical ambiguity and deal with data sparseness, we treat optional by-PPs which contain the &#8220;logical&#8221; subject (NP-LGS) as adjuncts rather than arguments of the passive participle.15 Here is the resulting CCG derivation, together with its dependency structure: 13 In the case of verbs like pay for, which take a PP argument, the null element appears within the PP.</S>
    <S sid="228" ssid="9">In order to obtain the correct lexical category of paid, (S[pss]\NP)/(PP/NP), we treat the null element like an argument of the preposition and percolate it up to the PP level.</S>
    <S sid="229" ssid="10">14 We assume that the fact that the subject NP argument of passive participials with category S[pss]\NP identifies the patient, rather than agent, is represented in the semantic interpretation of noted, for example, ax.noted'x one, where one&#8217; is simply a placeholder for a bindable argument, like the relational grammarians&#8217; ch&#710;omeur relation.</S>
    <S sid="230" ssid="11">15 Extractions such as Who was he paid by require the by-PP to be treated as an argument, and it would in fact be better to use a lexical rule to generate (S[pss]\NP)/PP[by] from S[pss]\NP and vice versa.</S>
    <S sid="231" ssid="12">Infinitival and Participial VPs, Gerunds.</S>
    <S sid="232" ssid="13">In the Treebank, participial phrases, gerunds, imperatives, and to-VP arguments are annotated as sentences with a &#8727; null subject: We treat these like verb phrases (S\NP) with the appropriate feature ([b], [to], [ng], or [pt]), depending on the part-of-speech tag of the verb.</S>
    <S sid="233" ssid="14">Control and Raising.</S>
    <S sid="234" ssid="15">CCGbank does not distinguish between control and raising.</S>
    <S sid="235" ssid="16">In the Treebank, subject-control and subject-raising verbs (e.g., want and seem) also take an S complement with a null subject that is coindexed with the subject of the main clause: We ignore the coindexation in the Treebank, and treat all control verbs as non-arbitrary control.</S>
    <S sid="236" ssid="17">As indicated by the index i, we assume that all verbs which subcategorize for a verb phrase complement and take no direct object mediate a dependency between their subject and their complement.</S>
    <S sid="237" ssid="18">Because the copula and to mediate similar dependencies between their subjects and complements, but do not fill their own subject dependencies, Japanese has the following dependencies: In the Treebank, object-raising verbs (wants half the debt forgiven) take a small clause argument with non-empty subject.</S>
    <S sid="238" ssid="19">Following our treatment of small clauses (see Section 5.3) we modify this tree so that we obtain the lexical category (((S[dcl]\NP)/(S[pss]\NPi))/NPi) for wanted, which mediates the dependency between debt and forgiven.16 Extraposition of Appositives.</S>
    <S sid="239" ssid="20">Appositive noun phrases can be extraposed out of a sentence or verb phrase, resulting in an anaphoric dependency.</S>
    <S sid="240" ssid="21">The Penn Treebank analyzes these as adverbial small clauses with a coindexed null subject: We also treat these appositives as sentential modifiers.</S>
    <S sid="241" ssid="22">However, the corresponding CCG derivation deliberately omits the dependency between dummies and drivers:17 This derivation uses one of the special binary type-changing rules (see Section 4.6) that takes into account that these appositives can only occur adjacent to commas.</S>
    <S sid="242" ssid="23">The Penn Treebank analyzes wh-questions, relative clauses, topicalization of complements, tough movement, cleft, and parasitic gaps in terms of movement.</S>
    <S sid="243" ssid="24">These constructions are frequent: The entire Treebank contains 16,056 *T* traces, including 8,877 NP traces, 4,120 S traces, 2,465 ADVP traces, 422 PP traces, and 210 other *T* traces.</S>
    <S sid="244" ssid="25">Sections 02&#8211;21 (39,604 sentences) contain 5,288 full subject relative clauses, as well as 459 full and 873 reduced object relative clauses.</S>
    <S sid="245" ssid="26">The dependencies involved in these constructions, however, are difficult to obtain from the output of standard parsers such as Collins (1999) or Charniak (2000), and require additional postprocessing that may introduce further noise and errors.</S>
    <S sid="246" ssid="27">In those cases where the trace corresponds to a &#8220;moved&#8221; argument, the corresponding long-range dependencies can be recovered directly from the correct CCG derivation.</S>
    <S sid="247" ssid="28">In the Treebank, the &#8220;moved&#8221; constituent is coindexed with a trace (*T*), which is inserted at the extraction site: 17 We regard this type of dependency as anaphoric rather than syntactic, on the basis of its immunity to such syntactic restrictions as subject islands.</S>
    <S sid="248" ssid="29">CCG has a similarly uniform analysis of these constructions, albeit one that does not require syntactic movement.</S>
    <S sid="249" ssid="30">In the CCG derivation of the example, the relative pronoun has the category (NPi\NPi)/(S[dcl]/NPi) whereas the verb bought just bears the standard transitive category (S[dcl]\NP)/NP.</S>
    <S sid="250" ssid="31">The subject NP and the incomplete VP combine via type-raising and forward composition into an S[dcl]/NP, which the relative pronoun then takes as its argument: The coindexation on the lexical category of the relative pronoun guarantees that the missing object unifies with the modified NP, and we obtain the desired dependencies: This analysis of movement in terms of functors over incomplete constituents allows CCG to use the same category for the verb when its arguments are extracted as when they are in situ.</S>
    <S sid="251" ssid="32">This includes not only relative clauses and wh-questions, but also piedpiping, tough movement, topicalization, and clefts.</S>
    <S sid="252" ssid="33">For our translation algorithm, the *T* traces are essential: They indicate the presence of a long-range dependency for a particular argument of the verb, and allow us to use a mechanism similar to GPSG&#8217;s slash-feature passing (Gazdar et al. 1985), so that long-range dependencies are represented in the gold-standard dependency structures of the test and training data.</S>
    <S sid="253" ssid="34">This is crucial to correctly inducing and evaluating grammars and parsers for any expressive formalism, including TAG, GPSG, HPSG, LFG, and MPG.</S>
    <S sid="254" ssid="35">A detailed description of this mechanism and of our treatment of other constructions that use *T* traces can be found in the CCGbank manual.</S>
    <S sid="255" ssid="36">This algorithm works also if there is a coordinate structure within the relative clause such that there are two *T* traces (the interest rates they pay *T* on their deposits and charge *T* on their loans), resulting in the following long-range dependencies: that the verb takes the VP and the NP argument in reversed order and change the tree accordingly before translation, resulting in the correct CCG analysis: We obtain the following long-range dependencies: Because our grammar does not use Baldridge&#8217;s (2002) modalities or Steedman&#8217;s (1996) equivalent rule-based restrictions, which prohibit this category from applying to in situ NPs, this may lead to overgeneralization.</S>
    <S sid="256" ssid="37">However, such examples are relatively frequent: There are 97 instances of ((S[.</S>
    <S sid="257" ssid="38">]\NP)/NP)/(S[dcl]\NP) in sections 02&#8211;21, and to omit this category would reduce coverage and recovery of long-range extractions.</S>
    <S sid="258" ssid="39">By percolating the *T* trace up to the SQ-level in a similar way to relative clauses and treating Which as syntactic head of the WHNP, we obtain the desired CCG analysis: We coindex the head of the extracted NP with that of the noun (cars): (S[wq]/(S[q]/ NPi))/Ni, and the subject of do with the subject of its complement ((S[q]/(S[b]\NP1))/NPi) to obtain the following dependencies: In this example, we need to rebracket the Treebank tree so that details of forms a constituent,18 apply a special rule to assign the category (NP\NP)/NP to the preposition, and combine it via type-raising and composition with details.</S>
    <S sid="259" ssid="40">This constituent is then treated as an argument of the relative pronoun: With appropriate coindexation ((NP\NPi)/(S[dcl]\NPj))\(NP/NPi)j, we obtain the following non-local dependencies:19 Because adjuncts generally do not extract unboundedly,20 the corresponding traces (which account for 20% of all *T* traces) can be ignored by the translation procedure.</S>
    <S sid="260" ssid="41">Instead, the dependency between when and dropped is directly established by the fact that dropped is the head of the complement S[dcl]: wh-extraction, which use the same lexical categories as for in situ complements, they also provide an analysis of right node raising constructions without introducing any new lexical categories.</S>
    <S sid="261" ssid="42">In the Treebank analysis of right node raising, the shared constituent is coindexed with two *RNR* traces in both of its canonical positions: We need to alter the translation algorithm slightly to deal with *RNR* traces in a manner essentially equivalent to the earlier treatment of *T* wh-traces.</S>
    <S sid="262" ssid="43">Details are in the CCGbank manual.</S>
    <S sid="263" ssid="44">The CCG derivation for the above example is as follows: The right node raising dependencies are as follows: Our algorithm works also if the shared constituent is an adjunct, or if two conjoined noun phrases share the same head, which is also annotated with *RNR* traces.</S>
    <S sid="264" ssid="45">Although there are only 209 sentences with *RNR* traces in the entire Treebank, right node raising is actually far more frequent, because *RNR* traces are not used when the conjuncts consist of single verb tokens.</S>
    <S sid="265" ssid="46">The Treebank contains 349 VPs in which a verb form (/VB/) is immediately followed by a conjunction (CC) and another verb form, and has an NP sister (without any coindexation or function tag).</S>
    <S sid="266" ssid="47">In CCGbank, sections 02&#8211;21 alone contain 444 sentences with verbal or adjectival right node raising.</S>
    <S sid="267" ssid="48">Right node raising is also marked in the Penn Treebank using *RNR* traces for &#8220;parasitic gap&#8221; constructions such as the following: These sentences require rules based on the substitution combinator S (Steedman 1996).</S>
    <S sid="268" ssid="49">Our treatment of right node raising traces deals with the first case correctly, via the backward crossing rule &lt;S&#215;, and allows us to obtain the following correct dependencies: The second type of parasitic gap, (44b), would be handled equally correctly by the forward substitution rule &gt;S, since the PPs are both arguments.</S>
    <S sid="269" ssid="50">Unfortunately, as we saw in Section 3, the Treebank classifies such PPs as directional adverbials, hence we translate them as adjuncts and lose such examples, of which there are at least three more, all also involving from and to: As in the case of leftward extraction, including such long-range dependencies in the dependency structure is crucial to correct induction and evaluation of all expressive grammar formalisms.</S>
    <S sid="270" ssid="51">Although no leftward-extracting parasitic gaps appear to occur in the Treebank, our grammar and model predicts examples like the following, and will cover them when encountered: Conflict which the system was held to cause, rather than resolve.</S>
    <S sid="271" ssid="52">(47) 6.4.1 Argument Cluster Coordination.</S>
    <S sid="272" ssid="53">If two VPs with the same head are conjoined, the second verb can be omitted.</S>
    <S sid="273" ssid="54">The Treebank encodes these constructions as a VPcoordination in which the second VP lacks a verb.</S>
    <S sid="274" ssid="55">The daughters of the second conjunct are coindexed with the corresponding elements in the first conjunct using a = index: In the CCG account of this construction, $5 million right away and additional amounts in the future form constituents (&#8220;argument clusters&#8221;), which are then coordinated.</S>
    <S sid="275" ssid="56">These constituents are obtained by type-raising and composing the arguments in each conjunct, yielding a functor which takes a verb with the appropriate category to its left to yield a verb phrase (Dowty 1988; Steedman 1985).</S>
    <S sid="276" ssid="57">Then the argument clusters are conjoined, and combine with the verb via function application:21 This construction is one in which the CCGbank head-dependency structure (shown subsequently) fails to capture the full set of predicate&#8211;argument structure relations that would be implicit in a full logical form: That is, the dependency structure does not express the fact that right away takes scope over $5 million and in future over additional amounts, rather than the other way around.</S>
    <S sid="277" ssid="58">However, this information is included in the full surface-compositional semantic interpretation that is built by the combinatory rules.</S>
    <S sid="278" ssid="59">Because the Treebank constituent structure does not correspond to the CCG analysis, we need to transform the tree before we can translate it.</S>
    <S sid="279" ssid="60">During preprocessing, we create a copy of the entire argument cluster which corresponds to the constituent structure of the CCG analysis.</S>
    <S sid="280" ssid="61">During normal category assignment, we use the first conjunct in its original form to obtain the correct categories of all constituents.</S>
    <S sid="281" ssid="62">In a later stage, we use type-raising and composition to combine the constituents within each argument cluster.</S>
    <S sid="282" ssid="63">For a detailed description of this algorithm and a number of variations on the original Treebank annotation that we did not attempt to deal with, the interested reader is referred to the CCGbank manual.</S>
    <S sid="283" ssid="64">There are 226 instances of argument-cluster coordination in the entire Penn Treebank.</S>
    <S sid="284" ssid="65">The algorithm delivers a correct CCG derivation for 146 of these.</S>
    <S sid="285" ssid="66">Translation failures are due to the fact that the algorithm can at present only deal with this construction if the two conjuncts are isomorphic in structure, which is not always the case.</S>
    <S sid="286" ssid="67">This is unfortunate, because CCG is particularly suited for this construction.</S>
    <S sid="287" ssid="68">However, we believe that it would be easier to manually reannotate those sentences that are not at present translated than to try to adapt the algorithm to deal with all of them individually.</S>
    <S sid="288" ssid="69">(PP-CLR=2 to the general manager))) This construction cannot be handled with the standard combinatory rules of CCG that are assumed for English.</S>
    <S sid="289" ssid="70">Instead, Steedman (2000) proposes an analysis of gapping that uses a unification-based &#8220;decomposition&#8221; rule.</S>
    <S sid="290" ssid="71">Categorial decomposition allows a category type to be split apart into two subparts, and is used to yield an analysis of gapping that is very similar to that of argument cluster coordination:22 22 It is only the syntactic types that are decomposed or recovered in this way: the corresponding semantic entities and in particular the interpretation for the gapped verb group can talk must be available from the left conjunct&#8217;s information structure, via anaphora.</S>
    <S sid="291" ssid="72">That is, decomposition adds very little to the categorial information available from the right conjunct, except to make the syntactic types yield an S. The real work is done in the semantics.</S>
    <S sid="292" ssid="73">Because the derivation is not a tree anymore, and the decomposed constituents do not correspond to actual constituents in the surface string, this analysis is difficult to represent in a treebank.</S>
    <S sid="293" ssid="74">The 107 sentences that contain sentential gapping are therefore omitted in the current version of CCGbank, even though special coordination rules that mimic the decomposition analysis are conceivable.</S>
    <S sid="294" ssid="75">Besides the cases discussed herein, the Treebank contains further kinds of null elements, all of which the algorithm ignores.</S>
    <S sid="295" ssid="76">The null element *ICH* (&#8220;Insert Constituent Here&#8221;), which appears 1,240 times, is used for extraposition of modifiers.</S>
    <S sid="296" ssid="77">Like ellipsis, this is a case of a semantic dependency which we believe to be anaphoric, and therefore not reflected in the syntactic category.</S>
    <S sid="297" ssid="78">For this reason we treat any constituent that is coindexed with an *ICH* as an adjunct.</S>
    <S sid="298" ssid="79">The null element *PPA* (&#8220;Permanent Predictable Ambiguity,&#8221; 26 occurrences) is used for genuine attachment ambiguities.</S>
    <S sid="299" ssid="80">Since the Treebank manual states that the actual constituent should be attached at the more likely attachment site, we chose to ignore any *PPA* null element.</S>
    <S sid="300" ssid="81">Our algorithm also ignores the null element *?</S>
    <S sid="301" ssid="82">*, which occurs 582 times, and indicates &#8220;a missing predicate or a piece thereof&#8221; (Marcus, Santorini, and Marcinkiewicz 1993).</S>
    <S sid="302" ssid="83">It is used for VP ellipsis, and can also occur in conjunction with a VP pro-form do (You either believe he can do it or you don&#8217;t *?</S>
    <S sid="303" ssid="84">*), or in comparatives (the total was far higher than expected *?</S>
    <S sid="304" ssid="85">*).23 We can now define the complete translation algorithm, including the modifications necessary to deal with traces and argument clusters: 23 We believe that both conjuncts in the first example are complete sentences which are related anaphorically.</S>
    <S sid="305" ssid="86">Therefore, the syntactic category of do is S[dcl]\NP, not (S[dcl]\NP)/VP.</S>
    <S sid="306" ssid="87">In the second example, *?</S>
    <S sid="307" ssid="88">* indicates a semantic argument of expected that we do not reflect in the syntactic category.</S>
    <S sid="308" ssid="89">The successive steps have the following more detailed character: preprocessTree: Correct tagging errors, ensure the constituent structure conforms to the CCG analysis.</S>
    <S sid="309" ssid="90">Eliminate quotes.</S>
    <S sid="310" ssid="91">Create copies of coordinated argument clusters that correspond to the CCG analysis. determineConstituentTypes: For each node, determine its constituent type (head, complement, adjunct, conjunction, a constituent that is coindexed with a *RNR* trace, spurious null element, or argument cluster). makeBinary: Binarize the tree. percolateTraces: Determine the CCG category of *T* and *RNR* traces in complement position, and percolate them up to the appropriate level in the tree. assignCategories: Assign CCG categories to nodes in the tree, starting at the root node.</S>
    <S sid="311" ssid="92">Nodes that are coindexed with *RNR* traces receive the category of the corresponding traces.</S>
    <S sid="312" ssid="93">Argument clusters are ignored in this step. treatArgumentClusters: Assign categories to argument clusters. cutTracesAndUnaryRules: Cut out constituents that are not part of the CCG derivation, such as traces, null elements, and the copy of the first conjunct in argument cluster coordination.</S>
    <S sid="313" ssid="94">Eliminate resulting unary projections of the form X &#8658; X. verifyDerivation: Discard those trees for which the algorithm does not produce a valid CCG derivation.</S>
    <S sid="314" ssid="95">In most cases, this is due to argument cluster coordination that is not annotated in a way that our algorithm can deal with. assignDependencies: coindex specific classes of lexical categories to project non-local dependencies, and generate the word&#8211;word dependencies that constitute the underlying predicate&#8211;argument structure.</S>
  </SECTION>
  <SECTION title="7." number="8">
    <S sid="315" ssid="1">In a number of cases, missing structure or a necessary distinction between different constructions needed to inform the translation is missing, and cannot be inferred deterministically from the Treebank analysis without further manual re-annotation.</S>
    <S sid="316" ssid="2">We discuss these residual problems here, because they are likely to present obstacles to the extraction of linguistically adequate grammars in any formalism.</S>
    <S sid="317" ssid="3">Our translation algorithm requires a distinction between complements and adjuncts.</S>
    <S sid="318" ssid="4">In many cases, this distinction is easily read off the Treebank annotation, but it is in general an open linguistic problem (McConnell-Ginet 1982).</S>
    <S sid="319" ssid="5">Because the Treebank annotation does not explicitly distinguish between complements and adjuncts, researchers typically develop their own heuristics&#8212;see, for example, Kinyon and Prolo (2002).</S>
    <S sid="320" ssid="6">For prepositional phrases, we rely on the -CLR (&#8220;closely related&#8221;) function tag to identify complements, although it is unclear whether the Treebank annotators were able to use this tag consistently.</S>
    <S sid="321" ssid="7">Not all PP arguments seem to have this function tag, and some PPs that have this tag may have been better considered adjuncts: For TAG, Chen, Bangalore, and Vijay-Shanker (2006) show that different heuristics yield grammars that differ significantly in size, coverage, and linguistic adequacy.</S>
    <S sid="322" ssid="8">We have not attempted such an investigation.</S>
    <S sid="323" ssid="9">In a future version of CCGbank, it may be possible to follow Shen and Joshi (2005) in using the semantic roles of the Proposition Bank (Palmer, Gildea, and Kingsbury 2005) to distinguish arguments and adjuncts.</S>
    <S sid="324" ssid="10">Particle-verb constructions are difficult to identify in the Treebank, because particles can be found as PRT, ADVP-CLR, and ADVP.</S>
    <S sid="325" ssid="11">Therefore, verbs in the CCGbank grammar do not subcategorize for particles, which are instead treated as adverbial modifiers.</S>
    <S sid="326" ssid="12">Compound nouns are often inherently ambiguous, and in most cases, the Treebank does not specify their internal structure: In order to obtain the correct analysis, manual re-annotation would be required.</S>
    <S sid="327" ssid="13">Because this was not deemed feasible within our project, compound nouns are simply translated into strictly right-branching binary trees, which yields the correct analysis in some, but not all, cases.</S>
    <S sid="328" ssid="14">This eschews the computational problem that a grammar for compound nouns induces all possible binary bracketings, but is linguistically incorrect.</S>
    <S sid="329" ssid="15">A similar problem arises in compound nouns that involve internal coordination: We include the following (linguistically incorrect) rule in our grammar, which yields a default dependency structure corresponding to N/N coordination: conj N &#8658; N (56) This rule allows us to translate the above tree as follows: N/N cotton N N conj and N N fibers The Treebank markup of NP appositives is indistinguishable from that of NP lists: Therefore, our current grammar does not distinguish between appositives and NP coordination, even though appositives should be analyzed as predicative modifiers.</S>
    <S sid="330" ssid="16">This leads to a reduction of ambiguity in the grammar, but is semantically incorrect: Our current grammar does not implement number agreement (which is, however, represented in the POS tags).</S>
    <S sid="331" ssid="17">One problem that prevented us from including number agreement is the above-mentioned inability to distinguish NP lists and appositives.</S>
    <S sid="332" ssid="18">In the Penn Treebank, all relative clauses are attached at the noun phrase level.</S>
    <S sid="333" ssid="19">This is semantically undesirable, because a correct interpretation of restrictive relative clauses can only be obtained if they modify the noun, whereas non-restrictive relative clauses are noun phrase modifiers.</S>
    <S sid="334" ssid="20">Because this distinction requires manual inspection on a caseby-case basis, we were unable to modify the Treebank analysis.</S>
    <S sid="335" ssid="21">Thus, all CCGbank relative pronouns have categories of the form (NPi\NPi)/(S/NPi), rather than (Ni\Ni)/(S/NPi).</S>
    <S sid="336" ssid="22">This will make life difficult for those trying to provide a Montague-style semantics for relative modifiers.</S>
    <S sid="337" ssid="23">Like most other problems that we were not able to overcome, this limitation of the Treebank ultimately reflects the sheer difficulty of providing a consistent and reliable annotation for certain linguistic phenomena, such as modifier scope.</S>
    <S sid="338" ssid="24">7.7.1 Heavy NP Shift.</S>
    <S sid="339" ssid="25">In English, noun phrase arguments can be shifted to the end of the sentence if they become too &#8220;heavy.&#8221; This construction was studied extensively by Ross (1967).</S>
    <S sid="340" ssid="26">The CCG analysis (Steedman 1996) uses backward crossed composition to provide an analysis where brings has its canonical lexical category (VP/PP)/NP: Because the Penn Treebank does not indicate heavy NP shift, the corresponding CCGbank derivation does not conform to the desired analysis, and requires additional lexical categories which may lead to incorrect overgeneralizations:24 This will also be a problem in using the Penn Treebank or CCGbank for any theory of grammar that treats heavy NP shift as extraction or movement.</S>
    <S sid="341" ssid="27">8.</S>
    <S sid="342" ssid="28">Coverage, Size, and Evaluation Here we first examine briefly the coverage of the translation algorithm on the entire Penn Treebank.</S>
    <S sid="343" ssid="29">Then we examine the CCG grammar and lexicon that are obtained from CCGbank.</S>
    <S sid="344" ssid="30">Although the grammar of CCG is usually thought of as consisting only of the combinatory rule schemata such as (3) and (5), we are interested here in the instantiation of these rules, in which the variables X and Y are bound to values such as S and NP, because statistical parsers such as Hockenmaier and Steedman&#8217;s (2002) or Clark and Curran&#8217;s (2004) are trained on counts of such instantiations.</S>
    <S sid="345" ssid="31">We report our results on sections 02&#8211;21, the standard training set for Penn Treebank parsers, and use section 00 to evaluate coverage of the training set on unseen data.</S>
    <S sid="346" ssid="32">Sections 02&#8211;21 contains 39,604 sentences (929,552 words/tokens), whereas section 00 consists of 1,913 sentences (45,422 words/tokens).</S>
    <S sid="347" ssid="33">CCGbank contains 48,934 (99.44%) of the 49,208 sentences in the entire Penn Treebank.</S>
    <S sid="348" ssid="34">The missing 274 sentences could not be automatically translated to CCG.</S>
    <S sid="349" ssid="35">This includes 107 instances of sentential gapping, a construction our algorithm does not cover (see Section 6.4.2), and 66 instances of non-sentential gapping, or argument-cluster coordination (see Section 6.4.1).</S>
    <S sid="350" ssid="36">The remaining translation failures include trees that consist of sequences of NPs that are not separated by commas, some fragments, and a small number of constructions involving long-range dependencies, such as wh-extraction, parasitic gaps, or argument cluster coordinations where the translation did not yield a valid CCG derivation because a complement had been erroneously identified as an adjunct.</S>
    <S sid="351" ssid="37">24 Backward crossed composition is also used by Steedman (1996, 2000) and Baldridge (2002) to account for constraints on preposition stranding in English.</S>
    <S sid="352" ssid="38">Because this rule in its unrestricted form leads to overgeneralization, Baldridge restricts crossing rules via the x modality.</S>
    <S sid="353" ssid="39">The current version of CCGbank does not implement modalities, but because the grammar that is implicit in CCGbank only consists of particular seen rule instantiations, it may not be affected by such overgeneration problems.</S>
    <S sid="354" ssid="40">A CCG lexicon specifies the lexical categories of words, and therefore contains the entire language-specific grammar.</S>
    <S sid="355" ssid="41">Here, we examine the size and coverage of the lexicon that consists of the word&#8211;category pairs that occur in CCGbank.</S>
    <S sid="356" ssid="42">This lexicon could be used by any CCG parser, although morphological generalization (which is beyond the scope of the present paper) and ways to treat unknown words are likely to be necessary to obtain a more complete lexicon.</S>
    <S sid="357" ssid="43">Number of Entries.</S>
    <S sid="358" ssid="44">The lexicon extracted from sections 02&#8211;21 has 74,669 entries for 44,210 word types (or 929,552 word tokens).</S>
    <S sid="359" ssid="45">Many words have only a small number of categories, but because a number of frequent closed-class items have a large number of categories (see Table 1), the expected number of lexical categories per token is 19.2.</S>
    <S sid="360" ssid="46">Number and Growth of Lexical Category Types.</S>
    <S sid="361" ssid="47">How likely is it that we have observed the complete inventory of category types in the English language?</S>
    <S sid="362" ssid="48">There are 1,286 lexical category types in sections 02&#8211;21.</S>
    <S sid="363" ssid="49">Figure 4 examines the growth of the number of lexical category types as a function of the amount of data translated into CCG.</S>
    <S sid="364" ssid="50">The log&#8211;log plot The growth of lexical category types and rule instantiations (sections 02&#8211;21).</S>
    <S sid="365" ssid="51">A log&#8211;log plot of the rank order and frequency of the lexical category types (left) and instantiations of combinatory rules (right) in CCGbank. of the rank order and frequency of the lexical categories in Figure 5 indicates that the underlying distribution is roughly Zipfian, with a small number of very frequent categories and a long tail of rare categories.</S>
    <S sid="366" ssid="52">We note 439 categories that occur only once, and only 556 categories occur five times or more.</S>
    <S sid="367" ssid="53">Inspection suggests that although some of the category types that occur only once are due to noise or annotation errors, most are correct and are in fact required for certain constructions.</S>
    <S sid="368" ssid="54">Typical examples of rare but correct and necessary categories are relative pronouns in pied-piping constructions, or verbs which take expletive subjects.</S>
    <S sid="369" ssid="55">Lexical Coverage on Unseen Data.</S>
    <S sid="370" ssid="56">The lexicon extracted from sections 02&#8211;21 contains the necessary categories (as determined by our translation algorithm) for 94.0% of all tokens in section 00 (42,707 out of 45,422).</S>
    <S sid="371" ssid="57">The missing entries that would be required for the remaining 6% of tokens fall into two classes: 1,728, or 3.8%, correspond to completely unknown words that do not appear at all in section 02&#8211;21, whereas the other 2.2% of tokens do appear in the training set, but not with the categories required in section 00.</S>
    <S sid="372" ssid="58">All statistical parsers have to be able to accept unknown words in their input, regardless of the underlying grammar formalism.</S>
    <S sid="373" ssid="59">Typically, frequency information for rare words in the training data is used to estimate parameters for unknown words (and when these rare or unknown words are encountered during parsing, additional information may be obtained from a POS-tagger (Collins 1997)).</S>
    <S sid="374" ssid="60">However, in a lexicalized formalism such as CCG, there is the additional problem of missing lexical entries for known words.</S>
    <S sid="375" ssid="61">Because lexical categories play such an essential role in CCG, even a small fraction of missing lexical entries can have a significant effect on coverage, since the parser will not be able to obtain the correct analysis for any sentence that contains such a token.</S>
    <S sid="376" ssid="62">Hockenmaier and Steedman (2002) show that this lexical coverage problem does in practice have a significant impact on overall parsing accuracy.</S>
    <S sid="377" ssid="63">However, because many of the known words with missing entries do not appear very often in the training data, Hockenmaier (2003a) demonstrates that this problem can be partially alleviated if the frequency threshold below which rare words are treated as unseen is set to a much higher value than for standard Treebank parsers.</S>
    <S sid="378" ssid="64">An alternative approach, advocated by Clark and Curran (2004), is to use a supertagger which predicts lexical CCG categories in combination with a discriminative parsing model.</S>
    <S sid="379" ssid="65">Size and Growth of Instantiated Syntactic Rule Set.</S>
    <S sid="380" ssid="66">Statistical CCG parsers such as Hockenmaier and Steedman (2002) or Clark and Curran (2004) are trained on counts of specific instantiations of combinatory rule schemata by category-types.</S>
    <S sid="381" ssid="67">It is therefore instructive to consider the frequency distribution of these category-instantiated rules.</S>
    <S sid="382" ssid="68">The grammar for sections 02-21 has 3,262 instantiations of general syntactic combinatory rules like those in (3) with specific categories.</S>
    <S sid="383" ssid="69">Of these, 1146 appear only once, and 2,027 appear less than five times.</S>
    <S sid="384" ssid="70">Although there is some noise, many of the CCG rules that appear only once are linguistically correct and should be used by the parser.</S>
    <S sid="385" ssid="71">They include certain instantiations of type-raising, coordination, or punctuation rules, or rules involved in argument cluster coordinations, pied-piping constructions, or questions, all of which are rare in the Wall Street Journal.</S>
    <S sid="386" ssid="72">As can be seen from Figure 5, the distribution of rule frequencies is again roughly Zipfian, with the 10 most frequent rules accounting for 59.2% of all rule instantiations (159 rules account for 95%; 591 rules for 99%).</S>
    <S sid="387" ssid="73">The growth of rule instantiations is shown in Figure 4.</S>
    <S sid="388" ssid="74">If function tags are ignored, the grammar for the corresponding sections of the original Treebank contains 12,409 phrase-structure rules, out of which 6,765 occur only once (Collins 1999).</S>
    <S sid="389" ssid="75">These rules also follow a Zipfian distribution (Gaizauskas 1995).</S>
    <S sid="390" ssid="76">The fact that both category types and rule instances are also Zipfian for CCGbank, despite its binarized rules, shows that the phenomenon is not just due to the Treebank annotation with its very flat rules.</S>
    <S sid="391" ssid="77">Syntactic Rule Coverage on Unseen Data.</S>
    <S sid="392" ssid="78">Syntactic rule coverage for unseen data is almost perfect: 51,932 of the 51,984 individual rule instantiations in section 00 (corresponding to 844 different rule types) have been observed in section 02&#8211;21.</S>
    <S sid="393" ssid="79">Out of the 52 missing rule instantiation tokens (corresponding to 38 rule types, because one rule appears 13 times in one sentence), six involve coordination, and three punctuation.</S>
    <S sid="394" ssid="80">One missing rule is an instance of substitution (caused by a parasitic gap).</S>
    <S sid="395" ssid="81">Two missing rules are instances of type-raised argument types combining with a verb of a rare type.</S>
  </SECTION>
  <SECTION title="9." number="9">
    <S sid="396" ssid="1">This paper has presented an algorithm which translates Penn Treebank phrase-structure trees into CCG derivations augmented with word&#8211;word dependencies that approximate the underlying predicate&#8211;argument structure.</S>
    <S sid="397" ssid="2">In order to eliminate some of the noise in the original annotation and to obtain linguistically adequate derivations that conform to the &#8220;correct&#8221; analyses proposed in the literature, considerable preprocessing was necessary.</S>
    <S sid="398" ssid="3">Even though certain mismatches between the syntactic annotations in the Penn Treebank and the underlying semantics remain, and will affect any similar attempt to obtain expressive grammars from the Treebank, we believe that CCGbank, the resulting corpus, will be of use to the computational linguistics community in the following ways.</S>
    <S sid="399" ssid="4">CCGbank has already enabled the creation of several robust and accurate wide-coverage CCG parsers, including Hockenmaier and Steedman (2002), Clark, Hockenmaier, and Steedman (2002), Hockenmaier (2003b), and Clark and Curran (2004, 2007).</S>
    <S sid="400" ssid="5">Although the construction of full logical forms was beyond the scope of this project, CCGbank can also be seen as a resource which may enable the automatic construction of full semantic interpretations by wide-coverage parsers.</S>
    <S sid="401" ssid="6">Unlike most Penn Treebank parsers, such as Collins (1999) or Charniak (2000), these CCGbank parsers return not only syntactic derivations, but also local and long-range dependencies, including those that arise under relativization and coordination.</S>
    <S sid="402" ssid="7">Although these dependencies are only an approximation of the full semantic interpretation that can in principle be obtained from a CCG, they may prove useful for tasks such as summarization and question answering (Clark, Steedman, and Curran 2004).</S>
    <S sid="403" ssid="8">Furthermore, Bos et al. (2004) and Bos (2005) have demonstrated that the output of CCGbank parsers can be successfully translated into Kamp and Reyle&#8217;s (1993) Discourse Representation Theory structures, to support question answering and the textual entailment task (Bos and Markert 2005).</S>
    <S sid="404" ssid="9">We hope that these results can be ported to other corpora and other similarly expressive grammar formalisms.</S>
    <S sid="405" ssid="10">We also hope that our experiences will be useful in designing guidelines for future treebanks.</S>
    <S sid="406" ssid="11">Although implementational details will differ across formalisms, similar problems and questions to those that arose in our work will be encountered in any attempt to extract expressive grammars from annotated corpora.</S>
    <S sid="407" ssid="12">Because CCGbank preserves most of the linguistic information in the Treebank in a somewhat less noisy form, we hope that others will find it directly helpful for inducing grammars and statistical parsing models for other linguistically expressive formalisms.</S>
    <S sid="408" ssid="13">There are essentially three ways in which this might work.</S>
    <S sid="409" ssid="14">For lexicalized grammars, it may in some cases be possible to translate the subcategorization frames in the CCG lexicon directly into the target theory.</S>
    <S sid="410" ssid="15">For type-logical grammars (Moortgat 1988; Morrill 1994; Moot 2003), this is little more than a matter of transducing the syntactic types for the lexicon into the appropriate notation.</S>
    <S sid="411" ssid="16">For formalisms like LTAG, the relation is more complex, but the work of Joshi and Kulick (1996), who &#8220;unfold&#8221; CCG categories into TAG elementary trees via partial proof trees, and Shen and Joshi (2005), who define LTAG &#8220;spines&#8221; that resemble categories, suggest that this is possible.</S>
    <S sid="412" ssid="17">Transduction into HPSG signs is less obvious, but also seems possible in principle.</S>
    <S sid="413" ssid="18">A second possibility is to transduce CCGbank itself into a form appropriate to the target formalism.</S>
    <S sid="414" ssid="19">There seems to be a similar ordering over alternative formalisms from straightforward to less straightforward for this approach.</S>
    <S sid="415" ssid="20">We would also expect that dependency grammars Mel&#8217;&#711;cuk and Pertsov 1987; Hudson 1984) and parsers (McDonald, Crammer, and Pereira 2005) could be trained and tested with little extra work on the dependencies in CCGbank.</S>
    <S sid="416" ssid="21">Finally, we believe that existing methods for translating the Penn Treebank from scratch into other grammar formalisms will benefit from including preprocessing similar to that described here.</S>
    <S sid="417" ssid="22">As some indication of the relative ease with which these techniques transfer, we offer the observation that the 900K-word German Tiger dependency corpus has recently been translated into CCG using very similar techniques by Hockenmaier (2006), and C&#184; ak&#305;c&#305; (2005) has derived a Turkish lexicon from the a similarly preprocessed version of the METU-Sabanc&#184;&#305; Turkish dependency treebank (Oflazer et al. 2003).</S>
    <S sid="418" ssid="23">A fundamental assumption behind attempts at the automatic translation of syntactically annotated corpora into different grammatical formalisms such as CCG, TAG, HPSG, or LFG is that the analyses that are captured in the original annotation can be mapped directly (or, at least, without too much additional work) into the desired analyses in the target formalism.</S>
    <S sid="419" ssid="24">This can only hold if all constructions that are treated in a similar manner in the original corpus are also treated in a similar manner in the target formalism.</S>
    <S sid="420" ssid="25">For the Penn Treebank, our research and the work of others (Xia 1999; Chen and Vijay-Shanker 2004; Chiang 2000; Cahill et al. 2002) have shown that such a correspondence exists in most cases.</S>
    <S sid="421" ssid="26">Although the output of most current Treebank parsers is linguistically impoverished, the Treebank annotation itself is not.</S>
    <S sid="422" ssid="27">It is precisely the linguistic richness and detail of the original annotation&#8212;in particular, the additional information present in the null elements and function tags that are ignored by most other parsers&#8212;that has made the creation of CCGbank possible.</S>
    <S sid="423" ssid="28">The translation process would have been easier if some of the annotation had been more explicit and precise (as in the case of VP coordination, where preprocessing was required to identify the conjuncts, or in NP coordination, where we were not able to distinguish NP lists from appositives) and consistent (most importantly in identifying adjuncts and arguments).</S>
    <S sid="424" ssid="29">An important conclusion that follows for the builders of future treebanks is that the tradition established by the Penn Treebank of including all linguistically relevant dependencies should be continued, with if anything even closer adherence to semantically informed linguistic insights into predicate&#8211;argument structural relations.</S>
    <S sid="425" ssid="30">Our results also indicate that corpora of at least the order of magnitude of the Penn Treebank are necessary to obtain grammars and parsers that are sufficiently expressive, robust, and wide in coverage to recover these relations completely.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="10">
    <S sid="426" ssid="1">We would like to thank our colleagues in Edinburgh and Philadelphia&#8212;in particular Jason Baldridge, Johan Bos, Stephen Clark, James Curran, Michael White, Mitch Marcus, Ann Bies, Martha Palmer, and Aravind Joshi&#8212;for numerous conversations and feedback on the corpus.</S>
    <S sid="427" ssid="2">We would also like to thank the Linguistic Data Consortium for their help in publishing CCGbank, and the Computational Linguistics reviewers for their extensive comments on earlier versions of this paper.</S>
    <S sid="428" ssid="3">We gratefully acknowledge the financial support provided by EPSRC grant GR/M96889.</S>
    <S sid="429" ssid="4">JH also acknowledges support by an EPSRC studentship and the Edinburgh Language Technology Group, and by NSF ITR grant 0205456 at the University of Pennsylvania.</S>
    <S sid="430" ssid="5">MJS acknowledges support from the Scottish Enterprise Edinburgh&#8211;Stanford Link (NSF IIS-041628 (R39058)) and EU IST grant PACOPLUS (FP6-2004-IST-4-27657).</S>
  </SECTION>
</PAPER>
