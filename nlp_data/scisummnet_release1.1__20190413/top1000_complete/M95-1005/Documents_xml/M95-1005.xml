<PAPER>
  <S sid="0" ssid="0">A Model-Theoretic Coreference Scoring Schem e Marc Vilain, John Burger, John Aberdeen, Dennis Connolly, Lynette Hirschman The MITRE Corporation 202 Burlington Rd .</S>
  <S sid="1" ssid="1">Bedford, MA 01730 mbv, john, aberdeen, lynette@mitre .org; dennis.x.connolly@ameritech.com This note describes a scoring scheme for the coreference task in MUC6 .</S>
  <S sid="2" ssid="2">It improves o n the original approach l by: (1) grounding the scoring scheme in terms of a model ; (2) producing more intuitive recall and precision scores ; and (3) not requiring explici t computation of the transitive closure of coreference .</S>
  <S sid="3" ssid="3">The principal conceptual differenc e is that we have moved from a syntactic scoring model based on following coreferenc e links to an approach defined by the model theory of those links .</S>
  <S sid="4" ssid="4">In brief, the scheme operates by comparing the equivalence classes defined by the link s in the key and the response, rather than the links themselves (thus, this is only wel l defined for identity links, at the moment) .</S>
  <S sid="5" ssid="5">These classes are of course the models of the IDENT equivalence relation, and this strategy is preferable for a number of reasons, on e being that the scores are independent of the particular links used to encode th e equivalence relation .</S>
  <S sid="6" ssid="6">The scores themselves are obtained by determining the minima l perturbations to the response that are required to transform its corresponding equivalenc e classes into those of the key .</S>
  <S sid="7" ssid="7">Specifically, the recall (respectively precision) error term s are found by calculating the least number of links that need to be added to the respons e (respectively the key) in order to have the classes align .</S>
  <S sid="8" ssid="8">Although at first blush thi s seems combinatorially explosive, due to references to minimal spanning subsets of th e equivalence relation, it turns out it can be accomplished with a very simple countin g scheme .</S>
  <S sid="9" ssid="9">A PROBLEMATIC CAS E Consider the first problematic example from the coreference task guidelines : ?</S>
  <S sid="10" ssid="10">Key Links : &lt;A-B B-C B-D&gt; ?</S>
  <S sid="11" ssid="11">Response Links: &lt;A-B C-D&gt; Note that the key links generate an equivalence class, the set (A B C D I .</S>
  <S sid="12" ssid="12">Technically , the links are a spanning tree of the sets implicit equivalence graph, i .e., thefully - connected graph whose nodes are the entities A, B, C, and D .</S>
  <S sid="13" ssid="13">The following figure shows the spanning tree in dark lines, and the rest of the graph in gray lines .</S>
  <S sid="14" ssid="14">This is just one such spanning tree for the overall equivalence class ; there are of course I Coreference task defmition ., version 2.0 and earlier.</S>
  <S sid="15" ssid="15">45 others, including the "non-problematic" case of &lt;A-B B-C C-D&gt; .</S>
  <S sid="16" ssid="16">Either way, a minimal spanning tree of the equivalence relation will always be of size 3, which aligns with th e intuitive notion that three links will always be necessary to make four entitie s coreferential under the criterion of strict identity .</S>
  <S sid="17" ssid="17">Returning to the task of scoring coreference for this problematic case, we note that a response of &lt;A-B C-D&gt; induces two equivalence classes, thus partitioning the set of ke y entities into subsets {A B } and { C DI .</S>
  <S sid="18" ssid="18">It is intuitive that the precision score for thi s response should be 2/2 = 1, since 2 out of 2 of the response links are "correct" .</S>
  <S sid="19" ssid="19">That is, both response links are arcs in the equivalence graph generated by the key .</S>
  <S sid="20" ssid="20">For recall, Sundheim et al .</S>
  <S sid="21" ssid="21">advance the desirable score of 2/3, which is not obtained by the syntacti c scoring measure.</S>
  <S sid="22" ssid="22">This score appeals to the intuitive notion that of the three links neces- sary to make the key entities fully coreferential, the response only provides two .</S>
  <S sid="23" ssid="23">Thinking model-theoretically, we note that the response corresponds to a subgraph of the fully-connected equivalence graph .</S>
  <S sid="24" ssid="24">The recall score of 2/3 aligns with the fact that one equivalence arc is required to "complete" the response graph, yielding one of the following four spanning trees .</S>
  <S sid="25" ssid="25">B LLC /e /e ms !/c / / Note that the problem with the syntactic (link-wise) scorer is that there are combina- tonally many such spanning trees for a given equivalence class, while keys only list one .</S>
  <S sid="26" ssid="26">COMPUTING MODEL-THEORETIC RECALL How then can we turn this notion of minimal missing links into a computationall y effective scoring procedure that works in the general case?</S>
  <S sid="27" ssid="27">Roughly stated, the scorin g mechanism for recall must form the equivalence sets generated by the key, and then determine for each such key set how many subsets the response partitions the key set into.</S>
  <S sid="28" ssid="28">The score then follows by simple arithmetic .</S>
  <S sid="29" ssid="29">Getting a bit more formal (but not much), let us define recall using these notions .</S>
  <S sid="30" ssid="30">First, let S be an equivalence set generated by the key, and let R1 .</S>
  <S sid="31" ssid="31">.Rm be equivalent classe s generated by the response.</S>
  <S sid="32" ssid="32">Then we define the following functions over S : ?</S>
  <S sid="33" ssid="33">p(S) is a partition of S relative to the response .</S>
  <S sid="34" ssid="34">Each subset of S in the partition is formed by intersecting S and those response sets Ri that overlap S .</S>
  <S sid="35" ssid="35">Note that the equivalence classes defined by the response may include implicit singleton sets ?</S>
  <S sid="36" ssid="36">these correspond to elements that are mentioned in the key but not in the response .</S>
  <S sid="37" ssid="37">46 For example, say the key generates the equivalence class S= { A B C D and the response is simply &lt;A-B&gt; .</S>
  <S sid="38" ssid="38">The relative partition p(S) is then {A B} {C} and {D} .</S>
  <S sid="39" ssid="39">c(S) is the minimal number of "correct" links necessary to generate the equivalenc e class S. It is clear that c(S) is one less than the cardinality of S, i .e .</S>
  <S sid="40" ssid="40">, c(S) = (ISI -1) ?</S>
  <S sid="41" ssid="41">m(S) is the number of "missing" links in the response relative to the key set S .</S>
  <S sid="42" ssid="42">As noted above, this is the number of links necessary to fully reunite any components o f the p(S) partition.</S>
  <S sid="43" ssid="43">We note that this is simply one fewer than the number of element s in the partition, that is , m(S) = (Ip(S)I ?</S>
  <S sid="44" ssid="44">1 ) Looking in isolation at a single equivalence class in the key, the recall error for that clas s is just the number of missing links divided by the minimal number of correct links, i .e .</S>
  <S sid="45" ssid="45">, m(S) c(S) Recall in turn i s _ ISI ?</S>
  <S sid="46" ssid="46">1 To see how this works in practice, consider the second problematic example noted b y Sundheim et al .</S>
  <S sid="47" ssid="47">Key Links: &lt;A-B B-C&gt; ?</S>
  <S sid="48" ssid="48">Response Links: &lt;A-C&gt; The key generates a single equivalence class S : (A B C}.</S>
  <S sid="49" ssid="49">The size of the class i s ISI=3, and the minimum number of links necessary to establish the class i s c(S) = (ISI ?</S>
  <S sid="50" ssid="50">The response partitions this class into a partition p(S) of size 2, containing {A C} an d { B }, where the latter element is implicitly defined .</S>
  <S sid="51" ssid="51">Working through the arithmetic, we have : R _ ISI ?</S>
  <S sid="52" ssid="52">2 This score of 1/2 is the intuitively "correct" one that the syntactic measure fails t o calculate .</S>
  <S sid="53" ssid="53">m(S ) c(S) (ISI ?</S>
  <S sid="54" ssid="54">(Ip(S)I -1) 47 Finally, we note that extending this measure from a single key equivalence class to a n entire test set T simply requires summing over the key equivalence classes .</S>
  <S sid="55" ssid="55">That is , E(ISiI ?</S>
  <S sid="56" ssid="56">Ip(Si)I ) SCORING PRECISION The recall scoring procedure operates by merging the subsets of a key equivalence clas s that are defined by equivalence classes in the response .</S>
  <S sid="57" ssid="57">It is of course the case that the response classes may not be proper subsets of the key .</S>
  <S sid="58" ssid="58">When the response overlaps the key in such a way as to produce a non-trivial set difference, as in the following figure, the response contains precision errors.</S>
  <S sid="59" ssid="59">How may we use our model-theoretic notions to provide a scoring mechanism for precision?</S>
  <S sid="60" ssid="60">In the case of recall, we conceptually needed to add links to the response , building up the responses equivalence classes so as to end up with the key .</S>
  <S sid="61" ssid="61">In the case of precision, we need to do the converse : add links to equivalence classes in the key so as to yield equivalence classes in the response .</S>
  <S sid="62" ssid="62">We are switching the "figure" and th e "ground"; that is we are switching our notion of where the base sets come from (th e response rather than the key), and of what defines the partitions on those base sets (the key rather than the response) .</S>
  <S sid="63" ssid="63">More precisely, given an equivalence class S defined by the response, we mus t determine the minimal number of links to be added to the key, so as to ensure that each o f the members of the response set is in the same key set.</S>
  <S sid="64" ssid="64">Once again, we proceed by generating a relative partition, in this case the partition of the response equivalence class S relative to key equivalence classes K1 .</S>
  <S sid="65" ssid="65">Elements of the response that are not found in the key once again generate implicit subsets, one per element.</S>
  <S sid="66" ssid="66">The number of missing elements is once again 1 less than the size of the partition .</S>
  <S sid="67" ssid="67">For the example above, we see that the response generates an equivalence class of size 3 , namely the set S = {A B C) .</S>
  <S sid="68" ssid="68">The key partitions this class into subsets {B C) and {A) , where the latter is implicit .</S>
  <S sid="69" ssid="69">The partition is of size 2, and so the minimal number of links that need to be added to reunite the partition is just 1 .</S>
  <S sid="70" ssid="70">Switching the figure and ground in the recall formula, the scoring arithmetic for precisio n works itself out as follows, where S is now an equivalence class from the response, an d p(S) is the partition of S vis-a-vis the key(s) .</S>
  <S sid="71" ssid="71">We then have : c(S) = (ISI ?</S>
  <S sid="72" ssid="72">1)  size of spanning tree for S m(S) = (Ip(S)I ?</S>
  <S sid="73" ssid="73">1)  number of missing links RT = 1(IS;I ?</S>
  <S sid="74" ssid="74">1) 48 PT 1(ISil ?</S>
  <S sid="75" ssid="75">Ip  (S i) I ) c(S)?m(S ) P ?</S>
  <S sid="76" ssid="76">(Ip(S)I -1) ISI -1 Precision ISI - 1 ISI ?</S>
  <S sid="77" ssid="77">Ip(S) I Thus, like the scheme proposed in Sundheim et al ., we have an aesthetically pleasing inverse relationship between precision and recall .</S>
  <S sid="78" ssid="78">For the example above, these formul a yield a precision of 1/2, which is intuitively appropriate, since of the two minimum link s needed to generate the response class {A B C}, the key only provides one, B-C .</S>
  <S sid="79" ssid="79">To extend from a single response to a complete test set T, we once again sum over the tes t set, this time iterating over response equivalence classes .</S>
  <S sid="80" ssid="80">Table 1 shows the precision and recall scores, using the model-theoretic measures , for al l of the examples given in Sundheim et al.</S>
  <S sid="81" ssid="81">Note that these results agree with the origina l scoring proposal for the first three cases, but agree with intuition for the last two .</S>
  <S sid="82" ssid="82">Key  Response  R  P A-B B-C C-D A-B C-D 2/3 2/2 A-B C-D A-B B-C C-D 2/2 2/3 A-B B-C B-D A-B B-C C-D 3/3 3/3 A-B B-C B-D A-B C-D 2/3 2/2 A-B B-C A-C 1/2 1/1 Table 1: Recall and precision scores for coreference example s EXAMPLES WITH MORE COMPLEXITY The examples so far have been purposefully simplified in that we have only considere d cases that defined one key class and one response class .</S>
  <S sid="83" ssid="83">Let us now consider some more- complex examples where keys and responses dont so neatly overlap .</S>
  <S sid="84" ssid="84">To begin with, imagine that the key and response are as follows .</S>
  <S sid="85" ssid="85">Key: &lt;B-C C-D D-E E-G G-H H-J&gt; ?</S>
  <S sid="86" ssid="86">Response : &lt;A-B B-C D-E E-F G-H-H-I &gt; The key establishes a single equivalence class, while the response defines three : {A B C}, {D E F}, {G H I} .</S>
  <S sid="87" ssid="87">In addition, the key contains the element J, which is missin g entirely from the response .</S>
  <S sid="88" ssid="88">These are shown in the following figure, where the thic k lines denote the key class, and thin ones denote response classes .</S>
  <S sid="89" ssid="89">49 Eyeballing the problem, we note that as there are seven elements in the key, six links must minimally be provided to achieve 100% recall.</S>
  <S sid="90" ssid="90">The response only provides thre e correct ones, so we would expect recall to come out at 50% .</S>
  <S sid="91" ssid="91">Precision should be 50% a s well, as half of the links indicated in the response are not in the key .</S>
  <S sid="92" ssid="92">Working through the math, we note that p(S), the partition of the key with respect to the response yield s four subsets, shown in the followinfigure with thin lines .</S>
  <S sid="93" ssid="93">A Evaluating for recall : R _ ISI ?</S>
  <S sid="94" ssid="94">1 = 3/6, or 50% For precision, we must consider the three equivalence classes defined in the response.</S>
  <S sid="95" ssid="95">Partitioning these three classes with respect to the key yields two subsets in each of the classes, for a total of six subsets.</S>
  <S sid="96" ssid="96">These are shown in thick lines in the following figure .</S>
  <S sid="97" ssid="97">To evaluate for precision, we must use the corpus-wide formula: 50 I(ISiI ?</S>
  <S sid="98" ssid="98">Ip  (S  i) I ) PT = E(ISil -1 ) (3?2)+(3?2)+(3?2 ) (3?1)+(3?1)+(3?1) = 3/6, or 50% Before closing, let us consider an even more complex example with multiple sets in bot h the key and the response .</S>
  <S sid="99" ssid="99">Key: &lt;A-B B-C D-E E-F F-G &gt; ?</S>
  <S sid="100" ssid="100">Response: &lt;A-B C-D F-G G-H&gt; Figure 1 shows the equivalence classes corresponding to the key and response .</S>
  <S sid="101" ssid="101">Figure 2 shows how the response partitions the two key sets .</S>
  <S sid="102" ssid="102">Based on this, we can compute recall using the corpus-wide formula for recall .</S>
  <S sid="103" ssid="103">Since there are two key sets, there will be tw o terms each in the numerator and the denominator .</S>
  <S sid="104" ssid="104">Ip(Si)I ) E(ISiI ?</S>
  <S sid="105" ssid="105">1 ) (3?2)+(4?3) (3?1)+(4?1) = 2/5 or 40% This is consistent with the observation that the response only provides two out of the fiv e links that are minimally required to fully designate all the coreference relations .</S>
  <S sid="106" ssid="106">Turning to precision, Figure 3 shows the partitions induced on the three response sets by the key .</S>
  <S sid="107" ssid="107">RT Thick = key Thin = response Figure 1 : Key and response H Thick = ke y Thin = partition wrt/response Figure 2 : Recall Thick = partition wrt/key Thin = Respons e Figure 3: Precision 51 E(ISiI ?</S>
  <S sid="108" ssid="108">I p  (S i) I ) PT = 1(ISil ?</S>
  <S sid="109" ssid="109">1 ) (2?1)+(2?2)+(3?2) (2?1)+(2?1)+(3?1 ) = 2/4, or 50 % It is delightful that the formula yields exactly what intuition would dictate in this case .</S>
  <S sid="110" ssid="110">COMPUTATIONAL CONSIDERATIONS, BRIEFLY EXPLORE D Our scoring expressions are easy to compute .</S>
  <S sid="111" ssid="111">The key step is the formation of equivalence classes, which can be accomplished by many algorithms .</S>
  <S sid="112" ssid="112">Tarjans classic UNION-FIND, to cite the obvious example, operates in time effectively linear with th e number of entities under consideration .</S>
  <S sid="113" ssid="113">This is substantially less expensive than enumerating the transitive closure of keys and answers, as is required by the origina l syntactic scoring procedure .</S>
  <S sid="114" ssid="114">Not often does attention to model theory yield efficient algorithms, but in this particular case the effort was well worth the while .</S>
</PAPER>
