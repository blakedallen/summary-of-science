<PAPER>
  <S sid="0">A Critique And Improvement Of An Evaluation Metric For Text Segmentation</S>
  <ABSTRACT>
    <S sid="1" ssid="1">metric, initially proposed by Beeferman, Berger, and Lafferty (1997), is becoming the standard measure for assessing text segmentation algorithms.</S>
    <S sid="2" ssid="2">However, a theoretical analysis of the metric finds several problems: the metric penalizes false negatives more heavily than false positives, overpenalizes near misses, and is affected by variation in segment size dis- We propose a simple modification to the that remedies these problems.</S>
    <S sid="3" ssid="3">This new metric&#8212;called WindowDiff&#8212;moves a fixed-sized window across the text and penalizes the algorithm whenever the number of boundaries within the window does not match the true number of boundaries for that window of text.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="4" ssid="1">The Pk evaluation metric, initially proposed by Beeferman, Berger, and Lafferty (1997), is becoming the standard measure for assessing text segmentation algorithms.</S>
    <S sid="5" ssid="2">However, a theoretical analysis of the metric finds several problems: the metric penalizes false negatives more heavily than false positives, overpenalizes near misses, and is affected by variation in segment size distribution.</S>
    <S sid="6" ssid="3">We propose a simple modification to the Pk metric that remedies these problems.</S>
    <S sid="7" ssid="4">This new metric&#8212;called WindowDiff&#8212;moves a fixed-sized window across the text and penalizes the algorithm whenever the number of boundaries within the window does not match the true number of boundaries for that window of text.</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="8" ssid="1">Text segmentation is the task of determining the positions at which topics change in a stream of text.</S>
    <S sid="9" ssid="2">Interest in automatic text segmentation has blossomed over the last few years, with applications ranging from information retrieval to text summarization to story segmentation of video feeds.</S>
    <S sid="10" ssid="3">Early work in multiparagraph discourse segmentation examined the problem of subdividing texts into multiparagraph units that represent passages or subtopics.</S>
    <S sid="11" ssid="4">An example, drawn from Hearst (1997), is a 21paragraph science news article, called &#8220;Stargazers,&#8221; whose main topic is the existence of life on earth and other planets.</S>
    <S sid="12" ssid="5">Its contents can be described as consisting of the following subtopic discussions (numbers indicate paragraphs): The TextTiling algorithm (Hearst 1993, 1994, 1997) attempts to recognize these subtopic changes by making use of patterns of lexical co-occurrence and distribution; subtopic boundaries are assumed to occur at the point in the documents at which large shifts in vocabulary occur.</S>
    <S sid="13" ssid="6">Many others have used this technique, or slight variations of it, for subtopic segmentation (Nomoto and Nitta 1994; Hasnah 1996; Richmond, Smith, and Amitay 1997; Heinonen 1998; Boguraev and Neff 2000).</S>
    <S sid="14" ssid="7">Other techniques use clustering and/or similarity matrices based on word co-occurrences (Reynar 1994; Yaari 1997; Choi 2000), and still others use machine learning techniques to detect cue words, or hand-selected cue words to detect segment boundaries (Passonneau and Litman 1993; Beeferman, Berger, and Lafferty 1997; Manning 1998).</S>
    <S sid="15" ssid="8">Researchers have explored the use of this kind of document segmentation to improve automated summarization (Salton et al. 1994; Barzilay and Elhadad 1997; Kan, Klavans, and McKeown 1998; Mittal et al.</S>
    <S sid="16" ssid="9">1999; Boguraev and Neff 2000) and automated genre detection (Karlgren 1996).</S>
    <S sid="17" ssid="10">Text segmentation issues are also important for passage retrieval, a subproblem of information retrieval (Hearst and Plaunt 1993; Salton, Allan, and Buckley 1993; Callan 1994; Kaszkiel and Zobel 1997).</S>
    <S sid="18" ssid="11">More recently, a great deal of interest has arisen in using automatic segmentation for the detection of topic and story boundaries in news feeds (Mani et al. 1997; Merlino, Morey, and Maybury 1997; Ponte and Croft 1997; Hauptmann and Witbrock 1998; Allan et al.</S>
    <S sid="19" ssid="12">1998; Beeferman, Berger, and Lafferty 1997, 1999).</S>
    <S sid="20" ssid="13">Sometimes segmentation is done at the clause level, for the purposes of detecting nuances of dialogue structure or for more sophisticated discourse-processing purposes (Morris and Hirst 1991; Passonneau and Litman 1993; Litman and Passonneau 1995; Hirschberg and Nakatani 1996; Marcu 2000).</S>
    <S sid="21" ssid="14">Some of these algorithms produce hierarchical dialogue segmentations whose evaluation is outside the scope of this discussion.</S>
    <S sid="22" ssid="15">There are two major difficulties associated with evaluating algorithms for text segmentation.</S>
    <S sid="23" ssid="16">The first is that since human judges do not always agree where boundaries should be placed and how fine grained an analysis should be, it is difficult to choose a reference segmentation for comparison.</S>
    <S sid="24" ssid="17">Some evaluations circumvent this difficulty by detecting boundaries in sets of concatenated documents, where there can be no disagreements about the fact of the matter (Reynar 1994; Choi 2000); others have several human judges make ratings to produce a &#8220;gold standard.&#8221; The second difficulty with evaluating these algorithms is that for different applications of text segmentation, different kinds of errors become important.</S>
    <S sid="25" ssid="18">For instance, for information retrieval, it can be acceptable for boundaries to be off by a few sentences&#8212; a condition called a near miss&#8212;but for news boundary detection, accurate placement is crucial.</S>
    <S sid="26" ssid="19">For this reason, some researchers prefer not to measure the segmentation algorithm directly, but consider its impact on the end application (Manning 1998; Kan, Klavans, and McKeown 1998).</S>
    <S sid="27" ssid="20">Our approach to these two difficulties is to evaluate algorithms on real segmentations using a &#8220;gold standard&#8221; and to develop an evaluation algorithm that suits all applications reasonably well.</S>
    <S sid="28" ssid="21">Precision and recall are standard evaluation measures for information retrieval tasks and are often applied to evaluation of text segmentation algorithms as well.</S>
    <S sid="29" ssid="22">Precision is the percentage of boundaries identified by an algorithm that are indeed true boundaries; recall is the percentage of true boundaries that are identified by the algorithm.</S>
    <S sid="30" ssid="23">However, precision and recall are problematic for two reasons.</S>
    <S sid="31" ssid="24">The first is that there is an inherent trade-off between precision and recall; improving one tends to cause the score for the other to decline.</S>
    <S sid="32" ssid="25">In the segmentation example, positing more boundaries will tend to improve the recall but at the same time reduce the precision.</S>
    <S sid="33" ssid="26">Some evaluators use a weighted combination of the two known as the F-measure (Baeza-Yates and Ribeiro-Neto 1999), but this is difficult to interpret (Beeferman, Berger, and Lafferty 1999).</S>
    <S sid="34" ssid="27">Another approach is to plot a precision-recall curve, showing the scores for precision at different levels of recall.</S>
    <S sid="35" ssid="28">Two hypothetical segmentations of the same reference (ground truth) document segmentation.</S>
    <S sid="36" ssid="29">The boxes indicate sentences or other units of subdivision, and spaces between boxes indicate potential boundary locations.</S>
    <S sid="37" ssid="30">Algorithm A-0 makes two near misses, while Algorithm A-1 misses both boundaries by a wide margin and introduces three false positives.</S>
    <S sid="38" ssid="31">Both algorithms would receive scores of 0 for both precision and recall.</S>
    <S sid="39" ssid="32">Another problem with precision and recall is that they are not sensitive to near misses.</S>
    <S sid="40" ssid="33">Consider, for example, a reference segmentation and the results obtained by two different text segmentation algorithms, as depicted in Figure 1.</S>
    <S sid="41" ssid="34">In both cases, the algorithms fail to match any boundary precisely; both receive scores of 0 for precision and recall.</S>
    <S sid="42" ssid="35">However, Algorithm A-0 is close to correct in almost all cases, whereas Algorithm A-1 is entirely off, adding extraneous boundaries and missing important boundaries entirely.</S>
    <S sid="43" ssid="36">In some circumstances, it would be useful to have an evaluation metric that penalizes A-0 less harshly than A-1.</S>
    <S sid="44" ssid="37">Beeferman, Berger, and Lafferty (1997) introduce a new evaluation metric that attempts to resolve the problems with precision and recall, including assigning partial credit to near misses.</S>
    <S sid="45" ssid="38">They justify their metric as follows (page 43): Segmentation ... is about identifying boundaries between successive units of information in a text corpus.</S>
    <S sid="46" ssid="39">Two such units are either related or unrelated by the intent of the document author.</S>
    <S sid="47" ssid="40">A natural way to reason about developing a segmentation algorithm is therefore to optimize the likelihood that two such units are correctly labeled as being related or being unrelated.</S>
    <S sid="48" ssid="41">Our error metric P&#181; is simply the probability that two sentences drawn randomly from the corpus are correctly identified as belonging to the same document or not belonging to the same document.</S>
    <S sid="49" ssid="42">The derivation of P&#181; is rather involved, and a much simpler version is adopted in the later work (Beeferman, Berger, and Lafferty 1999) and by others.</S>
    <S sid="50" ssid="43">This version, referred to as Pk, is calculated by setting k to half of the average true segment size and then computing penalties via a moving window of length k. At each location, the algorithm determines whether the two ends of the probe are in the same or different segments in the reference segmentation and increases a counter if the algorithm&#8217;s segmentation disagrees.</S>
    <S sid="51" ssid="44">The resulting count is scaled between 0 and 1 by dividing by the number of measurements taken.</S>
    <S sid="52" ssid="45">An algorithm that assigns all boundaries correctly receives a score of 0.</S>
    <S sid="53" ssid="46">Beeferman, Berger, and Lafferty (1999) state as part of An illustration of how the Pk metric handles false negatives.</S>
    <S sid="54" ssid="47">The arrowed lines indicate the two poles of the probe as it moves from left to right; the boxes indicate sentences or other units of subdivision; and the width of the window (k) is four, meaning four potential boundaries fall between the two ends of the probe.</S>
    <S sid="55" ssid="48">Solid lines indicate no penalty is assigned; dashed lines indicate a penalty is assigned.</S>
    <S sid="56" ssid="49">Total penalty is always k for false negatives. the justification for this metric that, to discourage &#8220;cheating&#8221; of the metric, degenerate algorithms&#8212;those that place boundaries at every position, or place no boundaries at all&#8212;are assigned (approximately) the same score.</S>
    <S sid="57" ssid="50">Additionally, the authors define a false negative (also referred to as a miss) as a case when a boundary is present in the reference segmentation but missing in the algorithm&#8217;s hypothesized segmentation, and a false positive as an assignment of a boundary that does not exist in the reference segmentation.</S>
    <S sid="58" ssid="51">The Pk metric is fast becoming the standard among researchers working in text segmentation (Allan et al. 1998; Dharanipragada et al.</S>
    <S sid="59" ssid="52">1999; Eichmann et al. 1999; van Mulbregt et al.</S>
    <S sid="60" ssid="53">1999; Choi 2000).</S>
    <S sid="61" ssid="54">However, we have reservations about this metric.</S>
    <S sid="62" ssid="55">We claim that the fundamental premise behind it is flawed; additionally, it has several significant drawbacks, which we identify in this section.</S>
    <S sid="63" ssid="56">In the remainder of the paper, we suggest modifications to resolve these problems, and we report the results of simulations that validate the analysis and suggest that the modified metric is an improvement over the original.</S>
    <S sid="64" ssid="57">Assume a text with segments of average size 2k, where k is the distance between the two ends of the Pk probe.</S>
    <S sid="65" ssid="58">If the algorithm misses a boundary&#8212;produces a false negative&#8212;it receives k penalties.</S>
    <S sid="66" ssid="59">To see why, suppose S1 and S2 are two segments of length 2k, and the algorithm misses the transition from S1 to S2.</S>
    <S sid="67" ssid="60">When Pk sweeps across S1, if both ends of the probe point to sentences that are inside S1, the two sentences are in the same segment in both the reference and the hypothesis, and no penalty is incurred.</S>
    <S sid="68" ssid="61">When the right end of the probe crosses the reference boundary between S1 and S2, it will start recording nonmatches, since the algorithm assigns the two sentences to the same segment, while the reference does not.</S>
    <S sid="69" ssid="62">This circumstance happens k times, until both ends of the probe point to sentences that are inside S2.</S>
    <S sid="70" ssid="63">(See Figure 2.)</S>
    <S sid="71" ssid="64">This analysis assumes average size segments; variation in segment size is discussed below, but does not have a large effect on this result.</S>
    <S sid="72" ssid="65">An illustration of how the Pk metric handles false positives.</S>
    <S sid="73" ssid="66">Notation is as in Figure 2.</S>
    <S sid="74" ssid="67">Total penalty depends on the distance between the false positive and the relevant correct boundaries; on average, it is k2, assuming a uniform distribution of boundaries across the document.</S>
    <S sid="75" ssid="68">This example shows the consequences of two different locations of false positives: on the left, the penalty is k2; on the right, it is k. Now, consider false positives.</S>
    <S sid="76" ssid="69">A false positive occurs when the algorithm places a boundary at some position where there is no boundary in the reference segmentation.</S>
    <S sid="77" ssid="70">The number of times that this false positive is noted by Pk depends on where exactly inside S2 the false positive occurs.</S>
    <S sid="78" ssid="71">(See Figure 3.)</S>
    <S sid="79" ssid="72">If it occurs in the middle of the segment, the false positive is noted k times (as seen on the right-hand side of Figure 3).</S>
    <S sid="80" ssid="73">If it occurs j &lt; k sentences from the beginning or the end of the segment, the segmentation is penalized j times.</S>
    <S sid="81" ssid="74">Assuming uniformly distributed false positives, on average a false positive is noted 2k times by the metric&#8212;half the rate for false negatives.</S>
    <S sid="82" ssid="75">This average increases with segment size, as we will discuss later, and changes if one assumes different distributions of false positives throughout the document.</S>
    <S sid="83" ssid="76">However, this does not change the fact that in most cases, false positives are penalized some amount less than false negatives.</S>
    <S sid="84" ssid="77">This is not an entirely undesirable side effect.</S>
    <S sid="85" ssid="78">This metric was devised to take into account how close an assigned boundary is to the true one, rather than just marking it as correct or incorrect.</S>
    <S sid="86" ssid="79">This method of penalizing false positives achieves this goal: the closer the algorithm&#8217;s boundary is to the actual boundary, the less it is penalized.</S>
    <S sid="87" ssid="80">However, overpenalizing false negatives to do this is not desirable.</S>
    <S sid="88" ssid="81">One way to fix the problem of penalizing false negatives more than false positives is to double the false positive penalty (or halve the false negative penalty).</S>
    <S sid="89" ssid="82">However, this would undermine the probabilistic nature of the metric.</S>
    <S sid="90" ssid="83">In addition, doubling the penalty may not always be the correct solution, since segment size will vary from the average, and false positives are not necessarily uniformly distributed throughout the document.</S>
    <S sid="91" ssid="84">Another important problem with the Pk metric is that it allows some errors to go unpenalized.</S>
    <S sid="92" ssid="85">In particular, it does not take into account the number of segment boundaries between the two ends of the probe.</S>
    <S sid="93" ssid="86">(See Figure 4.)</S>
    <S sid="94" ssid="87">Let r; indicate the number of boundaries between the ends of the probe according to the reference segmentation, and let a; indicate the number of boundaries proposed by some text segmentation algorithm for the same stretch of text.</S>
    <S sid="95" ssid="88">If r; = 1 (the reference segmentation indicates one boundary) and a; = 2 (the algorithm marks two boundaries within this range), then the algorithm makes at least one false positive (spurious boundary) error.</S>
    <S sid="96" ssid="89">However, the evaluation metric Pk does not assign a penalty in this situation.</S>
    <S sid="97" ssid="90">Similarly, if r; = 2 and a; = 1, the An illustration of the fact that the Pk metric fails to penalize false positives that fall within k sentences of a true boundary.</S>
    <S sid="98" ssid="91">Notation is as in Figure 2. algorithm has made at least one false negative (missing boundary) error, but it is not penalized for this error under Pk.</S>
    <S sid="99" ssid="92">The size of the segment plays a role in the amount that a false positive within the segment or a false negative at its boundary is penalized.</S>
    <S sid="100" ssid="93">Let us consider false negatives (missing boundaries) first.</S>
    <S sid="101" ssid="94">As seen above, with average size segments, the penalty for a false negative is k. For larger segments, it remains at k&#8212;it cannot be any larger than that, since for a given position i there can be at most k intervals of length k that include that position.</S>
    <S sid="102" ssid="95">As segment size gets smaller, however, the false negative penalty changes.</S>
    <S sid="103" ssid="96">Suppose we have two segments, A and B, and the algorithm misses the boundary between them.</S>
    <S sid="104" ssid="97">Then the algorithm will be penalized k times if Size(A)+ Size(B) &gt; 2k, that is, as long as each segment is about half the average size or larger.</S>
    <S sid="105" ssid="98">The penalty will then decrease linearly with Size(A)+Size(B) so long as k &lt; Size(A)+ Size(B) &lt; 2k.</S>
    <S sid="106" ssid="99">To be more exact, the penalty actually decreases linearly as the size of either segment decreases below k. This is intuitively clear from the simple observation that in order to incur a penalty at any range ri for a false negative, it has to be the case that ri &gt; ai.</S>
    <S sid="107" ssid="100">In order for this to be true, both the segment to the left and the segment to the right of the missed boundary have to be of size greater than k; otherwise, the penalty can only be equal to the size of the smaller segment.</S>
    <S sid="108" ssid="101">When Size(A)+Size(B) &lt; k, the penalty disappears completely, since then the probe&#8217;s interval is larger than the combined size of both segments, making it not sensitive enough to detect the false negative.</S>
    <S sid="109" ssid="102">It should be noted that fixing Problem 2 would at least partially fix this bias as well.</S>
    <S sid="110" ssid="103">Now, consider false positives (extraneous boundaries).</S>
    <S sid="111" ssid="104">For average segment size and a uniform distribution of false positives, the average penalty is k2, as described earlier.</S>
    <S sid="112" ssid="105">In general, in large enough segments, the penalty when the false positive is a distance d &lt; k from a boundary is d, and the penalty when the false positive is a distance d &gt; k from a boundary is k. Thus, for larger segments, the average penalty assuming a uniform distribution becomes larger, because there are more places in the segment that are at least k positions away from a boundary.</S>
    <S sid="113" ssid="106">The behavior at the edges of the segments remains the same, though, so the average penalty never reaches k. Now, consider what happens with smaller segments.</S>
    <S sid="114" ssid="107">Suppose we have a false positive in Segment A.</S>
    <S sid="115" ssid="108">As Size(A) decreases from 2k to k, the average false positive penalty decreases linearly with it, because when Size(A) decreases below 2k, the maximum distance any sentence can be from a boundary becomes less than k. Therefore, the A reference segmentation and five different hypothesized segmentations with different properties. maximum possible penalty for a false positive in A is less than k, and this number continues to decrease as Size(A) decreases.</S>
    <S sid="116" ssid="109">When Size(A) &lt; k, the false positive penalty disappears, for the same reason that the false negative penalty disappears for smaller segments.</S>
    <S sid="117" ssid="110">Again, fixing Problem 2 would go a long way toward eliminating this bias.</S>
    <S sid="118" ssid="111">Thus, errors in larger-than-average segments increase the penalty slightly (for false positives) or not at all (for false negatives) as compared to average size segments, while errors in smaller-than-average segments decrease the penalty significantly for both types of error.</S>
    <S sid="119" ssid="112">This means that as the variation of segment size increases, the metric becomes more lenient, since it severely underpenalizes errors in smaller segments, while not making up for this by overpenalizing errors in larger segments.</S>
    <S sid="120" ssid="113">Reconsider the segmentation made by Algorithm A-0 in Figure 1.</S>
    <S sid="121" ssid="114">In both cases of boundary assignment, Algorithm A-0 makes both a false positive and a false negative error, but places the boundary very close to the actual one.</S>
    <S sid="122" ssid="115">We will call this kind of error a near-miss error, distinct from a false positive or false negative error.</S>
    <S sid="123" ssid="116">Distinguishing this type of error from &#8220;pure&#8221; false positives better reflects the goal of creating a metric different from precision and recall, since it can be penalized less than a false negative or a false positive.</S>
    <S sid="124" ssid="117">Now, consider the algorithm segmentations shown in Figure 5.</S>
    <S sid="125" ssid="118">Each of the five algorithms makes a mistake either on the boundary between the first and second segment of the reference segmentation, or within the second segment.</S>
    <S sid="126" ssid="119">How should these various segmentations be penalized?</S>
    <S sid="127" ssid="120">In the analysis below, we assume an application for which it is important not to introduce spurious boundaries.</S>
    <S sid="128" ssid="121">These comparisons will most likely vary depending on the goals of the target application.</S>
    <S sid="129" ssid="122">Algorithm A-4 is arguably the worst of the examples, since it has a false positive and a false negative simultaneously.</S>
    <S sid="130" ssid="123">Algorithms A-0 and A-2 follow: they contain a pure false negative and false positive, respectively.</S>
    <S sid="131" ssid="124">Comparing Algorithms A-1 and A-3, we see that Algorithm A-3 is arguably better, because it recognizes that only one boundary is present rather than two.</S>
    <S sid="132" ssid="125">Algorithm A-1 does not recognize this, and inserts an extra segment.</S>
    <S sid="133" ssid="126">Even though Algorithm A-1 actually places a correct boundary, it also places an erroneous boundary, which, although close to the actual one, is still a false positive&#8212;in fact, a pure false positive.</S>
    <S sid="134" ssid="127">For this reason, Algorithm A-3 can be considered better than Algorithm A-1.</S>
    <S sid="135" ssid="128">Now, consider how Pk treats the five types of mistakes above.</S>
    <S sid="136" ssid="129">Again, assume the first and second segments in the reference segmentation are average size segments.</S>
    <S sid="137" ssid="130">Algorithm A-4 is penalized the most, as it should be.</S>
    <S sid="138" ssid="131">The penalty is as much as 2k if the false positive falls in the middle of Segment C, and it is &gt; k as long as the false positive is a distance &gt; 2k from the actual boundary between the first and second reference segments.</S>
    <S sid="139" ssid="132">The penalty is large because the metric catches both the false negative and the false positive errors.</S>
    <S sid="140" ssid="133">The segmentations assigned by Algorithms A-0 and A-2 are treated as discussed earlier in conjunction with Problem 1: the one assigned by Algorithm A-0 has a false negative and thus incurs a penalty of k, and the one assigned by Algorithm A-2 has a false positive, and thus incurs a penalty of &lt; k. Finally, consider the segmentations assigned by Algorithms A-1 and A-3, and suppose that both contain an incorrect boundary some small distance e from the actual one.</S>
    <S sid="141" ssid="134">Then the penalty for Algorithm A-1 is e, while the penalty for Algorithm A-3 is 2e.</S>
    <S sid="142" ssid="135">This should not be the case; Algorithm A-1 should be penalized more than Algorithm A-3, since a near-miss error is better than a pure false positive, even if it is close to the boundary.</S>
    <S sid="143" ssid="136">Pk is nonintuitive because it measures the probability that two sentences k units apart are incorrectly labeled as being in different segments, rather than directly reflecting the competence of the algorithm.</S>
    <S sid="144" ssid="137">Although perfect algorithms score 0, and various degenerate ones score 0.5, numerical interpretation and comparison are difficult because it is not clear how the scores are scaled.</S>
  </SECTION>
  <SECTION title="3." number="3">
    <S sid="145" ssid="1">It turns out that a simple change to the error metric algorithm remedies most of the problems described above, while retaining the desirable characteristic of penalizing near misses less than pure false positives and pure false negatives.</S>
    <S sid="146" ssid="2">The amended metric, which we call WindowDiff, works as follows: for each position of the probe, simply compare the number of reference segmentation boundaries that fall in this interval (ri) with the number of boundaries that are assigned by the algorithm (ai).</S>
    <S sid="147" ssid="3">The algorithm is penalized if ri =&#65533; ai (which is computed as |ri &#8722; ai |&gt; 0).</S>
    <S sid="148" ssid="4">More formally, where b(i, j) represents the number of boundaries between positions i and j in the text and N represents the number of sentences in the text.</S>
    <S sid="149" ssid="5">This approach clearly eliminates the asymmetry between the false positive and false negative penalties seen in the Pk metric.</S>
    <S sid="150" ssid="6">It also catches false positives and false negatives within segments of length less than k. To understand the behavior of WindowDiff with respect to the other problems, consider again the examples in Figure 5.</S>
    <S sid="151" ssid="7">This metric penalizes Algorithm A-4 (which contains both a false positive and a false negative) the most, assigning it a penalty of about 2k.</S>
    <S sid="152" ssid="8">Algorithms A-0, A-1, and A-2 receive the same penalty (about k), and Algorithm A-3 receives the smallest penalty (2e, where e is the offset from the actual boundary, presumed to be much smaller than k).</S>
    <S sid="153" ssid="9">Thus, although it makes the mistake of penalizing Algorithm A-1 as much as Algorithms A-0 and A-2, it correctly recognizes that the error made by Algorithm A-3 is a near miss and assigns it a smaller penalty than Algorithm A-1 or any of the others.</S>
    <S sid="154" ssid="10">We argue that this kind of error is less detrimental than the errors made by Pk.</S>
    <S sid="155" ssid="11">WindowDiff successfully distinguishes the near-miss error as a separate kind of error and penalizes it a different amount, something that Pk is unable to do.</S>
    <S sid="156" ssid="12">We explored a weighted version of WindowDiff, in which the penalty is weighted by the difference |ri &#8722; ai|.</S>
    <S sid="157" ssid="13">However, the results of the simulations were nearly identical with those of the nonweighted version of this metric, so we do not consider the weighted version further.</S>
  </SECTION>
  <SECTION title="4." number="4">
    <S sid="158" ssid="1">This section describes a set of simulations that verify the theoretical analysis of the Pk metric presented above.</S>
    <S sid="159" ssid="2">It also reports the results of simulating two alternatives, including the proposed solution just described.</S>
    <S sid="160" ssid="3">For the simulation runs described below, three metrics were implemented: In these studies, a single trial consists of generating a reference segmentation of 1,000 segments with some distribution, generating different experimental segmentations of a specific type 100 times, computing the metric based on the comparison of the reference and experimental segmentations, and averaging the 100 results.</S>
    <S sid="161" ssid="4">For example, we might generate a reference segmentation R, then generate 100 experimental segmentations that have false negatives with probability 0.5, and then compute the average of their Pk penalties.</S>
    <S sid="162" ssid="5">We carried out 10 such trials for each experiment and averaged the average penalties over these trials.</S>
    <S sid="163" ssid="6">The first set of tests was designed to test the metric&#8217;s performance on texts with different segment size distributions (Problem 3).</S>
    <S sid="164" ssid="7">We generated four sets of reference segmentations with segment size uniformly distributed between two numbers.</S>
    <S sid="165" ssid="8">Note that the units of segmentation are deliberately left unspecified.</S>
    <S sid="166" ssid="9">So a segment of size 25 can refer to 25 words, clauses, or sentences&#8212;whichever is applicable to the task under consideration.</S>
    <S sid="167" ssid="10">Also note that the same tests were run using larger segment sizes than those reported here, with the results remaining nearly identical.</S>
    <S sid="168" ssid="11">For these tests, the mean segment size was held constant at 25 for each set of reference segments, in order to produce distributions of segment size with the same means but different variances.</S>
    <S sid="169" ssid="12">The four ranges of segment sizes were (20, 30), (15, 35), (10, 40), and (5, 45).</S>
    <S sid="170" ssid="13">The results of these tests are shown in Table 1.</S>
    <S sid="171" ssid="14">The tests used the following types of experimental segmentations: The results indicate that variation in segment size does make a difference, but not a very big one.</S>
    <S sid="172" ssid="15">(As we will show, the differences are similar when we use a smaller probability of false negative/positive occurrence.)</S>
    <S sid="173" ssid="16">The Pk value for the (20, 30) range with FN segmentation is on average 0.245, and it decreases to 0.223 for the (5, 45) range.</S>
    <S sid="174" ssid="17">Similarly, the FP segmentation decreases from 0.128 for the (20, 30) range to 0.107 for the (5, 45) range, and the FNP segmentation decreases from 0.317 for the (20, 30) range to 0.268 for the (5, 45) range.</S>
    <S sid="175" ssid="18">Thus, variation in segment size has an effect on Pk, as predicted.</S>
    <S sid="176" ssid="19">Note that for false negatives, the Pk value for the (20, 30) range is not much different than for the (15, 35) range.</S>
    <S sid="177" ssid="20">This is expected since there are no segments of size less than k (12.5) in these conditions.</S>
    <S sid="178" ssid="21">For the (10, 40) range, the Pk value is slightly smaller; and for the (5, 45) range, it is smaller still.</S>
    <S sid="179" ssid="22">These results are to be expected, since more segments in these ranges will be of length less than k. For the FP segmentations, on the other hand, the decrease in Pk value is more pronounced, falling from 0.128 to 0.107 as the segment size range changes from (20, 30) to (5, 45).</S>
    <S sid="180" ssid="23">This is also consistent with our earlier analysis of the behavior of the metric on false positives as segment size decreases.</S>
    <S sid="181" ssid="24">Notice that the difference in Pk values between (15, 35) and (10, 40) is slightly larger than the other two differences.</S>
    <S sid="182" ssid="25">This happens because for segment sizes &lt; k, the false positive penalty disappears completely.</S>
    <S sid="183" ssid="26">The results for the FNP segmentation are consistent with what one would expect of a mix of the FN and FP segmentations.</S>
    <S sid="184" ssid="27">Several other observations can be made from Table 1.</S>
    <S sid="185" ssid="28">We can begin to make some judgments about how the metric performs on algorithms prone to different kinds of errors.</S>
    <S sid="186" ssid="29">First, Pk penalizes false negatives about twice as much as false positives, as predicted by our analysis.</S>
    <S sid="187" ssid="30">The experimental segmentations in Table 1a contain on average 500 false negatives, while the ones in Table 1b contain on average 500 false positives, but the penalty for the Table 1b segmentations is consistently about half that for those in Table 1a.</S>
    <S sid="188" ssid="31">Thus, algorithms prone to false positives are penalized less harshly than those prone to false negatives.</S>
    <S sid="189" ssid="32">The table also shows the performance of the two other metrics.</S>
    <S sid="190" ssid="33">Pk simply doubles the false positive penalty, while WD counts and compares the number of boundaries between the two ends of the probe, as described earlier.</S>
    <S sid="191" ssid="34">Both Pk and WD appear to solve the problem of underpenalizing false positives, but WD has the added benefit of being more stable across variations in segment size distribution.</S>
    <S sid="192" ssid="35">Thus, WD essentially solves Problems 1, 2, and 3.</S>
    <S sid="193" ssid="36">Table 1c shows that for the FNP segmentation (in which both false positives and false negatives occur), there is a disparity between the performances of Pk and WD.</S>
    <S sid="194" ssid="37">It appears that Pk is harsher in this situation.</S>
    <S sid="195" ssid="38">From the above discussion, we know that WD is more lenient in situations where a false negative and a false positive occur near each other (where &#8220;near&#8221; means within a distance of k2) than Pk is.</S>
    <S sid="196" ssid="39">However, Pk is more lenient for pure false positives that occur close to boundaries.</S>
    <S sid="197" ssid="40">Thus, it is not immediately clear why Pk is harsher in this situation, but a more detailed look provides the answer.</S>
    <S sid="198" ssid="41">Let us begin the analysis by trying to explain why Pk scores for the FNP segmentation make sense.</S>
    <S sid="199" ssid="42">The FNP segmentation places both false negatives and false positives with probability 0.5.</S>
    <S sid="200" ssid="43">Since we are working with reference segmentations of 1,000 segments, this means 500 missed boundaries and 500 incorrect boundaries.</S>
    <S sid="201" ssid="44">Since the probabilities are uniformly distributed across all segments and all boundaries, on average one would expect the following distribution of errors: A Type A error is a standard false positive, so the average penalty is k2.</S>
    <S sid="202" ssid="45">A Type B error is a standard false negative, so the average penalty is k. It remains to figure out what the average penalty is for a Type C error.</S>
    <S sid="203" ssid="46">Modeling the behavior of the metric, a Type C error occurrence in which a false positive and a false negative are some distance e &lt; k from each other incurs a penalty of 2e, where e is assigned for the false positive and another e is assigned for the false negative.</S>
    <S sid="204" ssid="47">This may range from 0 to 2k, and since error distribution is uniform, the penalty is k on average&#8212;the same as for a regular false negative.</S>
    <S sid="205" ssid="48">To translate this into actual values, we assume the metric is linear with respect to the number of errors (a reasonable assumption, supported by our experiments).</S>
    <S sid="206" ssid="49">Thus, if Pk outputs a penalty of p for 500 false negatives, it would have a penalty of p2 for 250 false negatives.</S>
    <S sid="207" ssid="50">Let a be the penalty for 500 Type A errors, b the penalty for 500 Type B errors, and c the penalty for 500 Type C errors; then the penalty for the FNP segmentation is p = a2 + b2 + c2.</S>
    <S sid="208" ssid="51">Assuming the metric is linear, we know that c = b = 2a (because Pk penalized false negatives twice as much as false positives on average).</S>
    <S sid="209" ssid="52">We can thus substitute either b or 2a for c. We choose to substitute 2a, because Pk is strongly affected by segment size variation for Type A and Type C errors, but not for Type B errors.</S>
    <S sid="210" ssid="53">Thus, replacing c with 2a is more accurate.</S>
    <S sid="211" ssid="54">Performing the substitution, we have p = 3 &#183; a2 + b2.</S>
    <S sid="212" ssid="55">We have a and b from the FP and FN data, respectively, so we can compute p. The results, arranged by segment size variation, are as follows: As can easily be seen, the estimate produced using this method is very similar to the actual Pk value.</S>
    <S sid="213" ssid="56">The same sort of analysis applies for Pk and WD.</S>
    <S sid="214" ssid="57">In Pk, Type A errors are penalized k on average, since the false positive penalty is doubled.</S>
    <S sid="215" ssid="58">Type B errors have an average penalty of k, as for Pk.</S>
    <S sid="216" ssid="59">Type C errors have an average penalty of 3e, where 2e is assigned for the false positive and e is assigned for the false negative.</S>
    <S sid="217" ssid="60">This means that the average penalty for a Type C error is 3 &#183; k2.</S>
    <S sid="218" ssid="61">Since we know that c = 1.5a by the linear metric assumption, we have p = a2 + b2 + 1.5 &#183; a2 = 5&#183; a4 + b2 (the choice of 1.5a over 1.5b was made for the same reason as the choice of 2a over b in the calculations for Pk).</S>
    <S sid="219" ssid="62">The results, arranged by segment size variation, are as follows: (20, 30) (15, 35) (10, 40) (5, 45) Estimate 0.443 0.429 0.401 0.378 Actual 0.446 0.432 0.403 0.375 Finally, WD incurs an average penalty of k for both Type A and Type B errors.</S>
    <S sid="220" ssid="63">For Type C errors, the penalty is 2e, so it is also k on average.</S>
    <S sid="221" ssid="64">Thus, we get p = a2 + 2b + a2 = a + b2.</S>
    <S sid="222" ssid="65">The results, arranged by segment size variation, are as follows: (20, 30) (15, 35) (10, 40) (5, 45) Estimate 0.363 0.364 0.359 0.355 Actual 0.376 0.370 0.357 0.343 These estimates do not correspond to the actual results quite as closely as the estimates for Pk and Pk did, but they are still very close.</S>
    <S sid="223" ssid="66">One reason why these estimates are a little less accurate is that for WD, Type C errors are more affected by variation in segment size than either Type A or Type B errors.</S>
    <S sid="224" ssid="67">This is clear from the fact that the decrease is greater in the actual data than in the estimate.</S>
    <S sid="225" ssid="68">Table 2 shows data similar to those of Table 1, but using two different probability values for error occurrence: 0.05 and 0.25.</S>
    <S sid="226" ssid="69">These results have the same tendencies as those shown above for p = 0.5.</S>
    <S sid="227" ssid="70">The second set of tests was designed to assess the performance of the metrics on algorithms prone to different kinds of errors.</S>
    <S sid="228" ssid="71">This would determine whether the metrics are consistent in applying penalties, or whether they favor certain kinds of errors over others.</S>
    <S sid="229" ssid="72">For these trials, we generated the reference segmentation using a uniform distribution of segment sizes in the (15, 35) range.</S>
    <S sid="230" ssid="73">We picked this range because it has reasonably high segment size variation, but segment size does not dip below k. For the Average error score for Pk, Pk, and WD over 10 trials of 100 measurements each, shown by segment size distribution range.</S>
    <S sid="231" ssid="74">(a) False negatives were placed with probability 0.05 at each boundary; (b) false positives were placed with probability 0.05, uniformly distributed within each segment; and (c) both false negatives and false positives were placed with probability 0.05.</S>
    <S sid="232" ssid="75">(d) False negatives were placed with probability 0.25 at each boundary; (e) false positives were placed with probability 0.25, uniformly distributed within each segment; and (f) both false negatives and false positives were placed with probability 0.25. reasons described above, this means the results will not be skewed by the sensitivity of Pk and Pk to segment size variations.</S>
    <S sid="233" ssid="76">The tests analyzed below were performed using the high error occurrence probabilities of 0.5, but similar results were obtained using probabilities of 0.25 and 0.05 as well.</S>
    <S sid="234" ssid="77">The following error distributions were used:1 occurring at each point with probability p = number of segments corresponds to a 0.5 probability value for each individual segment); The results are shown in Table 3.</S>
    <S sid="235" ssid="78">Pk penalizes FP2 less than FP1 and FP3, and FNP2 less than FNP1 and FNP3.</S>
    <S sid="236" ssid="79">This result is as expected.</S>
    <S sid="237" ssid="80">FP2 and FNP2 have false positives normally distributed around each boundary, which means that more of the false positives are close to the boundaries and thus are penalized less.</S>
    <S sid="238" ssid="81">If we made the standard deviation smaller, we would expect this difference to be even more apparent.</S>
    <S sid="239" ssid="82">Pk penalized FP2 and FNP2 the least in their respective categories, and FP1 and FNP1 the most, with FP3 and FNP3 falling in between.</S>
    <S sid="240" ssid="83">These results are as expected, for the same reasons as for Pk.</S>
    <S sid="241" ssid="84">The difference in the penalty for FP1 and FP3 (and FNP1 vs. FNP3)&#8212;for both Pk and Pk, but especially apparent for Pk&#8212;is interesting.</S>
    <S sid="242" ssid="85">In FP/FNP1, false positive probability is uniformly distributed throughout each segment, whereas in FP/FNP3, false positive probability is uniformly distributed throughout the entire document.</S>
    <S sid="243" ssid="86">Thus, the FP/FNP3 segmentations are more likely to have boundaries that are very close to each other, since they are not segment dependent, while FP/FNP1 are limited to at most one false positive per segment.</S>
    <S sid="244" ssid="87">This results in Pk assigning smaller penalties for FP/FNP3, since groups of false positives close together (to be more exact, within k sentences of each other) would be underpenalized.</S>
    <S sid="245" ssid="88">This difference is also present in the Pk results, but is about half for obvious reasons.</S>
    <S sid="246" ssid="89">WD penalized FP1 the most and FP3 the least among the FP segmentations.</S>
    <S sid="247" ssid="90">Among the FNP segmentations, FNP1 was penalized the most and FNP2 the least.</S>
    <S sid="248" ssid="91">To see why, we examine the results for the FP segmentations.</S>
    <S sid="249" ssid="92">WD penalizes pure false positives the same amount regardless of how close they are to a boundary; the only way false positives are underpenalized is if they occur in bunches.</S>
    <S sid="250" ssid="93">As mentioned earlier, this is most likely to happen in FP3.</S>
    <S sid="251" ssid="94">It is least likely to happen in FP1, since in FP1 there is a maximum of one false positive per segment, and this false positive is not necessarily close to a boundary.</S>
    <S sid="252" ssid="95">In FP2, false positives are also limited to one per segment, but they are also more likely to be close to boundaries.</S>
    <S sid="253" ssid="96">This increases the likelihood that 2 false positives will be within k sentences of each other and thus makes WD give a slightly lower score to the FP2 segmentation than to the FP1 segmentation.</S>
    <S sid="254" ssid="97">Now let us look at the FNP segmentations.</S>
    <S sid="255" ssid="98">FNP3 is penalized less than FNP1 for the same reason described above, and FNP2 is penalized even less than FNP3.</S>
    <S sid="256" ssid="99">The closer a Type C error is to the boundary, the lower the penalty.</S>
    <S sid="257" ssid="100">FNP2 has more errors distributed near the boundaries than the others: thus, the FNP2 segmentation is penalized less than either FNP1 or FNP3.</S>
    <S sid="258" ssid="101">The same tests were run for different error occurrence probabilities (p = 0.05 and p = 0.25), achieving results similar to those for p = 0.5 just described.</S>
    <S sid="259" ssid="102">There is a slight difference for the case of p = 0.05 because the error probability is too small for some of the trends to manifest themselves.</S>
    <S sid="260" ssid="103">In particular, the differences in the way WD treats the different segmentations disappear when the error probability is this small.</S>
    <S sid="261" ssid="104">We also performed a small set of tests to verify the theoretical finding that Pk and Pk overpenalize near-miss errors as compared with pure false positives, and that WD does the opposite, overpenalizing the pure false positives.</S>
    <S sid="262" ssid="105">Space limitations prevent detailed reporting of these results, but the simulations did indeed verify these expectations.</S>
  </SECTION>
  <SECTION title="5." number="5">
    <S sid="263" ssid="1">We have found that the Pk error metric for text segmentation algorithms is affected by the variation of segment size distribution, becoming slightly more lenient as the variance increases.</S>
    <S sid="264" ssid="2">It penalizes false positives significantly less than false negatives, particularly if the false positives are uniformly distributed throughout the document.</S>
    <S sid="265" ssid="3">It penalizes near-miss errors more than pure false positives of equal magnitude.</S>
    <S sid="266" ssid="4">Finally, it fails to take into account situations in which multiple boundaries occur between the two sides of the probe, and it often misses or underpenalizes mistakes in small segments.</S>
    <S sid="267" ssid="5">We proposed two modifications to tackle these problems.</S>
    <S sid="268" ssid="6">The first, which we call Pk, simply doubles the false positive penalty.</S>
    <S sid="269" ssid="7">This solves the problem of overpenalizing false negatives, but it is not effective at dealing with the other problems.</S>
    <S sid="270" ssid="8">The second, which we call WindowDiff (WD), counts the number of boundaries between the two ends of a fixed-length probe, and compares this number with the number of boundaries found in the same window of text for the reference segmentation.</S>
    <S sid="271" ssid="9">This modification addresses all of the problems listed above.</S>
    <S sid="272" ssid="10">WD is only slightly affected by variation of segment size distribution, gives equal weight to the false positive penalty and the false negative penalty, is able to catch mistakes in small segments just as well as mistakes in large segments, and penalizes near-miss errors less than pure false positives of equal magnitude.</S>
    <S sid="273" ssid="11">However, it has some problems of its own.</S>
    <S sid="274" ssid="12">WD penalizes all pure false positives the same amount regardless of how close they are to an actual boundary.</S>
    <S sid="275" ssid="13">It is not clear whether this is a good thing or not, but it seems to be preferable to overpenalizing near misses.</S>
    <S sid="276" ssid="14">The discussion above addresses Problems 1 through 4 but does not address Problem 5: how does one interpret the values produced by the metric?</S>
    <S sid="277" ssid="15">From the tests we have run, it appears that the WD metric grows in a roughly linear fashion with the difference between the reference and the experimental segmentations.</S>
    <S sid="278" ssid="16">In addition, we feel that WD is a more meaningful metric than Pk.</S>
    <S sid="279" ssid="17">Comparing two stretches of text to see how many discrepancies occur between the reference and the algorithm&#8217;s result seems more intuitive than determining how often two text units are incorrectly labeled as being in different segments.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="6">
    <S sid="280" ssid="1">This work was completed while the second author was a visiting professor at Harvard University.</S>
    <S sid="281" ssid="2">Both authors thank Barbara Grosz and Stuart Shieber, without whom this work would not have happened, and Freddy Choi for some helpful explanations.</S>
    <S sid="282" ssid="3">They would also like to thank the anonymous reviewers for their valuable comments.</S>
    <S sid="283" ssid="4">Partial support for the research reported in this paper was provided by National Science Foundation Grants IRI-9618848 and CDA-94-01024.</S>
  </SECTION>
</PAPER>
