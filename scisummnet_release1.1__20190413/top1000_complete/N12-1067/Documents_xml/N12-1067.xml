<PAPER>
  <S sid="0">Better Evaluation for Grammatical Error Correction</S>
  <ABSTRACT>
    <S sid="1" ssid="1">We present a novel method for evaluating grammatical error correction.</S>
    <S sid="2" ssid="2">The core of method, which we call is an algorithm for efficiently computing the sequence of phrase-level edits between a source sentence and a system hypothesis that achieves the highest overlap with the goldstandard annotation.</S>
    <S sid="3" ssid="3">This optimal edit seis subsequently scored using mea- We test our on the Helping Our Own (HOO) shared task data and show that our method results in more accurate evaluation for grammatical error correction.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="4" ssid="1">Progress in natural language processing (NLP) research is driven and measured by automatic evaluation methods.</S>
    <S sid="5" ssid="2">Automatic evaluation allows fast and inexpensive feedback during development, and objective and reproducible evaluation during testing time.</S>
    <S sid="6" ssid="3">Grammatical error correction is an important NLP task with useful applications for second language learning.</S>
    <S sid="7" ssid="4">Evaluation for error correction is typically done by computing F1 measure between a set of proposed system edits and a set of humanannotated gold-standard edits (Leacock et al., 2010).</S>
    <S sid="8" ssid="5">Unfortunately, evaluation is complicated by the fact that the set of edit operations for a given system hypothesis is ambiguous.</S>
    <S sid="9" ssid="6">This is due to two reasons.</S>
    <S sid="10" ssid="7">First, the set of edits that transforms one string into another is not necessarily unique, even at the token level.</S>
    <S sid="11" ssid="8">Second, edits can consist of longer phrases which introduce additional ambiguity.</S>
    <S sid="12" ssid="9">To see how this can affect evaluation, consider the following source sentence and system hypothesis from the recent Helping Our Own (HOO) shared task (Dale and Kilgarriff, 2011) on grammatical error correction: Source: Our baseline system feeds word into PB-SMT pipeline.</S>
    <S sid="13" ssid="10">Hypot.</S>
    <S sid="14" ssid="11">: Our baseline system feeds a word into PB-SMT pipeline.</S>
    <S sid="15" ssid="12">The HOO evaluation script extracts the system edit (c &#8212;* a), i.e., inserting the article a.</S>
    <S sid="16" ssid="13">Unfortunately, the gold-standard annotation instead contains the edits (word &#8212;* {a word, words}).</S>
    <S sid="17" ssid="14">Although the extracted system edit results in the same corrected sentence as the first gold-standard edit option, the system hypothesis was considered to be invalid.</S>
    <S sid="18" ssid="15">In this work, we propose a method, called MaxMatch (M2), to overcome this problem.</S>
    <S sid="19" ssid="16">The key idea is that if there are multiple possible ways to arrive at the same correction, the system should be evaluated according to the set of edits that matches the gold-standard as often as possible.</S>
    <S sid="20" ssid="17">To this end, we propose an algorithm for efficiently computing the set of phrase-level edits with the maximum overlap with the gold standard.</S>
    <S sid="21" ssid="18">The edits are subsequently scored using F1 measure.</S>
    <S sid="22" ssid="19">We test our method in the context of the HOO shared task and show that our method results in a more accurate evaluation for error correction.</S>
    <S sid="23" ssid="20">The remainder of this paper is organized as follows: Section 2 describes the proposed method; Section 3 presents experimental results; Section 4 discusses some details of grammar correction evaluation; and Section 5 concludes the paper.</S>
  </SECTION>
  <SECTION title="2 Method" number="2">
    <S sid="24" ssid="1">We begin by establishing some notation.</S>
    <S sid="25" ssid="2">We consider a set of source sentences 5 = {s1, ... , sn} together with a set of hypotheses H = {h1, ... , hn} generated by an error correction system.</S>
    <S sid="26" ssid="3">Let G = {g1, ... , gn} be the set of gold standard annotations for the same sentences.</S>
    <S sid="27" ssid="4">Each annotation gi = {g1i , ... , gr i } is a set of edits.</S>
    <S sid="28" ssid="5">An edit is a triple (a, b, C), consisting of: The remainder of this section describes a method for solving these two steps.</S>
    <S sid="29" ssid="6">We start by describing how to construct an edit lattice from a source-hypothesis pair.</S>
    <S sid="30" ssid="7">Then, we show that finding the optimal sequence of edits is equivalent to solving a shortest path search through the lattice.</S>
    <S sid="31" ssid="8">Finally, we describe how to evaluate the edits using F1 measure.</S>
    <S sid="32" ssid="9">We start from the well-established Levenshtein distance (Levenshtein, 1966), which is defined as the minimum number of insertions, deletions, and substitutions needed to transform one string into another.</S>
    <S sid="33" ssid="10">The Levenshtein distance between a source sentence si = s1i,...,ski and a hypothesis hi = h1i, ... , hl i can be efficiently computed using a two dimensional matrix that is filled using a classic dynamic programming algorithm.</S>
    <S sid="34" ssid="11">We assume that both si and hi have been tokenized.</S>
    <S sid="35" ssid="12">The matrix for the example from Section 1 is shown in Figure 1.</S>
    <S sid="36" ssid="13">By performing a simple breadth-first search, similar to the Viterbi algorithm, we can extract the lattice of all shortest paths that lead from the top-left corner to the bottom-right corner of the Levenshtein matrix.</S>
    <S sid="37" ssid="14">Each vertex in the lattice corresponds to a cell in the Levenshtein matrix, and each edge in the lattice corresponds to an atomic edit operation: inserting a token, deleting a token, substituting a token, or leaving a token unchanged.</S>
    <S sid="38" ssid="15">Each path through the lattice corresponds to a shortest sequence of edits that transform si into hi.</S>
    <S sid="39" ssid="16">We assign a unit cost to each edge in the lattice.</S>
    <S sid="40" ssid="17">We have seen that annotators can use longer phrases and that phrases can include unchanged words from the context, e.g., the gold edit from the example in Section 1 is (4, 5, word, {a word, words}).</S>
    <S sid="41" ssid="18">However, it seems unrealistic to allow an arbitrary number of unchanged words in an edit.</S>
    <S sid="42" ssid="19">In particular, we want to avoid very large edits that cover complete sentences.</S>
    <S sid="43" ssid="20">Therefore, we limit the number of unchanged words by a parameter u.</S>
    <S sid="44" ssid="21">To allow for phrase-level edits, we add transitive edges to the lattice as long as the number of unchanged words in the newly added edit is not greater than u and the edit changes at least one word.</S>
    <S sid="45" ssid="22">Let e1 = (a1, b1, C1) and e2 = (a2, b2, C2) be two edits corresponding to adjacent edges in the lattice, with the first end offset b1 being equal to the second start offset a2.</S>
    <S sid="46" ssid="23">We can combine them into a new edit e3 = (a1, b2, C1 + C2), where C1 + C2 is the concatenation of strings C1 and C2.</S>
    <S sid="47" ssid="24">The cost of a transitive edge is the sum of the costs of its parts.</S>
    <S sid="48" ssid="25">The lattice extracted from the example sentence is shown in Figure 2.</S>
    <S sid="49" ssid="26">Our goal is to find the sequence of edits ei with the maximum overlap with the gold standard.</S>
    <S sid="50" ssid="27">Let L = (V, E) be the edit lattice graph from the last section.</S>
    <S sid="51" ssid="28">We change the cost of each edge whose corsystem feeds a word into PB-SMT pipeline . responding edit has a match in the gold standard to &#8722;(u + 1) &#215; |E|.</S>
    <S sid="52" ssid="29">An edit e matches a gold edit g iff they have the same offsets and e&#8217;s correction is included in g: Then, we perform a single-source shortest path search with negative edge weights from the start to the end vertex1.</S>
    <S sid="53" ssid="30">This can be done efficiently, for example with the Bellman-Ford algorithm (Cormen et al., 2001).</S>
    <S sid="54" ssid="31">As the lattice is acyclic, the algorithm is guaranteed to terminate and return a shortest path.</S>
    <S sid="55" ssid="32">Theorem 1.</S>
    <S sid="56" ssid="33">The set of edits corresponding to the shortest path has the maximum overlap with the gold standard annotation.</S>
    <S sid="57" ssid="34">Proof.</S>
    <S sid="58" ssid="35">Let e = e1, ... , ek be the edit sequence corresponding to the shortest path and let p be the number of matched edits.</S>
    <S sid="59" ssid="36">Assume that there exists another edit sequence e0 with higher total edge weights but p0 &gt; p matching edits.</S>
    <S sid="60" ssid="37">Then we have where q and q0 denote the combined cost of all nonmatching edits in the two paths, respectively.</S>
    <S sid="61" ssid="38">Because p0 &#8722; p &#8805; 1, the right hand side is at most &#8722;(u + 1)|E|.</S>
    <S sid="62" ssid="39">Because q and q0 are positive and bounded by (u + 1)|E|, the left hand side cannot be smaller than or equal to &#8722;(u + 1)|E|.</S>
    <S sid="63" ssid="40">This is a contradiction.</S>
    <S sid="64" ssid="41">Therefore there cannot exist such an edit sequence e0, and e is the sequence with the maximum overlap with the gold-standard annotation.</S>
    <S sid="65" ssid="42">What is left to do is to evaluate the set of edits with respect to the gold standard.</S>
    <S sid="66" ssid="43">This is done by computing precision, recall, and F1 measure (van Rijsbergen, 1979) between the set of system edits {e1, ... , en} and the set of gold edits {g1, ... , gn} for all sentences where we define the intersection between ei and gi as ei &#8745; gi = {e &#8712; ei  |&#8707; g &#8712; gi(match(e, g))}.</S>
    <S sid="67" ssid="44">(6)</S>
  </SECTION>
  <SECTION title="3 Experiments and Results" number="3">
    <S sid="68" ssid="1">We experimentally test our M2 method in the context of the HOO shared task.</S>
    <S sid="69" ssid="2">The HOO test data2 consists of text fragments from NLP papers together with manually-created gold-standard corrections (see (Dale and Kilgarriff, 2011) for details).</S>
    <S sid="70" ssid="3">We test our method by re-scoring the best runs of the participating teams3 in the HOO shared task with our M2 scorer and comparing the scores with the official HOO scorer, which simply uses GNU wdiff4 to extract system edits.</S>
    <S sid="71" ssid="4">We obtain each system&#8217;s output and segment it at the sentence level according to the gold standard sentence segmentation.</S>
    <S sid="72" ssid="5">The source sentences, system hypotheses, and corrections are tokenized using the Penn Treebank standard (Marcus et al., 1993).</S>
    <S sid="73" ssid="6">The character edit offsets are automatically converted to token offsets.</S>
    <S sid="74" ssid="7">We set the parameter u to 2, allowing up to two unchanged words per edit.</S>
    <S sid="75" ssid="8">The results are shown in Table 1.</S>
    <S sid="76" ssid="9">Note that the M2 scorer and the HOO scorer adhere to the same score definition and only differ in the way the system edits are computed.</S>
    <S sid="77" ssid="10">We can see that the M2 scorer results in higher scores than the official scorer for all systems, showing that the official scorer missed some valid edits.</S>
    <S sid="78" ssid="11">For example, the M2 scorer finds 155 valid edits for the UI system compared to 141 found by the official scorer, and 83 valid edits for the NU system, compared to 78 by the official scorer.</S>
    <S sid="79" ssid="12">We manually inspect the output of the scorers and find that the M2 scorer indeed extracts the correct edits matching the gold standard where possible.</S>
    <S sid="80" ssid="13">Examples are shown in Table 2.</S>
  </SECTION>
  <SECTION title="4 Discussion" number="4">
    <S sid="81" ssid="1">The evaluation framework proposed in this work differs slightly from the one in the HOO shared task.</S>
    <S sid="82" ssid="2">Sentence-by-sentence.</S>
    <S sid="83" ssid="3">We compute the edits between source-hypothesis sentence pairs, while the HOO scorer computes edits at the document level.</S>
    <S sid="84" ssid="4">As the HOO data comes in a sentencesegmented format, both approaches are equivalent, while sentence-by-sentence is easier to work with.</S>
    <S sid="85" ssid="5">Token-level offsets.</S>
    <S sid="86" ssid="6">In our work, the start and end of an edit are given as token offsets, while the HOO data uses character offsets.</S>
    <S sid="87" ssid="7">Character offsets make the evaluation procedure very brittle as a small change, e.g., an additional whitespace character, will affect all subsequent edits.</S>
    <S sid="88" ssid="8">Character offsets also introduce ambiguities in the annotation, e.g., whether a comma is part of the preceding token.</S>
    <S sid="89" ssid="9">Alternative scoring.</S>
    <S sid="90" ssid="10">The HOO shared task defines three different scores: detection, recognition, and correction.</S>
    <S sid="91" ssid="11">Effectively, all three scores are F1 measures and only differ in the conditions on when an edit is counted as valid.</S>
    <S sid="92" ssid="12">Additionally, each score is reported under a &#8220;with bonus&#8221; alternative, where a system receives rewards for missed optional edits.</S>
    <S sid="93" ssid="13">The F1 measure defined in Section 2.3 is equivalent to correction without bonus.</S>
    <S sid="94" ssid="14">Our method can be used to compute detection and recognition scores and scores with bonus as well.</S>
  </SECTION>
  <SECTION title="5 Conclusion" number="5">
    <S sid="95" ssid="1">We have presented a novel method, called MaxMatch (M2), for evaluating grammatical error correction.</S>
    <S sid="96" ssid="2">Our method computes the sequence of phrase-level edits that achieves the highest overlap with the gold-standard annotation.</S>
    <S sid="97" ssid="3">Experiments on the HOO data show that our method overcomes deficiencies in the current evaluation method.</S>
    <S sid="98" ssid="4">The M2 scorer is available for download at http://nlp.comp.nus.edu.sg/software/.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="6">
    <S sid="99" ssid="1">We thank Chang Liu for comments on an earlier draft.</S>
    <S sid="100" ssid="2">This research is supported by the Singapore National Research Foundation under its International Research Centre @ Singapore Funding Initiative and administered by the IDM Programme Office.</S>
  </SECTION>
</PAPER>
