<PAPER>
  <S sid="0">Coping With Syntactic Ambiguity Or How To Put The Block In The Box On The Table</S>
  <ABSTRACT>
    <S sid="1" ssid="1">we construct a table so that the entry in the tells the parser how to parse i occurrences of 9.</S>
    <S sid="2" ssid="2">An Example Suppose for example that we were given the following grammar: (40a) S NP VP ADJS (40b) S V NP (PP) ADJS ADJS (40c) VP -0.</S>
    <S sid="3" ssid="3">V NP (PP) ADJS (40d) PP P NP (40e) NP NI NP PP ADJS adj ADJS I (In this example we will assume no lexical ambiguity V, P, inspection, we notice that NP are Catalan grammars and that ADJS is a Step grammar.</S>
    <S sid="4" ssid="4">PP = E i&gt;0 NP = N ADJS = With these observations, the parser can process PPs, and by counting the number of occurrencof terminal symbols and looking up numbers in the appropriate tables.</S>
    <S sid="5" ssid="5">We now substitute (41a-c) into (40c).</S>
    <S sid="6" ssid="6">(42) VP = V NP (1 + PP)ADJS V (N E N)')(E (E and simplify the convolution of the two Catalan functions VP = V (N E adj') so that the parser can also find VPs by just counting coccurrences of terminal symbols.</S>
    <S sid="7" ssid="7">Now we simplify so that can also be parsed by just counting occurrences of terminal symbols. translate (40a-b) into the equation: (44) S = NP VP ADJS + V NP (1+PP) ADJS ADJS and then expand VP using (42) (45) S = NP (V NP (1+PP) ADJS) ADJS + V NP (1+PP) ADJS ADJS and factor S = (NP + 1) V NP (1+PP) That can be simplified considerably because NP (1 + PP) = N E E N E and (48) = E adj' E adj' = (i + so that S = (N E + 1) N E Cat.</S>
    <S sid="8" ssid="8">14- (i + has the following Jump Jump &#8226; &#8226; &#8226; &#8226; &#8226; (1, (i + 1+ (50) The entire example grammar has now been compiled into a form that is easier for parsing.</S>
    <S sid="9" ssid="9">This formula says that sentences are all of the form: (51) S (N (P N)*) V N (P N)* adj* which could be recognized by the following finite state machine: (52) &#8250;c) Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguity Furthermore, the number of parse trees for a given input sentence can be found by multiplying three numbers: (a) the Catalan of the number of P N's before the verb, (b) the Catalan of one more than the number of P N's after the verb, and (c) the ramp of the number of adj's.</S>
    <S sid="10" ssid="10">For example, the sentence (53) The man on the hill saw the boy with a telescope yesterday in the morning.</S>
    <S sid="11" ssid="11">Cat * * 3 = 6 parses.</S>
    <S sid="12" ssid="12">That is, there is one way to parse &amp;quot;the man on the hill,&amp;quot; two ways to parse &amp;quot;saw the boy with a telescope&amp;quot; (&amp;quot;telescope&amp;quot; is either a complement of &amp;quot;see&amp;quot; as in (54a-c) or is attached to &amp;quot;boy&amp;quot; as in (54d-f)), and three ways to parse the adjuncts (they could both attach to the S (54a,d), or they could both attach to the VP (54b,e), or they could split (54c,f)).</S>
    <S sid="13" ssid="13">(54a) [The man on the hill [saw the boy with a telescope] [yesterday in the morning.]]</S>
    <S sid="14" ssid="14">(54b) The man on the hill [[saw the boy with a telescope] [yesterday in the morning.]]</S>
    <S sid="15" ssid="15">(54c) The man on the hill [[saw the boy with a telescope] yesterday] in the morning.</S>
    <S sid="16" ssid="16">(54d) [The man on the hill saw [the boy with a telescope] [yesterday in the morning.]]</S>
    <S sid="17" ssid="17">(54e) The man on the hill [saw [the boy with a telescope] [yesterday in the morning.]]</S>
    <S sid="18" ssid="18">(54f) The man on the hill [saw [the boy with a telescope] yesterday] in the morning.</S>
    <S sid="19" ssid="19">All and only these possibilities are permitted by the grammar.</S>
    <S sid="20" ssid="20">10.</S>
    <S sid="21" ssid="21">Conclusion We began our discussion with the observation that certain grammars are &amp;quot;every way ambiguous&amp;quot; and suggested that this observation could lead to improved parsing performance.</S>
    <S sid="22" ssid="22">Catalan grammars were then introduced to remedy the situation so that the processor can delay attachment decisions until it discovers some more useful constraints.</S>
    <S sid="23" ssid="23">Until such time, the processor can do little more than note that the input sentence is &amp;quot;every way ambiguous.&amp;quot; We suggested that a table lookup scheme might be an effective method to implement such a processor.</S>
    <S sid="24" ssid="24">We then introduced rules for combining primitive grammars, such as Catalan grammars, into composite grammars.</S>
    <S sid="25" ssid="25">This linear systems view &amp;quot;bundles up&amp;quot; all the parse trees into a single concise description capable of telling us everything we might want to know about the parses (including how much it might cost to ask a particular question).</S>
    <S sid="26" ssid="26">This abstract view of ambiguity enables us to ask questions in the most convenient order, and to delay asking until it is clear that the pay-off will exceed the cost.</S>
    <S sid="27" ssid="27">This abstraction was strongly influenced by the notion of binding.</S>
    <S sid="28" ssid="28">We have presented combination rules in three different representation systems: power series, ATNs, and context-free grammars, each of which contributed its own insights.</S>
    <S sid="29" ssid="29">Power series are convenient for defining the algebraic operations, ATNs are most suited for discussing implementation issues, and context-free grammars enable the shortest derivations.</S>
    <S sid="30" ssid="30">Perhaps the following quotation best summarizes our motivation for alternating among these three representation systems: thing or idea seems meaningful only when we have different ways to represent it &#8212; different perspectives and different associations.</S>
    <S sid="31" ssid="31">Then you can turn it around in your mind, so to speak; however, it seems at the moment you can see it another way; you never come to a full stop.</S>
    <S sid="32" ssid="32">(Minsky 1981, p. 19) In each of these representation schemes, we have introduced five primitive grammars: Catalan, Unit Step, 1, and 0, and terminals; and four composition rules: addition, subtraction, multiplication, and division.</S>
    <S sid="33" ssid="33">We have seen that it is often possible to employ these analytic tools in order to re-organize (compile) the grammar into a form more suitable for processing efficiently.</S>
    <S sid="34" ssid="34">We have identified certain where the ambiguity is combinatoric, and have sketched a few modifications to the grammar that enable processing to proceed in a more efficient manner.</S>
    <S sid="35" ssid="35">In particular, we have observed it to be important for the grammar to avoid referencing quantities that are not easily determined, such as the dividing point between a noun phrase and a prepositional phrase as in (55) Put the block in the box on the table in the kitchen ... We have seen that the desired re-organization can be achieved by taking advantage of the fact that the autoconvolution of a Catalan series produces another Caseries.</S>
    <S sid="36" ssid="36">This reduced processing time from to almost linear time.</S>
    <S sid="37" ssid="37">Similar analyses have been discussed for a number of lexically and structurally ambiguous constructions, culminating with the example in section 9, where we transformed a grammar into a form that could be parsed by a single left-to-right pass over the terminal elements.</S>
    <S sid="38" ssid="38">Currently, these grammar reformulations have to be performed by hand.</S>
    <S sid="39" ssid="39">It ought to be possible to automate this process so that the reformulations could be performed by a grammar compiler.</S>
    <S sid="40" ssid="40">We leave this project open for future research.</S>
    <S sid="41" ssid="41">11.</S>
    <S sid="42" ssid="42">Acknowledgments We would like to thank Jon Allen, Sarah Ferguson, Lowell Hawkinson, Kris Halvorsen, Bill Long, Mitch Marcus, Rohit Parikh, and Peter Szolovits for their very useful comments on earlier drafts.</S>
    <S sid="43" ssid="43">We would Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 especially like to thank Bill Martin for initiating the project.</S>
  </ABSTRACT>
  <SECTION title="Cambridge, MA 02139" number="1">
    <S sid="44" ssid="1">Sentences are far more ambiguous than one might have thought.</S>
    <S sid="45" ssid="2">There may be hundreds, perhaps thousands, of syntactic parse trees for certain very natural sentences of English.</S>
    <S sid="46" ssid="3">This fact has been a major problem confronting natural language processing, especially when a large percentage of the syntactic parse trees are enumerated during semantic/pragmatic processing.</S>
    <S sid="47" ssid="4">In this paper we propose some methods for dealing with syntactic ambiguity in ways that exploit certain regularities among alternative parse trees.</S>
    <S sid="48" ssid="5">These regularities will be expressed as linear combinations of ATN networks, and also as sums and products of formal power series.</S>
    <S sid="49" ssid="6">We believe that such encoding of ambiguity will enhance processing, whether syntactic and semantic constraints are processed separately in sequence or interleaved together.</S>
    <S sid="50" ssid="7">Most parsers find the set of parse trees by starting with the empty set and adding to it each time they find a new possibility.</S>
    <S sid="51" ssid="8">We make the observation that in certain situations it would be much more efficient to work in the other direction, starting from the universal set (i.e, the set of all binary trees) and ruling trees out when the parser decides that they cannot be parses.</S>
    <S sid="52" ssid="9">Ruling-out is easier when the set of parse trees is closer to the universal set and ruling-in is easier when the set of parse trees is closer to the empty set.</S>
    <S sid="53" ssid="10">Rulingout is particularly suited for &amp;quot;every way ambiguous&amp;quot; constructions such as prepositional phrases that have just as many parse trees as there are binary trees over the terminal elements.</S>
    <S sid="54" ssid="11">Since every tree is a parse, the parser doesn't have to rule any of them out.</S>
    <S sid="55" ssid="12">In some sense, this is a formalization of an idea that has been in the literature for some time.</S>
    <S sid="56" ssid="13">That is, it has been noticed for a long time that these sorts of very ambiguous constructions are very difficult for most parsing algorithms, but (apparently) not for people.</S>
    <S sid="57" ssid="14">This observation has led some researchers to hypothesize additional parsing mechanisms, such as pseudo-attachment (Church 1980, pp.</S>
    <S sid="58" ssid="15">65-71)2 and permanent predictable ambiguity (Sager 1973), so that the parser could &amp;quot;attach all ways&amp;quot; in a single step.</S>
    <S sid="59" ssid="16">However, these mechanisms have always lacked a precise interpretation; we will present a much more formal way of coping with &amp;quot;every way ambiguous&amp;quot; grammars, defined in terms of Catalan numbers (Knuth 1975, pp.</S>
    <S sid="60" ssid="17">388-389, 531-533).</S>
    <S sid="61" ssid="18">Sentences are far more ambiguous than one might have thought.</S>
    <S sid="62" ssid="19">Our experience with the EQSP parser (Martin, Church, and Patil 1981) indicates that there may be hundreds, perhaps thousands, of syntactic parse trees for certain very natural sentences of English.</S>
    <S sid="63" ssid="20">For example, consider the following sentence with two prepositional phrases: 2 The idea of pseudo-attachment was first proposed by Marcus (private communication), though Marcus does not accept the formulation in Church 1980.</S>
    <S sid="64" ssid="21">Copyright 1982 by the Association for Computational Linguistics.</S>
    <S sid="65" ssid="22">Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page.</S>
    <S sid="66" ssid="23">To copy otherwise, or to republish, requires a fee and/or specific permission.</S>
    <S sid="67" ssid="24">These syntactic ambiguities grow &amp;quot;combinatorially&amp;quot; with the number of prepositional phrases.</S>
    <S sid="68" ssid="25">For example, when a third PP is added to the sentence above, there are five interpretations: When a fourth PP is added, there are fourteen trees, and so on.</S>
    <S sid="69" ssid="26">This sort of combinatoric ambiguity has been a major problem confronting natural language processing.</S>
    <S sid="70" ssid="27">In this paper we propose some methods for dealing with syntactic ambiguity in ways that take advantage of regularities among the alternative parse trees.</S>
    <S sid="71" ssid="28">In particular, we observe that enumerating the parse trees as above fails to capture the important generalization that prepositional phrases are &amp;quot;every way ambiguous,&amp;quot; or more precisely, the set of parse trees over i PPs is the same as the set of binary trees that can be constructed over i terminal elements.</S>
    <S sid="72" ssid="29">Notice, for example, that there are two possible binary trees over three elements, corresponding to (2a) and (2b), respectively, and that there are five binary trees over four elements corresponding to (3a)&#8212;(3c), respectively.</S>
    <S sid="73" ssid="30">PPs, adjuncts, conjuncts, noun-noun modification, stack relative clauses, and other &amp;quot;every way ambiguous&amp;quot; constructions will be treated as primitive objects.</S>
    <S sid="74" ssid="31">They can be combined in various ways to produce composite constructions, such as lexical ambiguity, which may also be very ambiguous but not necessarily &amp;quot;every way ambiguous.&amp;quot; Lexical ambiguity, for example, will be analyzed as the sum of its senses, or in flow graph terminology (Oppenheim and Schafer 1975) as a parallel connection of its senses.</S>
    <S sid="75" ssid="32">Structural ambiguity, on the other hand, will be analyzed as the product of its components, or in flow graph terminology as a series connection.</S>
  </SECTION>
  <SECTION title="2." number="2">
    <S sid="76" ssid="1">This section will make the linear systems analogy more precise by relating context-free grammars to formal power series (polynominals).</S>
    <S sid="77" ssid="2">Formal power series are a well-known device in the formal language literature (e.g., Salomaa 1973) for developing the algebraic properties of context-free grammars.</S>
    <S sid="78" ssid="3">We introduce them here to establish a formal basis for our upcoming discussion of processing issues.</S>
    <S sid="79" ssid="4">The power series for grammar (5a) is (5b).</S>
    <S sid="80" ssid="5">Each term consists of a sentence generated by the grammar and an ambiguity coefficient3 which counts how many ways the sentence can be generated.</S>
    <S sid="81" ssid="6">For example, the sentence &amp;quot;John&amp;quot; has one parse tree and so on.</S>
    <S sid="82" ssid="7">The reader can verify for himself that &amp;quot;John and John and John and John and John&amp;quot; has fourteen trees.</S>
    <S sid="83" ssid="8">Note that the power series encapsulates the ambiguity response of the system (grammar) to all possible input sentences.</S>
    <S sid="84" ssid="9">In this way, the power series is analogous to the impulse response in electrical engineering, which encapsulates the response of the system (circuit) to all possible input frequencies.</S>
    <S sid="85" ssid="10">(Ambiguity coefficients bear a strong resemblance to frequency coefficients in Fourier analysis.)</S>
    <S sid="86" ssid="11">All of these transformed representation systems (e.g., power series, impulse response, and Fourier series) provide a complete description of the system with no loss of information4 (and no heuristic approximations, for example, search strategies (Kaplan 1972)).</S>
    <S sid="87" ssid="12">Transforms are often very useful because they provide a different point of view.</S>
    <S sid="88" ssid="13">Certain observations are more easily seen in the transform space than in the original space, and vice versa.</S>
    <S sid="89" ssid="14">This paper will discuss several ways to generate the power series.</S>
    <S sid="90" ssid="15">Initially let us consider successive approximation.</S>
    <S sid="91" ssid="16">Of all the techniques to be presented here, successive approximations most closely resembles the approach taken by most current chart parsers including EQSP (Martin, Church, and Patil 1981).</S>
    <S sid="92" ssid="17">The alternative approaches take advantage of certain regularities in the power series in order to produce the same results more efficiently.</S>
    <S sid="93" ssid="18">Successive approximation works as follows.</S>
    <S sid="94" ssid="19">First we translate grammar (5a) into the equation: where &amp;quot;+&amp;quot; connects two ways of generating an NP and &amp;quot;.&amp;quot; concatenates two parts of an NP.</S>
    <S sid="95" ssid="20">In some sense, we want to &amp;quot;solve&amp;quot; this equation for NP.</S>
    <S sid="96" ssid="21">This can be accomplished by refining successive approximations.</S>
    <S sid="97" ssid="22">An initial approximation NP0 is formed by taking NP to be the empty language, Then we form the next approximation by substituting the previous approximation into equation (7), and simplifying according to the usual rules of algebra (e.g., assuming distributivity, associativity,5 identity element, and zero element).</S>
    <S sid="98" ssid="23">4 This needs a qualification.</S>
    <S sid="99" ssid="24">It is true that the power series provides a complete description of the ambiguity response to any input sentence.</S>
    <S sid="100" ssid="25">However, the power series representation may be losing some information that would be useful for parsing.</S>
    <S sid="101" ssid="26">In particular, there might be some cases where it is impossible to recover the parse trees exactly, as we will see, though this may not be too serious a problem for many practical applications.</S>
    <S sid="102" ssid="27">That is, it is often possible to recover most (if not all) of the structure, which may be adequate for many applications.</S>
    <S sid="103" ssid="28">5 The careful reader may correctly object to this assumption.</S>
    <S sid="104" ssid="29">We include it here for expository convenience, as it greatly simplifies the derivations though it should be noted that many of the results could be derived without the assumption.</S>
    <S sid="105" ssid="30">Furthermore, this assumption is valid for counting ambiguity.</S>
    <S sid="106" ssid="31">That is, IA &#8226; BI * ICI = IAI * I8 &#8226; CI, where A, B, and C are sets of trees and Eventually, we have NP expressed as an infinitely long polynominal (5b) above.</S>
    <S sid="107" ssid="32">This expression can be simplified by introducing a notation for exponentiation.</S>
    <S sid="108" ssid="33">Let x' be an abbreviation for multiplying x x &#8226; ... &#8226; x, i times.</S>
    <S sid="109" ssid="34">Note that parentheses are interpreted differently in algebraic equations than in context-free rules.</S>
    <S sid="110" ssid="35">In context-free rules, parentheses denote optionality, where in equations they denote precedence relations among algebraic operations.</S>
  </SECTION>
  <SECTION title="3." number="3">
    <S sid="111" ssid="1">Ambiguity coefficients take on an important practical significance when we can model them directly without resorting to successive approximation as above.</S>
    <S sid="112" ssid="2">This can result in substantial time and space savings in certain special cases where there are much more efficient ways to compute the coefficients than successive approximation (chart parsing).</S>
    <S sid="113" ssid="3">Equation (9) is such a special case; the coefficients follow a well-known combinatoric series called the Catalan Numbers (Knuth 1975, pp.</S>
    <S sid="114" ssid="4">388-389, 531-533).6 This section will describe Catalan numbers and their relation to parsing.</S>
    <S sid="115" ssid="5">The first few Catalan numbers are 1, 1, 2, 5, 14, 42, 132, 469, 1430, 4862.</S>
    <S sid="116" ssid="6">They are generated by the closed form expression:7 This formula can be explained in terms of parenthesized expressions, which are equivalent to trees.</S>
    <S sid="117" ssid="7">Cat, is the number of ways to parenthesize a formula of length n. There are two conditions on parenthesization: (a) there must be the same number of open and close parentheses, and (b) they must be properly nested so that an open parenthesis precedes its matching close parenthesis.</S>
    <S sid="118" ssid="8">The first term counts the number of 6 This fact was first pointed out to us by V. Pratt.</S>
    <S sid="119" ssid="9">We suspect that it is a generally well-known result in the formal language community, though its origin is unclear. where a! is equal to the product of all integers between 1 and a. Binomial coefficients are very common in combinatorics where they are interpreted as the number of ways to pick b objects out of a set of a objects.</S>
    <S sid="120" ssid="10">American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 141 Kenneth Church and Ramesh Path Coping with Syntactic Ambiguity sequences of 2n parentheses, such that there are the same number of opens and closes.</S>
    <S sid="121" ssid="11">The second term subtracts cases violating condition (b).</S>
    <S sid="122" ssid="12">This explanation is elaborated in Knuth 1975, p. 531.</S>
    <S sid="123" ssid="13">It is very useful to know that the ambiguity coefficients are Catalan numbers because this observation enables us to replace equation (9) with (11), where Cat i denotes the ith Catalan number.</S>
    <S sid="124" ssid="14">(All summations range from 0 to 00 unless noted otherwise.)</S>
    <S sid="125" ssid="15">The ith Catalan number is the number of binary trees that can be constructed over i phrases.</S>
    <S sid="126" ssid="16">This theoretical model correctly predicts our practical experience with EQSP.</S>
    <S sid="127" ssid="17">EQSP found exactly the Catalan number of parse trees for each sentence in the following sequence.</S>
    <S sid="128" ssid="18">14 It was the number of products of products of products of products.</S>
    <S sid="129" ssid="19">These predictions continue to hold with as many as nine prepositional phrases (4862 parse trees).</S>
  </SECTION>
  <SECTION title="4." number="4">
    <S sid="130" ssid="1">We could improve EQSP's performance on PPs if we could find a more efficient way to compute Catalan numbers than chart parsing, the method currently employed by EQSP.</S>
    <S sid="131" ssid="2">Let us propose two alternatives: table lookup and evaluating expression (10) directly.</S>
    <S sid="132" ssid="3">Both are very efficient over practical ranges of n, say no more than 20 phrases or so.8 In both cases, the ambiguity of a sentence in grammar (5a) can be determined by counting the number of occurrences of &amp;quot;and John&amp;quot; and then retrieving the Catalan of that number.</S>
    <S sid="133" ssid="4">These approaches both take linear time (over practical ranges of n),9 whereas chart parsing requires cubic time to parse sentences in these grammars, a significant improvement.</S>
    <S sid="134" ssid="5">So far we have shown how to compute in linear time the number of ambiguous interpretations of a sentence in an &amp;quot;every way ambiguous&amp;quot; grammar.</S>
    <S sid="135" ssid="6">However, we are really interested in finding parse trees, not just the number of ambiguous interpretations.</S>
    <S sid="136" ssid="7">We could extend the table lookup algorithm to find trees rather than ambiguity coefficients, by modifying the table to store trees instead of numbers.</S>
    <S sid="137" ssid="8">For parsing purposes, Cati can be thought of as a pointer to the ith entry of the table.</S>
    <S sid="138" ssid="9">So, for a sentence in grammar (5a), for example, the machine could count the number of occurrences of &amp;quot;and John&amp;quot; and then retrieve the table entry for that number. index trees [John and [John and John]]] The table would be more general if it did not specify the lexical items at the leaves.</S>
    <S sid="139" ssid="10">Let us replace the table above with index trees and assume the machine can bind the x's to the appropriate lexical items.</S>
    <S sid="140" ssid="11">There is a real problem with this table lookup machine.</S>
    <S sid="141" ssid="12">The parse trees may not be exactly correct because the power series computation assumed that multiplication was associative, which is an appropriate assumption for computing ambiguity, but inappropriate for constructing trees.</S>
    <S sid="142" ssid="13">For example, we observed that prepositional phrases and conjunction are both &amp;quot;every way ambiguous&amp;quot; grammars because their ambiguity coefficients are Catalan numbers.</S>
    <S sid="143" ssid="14">However, it is not the case that they generate exactly the same parse trees.</S>
    <S sid="144" ssid="15">Nevertheless we present the table lookup pseudoparser here because it seems to be a speculative new approach with considerable promise.</S>
    <S sid="145" ssid="16">It is often more efficient than a real parser, and the trees that it finds may be just as useful as the correct one for many practical purposes.</S>
    <S sid="146" ssid="17">For example, many speech recognition projects employ a parser to filter out syntactically inappropriate hypotheses.</S>
    <S sid="147" ssid="18">However, a full parser is not really necessary for this task; a recognizer such as this table lookup pseudo-parser may be perfectly adequate for this task.</S>
    <S sid="148" ssid="19">Furthermore, it is often possible to recover the correct trees from the output of the pseudo-parser.</S>
    <S sid="149" ssid="20">In particular, the difference between prepositional phrases and conjunction could be accounted for by modifying the interpretation of the PP category label, so that the trees would be interpreted correctly even though they are not exactly correct.</S>
    <S sid="150" ssid="21">8 The table lookup scheme ought to have a way to handle the theoretical possibility that there are an unlimited number of prepositional phrases.</S>
    <S sid="151" ssid="22">The table lookup routine will employ a more traditional parsing algorithm (e.g., Earley's algorithm) when the number of phrases in the input sentence is not stored in the table.</S>
    <S sid="152" ssid="23">The table lookup approach works for primitive grammars.</S>
    <S sid="153" ssid="24">The next two sections show how to decompose composite grammars into series and parallel combinations of primitive grammars.</S>
  </SECTION>
  <SECTION title="5." number="5">
    <S sid="154" ssid="1">Parallel decomposition can be very useful for dealing with lexical ambiguity, as in where &amp;quot;total&amp;quot; can be taken as a noun or as a verb, as in: (14a) The accountant brought the daily sales to total with products near profits organized according to the new law. noun (14b) The daily sales were ready for the accountant to total with products near profits organized according to the new law. verb The analysis of these sentences makes use of the additivity property of linear systems.</S>
    <S sid="155" ssid="2">That is, each case, (14a) and (14b), is treated separately, and then the results are added together.</S>
    <S sid="156" ssid="3">Assuming &amp;quot;total&amp;quot; is a noun, there are three prepositional phrases contributing Cat3 bracketings, and assuming it is a verb, there are two prepositional phrases for Cat2 ambiguities.</S>
    <S sid="157" ssid="4">Combining the two cases produces Cat3 + Cat2 = 5 + 2 = 7 parses.</S>
    <S sid="158" ssid="5">Adding another prepositional phrase yields Cat4 + Cat3 = 14 + 5 = 19 parses.</S>
    <S sid="159" ssid="6">(EOSP behaved as predicted in both cases.)</S>
    <S sid="160" ssid="7">This behavior is generalized by the following power series: This observation can be incorporated into the table lookup pseudo-parser outlined above.</S>
    <S sid="161" ssid="8">Recall that Cat, is interpreted as the ith index in a table containing all binary trees dominating i leaves.</S>
    <S sid="162" ssid="9">Similarly, Cati + Cati+ I will be interpreted as an instruction to &amp;quot;append&amp;quot; the ith entry and i+ 1 th entry of the table.10 Let us consider a system where syntactic processing strictly precedes semantic and pragmatic processing.</S>
    <S sid="163" ssid="10">In such a system, how could we incorporate semantic and pragmatic heuristics once we have already parsed the input sentence and found that it was the sum of two Catalans?</S>
    <S sid="164" ssid="11">The parser can simply subtract the inappropriate interpretations.</S>
    <S sid="165" ssid="12">If the oracle says that &amp;quot;total&amp;quot; is a verb, then (16a) would be subtracted from the combined sum, and if the oracle says that &amp;quot;total&amp;quot; is a noun, then (16b) would be subtracted.</S>
    <S sid="166" ssid="13">On the other hand, our analysis is also useful in a system that interleaves syntactic processing with semantic and pragmatic processing.</S>
    <S sid="167" ssid="14">Suppose that we had a semantic routine that could disambiguate &amp;quot;total,&amp;quot; but only at a very high cost in execution time.</S>
    <S sid="168" ssid="15">We need a way to estimate the usefulness of executing the semantic routine so that we don't spend the time if it is not likely to pay off.</S>
    <S sid="169" ssid="16">The analysis above provides a very simple way to estimate the benefit of disambiguating &amp;quot;total.&amp;quot; If it turns out to be a verb, then (16a) trees have been ruled out, and if it turns out to be a noun, then (16b) trees have been ruled out.</S>
    <S sid="170" ssid="17">We prefer our declarative algebraic approach over procedural heuristic search strategies (e.g., Kaplan 1972) because we do not have to specify the order of evaluation.</S>
    <S sid="171" ssid="18">We can delay the binding of decisions until the most opportune moment.</S>
  </SECTION>
  <SECTION title="6." number="6">
    <S sid="172" ssid="1">Suppose we have a non-terminal S that is a series combination of two other non-terminals, NP and VP.</S>
    <S sid="173" ssid="2">By inspection, the power series of S is: This result is easily verified when there is an unmistakable dividing point between the subject and the predicate.</S>
    <S sid="174" ssid="3">For example, the verb &amp;quot;is&amp;quot; separates the PPs in the subject from those in the predicate in (19a), but not in (19b).</S>
    <S sid="175" ssid="4">In (19a), the total number of parse trees is the product of the number of ways of parsing the subject times the number of ways of parsing the predicate.</S>
    <S sid="176" ssid="5">Both the subject and the predicate produce a Catalan number of parses, and hence the result is the product of two Catalan numbers, which was verified by EQSP (Martin, Church, and Patil 1981, p. 53).</S>
    <S sid="177" ssid="6">This result can be formalized in terms of the power series: 10 This can be implemented efficiently, given an appropriate representation of sets of trees.</S>
    <S sid="178" ssid="7">Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguity The power series says that the ambiguity of a particular sentence is the product of Cati and Cat, where i is the number of PPs before &amp;quot;is&amp;quot; and j is the number after &amp;quot;is.&amp;quot; This could be incorporated in the table lookup parser as an instruction to &amp;quot;multiply&amp;quot; the ith entry in the table by the jth entry.</S>
    <S sid="179" ssid="8">Multiplication is a cross-product operation; L x R generates the set of binary trees whose left sub-tree l is from L and whose right sub-tree r is from R. (22) L x R = {(1, r) 11 cL &amp; r&#8364;R} This is a formal definition.</S>
    <S sid="180" ssid="9">For practical purposes, it may be more useful for the parser to output the list in the factored form: which is much more concise than a list of trees.</S>
    <S sid="181" ssid="10">It is possible, for example, that semantic processing can take advantage of factoring, capturing a semantic generalization that holds across all subjects or all predicates.</S>
    <S sid="182" ssid="11">Imagine, for example, that there is a semantic agreement constraint between predicates and arguments.</S>
    <S sid="183" ssid="12">For example, subjects and predicates might have to agree on the feature +human.</S>
    <S sid="184" ssid="13">Suppose that we were given sentences where this constraint was violated by all ambiguous interpretations of the sentence.</S>
    <S sid="185" ssid="14">In this case, it would be more efficient to employ a feature vector scheme (Dostert and Thompson 1971) which propagates the features in factored form.</S>
    <S sid="186" ssid="15">That is, it computes a feature vector for the union of all possible subjects, and a vector for the union of all possible VPs, and then compares (intersects) these vectors to check if there are any interpretations that meet the constraint.</S>
    <S sid="187" ssid="16">A system such as this, which keeps the parses in factored form, is much more efficient than one that multiplies them out.</S>
    <S sid="188" ssid="17">Even if semantics cannot take advantage of the factoring, there is no harm in keeping the representation in factored form, because it is straightforward to expand (23) into a list of trees (though it may be somewhat slow).</S>
    <S sid="189" ssid="18">This example is relatively simple because &amp;quot;is&amp;quot; helps the parser determine the value of i and j.</S>
    <S sid="190" ssid="19">Now let us return to example (19b) where &amp;quot;is&amp;quot; does not separate the two strings of PPs.</S>
    <S sid="191" ssid="20">Again, we determine the power series by multiplying the two subcases: However, this form is not so useful for parsing because the parser cannot easily determine i and j, the number of prepositional phrases in the subject and the number in the predicate.</S>
    <S sid="192" ssid="21">It appears the parser will have to compute the product of two Catalans for each way of picking i and j, which is somewhat expensive.11 Fortunately, the Catalan function has some special properties so that it is possible algebraically to remove the references to i and j.</S>
    <S sid="193" ssid="22">In the next section we show how this expression can be reformulated in terms of n, the total number of PPs.</S>
    <S sid="194" ssid="23">Some readers may have noticed that expression (24) is in convolution form.</S>
    <S sid="195" ssid="24">We will make use of this in the reformulation.</S>
    <S sid="196" ssid="25">Notice that the Catalan series is a fixed point under auto-convolution (except for a shift); that is, multiplying a Catalan power series (i.e., 1 + x + 2x2 + 5x3 + 14x4 + Catix1 ...) with itself produces another polynomial with Catalan coefficients.12 The multiplication is worked out for the first few terms.</S>
    <S sid="197" ssid="26">This property can be summarized as: (25) E Cat, xi E Cat x'1i xi = E Catn+ X where n equals i+j.</S>
    <S sid="198" ssid="27">Intuitively, this equation says that if we have two &amp;quot;every way ambiguous&amp;quot; (Catalan) constructions, and we combine them in every possible way (convolution), the result is an &amp;quot;every way ambiguous&amp;quot; (Catalan) construction.</S>
    <S sid="199" ssid="28">With this observation, equation (24) reduces to: Hence the number of parses in the auxiliary-inverted case is the Catalan of one more than in the noninverted cases.</S>
    <S sid="200" ssid="29">As predicted, EQSP found the following inverted sentences to be more ambiguous than their non-inverted counterparts (previously discussed on page 142) by one Catalan number.</S>
    <S sid="201" ssid="30">11 Earley's algorithm and most other context-free parsing algorithms actually work this way.</S>
    <S sid="202" ssid="31">12 The proof immediately follows from the z-transform of the Catalan series (Knuth 1975, p. 388): zB(z) = B(z) &#8212; 1. of products.</S>
    <S sid="203" ssid="32">14 It was the number of products of products of products of products.</S>
    <S sid="204" ssid="33">How could this result be incorporated into the table lookup pseudo-parser?</S>
    <S sid="205" ssid="34">Recall that the pseudo-parser implements Catalan grammars by returning an index into the Catalan table.</S>
    <S sid="206" ssid="35">For example, if there were i PPs, the parser would return: (CAT-TABLE i).</S>
    <S sid="207" ssid="36">We now extend the indexing scheme so that the parser implements a series connection of two Catalan grammars by returning one higher index than it would for a simple Catalan grammar.</S>
    <S sid="208" ssid="37">That is, if there were n PPs, the parser would return (CAT-TABLE (-4- n 1)).</S>
    <S sid="209" ssid="38">Series connections of Catalan grammars are very common in every day natural language, as illustrated by the following two sentences, which have received considerable attention in the literature because the parser cannot separate the direct object from the prepositional complement.</S>
    <S sid="210" ssid="39">Both examples have a Catalan number of ambiguities because the auto-convolution of a Catalan series yields another Catalan series.13 This result can improve parsing performance because it suggests ways to reorganize (compile) the grammar so that there will be fewer references to quantities that are not readily available.</S>
    <S sid="211" ssid="40">This re-organization will reap benefits that chart parsers (e.g., Earley's algorithm) do not currently achieve because the re-organization is taking advantage of a number of combinatoric regularities, especially convolution, that are not easily encoded into a chart.</S>
    <S sid="212" ssid="41">Section 9 presents an example of the reorganization.</S>
    <S sid="213" ssid="42">13 There is a difference between these two sentences because &amp;quot;put&amp;quot; subcategorizes for two objects unlike &amp;quot;see.&amp;quot; Suppose we analyze &amp;quot;see&amp;quot; as lexically ambiguous between two senses, one that selects for exactly two objects like &amp;quot;put&amp;quot; and one that selects for exactly one object as in &amp;quot;I saw it.&amp;quot; The first sense contributes the same number of parses as &amp;quot;put&amp;quot; and the second sense contributes an additional Catalan factor.</S>
    <S sid="214" ssid="43">Perhaps it is worthwhile to reformulate chart parsing in our terms in order to show which of the above results can be captured by such an approach and which cannot.</S>
    <S sid="215" ssid="44">Traditionally, chart parsers maintain a chart (or matrix) M, whose entries M1 contain the set of category labels that span from position i to position j in the input sentence.</S>
    <S sid="216" ssid="45">This is accomplished by finding a position k between i and j such that there is a phrase from i to k that can combine with another phrase from k to j.</S>
    <S sid="217" ssid="46">An implementation of the inner loop looks something like: Essentially, then, a chart parser is maintaining the invariant where addition and multiplication of matrix elements is related to parallel and series combination.</S>
    <S sid="218" ssid="47">Thus chart parsers are able to process very ambiguous sentences in polynomial time, as opposed to exponential (or Catalan) time.</S>
    <S sid="219" ssid="48">However, the examples above illustrate cases where chart parsers are not as efficient as they might be.</S>
    <S sid="220" ssid="49">In particular, chart parsers implement convolution the &amp;quot;long way,&amp;quot; by picking each possible dividing point k, and parsing from i to k and from k to j; they do not reduce the convolution of two Catalans as we did above.</S>
    <S sid="221" ssid="50">Similarly, chart parsers do not make use of the &amp;quot;every way ambiguous&amp;quot; generalization; given a Catalan grammar, chart parsers will eventually enumerate all possible values of i, j, and k. Thus far, most of our derivations have been justified in terms of successive approximation.</S>
    <S sid="222" ssid="51">It is also possible to derive some interesting (and well-known) results directly from the grammar itself.</S>
    <S sid="223" ssid="52">Suppose, for the sake of discussion, that we choose to analyze adjuncts with a right branching grammar.14 (By convention, terminal symbols appear in lower case.)</S>
    <S sid="224" ssid="53">First we translate the grammar into an equation in the usual way.</S>
    <S sid="225" ssid="54">That is, ADJS is modeled as a parallel combination of two subgrammars, adj ADJS and A.</S>
    <S sid="226" ssid="55">(A, the empty string, is modeled as 1 because it is the 14 A similar analysis of adjuncts is adopted in Kaplan and Bresnan 1981.</S>
    <S sid="227" ssid="56">This analysis can also be defended on performance grounds as an efficiency approximation.</S>
    <S sid="228" ssid="57">(This approximation is in the spirit of pseudo-attachment (Church 1980).)</S>
    <S sid="229" ssid="58">We can simplify (31b) so the right hand side is expressed in terminal symbols alone, with no references to non-terminals.</S>
    <S sid="230" ssid="59">This is very useful for processing because it is much easier for the parser to determine the presence or absence of terminals than of nonterminals.</S>
    <S sid="231" ssid="60">That is, it is easier for the parser to determine, for example, whether a word is an adj, than it is to decide whether a substring is an ADJS phrase.</S>
    <S sid="232" ssid="61">The simplification moves all references to ADJS to the left hand side, by subtracting from both sides, Grammars like ADJS will sometimes be referred to as a step, by analogy to a unit step function in electrical engineering.</S>
    <S sid="233" ssid="62">8.</S>
    <S sid="234" ssid="63">Computing the Power Series from the ATN This section will re-derive the power series for the unit step grammar directly from the ATN representation by treating the networks as flow graphs (Oppenheim 1975).</S>
    <S sid="235" ssid="64">The graph transformations presented here are directly analogous to the algebraic simplifications employed in the previous section.</S>
    <S sid="236" ssid="65">First we translate the grammar into an ATN in the usual way (Woods 1970).</S>
    <S sid="237" ssid="66">This graph can be simplified by performing a compiler optimization call tail recursion (Church and Kaplan 1981 and references therein).</S>
    <S sid="238" ssid="67">This transformation replaces the final push arc with a jump: Jump Tail recursion corresponds directly to the algebraic operations of moving the ADJS term to the left hand side, factoring out the ADJS, and dividing from both sides.</S>
    <S sid="239" ssid="68">Then we remove the top jump arc by series reduction.</S>
    <S sid="240" ssid="69">This step corresponds to multiplying by 1 since a jump arc is the ATN representation for the identity element under series combination. where the zero-th term corresponds to zero iterations around the loop, the first term corresponds to a single iteration, the second term to two iterations, and so on.</S>
    <S sid="241" ssid="70">Recall that (36) is equivalent to: (37) 1 1&#8212;adj With this observation, it is possible to open the loop: (38) ADJS:01/(1-adj) Jump Pop After one final series reduction, the ATN is equivalent to expression (31e) above.</S>
    <S sid="242" ssid="71">Intuitively, an ATN loop (or step grammar) is a division operator.</S>
    <S sid="243" ssid="72">We now have composition operators for parallel composition (addition), series composition (multiplication), and loops (division).</S>
    <S sid="244" ssid="73">An ATN loop can be implemented in terms of the table lookup scheme discussed above.</S>
    <S sid="245" ssid="74">First we reformulate the loop as an infinite sum: Then we construct a table so that the ith entry in the table tells the parser how to parse i occurrences of adj.</S>
  </SECTION>
  <SECTION title="9." number="7">
    <S sid="246" ssid="1">Suppose for example that we were given the following grammar: (In this example we will assume no lexical ambiguity among N, V, P, and adj.)</S>
    <S sid="247" ssid="2">By inspection, we notice that NP and PP are Catalan grammars and that ADJS is a Step grammar.</S>
    <S sid="248" ssid="3">With these observations, the parser can process PPs, NPs, and ADJSs by counting the number of occurrences of terminal symbols and looking up those numbers in the appropriate tables.</S>
    <S sid="249" ssid="4">We now substitute (41a-c) into (40c).</S>
    <S sid="250" ssid="5">(42) VP = V NP (1 + PP)ADJS = V (N E Cati(P N)')(E Cati(P (E adji) and simplify the convolution of the two Catalan functions (43) VP = V (N E Cati+i(P N)i)(E adj') so that the parser can also find VPs by just counting coccurrences of terminal symbols.</S>
    <S sid="251" ssid="6">Now we simplify (40a-b) so that S phrases can also be parsed by just counting occurrences of terminal symbols.</S>
    <S sid="252" ssid="7">First, translate (40a-b) into the equation: Furthermore, the number of parse trees for a given input sentence can be found by multiplying three numbers: (a) the Catalan of the number of P N's before the verb, (b) the Catalan of one more than the number of P N's after the verb, and (c) the ramp of the number of adj's.</S>
    <S sid="253" ssid="8">For example, the sentence (53) The man on the hill saw the boy with a telescope yesterday in the morning. has Cat * Cat2 * 3 = 6 parses.</S>
    <S sid="254" ssid="9">That is, there is one way to parse &amp;quot;the man on the hill,&amp;quot; two ways to parse &amp;quot;saw the boy with a telescope&amp;quot; (&amp;quot;telescope&amp;quot; is either a complement of &amp;quot;see&amp;quot; as in (54a-c) or is attached to &amp;quot;boy&amp;quot; as in (54d-f)), and three ways to parse the adjuncts (they could both attach to the S (54a,d), or they could both attach to the VP (54b,e), or they could split (54c,f)).</S>
    <S sid="255" ssid="10">All and only these possibilities are permitted by the grammar.</S>
  </SECTION>
  <SECTION title="10." number="8">
    <S sid="256" ssid="1">We began our discussion with the observation that certain grammars are &amp;quot;every way ambiguous&amp;quot; and suggested that this observation could lead to improved parsing performance.</S>
    <S sid="257" ssid="2">Catalan grammars were then introduced to remedy the situation so that the processor can delay attachment decisions until it discovers some more useful constraints.</S>
    <S sid="258" ssid="3">Until such time, the processor can do little more than note that the input sentence is &amp;quot;every way ambiguous.&amp;quot; We suggested that a table lookup scheme might be an effective method to implement such a processor.</S>
    <S sid="259" ssid="4">We then introduced rules for combining primitive grammars, such as Catalan grammars, into composite grammars.</S>
    <S sid="260" ssid="5">This linear systems view &amp;quot;bundles up&amp;quot; all the parse trees into a single concise description capable of telling us everything we might want to know about the parses (including how much it might cost to ask a particular question).</S>
    <S sid="261" ssid="6">This abstract view of ambiguity enables us to ask questions in the most convenient order, and to delay asking until it is clear that the pay-off will exceed the cost.</S>
    <S sid="262" ssid="7">This abstraction was very strongly influenced by the notion of delayed binding.</S>
    <S sid="263" ssid="8">We have presented combination rules in three different representation systems: power series, ATNs, and context-free grammars, each of which contributed its own insights.</S>
    <S sid="264" ssid="9">Power series are convenient for defining the algebraic operations, ATNs are most suited for discussing implementation issues, and context-free grammars enable the shortest derivations.</S>
    <S sid="265" ssid="10">Perhaps the following quotation best summarizes our motivation for alternating among these three representation systems: A thing or idea seems meaningful only when we have several different ways to represent it &#8212; different perspectives and different associations.</S>
    <S sid="266" ssid="11">Then you can turn it around in your mind, so to speak; however, it seems at the moment you can see it another way; you never come to a full stop.</S>
    <S sid="267" ssid="12">(Minsky 1981, p. 19) In each of these representation schemes, we have introduced five primitive grammars: Catalan, Unit Step, 1, and 0, and terminals; and four composition rules: addition, subtraction, multiplication, and division.</S>
    <S sid="268" ssid="13">We have seen that it is often possible to employ these analytic tools in order to re-organize (compile) the grammar into a form more suitable for processing efficiently.</S>
    <S sid="269" ssid="14">We have identified certain situations where the ambiguity is combinatoric, and have sketched a few modifications to the grammar that enable processing to proceed in a more efficient manner.</S>
    <S sid="270" ssid="15">In particular, we have observed it to be important for the grammar to avoid referencing quantities that are not easily determined, such as the dividing point between a noun phrase and a prepositional phrase as in (55) Put the block in the box on the table in the kitchen ... We have seen that the desired re-organization can be achieved by taking advantage of the fact that the autoconvolution of a Catalan series produces another Catalan series.</S>
    <S sid="271" ssid="16">This reduced processing time from 0(n3) to almost linear time.</S>
    <S sid="272" ssid="17">Similar analyses have been discussed for a number of lexically and structurally ambiguous constructions, culminating with the example in section 9, where we transformed a grammar into a form that could be parsed by a single left-to-right pass over the terminal elements.</S>
    <S sid="273" ssid="18">Currently, these grammar reformulations have to be performed by hand.</S>
    <S sid="274" ssid="19">It ought to be possible to automate this process so that the reformulations could be performed by a grammar compiler.</S>
    <S sid="275" ssid="20">We leave this project open for future research.</S>
  </SECTION>
  <SECTION title="11." number="9">
    <S sid="276" ssid="1">We would like to thank Jon Allen, Sarah Ferguson, Lowell Hawkinson, Kris Halvorsen, Bill Long, Mitch Marcus, Rohit Parikh, and Peter Szolovits for their very useful comments on earlier drafts.</S>
    <S sid="277" ssid="2">We would especially like to thank Bill Martin for initiating the project.</S>
  </SECTION>
</PAPER>
