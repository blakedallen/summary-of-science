<PAPER>
  <S sid="0">Has A Consensus NL Generation Architecture Appeared And Is It Psycholinguistically Plausible?</S>
  <ABSTRACT>
    <S sid="1" ssid="1">I survey some recent applications-oriented NL generation systems, and claim that despite very different theoretical backgrounds, these systems have a remarkably similar architecture in terms of the modules they divide the generation process into, the computations these modules perform, and the way the modules interact with each other.</S>
    <S sid="2" ssid="2">I also compare this 'consensus architecture' among applied NLG systems with psycholinguistic knowledge about how humans speak, and argue that at least some aspects of the consensus architecture seem to be in agreement with what is known about human language production, despite the fact that psycholinguistic plausibility was not in general a goal of the developers of the surveyed systems.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="3" ssid="1">In this paper I survey some recently-developed NL generation systems that (a) cover the complete generation process and (b) are designed to be used by application programs, as well as (or even instead of) making some theoretical point.</S>
    <S sid="4" ssid="2">I claim that despite their widely differing theoretical backgrounds, the surveyed systems are similar in terms of the modules they divide the generation process into, the way the modules interact with each other, and (at least in some cases) the kinds of computations each individual module performs.</S>
    <S sid="5" ssid="3">In other words, despite different theoretical claims, there is a remarkable level of similarity in how these systems 'really work'; that is, a de facto 'consensus architecture' seems to be emerging for how applied NLG systems should generate text.</S>
    <S sid="6" ssid="4">The existence of such agreement among the surveyed systems is especially surprising because in some cases the theoretical backgrounds of the systems examined argue against some aspects of the consensus architecture.</S>
    <S sid="7" ssid="5">I also compare the consensus architecture to psycholinguistic knowledge about language generation in human speakers.</S>
    <S sid="8" ssid="6">Such a comparison is often difficult to make, because of the many gaps in our current knowledge about how humans speak.</S>
    <S sid="9" ssid="7">Nevertheless, I argue that as far as such a comparison can be made, the specific design decisions embodied in the consensus architecture seem to often be more or less in accord with current knowledge of human language generation.</S>
    <S sid="10" ssid="8">This is again perhaps somewhat surprising, since psycholinguistic plausibility was not in general a goal of the developers of the examined systems.</S>
    <S sid="11" ssid="9">Perhaps (being very speculative) this indicates that there is some connection between the engineering considerations that underlie the design decisions made in the consensus architecture, and the maximizeperformance-in-the-real-world criteria that drove the evolutionary processes that created the human language processor.</S>
    <S sid="12" ssid="10">If (a big if!) there is some truth to this hypothesis, then studying the engineering issues involved in building applied systems may lead to insights about the way the human language system works.</S>
  </SECTION>
  <SECTION title="2 The Systems Surveyed" number="2">
    <S sid="13" ssid="1">The analysis presented here is based on a survey of generation systems that: In short, the idea was to survey recent systems that looked at the entire generation problem, and that were motivated by applications and engineering considerations as well as linguistic theory.</S>
    <S sid="14" ssid="2">The systems examined were:1 FUF [Elhadad, 1992]: Developed at Columbia University and used in several projects there, including COMET and ADVISOR II; I will use the term `FUF' in this paper to refer to both FUF itself and the various related systems at Columbia.</S>
    <S sid="15" ssid="3">Several other universities have also recently begun to use FUF in their research.</S>
    <S sid="16" ssid="4">FUF is based on Kay's functional unification formalism [Kay, 1979].</S>
    <S sid="17" ssid="5">IDAS [Reiter 0 at., 19921: Developed at Edinburgh University, IDAS was a prototype online documentation system for users of complex machinery.</S>
    <S sid="18" ssid="6">From a theoretical perspective, IDAS's main objective was to show that a single representation and reasoning system can be used for both domain and linguistic knowledge [Reiter and Mellish, 1992].</S>
    <S sid="19" ssid="7">JOYCE [Rambow and Korelsky, 1992]: Developed at Odyssey Research Associates, JOYCE is taken as a representative of several NL generation systems produced by ORA and CoGenTex, including GOSSIP, FOG, and LFS.</S>
    <S sid="20" ssid="8">These systems are all aimed at commercial or government applications (in JovcE's case, producing summaries of software designs), and are all based on Mel''Cuk's Meaning-Text theory [Mel'euk, 19881.</S>
    <S sid="21" ssid="9">PENMAN [Penman Natural Language Group, 1989]: Under development at ISI since the early 1980's, PENMAN has been used in several demonstration systems.</S>
    <S sid="22" ssid="10">As usual, I will use 'PENMAN' to refer to both PENMAN itself and the systems that were built around it.</S>
    <S sid="23" ssid="11">PENMAN'S theoretical basis is systemic linguistics [Halliday, 1985] and rhetorical-structure theory.</S>
    <S sid="24" ssid="12">SPOKESMAN [Meteer, 1989]: SPOKESMAN was developed at BBN for various applications, and has some of the same design goals as McDonald's 'The selection rules are of course not completely well defined, which means there was inevitably some arbitrariness when I used them to select particular systems to indude in the survey.</S>
    <S sid="25" ssid="13">I encourage any reader who believes that I have unfairly omitted a system to contact me, so that this system can be included in future versions of the survey.</S>
    <S sid="26" ssid="14">MUMBLE system [McDonald, 19831, including in particular the desire to build a system that at least in some respects is psycholinguistically plausible.</S>
    <S sid="27" ssid="15">SPOKESMAN uses Tree-Adjoining Grammars [Josh, 1987] for syntactic processing.</S>
    <S sid="28" ssid="16">All of the examined systems produce English, and they also are mostly aimed at producing technical texts (instead of, say, novels or newspaper articles); it would be interesting to examine systems aimed at other languages or other types of applications, and see if this caused any architectural differences.</S>
  </SECTION>
  <SECTION title="3 An Overview of the Consensus Architecture" number="3">
    <S sid="29" ssid="1">As can be seen, the chosen systems have widely different theoretical bases.</S>
    <S sid="30" ssid="2">It is therefore quite interesting that they all seem to have ended up with broadly similar architectures, in that they break up the generation process into a similar set of modules, and they all use a pipeline architecture to connect the modules; i.e., the modules are linearly ordered, and information flows from each module to its successor in the pipeline, with no feedback from later modules to earlier modules.</S>
    <S sid="31" ssid="3">The actual modules possessed by the systems (discussed in more detail in Section 4, as is the pipeline architecture) are: Content Determination: This maps the initial input of the generation system (e.g., a query to be answered, or an intention to be satisfied) onto a semantic form, possibly annotated with rhetorical (e.g., RST) relations.</S>
    <S sid="32" ssid="4">Sentence Planning.</S>
    <S sid="33" ssid="5">Many names have been used for this process; here I use one suggested by Rambow and Korelsky [1992].</S>
    <S sid="34" ssid="6">The basic goal is to map conceptual structures onto linguistic ones: this includes generating referring expressions, choosing content words and (abstract) grammatical relationships, and grouping information into clauses and sentences.</S>
    <S sid="35" ssid="7">Surface Generation: I use this term in a fairly narrow sense here, to mean a module that takes as input an abstract specification of information to be communicated by syntax and function words, and produces as output a surface form that communicates this information (e.g., maps : speechact imperative into an English sentence that lacks a surface subject).</S>
    <S sid="36" ssid="8">All of the examined systems had separate sentence-planning and surfacegeneration modules, and the various intermediate forms used to pass information between these modules conveyed similar kinds of information.</S>
    <S sid="37" ssid="9">Morphology: Most of the systems have a fairly simple morphological component, presumably since English morphology is quite simple.</S>
    <S sid="38" ssid="10">Formatting: IDAS, JOYCE, and PENMAN also contain mechanisms for formatting (in the IATEX sense) their output, and/or adding hypertext annotations to enable users to click on portions of the generated text.</S>
  </SECTION>
  <SECTION title="4 A More Detailed Examination of" number="4">
    <S sid="39" ssid="1">This section describes the consensus architecture in more detail, with particular emphasis on some of the design decisions embodied in it that more theoretically motivated researchers have disagreed with.</S>
    <S sid="40" ssid="2">It furthermore examines the plausibility of these decisions from a psycholinguistic perspective, and argues that in many respects they agree with what is known about how humans generate text.</S>
    <S sid="41" ssid="3">The consensus architecture divides the generation process into multiple modules, with information flowing in a 'pipeline' fashion from one module to the next.</S>
    <S sid="42" ssid="4">By pipeline, I mean that the modules are arranged in a linear order, and each module receives information only from its predecessor (and the various linguistic and domain knowledge bases), and sends information only to its successor.</S>
    <S sid="43" ssid="5">Information does not flow 'backwards' from a module to its predecessor, and global 'blackboards' that all modules can access and modify are not used.</S>
    <S sid="44" ssid="6">I do not mean by 'pipeline' that generation must be incremental in the sense that, say, syntactic processing of the first sentence is done at the same time as semantic processing of the second; I believe most of the systems examined could in fact do this, but they have not bothered to do so (probably because it would not be of much benefit to the applications programs of interest).</S>
    <S sid="45" ssid="7">4.1.1 Design decision: avoid integrated architecture Many NL generation researchers have argued against dividing the generation process into modules; perhaps the best-known are Appelt [1985] and Danlos [1984].</S>
    <S sid="46" ssid="8">Others, such as Rubinoff [1992], have accepted modules but have argued that the architecture must allow feedback between later modules and earlier modules, which argues against the one-way information flow of the pipeline architecture.</S>
    <S sid="47" ssid="9">The argument against pipelines and modules is almost always some variant of 'there are linguistic phenomena that can only be properly handled by looking at constraints from different levels (intentional, semantic, syntactic, morphological), and this is difficult to do in a pipeline system.'</S>
    <S sid="48" ssid="10">To take one fairly random example, Danlos and Namer [1988] have pointed out that since the French masculine and feminine pronouns le and la are abbreviated to l' before a word that starts with a vowel, and since in some cases le and la may be unambiguous references while l' is not, the referring expression system must have some knowledge of surface word order and selected content and function words before it can decide whether a pronoun is acceptable; this will not be possible if referring expressions are chosen before syntactic structures are built, as happens in the consensus architecture.</S>
    <S sid="49" ssid="11">There is undoubtably some truth to these arguments, but the applications builder also has to consider the engineering reality that the sorts of systems proposed by Appelt, Danlos, and Namer are extremely difficult to build from an engineering perspective.</S>
    <S sid="50" ssid="12">The engineering argument for modularization is particularly strong; Marr has put this very well in [Man, 1976, page 485]: Any large computation should be split up and implemented as a collection of small subparts that are as nearly independent of one another as the overall task allows.</S>
    <S sid="51" ssid="13">If a process is not designed in this way a small change in one place will have consequences in many other places.</S>
    <S sid="52" ssid="14">This means that the process as a whole becomes extremely difficult to debug or improve, whether by a human designer or in the course of natural evolution, because a small chance to improve one part has to be accompanied by many simultaneous compensatory changes elsewhere.</S>
    <S sid="53" ssid="15">Marr argues that a modularized structure makes sense both for human engineers and for the evolutionary process that produced the human brain.</S>
    <S sid="54" ssid="16">The evidence is indeed strong that the human brain is highly modularized.</S>
    <S sid="55" ssid="17">This evidence comes from many sources (e.g., cognitive experiments and PET scans of brain activity), but I think perhaps the most convincing evidence is from studies of humans with brain damage.</S>
    <S sid="56" ssid="18">Such people tend to lose specific abilities, not suffer overall degradation that applies equally to all abilities.</S>
    <S sid="57" ssid="19">Ellis and Young [1988] provide an excellent summary of such work, and list patients that, for example ical structures, but have a severely restricted vocabulary; i.e., have impaired lexical choice (these patients still have conceptual knowledge, they just have problems le)dcalizing it).</S>
    <S sid="58" ssid="20">The main engineering argument for arranging modules into a pipeline instead of a more complex structure is again simplicity and ease of debugging.</S>
    <S sid="59" ssid="21">In a one-way pipeline of N modules there are only N-1 interfaces between modules, while a pipeline with `two-way' information flow has 2(N-1) interfaces, and a system that fully connects each module with every .other module will have N(N-1) interfaces.</S>
    <S sid="60" ssid="22">A system that has a twoway interface between every possible pair of modules will undoubtably be able to handle many linguistic phenomena in a more powerful, elegant, principled, etc, manner than a system that arranges modules in a simple one-way pipeline; such a system will also, however, be much more difficult to build and (especially) debug.</S>
    <S sid="61" ssid="23">It is easy to argue that a one-way pipeline is worse at handling some linguistic phenomena than a richlyconnected architecture, but this is not the end of the story for the system-building engineer; he or she has to balance the cost of the pipeline being inefficient and/or inelegant at handling some phenomena against the benefit of the pipeline being a much easier structure to build and debug.</S>
    <S sid="62" ssid="24">We have insufficient engineering data at present to make any well-substantiated claims about whether the one-way pipeline has the optimal cost/benefit tradeoff or not (and in any case this will probably_ depend somewhat on the circumstances of each application [Reiter and Mellish, 1993]), but the circumstantial evidence on this question is striking; despite the fact that so many theoretical papers have argued against pipelines and very few (if any) have argued for pipelines, every one of the applicationsoriented systems examined in this survey chose to use the one-way pipeline architecture.</S>
    <S sid="63" ssid="25">In other words, an applications systems builder can not look at particular linguistic phenomena in isolation; he or she must weigh the benefits of 'properly' handling these phenomena against the cost of implementing the proposed architecture.</S>
    <S sid="64" ssid="26">In the French pronoun case described by Danlos and Namer, for example, the applications builder might argue that in the great majority of cases no harm will in fact be done if the referring-expression generator simply ignores the possibility that pronouns may be abbreviated to l', especially given humans' ability to use context to disambiguate references; and if a situation does arise where it is absolutely essential that the human reader be able to correctly disambiguate a reference, then perhaps pronouns should not be used in any case.</S>
    <S sid="65" ssid="27">Given this, and the very high engineering cost of building an integrated architecture of the sort proposed by Danlos and Namer, is implementing such an architecture truly the most effective way of using scarce engineering resources?</S>
    <S sid="66" ssid="28">Psycholinguistic research on self-monitoring and self-repair (summarized in [Levelt, 1989, pages 458299]) suggests that there is some feedback in the human language generation system, so the human language processor is probably more complex than a simple one-way pipeline; but it may not be much more complex.</S>
    <S sid="67" ssid="29">To the best of my knowledge, most of the observed self-repair phenomena could be explained by an architecture that added a few feedback loops from later stages of the pipeline back to the initial planner; this would only slightly add to the number of intermodule interfaces (perhaps N+1 instead of N-1, say), and hence would have a much lower engineering cost than implementing the fully connected 'every module communicates with every other module' architecture.</S>
    <S sid="68" ssid="30">Whether the human language engine is organized as a 'pipeline plus a few feedback loops' or an 'every module talks to every other module' architecture is unknown at this point; hopefully new psycholinguistic experiments will shed more light on this issue.</S>
    <S sid="69" ssid="31">I think it would be very interesting, for example, to test human French speakers on situations of the sort described by Danlos and Namer, and see what they actually did in such contexts; I do not believe that such an experiment has (to date) been performed.</S>
    <S sid="70" ssid="32">Content determination takes the initial input to the generation system, which may be, for example, a query to be answered or an intention to be satisfied, and produces from it a 'semantic form', 'conceptual representation', or 'list of propositions', i.e., a specification of the meaning content of the output text.</S>
    <S sid="71" ssid="33">I will in this paper use the term semantic representation for this meaning specification.</S>
    <S sid="72" ssid="34">Roughly speaking, the semantic representations used by all of the examined systems can be characterized as some kind of 'semantic net' (using the term in its broadest sense, as in [Sowa, 1991]) where the primitive elements in the net are conceptual instead of linguistic (e.g., domain KB concepts instead of English words).</S>
    <S sid="73" ssid="35">In some cases the semantic nets also include discourse and rhetorical relations between portions of the net; subsequent portions of the generator use these to generate discourse connectives (e.g., However), control formatting (e.g., the use of bulletized lists), etc.</S>
    <S sid="74" ssid="36">The systems examined use quite different contentdetermination mechanisms (i.e., there was no consensus); schemas [McKeown, 1985] were the most popular approach.</S>
  </SECTION>
  <SECTION title="4.2.1 Design decision: integrated content determination and rhetorical planning" number="5">
    <S sid="75" ssid="1">Content determination in the systems examined basically performs two functions: Deep content determination: Determine what information should be communicated to the hearer.</S>
    <S sid="76" ssid="2">Rhetorical planning: Organize this information in a rhetorically coherent manner.</S>
    <S sid="77" ssid="3">Hovy [1988] has proposed an architecture where these tasks are performed separately (in particular, the application program performs deep content determination, while the generation system performs rhetorical planning).</S>
    <S sid="78" ssid="4">Among the systems examined, however, Hovy is unique in taking this approach; the builders of the other systems (including Moore and Paris [1989], who also worked with PENMAN) apparently believe that these two processes are so closely related that they should be performed simultaneously.</S>
    <S sid="79" ssid="5">I am not aware of any psychological data that directly address this issue.</S>
    <S sid="80" ssid="6">However, Hovy's architecture requires the language-producing agent to completely determine the content of a paragraph before he/she/it can begin to utter it (since the rhetorical planner determines what the first sentence is, and it is not called until deep content determination is completed), and intuitively it seems implausible to me that human speakers do this; it also goes against incremental theories of human speech production [Levelt, 1989, pages 24-27].</S>
    <S sid="81" ssid="7">The sentence planner converts the semantic representation, which is specified in terms of domain entities, into an abstract linguistic representation that specifies content words and grammatical relationships.</S>
    <S sid="82" ssid="8">I will use Mer-Cuk's term deep syntactic form for this representation.</S>
    <S sid="83" ssid="9">All of the systems analyzed possess a deep syntactic representation; none attempt to go from semantics to surface form in a single step.</S>
    <S sid="84" ssid="10">IDAS and PENMAN use variants of the same deep syntactic language, SPL [Kasper, 1989].</S>
    <S sid="85" ssid="11">FUF and JOYCE use deep syntactic languages that are based (respectively) on functional unification and meaning-text theory, but these convey much the same information as SPL.</S>
    <S sid="86" ssid="12">SPOKESMAN uses the realization specification language of MUMBLE [McDonald, 1983] as its deep syntactic representation; I have found it difficult to compare this language to the others, but McDonald (personal communication) agrees that it conveys essentially the same information as SPL.</S>
    <S sid="87" ssid="13">Unfortunately, while all of the systems possessed a module which converted semantic representations into deep syntactic ones, each system used a different name for this module.</S>
    <S sid="88" ssid="14">In FUF it is the 'lexical chooser', in IDAS it is the 'text planner', in JOYCE it is the 'sentence planner', in SPOKESMAN it is the 'text structurer', and in PENMAN it doesn't seem to have a name at all, e.g., Hovy [1988] simply refers to 'pre-generation textplanning tasks'.</S>
    <S sid="89" ssid="15">I use the JOYCE term here because I think it is the least ambiguous.</S>
    <S sid="90" ssid="16">The specific tasks performed by the sentence planner include: Relatively little is said in the papers about clause grouping and referring-expression generation, but more information is available on the first task, mapping domain entities onto linguistic entities.</S>
    <S sid="91" ssid="17">All the examined systems except perhaps PENMAN use a variant of what I have elsewhere called the 'structuremapping' approach [Reiter, 1991];2 I do not know what approach PENMAN uses (the papers are not clear on this).</S>
    <S sid="92" ssid="18">Structure-mapping is based on a dictionary that lists the semantic-net equivalents of linguistic resources [Meteer, 1991] such as content words and grammatical relationships.</S>
    <S sid="93" ssid="19">This dictionary might, for example, indicate that the English word sisteris equivalent (in the domain knowledge-base of interest) to the structure Sibling with attribute Sex:Female, and that the domain relation Part-of can be expressed with the grammatical possessive, e.g., the car's engine.</S>
    <S sid="94" ssid="20">Given this dictionary, the structure-mapping algorithm iteratively replaces semantic structures by linguistic ones, until the entire semantic net has been recoded into a linguistic structure.</S>
    <S sid="95" ssid="21">There may be several ways of recoding a semantic representation into a linguistic one, which means structure-mapping systems have a choice between using the first acceptable reduction they find, or doing a search for a reduction that maximizes some optimality criterion (e.g., fewest number of words).</S>
    <S sid="96" ssid="22">The papers I read were not very clear on this issue, but I believe that while most of the systems surveyed use the first acceptable reduction found, FUF in some cases searches for an optimal reduction. choice from surface realization The consensus architecture clearly separates lexical choice of content words (done during sentence planning) from syntactic processing (performed during surface generation).</S>
    <S sid="97" ssid="23">In other words, it does not use an integrated `lexicogrammar', which systemic theorists in particular (e.g., [Matthiessen, 19911) have argued for, and which is implicit in some unification-based approaches, such as the semantic head-driven algorithm [Shieber et al., 19901.</S>
    <S sid="98" ssid="24">Despite these theoretical arguments, none of the systems examined used an integrated lexicogrammar, including unification-based FUF and systemic-based PENMAN.3 In contrast, earlier unification-based sys'Even though I have previously argued against structure-mapping because it does not do a good job of handling lexical preferences [Reiter, 1991], I nevertheless ended up using this technique when I moved from my Ph.D research to the more applications-oriented IDAS project.</S>
    <S sid="99" ssid="25">Perhaps this is another example of engineering considerations overriding theoretical arguments. terns, such as the tactical component of McKeown's TEXT system [McKeown, 1985], did integrate lexical and syntactic processing in a single 'tactical generator'; also, systemic systems that have been less driven by application needs than PENMAN, such as GENESYS [Fawcett and Tucker, 1990], have used integrated lexicogrammars.</S>
    <S sid="100" ssid="26">There is psychological evidence that at least some lexical processing is separated from syntactic processing, e.g., the patient mentioned in Section 4.1.1 who was able to perform content-determination and syntactic generation but had a very restricted speaking vocabulary.</S>
    <S sid="101" ssid="27">I think it's also very suggestive that humans have different learning patterns for content and function words; the former are 'open-class' and easily learned, while the latter are 'closed-class' and people tend to stick to the ones they learned as children.</S>
    <S sid="102" ssid="28">There is less evidence on the location of lexical choice in the psycholinguistic pipeline, and on whether it is performed in one stage or distributed among several stages.</S>
    <S sid="103" ssid="29">Surface generation has been used to mean many different things in the literature.</S>
    <S sid="104" ssid="30">I use it here to refer to the &amp;quot;portion of the generation system that knows how grammatical relationships are actually expressed in English (or whatever the target language is).</S>
    <S sid="105" ssid="31">For example, it is the surface generator that knows what function words and word order relationships are used in English for imperative, interrogative, and negated sentences; it is the surface generator that knows which auxiliaries are required for the various English tenses; and it is the surface generator that knows when pronominalization is syntactically required (John scolded himself, not John scolded John). with (almost?) no backtracking The grammars and grammar representations used by the systems examined are quite different, but all systems process the grammars with a top-down algorithm that uses minimal, if any, backtracking.</S>
    <S sid="106" ssid="32">None of the systems use the semantic head-driven generation algorithm [Shieber et at., 1990], although this is probably the single best-known algorithm for surface generation; Elhadad [1992, chapter 4] claims that such an algorithm is only necessary for systems that attempt to simultaneously perform both lexical choice and surface generation, which none of the examined systems do.</S>
    <S sid="107" ssid="33">Perhaps more interestingly, four of the five systems do not allow backtracking, and the fifth, FUF, allows backtracking but does not seem to use it much (if at all) during surface generation (backtracking is used in FUF during sentence planning).</S>
    <S sid="108" ssid="34">This is interesting, since backtracking is usually regarded as an essential component of unification-based generation approaches; it is certainly used in the semantic-headdriven algorithm, and in the TEXT generator [McKeown, 1985].</S>
    <S sid="109" ssid="35">From a psycholinguistic perspective, many people have argued that human language production is incremental (see the summary in [Levelt, 1989, pages 24-27]), which means that of necessity it cannot include much backtracking.</S>
    <S sid="110" ssid="36">The garden-path phenomena shows that there are limits to how much syntactic backtracking people people perform during language understanding.</S>
    <S sid="111" ssid="37">This evidence is of course suggestive rather than definitive; it seems likely that there are limitations on how much (if any) backtracking humans will perform during syntactic processing (see also the arguments in [McDonald, 1983]), but there is no hard proof of this (as far as I am aware).</S>
    <S sid="112" ssid="38">These modules will not be further examined here, mainly because little information is given in the papers on the details of how morphology and formatting are implemented.</S>
  </SECTION>
  <SECTION title="5 A Controversial (?)" number="6">
    <S sid="113" ssid="1">I would like to conclude with a perhaps controversial personal opinion.</S>
    <S sid="114" ssid="2">There have been many cases where NL generation researchers (including myself) have claimed that a certain linguistic phenomena is best handled by a certain architecture.</S>
    <S sid="115" ssid="3">Even if this is true, however, if it turns out that adopting this architecture will substantially complicate the design of the overall generation system, and that the most common cases of the phenomena of interest can be adequately handled by adding a few heuristics to the appropriate stage of a simpler architecture, then the engineeringoriented NL worker must ask him- or herself if the benefits of the proposed architecture truly outweigh its costs.</S>
    <S sid="116" ssid="4">For instance, one cannot simply argue that an integrated architecture is superior to a pipeline because it is better suited to handling certain kinds of pronominalization; it is also necessary to evaluate the engineering cost of shifting to an integrated architecture, and determine if, for example, better overall performance for the amount of engineering resources available could be obtained by keeping the general pipeline architecture, and instead investing some of the engineering resources 'saved' by this decision into building more sophisticated heuristics into the pronominalization module.</S>
    <S sid="117" ssid="5">In doing so, I believe (and again this is a personal belief that probably cannot be substantiated by the existing evidence) that the NL engineer is coming close to the 'reasoning' of the evolutionary process that created the human language system.</S>
    <S sid="118" ssid="6">Evolution does not care about elegant declarative formalisms or 'proper' (as opposed to chacky') handling of special cases; evolution's goal is to maximize performance in real-world situations, while maintaining an architecture that can be easily tinkered with by future evolutionary processes.</S>
    <S sid="119" ssid="7">In short, evolution is an engineer, not a mathematician.4 It is thus perhaps not surprising if NL generation systems designed to be used in real-world applications end up with an architecture that seem to bear some resemblance to the architecture of the human language processor;5 and future attempts to build applications-oriented generation systems may end up giving us real insights into how language processing works in humans, even if this is not the main purpose of these systems.</S>
    <S sid="120" ssid="8">Similarly, psycholinguistic knowledge of how the human language generator works may suggest useful algorithms for NL engineers; one such case is described in [Reiter and Dale, 1992].</S>
    <S sid="121" ssid="9">Cross-fertilization between psycholinguistics and NL engineering will only arise, however, if the results of engineering analyses are reported in the research literature, especially when they suggest going against some theoretical principle.</S>
    <S sid="122" ssid="10">Unfortunately, to date the results of such analyses have all-too-often been regarded more as embarrassments (since they contradict theory) than as valuable observations, and hence have not been published.</S>
    <S sid="123" ssid="11">I would like to conclude this paper by encouraging generation researchers to regard the results of engineering analyses to be as interesting and as important to the understanding of language as conventional linguistic analyses.</S>
    <S sid="124" ssid="12">After all, as Woods [1975] has pointed out, while descriptive analyses of language can at best tell us what the brain does, engineering analyses can potentially offer insights on why the brain functions as it does.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="7">
    <S sid="125" ssid="1">I would like to thank Jean Carletta, Robert Dale, Michael Elhadad, David McDonald, Richard Kittredge, Tanya Korelsky, Chris Mellish, Owen Rambow, and Graeme Ritchie for their very helpful comments on earlier versions of this work.</S>
    <S sid="126" ssid="2">It goes without saying, of course, that the views represented are my own, and that any factual errors are entirely my fault.</S>
    <S sid="127" ssid="3">This re4Gould's various popular books on evolutionary biology, such as [Gould, 1983], give an excellent feel for evolution as an engineer-cum-hackers; see also the interesting discussion of language and evolution in [Pinker, 1994].</S>
    <S sid="128" ssid="4">50f course, the best way to do something on a machine is often not the best way to do it in nature; e.g., birds and airplanes use different mechanisms to fly.</S>
    <S sid="129" ssid="5">On the other hand, there does seem to be a remarkable congruence between effective vision processing strategies in animals and computers [Marr, 1982].</S>
    <S sid="130" ssid="6">One could also argue that since language (unlike flying) is purely a product of the human mind, any effective language processor is probably going to have to share some of the mind's processing strategies. search was mostly done while the author was at the University of Edinburgh, where he was supported by SERC grant GR/F/36750.</S>
  </SECTION>
</PAPER>
