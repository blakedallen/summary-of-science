<PAPER>
  <S sid="0">Learning To Recognize Features Of Valid Textual Entailments</S>
  <ABSTRACT>
    <S sid="1" ssid="1">This paper advocates a new architecture for textual inference in which finding a good alignment is separated from evaluating entailment.</S>
    <S sid="2" ssid="2">Current approaches to semantic inference in question answering and textual entailment have approximated the entailment problem as that of computing the best alignment of the hypothesis to the text, using a locally decomposable matching score.</S>
    <S sid="3" ssid="3">We argue that there are significant weaknesses in this approach, including flawed assumptions of monotonicity and locality.</S>
    <S sid="4" ssid="4">Instead we propose a pipelined approach where alignment is followed by a classification step, in which we extract features representing high-level characteristics of the entailment problem, and pass the resulting feature vector to a statistical classifier trained on development data.</S>
    <S sid="5" ssid="5">We report results on data from the 2005 Pascal RTE Challenge which surpass previously reported results for alignment-based systems.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="6" ssid="1">During the last five years there has been a surge in work which aims to provide robust textual inference in arbitrary domains about which the system has no expertise.</S>
    <S sid="7" ssid="2">The best-known such work has occurred within the field of question answering (Pasca and Harabagiu, 2001; Moldovan et al., 2003); more recently, such work has continued with greater focus in addressing the PASCAL Recognizing Textual Entailment (RTE) Challenge (Dagan et al., 2005) and within the U.S. Government AQUAINT program.</S>
    <S sid="8" ssid="3">Substantive progress on this task is key to many text and natural language applications.</S>
    <S sid="9" ssid="4">If one could tell that Protestors chanted slogans opposing a free trade agreement was a match for people demonstrating against free trade, then one could offer a form of semantic search not available with current keywordbased search.</S>
    <S sid="10" ssid="5">Even greater benefits would flow to richer and more semantically complex NLP tasks.</S>
    <S sid="11" ssid="6">Because full, accurate, open-domain natural language understanding lies far beyond current capabilities, nearly all efforts in this area have sought to extract the maximum mileage from quite limited semantic representations.</S>
    <S sid="12" ssid="7">Some have used simple measures of semantic overlap, but the more interesting work has largely converged on a graphalignment approach, operating on semantic graphs derived from syntactic dependency parses, and using a locally-decomposable alignment score as a proxy for strength of entailment.</S>
    <S sid="13" ssid="8">(Below, we argue that even approaches relying on weighted abduction may be seen in this light.)</S>
    <S sid="14" ssid="9">In this paper, we highlight the fundamental semantic limitations of this type of approach, and advocate a multi-stage architecture that addresses these limitations.</S>
    <S sid="15" ssid="10">The three key limitations are an assumption of monotonicity, an assumption of locality, and a confounding of alignment and evaluation of entailment.</S>
    <S sid="16" ssid="11">We focus on the PASCAL RTE data, examples from which are shown in table 1.</S>
    <S sid="17" ssid="12">This data set contains pairs consisting of a short text followed by a one-sentence hypothesis.</S>
    <S sid="18" ssid="13">The goal is to say whether the hypothesis follows from the text and general background knowledge, according to the intuitions of an intelligent human reader.</S>
    <S sid="19" ssid="14">That is, the standard is not whether the hypothesis is logically entailed, but whether it can reasonably be inferred.</S>
  </SECTION>
  <SECTION title="2 Approaching a robust semantics" number="2">
    <S sid="20" ssid="1">In this section we try to give a unifying overview to current work on robust textual inference, to present fundamental limitations of current methods, and then to outline our approach to resolving them.</S>
    <S sid="21" ssid="2">Nearly all current textual inference systems use a single-stage matching/proof process, and differ mainly in the sophistication of the matching stage.</S>
    <S sid="22" ssid="3">The simplest approach is to base the entailment prediction on the degree of semantic overlap between the text and hypothesis using models based on bags of words, bags of n-grams, TF-IDF scores, or something similar (Jijkoun and de Rijke, 2005).</S>
    <S sid="23" ssid="4">Such models have serious limitations: semantic overlap is typically a symmetric relation, whereas entailment is clearly not, and, because overlap models do not account for syntactic or semantic structure, they are easily fooled by examples like ID 2081.</S>
    <S sid="24" ssid="5">A more structured approach is to formulate the entailment prediction as a graph matching problem (Haghighi et al., 2005; de Salvo Braz et al., 2005).</S>
    <S sid="25" ssid="6">In this formulation, sentences are represented as normalized syntactic dependency graphs (like the one shown in figure 1) and entailment is approximated with an alignment between the graph representing the hypothesis and a portion of the corresponding graph(s) representing the text.</S>
    <S sid="26" ssid="7">Each possible alignment of the graphs has an associated score, and the score of the best alignment is used as an approximation to the strength of the entailment: a betteraligned hypothesis is assumed to be more likely to be entailed.</S>
    <S sid="27" ssid="8">To enable incremental search, alignment scores are usually factored as a combination of local terms, corresponding to the nodes and edges of the two graphs.</S>
    <S sid="28" ssid="9">Unfortunately, even with factored scores the problem of finding the best alignment of two graphs is NP-complete, so exact computation is intractable.</S>
    <S sid="29" ssid="10">Authors have proposed a variety of approximate search techniques.</S>
    <S sid="30" ssid="11">Haghighi et al. (2005) divide the search into two steps: in the first step they consider node scores only, which relaxes the problem to a weighted bipartite graph matching that can be solved in polynomial time, and in the second step they add the edges scores and hillclimb the alignment via an approximate local search.</S>
    <S sid="31" ssid="12">A third approach, exemplified by Moldovan et al. (2003) and Raina et al.</S>
    <S sid="32" ssid="13">(2005), is to translate dependency parses into neo-Davidsonian-style quasilogical forms, and to perform weighted abductive theorem proving in the tradition of (Hobbs et al., 1988).</S>
    <S sid="33" ssid="14">Unless supplemented with a knowledge base, this approach is actually isomorphic to the graph matching approach.</S>
    <S sid="34" ssid="15">For example, the graph in figure 1 might generate the quasi-LF rose(e1), nsubj(e1, x1), sales(x1), nn(x1, x2), Mitsubishi(x2), dobj(e1, x3), percent(x3), num(x3, x4), 46(x4).</S>
    <S sid="35" ssid="16">There is a term corresponding to each node and arc, and the resolution steps at the core of weighted abduction theorem proving consider matching an individual node of the hypothesis (e.g. rose(e1)) with something from the text (e.g. fell(e1)), just as in the graph-matching approach.</S>
    <S sid="36" ssid="17">The two models become distinct when there is a good supply of additional linguistic and world knowledge axioms&#8212;as in Moldovan et al. (2003) but not Raina et al.</S>
    <S sid="37" ssid="18">(2005).</S>
    <S sid="38" ssid="19">Then the theorem prover may generate intermediate forms in the proof, but, nevertheless, individual terms are resolved locally without reference to global context.</S>
    <S sid="39" ssid="20">Finally, a few efforts (Akhmatova, 2005; Fowler et al., 2005; Bos and Markert, 2005) have tried to translate sentences into formulas of first-order logic, in order to test logical entailment with a theorem prover.</S>
    <S sid="40" ssid="21">While in principle this approach does not suffer from the limitations we describe below, in practice it has not borne much fruit.</S>
    <S sid="41" ssid="22">Because few problem sentences can be accurately translated to logical form, and because logical entailment is a strict standard, recall tends to be poor.</S>
    <S sid="42" ssid="23">The simple graph matching formulation of the problem belies three important issues.</S>
    <S sid="43" ssid="24">First, the above systems assume a form of upward monotonicity: if a good match is found with a part of the text, other material in the text is assumed not to affect the validity of the match.</S>
    <S sid="44" ssid="25">But many situations lack this upward monotone character.</S>
    <S sid="45" ssid="26">Consider variants on ID 98.</S>
    <S sid="46" ssid="27">Suppose the hypothesis were Arafat targeted for assassination.</S>
    <S sid="47" ssid="28">This would allow a perfect graph match or zero-cost weighted abductive proof, because the hypothesis is a subgraph of the text.</S>
    <S sid="48" ssid="29">However, this would be incorrect because it ignores the modal operator could.</S>
    <S sid="49" ssid="30">Information that changes the validity of a proof can also exist outside a matching clause.</S>
    <S sid="50" ssid="31">Consider the alternate text Sharon denies Arafat is targeted for assassination.1 The second issue is the assumption of locality.</S>
    <S sid="51" ssid="32">Locality is needed to allow practical search, but many entailment decisions rely on global features of the alignment, and thus do not naturally factor by nodes and edges.</S>
    <S sid="52" ssid="33">To take just one example, dropping a restrictive modifier preserves entailment in a positive context, but not in a negative one.</S>
    <S sid="53" ssid="34">For example, Dogs barked loudly entails Dogs barked, but No dogs barked loudly does not entail No dogs barked.</S>
    <S sid="54" ssid="35">These more global phenomena cannot be modeled with a factored alignment score.</S>
    <S sid="55" ssid="36">The last issue arising in the graph matching approaches is the inherent confounding of alignment and entailment determination.</S>
    <S sid="56" ssid="37">The way to show that one graph element does not follow from another is to make the cost of aligning them high.</S>
    <S sid="57" ssid="38">However, since we are embedded in a search for the lowest cost alignment, this will just cause the system to choose an alternate alignment rather than recognizing a non-entailment.</S>
    <S sid="58" ssid="39">In ID 152, we would like the hypothesis to align with the first part of the text, to be able to prove that civilians are not members of law enforcement agencies and conclude that the hypothesis does not follow from the text.</S>
    <S sid="59" ssid="40">But a graphmatching system will to try to get non-entailment by making the matching cost between civilians and members of law enforcement agencies be very high.</S>
    <S sid="60" ssid="41">However, the likely result of that is that the final part of the hypothesis will align with were civilians at the end of the text, assuming that we allow an alignment with &#8220;loose&#8221; arc correspondence.2 Under this candidate alignment, the lexical alignments are perfect, and the only imperfect alignment is the subject arc of were is mismatched in the two.</S>
    <S sid="61" ssid="42">A robust inference guesser will still likely conclude that there is entailment.</S>
    <S sid="62" ssid="43">We propose that all three problems can be resolved in a two-stage architecture, where the alignment phase is followed by a separate phase of entailment determination.</S>
    <S sid="63" ssid="44">Although developed independently, the same division between alignment and classification has also been proposed by Marsi and Krahmer (2005), whose textual system is developed and evaluated on parallel translations into Dutch.</S>
    <S sid="64" ssid="45">Their classification phase features an output space of five semantic relations, and performs well at distinguishing entailing sentence pairs.</S>
    <S sid="65" ssid="46">Finding aligned content can be done by any search procedure.</S>
    <S sid="66" ssid="47">Compared to previous work, we emphasize structural alignment, and seek to ignore issues like polarity and quantity, which can be left to a subsequent entailment decision.</S>
    <S sid="67" ssid="48">For example, the scoring function is designed to encourage antonym matches, and ignore the negation of verb predicates.</S>
    <S sid="68" ssid="49">The ideas clearly generalize to evaluating several alignments, but we have so far worked with just the one-best alignment.</S>
    <S sid="69" ssid="50">Given a good alignment, the determination of entailment reduces to a simple classification decision.</S>
    <S sid="70" ssid="51">The classifier is built over features designed to recognize patterns of valid and invalid inference.</S>
    <S sid="71" ssid="52">Weights for the features can be hand-set or chosen to minimize a relevant loss function on training data using standard techniques from machine learning.</S>
    <S sid="72" ssid="53">Because we already have a complete alignment, the classifier&#8217;s decision can be conditioned on arbitrary global features of the aligned graphs, and it can detect failures of monotonicity.</S>
  </SECTION>
  <SECTION title="3 System" number="3">
    <S sid="73" ssid="1">Our system has three stages: linguistic analysis, alignment, and entailment determination.</S>
    <S sid="74" ssid="2">Our goal in this stage is to compute linguistic representations of the text and hypothesis that contain as much information as possible about their semantic content.</S>
    <S sid="75" ssid="3">We use typed dependency graphs, which contain a node for each word and labeled edges representing the grammatical relations between words.</S>
    <S sid="76" ssid="4">Figure 1 gives the typed dependency graph for ID 971.</S>
    <S sid="77" ssid="5">This representation contains much of the information about words and relations between them, and is relatively easy to compute from a syntactic parse.</S>
    <S sid="78" ssid="6">However many semantic phenomena are not represented properly; particularly egregious is the inability to represent quantification and modality.</S>
    <S sid="79" ssid="7">We parse input sentences to phrase structure trees using the Stanford parser (Klein and Manning, 2003), a statistical syntactic parser trained on the Penn TreeBank.</S>
    <S sid="80" ssid="8">To ensure correct parsing, we preprocess the sentences to collapse named entities into new dedicated tokens.</S>
    <S sid="81" ssid="9">Named entities are identified by a CRF-based NER system, similar to that described in (McCallum and Li, 2003).</S>
    <S sid="82" ssid="10">After parsing, contiguous collocations which appear in WordNet (Fellbaum, 1998) are identified and grouped.</S>
    <S sid="83" ssid="11">We convert the phrase structure trees to typed dependency graphs using a set of deterministic handcoded rules (de Marneffe et al., 2006).</S>
    <S sid="84" ssid="12">In these rules, heads of constituents are first identified using a modified version of the Collins head rules that favor semantic heads (such as lexical verbs rather than auxiliaries), and dependents of heads are typed using tregex patterns (Levy and Andrew, 2006), an extension of the tgrep pattern language.</S>
    <S sid="85" ssid="13">The nodes in the final graph are then annotated with their associated word, part-of-speech (given by the parser), lemma (given by a finite-state transducer described by Minnen et al. (2001)) and named-entity tag.</S>
    <S sid="86" ssid="14">The purpose of the second phase is to find a good partial alignment between the typed dependency graphs representing the hypothesis and the text.</S>
    <S sid="87" ssid="15">An alignment consists of a mapping from each node (word) in the hypothesis graph to a single node in the text graph, or to null.3 Figure 1 gives the alignment for ID 971.</S>
    <S sid="88" ssid="16">The space of alignments is large: there are O((m + 1)') possible alignments for a hypothesis graph with n nodes and a text graph with m nodes.</S>
    <S sid="89" ssid="17">We define a measure of alignment quality, and a procedure for identifying high scoring alignments.</S>
    <S sid="90" ssid="18">We choose a locally decomposable scoring function, such that the score of an alignment is the sum of the local node and edge alignment scores.</S>
    <S sid="91" ssid="19">Unfortunately, there is no polynomial time algorithm for finding the exact best alignment.</S>
    <S sid="92" ssid="20">Instead we use an incremental beam search, combined with a node ordering heuristic, to do approximate global search in the space of possible alignments.</S>
    <S sid="93" ssid="21">We have experimented with several alternative search techniques, and found that the solution quality is not very sensitive to the specific search procedure used.</S>
    <S sid="94" ssid="22">Our scoring measure is designed to favor alignments which align semantically similar subgraphs, irrespective of polarity.</S>
    <S sid="95" ssid="23">For this reason, nodes receive high alignment scores when the words they represent are semantically similar.</S>
    <S sid="96" ssid="24">Synonyms and antonyms receive the highest score, and unrelated words receive the lowest.</S>
    <S sid="97" ssid="25">Our hand-crafted scoring metric takes into account the word, the lemma, and the part of speech, and searches for word relatedness using a range of external resources, including WordNet, precomputed latent semantic analysis matrices, and special-purpose gazettes.</S>
    <S sid="98" ssid="26">Alignment scores also incorporate local edge scores, which are based on the shape of the paths between nodes in the text graph which correspond to adjacent nodes in the hypothesis graph.</S>
    <S sid="99" ssid="27">Preserved edges receive the highest score, and longer paths receive lower scores.</S>
    <S sid="100" ssid="28">In the final stage of processing, we make a decision about whether or not the hypothesis is entailed by the text, conditioned on the typed dependency graphs, as well as the best alignment between them.</S>
    <S sid="101" ssid="29">Because we have a data set of examples that are labeled for entailment, we can use techniques from supervised machine learning to learn a classifier.</S>
    <S sid="102" ssid="30">We adopt the standard approach of defining a featural representation of the problem and then learning a linear decision boundary in the feature space.</S>
    <S sid="103" ssid="31">We focus here on the learning methodology; the next section covers the definition of the set of features.</S>
    <S sid="104" ssid="32">Defined in this way, one can apply any statistical learning algorithm to this classification task, such as support vector machines, logistic regression, or naive Bayes.</S>
    <S sid="105" ssid="33">We used a logistic regression classifier with a Gaussian prior parameter for regularization.</S>
    <S sid="106" ssid="34">We also compare our learning results with those achieved by hand-setting the weight parameters for the classifier, effectively incorporating strong prior (human) knowledge into the choice of weights.</S>
    <S sid="107" ssid="35">An advantage to the use of statistical classifiers is that they can be configured to output a probability distribution over possible answers rather than just the most likely answer.</S>
    <S sid="108" ssid="36">This allows us to get confidence estimates for computing a confidence weighted score (see section 5).</S>
    <S sid="109" ssid="37">A major concern in applying machine learning techniques to this classification problem is the relatively small size of the training set, which can lead to overfitting problems.</S>
    <S sid="110" ssid="38">We address this by keeping the feature dimensionality small, and using high regularization penalties in training.</S>
  </SECTION>
  <SECTION title="4 Feature representation" number="4">
    <S sid="111" ssid="1">In the entailment determination phase, the entailment problem is reduced to a representation as a vector of 28 features, over which the statistical classifier described above operates.</S>
    <S sid="112" ssid="2">These features try to capture salient patterns of entailment and non-entailment, with particular attention to contexts which reverse or block monotonicity, such as negations and quantifiers.</S>
    <S sid="113" ssid="3">This section describes the most important groups of features.</S>
    <S sid="114" ssid="4">Polarity features.</S>
    <S sid="115" ssid="5">These features capture the presence (or absence) of linguistic markers of negative polarity contexts in both the text and the hypothesis, such as simple negation (not), downward-monotone quantifiers (no, few), restricting prepositions (without, except) and superlatives (tallest).</S>
    <S sid="116" ssid="6">Adjunct features.</S>
    <S sid="117" ssid="7">These indicate the dropping or adding of syntactic adjuncts when moving from the text to the hypothesis.</S>
    <S sid="118" ssid="8">For the common case of restrictive adjuncts, dropping an adjunct preserves truth (Dogs barked loudly &#65533;= Dogs barked), while adding an adjunct does not (Dogs barked K Dogs barked today).</S>
    <S sid="119" ssid="9">However, in negative-polarity contexts (such as No dogs barked), this heuristic is reversed: adjuncts can safely be added, but not dropped.</S>
    <S sid="120" ssid="10">For example, in ID 59, the hypothesis aligns well with the text, but the addition of in Iraq indicates non-entailment.</S>
    <S sid="121" ssid="11">We identify the &#8220;root nodes&#8221; of the problem: the root node of the hypothesis graph and the corresponding aligned node in the text graph.</S>
    <S sid="122" ssid="12">Using dependency information, we identify whether adjuncts have been added or dropped.</S>
    <S sid="123" ssid="13">We then determine the polarity (negative context, positive context or restrictor of a universal quantifier) of the two root nodes to generate features accordingly.</S>
    <S sid="124" ssid="14">Antonymy features.</S>
    <S sid="125" ssid="15">Entailment problems might involve antonymy, as in ID 971.</S>
    <S sid="126" ssid="16">We check whether an aligned pairs of text/hypothesis words appear to be antonymous by consulting a pre-computed list of about 40,000 antonymous and other contrasting pairs derived from WordNet.</S>
    <S sid="127" ssid="17">For each antonymous pair, we generate one of three boolean features, indicating whether (i) the words appear in contexts of matching polarity, (ii) only the text word appears in a negative-polarity context, or (iii) only the hypothesis word does.</S>
    <S sid="128" ssid="18">Modality features.</S>
    <S sid="129" ssid="19">Modality features capture simple patterns of modal reasoning, as in ID 98, which illustrates the heuristic that possibility does not entail actuality.</S>
    <S sid="130" ssid="20">According to the occurrence (or not) of predefined modality markers, such as must or maybe, we map the text and the hypothesis to one of six modalities: possible, not possible, actual, not actual, necessary, and not necessary.</S>
    <S sid="131" ssid="21">The text/hypothesis modality pair is then mapped into one of the following entailment judgments: yes, weak yes, don&#8217;t know, weak no, or no.</S>
    <S sid="132" ssid="22">For example: (not possible |= not actual)?</S>
    <S sid="133" ssid="23">&#8658; yes (possible |= necessary)?</S>
    <S sid="134" ssid="24">&#8658; weak no Factivity features.</S>
    <S sid="135" ssid="25">The context in which a verb phrase is embedded may carry semantic presuppositions giving rise to (non-)entailments such as The gangster tried to escape 6|= The gangster escaped.</S>
    <S sid="136" ssid="26">This pattern of entailment, like others, can be reversed by negative polarity markers (The gangster managed to escape |= The gangster escaped while The gangster didn&#8217;t manage to escape 6|= The gangster escaped).</S>
    <S sid="137" ssid="27">To capture these phenomena, we compiled small lists of &#8220;factive&#8221; and non-factive verbs, clustered according to the kinds of entailments they create.</S>
    <S sid="138" ssid="28">We then determine to which class the parent of the text aligned with the hypothesis root belongs to.</S>
    <S sid="139" ssid="29">If the parent is not in the list, we only check whether the embedding text is an affirmative context or a negative one.</S>
    <S sid="140" ssid="30">Quantifier features.</S>
    <S sid="141" ssid="31">These features are designed to capture entailment relations among simple sentences involving quantification, such as Every company must report |= A company must report (or The company, or IBM).</S>
    <S sid="142" ssid="32">No attempt is made to handle multiple quantifiers or scope ambiguities.</S>
    <S sid="143" ssid="33">Each quantifier found in an aligned pair of text/hypothesis words is mapped into one of five quantifier categories: no, some, many, most, and all.</S>
    <S sid="144" ssid="34">The no category is set apart, while an ordering over the other four categories is defined.</S>
    <S sid="145" ssid="35">The some category also includes definite and indefinite determiners and small cardinal numbers.</S>
    <S sid="146" ssid="36">A crude attempt is made to handle negation by interchanging no and all in the presence of negation.</S>
    <S sid="147" ssid="37">Features are generated given the categories of both hypothesis and text.</S>
    <S sid="148" ssid="38">Number, date, and time features.</S>
    <S sid="149" ssid="39">These are designed to recognize (mis-)matches between numbers, dates, and times, as in IDs 1806 and 231.</S>
    <S sid="150" ssid="40">We do some normalization (e.g. of date representations) and have a limited ability to do fuzzy matching.</S>
    <S sid="151" ssid="41">In ID 1806, the mismatched years are correctly identified.</S>
    <S sid="152" ssid="42">Unfortunately, in ID 231 the significance of over is not grasped and a mismatch is reported.</S>
    <S sid="153" ssid="43">Alignment features.</S>
    <S sid="154" ssid="44">Our feature representation includes three real-valued features intended to represent the quality of the alignment: score is the raw score returned from the alignment phase, while goodscore and badscore try to capture whether the alignment score is &#8220;good&#8221; or &#8220;bad&#8221; by computing the sigmoid function of the distance between the alignment score and hard-coded &#8220;good&#8221; and &#8220;bad&#8221; reference values.</S>
  </SECTION>
  <SECTION title="5 Evaluation" number="5">
    <S sid="155" ssid="1">We present results based on the First PASCAL RTE Challenge, which used a development set containing 567 pairs and a test set containing 800 pairs.</S>
    <S sid="156" ssid="2">The data sets are balanced to contain equal numbers of yes and no answers.</S>
    <S sid="157" ssid="3">The RTE Challenge recommended two evaluation metrics: raw accuracy and confidence weighted score (CWS).</S>
    <S sid="158" ssid="4">The CWS is computed as follows: for each positive integer k up to the size of the test set, we compute accuracy over the k most confident predictions.</S>
    <S sid="159" ssid="5">The CWS is then the average, over k, of these partial accuracies.</S>
    <S sid="160" ssid="6">Like raw accuracy, it lies in the interval [0, 1], but it will exceed raw accuracy to the degree that predictions are well-calibrated.</S>
    <S sid="161" ssid="7">Several characteristics of the RTE problems should be emphasized.</S>
    <S sid="162" ssid="8">Examples are derived from a broad variety of sources, including newswire; therefore systems must be domain-independent.</S>
    <S sid="163" ssid="9">The inferences required are, from a human perspective, fairly superficial: no long chains of reasoning are involved.</S>
    <S sid="164" ssid="10">However, there are &#8220;trick&#8221; questions expressly designed to foil simplistic techniques.</S>
    <S sid="165" ssid="11">The definition of entailment is informal and approximate: whether a competent speaker with basic knowledge of the world would typically infer the hypothesis from the text.</S>
    <S sid="166" ssid="12">Entailments will certainly depend on linguistic knowledge, and may also depend on world knowledge; however, the scope of required world knowledge is left unspecified.4 Despite the informality of the problem definition, human judges exhibit very good agreement on the RTE task, with agreement rate of 91&#8211;96% (Dagan et al., 2005).</S>
    <S sid="167" ssid="13">In principle, then, the upper bound for machine performance is quite high.</S>
    <S sid="168" ssid="14">In practice, however, the RTE task is exceedingly difficult for computers.</S>
    <S sid="169" ssid="15">Participants in the first PASCAL RTE workshop reported accuracy from 49% to 59%, and CWS from 50.0% to 69.0% (Dagan et al., 2005).</S>
    <S sid="170" ssid="16">Table 2 shows results for a range of systems and testing conditions.</S>
    <S sid="171" ssid="17">We report accuracy and CWS on each RTE data set.</S>
    <S sid="172" ssid="18">The baseline for all experiments is random guessing, which always attains 50% accuracy.</S>
    <S sid="173" ssid="19">We show comparable results from recent systems based on lexical similarity (Jijkoun and de Rijke, 2005), graph alignment (Haghighi et al., 2005), weighted abduction (Raina et al., 2005), and a mixed system including theorem proving (Bos and Markert, 2005).</S>
    <S sid="174" ssid="20">We then show results for our system under several different training regimes.</S>
    <S sid="175" ssid="21">The row labeled &#8220;alignment only&#8221; describes experiments in which all features except the alignment score are turned off.</S>
    <S sid="176" ssid="22">We predict entailment just in case the alignment score exceeds a threshold which is optimized on development data.</S>
    <S sid="177" ssid="23">&#8220;Hand-tuning&#8221; describes experiments in which all features are on, but no training occurs; rather, weights are set by hand, according to human intuition.</S>
    <S sid="178" ssid="24">Finally, &#8220;learning&#8221; describes experiments in which all features are on, and feature weights are trained on the development data.</S>
    <S sid="179" ssid="25">The 4Each RTE problem is also tagged as belonging to one of seven tasks.</S>
    <S sid="180" ssid="26">Previous work (Raina et al., 2005) has shown that conditioning on task can significantly improve accuracy.</S>
    <S sid="181" ssid="27">In this work, however, we ignore the task variable, and none of the results shown in table 2 reflect optimization by task. figures reported for development data performance therefore reflect overfitting; while such results are not a fair measure of overall performance, they can help us assess the adequacy of our feature set: if our features have failed to capture relevant aspects of the problem, we should expect poor performance even when overfitting.</S>
    <S sid="182" ssid="28">It is therefore encouraging to see CWS above 70%.</S>
    <S sid="183" ssid="29">Finally, the figures reported for test data performance are the fairest basis for comparison.</S>
    <S sid="184" ssid="30">These are significantly better than our results for alignment only (Fisher&#8217;s exact test, p &lt; 0.05), indicating that we gain real value from our features.</S>
    <S sid="185" ssid="31">However, the gain over comparable results from other teams is not significant at the p &lt; 0.05 level.</S>
    <S sid="186" ssid="32">A curious observation is that the results for handtuned weights are as good or better than results for learned weights.</S>
    <S sid="187" ssid="33">A possible explanation runs as follows.</S>
    <S sid="188" ssid="34">Most of the features represent high-level patterns which arise only occasionally.</S>
    <S sid="189" ssid="35">Because the training data contains only a few hundred examples, many features are active in just a handful of instances; their learned weights are therefore quite noisy.</S>
    <S sid="190" ssid="36">Indeed, a feature which is expected to favor entailment may even wind up with a negative weight: the modal feature weak yes is an example.</S>
    <S sid="191" ssid="37">As shown in table 3, the learned weight for this feature was strongly negative &#8212; but this resulted from a single training example in which the feature was active but the hypothesis was not entailed.</S>
    <S sid="192" ssid="38">In such cases, we shouldn&#8217;t expect good generalization to test data, and human intuition about the &#8220;value&#8221; of specific features may be more reliable.</S>
    <S sid="193" ssid="39">Table 3 shows the values learned for selected feature weights.</S>
    <S sid="194" ssid="40">As expected, the features added adjunct in all context, modal yes, and text is factive were all found to be strong indicators of entailment, while date insert, date modifier insert, widening from text to hyp all indicate lack of entailment.</S>
    <S sid="195" ssid="41">Interestingly, text has neg marker and text &amp; hyp diffpolarity were also found to disfavor entailment; while this outcome is sensible, it was not anticipated or designed.</S>
  </SECTION>
  <SECTION title="6 Conclusion" number="6">
    <S sid="196" ssid="1">The best current approaches to the problem of textual inference work by aligning semantic graphs, using a locally-decomposable alignment score as a proxy for strength of entailment.</S>
    <S sid="197" ssid="2">We have argued that such models suffer from three crucial limitations: an assumption of monotonicity, an assumption of locality, and a confounding of alignment and entailment determination.</S>
    <S sid="198" ssid="3">We have described a system which extends alignment-based systems while attempting to address these limitations.</S>
    <S sid="199" ssid="4">After finding the best alignment between text and hypothesis, we extract highlevel semantic features of the entailment problem, and input these features to a statistical classifier to make an entailment decision.</S>
    <S sid="200" ssid="5">Using this multi-stage architecture, we report results on the PASCAL RTE data which surpass previously-reported results for alignment-based systems.</S>
    <S sid="201" ssid="6">We see the present work as a first step in a promising direction.</S>
    <S sid="202" ssid="7">Much work remains in improving the entailment features, many of which may be seen as rough approximations to a formal monotonicity calculus.</S>
    <S sid="203" ssid="8">In future, we aim to combine more precise modeling of monotonicity effects with better modeling of paraphrase equivalence.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="7">
    <S sid="204" ssid="1">We thank Anna Rafferty, Josh Ainslie, and particularly Roger Grosse for contributions to the ideas and system reported here.</S>
    <S sid="205" ssid="2">This work was supported in part by the Advanced Research and Development Activity (ARDA)&#8217;s Advanced Question Answering for Intelligence (AQUAINT) Program.</S>
  </SECTION>
</PAPER>
