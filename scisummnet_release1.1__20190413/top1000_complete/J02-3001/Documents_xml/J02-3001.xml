<PAPER>
  <S sid="0">Automatic Labeling Of Semantic Roles</S>
  <ABSTRACT>
    <S sid="1" ssid="1">present a system for identifying the semantic relationships, or filled by constituents of a sentence within a semantic frame.</S>
    <S sid="2" ssid="2">Given an input sentence and a target word frame, the system labels constituents with either abstract semantic roles, such as or more domain-specific semantic roles, such as and The system is based on statistical classifiers trained on roughly 50,000 sentences that were hand-annotated with semantic roles by the FrameNet semantic labeling project.</S>
    <S sid="3" ssid="3">We then parsed each training sentence into a syntactic tree and extracted various lexical and syntactic features, including the phrase type of each constituent, its grammatical function, and its position in the sentence.</S>
    <S sid="4" ssid="4">These features were combined with knowledge of the predicate verb, noun, or adjective, as well as information such as the prior probabilities of various combinations of semantic roles.</S>
    <S sid="5" ssid="5">We used various lexical clustering algorithms to generalize across possible fillers of roles.</S>
    <S sid="6" ssid="6">Test sentences were parsed, were annotated with these features, and were then passed through the classifiers.</S>
    <S sid="7" ssid="7">Our system achieves 82% accuracy in identifying the semantic role of presegmented constituents.</S>
    <S sid="8" ssid="8">At the more difficult task of simultaneously segmenting constituents and identifying their semantic role, the system achieved 65% precision and 61% recall.</S>
    <S sid="9" ssid="9">Our study also allowed us to compare the usefulness of different features and feature combination methods in the semantic role labeling task.</S>
    <S sid="10" ssid="10">We also explore the integration of role labeling with statistical syntactic parsing and attempt to generalize to predicates unseen in the training data.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="11" ssid="1">We present a system for identifying the semantic relationships, or semantic roles, filled by constituents of a sentence within a semantic frame.</S>
    <S sid="12" ssid="2">Given an input sentence and a target word and frame, the system labels constituents with either abstract semantic roles, such as AGENT or PATIENT, or more domain-specific semantic roles, such as SPEAKER, MESSAGE, and TOPIC.</S>
    <S sid="13" ssid="3">The system is based on statistical classifiers trained on roughly 50,000 sentences that were hand-annotated with semantic roles by the FrameNet semantic labeling project.</S>
    <S sid="14" ssid="4">We then parsed each training sentence into a syntactic tree and extracted various lexical and syntactic features, including the phrase type of each constituent, its grammatical function, and its position in the sentence.</S>
    <S sid="15" ssid="5">These features were combined with knowledge of the predicate verb, noun, or adjective, as well as information such as the prior probabilities of various combinations of semantic roles.</S>
    <S sid="16" ssid="6">We used various lexical clustering algorithms to generalize across possible fillers of roles.</S>
    <S sid="17" ssid="7">Test sentences were parsed, were annotated with these features, and were then passed through the classifiers.</S>
    <S sid="18" ssid="8">Our system achieves 82% accuracy in identifying the semantic role of presegmented constituents.</S>
    <S sid="19" ssid="9">At the more difficult task of simultaneously segmenting constituents and identifying their semantic role, the system achieved 65% precision and 61% recall.</S>
    <S sid="20" ssid="10">Our study also allowed us to compare the usefulness of different features and feature combination methods in the semantic role labeling task.</S>
    <S sid="21" ssid="11">We also explore the integration of role labeling with statistical syntactic parsing and attempt to generalize to predicates unseen in the training data.</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="22" ssid="1">Recent years have been exhilarating ones for natural language understanding.</S>
    <S sid="23" ssid="2">The excitement and rapid advances that had characterized other language-processing tasks such as speech recognition, part-of-speech tagging, and parsing have finally begun to appear in tasks in which understanding and semantics play a greater role.</S>
    <S sid="24" ssid="3">For example, there has been widespread commercial deployment of simple speech-based natural language understanding systems that answer questions about flight arrival times, give directions, report on bank balances, or perform simple financial transactions.</S>
    <S sid="25" ssid="4">More sophisticated research systems generate concise summaries of news articles, answer fact-based questions, and recognize complex semantic and dialogue structure.</S>
    <S sid="26" ssid="5">But the challenges that lie ahead are still similar to the challenge that the field has faced since Winograd (1972): moving away from carefully hand-crafted, domaindependent systems toward robustness and domain independence.</S>
    <S sid="27" ssid="6">This goal is not as far away as it once was, thanks to the development of large semantic databases such as WordNet (Fellbaum 1998) and progress in domain-independent machine learning algorithms.</S>
    <S sid="28" ssid="7">Current information extraction and dialogue understanding systems, however, are still based on domain-specific frame-and-slot templates.</S>
    <S sid="29" ssid="8">Systems for booking airplane information use domain-specific frames with slots like ORIG CITY, DEST CITY, or DEPART TIME (Stallard 2000).</S>
    <S sid="30" ssid="9">Systems for studying mergers and acquisitions use slots like PRODUCTS, RELATIONSHIP, JOINT VENTURE COMPANY, and AMOUNT (Hobbs et al. 1997).</S>
    <S sid="31" ssid="10">For natural language understanding tasks to proceed beyond these specific domains, we need semantic frames and semantic understanding systems that do not require a new set of slots for each new application domain.</S>
    <S sid="32" ssid="11">In this article we describe a shallow semantic interpreter based on semantic roles that are less domain specific than TO AIRPORT or JOINT VENTURE COMPANY.</S>
    <S sid="33" ssid="12">These roles are defined at the level of semantic frames of the type introduced by Fillmore (1976), which describe abstract actions or relationships, along with their participants.</S>
    <S sid="34" ssid="13">For example, the JUDGEMENT frame contains roles like JUDGE, EVALUEE, and REASON, and the STATEMENT frame contains roles like SPEAKER, ADDRESSEE, and MESSAGE, as the following examples show: These shallow semantic roles could play an important role in information extraction.</S>
    <S sid="35" ssid="14">For example, a semantic role parse would allow a system to realize that the ruling that is the direct object of change in (3) plays the same THEME role as the ruling that is the subject of change in (4): The fact that semantic roles are defined at the frame level means, for example, that the verbs send and receive would share the semantic roles (SENDER, RECIPIENT, GOODS, etc.) defined with respect to a common TRANSFER frame.</S>
    <S sid="36" ssid="15">Such common frames might allow a question-answering system to take a question like (5) and discover that (6) is relevant in constructing an answer to the question: This shallow semantic level of interpretation has additional uses outside of generalizing information extraction, question answering, and semantic dialogue systems.</S>
    <S sid="37" ssid="16">One such application is in word sense disambiguation, where the roles associated with a word can be cues to its sense.</S>
    <S sid="38" ssid="17">For example, Lapata and Brew (1999) and others have shown that the different syntactic subcategorization frames of a verb such as serve can be used to help disambiguate a particular instance of the word.</S>
    <S sid="39" ssid="18">Adding semantic role subcategorization information to this syntactic information could extend this idea to use richer semantic knowledge.</S>
    <S sid="40" ssid="19">Semantic roles could also act as an important intermediate representation in statistical machine translation or automatic text summarization and in the emerging field of text data mining (TDM) (Hearst 1999).</S>
    <S sid="41" ssid="20">Finally, incorporating semantic roles into probabilistic models of language may eventually yield more accurate parsers and better language models for speech recognition.</S>
    <S sid="42" ssid="21">This article describes an algorithm for identifying the semantic roles filled by constituents in a sentence.</S>
    <S sid="43" ssid="22">We apply statistical techniques that have been successful for the related problems of syntactic parsing, part-of-speech tagging, and word sense disambiguation, including probabilistic parsing and statistical classification.</S>
    <S sid="44" ssid="23">Our statistical algorithms are trained on a hand-labeled data set: the FrameNet database (Baker, Fillmore, and Lowe 1998; Johnson et al. 2001).</S>
    <S sid="45" ssid="24">The FrameNet database defines a tag set of semantic roles called frame elements and included, at the time of our experiments, roughly 50,000 sentences from the British National Corpus hand-labeled with these frame elements.</S>
    <S sid="46" ssid="25">This article presents our system in stages, beginning in Section 2 with a more detailed description of the data and the set of frame elements or semantic roles used.</S>
    <S sid="47" ssid="26">We then introduce (in Section 3) the statistical classification technique used and examine in turn the knowledge sources of which our system makes use.</S>
    <S sid="48" ssid="27">Section 4 describes the basic syntactic and lexical features used by our system, which are derived from a Penn Treebank&#8211;style parse of individual sentences to be analyzed.</S>
    <S sid="49" ssid="28">We break our task into two subproblems: finding the relevant sentence constituents (deferred until Section 5), and giving them the correct semantic labels (Sections 4.2 and 4.3).</S>
    <S sid="50" ssid="29">Section 6 adds higher-level semantic knowledge to the system, attempting to model the selectional restrictions on role fillers not directly captured by lexical statistics.</S>
    <S sid="51" ssid="30">We compare hand-built and automatically derived resources for providing this information.</S>
    <S sid="52" ssid="31">Section 7 examines techniques for adding knowledge about systematic alternations in verb argument structure with sentence-level features.</S>
    <S sid="53" ssid="32">We combine syntactic parsing and semantic role identification into a single probability model in Section 8.</S>
    <S sid="54" ssid="33">Section 9 addresses the question of generalizing statistics from one target predicate to another, beginning with a look at domain-independent thematic roles in Section 9.1.</S>
    <S sid="55" ssid="34">Finally we draw conclusions and discuss future directions in Section 10.</S>
  </SECTION>
  <SECTION title="2." number="3">
    <S sid="56" ssid="1">Semantic roles are one of the oldest classes of constructs in linguistic theory, dating back thousands of years to Panini&#8217;s k&#175;araka theory (Misra 1966; Rocher 1964; Dahiya 1995).</S>
    <S sid="57" ssid="2">Longevity, in this case, begets variety, and the literature records scores of proposals for sets of semantic roles.</S>
    <S sid="58" ssid="3">These sets of roles range from the very specific to the very general, and many have been used in computational implementations of one type or another.</S>
    <S sid="59" ssid="4">At the specific end of the spectrum are domain-specific roles such as the FRoM AIRPoRT, To AIRPoRT, or DEPART TIME discussed above, or verb-specific roles such as EATER and EATEN for the verb eat.</S>
    <S sid="60" ssid="5">The opposite end of the spectrum consists of theories with only two &#8220;proto-roles&#8221; or &#8220;macroroles&#8221;: PRoTo-AGENT and PRoTo-PATIENT (Van Valin 1993; Dowty 1991).</S>
    <S sid="61" ssid="6">In between lie many theories with approximately 10 roles, such as Fillmore&#8217;s (1971) list of nine: AGENT, EXPERIENCER, INSTRUMENT, OBJECT, SoURCE, GoAL, LoCATIoN, TIME, and PATH.1 Sample domains and frames from the FrameNet lexicon.</S>
    <S sid="62" ssid="7">Many of these sets of roles have been proposed by linguists as part of theories of linking, the part of grammatical theory that describes the relationship between semantic roles and their syntactic realization.</S>
    <S sid="63" ssid="8">Other sets have been used by computer scientists in implementing natural language understanding systems.</S>
    <S sid="64" ssid="9">As a rule, the more abstract roles have been proposed by linguists, who are more concerned with explaining generalizations across verbs in the syntactic realization of their arguments, whereas the more specific roles have more often been proposed by computer scientists, who are more concerned with the details of the realization of the arguments of specific verbs.</S>
    <S sid="65" ssid="10">The FrameNet project (Baker, Fillmore, and Lowe 1998) proposes roles that are neither as general as the 10 abstract thematic roles, nor as specific as the thousands of potential verb-specific roles.</S>
    <S sid="66" ssid="11">FrameNet roles are defined for each semantic frame.</S>
    <S sid="67" ssid="12">A frame is a schematic representation of situations involving various participants, props, and other conceptual roles (Fillmore 1976).</S>
    <S sid="68" ssid="13">For example, the frame CONVERSATION, shown in Figure 1, is invoked by the semantically related verbs argue, banter, debate, converse, and gossip, as well as the nouns dispute, discussion, and tiff, and is defined as follows: The roles defined for this frame, and shared by all its lexical entries, include PROTAGONIST-1 and PROTAGONIST-2 or simply PROTAGONISTS for the participants in the conversation, as well as MEDIUM and TOPIC.</S>
    <S sid="69" ssid="14">Similarly, the JUDGMENT frame mentioned above has the roles JUDGE, EVALUEE, and REASON and is invoked by verbs such as blame, admire, and praise and nouns such as fault and admiration.</S>
    <S sid="70" ssid="15">We refer to the roles for a given frame as frame elements.</S>
    <S sid="71" ssid="16">A number of hand-annotated examples from the JUDGMENT frame are included below to give a flavor of the FrameNet database: Defining semantic roles at this intermediate frame level helps avoid some of the well-known difficulties of defining a unique small set of universal, abstract thematic roles while also allowing some generalization across the roles of different verbs, nouns, and adjectives, each of which adds semantics to the general frame or highlights a particular aspect of the frame.</S>
    <S sid="72" ssid="17">One way of thinking about traditional abstract thematic roles, such as AGENT and PATIENT, in the context of FrameNet is to conceive them as frame elements defined by abstract frames, such as action and motion, at the top of an inheritance hierarchy of semantic frames (Fillmore and Baker 2000).</S>
    <S sid="73" ssid="18">The examples above illustrate another difference between frame elements and thematic roles as commonly described in the literature.</S>
    <S sid="74" ssid="19">Whereas thematic roles tend to be arguments mainly of verbs, frame elements can be arguments of any predicate, and the FrameNet database thus includes nouns and adjectives as well as verbs.</S>
    <S sid="75" ssid="20">The examples above also illustrate a few of the phenomena that make it hard to identify frame elements automatically.</S>
    <S sid="76" ssid="21">Many of these are caused by the fact that there is not always a direct correspondence between syntax and semantics.</S>
    <S sid="77" ssid="22">Whereas the subject of blame is often the JUDGE, the direct object of blame can be an EVALUEE (e.g., the poor in &#8220;blaming the poor&#8221;) or a REASON (e.g., everything in &#8220;blame everything on coyotes&#8221;).</S>
    <S sid="78" ssid="23">The identity of the JUDGE can also be expressed in a genitive pronoun, (e.g., his in &#8220;his praise&#8221;) or even an adjective (e.g., critical in &#8220;critical praise&#8221;).</S>
    <S sid="79" ssid="24">The corpus used in this project is perhaps best described in terms of the methodology used by the FrameNet team.</S>
    <S sid="80" ssid="25">We outline the process here; for more detail see Johnson et al. (2001).</S>
    <S sid="81" ssid="26">As the first step, semantic frames were defined for the general domains chosen; the frame elements, or semantic roles for participants in a frame, were defined; and a list of target words, or lexical predicates whose meaning includes aspects of the frame, was compiled for each frame.</S>
    <S sid="82" ssid="27">Example sentences were chosen by searching the British National Corpus for instances of each target word.</S>
    <S sid="83" ssid="28">Separate searches were performed for various patterns over lexical items and part-of-speech sequences in the target words&#8217; context, producing a set of subcorpora for each target word, designed to capture different argument structures and ensure that some examples of each possible syntactic usage of the target word would be included in the final database.</S>
    <S sid="84" ssid="29">Thus, the focus of the project was on completeness of examples for lexicographic needs, rather than on statistically representative data.</S>
    <S sid="85" ssid="30">Sentences from each subcorpus were then annotated by hand, marking boundaries of each frame element expressed in the sentence and assigning tags for the annotated constituent&#8217;s frame semantic role, syntactic category (e.g., noun phrase or prepositional phrase), and grammatical function in relation to the target word (e.g., object or complement of a verb).</S>
    <S sid="86" ssid="31">In the final phase of the process, the annotated sentences for each target word were checked for consistency.</S>
    <S sid="87" ssid="32">In addition to the tags just mentioned, the annotations include certain other information, which we do not make use of in this work, such as word sense tags for some target words and tags indicating metaphoric usages.</S>
    <S sid="88" ssid="33">Tests of interannotator agreement were performed for data from a small number of predicates before the final consistency check.</S>
    <S sid="89" ssid="34">Interannotator agreement at the sentence level, including all frame element judgments and boundaries for one predicate, varied from .66 to .82 depending on the predicate.</S>
    <S sid="90" ssid="35">The kappa statistic (Siegel and Castellan 1988) varied from .67 to .82.</S>
    <S sid="91" ssid="36">Because of the large number of possible categories when boundary judgments are considered, kappa is nearly identical to the interannotator agreement.</S>
    <S sid="92" ssid="37">The system described in this article (which gets .65/.61 precision/recall on individual frame elements; see Table 15) correctly identifies all frame elements in 38% of test sentences.</S>
    <S sid="93" ssid="38">Although this .38 is not directly comparable to the .66&#8211;.82 interannotator agreements, it&#8217;s clear that the performance of our system still falls significantly short of human performance on the task.</S>
    <S sid="94" ssid="39">The British National Corpus was chosen as the basis of the FrameNet project despite differences between British and American usage because, at 100 million words, it provides the largest corpus of English with a balanced mixture of text genres.</S>
    <S sid="95" ssid="40">The British National Corpus includes automatically assigned syntactic part-of-speech tags for each word but does not include full syntactic parses.</S>
    <S sid="96" ssid="41">The FrameNet annotators did not make use of, or produce, a complete syntactic parse of the annotated sentences, although some syntactic information is provided by the grammatical function and phrase type tags of the annotated frame elements.</S>
    <S sid="97" ssid="42">The preliminary version of the FrameNet corpus used for our experiments contained 67 frame types from 12 general semantic domains chosen for annotation.</S>
    <S sid="98" ssid="43">A complete list of the semantic domains represented in our data is shown in Table 1, along with representative frames and predicates.</S>
    <S sid="99" ssid="44">Within these frames, examples of a total of 1,462 distinct lexical predicates, or target words, were annotated: 927 verbs, 339 nouns, and 175 adjectives.</S>
    <S sid="100" ssid="45">There are a total of 49,013 annotated sentences and 99,232 annotated frame elements (which do not include the target words themselves).</S>
    <S sid="101" ssid="46">How important is the particular set of semantic roles that underlies our system?</S>
    <S sid="102" ssid="47">For example, could the optimal choice of semantic roles be very dependent on the application that needs to exploit their information?</S>
    <S sid="103" ssid="48">Although there may well be application-specific constraints on semantic roles, our semantic role classifiers seem in practice to be relatively independent of the exact set of semantic roles under consideration.</S>
    <S sid="104" ssid="49">Section 9.1 describes an experiment in which we collapsed the FrameNet roles into a set of 18 abstract thematic roles.</S>
    <S sid="105" ssid="50">We then retrained our classifier and achieved roughly comparable results; overall performance was 82.1% for abstract thematic roles, compared to 80.4% for frame-specific roles.</S>
    <S sid="106" ssid="51">Although this doesn&#8217;t show that the detailed set of semantic roles is irrelevant, it does suggest that our statistical classification algorithm, at least, is relatively robust to even quite large changes in role identities.</S>
  </SECTION>
  <SECTION title="3." number="4">
    <S sid="107" ssid="1">Assignment of semantic roles is an important part of language understanding, and the problem of how to assign such roles has been attacked by many computational systems.</S>
    <S sid="108" ssid="2">Traditional parsing and understanding systems, including implementations of unification-based grammars such as Head-Driven Phrase Structure Grammar (HPSG) (Pollard and Sag 1994), rely on hand-developed grammars that must anticipate each way in which semantic roles may be realized syntactically.</S>
    <S sid="109" ssid="3">Writing such grammars is time consuming, and typically such systems have limited coverage.</S>
    <S sid="110" ssid="4">Data-driven techniques have recently been applied to template-based semantic interpretation in limited domains by &#8220;shallow&#8221; systems that avoid complex feature structures and often perform only shallow syntactic analysis.</S>
    <S sid="111" ssid="5">For example, in the context of the Air Traveler Information System (ATIS) for spoken dialogue, Miller et al. (1996) computed the probability that a constituent such as Atlanta filled a semantic slot such as DESTINATION in a semantic frame for air travel.</S>
    <S sid="112" ssid="6">In a data-driven approach to information extraction, Riloff (1993) builds a dictionary of patterns for filling slots in a specific domain such as terrorist attacks, and Riloff and Schmelzenbach (1998) extend this technique to derive automatically entire &#8220;case frames&#8221; for words in the domain.</S>
    <S sid="113" ssid="7">These last systems make use of a limited amount of hand labor to accept or reject automatically generated hypotheses.</S>
    <S sid="114" ssid="8">They show promise for a more sophisticated approach to generalizing beyond the relatively small number of frames considered in the tasks.</S>
    <S sid="115" ssid="9">More recently, a domain-independent system has been trained by Blaheta and Charniak (2000) on the function tags, such as MANNER and TEMPORAL, included in the Penn Treebank corpus.</S>
    <S sid="116" ssid="10">Some of these tags correspond to FrameNet semantic roles, but the Treebank tags do not include all the arguments of most predicates.</S>
    <S sid="117" ssid="11">In this article, we aim to develop a statistical system for automatically learning to identify all semantic roles for a wide variety of predicates in unrestricted text.</S>
  </SECTION>
  <SECTION title="4." number="5">
    <S sid="118" ssid="1">In this section we describe the first, basic version of our statistically trained system for automatically identifying frame elements in text.</S>
    <S sid="119" ssid="2">The system will be extended in later sections.</S>
    <S sid="120" ssid="3">We first describe in detail the sentence- and constituent-level features on which our system is based and then use these features to calculate probabilities for predicting frame element labels in Section 4.2.</S>
    <S sid="121" ssid="4">In this section we give results for a system that labels roles using the human-annotated boundaries for the frame elements within the sentence; we return to the question of automatically identifying the boundaries in Section 5.</S>
    <S sid="122" ssid="5">Our system is a statistical one, based on training a classifier on a labeled training set and testing on a held-out portion of the data.</S>
    <S sid="123" ssid="6">The system is trained by first using an automatic syntactic parser to analyze the 36,995 training sentences, matching annotated frame elements to parse constituents and extracting various features from the string of words and the parse tree.</S>
    <S sid="124" ssid="7">During testing, the parser is run on the test sentences and the same features are extracted.</S>
    <S sid="125" ssid="8">Probabilities for each possible semantic role r are then computed from the features.</S>
    <S sid="126" ssid="9">The probability computation is described in the next section; here we discuss the features used.</S>
    <S sid="127" ssid="10">The features used represent various aspects of the syntactic structure of the sentence as well as lexical information.</S>
    <S sid="128" ssid="11">The relationship between such surface manifestations and semantic roles is the subject of linking theory (see Levin and Rappaport Hovav [1996] for a synthesis of work in this area).</S>
    <S sid="129" ssid="12">In general, linking theory argues that the syntactic realization of arguments of a predicate is predictable from semantics; exactly how this relationship works, however, is the subject of much debate.</S>
    <S sid="130" ssid="13">Regardless of the underlying mechanisms used to generate syntax from semantics, the relationship between the two suggests that it may be possible to learn to recognize semantic relationships from syntactic cues, given examples with both types of information.</S>
    <S sid="131" ssid="14">4.1.1 Phrase Type.</S>
    <S sid="132" ssid="15">Different semantic roles tend to be realized by different syntactic categories.</S>
    <S sid="133" ssid="16">For example, in communication frames, the SpEAKER is likely to appear as a noun phrase, Topic as a prepositional phrase or noun phrase, and MEDiUM as a prepositional phrase, as in: &#8220;[Speaker We ] talked [Topic about the proposal ] [Medium over the phone ] .&#8221; The phrase type feature we used indicates the syntactic category of the phrase expressing the semantic roles, using the set of syntactic categories of the Penn Treebank project, as described in Marcus, Santorini, and Marcinkiewicz (1993).</S>
    <S sid="134" ssid="17">In our data, frame elements are most commonly expressed as noun phrases (NPs, 47% of frame elements in the training set), and prepositional phrases (PPs, 22%).</S>
    <S sid="135" ssid="18">The next most common categories are adverbial phrases (ADVPs, 4%), particles (e.g.</S>
    <S sid="136" ssid="19">&#8220;make something up&#8221;; PRTs, 2%) and clauses (SBARs, 2%, and Ss, 2%).</S>
    <S sid="137" ssid="20">(Tables 22 and 23 in the Appendix provides a listing of Penn Treebank&#8217;s part-of-speech tags and constituent labels.)</S>
    <S sid="138" ssid="21">We used Collins&#8217; (1997) statistical parser trained on examples from the Penn Treebank to generate parses of the same format for the sentences in our data.</S>
    <S sid="139" ssid="22">Phrase types were derived automatically from parse trees generated by the parser, as shown in Figure 2.</S>
    <S sid="140" ssid="23">Given the automatically generated parse tree, the constituent spanning the same set of words as each annotated frame element was found, and the constituent&#8217;s nonterminal label was taken as the phrase type.</S>
    <S sid="141" ssid="24">In cases in which more than one constituent matches because of a unary production in the parse tree, the higher constituent was chosen.</S>
    <S sid="142" ssid="25">A sample sentence with parser output (above) and FrameNet annotation (below).</S>
    <S sid="143" ssid="26">Parse constituents corresponding to frame elements are highlighted.</S>
    <S sid="144" ssid="27">The matching was performed by calculating the starting and ending word positions for each constituent in the parse tree, as well as for each annotated frame element, and matching each frame element with the parse constituent with the same beginning and ending points.</S>
    <S sid="145" ssid="28">Punctuation was ignored in this computation.</S>
    <S sid="146" ssid="29">Because of parsing errors, or, less frequently, mismatches between the parse tree formalism and the FrameNet annotation standards, for 13% of the frame elements in the training set, there was no parse constituent matching an annotated frame element.</S>
    <S sid="147" ssid="30">The one case of systematic mismatch between the parse tree formalism and the FrameNet annotation standards is the FrameNet convention of including both a relative pronoun and its antecedent in frame elements, as in the first frame element in the following sentence: Mismatch caused by the treatment of relative pronouns accounts for 1% of the frame elements in the training set.</S>
    <S sid="148" ssid="31">During testing, the largest constituent beginning at the frame element&#8217;s left boundary and lying entirely within the element was used to calculate the frame element&#8217;s features.</S>
    <S sid="149" ssid="32">We did not use this technique on the training set, as we expected that it would add noise to the data, but instead discarded examples with no matching parse constituent.</S>
    <S sid="150" ssid="33">Our technique for finding a near match handles common parse errors such as a prepositional phrase being incorrectly attached to a noun phrase at the right-hand edge, and it guarantees that some syntactic category will be returned: the part-of-speech tag of the frame element&#8217;s first word in the limiting case. alization as subject or direct object is one of the primary facts that linking theory attempts to explain.</S>
    <S sid="151" ssid="34">It was a motivation for the case hierarchy of Fillmore (1968), which allowed such rules as &#8220;If there is an underlying AGENT, it becomes the syntactic subject.&#8221; Similarly, in his theory of macroroles, Van Valin (1993) describes the ACTOR as being preferred in English for the subject.</S>
    <S sid="152" ssid="35">Functional grammarians consider syntactic subjects historically to have been grammaticalized agent markers.</S>
    <S sid="153" ssid="36">As an example of how such a feature can be useful, in the sentence &#8220;He drove the car over the cliff,&#8221; the subject NP is more likely to fill the AGENT role than the other two NPs.</S>
    <S sid="154" ssid="37">We will discuss various grammatical-function features that attempt to indicate a constituent&#8217;s syntactic relation to the rest of the sentence, for example, as a subject or object of a verb.</S>
    <S sid="155" ssid="38">The first such feature, which we call &#8220;governing category,&#8221; or gov, has only two values, S and VP, corresponding to subjects and objects of verbs, respectively.</S>
    <S sid="156" ssid="39">This feature is restricted to apply only to NPs, as it was found to have little effect on other phrase types.</S>
    <S sid="157" ssid="40">As with phrase type, the feature was read from parse trees returned by the parser.</S>
    <S sid="158" ssid="41">We follow links from child to parent up the parse tree from the constituent corresponding to a frame element until either an S or VP node is found and assign the value of the feature according to whether this node is an S or a VP.</S>
    <S sid="159" ssid="42">NP nodes found under S nodes are generally grammatical subjects, and NP nodes under VP nodes are generally objects.</S>
    <S sid="160" ssid="43">In most cases the S or VP node determining the value of this feature immediately dominates the NP node, but attachment errors by the parser or constructions such as conjunction of two NPs can cause intermediate nodes to be introduced.</S>
    <S sid="161" ssid="44">Searching for higher ancestor nodes makes the feature robust to such cases.</S>
    <S sid="162" ssid="45">Even given good parses, this feature is not perfect in discriminating grammatical functions, and in particular it confuses direct objects with adjunct NPs such as temporal phrases.</S>
    <S sid="163" ssid="46">For example, town in the sentence &#8220;He left town&#8221; and yesterday in the sentence &#8220;He left yesterday&#8221; will both be assigned a governing category of VP.</S>
    <S sid="164" ssid="47">Direct and indirect objects both appear directly under the VP node.</S>
    <S sid="165" ssid="48">For example, in the sentence &#8220;He gave me a new hose,&#8221; me and a new hose are both assigned a governing category of VP.</S>
    <S sid="166" ssid="49">More sophisticated handling of such cases could improve our system.</S>
    <S sid="167" ssid="50">4.1.3 Parse Tree Path.</S>
    <S sid="168" ssid="51">Like the governing-category feature described above, the parse tree path feature (path) is designed to capture the syntactic relation of a constituent to the rest of the sentence.</S>
    <S sid="169" ssid="52">The path feature, however, describes the syntactic relation between the target word (that is, the predicate invoking the semantic frame) and the constituent in question, whereas the gov feature is independent of where the target word appears in the sentence; that is, it identifies all subjects whether they are the subject of the target word or not.</S>
    <S sid="170" ssid="53">The path feature is defined as the path from the target word through the parse tree to the constituent in question, represented as a string of parse tree nonterminals linked by symbols indicating upward or downward movement through the tree, as shown in Figure 3.</S>
    <S sid="171" ssid="54">Although the path is composed as a string of symbols, our system treats the string as an atomic value.</S>
    <S sid="172" ssid="55">The path includes, as the first element of the string, the part of speech of the target word and, as the last element, the phrase type or syntactic category of the sentence constituent marked as a frame element.</S>
    <S sid="173" ssid="56">After some experimentation, we settled on a version of the path feature that collapses the various part-of-speech tags for verbs, including past-tense verb (VBD), third-person singular present-tense verb (VBZ), other present-tense verb (VBP), and past participle (VBN), into a single verb tag denoted &#8220;VB.&#8221; Our path feature is dependent on the syntactic representation used, which in our case is the Treebank-2 annotation style (Marcus et al. 1994), as our parser is trained on this later version of the Treebank data.</S>
    <S sid="174" ssid="57">Figure 4 shows the annotation for the sentence &#8220;They expect him to cut costs throughout the organization,&#8221; which exhibits In this example, the path from the target word ate to the frame element He can be represented as VBTVPTS&#8595;NP, with T indicating upward movement in the parse tree and &#8595; downward movement.</S>
    <S sid="175" ssid="58">The NP corresponding to He is found as described in Section 4.1.1.</S>
    <S sid="176" ssid="59">Treebank annotation of raising constructions. the syntactic phenomenon known as subject-to-object raising, in which the main verb&#8217;s object is interpreted as the embedded verb&#8217;s subject.</S>
    <S sid="177" ssid="60">The Treebank-2 style tends to be generous in its usage of S nodes to indicate clauses, a decision intended to make possible a relatively straightforward mapping from S nodes to predications.</S>
    <S sid="178" ssid="61">In this example, the path from cut to the frame element him would be VBTVPTVPTStNP, which typically indicates a verb&#8217;s subject, despite the accusative case of the pronoun him.</S>
    <S sid="179" ssid="62">For the target word of expect in the sentence of Figure 4, the path to him would be VBTVPtStNP, rather than the typical direct-object path of VBTVPtNP.</S>
    <S sid="180" ssid="63">An example of Treebank-2 annotation of an &#8220;equi&#8221; construction, in which a noun phrase serves as an argument of both the main and subordinate verbs, is shown in Figure 5.</S>
    <S sid="181" ssid="64">Here, an empty category is used in the subject position of the subordinate clause and is co-indexed with the NP Congress in the direct-object position of the main clause.</S>
    <S sid="182" ssid="65">The empty category, however, is not used in the statistical model of the parser or shown in its output and is also not used by the FrameNet annotation, which would mark the NP Congress as a frame element of raise in this example.</S>
    <S sid="183" ssid="66">Thus, the value of our path feature from the target word raise to the frame element Congress would be VBTVPTVPTSTVPtNP, and from the target word of persuaded the path to Congress would be the standard direct-object path VBTVPtNP.</S>
    <S sid="184" ssid="67">Other changes in annotation style from the original Treebank style were specifically intended to make predicate argument structure easy to read from the parse trees and include new empty (or null) constituents, co-indexing relations between nodes, and secondary functional tags such as subject and temporal.</S>
    <S sid="185" ssid="68">Our parser output, however, does not include this additional information, but rather simply gives trees of phrase type categories.</S>
    <S sid="186" ssid="69">The sentence in Figure 4 is one example of how the change in annotation style of Treebank-2 can affect this level of representation; the earlier style assigned the word him an NP node directly under the VP of expect.</S>
    <S sid="187" ssid="70">The most common values of the path feature, along with interpretations, are shown in Table 2.</S>
    <S sid="188" ssid="71">For the purposes of choosing a frame element label for a constituent, the path feature is similar to the gov feature defined above.</S>
    <S sid="189" ssid="72">Because the path captures more information than the governing category, it may be more susceptible to parser errors and data sparseness.</S>
    <S sid="190" ssid="73">As an indication of this, our path feature takes on a total of 2,978 possible values in the training data when frame elements with no matching Example of target word renting in a small clause. parse constituent are not counted and 4,086 possible values when paths are found to the best-matching constituent in these cases.</S>
    <S sid="191" ssid="74">The governing-category feature, on the other hand, which is defined only for NPs, has only two values (S, corresponding to subjects, and VP, corresponding to objects).</S>
    <S sid="192" ssid="75">In cases in which the path feature includes an S or VP ancestor of an NP node as part of the path to the target word, the gov feature is a function of the path feature.</S>
    <S sid="193" ssid="76">This is the case most of the time, including for our prototypical subject (VBTVPTStNP) and object (VBTVPtNP) paths.</S>
    <S sid="194" ssid="77">Of the 35,138 frame elements identified as NPs by the parser, only 4% have a path feature that does not include a VP or S ancestor.</S>
    <S sid="195" ssid="78">One such example is shown in Figure 6, where the small clause &#8220;the remainder renting ...&#8221; has no S node, giving a path feature from renting to the remainder of VBTVPTNPtNP.</S>
    <S sid="196" ssid="79">The value of the gov feature here is VP, as the algorithm finds the VP of the sentence&#8217;s main clause as it follows parent links up the tree.</S>
    <S sid="197" ssid="80">The feature is spurious in this case, because the main VP is not headed by, or relevant to, the target word renting.</S>
    <S sid="198" ssid="81">Systems based on the path and gov features are compared in Section 4.3.</S>
    <S sid="199" ssid="82">The differences between the two are relatively small for the purpose of identifying semantic roles when frame element boundaries are known.</S>
    <S sid="200" ssid="83">The path feature will, however, be important in identifying which constituents are frame elements for a given target word, as it gives us a way of navigating through the parse tree to find the frame elements in the sentence.</S>
    <S sid="201" ssid="84">4.1.4 Position.</S>
    <S sid="202" ssid="85">To overcome errors due to incorrect parses, as well as to see how much can be done without parse trees, we introduced position as a feature.</S>
    <S sid="203" ssid="86">The position feature simply indicates whether the constituent to be labeled occurs before or after the predicate defining the semantic frame.</S>
    <S sid="204" ssid="87">We expected this feature to be highly correlated with grammatical function, since subjects will generally appear before a verb and objects after.</S>
    <S sid="205" ssid="88">Although we do not have hand-checked parses against which to measure the performance of the automatic parser on our corpus, the result that 13% of frame elements have no matching parse constituent gives a rough idea of the parser&#8217;s accuracy.</S>
    <S sid="206" ssid="89">Almost all of these cases in which no matching parse constituent was found are due to parser error.</S>
    <S sid="207" ssid="90">Other parser errors include cases in which a constituent is found, but with the incorrect label or internal structure.</S>
    <S sid="208" ssid="91">This result also considers only the individual constituent representing the frame element: the parse for the rest of the sentence may be incorrect, resulting in an incorrect value for the grammatical function features described in the previous two sections.</S>
    <S sid="209" ssid="92">Collins (1997) reports 88% labeled precision and recall on individual parse constituents on data from the Penn Treebank, roughly consistent with our finding of at least 13% error.</S>
    <S sid="210" ssid="93">4.1.5 Voice.</S>
    <S sid="211" ssid="94">The distinction between active and passive verbs plays an important role in the connection between semantic role and grammatical function, since direct objects of active verbs often correspond in semantic role to subjects of passive verbs.</S>
    <S sid="212" ssid="95">From the parser output, verbs were classified as active or passive by building a set of 10 passive-identifying patterns.</S>
    <S sid="213" ssid="96">Each of the patterns requires both a passive auxiliary (some form of to be or to get) and a past participle.</S>
    <S sid="214" ssid="97">Roughly 5% of the examples were identified as passive uses.</S>
    <S sid="215" ssid="98">4.1.6 Head Word.</S>
    <S sid="216" ssid="99">As previously noted, we expected lexical dependencies to be extremely important in labeling semantic roles, as indicated by their importance in related tasks such as parsing.</S>
    <S sid="217" ssid="100">Head words of noun phrases can be used to express selectional restrictions on the semantic types of role fillers.</S>
    <S sid="218" ssid="101">For example, in a communication frame, noun phrases headed by Bill, brother, or he are more likely to be the SpEAKER, whereas those headed by proposal, story, or question are more likely to be the Topic.</S>
    <S sid="219" ssid="102">(We did not attempt to resolve pronoun references.)</S>
    <S sid="220" ssid="103">Since the parser we used assigns each constituent a head word as an integral part of the parsing model, we were able to read the head words of the constituents from the parser output, employing the same set of rules for identifying the head child of each constituent in the parse tree.</S>
    <S sid="221" ssid="104">The rules for assigning a head word are listed in Collins (1999).</S>
    <S sid="222" ssid="105">Prepositions are considered to be the head words of prepositional phrases.</S>
    <S sid="223" ssid="106">The rules for assigning head words do not attempt to distinguish between cases in which the preposition expresses the semantic content of a role filler, such as PATH frame elements expressed by prepositional phrases headed by along, through, or in, and cases in which the preposition might be considered to be purely a case marker, as in most uses of of, where the semantic content of the role filler is expressed by the preposition&#8217;s object.</S>
    <S sid="224" ssid="107">Complementizers are considered to be heads, meaning that infinitive verb phrases are always headed by to and subordinate clauses such as in the sentence &#8220;I&#8217;m sure that he came&#8221; are headed by that.</S>
    <S sid="225" ssid="108">For our experiments, we divided the FrameNet corpus as follows: one-tenth of the annotated sentences for each target word were reserved as a test set, and another onetenth were set aside as a tuning set for developing our system.</S>
    <S sid="226" ssid="109">A few target words where fewer than 10 examples had been chosen for annotation were removed from the corpus.</S>
    <S sid="227" ssid="110">(Section 9 will discuss generalization to unseen predicates.)</S>
    <S sid="228" ssid="111">In our corpus, the average number of sentences per target word is only 34, and the number of sentences per frame is 732, both relatively small amounts of data on which to train frame element classifiers.</S>
    <S sid="229" ssid="112">To label the semantic role of a constituent automatically, we wish to estimate a probability distribution indicating how likely the constituent is to fill each possible Distributions calculated for semantic role identification: r indicates semantic role, pt phrase type, gov grammatical function, h head word, and t target word, or predicate.</S>
    <S sid="230" ssid="113">Distribution role, given the features described above and the predicate, or target word, t: P(r I h, pt, gov, position, voice, t) where r indicates semantic role, h head word, and pt phrase type.</S>
    <S sid="231" ssid="114">It would be possible to calculate this distribution directly from the training data by counting the number of times each role appears with a combination of features and dividing by the total number of times the combination of features appears: #(r, h, pt,gov, position, voice, t) P(r  |h, pt, gov, position, voice, t) = #(h, pt,gov, position, voice, t) In many cases, however, we will never have seen a particular combination of features in the training data, and in others we will have seen the combination only a small number of times, providing a poor estimate of the probability.</S>
    <S sid="232" ssid="115">The small number of training sentences for each target word and the large number of values that the head word feature in particular can take (any word in the language) contribute to the sparsity of the data.</S>
    <S sid="233" ssid="116">Although we expect our features to interact in various ways, we cannot train directly on the full feature set.</S>
    <S sid="234" ssid="117">For this reason, we built our classifier by combining probabilities from distributions conditioned on a variety of subsets of the features.</S>
    <S sid="235" ssid="118">Table 3 shows the probability distributions used in the final version of the system.</S>
    <S sid="236" ssid="119">Coverage indicates the percentage of the test data for which the conditioning event had been seen in training data.</S>
    <S sid="237" ssid="120">Accuracy is the proportion of covered test data for which the correct role is given the highest probability, and Performance, which is the product of coverage and accuracy, is the overall percentage of test data for which the correct role is predicted.3 Accuracy is somewhat similar to the familiar metric of precision in that it is calculated over cases for which a decision is made, and performance is similar to recall in that it is calculated over all true frame elements.</S>
    <S sid="238" ssid="121">Unlike in a traditional precision/recall trade-off, however, these results have no threshold to adjust, and the task is a multiway classification rather than a binary decision.</S>
    <S sid="239" ssid="122">The distributions calculated were simply the empirical distributions from the training data.</S>
    <S sid="240" ssid="123">That is, occurrences of each role and each set of conditioning events were counted in a table, and probabilities calculated by dividing the counts for each role by the total number Sample probabilities for P(r  |pt, gov, t) calculated from training data for the verb abduct.</S>
    <S sid="241" ssid="124">The variable gov is defined only for noun phrases.</S>
    <S sid="242" ssid="125">The roles defined for the removing frame in the motion domain are AGENT (AGT), THEME (THM), COTHEME (COTHM) (&#8220;... had been abducted with him&#8221;), and MANNER (MANR). of observations for each conditioning event.</S>
    <S sid="243" ssid="126">For example, the distribution P(r  |pt, t) was calculated as follows: Some sample probabilities calculated from the training are shown in Table 4.</S>
    <S sid="244" ssid="127">As can be seen from Table 3, there is a trade-off between more-specific distributions, which have high accuracy but low coverage, and less-specific distributions, which have low accuracy but high coverage.</S>
    <S sid="245" ssid="128">The lexical head word statistics, in particular, are valuable when data are available but are particularly sparse because of the large number of possible head words.</S>
    <S sid="246" ssid="129">To combine the strengths of the various distributions, we merged them in various ways to obtain an estimate of the full distribution P(r  |h, pt,gov, position, voice, t).</S>
    <S sid="247" ssid="130">The first combination method is linear interpolation, which simply averages the probabilities given by each of the distributions: where Ei &#955;i = 1.</S>
    <S sid="248" ssid="131">The geometric mean, when expressed in the log domain, is similar: where Z is a normalizing constant ensuring that Er P(r  |constituent) = 1.</S>
    <S sid="249" ssid="132">Results for systems based on linear interpolation are shown in the first row of Table 5.</S>
    <S sid="250" ssid="133">These results were obtained using equal values of &#955; for each distribution defined for the relevant conditioning event (but excluding distributions for which the conditioning event was not seen in the training data).</S>
    <S sid="251" ssid="134">As a more sophisticated method of choosing interpolation weights, the expectation maximization (EM) algorithm was used to estimate the likelihood of the observed role&#8217;s being produced by each of the distributions in the general techniques of Jelinek and Mercer (1980).</S>
    <S sid="252" ssid="135">Because a number of the distributions used may have no training data for a given set of variables, the data were divided according to the set of distributions available, and a separate set of interpolation weights was trained for each set of distributions.</S>
    <S sid="253" ssid="136">This technique (line 2 of Table 5) did not outperform equal weights even on the data used to determine the weights.</S>
    <S sid="254" ssid="137">Although the EM algorithm is guaranteed to increase the likelihood of the training data, that likelihood does not always correspond to our scoring, which is based only on whether the correct outcome is assigned the highest probability.</S>
    <S sid="255" ssid="138">Results of the EM interpolation on held-out test data are shown in Table 6.</S>
    <S sid="256" ssid="139">Experimentation has shown that the weights used have relatively little impact in our interpolation scheme, no doubt because the evaluation metric depends only on the ranking of the probabilities and not on their exact values.</S>
    <S sid="257" ssid="140">Changing the interpolation weights rarely changes the probabilities of the roles enough to change their ranking.</S>
    <S sid="258" ssid="141">What matters most is whether a combination of variables has been seen in the training data or not.</S>
    <S sid="259" ssid="142">Results for the geometric mean are shown in row 3 of Table 5.</S>
    <S sid="260" ssid="143">As with linear interpolation, the exact weights were found to have little effect, and the results shown reflect equal weights.</S>
    <S sid="261" ssid="144">An area we have not explored is the use of the maximum-entropy techniques of, for example, Pietra, Pietra, and Lafferty (1997), to set weights for the log-linear model, either at the level of combining our probability distributions or at the level of calculating weights for individual values of the features.</S>
    <S sid="262" ssid="145">In the &#8220;backoff&#8221; combination method, a lattice was constructed over the distributions in Table 3 from more-specific conditioning events to less-specific, as shown in Figure 7.</S>
    <S sid="263" ssid="146">The lattice is used to select a subset of the available distributions to combine.</S>
    <S sid="264" ssid="147">The less-specific distributions were used only when no data were present for any more-specific distribution.</S>
    <S sid="265" ssid="148">Thus, the distributions selected are arranged in a cut across the lattice representing the most-specific distributions for which data are available.</S>
    <S sid="266" ssid="149">The selected probabilities were combined with both linear interpolation and a geometric mean, with results shown in Table 5.</S>
    <S sid="267" ssid="150">The final row of the table represents the baseline Lattice organization of the distributions from Table 3, with more-specific distributions toward the top. of always selecting the most common role of the target word for all its constituents, that is, using only P(r I t).</S>
    <S sid="268" ssid="151">Although this lattice is reminiscent of techniques of backing off to less specific distributions commonly used in n-gram language modeling, it differs in that we use the lattice only to select distributions for which the conditioning event has been seen in the training data.</S>
    <S sid="269" ssid="152">Discounting and deleted interpolation methods in language modeling typically are used to assign small, nonzero probability to a predicted variable unseen in the training data even when a specific conditioning event has been seen.</S>
    <S sid="270" ssid="153">In our case, we are perfectly willing to assign zero probability to a specific role (the predicted variable).</S>
    <S sid="271" ssid="154">We are interested only in finding the role with the highest probability, and a role given a small, nonzero probability by smoothing techniques will still not be chosen as the classifier&#8217;s output.</S>
    <S sid="272" ssid="155">The lattice presented in Figure 7 represents just one way of choosing subsets of features for our system.</S>
    <S sid="273" ssid="156">Designing a feature lattice can be thought of as choosing a set of feature subsets: once the probability distributions of the lattice have been chosen, the graph structure of the lattice is determined by the subsumption relations among the sets of conditioning variables.</S>
    <S sid="274" ssid="157">Given a set of N conditioning variables, there are 2N possible subsets, and 22N possible sets of subsets, giving us a doubly exponential number of possible lattices.</S>
    <S sid="275" ssid="158">The particular lattice of Figure 7 was chosen to represent some expected interaction between features.</S>
    <S sid="276" ssid="159">For example, we expect position and voice to interact, and they are always used together.</S>
    <S sid="277" ssid="160">We expect the head word h and the phrase type pt to be relatively independent predictors of the semantic role and therefore include them separately as roots of the backoff structure.</S>
    <S sid="278" ssid="161">Although we will not explore all the possibilities for our lattice, some of the feature interactions are examined more closely in Section 4.3.</S>
    <S sid="279" ssid="162">The final system performed at 80.4% accuracy, which can be compared to the 40.9% achieved by always choosing the most probable role for each target word, essentially chance performance on this task.</S>
    <S sid="280" ssid="163">Results for this system on test data, held out during development of the system, are shown in Table 6.</S>
    <S sid="281" ssid="164">Surprisingly, the EM-based interpolation performed better than the lattice-based system on the held-out test set, but not on the data used to set the weights in the EM-based system.</S>
    <S sid="282" ssid="165">We return to an analysis of which roles are hardest to classify in Section 9.1.</S>
    <S sid="283" ssid="166">Three of our features, position, gov, and path, attempt to capture the syntactic relation between the target word and the constituent to be labeled, and in particular to differentiate the subjects from objects of verbs.</S>
    <S sid="284" ssid="167">To compare these three features directly, experiments were performed using each feature alone in an otherwise identical sysLattice structures for comparing grammatical-function features. tem.</S>
    <S sid="285" ssid="168">Results are shown in Table 7.</S>
    <S sid="286" ssid="169">For the first set of experiments, corresponding to the first column of Table 7, no voice information was used, with the result that the remaining distributions formed the lattice of Figure 8a.</S>
    <S sid="287" ssid="170">(&#8220;GF&#8221; (grammatical function) in the figure represents one of the features position, gov, and path.)</S>
    <S sid="288" ssid="171">Adding voice information back into the system independently of the grammatical-function feature results Minimal lattice. in the lattice of Figure 8b, corresponding to the second column of Table 7.</S>
    <S sid="289" ssid="172">Choosing distributions such that the grammatical function and voice features are always used together results in Figure 8c, corresponding to the third column of Table 7.</S>
    <S sid="290" ssid="173">In each case, as in previous results, the grammatical function feature was used only when the candidate constituent was an NP.</S>
    <S sid="291" ssid="174">The last row of Table 7 shows results using no grammatical-function feature: the distributions making use of GF are removed from the lattices of Figure 8.</S>
    <S sid="292" ssid="175">As a guideline for interpreting these results, with 8,167 observations, the threshold for statistical significance with p &lt; .05 is a 1.0% absolute difference in performance.</S>
    <S sid="293" ssid="176">It is interesting to note that looking at a constituent&#8217;s position relative to the target word performed as well as either of our features that read grammatical function off the parse tree, both with and without passive information.</S>
    <S sid="294" ssid="177">The gov and path features seem roughly equivalent in performance.</S>
    <S sid="295" ssid="178">Using head word, phrase type, and target word without either position or grammatical function yielded only 76.3% accuracy, indicating that although the two features accomplish a similar goal, it is important to include some measure of the constituent&#8217;s relationship to the target word, whether relative position or either of the syntactic features.</S>
    <S sid="296" ssid="179">Use of the active/passive voice feature seems to be beneficial only when the feature is tied to grammatical function: the second column in Table 7 shows no improvement over the first, while the right-hand column, where grammatical function and voice are tied, shows gains (although only trends) of at least 0.5% in all cases.</S>
    <S sid="297" ssid="180">As before, our three indicators of grammatical function seem roughly equivalent, with the best result in this case being the gov feature.</S>
    <S sid="298" ssid="181">The lattice of Figure 8c performs as well as our system of Figure 7, indicating that including both position and either of the syntactic relations is redundant.</S>
    <S sid="299" ssid="182">As an experiment to see how much can be accomplished with as simple a system as possible, we constructed the minimal lattice of Figure 9, which includes just two distributions, along with a prior for the target word to be used as a last resort when no data are available.</S>
    <S sid="300" ssid="183">This structure assumes that head word and grammatical function are independent.</S>
    <S sid="301" ssid="184">It further makes no use of the voice feature.</S>
    <S sid="302" ssid="185">We chose the path feature as the representation of grammatical function in this case.</S>
    <S sid="303" ssid="186">This system classified 76.3% of frame elements correctly, indicating that one can obtain roughly nine-tenths the performance of the full system with a simple approach.</S>
    <S sid="304" ssid="187">(We will return to a similar system for the purposes of cross-domain experiments in Section 9.)</S>
  </SECTION>
  <SECTION title="5." number="6">
    <S sid="305" ssid="1">In this section we examine the system&#8217;s performance on the task of locating the frame elements in a sentence.</S>
    <S sid="306" ssid="2">Although our probability model considers the question of finding the boundaries of frame elements separately from the question of finding the correct label for a particular frame element, similar features are used to calculate both probabilities.</S>
    <S sid="307" ssid="3">In the experiments below, the system is no longer given frame element boundaries but is still given as inputs the human-annotated target word and the frame to which it belongs.</S>
    <S sid="308" ssid="4">We do not address the task of identifying which frames come into play in a sentence but envision that existing word sense disambiguation techniques could be applied to the task.</S>
    <S sid="309" ssid="5">As before, features are extracted from the sentence and its parse and are used to calculate probability tables, with the predicted variable in this case being fe, a binary indicator of whether a given constituent in the parse tree is or is not a frame element.</S>
    <S sid="310" ssid="6">The features used were the path feature of Section 4.1.3, the identity of the target word, and the identity of the constituent&#8217;s head word.</S>
    <S sid="311" ssid="7">The probability distributions calculated from the training data were P(fe  |path), P(fe  |path, t), and P(fe  |h, t), where fe indicates an event where the parse constituent in question is a frame element, path the path through the parse tree from the target word to the parse constituent, t the identity of the target word, and h the head word of the parse constituent.</S>
    <S sid="312" ssid="8">Some sample values from these distributions are shown in Table 8.</S>
    <S sid="313" ssid="9">For example, the path VBTVPtNP, which corresponds to the direct object of a verbal target word, had a high probability of being a frame element.</S>
    <S sid="314" ssid="10">The table also illustrates cases of sparse data for various feature combinations.</S>
    <S sid="315" ssid="11">By varying the probability threshold at which a decision is made, one can plot a precision/recall curve as shown in Figure 10.</S>
    <S sid="316" ssid="12">P(fe  |path, t) performs relatively poorly because of fragmentation of the training data (recall that only about 30 sentences are available for each target word).</S>
    <S sid="317" ssid="13">Although the lexical statistic P(fe  |h, t) alone is not useful as a classifier, using it in linear interpolation with the path statistics improves results.</S>
    <S sid="318" ssid="14">The curve labeled &#8220;interpolation&#8221; in Figure 10 reflects a linear interpolation of the form Note that this method can identify only those frame elements that have a corresponding constituent in the automatically generated parse tree.</S>
    <S sid="319" ssid="15">For this reason, it is interesting to calculate how many true frame elements overlap with the results of the system, relaxing the criterion that the boundaries must match exactly.</S>
    <S sid="320" ssid="16">Results for partial matching are shown in Table 9.</S>
    <S sid="321" ssid="17">Three types of overlap are possible: the identified constituent entirely within the true frame element, the true frame element entirely within the identified constituent, and each sequence partially contained by the other.</S>
    <S sid="322" ssid="18">An example of the first case is shown in Figure 11, where the true MESSAGE frame element is Mandarin by a head, but because of an error in the parser output, no constituent exactly matches the frame element&#8217;s boundaries.</S>
    <S sid="323" ssid="19">In this case, the system identifies Plot of precision/recall curve for various methods of identifying frame elements.</S>
    <S sid="324" ssid="20">Recall is calculated over only frame elements with matching parse constituents.</S>
    <S sid="325" ssid="21">Exactly matching boundaries 66% 5,421 Identified constituent entirely within true frame element 8 663 True frame element entirely within identified constituent 7 599 Both partially within the other 0 26 No overlap with any true frame element 13 972 two frame elements, indicated by shading, which together span the true frame element.</S>
    <S sid="326" ssid="22">When the automatically identified constituents were fed through the role-labeling system described above, 79.6% of the constituents that had been correctly identified in the first stage were assigned the correct role in the second, roughly equivalent to the performance when roles were assigned to constituents identified by hand.</S>
    <S sid="327" ssid="23">A more sophisticated integrated system for identifying and labeling frame elements is described in Section 7.1.</S>
  </SECTION>
  <SECTION title="6." number="7">
    <S sid="328" ssid="1">As can be seen from Table 3, information about the head word of a constituent is valuable in predicting the constituent&#8217;s role.</S>
    <S sid="329" ssid="2">Of all the distributions presented, An example of overlap between identified frame elements and the true boundaries, caused by parser error.</S>
    <S sid="330" ssid="3">In this case two frame elements identified by the classifier (shaded subtrees) are entirely within the human annotation (indicated below the sentence), contributing two instances to row 2 of Table 9.</S>
    <S sid="331" ssid="4">P(r I h, pt, t) predicts the correct role most often (87.4% of the time) when training data for a particular head word have been seen.</S>
    <S sid="332" ssid="5">Because of the large vocabulary of possible head words, however, it also has the smallest coverage, meaning that it is likely that, for a given case in the test data, no frame element with the same head word will have been seen in the set of training sentences for the target word in question.</S>
    <S sid="333" ssid="6">To capitalize on the information provided by the head word, we wish to find a way to generalize from head words seen in the training data to other head words.</S>
    <S sid="334" ssid="7">In this section we compare three different approaches to the task of generalizing over head words: automatic clustering of a large vocabulary of head words to identify words with similar semantics; use of a hand-built ontological resource, WordNet, to organize head words in a semantic hierarchy; and bootstrapping to make use of unlabeled data in training the system.</S>
    <S sid="335" ssid="8">We will focus on frame elements filled by noun phrases, which constitute roughly half the total.</S>
    <S sid="336" ssid="9">To find groups of head words that are likely to fill the same semantic roles, an automatic clustering of nouns was performed using word co-occurrence data from a large corpus.</S>
    <S sid="337" ssid="10">This technique is based on the expectation that words with similar semantics will tend to co-occur with the same other sets of words.</S>
    <S sid="338" ssid="11">For example, nouns describing foods will tend to occur as direct objects of verbs such as eat devour, and savor.</S>
    <S sid="339" ssid="12">The clustering algorithm attempts to find such patterns of co-occurrence from the counts of grammatical relations between pairs of specific words in the corpus, without the use of any external knowledge or semantic representation.</S>
    <S sid="340" ssid="13">We extracted verb&#8211;direct object relations from an automatically parsed version of the British National Corpus, using the parser of Carroll and Rooth (1998).4 Clustering was performed using the probabilistic model of co-occurrence described in detail by Hofmann and Puzicha (1998).</S>
    <S sid="341" ssid="14">(For other natural language processing [NLP] applications of the probabilistic clustering algorithm, see, e.g., Rooth [1995], Rooth et al. [1999]; for application to language modeling, see Gildea and Hofmann [1999].</S>
    <S sid="342" ssid="15">According to this model, the two observed variables, in this case the verb and the head noun of its object, can be considered independent given the value of a hidden cluster variable, c: One begins by setting a priori the number of values that c can take and using the EM algorithm to estimate the distributions P(c), P(n  |c), and P(v  |c).</S>
    <S sid="343" ssid="16">Deterministic annealing was used to prevent overfitting of the training data.</S>
    <S sid="344" ssid="17">We are interested only in the clusters of nouns given by the distribution P(n  |c): the verbs and the distribution P(v  |c) are thrown away once training is complete.</S>
    <S sid="345" ssid="18">Other grammatical relations besides direct object could be used, as could a set of relations.</S>
    <S sid="346" ssid="19">We used the direct object (following other clustering work such as Pereira, Tishby, and Lee [1993]) because it is particularly likely to exhibit semantically significant selectional restrictions.</S>
    <S sid="347" ssid="20">A total of 2,610,946 verb-object pairs were used as training data for the clustering, with a further 290,105 pairs used as a cross-validation set to control the parameters of the clustering algorithm.</S>
    <S sid="348" ssid="21">Direct objects were identified as noun phrases directly under a verb phrase node&#8212;not a perfect technique, since it also finds nominal adjuncts such as &#8220;I start today.&#8221; Forms of the verb to be were excluded from the data, as its cooccurrence patterns are not semantically informative.</S>
    <S sid="349" ssid="22">The number of values possible for the latent cluster variable was set to 256.</S>
    <S sid="350" ssid="23">(Comparable results were found with 64 clusters; the use of deterministic annealing prevents large numbers of clusters from resulting in overfitting.)</S>
    <S sid="351" ssid="24">The soft clustering of nouns thus generated is used as follows: for each example in the frame element&#8211;annotated training data, probabilities for values of the hidden cluster variable were calculated using Bayes&#8217; rule: The clustering was applied only to noun phrase constituents; the distribution P(n  |c) from the clustering is used as a distribution P(h  |c) over noun head words.</S>
    <S sid="352" ssid="25">Using the cluster probabilities, a new estimate of P(r  |c, pt, t) is calculated for cases where pt, the phrase type or syntactic category of the constituent, is NP: &#65533; where j is an index ranging over the frame elements in the training set and their associated features pt, t, h and their semantic roles r. During testing, a smoothed estimate of the head word&#8211;based role probability is calculated by marginalizing over cluster values: As with the other methods of generalization described in this section, automatic clustering was applied only to noun phrases, which represent 50% of the constituents in the test data.</S>
    <S sid="353" ssid="26">We would not expect head word to be as valuable for other phrase types.</S>
    <S sid="354" ssid="27">The second most common category is prepositional phrases.</S>
    <S sid="355" ssid="28">The head of a prepositional phrase (PP) is considered to be the preposition, according to the rules we use, and because the set of prepositions is small, coverage is not as great a problem.</S>
    <S sid="356" ssid="29">Furthermore, the preposition is often a direct indicator of the semantic role.</S>
    <S sid="357" ssid="30">(A more complete model might distinguish between cases in which the preposition serves as a case or role marker and others in which it is semantically informative, with clustering performed on the preposition&#8217;s object in the former case.</S>
    <S sid="358" ssid="31">We did not attempt to make this distinction.)</S>
    <S sid="359" ssid="32">Phrase types other than NP and PP make up only a small proportion of the data.</S>
    <S sid="360" ssid="33">Table 10 shows results for the use of automatic clustering on constituents identified by the parser as noun phrases.</S>
    <S sid="361" ssid="34">As can be seen in the table, the vocabulary used for clustering includes almost all (97.9%) of the test data, and the decrease in accuracy from direct lexical statistics to clustered statistics is relatively small (from 87.0% to 79.7%).</S>
    <S sid="362" ssid="35">When combined with the full system described above, clustered statistics increase performance on NP constituents from 83.4% to 85.0% (statistically significant at p &lt; .05).</S>
    <S sid="363" ssid="36">Over the entire test set, this translates into an improvement from 80.4% to 81.2%.</S>
    <S sid="364" ssid="37">The automatic clustering described above can be seen as an imperfect method of deriving semantic classes from the vocabulary, and we might expect a hand-developed set of classes to do better.</S>
    <S sid="365" ssid="38">We tested this hypothesis using WordNet (Fellbaum 1998), a freely available semantic hierarchy.</S>
    <S sid="366" ssid="39">The basic technique, when presented with a head word for which no training examples had been seen, was to ascend the type hierarchy until reaching a level for which training data are available.</S>
    <S sid="367" ssid="40">To do this, counts of training data were percolated up the semantic hierarchy in a technique similar to that of, for example, McCarthy (2000).</S>
    <S sid="368" ssid="41">For each training example, the count #(r, s, pt, t) was incremented in a table indexed by the semantic role r, WordNet sense s, phrase type pt, and target word t, for each WordNet sense s above the head word h in the hypernym hierarchy.</S>
    <S sid="369" ssid="42">In fact, the WordNet hierarchy is not a tree, but rather includes multiple inheritance.</S>
    <S sid="370" ssid="43">For example, person has as hypernyms both life form and causal agent.</S>
    <S sid="371" ssid="44">In such cases, we simply took the first hypernym listed, effectively converting the structure into a tree.</S>
    <S sid="372" ssid="45">A further complication is that several WordNet senses are possible for a given head word.</S>
    <S sid="373" ssid="46">We simply used the first sense listed for each word; a word sense disambiguation module capable of distinguishing WordNet senses might improve our results.</S>
    <S sid="374" ssid="47">As with the clustering experiments reported above, the WordNet hierarchy was used only for noun phrases.</S>
    <S sid="375" ssid="48">The WordNet hierarchy does not include pronouns; to increase coverage, the personal pronouns I, me, you, he, she, him, her, we, and us were added as hyponyms of person.</S>
    <S sid="376" ssid="49">Pronouns that refer to inanimate, or both animate and inanimate, objects were not included.</S>
    <S sid="377" ssid="50">In addition, the CELEX English lexical database (Baayen, Piepenbrock, and Gulikers 1995) was used to convert plural nouns to their singular forms.</S>
    <S sid="378" ssid="51">As shown in Table 11, accuracy for the WordNet technique is roughly the same as that in the automatic clustering results in Table 10: 84.3% on NPs, as opposed to 85.0% with automatic clustering.</S>
    <S sid="379" ssid="52">This indicates that the error introduced by the unsupervised clustering is roughly equivalent to the error caused by our arbitrary choice of the first WordNet sense for each word and the first hypernym for each WordNet sense.</S>
    <S sid="380" ssid="53">Coverage for the WordNet technique is lower, however, largely because of the absence of proper nouns from WordNet, as well as the absence of nonanimate pronouns (both personal pronouns such as it and they and indefinite pronouns such as something and anyone).</S>
    <S sid="381" ssid="54">A dictionary of proper nouns would likely help improve coverage, and a module for anaphora resolution might help cases with pronouns, with or without the use of WordNet.</S>
    <S sid="382" ssid="55">The conversion of plural forms to singular base forms was an important part of the success of the WordNet system, increasing coverage from 71.0% to 80.8%.</S>
    <S sid="383" ssid="56">Of the remaining 19.2% of all noun phrases not covered by the combination of lexical and WordNet sense statistics, 22% consisted of head words defined in WordNet, but for which no training data were available for any hypernym, and 78% consisted of head words not defined in WordNet.</S>
    <S sid="384" ssid="57">A third way of attempting to improve coverage of the lexical statistics is to &#8220;bootstrap,&#8221; or label unannotated data with the automatic system described in Sections 4 and 5 and use the (imperfect) result as further training data.</S>
    <S sid="385" ssid="58">This can be considered a variant of the EM algorithm, although we use the single most likely hypothesis for the unannotated data, rather than calculating the expectation over all hypotheses.</S>
    <S sid="386" ssid="59">Only one iteration of training on the unannotated data was performed.</S>
    <S sid="387" ssid="60">The unannotated data used consisted of 156,590 sentences containing the target words of our corpus, increasing the total amount of data available to roughly six times the 36,995 annotated training sentences.</S>
    <S sid="388" ssid="61">Table 12 shows results on noun phrases for the bootstrapping method.</S>
    <S sid="389" ssid="62">The accuracy of a system trained only on data from the automatic labeling (Panto) is 81.0%, reasonably close to the 87.0% for the system trained only on annotated data (Ptrai,,,).</S>
    <S sid="390" ssid="63">Combining the annotated and automatically labeled data increases coverage from 41.6% to 54.7% and performance to 44.5%.</S>
    <S sid="391" ssid="64">Because the automatically labeled data are not as accurate as the annotated data, we can do slightly better by using the automatic data only in cases where no training data are available, backing off to the distribution Panto from Ptrai,,,.</S>
    <S sid="392" ssid="65">The fourth row of Table 12 shows results with Panto incorporated into the backoff lattice of all the features of Figure 7, which actually resulted in a slight decrease in performance from the system without the bootstrapped data, shown in the third row.</S>
    <S sid="393" ssid="66">This is presumably because, although the system trained on automatically labeled data performed with reasonable accuracy, many of the cases it classifies correctly overlap with the training data.</S>
    <S sid="394" ssid="67">In fact our backing-off estimate of P(r h, pt, t) classifies correctly only 66% of the additional cases that it covers over Ptrain(r h, pt, t).</S>
    <S sid="395" ssid="68">The three methods of generalizing lexical statistics each had roughly equivalent accuracy on cases for which they were able to derive an estimate of the role probabilities for unseen head words.</S>
    <S sid="396" ssid="69">The differences between the three were primarily due to how much they could improve the coverage of the estimator, that is, how many new noun heads they were able to handle.</S>
    <S sid="397" ssid="70">The automatic-clustering method performed by far the best on this metric; only 2.1% of test cases were unseen in the data used for the automatic clustering.</S>
    <S sid="398" ssid="71">This indicates how much can be achieved with unsupervised methods given very large training corpora.</S>
    <S sid="399" ssid="72">The bootstrapping technique described here, although it has a similar unsupervised flavor, made use of much less data than the corpus used for noun clustering.</S>
    <S sid="400" ssid="73">Unlike probabilistic clustering, the bootstrapping technique can make use of only those sentences containing the target words in question.</S>
    <S sid="401" ssid="74">The WordNet experiment, on the other hand, indicates both the usefulness of hand-built resources when they apply and the difficulty of attaining broad coverage with such resources.</S>
    <S sid="402" ssid="75">Combining the three systems described would indicate whether their gains are complementary or overlapping.</S>
  </SECTION>
  <SECTION title="7." number="8">
    <S sid="403" ssid="1">One of the primary difficulties in labeling semantic roles is that one predicate may be used with different argument structures: for example, in the sentences &#8220;He opened the door&#8221; and &#8220;The door opened,&#8221; the verb open assigns different semantic roles to its syntactic subject.</S>
    <S sid="404" ssid="2">In this section we compare two strategies for handling this type of alternation in our system: a sentence-level feature for frame element groups and a subcategorization feature for the syntactic uses of verbs.</S>
    <S sid="405" ssid="3">Then a simple system using the predicate&#8217;s argument structure, or syntactic signature, as the primary feature will be contrasted with previous systems based on local, independent features.</S>
    <S sid="406" ssid="4">The system described in previous sections for classifying frame elements makes an important simplifying assumption: it classifies each frame element independent of the decisions made for the other frame elements in the sentence.</S>
    <S sid="407" ssid="5">In this section we remove this assumption and present a system that can make use of the information that, for example, a given target word requires that one role always be present or that having two instances of the same role is extremely unlikely.</S>
    <S sid="408" ssid="6">To capture this information, we introduce the notion of a frame element group, which is the set of frame element roles present in a particular sentence (technically a multiset, as duplicates are possible, though quite rare).</S>
    <S sid="409" ssid="7">Frame element groups (FEGs) are unordered: examples are shown in Table 13.</S>
    <S sid="410" ssid="8">Sample probabilities from the training data for the frame element groups of the target word blame are shown in Table 14.</S>
    <S sid="411" ssid="9">The FrameNet corpus recognizes three types of &#8220;null-instantiated&#8221; frame elements (Fillmore 1986), which are implied but do not appear in the sentence.</S>
    <S sid="412" ssid="10">An example of null instantiation is the sentence &#8220;Have you eaten?&#8221; where food is understood.</S>
    <S sid="413" ssid="11">We did not attempt to identify such null elements, and any null-instantiated roles are not included in the sentence&#8217;s FEG.</S>
    <S sid="414" ssid="12">This increases the variability of observed FEGs, as a predicate may require a certain role but allow it to be null instantiated.</S>
    <S sid="415" ssid="13">Our system for choosing the most likely overall assignment of roles for all the frame elements of a sentence uses an approximation that we derive beginning with the true probability of the optimal role assignment r*: where P(r1...n I t,f1...n) represents the probability of an overall assignment of roles ri to each of the n constituents of a sentence, given the target word t and the various features fi of each of the constituents.</S>
    <S sid="416" ssid="14">In the first step we apply Bayes&#8217; rule to this and in the second we make the assumption that the features of the various constituents of a sentence are independent given the target word and each constituent&#8217;s role and discard the term P(f1...n  |t), which is constant with respect to r: We estimate the prior over frame element assignments as the probability of the frame element groups, represented with the set operator {}: and finally discard the feature prior P(fi  |t) as being constant over the argmax expression: This leaves us with an expression in terms of the prior for frame element groups of a particular target word P({r1...n}  |t), the local probability of a frame element given a constituent&#8217;s features P(ri  |fi, t) on which our previous system was based, and the individual priors for the frame elements chosen P(ri  |t).</S>
    <S sid="417" ssid="15">This formulation can be used to assign roles either when the frame element boundaries are known or when they are not, as we will discuss later in this section.</S>
    <S sid="418" ssid="16">Calculating empirical FEG priors from the training data is relatively straightforward, but the sparseness of the data presents a problem.</S>
    <S sid="419" ssid="17">In fact, 15% of the test sentences had an FEG not seen in the training data for the target word in question.</S>
    <S sid="420" ssid="18">Using the empirical value for the FEG prior, these sentences could never be correctly classified.</S>
    <S sid="421" ssid="19">For this reason, we introduce a smoothed estimate of the FEG prior consisting of a linear interpolation of the empirical FEG prior and the product, for each possible frame element, of the probability of being present or not present in a sentence given the target word: The value of A was empirically set to maximize performance on the development set; a value of 0.6 yielded performance of 81.6%, a significant improvement over the 80.4% of the baseline system.</S>
    <S sid="422" ssid="20">Results were relatively insensitive to the exact value of A.</S>
    <S sid="423" ssid="21">Up to this point, we have considered separately the problems of labeling roles given that we know where the boundaries of the frame elements lie (Section 4, as well as Section 6) and finding the constituents to label in the sentence (Section 5).</S>
    <S sid="424" ssid="22">We now turn to combining the two systems described above into a complete role labeling system.</S>
    <S sid="425" ssid="23">We use equation (16), repeated below, to estimate the probability that a constituent is a frame element: where p is the path through the parse tree from the target word to the constituent, t is the target word, and h is the constituent&#8217;s head word.</S>
    <S sid="426" ssid="24">The first two rows of Table 15 show the results when constituents are determined to be frame elements by setting the threshold on the probability P(fe  |p, h, t) to 0.5 and then running the labeling system of Section 4 on the resulting set of constituents.</S>
    <S sid="427" ssid="25">The first two columns of results show precision and recall for the task of identifying frame element boundaries correctly.</S>
    <S sid="428" ssid="26">The second pair of columns gives precision and recall for the combined task of boundary identification and role labeling; to be counted as correct, the frame element must both have the correct boundary and be labeled with the correct role.</S>
    <S sid="429" ssid="27">Contrary to our results using human-annotated boundaries, incorporating FEG priors into the system based on automatically identified boundaries had a negative effect on labeled precision and recall.</S>
    <S sid="430" ssid="28">No doubt this is due to introducing a dependency on other frame element decisions that may be incorrect: the use of FEG priors causes errors in boundary identification to be compounded.</S>
    <S sid="431" ssid="29">One way around this problem is to integrate boundary identification with role labeling, allowing the FEG priors and the role-labeling decisions to affect which constituents are frame elements.</S>
    <S sid="432" ssid="30">This was accomplished by extending the formulation where fei is a binary variable indicating that a constituent is a frame element and P(fei  |fi) is calculated as above.</S>
    <S sid="433" ssid="31">When fei is true, role probabilities are calculated as before; when fei is false, ri assumes an empty role with probability one and is not included in the FEG represented by fr1...nj.</S>
    <S sid="434" ssid="32">One caveat in using this integrated approach is its exponential complexity: each combination of role assignments to constituents is considered, and the number of combinations is exponential in the number of constituents.</S>
    <S sid="435" ssid="33">Although this did not pose a problem when only the annotated frame elements were under consideration, now we Two subcategorizations for the target word open.</S>
    <S sid="436" ssid="34">The relevant production in the parse tree is highlighted.</S>
    <S sid="437" ssid="35">On the left, the value of the feature is &#8220;VP &#8594; VB NP&#8221;; on the right it is &#8220;VP &#8594; VB.&#8221; must include every parse constituent with a nonzero probability for P(fei  |fi).</S>
    <S sid="438" ssid="36">To make the computation tractable, we implement a pruning scheme: hypotheses are extended by choosing assignments for one constituent at a time, and only the top m hypotheses are retained for extension by assignments to the next constituent.</S>
    <S sid="439" ssid="37">Here we set m = 10 after experimentation showed that increasing m yielded no significant improvement.</S>
    <S sid="440" ssid="38">Results for the integrated approach are shown in the last row of Table 15.</S>
    <S sid="441" ssid="39">Allowing role assignments to influence boundary identification improves results both on the unlabeled boundary identification task and on the combined identification and labeling task.</S>
    <S sid="442" ssid="40">The integrated approach puts us in a different portion of the precision/recall curve from the results in the first two rows, as it returns a higher number of frame elements (7,736 vs. 5,719).</S>
    <S sid="443" ssid="41">A more direct comparison can be made by lowering the probability threshold for frame element identification from 0.5 to 0.35 to force the nonintegrated system to return the same number of frame elements as the integrated system.</S>
    <S sid="444" ssid="42">This yields a frame element identification precision of 71.3% and recall of 67.6% and a labeled precision of 60.8% and recall of 57.6%, which is dominated by the result for the integrated system.</S>
    <S sid="445" ssid="43">The integrated system does not have a probability threshold to set; nonetheless it comes closer to identifying the correct number of frame elements (8,167) than does the independent boundary identifier when the theoretically optimal threshold of 0.5 is used with the latter.</S>
    <S sid="446" ssid="44">Recall that use of the FEG prior was motivated by the tendency of verbs to assign differing roles to the same syntactic position.</S>
    <S sid="447" ssid="45">For example, the verb open assigns different roles to the syntactic subject in He opened the door and The door opened.</S>
    <S sid="448" ssid="46">In this section we consider a different feature motivated by these problems: the syntactic subcategorization of the verb.</S>
    <S sid="449" ssid="47">For example, the verb open seems to be more likely to assign the role PATIENT to its subject in an intransitive context and AGENT to its subject in a transitive context.</S>
    <S sid="450" ssid="48">Our use of a subcategorization feature was intended to differentiate between transitive and intransitive uses of a verb.</S>
    <S sid="451" ssid="49">The feature used was the identity of the phrase structure rule expanding the target word&#8217;s parent node in the parse tree, as shown in Figure 12.</S>
    <S sid="452" ssid="50">For example, for He closed the door, with close as the target word, the subcategorization feature would be &#8220;VP &#8594; VB NP.&#8221; The subcategorization feature was used only when the target word was a verb.</S>
    <S sid="453" ssid="51">The various part-of-speech tags for verb forms (VBD for past-tense verb forms, VBZ for third-person singular present tense, VBP for other present tense, VBG for present participles, and VBN for past participles) were collapsed into a single tag VB.</S>
    <S sid="454" ssid="52">It is important to note that we are not able to distinguish complements from adjuncts, and our subcategorization feature could be sabotaged by cases such as The door closed yesterday.</S>
    <S sid="455" ssid="53">In the Penn Treebank style, yesterday is considered an NP with tree structure equivalent to that of a direct object.</S>
    <S sid="456" ssid="54">Our subcategorization feature is fairly specific: for example, the addition of an ADVP to a verb phrase will result in a different value.</S>
    <S sid="457" ssid="55">We tested variations of the feature that counted the number of NPs in a VP or the total number of children of the VP, with no significant change in results.</S>
    <S sid="458" ssid="56">The subcategorization feature was used in conjunction with the path feature, which represents the sequence of nonterminals along the path through the parse tree from the target word to the constituent representing a frame element.</S>
    <S sid="459" ssid="57">Making use of the new subcategorization (subcat) feature by adding the distribution P(r  |subcat, path, t) to the lattice of distributions in the baseline system resulted in a slight improvement to 80.8% performance from 80.4%.</S>
    <S sid="460" ssid="58">As with the gov feature in the baseline system, it was found beneficial to use the subcat feature only for NP constituents.</S>
    <S sid="461" ssid="59">Combining the FEG priors and subcategorization feature into a single system resulted in performance of 81.6%, no improvement over using FEG priors without subcategorization.</S>
    <S sid="462" ssid="60">We suspect that the two seemingly different approaches in fact provide similar information.</S>
    <S sid="463" ssid="61">For example, in our hypothetical example of the sentence He opened the door vs. the sentence The door opened, the verb open would have high priors for the FEGs {AGENT, THEME} and {THEME}, but a low prior for {AGENT}.</S>
    <S sid="464" ssid="62">In sentences with only one candidate frame element (the subject in The door closed), the use of the FEG prior will cause it to be labeled THEME, even when the feature probabilities prefer labeling a subject as AGENT.</S>
    <S sid="465" ssid="63">Thus the FEG prior, by representing the set of arguments the predicate is likely to take, essentially already performs the function of the subcategorization feature.</S>
    <S sid="466" ssid="64">The FEG prior allows us to introduce a dependency between the classifications of the sentence&#8217;s various constituents with a single parameter.</S>
    <S sid="467" ssid="65">Thus, it can handle the alternation of our example without, for example, introducing the role chosen for one constituent as an additional feature in the probability distribution for the next constituent&#8217;s role.</S>
    <S sid="468" ssid="66">It appears that because introducing additional features can further fragment our already sparse data, it is preferable to have a single parameter for the FEG prior.</S>
    <S sid="469" ssid="67">An interesting result reinforcing this conclusion is that some of the argumentstructure features that aided the system when individual frame elements were considered independently are unnecessary when using FEG priors.</S>
    <S sid="470" ssid="68">Removing the features passive and position from the system and using a smaller lattice of only the distributions not employing these features yields an improved performance of 82.8% on the role-labeling task using hand-annotated boundaries.</S>
    <S sid="471" ssid="69">We believe that, because these features pertain to syntactic alternations in how arguments are realized, they overlap with the function of the FEG prior.</S>
    <S sid="472" ssid="70">Adding unnecessary features to the system can reduce performance by fragmenting the training data.</S>
    <S sid="473" ssid="71">In the experiments reported in previous sections, we have used the parse tree returned by a statistical parser as input to the role-labeling system.</S>
    <S sid="474" ssid="72">In this section, we explore the interaction between semantic roles and syntactic parsing by integrating the parser with the semantic-role probability model.</S>
    <S sid="475" ssid="73">This allows the semantic-role assignment to affect the syntactic attachment decisions made by the parser, with the hope of improving the accuracy of the complete system.</S>
    <S sid="476" ssid="74">Although most statistical parsing work measures performance in terms of syntactic trees without semantic information, an assignment of role fillers has been incorporated into a statistical parsing model by Miller et al. (2000) for the domain-specific templates of the Message Understanding Conference (Defense Advanced Research Projects Agency 1998) task.</S>
    <S sid="477" ssid="75">A key finding of Miller et al.&#8217;s work was that a system developed by annotating role fillers in text and training a statistical system performed at the same level as one based on writing a large system of rules, which requires much more highly skilled labor to design.</S>
    <S sid="478" ssid="76">We use as the baseline of all our parsing experiments the model described in Collins (1999).</S>
    <S sid="479" ssid="77">The algorithm is a form of chart parsing, which uses dynamic programming to search through the exponential number of possible parses by considering subtrees for each subsequence of the sentence independently.</S>
    <S sid="480" ssid="78">To apply chart parsing to a probabilistic grammar, independence relations must be assumed to hold between the probabilities of a parse tree and the internal structure of its subtrees.</S>
    <S sid="481" ssid="79">In the case of stochastic context-free grammar, the probability of a tree is independent of the internal structure of its subtrees, given the topmost nonterminal of the subtree.</S>
    <S sid="482" ssid="80">The chart-parsing algorithm can simply find the highest-probability parse for each nonterminal for each substring of the input sentence.</S>
    <S sid="483" ssid="81">No lower-probability subtrees will ever be used in a complete parse, and they can be thrown away.</S>
    <S sid="484" ssid="82">Recent lexicalized stochastic parsers such as Collins (1999), Charniak (1997), and others add additional features to each constituent, the most important being the head word of the parse constituent.</S>
    <S sid="485" ssid="83">The statistical system for assigning semantic roles described in the previous sections does not fit easily into the chart-parsing framework, as it relies on long-distance dependencies between the target word and its frame elements.</S>
    <S sid="486" ssid="84">In particular, the path feature, which is used to &#8220;navigate&#8221; through the sentence from the target word to its likely frame elements, may be an arbitrarily long sequence of syntactic constituents.</S>
    <S sid="487" ssid="85">A path feature looking for frame elements for a target word in another part of the sentence may examine the internal structure of a constituent, violating the independence assumptions of the chart parser.</S>
    <S sid="488" ssid="86">The use of priors over FEGs further complicates matters by introducing sentence-level features dependent on the entire parse.</S>
    <S sid="489" ssid="87">For these reasons, we use the syntactic parsing model without frame element probabilities to generate a number of candidate parses, compute the best frame element assignment for each, and then choose the analysis with the highest overall probability.</S>
    <S sid="490" ssid="88">The frame element assignments are computed as in Section 7.1, with frame element probabilities being applied to every constituent in the parse.</S>
    <S sid="491" ssid="89">To return a large number of candidate parses, the parser was modified to include constituents in the chart even when they were equivalent, according to the parsing model, to a higher-probability constituent.</S>
    <S sid="492" ssid="90">Rather than choosing a fixed n and keeping the n best constituents for each entry in the chart, we chose a probability threshold and kept all constituents within a margin of the highest-probability constituent.</S>
    <S sid="493" ssid="91">Thus the mechanism is similar to the beam search used to prune nonequivalent edges, but a lower threshold was used for equivalent edges (1e vs. 1 100).</S>
    <S sid="494" ssid="92">Using these pruning parameters, an average of 14.9 parses per sentence were obtained.</S>
    <S sid="495" ssid="93">After rescoring with frame element probabilities, 18% of the sentences were assigned a parse different from the original best parse.</S>
    <S sid="496" ssid="94">Nevertheless, the impact on identification of frame elements was small; results are shown in Table 16.</S>
    <S sid="497" ssid="95">The results show a slight, but not statistically significant, increase in recall of frame elements.</S>
    <S sid="498" ssid="96">One possible reason that the improvement is not greater is the relatively small number of parses per sentence available for rescoring.</S>
    <S sid="499" ssid="97">Unfortunately, the parsing algorithm used to generate n-best parses is inefficient, and generating large numbers of parses seems to be computationally intractable.</S>
    <S sid="500" ssid="98">In theory, the complexity of n-best variations of the Viterbi chart-parsing algorithm is quadratic in n. One can simply expand the dynamic programming chart to have n slots for the best solutions to each subproblem, rather than one.</S>
    <S sid="501" ssid="99">As our grammar forms new constituents from pairs of smaller constituents (that is, it internally uses a binarized grammar), for each pair of constituents considered in a single-best parser, up to n2 pairs would be present in the n-best variant.</S>
    <S sid="502" ssid="100">The beam search used by modern parsers, however, makes the analysis more complex.</S>
    <S sid="503" ssid="101">Lexicalization of parse constituents dramatically increases the number of categories that must be stored in the chart, and efficient parsing requires that constituents below a particular probability threshold be dropped from further consideration.</S>
    <S sid="504" ssid="102">In practice, returning a larger number of parses with our algorithm seems to require increasing the pruning beam size to a degree that makes run times prohibitive.</S>
    <S sid="505" ssid="103">In addition to the robustness of even relatively simple parsing models, one explanation for the modest improvement may be the fact that even our integrated system includes semantic information for only one word in the sentence.</S>
    <S sid="506" ssid="104">As the coverage of our frame descriptions increases, it may be possible to do better and to model the interactions between the frames invoked by a text.</S>
    <S sid="507" ssid="105">Most of the statistics used in the system as described above are conditioned on the target word, or predicate, for which semantic roles are being identified.</S>
    <S sid="508" ssid="106">This limits the applicability of the system to words for which training data are available.</S>
    <S sid="509" ssid="107">In Section 6, we attempted to generalize across fillers for the roles of a single predicate.</S>
    <S sid="510" ssid="108">In this section, we turn to the related but somewhat more difficult question of generalizing from seen to unseen predicates.</S>
    <S sid="511" ssid="109">Many ways of attempting this generalization are possible, but the simplest is provided by the frame-semantic information of the FrameNet database.</S>
    <S sid="512" ssid="110">We can use data from target words in the same frame to predict behavior for an unseen word, or, if no data are available for the frame in question, we can use data from the same broad semantic domain into which the frames are grouped.</S>
    <S sid="513" ssid="111">To investigate the degree to which our system is dependent on the set of semantic roles used, we performed experiments using abstract, general semantic roles such as AGENT, PATIENT, and GOAL.</S>
    <S sid="514" ssid="112">Such roles were proposed in theories of linking such as Fillmore (1968) and Jackendoff (1972) to explain the syntactic realization of semantic arguments.</S>
    <S sid="515" ssid="113">This level of roles, often called thematic roles, was seen as useful for expressing generalizations such as &#8220;If a sentence has an AGENT, the AGENT will occupy the subject position.&#8221; Such correlations might enable a statistical system to generalize from one semantic domain to another.</S>
    <S sid="516" ssid="114">Recent work on linguistic theories of linking has attempted to explain syntactic realization in terms of the fundamentals of verbs&#8217; meaning (see Levin and Rappaport Hovav [1996] for a survey of a number of theories).</S>
    <S sid="517" ssid="115">Although such an explanation is desirable, our goal is more modest: an automatic procedure for identifying semantic roles in text.</S>
    <S sid="518" ssid="116">We aim to use abstract roles as a means of generalizing from limited training data in various semantic domains.</S>
    <S sid="519" ssid="117">We see this effort as consistent with various theoretical accounts of the underlying mechanisms of argument linking, since the various theories all postulate some sort of generalization between the roles of specific predicates.</S>
    <S sid="520" ssid="118">To this end, we developed a correspondence from frame-specific roles to a set of abstract thematic roles.</S>
    <S sid="521" ssid="119">For each frame, an abstract thematic role was assigned to each frame element in the frame&#8217;s definition.</S>
    <S sid="522" ssid="120">Since there is no canonical set of abstract semantic roles, we decided upon the list shown in Table 17.</S>
    <S sid="523" ssid="121">We are interested in adjuncts as well as arguments, leading to roles such as DEGREE not found in many theories of verb-argument linking.</S>
    <S sid="524" ssid="122">The difficulty of fitting many relations into standard categories such as AGENT and PATIENT led us to include other roles such as TOPIC.</S>
    <S sid="525" ssid="123">In all, we used 18 roles, a somewhat richer set than is often used, but still much more restricted than the frame-specific roles.</S>
    <S sid="526" ssid="124">Even with this enriched set, not all framespecific roles fit neatly into one category.</S>
    <S sid="527" ssid="125">An experiment was performed replacing each role tag in the training and test data with the corresponding thematic role and training the system as described above on the new dataset.</S>
    <S sid="528" ssid="126">Results were roughly comparable for the two types of semantic roles: overall performance was 82.1% for thematic roles, compared to 80.4% for framespecific roles.</S>
    <S sid="529" ssid="127">This reflects the fact that most frames had a one-to-one mapping from frame-specific to abstract roles, so the tasks were largely equivalent.</S>
    <S sid="530" ssid="128">We expect abstract roles to be most useful when one is generalizing to predicates and frames not found in the training data, the topic of the following sections.</S>
    <S sid="531" ssid="129">One interesting consequence of using abstract roles is that they allow us to compare more easily the system&#8217;s performance on different roles because of the smaller number of categories.</S>
    <S sid="532" ssid="130">This breakdown is shown in Table 18.</S>
    <S sid="533" ssid="131">Results are given for two systems: the first assumes that the frame element boundaries are known and the second finds them automatically.</S>
    <S sid="534" ssid="132">The second system, which is described in Section 7.1, corresponds to the rightmost two columns in Table 18.</S>
    <S sid="535" ssid="133">The &#8220;Labeled Recall&#8221; column shows how often the frame element is correctly identified, whereas the &#8220;Unlabeled Recall&#8221; column shows how often a constituent with the given role is correctly identified as being a frame element, even if it is labeled with the wrong role.</S>
    <S sid="536" ssid="134">EXPERIENCER and AGENT, two similar roles generally found as the subject for complementary sets of verbs, are the roles that are correctly identified the most often.</S>
    <S sid="537" ssid="135">The &#8220;Unlabeled Recall&#8221; column shows that these roles are easy to find in the sentence, as a predicate&#8217;s subject is almost always a frame element, and the &#8220;Known Boundaries&#8221; column shows that they are also not often confused with other roles when it is known that they are frame elements.</S>
    <S sid="538" ssid="136">The two most difficult roles in terms of unlabeled recall, MANNER and DEGREE, are typically realized by adverbs or prepositional phrases and considered adjuncts.</S>
    <S sid="539" ssid="137">It is interesting to note that these are considered in FrameNet to be general frame elements that can be used in any frame.</S>
    <S sid="540" ssid="138">STATE Rex spied out Sam Maggott hollering at all and sundry and making good use of his over-sized red gingham handkerchief.</S>
    <S sid="541" ssid="139">Topic He said, &#8220;We would urge people to be aware and be alert with fireworks because your fun might be someone else&#8217;s tragedy.&#8221; This section has shown that our system can use roles defined at a more abstract level than the corpus&#8217;s frame-level roles and in fact that when we are looking at a single predicate, the choice has little effect.</S>
    <S sid="542" ssid="140">In the following sections, we attempt to use the abstract roles to generalize the behavior of semantically related predicates.</S>
    <S sid="543" ssid="141">We will present results at different, successively broader levels of generalization, making use of the categorization of FrameNet predicates into frames and more general semantic domains.</S>
    <S sid="544" ssid="142">We first turn to using data from the appropriate frame when no data for the target word are available.</S>
    <S sid="545" ssid="143">Table 19 shows results for various probability distributions using a division of training and test data constructed such that no target words are in common.</S>
    <S sid="546" ssid="144">Every tenth target word was included in the test set.</S>
    <S sid="547" ssid="145">The amount of training data available for each frame varied, from just one target word in some cases to 167 target words in the &#8220;perception/noise&#8221; frame.</S>
    <S sid="548" ssid="146">The training set contained a total of 75,919 frame elements and the test set 7,801 frame elements.</S>
    <S sid="549" ssid="147">Performance broken down by abstract role.</S>
    <S sid="550" ssid="148">The third column represents accuracy when frame element boundaries are given to the system, and the fourth and fifth columns reflect finding the boundaries automatically.</S>
    <S sid="551" ssid="149">Unlabeled recall includes cases that were identified as a frame element but given the wrong role.</S>
    <S sid="552" ssid="150">The results show a familiar trade-off between coverage and accuracy.</S>
    <S sid="553" ssid="151">Conditioning both the head word and path features on the frame reduces coverage but improves accuracy.</S>
    <S sid="554" ssid="152">A linear interpolation, &#955;1P(r I path, f ) + &#955;2P(r I h,f) + &#955;3P(r I pt, position, voice,f) achieved 79.4% performance on the test set, significantly better than any of the individual distributions and approaching the result of 82.1% for the original system, using target-specific statistics and thematic roles.</S>
    <S sid="555" ssid="153">This result indicates that predicates in the same frame behave similarly in terms of their argument structure, a finding generally consistent with theories of linking that claim that the syntactic realization of verb arguments can be predicted from their semantics.</S>
    <S sid="556" ssid="154">We would expect verbs in the same frame to be semantically similar and to have the same patterns of argument structure.</S>
    <S sid="557" ssid="155">The relatively high performance of frame-level statistics indicates that the Minimal lattice for cross-frame generalization. frames defined by FrameNet are fine-grained enough to capture the relevant semantic similarities.</S>
    <S sid="558" ssid="156">This result is encouraging in that it indicates that a relatively small amount of data can be annotated for a few words in a semantic frame and used to train a system that can then bootstrap to a larger number of predicates.</S>
    <S sid="559" ssid="157">More difficult than the question of unseen predicates in a known frame are frames for which no training data are present.</S>
    <S sid="560" ssid="158">The 67 frames in the current data set cover only a fraction of the English language, and the high cost of annotation makes it difficult to expand the data set to cover all semantic domains.</S>
    <S sid="561" ssid="159">The FrameNet project is defining additional frames and annotating data to expand the scope of the database.</S>
    <S sid="562" ssid="160">The question of how many frames exist, however, remains unanswered for the time being; a full account of frame semantics is expected to include multiple frames being invoked by many words, as well as an inheritance hierarchy of frames and a more detailed representation of each frame&#8217;s meaning.</S>
    <S sid="563" ssid="161">In this section, we examine the FrameNet data by holding out an entire frame for testing and using other frames from the same general semantic domain for training.</S>
    <S sid="564" ssid="162">Recall from Figure 1 that domains like COMMUNICATION include frames like CONVERSATION, QUESTIONING, and STATEMENT.</S>
    <S sid="565" ssid="163">Because of the variation in difficulty between different frames and the dependence of the results on which frames are held out for testing, we used a jackknifing methodology.</S>
    <S sid="566" ssid="164">Each frame was used in turn as test data, with all other frames used as training data.</S>
    <S sid="567" ssid="165">The results in Table 20 show average results over the entire data set.</S>
    <S sid="568" ssid="166">Combining the distributions gives a system based on the (very restricted) backoff lattice of Figure 13.</S>
    <S sid="569" ssid="167">This system achieves performance of 51.0%, compared to 82.1% for the original system and 79.4% for the within-frame generalization task.</S>
    <S sid="570" ssid="168">The results show that generalizing across frames, even within a domain, is more difficult than generalizing across target words within a frame.</S>
    <S sid="571" ssid="169">There are several factors that may account for this: the FrameNet domains were intended primarily as a way of organizing the project, and their semantics have not been formalized.</S>
    <S sid="572" ssid="170">Thus, it may not be surprising that they do not correspond to significant generalizations about argument structure.</S>
    <S sid="573" ssid="171">The domains are fairly broad, as indicated by the fact that always choosing the most common role for a given domain (the baseline for cross-frame, within-domain generalization, given as P(r  |d) in Table 20, classifies 28.4% of frame elements correctly) does not do better than the cross-domain baseline of always choosing the most common role from the entire database regardless of domain (P(r) in Table 20, which yields 28.7% correct).</S>
    <S sid="574" ssid="172">This contrasts with a 40.9% baseline for P(r  |t), that is, always choosing the most common role for a particular target word (Table 5, last line).</S>
    <S sid="575" ssid="173">Domain information does not seem to help a great deal, given no information about the frame.</S>
    <S sid="576" ssid="174">Furthermore, the cross-frame experiments here are dependent on the mapping of frame-level roles to abstract thematic roles.</S>
    <S sid="577" ssid="175">This mapping was done at the frame level; that is, FrameNet roles with the same label in two different frames may be translated into two different thematic roles, but all target words in the same frame make use of the same mapping.</S>
    <S sid="578" ssid="176">The mapping of roles within a frame is generally one to one, and therefore the choice of mapping has little effect when using statistics conditioned on the target word and on the frame, as in the previous section.</S>
    <S sid="579" ssid="177">When we are attempting to generalize between frames, the mapping determines which roles from the training frame are used to calculate probabilities for the roles in the test frames, and the choice of mapping is much more significant.</S>
    <S sid="580" ssid="178">The mapping used is necessarily somewhat arbitrary.</S>
    <S sid="581" ssid="179">It is interesting to note that the path feature performs better when not conditioned on the domain.</S>
    <S sid="582" ssid="180">The head word, however, seems to be more domain-specific: although coverage declines when the context is restricted to the semantic domain, accuracy improves.</S>
    <S sid="583" ssid="181">This seems to indicate that the identity of certain role fillers is domainspecific, but that the syntax/semantics correspondence captured by the path feature is more general, as predicted by theories of syntactic linking.</S>
    <S sid="584" ssid="182">As general as they are, the semantic domains of the current FrameNet database cover only a small portion of the language.</S>
    <S sid="585" ssid="183">The domains are defined at the level of, for example, COMMUNICATION and EMOTION; a list of the 12 domains in our corpus is given in Table 1.</S>
    <S sid="586" ssid="184">Whether generalization is possible across domains is an important question for a general language-understanding system.</S>
    <S sid="587" ssid="185">For these experiments, a jackknifing protocol similar to that of the previous section was used, this time holding out one entire domain at a time and using all the others as training material.</S>
    <S sid="588" ssid="186">Results for the path and head word feature are shown in Table 21.</S>
    <S sid="589" ssid="187">The distributions P(r  |path), P(r  |h), and P(r) of Table 21 also appeared in Table 20; the difference between the experiments is only in the division of training and test sets.</S>
    <S sid="590" ssid="188">A linear interpolation, &#955;1P(r  |path) + &#955;2P(r  |h), classifies 39.8% of frame elements correctly.</S>
    <S sid="591" ssid="189">This is no better than our result of 40.9% (Table 3) for always choosing a predicate&#8217;s most frequent role; however, the cross-domain system does not have role frequencies for the test predicates.</S>
    <S sid="592" ssid="190">As one might expect, as we make successively broader generalizations to semantically more distant predicates, performance degrades.</S>
    <S sid="593" ssid="191">Our results indicate that frame semantics give us a level at which generalizations relevant to argument linking can be made.</S>
    <S sid="594" ssid="192">Our results for unseen predicates within the same frame are encouraging, indicating that the predicates are semantically similar in ways that result in similar argument structure, as the semantically based theories of linking advocated by Levin (1993) and Levin and Rappaport Hovav (1996) would predict.</S>
    <S sid="595" ssid="193">We hope that corpus-based systems such as ours can provide a way of testing and elaborating such theories in the future.</S>
    <S sid="596" ssid="194">We believe that some level of skeletal representation of the relevant aspects of a word&#8217;s meaning, along the lines of Kipper et al. (2000) and of the frame hierarchy being developed by the FrameNet project, could be used in the future to help a statistical system generalize from similar words for which training data are available.</S>
  </SECTION>
  <SECTION title="10." number="9">
    <S sid="597" ssid="1">Our system is able to label semantic roles automatically with fairly high accuracy, indicating promise for applications in various natural language tasks.</S>
    <S sid="598" ssid="2">Semantic roles do not seem to be simple functions of a sentence&#8217;s syntactic tree structure, and lexical statistics were found to be extremely valuable, as has been the case in other natural language processing applications.</S>
    <S sid="599" ssid="3">Although lexical statistics are quite accurate on the data covered by observations in the training set, the sparsity of their coverage led us to introduce semantically motivated knowledge sources, which in turn allowed us to compare automatically derived and hand-built semantic resources.</S>
    <S sid="600" ssid="4">Various methods of extending the coverage of lexical statistics indicated that the broader coverage of automatic clustering outweighed its imprecision.</S>
    <S sid="601" ssid="5">Carefully choosing sentence-level features for representing alternations in verb argument structure allowed us to introduce dependencies between frame element decisions within a sentence without adding too much complexity to the system.</S>
    <S sid="602" ssid="6">Integrating semantic interpretation and syntactic parsing yielded only the slightest gain, showing that although probabilistic models allow easy integration of modules, the gain over an unintegrated system may not be large because of the robustness of even simple probabilistic systems.</S>
    <S sid="603" ssid="7">Many aspects of our system are still quite preliminary.</S>
    <S sid="604" ssid="8">For example, our system currently assumes knowledge of the correct frame type for the target word to determine the semantic roles of its arguments.</S>
    <S sid="605" ssid="9">A more complete semantic analysis system would thus require a module for frame disambiguation.</S>
    <S sid="606" ssid="10">It is not clear how difficult this problem is and how much it overlaps with the general problem of word-sense disambiguation.</S>
    <S sid="607" ssid="11">Much else remains to be done to apply the system described here to the interpretation of general text.</S>
    <S sid="608" ssid="12">One technique for dealing with the sparseness of lexical statistics would be the combination of FrameNet data with named-entity systems for recognizing times, dates, and locations, the effort that has gone into recognizing these items, typically used as adjuncts, should complement the FrameNet data, which is more focused on arguments.</S>
    <S sid="609" ssid="13">Generalization to predicates for which no annotated data are available may be possible using other lexical resources or automatic clustering of predicates.</S>
    <S sid="610" ssid="14">Automatically learning generalizations about the semantics and syntactic behavior of predicates is an exciting problem for the years to come.</S>
  </SECTION>
  <SECTION title="Appendix" number="10">
    <S sid="611" ssid="1">Penn Treebank constituent (or nonterminal) labels.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="11">
    <S sid="612" ssid="1">We are grateful to Chuck Fillmore, Andreas Stolcke, Jerry Feldman, and three anonymous reviewers for their comments and suggestions, to Collin Baker for his assistance with the FrameNet data, and to Mats Rooth and Sabine Schulte im Walde for making available their parsed corpus.</S>
    <S sid="613" ssid="2">This work was primarily funded by National Science Foundation grant ITR/HCI #0086132 to the FrameNet project.</S>
  </SECTION>
</PAPER>
