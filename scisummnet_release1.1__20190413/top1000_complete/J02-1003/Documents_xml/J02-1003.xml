<PAPER>
  <S sid="0">Generating Referring Expressions: Boolean Extensions Of The Incremental Algorithm</S>
  <ABSTRACT>
    <S sid="1" ssid="1">This paper brings a logical perspective to the generation of referring expressions, addressing the incompleteness of existing algorithms in this area.</S>
    <S sid="2" ssid="2">After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.</S>
    <S sid="3" ssid="3">To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="4" ssid="1">This paper brings a logical perspective to the generation of referring expressions, addressing the incompleteness of existing algorithms in this area.</S>
    <S sid="5" ssid="2">After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.</S>
    <S sid="6" ssid="3">To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental Algorithm of Dale and Reiter (1995).</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="7" ssid="1">Generation of referring expressions (GRE) is a key task of most natural language generation (NLG) systems (e.g., Reiter and Dale 2000, Section 5.4).</S>
    <S sid="8" ssid="2">Regardless of the type of knowledge base (KB) forming the input to the generator, many objects will not be designated in it via an ordinary proper name.</S>
    <S sid="9" ssid="3">A person like Mr. Jones, for example, may be designated using an artificial name like #Jones083, if the name Jones is not uniquely distinguishing.</S>
    <S sid="10" ssid="4">The same is true for a piece of furniture, a tree, or an atomic particle, for instance, for which no proper name is in common use at all, or (in most cases) if the generator tries to refer to an entire set of objects.</S>
    <S sid="11" ssid="5">In all such cases, the generator has to &#8220;invent&#8221; a description that enables the hearer to identify the intended referent.</S>
    <S sid="12" ssid="6">In the case of Mr. Jones, for example, the program could identify him by providing his full name and address; in the case of a tree, some longer description may be necessary.</S>
    <S sid="13" ssid="7">Henceforth, we will call the intended referent the target of the GRE algorithm.</S>
    <S sid="14" ssid="8">The question that we set out to answer is whether existing GRE algorithms produce adequate descriptions whenever such descriptions exist: in short, whether these algorithms are, as we shall say, complete.</S>
    <S sid="15" ssid="9">The paper brings a degree of formal precision to this issue and reveals a number of reasons why current GRE algorithms are incomplete; we sketch remedies and discuss their consequences in terms of linguistic coverage and computational tractability.</S>
    <S sid="16" ssid="10">We take the Incremental Algorithm (Dale and Reiter 1995) to represent the state of the art in this area, and we minimize the deviations from this algorithm.</S>
    <S sid="17" ssid="11">As a result, this paper might be read as an investigation into how widely the ideas underlying the Incremental Algorithm can be used, and the extent to which they may be generalized.</S>
    <S sid="18" ssid="12">The main generalization that we will investigate involves complex Boolean combinations of properties, that is, descriptions that involve more than a merely intersective (i.e., logically conjunctive) combination of properties.</S>
    <S sid="19" ssid="13">Such generalizations are natural because the properties involved are implicitly present in the KB, as we will explain; they become especially relevant when the algorithms are also generalized to generate references to sets, rather than individual objects.</S>
    <S sid="20" ssid="14">But, before we arrive at these generalizations, we will identify and confront a number of cases in which current GRE algorithms are incomplete even with respect to merely intersective descriptions.</S>
    <S sid="21" ssid="15">In this paper, we will deal with &#8220;first mention&#8221; descriptions only (unlike Dale 1992, Chapter 5; Mittal et al. 1998; Kibble 1999), assuming that the information used for generating the description is limited to a KB containing complete information about which properties are true of each object.</S>
    <S sid="22" ssid="16">Also, we focus on &#8220;one shot&#8221; descriptions, disregarding cases where an object is described through its relations with other objects (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001).</S>
    <S sid="23" ssid="17">More crucially, we follow Dale and Reiter (1995) in focusing on the semantic content of a description (i.e., the problem of content determination, for short), assuming that any combination of properties can be expressed by the NLG module responsible for linguistic realization.</S>
    <S sid="24" ssid="18">This modular approach allows us to separate logical aspects of generation (which are largely language independent) from purely linguistic aspects, and it allows the realization module to base its decisions on complete information about which combination of properties is to be realized.</S>
    <S sid="25" ssid="19">Accordingly, when we write Generation of Referring Expressions or GRE, we will refer specifically to determination of the semantic content of a description.</S>
    <S sid="26" ssid="20">Analogously, the word description will refer to the semantic content of a linguistic expression only.</S>
    <S sid="27" ssid="21">Note that our modular approach makes it unnatural to assume that a description is always expressed by a single noun phrase: if several sentences are needed, then so be it.</S>
    <S sid="28" ssid="22">After summarizing the Incremental Algorithm in Section 2, in Section 3 we take a closer look at the algorithm in its standard, &#8220;intersective&#8221; form, in which it identifies an object by intersecting a number of atomic properties.</S>
    <S sid="29" ssid="23">We discuss cases in which this algorithm fails to find an adequate description even though such a description exists, and we propose a number of possible remedies.</S>
    <S sid="30" ssid="24">Having extablished a completeness result for a version of the intersective Incremental Algorithm, we turn to questions of completeness that involve more complex Boolean combinations in Section 4.</S>
    <S sid="31" ssid="25">In Section 5, we summarize the main results of our exploration and put them in perspective.</S>
  </SECTION>
  <SECTION title="2." number="3">
    <S sid="32" ssid="1">The Incremental Algorithm of Dale and Reiter (1995) singles out a target object from among some larger domain of entities.</S>
    <S sid="33" ssid="2">It does this by logically conjoining a number of properties found in a part of the KB that represents information shared between speaker and hearer.</S>
    <S sid="34" ssid="3">The authors observed that the problem of finding a (&#8220;Full Brevity&#8221;) description that contains the minimum number of properties is computationally intractable (i.e., NP Hard).</S>
    <S sid="35" ssid="4">They combined this with the known fact that speakers often produce nonminimal descriptions anyway (e.g., Pechman 1989).</S>
    <S sid="36" ssid="5">Accordingly, they proposed an algorithm that only approximates Full Brevity, while being of only linear complexity.</S>
    <S sid="37" ssid="6">Our summary of the algorithm glosses over many details, yet still allows us to discuss completeness.</S>
    <S sid="38" ssid="7">In particular, we disregard any special provisions that might be made for the selection of head nouns because, arguably, this has to involve realizational issues.1 The Incremental Algorithm produces a set L of properties P1,.</S>
    <S sid="39" ssid="8">.</S>
    <S sid="40" ssid="9">.</S>
    <S sid="41" ssid="10">, Pn such that their logical conjunction forms a &#8220;distinguishing description&#8221; (Dale 1989) of the target object r. In other words, writing [[Q]] for the extension of Q (i.e., the set of objects that have the property Q), the intersection [[P1]] n &#183; &#183; &#183; n [[Pn]] must equal the singleton set {r}.</S>
    <S sid="42" ssid="11">It is a &#8220;hillclimbing&#8221; algorithm, which finds better and better approximations of the target set {r} by accumulating more and more properties&#8212;hence the term Incremental.</S>
    <S sid="43" ssid="12">There is no backtracking.</S>
    <S sid="44" ssid="13">Consequently, if some property Pi in L is made redundant by later additions (i.e., when ([[P1]] n &#183; &#183; &#183; n [[Pi &#8722; 1]] n [[Pi + 1]] n &#183; &#183; &#183; n [[Pn]]) C [[Pi]]), then Pi is retained as a member of L nevertheless.</S>
    <S sid="45" ssid="14">In the full algorithm (see below, D&amp;RAtt), properties are analyzed as pairs consisting of an Attribute and a Value.</S>
    <S sid="46" ssid="15">Attributes are ordered in a list A.</S>
    <S sid="47" ssid="16">If Ai precedes Aj in A, then Ai is &#8220;more preferred than&#8221; Aj; as a consequence, Ai will be considered before Aj by the algorithm.</S>
    <S sid="48" ssid="17">Suppose r is the target object, and D (the &#8220;domain&#8221;) is the set of elements from which r is to be selected.</S>
    <S sid="49" ssid="18">The algorithm iterates through A; for each Attribute Ai, it checks whether specifying a Value for that Attribute would rule out at least one object that has not already been ruled out; if so, the Attribute is added to L, with a suitable Value (FindBestValue, below).</S>
    <S sid="50" ssid="19">C is the set of &#8220;confusables&#8221; at any given stage of the algorithm.2 Objects that are ruled out are removed from C. The process of expanding L and contracting C continues until C = {r}; if and when this condition is met, L is a distinguishing set of properties.</S>
    <S sid="51" ssid="20">For easy generalizability, the algorithm will be cast in set-theoretic terms.</S>
    <S sid="52" ssid="21">We first present a version that focuses on properties, without separating these into Attributes and Values, and assume the properties themselves are ordered in a list P (cf.</S>
    <S sid="53" ssid="22">Reiter and Dale 2000).</S>
    <S sid="54" ssid="23">This version of the algorithm will be called D&amp;RProp, or D&amp;R when there is no risk of confusion.</S>
    <S sid="55" ssid="24">We assume that the domain contains one or more objects other than the target object, the so-called distractors: thus, r E D but {r} =&#65533; D. Return Failure {All properties in P have been tested, and still C =&#65533; {r}} Assuming (as do Dale and Reiter [1995]) that the tests in the body of the loop take some constant amount of time, the worst-case running time is on the order of na (i.e., O(na)), where na is the total number of properties.</S>
    <S sid="56" ssid="25">So, the algorithm has only linear complexity.</S>
    <S sid="57" ssid="26">A slightly closer approximation of Full Brevity can be achieved if Attributes and Values are separated (Dale and Reiter 1995), allowing the algorithm to choose the &#8220;best&#8221; Value for each Attribute.</S>
    <S sid="58" ssid="27">Given an Attribute, FindBestValue selects the Value that removes most distractors while still including the target r. If no Value includes r, the function returns nil.</S>
    <S sid="59" ssid="28">In case of a tie (i.e., no Value removes more distractors than all others), FindBestValue chooses the least specific of the contestants.</S>
    <S sid="60" ssid="29">For example, when dog rules out as many distractors as chihuahua, chihuahua cannot be chosen.</S>
    <S sid="61" ssid="30">A is the list of Attributes; L is the set of Attribute/Value combinations returned by the algorithm.</S>
    <S sid="62" ssid="31">A further notational convention will be useful: Values will be identified by two indices, the first of which identifies the Attribute.</S>
    <S sid="63" ssid="32">Thus, to denote Value j of Attribute Ai, we write Vi,j.</S>
    <S sid="64" ssid="33">This version of the algorithm will be called D&amp;RAtt.</S>
    <S sid="65" ssid="34">The initializations of L and D are omitted for brevity.</S>
    <S sid="66" ssid="35">We will switch back and forth between D&amp;R and D&amp;RAtt, depending on what is at stake.</S>
    <S sid="67" ssid="36">Like D&amp;R, D&amp;RAtt has linear complexity.</S>
    <S sid="68" ssid="37">This can be made precise in the following way.3 If the running time of a call of FindBestValue(r,Ai) is a constant times the number of Values of the Attribute Ai, then the worst-case running time of D&amp;RAtt is O(nvna), where na equals the number of Attributes in the language and nv the average number of Values of all Attributes.</S>
    <S sid="69" ssid="38">Some new definitions will be useful.</S>
    <S sid="70" ssid="39">A GRE algorithm is successful with respect to a given situation (i.e., with respect to a KB and a target) if it produces a distinguishing description of r in that situation.</S>
    <S sid="71" ssid="40">We will call an algorithm complete if it is successful in every situation in which a distinguishing description exists.</S>
    <S sid="72" ssid="41">Success is not always possible: the properties in the KB may not be sufficient for individuating a given object.</S>
    <S sid="73" ssid="42">Such no-win situations will not be held against an algorithm.</S>
    <S sid="74" ssid="43">The Incremental Algorithm generates descriptions that contain set intersection as their only Boolean operation.</S>
    <S sid="75" ssid="44">We define a GRE algorithm to be intersectively complete if it has the following property: whenever an object can be characterized by intersecting a finite number of properties, the algorithm will find such an intersection.</S>
    <S sid="76" ssid="45">We would like to prove the Incremental Algorithm to be intersectively complete, but we will meet a few obstacles before we get there.</S>
    <S sid="77" ssid="46">One assumption without which the Incremental Algorithm cannot be proven to be intersectively complete concerns the semantic relation between different Values of a given Attribute: their extensions should not &#8220;overlap&#8221; in the following precise sense: van Deemter Generating Referring Expressions (If Vi,j and Vi,k do not overlap, then either [[Vi,j]] &#57738; [[Vi,k]], or [[Vi,k]] &#57738; [[Vi,j]], or [[Vi,j]] and [[Vi,k]] have an empty intersection.)</S>
    <S sid="78" ssid="47">Values can overlap for different reasons.</S>
    <S sid="79" ssid="48">Some Attributes (e.g., COLOR) have &#8220;vague&#8221; Values (e.g., RED, ORANGE), which may be modeled as overlapping: some objects may count as both red and orange.</S>
    <S sid="80" ssid="49">Also, Values may derive from particular parts or aspects of an object; for example, if an object counts as METAL (PLASTIC) because it has some METAL (PLASTIC) parts, then it may be listed as both METAL and PLASTIC.</S>
    <S sid="81" ssid="50">Further examples arise if the KB models relations through unanalyzed properties.</S>
    <S sid="82" ssid="51">For example, a desk, or a particular type of desk, can stand in a given relation (e.g., &#8220;being considered by&#8221; or &#8220;being bought by&#8221;) to more than one other company.</S>
    <S sid="83" ssid="52">To see the problems arising from overlapping Values, consider a KB that models which customer bought which types of desks, and where C = {a, b, c, d, e, f}:</S>
  </SECTION>
  <SECTION title="BOUGHT-BY: PHILIPS ({a, b, e}), SONY ({a, c, d,f}) COLOR: BROWN ({a,b}), YELLOW ({c,d})" number="4">
    <S sid="84" ssid="1">(Desks of types a, b, and e were bought by Philips, and so on.</S>
    <S sid="85" ssid="2">Note that desks of type a were bought by two different companies.)</S>
    <S sid="86" ssid="3">Suppose a is the target, while the Attribute BOUGHT-BY is more &#8220;preferred&#8221; than COLOR.</S>
    <S sid="87" ssid="4">The Value PHILIPS (being the BestValue of BOUGHT-BY, since it removes more distractors than the Value SONY) is chosen first, reducing the initial set C to {a, b, e}.</S>
    <S sid="88" ssid="5">Now, the algorithm is doomed to end in Failure, since the different Values of COLOR are unable to remove the unwanted b without also sacrificing a.</S>
    <S sid="89" ssid="6">None of this can be corrected, since the algorithm does not use backtracking.</S>
    <S sid="90" ssid="7">Note that a uniquely identifying description of a would have been possible if only SONY had been chosen instead of PHILIPS, leading to a description like the brown desk bought by Sony.</S>
    <S sid="91" ssid="8">The algorithm does not just fail: it fails in a situation where Success was perfectly achievable!</S>
    <S sid="92" ssid="9">How can this limitation be remedied?</S>
    <S sid="93" ssid="10">One might introduce a limited kind of backtracking, which &#8220;remembers&#8221; where the algorithm has encountered overlapping Values and, when it results in Failure, goes back to the last-encountered situation where it has made a choice between overlapping Values; if this does not lead to Success, the algorithm backtracks to the previous choice situation, and so on until no more choice situations are left (Failure) or a distinguishing description has been reached (Success).</S>
    <S sid="94" ssid="11">Unfortunately, this algorithm becomes intractable if Values overlap too often: in the worst case, we are back to having to check all combinations of properties.</S>
    <S sid="95" ssid="12">A simpler and computationally more efficient algorithm would include all overlapping Values that are true of the target while also removing some distractors.</S>
    <S sid="96" ssid="13">This could be done as follows: whenever a Value Vi,j of an Attribute Ai is selected for inclusion in L, search for other Values of the same Attribute that have the target r as an element; if such a Value Vi,k is found, check whether it stands in the subset relation to Vi,j (i.e., either [[Vi,j]] &#57736; [[Vi,k]] or [[Vi,k]] &#57736; [[Vi,j]]); if not, then include Vi,k as well; next, search for yet another Value Vi,l of the same Attribute that has r as an element, and include Vi,l if it does not stand in the subset relation to Vi,j or Vi,k; and so on until no other Values of Ai exist that have r as an element; then move on to the next Attribute.</S>
    <S sid="97" ssid="14">This algorithm has a worst-case running time of O(nan2v).4 In our example, this algorithm would produce a set consisting of the properties BOUGHT BY SONY and BOUGHT BY PHILIPS, which can be realized as the desk bought by Sony and by Philips; if we change the example by letting Philips buy c as well as a, the algorithm will go on to select the property BROWN, resulting in a set of properties that may be realized as the brown desk bought by Sony and by Philips.</S>
    <S sid="98" ssid="15">Such descriptions appear to be quite natural.</S>
    <S sid="99" ssid="16">One might even argue, on Gricean grounds (Grice 1975), that identifying a simply as being bought by Philips can give rise to the false implicature that a was not bought by Sony.</S>
    <S sid="100" ssid="17">This suggests that the proposed algorithm might also be empirically more accurate than the one using limited backtracking provided, of course, properties are properly aggregated (e.g., Dalianis and Hovy 1996).</S>
    <S sid="101" ssid="18">To prove intersective completeness, certain assumptions concerning the cardinality of sets need to be made.</S>
    <S sid="102" ssid="19">To give an extreme example, suppose one wanted to refer to a real number that does not have a &#8220;proper name&#8221; (unlike, e.g., 7r); then the class of potentially useful properties is so vast that no GRE algorithm can take them all into consideration.</S>
    <S sid="103" ssid="20">As long as the number of properties (i.e., Attribute/Value combinations) is denumerably infinite (Kleene 1971), only termination becomes problematic: if a uniquely referring description [[P1]] n &#183; &#183; &#183; n [[Pn]] exists, then the algorithm will find one in finite time, since each of the n properties in the description will be found in finite time; if no distinguishing description exists, however, the algorithm never terminates.</S>
    <S sid="104" ssid="21">In the less likely case where the set of properties is nondenumerably infinite (i.e., it does not stand in a 1-1 relation to any set of natural numbers), completeness becomes problematic as well, since it is impossible for the algorithm to consider all properties; hence, successful combinations may be overlooked (cf.</S>
    <S sid="105" ssid="22">Kleene 1971,pages 6&#8211;8).</S>
    <S sid="106" ssid="23">Infinity of the set of distractors results in a different problem.</S>
    <S sid="107" ssid="24">The key question is whether there exists an effective procedure for removing distractors (i.e., for calculating C n [[Pi]]).</S>
    <S sid="108" ssid="25">If no such procedure exists, the Incremental Algorithm can only be applied after a property has been found that cuts down the set of distractors to a manageable size.</S>
    <S sid="109" ssid="26">To be on the safe side when we prove completeness, we will assume that the set of properties is at most denumerably infinite, while the set of distractors is finite.</S>
    <S sid="110" ssid="27">These assumptions are harmless in connection with present NLG systems, all of which work with relatively small sets.</S>
    <S sid="111" ssid="28">It is unclear how human speakers cope with large sets of properties and/or distractors, but this question goes beyond our present concerns.</S>
    <S sid="112" ssid="29">Based on these considerations, we prove intersective completeness under some assumptions concerning infinity and overlapping Values.</S>
    <S sid="113" ssid="30">We deal first with D&amp;R, then with the more complex D&amp;RAtt.</S>
    <S sid="114" ssid="31">Theorem 1: Completeness of D&amp;R Suppose there are at most denumerably many properties, and finitely many (one or more) distractors.</S>
    <S sid="115" ssid="32">Then if an object can be individuated by intersecting a finite number of properties, D&amp;R will find such an intersection.</S>
    <S sid="116" ssid="33">Proof Suppose [[Q1]] n &#183;&#183;&#183; n [[Qm]] = {r}, where the properties Q1,...,Qm occur in P in the order indicated by the subscripts.</S>
    <S sid="117" ssid="34">Now either D&amp;R returns Success before it has inspected all of Q1, ... , Qm, or it reaches the point where all of Q1, ... , Qm have been inspected.</S>
    <S sid="118" ssid="35">This does not mean that all of Q1, ... , Qm have necessarily been included in L, since other properties in P may have been selected that cause some of Q1, ... , Qm not to remove any distractors.</S>
    <S sid="119" ssid="36">Yet, when all of Q1,...,Qm have been inspected, Success must have been achieved.</S>
    <S sid="120" ssid="37">To see this, let Desi be the description that results after processing (i.e., inspecting and possibly including) Qi.</S>
    <S sid="121" ssid="38">Then a proof by induction over van Deemter Generating Referring Expressions i shows that [[Desi]] c [[Q1]] n &#183; &#183; &#183; n [[Qi]], for all i &lt; m. (Consider the basic case, where i = 1, and assume that Q1 E&#65533; [[Des1]].</S>
    <S sid="122" ssid="39">Q1 was rejected, so it did not remove any distractors; hence, [[Des1]] c [[Q1]].</S>
    <S sid="123" ssid="40">The induction step is analogous.)</S>
    <S sid="124" ssid="41">It follows that [[Desm]] c [[Q1]] n &#183; &#183; &#183; n [[Qm]] = {r}.</S>
    <S sid="125" ssid="42">But r E [[Desm]], so [[Desm]] = {r}.</S>
    <S sid="126" ssid="43">Theorem 2: Completeness of D&amp;RAtt Assume (1) Attributes have no overlapping Values (see Section 3.1), and (2) there are at most denumerably many Attributes and Values, and finitely many (one or more) distractors.</S>
    <S sid="127" ssid="44">Then if an object can be individuated by intersecting a finite number of properties, D&amp;RAtt will find such an intersection.</S>
    <S sid="128" ssid="45">Proof Given Assumption (1), if D&amp;R is complete, then so is D&amp;RAtt.</S>
    <S sid="129" ssid="46">To see this, let BV abbreviate FindBestValue(r,Ai).</S>
    <S sid="130" ssid="47">Suppose there is a Value Vi,j of Attribute Ai that leads to a distinguishing description whereas BV does not.</S>
    <S sid="131" ssid="48">Then a contradiction is derived as follows.</S>
    <S sid="132" ssid="49">For certain Vi,a1, .</S>
    <S sid="133" ssid="50">.</S>
    <S sid="134" ssid="51">.</S>
    <S sid="135" ssid="52">, Vi,an, So, either (i) r E&#65533; BV or (ii) there exists x =&#65533; r for which x E [[Vi,a1]] n &#183; &#183; &#183; n [[Vi,an]] n BV .</S>
    <S sid="136" ssid="53">But Case (i) contradicts the definition of FindBestValue (see Section 2); Case (ii), on the other hand, implies that hence, x E [[BV ]] while x E&#65533; [[Vi,j]].</S>
    <S sid="137" ssid="54">But r E [[BV]] n [[Vi,j]], so [[BV]] and [[Vi,j]] are not disjoint.</S>
    <S sid="138" ssid="55">Consequently, by Assumption (1), Case (ii) implies that [[Vi,a1]] n &#183; &#183; &#183; n [[Vi,an]] n [[Vi,j]] is a real subset of [[Vi,a1]] n &#183; &#183; &#183; n [[Vi,an]] n [[BV ]], contradicting the fact that FindBestValue prefers a more general Value (i.e., BV ) over a more specific one (i.e., Vi,j) only if it removes the same distractors.</S>
  </SECTION>
  <SECTION title="4." number="5">
    <S sid="139" ssid="1">Both versions of the Incremental Algorithm have been proven to be intersectively complete.</S>
    <S sid="140" ssid="2">Now we widen the issue to include all other Boolean combinations, involving negation (i.e., complementation) and disjunction (i.e., union).5 This is natural, since properties expressed by Boolean combinations are implicit in the KB: if the KB lists the property POODLE and the property ALSATIAN, then it implicitly contains the property of being either a poodle or an Alsatian.</S>
    <S sid="141" ssid="3">This move will, however, only have its full impact when we also widen the issue to reference to sets of objects.</S>
    <S sid="142" ssid="4">In the new setting, it will be useful to generalize our earlier notion of intersective completeness (Section 3), calling a GRE algorithm Boolean complete iff it finds a Boolean description of a set whenever one can be given on the basis of the properties in the KB.</S>
    <S sid="143" ssid="5">Generating descriptions is even more important if the target is a set than if it is a single object: even if the objects in the set have proper names, the set as a whole may lack a name (and enumerating the objects may be cumbersome).</S>
    <S sid="144" ssid="6">Yet, reference to sets has long been disregarded in NLG.</S>
    <S sid="145" ssid="7">In this section, we sketch generalizations of D&amp;R that produce descriptions of sets.</S>
    <S sid="146" ssid="8">To begin with, the algorithm D&amp;RPlural finds intersections P1 n&#183; &#183; &#183;nPn of atomic properties P1,.</S>
    <S sid="147" ssid="9">.</S>
    <S sid="148" ssid="10">.</S>
    <S sid="149" ssid="11">, Pn whose extension equals a given target set S (van Deemter 2000).</S>
    <S sid="150" ssid="12">Since S may or may not be a singleton, D&amp;RPlural subsumes D&amp;R.</S>
    <S sid="151" ssid="13">As before, we assume a nonempty set of distractors; that is, S C D but S =&#65533; D.6 Return Failure {All properties in P have been tested, yet C =&#65533; S} Note that S takes the place of the target object r in the earlier algorithms; the process of expanding L and contracting C continues until C = S. Because this is basically the same algorithm as D&amp;R, it has the same computational complexity of O(na), where na is the cardinality of P. D&amp;RPlural characterizes a set by scrutinizing its elements.</S>
    <S sid="152" ssid="14">This does not work for properties like BEING OF THE SAME AGE, which crucially pertain to sets of objects (cf.</S>
    <S sid="153" ssid="15">Stone 2000).</S>
    <S sid="154" ssid="16">The algorithm can, however, be generalized to cover such cases if we initialize C not to D but to the powerset of D, after which the algorithm selects properties of sets, removing from P(D) all those sets for which the property is false.</S>
    <S sid="155" ssid="17">For example, selection of BEING OF THE SAME AGE removes all those sets whose elements are not of the same age as each other, selection of FORMING A FOOTBALL TEAM removes all sets that do not make up a football team, and so on.</S>
    <S sid="156" ssid="18">As a result, the algorithm generates descriptions of sets of collective entities (i.e., sets of sets).</S>
    <S sid="157" ssid="19">In this way, descriptions such as those teams all of whose members are of the same age can be generated.</S>
    <S sid="158" ssid="20">In this collective version of D&amp;RPlural, the target S is a set of sets; P is a list of properties of sets, so if Pi E P, then [[Pill is also a set of sets.</S>
    <S sid="159" ssid="21">As in the case of distributive properties, describing one entity (in this case, one set) is a special case of describing a set of entities.</S>
    <S sid="160" ssid="22">Once again, these adaptations leave the algorithm structurally unchanged: sets replace objects throughout.</S>
    <S sid="161" ssid="23">Yet, they cause the complexity of the algorithm to become exponential, since testing whether C = S involves inspecting all elements of C, of which there can be up to 2nd (where nd is the cardinality of the domain D).</S>
    <S sid="162" ssid="24">This algorithm can also be applied to distributive properties if these are upgraded to the level of sets: Let a newfangled distributive property be true of a set iff the property (in ordinary parlance) is true of all its elements (Kamp and Reyle 1993, page 338).</S>
    <S sid="163" ssid="25">This requires that the target S is always cast as a set of sets, even if it is viewed distributively.</S>
    <S sid="164" ssid="26">For example, if a set of players&#8212;say, a, b, and c&#8212;are to be characterized as a collection (e.g., to say that they won as a team of three), then S = {{a, b, c}}; if they are to be characterized distributively (e.g., to say that each of them has the flu), then S = {{a, b, c}, {a, b}, {a, c}, {b, c}, {a}, {b}, {c}}.</S>
    <S sid="165" ssid="27">In this way, the algorithm is able to combine collective and distributive properties, as in those football teams whose members are British.</S>
    <S sid="166" ssid="28">We will not explore collective versions of the Incremental Algorithm further here, focusing instead on the relatively simple case of D&amp;RPlural, in which all properties are distributive.</S>
    <S sid="167" ssid="29">As in the case of D&amp;R, it is easy to separate Attributes and Values when referring to sets, allowing a closer approximation of Full Brevity: the resulting algorithm, D&amp;RPlural,Att, is to D&amp;RPlural as D&amp;RAtt is to D&amp;R; overlapping Values can be treated as described in Section 3.1.</S>
    <S sid="168" ssid="30">In what follows, we will once again take propertyoriented versions of the Incremental Algorithm as our starting point, but implications for the separation between Attributes and Values will be mentioned where they are nontrivial.</S>
    <S sid="169" ssid="31">Now that we are able to generate references to sets, let us move away from purely intersective descriptions, on to full Boolean combinations of properties.</S>
    <S sid="170" ssid="32">Consider a KB whose domain is a set of animals (a, b, c, d, e) and whose only Attributes are TYPE and COLOR: TYPE: DOG ({a, b, c, d, e}), POODLE ({a, b}) COLOR: BLACK ({a, b, c}), WHITE ({d, e}) (All domain elements happen to be dogs.)</S>
    <S sid="171" ssid="33">In this situation, the Incremental Algorithm does not allow us to individuate any of the animals.</S>
    <S sid="172" ssid="34">Intuitively, however, the KB should enable one to refer to c, for example, since it is the only black dog that is not a poodle: {c} = BLACK n POODLE A similar gap exists where disjunctions might be used.</S>
    <S sid="173" ssid="35">For example, the Incremental Algorithm does not make the set of dogs that are either white or poodles referrable, whereas it is referrable in English&#8212;for example, the white dogs and the poodles.</S>
    <S sid="174" ssid="36">In the next two sections, we will investigate how negation and disjunction can be taken into account in GRE.</S>
    <S sid="175" ssid="37">But first we introduce a trick for determining whether unique identification of an entity is possible, in a given situation.7 The idea is to calculate, for each element d in the domain, the Satellite set of d, that is, the intersection of the extensions of all the properties true of d. Taking all extensions from our dog example, we have Satellite sets show which sets can be uniquely identified and which ones cannot.</S>
    <S sid="176" ssid="38">In the case of the dogs, for example, no intersective description of {c} is possible because, in the Satellite sets, c is always accompanied by other objects (i.e., a and b); more generally, in this example, no object in the domain is uniquely identifiable, since no object occurs in a Satellite set that is a singleton.</S>
    <S sid="177" ssid="39">Satellite sets can also be applied to the construction of descriptions.</S>
    <S sid="178" ssid="40">The entity {a, b}, for example, is uniquely described by the intersection DOG n POODLE n BLACK, and this can be read off the list of Satellite sets.</S>
    <S sid="179" ssid="41">Two of the three properties in DOG n POODLE n BLACK are redundant, however.</S>
    <S sid="180" ssid="42">Using Satellites sets for the construction of descriptions can be particularly useful when properly generalized to Boolean descriptions, but shortening the resulting descriptions in a computationally efficient way is difficult (van Deemter and Halld &#180;orsson 2001).</S>
    <S sid="181" ssid="43">The present paper will focus on another approach to Boolean descriptions, which takes the Incremental Algorithm as its point of departure (van Deemter 2001).</S>
    <S sid="182" ssid="44">In this section, we will show how full Boolean descriptions can be generated.</S>
    <S sid="183" ssid="45">This can be done in many different ways depending, among other things, on what form of descriptions are preferred, for example, disjunctions of conjunctions, or conjunctions of disjunctions.</S>
    <S sid="184" ssid="46">We will aim for the latter, while staying as close as possible to the Incremental Algorithm.</S>
    <S sid="185" ssid="47">The algorithm proceeds as follows.</S>
    <S sid="186" ssid="48">First we add negations to the list of atomic properties.</S>
    <S sid="187" ssid="49">Then D&amp;RPlural runs a number of times: first, in Phase 1, the algorithm is performed using all positive and negative literals; if this algorithm ends before C = S, Phase 2 is entered in which further distractors are removed from C by making use of negations of intersections of two literals, and so on, until either C = S (Success) or all combinations have been tried (Failure).</S>
    <S sid="188" ssid="50">Observe that the negation of an intersection comes down to set union, because of De Morgan&#8217;s Law: P1 n &#183; &#183; &#183; n Pn = P1 U &#183; &#183; &#183; U Pn.</S>
    <S sid="189" ssid="51">Thus, Phase 2 of the algorithm deals with disjunctions of length 2, Phase 3 deals with disjunctions of length 3, and so on.</S>
    <S sid="190" ssid="52">Optimizations may be applied to shorten the resulting descriptions.</S>
    <S sid="191" ssid="53">For instance, a description of the form (P U Q) n (P U R) can be simplified to (P U (Q n R)) using standard algorithms (e.g., McCluskey 1965).</S>
    <S sid="192" ssid="54">Such optimizations, however, are less urgent than in the case of the more verbose descriptions generated using Satellite sets (see above), and we will disregard optimizations here.</S>
    <S sid="193" ssid="55">A schematic presentation may be useful, in which P+1_ stands for any literal, that is, any atomic property or its negation.</S>
    <S sid="194" ssid="56">(Different occurrences of P+1_ denote potentially different literals.)</S>
    <S sid="195" ssid="57">The length of a property will equal the number of literals van Deemter Generating Referring Expressions occurring in it.</S>
    <S sid="196" ssid="58">We will say that a D&amp;RPlural phase uses a set of properties X if it loops through the properties in X (i.e., X takes the place of P in the original D&amp;RPlural).</S>
    <S sid="197" ssid="59">D&amp;RB.,e&#65533; Phase 1.</S>
    <S sid="198" ssid="60">Perform D&amp;RPlural using all properties of the form P+/_.</S>
    <S sid="199" ssid="61">If this is successful, then stop; otherwise, go to Phase 2.</S>
    <S sid="200" ssid="62">Phase 2.</S>
    <S sid="201" ssid="63">Based on the Values of L and C coming out of Phase 1, perform D&amp;RPlural using all properties of the form P+/_ U P+/_.</S>
    <S sid="202" ssid="64">If this is successful, then stop; otherwise, go to Phase 3.</S>
    <S sid="203" ssid="65">Phase 3.</S>
    <S sid="204" ssid="66">Based on the Values of L and C coming out of Phase 2, perform D&amp;RPlural using all properties of the form P+/_ U P+/_ U P+/_.</S>
    <S sid="205" ssid="67">If this is successful, then stop; otherwise, go to Phase 4.</S>
    <S sid="206" ssid="68">Etc.</S>
    <S sid="207" ssid="69">One can require without loss of generality that no property, considered at any phase, may have different occurrences of the same atom.</S>
    <S sid="208" ssid="70">(For example, it is useless to consider the property P1 U P2 U P1, which must be true of any element in the domain, or the property P1 U P2 U P1, which is equivalent to the earlier-considered property P1 U P2.)</S>
    <S sid="209" ssid="71">Therefore, since at phase n there is room for properties of length n, the maximal number of phases equals the total number of atomic properties.</S>
    <S sid="210" ssid="72">Consider our old example, where the preference order of atomic properties corresponds with the order in which they are listed, and where the same order extends to their negations, all of which are less preferred.</S>
    <S sid="211" ssid="73">Abbreviating B = BLACK, D = DOG, P = POODLE, and W = WHITE, we have P = (B, D, P, W, B, D, P, W).</S>
    <S sid="212" ssid="74">Now, if S = {c, d, e} and S = {c} (as before) are to be characterized, nothing eventful happens.</S>
    <S sid="213" ssid="75">In both cases, a description is found during Phase 1: P in the first case, B n P in the second.</S>
    <S sid="214" ssid="76">The situation gets more interesting if S = {a, b, d, e}, which triggers Phase 2.</S>
    <S sid="215" ssid="77">For instance, if positive literals precede negative literals, the properties relevant for Phase 2 might be ordered as follows: (BUD,BUP,BUW,DUP,DUW,PUW,BUD,BUP,BUW,DUB, DUP,DUW,PUB,PUD,PUW, WUB, WUD, WUP,BUD,BUP, BUW,DUP,DUW,PUW) During Phase 1, no property is selected, since the only property true of all elements in S = {a, b, d, e} is D, which fails to remove any distractors.</S>
    <S sid="216" ssid="78">During Phase 2, one property after another is rejected.</S>
    <S sid="217" ssid="79">For example, the property BUD is rejected because it does not remove any distractors.</S>
    <S sid="218" ssid="80">The first property that is true of all elements of S while also removing distractors is P U W. This property removes all distractors at once, causing the algorithm to end with L = {POODLE U WHITE} as the complete description.</S>
    <S sid="219" ssid="81">If we modify the example by letting [[BLACK]] = {a, c} (rather than {a, b, c}) and S = {b, c, d, e} (rather than S = {a, b, d, e}), then the description L = {BLACK U POODLE} is found.</S>
    <S sid="220" ssid="82">D&amp;RBoolean is incremental not only within a phase, but also from one phase to the next, which causes shorter disjunctions to be favored over longer ones.</S>
    <S sid="221" ssid="83">Once a property has been selected, it will not be abandoned even if properties selected during later phases make it logically superfluous.</S>
    <S sid="222" ssid="84">As a result, one may generate descriptions like X n (Y U Z) (e.g., white (cats and dogs)) in a situation where Y U Z (e.g., cats and dogs) would have sufficed (because (Y U Z) C_ X).</S>
    <S sid="223" ssid="85">This is not unlike some of the redundancies generated by Dale and Reiter&#8217;s algorithm and, as in their case, it is unclear whether this is descriptively adequate.</S>
    <S sid="224" ssid="86">Adaptations can be made if needed.</S>
    <S sid="225" ssid="87">For instance, phases might run separately before running in combination: first (as usual) Phase 1, then 2, then (as usual) 1&amp;2, then 3, then 1&amp;3, then 2&amp;3, then (as usual) 1&amp;2&amp;3, and so on.8 As a result of this adaptation, the description Y U Z would be generated because of Phase 2 alone.</S>
    <S sid="226" ssid="88">Double incrementality, however, does not save D&amp;RBoolean from intractability.</S>
    <S sid="227" ssid="89">To estimate running time as a function of the number of properties (na) in the KB and those in the description (nl), we can mirror an argument in Dale and Reiter (1995, Section 3.1.1) to show that the maximal number of properties to be considered equals (The factor of 2 derives from inspecting both each atom and its negation.)</S>
    <S sid="228" ssid="90">If nl &#171; na, then this is on the order of nnl a .</S>
    <S sid="229" ssid="91">To avoid intractability, the algorithm can be pruned.</S>
    <S sid="230" ssid="92">No matter where this is done, the result is a polynomial algorithm.</S>
    <S sid="231" ssid="93">By cutting off after Phase 1, for example, only (negations of) atomic properties are combined, producing such descriptions as the black dog that is not a poodle, disregarding more complex descriptions; as a result, completeness is lost, but only for references to nonsingleton sets, because set union does not add descriptive power where the description of singletons is concerned.</S>
    <S sid="232" ssid="94">The number of properties to be considered by this simpler algorithm equals (na)2 + 2na &#8722;1.</S>
    <S sid="233" ssid="95">To produce descriptions like WHITE n (CAT U DOG) (i.e., white (cats and dogs)) as well, the algorithm can be cut off one phase later, leading to a worst-case running time of O(n3a), and so on for more and more complex descriptions.</S>
    <S sid="234" ssid="96">D&amp;RBoolea can, of course, be modified to take advantage of the distinction between Attributes and Values.</S>
    <S sid="235" ssid="97">Suppose, for example, that V1 U &#183; &#183; &#183; U Vn takes precedence over W1 U &#183; &#183; &#183; U Wn whenever there are more negative Values among V1, ... , Vn than among W1, ... , Wn.</S>
    <S sid="236" ssid="98">Then the preference ordering between Attributes may be taken into account if the number of negative Values is the same in both unions; in case of a tie, the number of distractors removed by each of the two unions may decide; if all this fails to tip the balance, the relative specificity of Attributes may be used.</S>
    <S sid="237" ssid="99">The situation resembles that of D&amp;RAtt but, in the case of the new algorithm, D&amp;RBoolean,Att, there is more scope for choice, because it compares combinations (i.e., unions) of properties: when the preference order of individual Attributes has been decided, it can happen that [[Vi]] is more preferred than [[Wj]], while [[Wk]] is more preferred than [[Vl]], in which case it is unclear whether V1 U &#183; &#183; &#183; U Vn should be more preferred or W1 U &#183; &#183; &#183; U Wn.</S>
    <S sid="238" ssid="100">(Problems of this kind are not specific to Boolean combinations.</S>
    <S sid="239" ssid="101">For example, if an object x is identified through the relation R(xy) and the predicate P(y), then the degrees of preference of both R and P are relevant, and it is unclear which of the two is more important.)</S>
    <S sid="240" ssid="102">Once D&amp;RBoolean,Att is constructed along these lines, the question of overlapping Values arises in exactly the same way as in the case of D&amp;RAtt and D&amp;RPlural,Att.</S>
    <S sid="241" ssid="103">The problem arises if components of different unions overlap, as when the algorithm compares Vi,jUVk,l and Vi,jUVk,l,, where Vk,l and Vk,l, overlap in the sense of Section 3.1: as in the case of D&amp;RAtt, simply choosing the option that removes the most distractors may cause the algorithm to become incomplete.</S>
    <S sid="242" ssid="104">This problem can be overcome as before, using either limited backtracking or inclusion of all relevant options (Section 3.1).</S>
    <S sid="243" ssid="105">Instead of exploring D&amp;RBoolean,Att any further, we will return to its predecessor, D&amp;RBoolean, to prove that it is powerful enough to do its job.</S>
    <S sid="244" ssid="106">In Section 3.3, we proved intersective completeness for two versions of Dale and Reiter&#8217;s Incremental Algorithm, D&amp;R and D&amp;RAtt.</S>
    <S sid="245" ssid="107">We now prove Boolean completeness for D&amp;RBoolean, the Boolean extension of D&amp;RPlural.</S>
    <S sid="246" ssid="108">Theorem 3: Completeness of D&amp;RBOOk.</S>
    <S sid="247" ssid="109">Assume there are at most denumerably many properties, and finitely many distractors (one or more).</S>
    <S sid="248" ssid="110">Then if a set can be individuated distributively by any Boolean combination of properties, D&amp;RBoolean will find such a combination.</S>
    <S sid="249" ssid="111">Proof Any Boolean expression can be written in conjunctive normal form (CNF), that is, as an intersection of unions of literals (e.g., Fitting 1996).</S>
    <S sid="250" ssid="112">Theorem 3 follows from the following lemma.</S>
    <S sid="251" ssid="113">Lemma Let cp be a CNF formula whose longest union has a length of n (i.e., it conjoins n literals).</S>
    <S sid="252" ssid="114">Then D&amp;RBoolean will find a description cp' that is coextensive with cp, in at most n phases.</S>
    <S sid="253" ssid="115">This is proven by induction on the size of n. Basic case: If n = 1, the lemma is equivalent to completeness of D&amp;RPlural, the proof of which is analogous to that of the completeness of D&amp;R, replacing {r} by S. Induction step: Suppose the lemma is true for all n &lt; i.</S>
    <S sid="254" ssid="116">Now consider a CNF cp whose longest union has length i; let cp contain m unions of length i, namely, cp1 n &#183; &#183; &#183; n cpm.</S>
    <S sid="255" ssid="117">Then cp can be written as the CNF x n cp1 n &#183; &#183; &#183; n cpm, where all the unions in x have length &lt; i.</S>
    <S sid="256" ssid="118">The lemma is true for all n &lt; i, so if x is sent to D&amp;RBoolean, then the output is some x' such that [[x']] = [[x]], in fewer than i phases; so if, instead, cp is sent to D&amp;RBoolean, then, after i &#8722; 1 phases, some possibly incomplete description 77 has been found, such that [[77]] C [[x]].</S>
    <S sid="257" ssid="119">Also, [[cp]] C [77]].</S>
    <S sid="258" ssid="120">Phase i inspects all unions of length i, including each of cp1, ... , cpm.</S>
    <S sid="259" ssid="121">Therefore, unless a description coextensive with cp is found before phase i, one will be found during phase i.</S>
    <S sid="260" ssid="122">To see this, suppose the algorithm finds 0 such that [[0]] = [[cp1]] n &#183; &#183; &#183; n [[cpm]].</S>
    <S sid="261" ssid="123">Then [[x]] n [[0]] = [[cp]]; but [[cp]] C [77]] C [[x]], therefore also [[77]] n [[0]] = [[cp]].</S>
  </SECTION>
  <SECTION title="5." number="6">
    <S sid="262" ssid="1">The GRE algorithms discussed in this paper are fairly limited in their aspirations.</S>
    <S sid="263" ssid="2">For example, they do not involve relational descriptions (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001) or properties that are vague or context dependent (van Deemter 2000).</S>
    <S sid="264" ssid="3">Moreover, they disregard shades of salience (unlike algorithms proposed in Krahmer and Theune [1999], Theune [2000]), relying instead on a simple dichotomy between those objects that are salient enough (which end up in the domain D) and those that are not (Reiter and Dale 2000, Section 5.4).</S>
    <S sid="265" ssid="4">Finally, like all other GRE algorithms that we are aware of, they disregard the generation of descriptions in intensional contexts (e.g., John knows that x is the murderer ofJones; Dowty, Wall, and Peters 1981).</S>
    <S sid="266" ssid="5">But even within this limited brief, existing algorithms are incomplete.</S>
    <S sid="267" ssid="6">In particular, we have shown Dale and Reiter&#8217;s (1995) Incremental Algorithm to be intersectively incomplete with respect to Attributes that have overlapping Values and (less surprisingly) in some situations where the class of properties is infinitely large.</S>
    <S sid="268" ssid="7">Furthermore, the Incremental Algorithm excludes reference to sets and limits itself to purely intersective combinations of atomic properties, causing the algorithm to be incomplete with respect to the set of all Boolean combinations.</S>
    <S sid="269" ssid="8">Having noted these shortcomings, we have modified the Incremental Algorithm in such a way that these limitations are removed.</S>
    <S sid="270" ssid="9">The result is a set of generalizations of the Incremental Algorithm, for which we have proven completeness under appropriate assumptions.</S>
    <S sid="271" ssid="10">Integration of these different algorithms into one unified algorithm would be a nontrivial enterprise, as we have shown in Section 4.3.</S>
    <S sid="272" ssid="11">Integration with previously proposed extensions of the Incremental Algorithm would raise further questions, stemming from the fact that our descriptions are structurally complex.</S>
    <S sid="273" ssid="12">For example, consider the treatment of relational properties.</S>
    <S sid="274" ssid="13">Which is better: adding a relational property to a given incomplete description (... in the wooden shed) or adding a negated property (... which is not a poodle)?</S>
    <S sid="275" ssid="14">Making informed decisions about such questions, with proper attention to their combined effects, is a difficult task that is perhaps best tackled using the graph-theoretical approach outlined by Krahmer, van Erk, and Verleg (2001).</S>
    <S sid="276" ssid="15">Their approach is specifically suitable for accommodating different GRE algorithms and treats relations in the same way as properties Brevity.</S>
    <S sid="277" ssid="16">We have assumed that, on the whole, descriptions ought to be as brief as they can, as long as they are uniquely identifying.</S>
    <S sid="278" ssid="17">But in fact, a description can contain much more than is logically necessary for identification, even beyond the redundancies allowed by the Incremental Algorithm.</S>
    <S sid="279" ssid="18">Logically superfluous properties can, for example, be motivated by &#8220;overloading&#8221; if they serve communicative purposes other than identification (Pollack 1991; Dale and Reiter 1995, Section 2.4; Stone and Webber 1998; Jordan 1999).</S>
    <S sid="280" ssid="19">A description may also contain fewer properties than would be necessary for identification&#8212;for example, when no distinguishing description exists.</S>
    <S sid="281" ssid="20">A nondistinguishing description may take the form either of a definite description (as in John&#8217;s son, when John has several sons) or of an indefinite description (as in one of John&#8217;s sons; Horacek 1997; Stone and Webber 1998; Krahmer and Theune 1999).</S>
    <S sid="282" ssid="21">In both cases, the description may be useful even though it fails to be distinguishing.</S>
    <S sid="283" ssid="22">Tractability.</S>
    <S sid="284" ssid="23">Computational tractability has also been paramount in our explorations.</S>
    <S sid="285" ssid="24">There is no agreement on the extent to which computational linguists should worry about the computational complexity of algorithms, or about the precise way in which complexity is most relevant (e.g., &#8220;typical&#8221; or worst-case complexity, cf. footnote 3).</S>
    <S sid="286" ssid="25">Far from aiming to speak the last word on these issues, the material discussed here does shed some light on them.</S>
    <S sid="287" ssid="26">For example, even a fast algorithm can require a large number of calculations, in which case a solution may never be found; in the case of GRE, this happens when the set of distractors or the set of properties becomes extremely large (Section 3.2).</S>
    <S sid="288" ssid="27">Conversely, a complex algorithm can be safe to use if the domain is small (or if key calculations can be performed offline; e.g., Bateman 1999).</S>
    <S sid="289" ssid="28">This may be achieved by putting a bound on the size of the search space, and this may be justifiable on empirical grounds (see the discussion of D&amp;RBoolean in Section 4.3).</S>
    <S sid="290" ssid="29">One might, on the other hand, argue that bounding does not eliminate the disadvantages of an otherwise intractable algorithm, because the true nature of an algorithm is best revealed &#8220;by considering how it operates on unlimited cases&#8221; (Barton, Berwick, and Ristad 1987, Section 1.4.1).</S>
    <S sid="291" ssid="30">Be this as it may, we believe that complexity theory can offer valuable insights into the structure of GRE algorithms and that the growing attention to complexity in this area is a healthy development even if the practical implications are not always straightforward.</S>
    <S sid="292" ssid="31">Recent work also highlights an interesting mirror image of GRE complexity: a logically superfluous property may make it easier for the reader to find the referent. van Deemter Generating Referring Expressions An interesting class of cases is explored in Paraboni (2000), which focuses on descriptions of document parts.</S>
    <S sid="293" ssid="32">Consider the description the medicine depicted in Section 2.3.</S>
    <S sid="294" ssid="33">If Section 2 happens to contain only one figure, then the description the medicine depicted in Section 2 would have been logically sufficient, but this description would have made it necessary for the reader, in the worst case, to search through all of Section 2, making it less useful.</S>
    <S sid="295" ssid="34">Examples of this kind suggest that GRE should also take the computational complexity of interpretation into account.</S>
    <S sid="296" ssid="35">Experimental research on &#8220;minimal cooperative effort&#8221; (Clark 1992; Cremers 1996) points in the same direction.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="7">
    <S sid="297" ssid="1">Thanks are due to Robert Dale, Magn&#180;us Halld&#180;orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.</S>
    <S sid="298" ssid="2">Helpful comments from the reviewers of Computational Linguistics are also gratefully acknowledged.</S>
  </SECTION>
</PAPER>
