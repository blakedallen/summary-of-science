<PAPER>
  <S sid="0">A Global Joint Model for Semantic Role Labeling</S>
  <ABSTRACT>
    <S sid="1" ssid="1">We present a model for semantic role labeling that effectively captures the linguistic intuition that a semantic argument frame is a joint structure, with strong dependencies among the arguments.</S>
    <S sid="2" ssid="2">We show how to incorporate these strong dependencies in a statistical joint model with a rich set of features over multiple argument phrases.</S>
    <S sid="3" ssid="3">The proposed model substantially outperforms a similar state-of-the-art local model that does not include dependencies among different arguments.</S>
    <S sid="4" ssid="4">We evaluate the gains from incorporating this joint information on the Propbank corpus, when using correct syntactic parse trees as input, and when using automatically derived parse The gains amount to reduction on all arguments and core arguments for gold-standard parse trees on Propbank.</S>
    <S sid="5" ssid="5">For automatic parse trees, the error reductions are all and core arguments, respectively.</S>
    <S sid="6" ssid="6">We also present results on the CoNLL 2005 shared task data set.</S>
    <S sid="7" ssid="7">Additionally, we explore considering multiple syntactic analyses to cope with parser noise and uncertainty.</S>
  </ABSTRACT>
  <SECTION title="" number="1">
    <S sid="8" ssid="1">We present a model for semantic role labeling that effectively captures the linguistic intuition that a semantic argument frame is a joint structure, with strong dependencies among the arguments.</S>
    <S sid="9" ssid="2">We show how to incorporate these strong dependencies in a statistical joint model with a rich set of features over multiple argument phrases.</S>
    <S sid="10" ssid="3">The proposed model substantially outperforms a similar state-of-the-art local model that does not include dependencies among different arguments.</S>
    <S sid="11" ssid="4">We evaluate the gains from incorporating this joint information on the Propbank corpus, when using correct syntactic parse trees as input, and when using automatically derived parse trees.</S>
    <S sid="12" ssid="5">The gains amount to 24.1% error reduction on all arguments and 36.8% on core arguments for gold-standard parse trees on Propbank.</S>
    <S sid="13" ssid="6">For automatic parse trees, the error reductions are 8.3% and 10.3% on all and core arguments, respectively.</S>
    <S sid="14" ssid="7">We also present results on the CoNLL 2005 shared task data set.</S>
    <S sid="15" ssid="8">Additionally, we explore considering multiple syntactic analyses to cope with parser noise and uncertainty.</S>
  </SECTION>
  <SECTION title="1." number="2">
    <S sid="16" ssid="1">Since the release of the FrameNet (Baker, Fillmore, and Lowe 1998) and Propbank (Palmer, Gildea, and Kingsbury 2005) corpora, there has been a large amount of work on statistical models for semantic role labeling.</S>
    <S sid="17" ssid="2">Most of this work relies heavily on local classifiers: ones that decide the semantic role of each phrase independently of the roles of other phrases.</S>
    <S sid="18" ssid="3">However, linguistic theory tells us that a core argument frame is a joint structure, with strong dependencies between arguments.</S>
    <S sid="19" ssid="4">For instance, in the sentence [Final-hour trading]THEME accelerated [to 108.1 million shares]TARGET [yesterday]ARGM-TMP, the first argument is the subject noun phrase final-hour trading of the active verb accelerated.</S>
    <S sid="20" ssid="5">If we did not consider the rest of the sentence, it would look more like an AGENT argument, but when we realize that there is no other good candidate for a THEME argument, because to 108.1 million shares must be a TARGET and yesterday is most likely ARGM-TMP, we can correctly label it THEME.</S>
    <S sid="21" ssid="6">Even though previous work has modeled some correlations between the labels of parse tree nodes (see Section 2), many important phenomena have not been modeled.</S>
    <S sid="22" ssid="7">The key properties needed to model this joint structure are: (1) no finite Markov horizon assumption for dependencies among node labels, (2) features looking at the labels of multiple argument nodes and internal features of these nodes, and (3) a statistical model capable of incorporating these long-distance dependencies and generalizing well.</S>
    <S sid="23" ssid="8">We show how to build a joint model of argument frames, incorporating novel features into a discriminative log-linear model.</S>
    <S sid="24" ssid="9">This system achieves an error reduction of 24.1% on ALL arguments and 36.8% on CORE arguments over a state-of-the-art independent classifier for gold-standard parse trees on Propbank.</S>
    <S sid="25" ssid="10">If we consider the linguistic basis for joint modeling of a verb&#8217;s arguments (including modifiers), there are at least three types of information to be captured.</S>
    <S sid="26" ssid="11">The most basic is to limit occurrences of each kind of argument.</S>
    <S sid="27" ssid="12">For instance, there is usually at most one argument of a verb that is an ARG0 (agent), and although some modifier roles such as ARGM-TMP can fairly easily be repeated, others such as ARGM-MNR also generally occur at most once.1 The remaining two types of information apply mainly to core arguments (the strongly selected arguments of a verb: ARG0&#8211;ARG5 in Propbank), which in most linguistic theories are modeled as belonging together in an argument frame (set of arguments).</S>
    <S sid="28" ssid="13">The information is only marginally useful for adjuncts (the ARGM arguments of Propbank), which are usually treated as independent realizational choices not included in the argument frame of a verb.</S>
    <S sid="29" ssid="14">Firstly, many verbs take a number of different argument frames.</S>
    <S sid="30" ssid="15">Previous work has shown that these are strongly correlated with the word sense of the verb (Roland and Jurafsky 2002).</S>
    <S sid="31" ssid="16">If verbs were disambiguated for sense, the semantic roles of phrases would be closer to independent given the sense of the verb.</S>
    <S sid="32" ssid="17">However, because in almost all semantic role labeling work (including ours), the word sense is unknown and the model conditions only on the lemma, there is much joint information between arguments when conditioning only on the verb lemma.</S>
    <S sid="33" ssid="18">For example, compare: In the first case the noun phrase after passed is an ARG1, whereas in the second case it is a ARGM-LOC, with the choice governed by the sense of the verb pass.</S>
    <S sid="34" ssid="19">Secondly, even with same sense of a verb, different patterns of argument realization lead to joint information between arguments.</S>
    <S sid="35" ssid="20">Consider: (4) The meal that the ogre cooked the children is still remembered.</S>
    <S sid="36" ssid="21">Despite both examples having an identical surface syntax, knowing that the ARG1 of cook is expressed by the initial noun meal in the second example gives evidence that the children is the ARG2 (beneficiary), not the ARG1 in this case.</S>
    <S sid="37" ssid="22">Let us think of a graphical model over a set of m variables, one for each node in the parse tree t, representing the labels of the nodes and the dependencies between them.</S>
    <S sid="38" ssid="23">In order for a model over these variables to capture, for example, the statistical tendency of some semantic roles to occur at most once (e.g., that there is usually at most one constituent labeled AGENT), there must be a dependency link between any two variables.</S>
    <S sid="39" ssid="24">To estimate the probability that a certain node gets the role AGENT, we need to know if any of the other nodes were labeled with this role.</S>
    <S sid="40" ssid="25">We propose such a model, with a very rich graphical model structure, which is globally conditioned on the observation (the parse tree).2 Such a model is formally a Conditional Random Field (CRF) (Lafferty, McCallum, and Pereira 2001).</S>
    <S sid="41" ssid="26">However, note that in practice this term has previously been used almost exclusively to describe the restricted case of linear chain Conditional Markov Random Fields (sequence models) (Lafferty, McCallum, and Pereira 2001; Sha and Pereira 2003), or at least models that have strong Markov properties, which allow efficient dynamic programming algorithms (Cohn and Blunsom 2005).</S>
    <S sid="42" ssid="27">Instead, we consider a densely connected CRF structure, with no Markov properties, and use approximate inference by re-ranking the n-best solutions of a simpler model with stronger independence assumptions (for which exact inference is possible).</S>
    <S sid="43" ssid="28">Such a rich graphical model can represent many dependencies but there are two dangers&#8212;one is that the computational complexity of training the model and searching for the most likely labeling given the tree can be prohibitive, and the other is that if too many dependencies are encoded, the model will over-fit the training data and will not generalize well.</S>
    <S sid="44" ssid="29">We propose a model which circumvents these two dangers and achieves significant performance gains over a similar local model that does not add any dependency arcs among the random variables.</S>
    <S sid="45" ssid="30">To tackle the efficiency problem, we adopt dynamic programming and re-ranking algorithms.</S>
    <S sid="46" ssid="31">To avoid overfitting we encode only a small set of linguistically motivated dependencies in features over sets of the random variables.</S>
    <S sid="47" ssid="32">Our re-ranking approach, like the approach to parse re-ranking of Collins (2000), employs a simpler model&#8212;a local semantic role labeling algorithm&#8212;as a first pass to generate a set of n likely complete assignments of labels to all parse tree nodes.</S>
    <S sid="48" ssid="33">The joint model is restricted to these n assignments and does not have to search the exponentially large space of all possible joint labelings.</S>
  </SECTION>
  <SECTION title="2." number="3">
    <S sid="49" ssid="1">There has been a substantial amount of work on automatic semantic role labeling, starting with the statistical model of Gildea and Jurafsky (2002).</S>
    <S sid="50" ssid="2">Researchers have worked on defining new useful features, and different system architectures and models.</S>
    <S sid="51" ssid="3">Here we review the work most closely related to ours, concentrating on methods for incorporating joint information and for increasing robustness to parser error.</S>
  </SECTION>
  <SECTION title="2.1 Methods for Incorporating Joint Information" number="4">
    <S sid="52" ssid="1">Gildea and Jurafsky (2002) propose a method to model global dependencies by including a probability distribution over multi-sets of semantic role labels given a predicate.</S>
    <S sid="53" ssid="2">In this way the model can consider the assignment of all nodes in the parse tree and evaluate whether the set of realized semantic roles is likely.</S>
    <S sid="54" ssid="3">If a necessary role is missing or if an unusual set of arguments is assigned by the local model, this additional factor can correct some of the mistakes.</S>
    <S sid="55" ssid="4">The distribution over label multi-sets is estimated using interpolation of a relative frequency and a back-off distribution.</S>
    <S sid="56" ssid="5">The back-off distribution assumes each argument label is present or absent independently of the other labels, namely, it assumes a Bernoulli Naive Bayes model.</S>
    <S sid="57" ssid="6">The most likely assignment of labels according to such a joint model is found approximately using re-scoring of the top k = 10 assignments according to a local model, which does not include dependencies among arguments.</S>
    <S sid="58" ssid="7">Using this model improves the performance of the system in F-measure from 59.2 to 62.85.</S>
    <S sid="59" ssid="8">This shows that adding global information improves the performance of a role labeling system considerably.</S>
    <S sid="60" ssid="9">However, the type of global information in this model is limited to label multi-sets.</S>
    <S sid="61" ssid="10">We will show that much larger gains are possible from joint modeling, adding richer sources of joint information using a more flexible statistical model.</S>
    <S sid="62" ssid="11">The model of Pradhan, Hacioglu, et al. (2004, 2005) is a state-of-the-art model, based on Support Vector Machines, and incorporating a large set of structural and lexical features.</S>
    <S sid="63" ssid="12">At the heart of the model lies a local classifier, which labels each parse tree node with one of the possible argument labels or NONE.</S>
    <S sid="64" ssid="13">Joint information is integrated into the model in two ways: Dynamic class context: Using the labels of the two nodes to the left as features for classifying the current node.</S>
    <S sid="65" ssid="14">This is similar to the Conditional Markov Models (CMM) often used in information extraction (McCallum, Freitag, and Pereira 2000).</S>
    <S sid="66" ssid="15">Notice that here the previous two nodes classified are not in general the previous two nodes assigned non-NONE labels.</S>
    <S sid="67" ssid="16">If a linear order on all nodes is imposed, then the previous two nodes classified most likely bear the label NONE.</S>
    <S sid="68" ssid="17">Language model lattice re-scoring: Re-scoring of an N-best lattice with a trigram language model over semantic role label sequences.</S>
    <S sid="69" ssid="18">The target predicate is also part of the sequence.</S>
    <S sid="70" ssid="19">These ways of incorporating joint information resulted in small gains over a baseline system using only the features of Gildea and Jurafsky (2002).</S>
    <S sid="71" ssid="20">The performance gain due to joint information over a system using all features was not reported.</S>
    <S sid="72" ssid="21">The joint information captured by this model is limited by the n-gram Markov assumption of the language model over labels.</S>
    <S sid="73" ssid="22">In our work, we improve the modeling of joint dependencies by looking at longer-distance context, by defining richer features over the sequence of labels and input features, and by estimating the model parameters discriminatively.</S>
    <S sid="74" ssid="23">A system which can integrate longer-distance dependencies is that of Punyakanok et al. (2004) and Punyakanok, Roth, and Yih (2005).</S>
    <S sid="75" ssid="24">The idea is to build a semantic role labeling system that is based on local classifiers but also uses a global component that ensures that several linguistically motivated global constraints on argument frames are satisfied.</S>
    <S sid="76" ssid="25">The constraints are categorical and specified by hand.</S>
    <S sid="77" ssid="26">For example, one global constraint is that the argument phrases cannot overlap&#8212;that is, if a node is labeled with a non-NONE label, all of its descendants have to be labeled NONE.</S>
    <S sid="78" ssid="27">The proposed framework is integer linear programming (ILP), which makes it possible to find the most likely assignment of labels to all nodes of the parse tree subject to specified constraints.</S>
    <S sid="79" ssid="28">Solving the ILP problem is NP-hard but it is very fast in practice (Punyakanok et al. 2004).</S>
    <S sid="80" ssid="29">The authors report substantial gains in performance due to these global consistency constraints.</S>
    <S sid="81" ssid="30">This method was applied to improve the performance both of a system based on labeling syntactic chunks and one based on labeling parse tree nodes.</S>
    <S sid="82" ssid="31">Our work differs from that work in that our constraints are not categorical (either satisfied or not), but are rather statistical preferences, and that they are learned automatically based on features specified by the knowledge engineer.</S>
    <S sid="83" ssid="32">On the other hand, we solve the search/estimation problem through re-ranking and n-best search only approximately, not exactly.</S>
    <S sid="84" ssid="33">So far we have mainly discussed systems which label nodes in a parse tree.</S>
    <S sid="85" ssid="34">Many systems that only use shallow syntactic information have also been presented (Hacioglu 2004; Punyakanok et al. 2004); using full syntactic parse information was not allowed in the CoNLL 2004 shared task on Semantic Role Labeling and description of such systems can be found in (Carreras and M`arquez 2004).</S>
    <S sid="86" ssid="35">Most systems which use only shallow syntactic information represent the input sentence as a sequence of tokens (words or phrases), which they label with a BIO tagging representation (beginning, inside, and outside argument labels) (Hacioglu 2004).</S>
    <S sid="87" ssid="36">Limited joint information is used by such systems, provided as a fixed size context of tags on previous tokens; for example, a length five window is used in the chunk-based system in (Pradhan, Hacioglu et al. 2005).</S>
    <S sid="88" ssid="37">A method that models joint information in a different way was proposed by Cohn and Blunsom (2005).</S>
    <S sid="89" ssid="38">It uses a tree-structured CRF, where the statistical dependency structure is exactly defined by the edges in the syntactic parse tree.</S>
    <S sid="90" ssid="39">The only dependencies captured are between the label of a node and the label of each of its children.</S>
    <S sid="91" ssid="40">However, the arguments of a predicate can be arbitrarily far from each other in the syntactic parse tree and therefore a tree-CRF model is limited in its ability to model dependencies among different arguments.</S>
    <S sid="92" ssid="41">For instance, the dependency between the meal and the children for the sentence in example (4) will not be captured because these phrases are not in the same local tree according to Penn Treebank syntax.</S>
    <S sid="93" ssid="42">There have been multiple approaches to reducing the sensitivity of semantic role labeling systems to syntactic parser error.</S>
    <S sid="94" ssid="43">Promising approaches have been to consider multiple syntactic analyses&#8212;the top k parses from a single or multiple full parsers (Punyakanok, Roth, and Yih 2005), or a shallow parse and a full parse (M`arquez et al. 2005; Pradhan et al.</S>
    <S sid="95" ssid="44">2005), or several types of full syntactic parses (Pradhan, Ward et al. 2005).</S>
    <S sid="96" ssid="45">Such techniques are important for achieving good performance: The top four systems in the CoNLL 2005 shared task competition all used multiple syntactic analyses (Carreras and M`arquez 2005).</S>
    <S sid="97" ssid="46">These previous methods develop special components to combine the labeling decisions obtained using different syntactic annotation.</S>
    <S sid="98" ssid="47">The method of Punyakanok, Roth, and Yih (2005) uses ILP to derive a consistent set of arguments, each of which could be derived using a different parse tree.</S>
    <S sid="99" ssid="48">Pradhan, Ward et al. (2005) use stacking to train a classifier which combines decisions based on different annotations, and M`arquez et al.</S>
    <S sid="100" ssid="49">(2005) use special-purpose filtering and inference stages which combine arguments proposed by systems using shallow and full analyses.</S>
    <S sid="101" ssid="50">Our approach to increasing robustness uses the top k parses from a single parser and is a simple general method to factor in the uncertainty of the parser by applying Bayesian inference.</S>
    <S sid="102" ssid="51">It is most closely related to the method described in Finkel, Manning, and Ng (2006) and can be seen as an approximation of that method.</S>
    <S sid="103" ssid="52">We describe our system in detail by first introducing simpler local semantic role labeling models in Section 4, and later building on them to define joint models in Section 5.</S>
    <S sid="104" ssid="53">Before we start presenting models, we describe the data and evaluation measures used in Section 3.</S>
    <S sid="105" ssid="54">Readers can skip the next section and continue on to Section 4 if they are not interested in the details of the evaluation.</S>
  </SECTION>
  <SECTION title="3." number="5">
    <S sid="106" ssid="1">For most of our experiments we used the February 2004 release of Propbank.</S>
    <S sid="107" ssid="2">We also report results on the CoNLL 2005 shared task data (Propbank I) in Section 6.2.</S>
    <S sid="108" ssid="3">For the latter, we used the standard CoNLL evaluation measures, and we refer readers to the description of that task for details of the evaluation (Carreras and M`arquez 2005).</S>
    <S sid="109" ssid="4">In this section we describe the data and evaluation measures we used for the February 2004 data.</S>
    <S sid="110" ssid="5">We use our own set of measures on the February 2004 data for three reasons.</S>
    <S sid="111" ssid="6">Firstly, we wish to present a richer set of measures, which can better illustrate the performance of the system on core arguments as against adjuncts and the performance on identifying versus classifying arguments.</S>
    <S sid="112" ssid="7">Secondly, we technically could not use the CoNLL measure on the February 2004 data, because this earlier data was not available in a format which specifies which arguments should have the additional R-ARGX labels used in the CoNLL evaluation.3 Finally, these measures are better for comparison with early papers, because most research before 2005 did not distinguish referring arguments.</S>
    <S sid="113" ssid="8">We describe our argument-based measures in detail here in case researchers are interested in replicating our results for the February 2004 data.</S>
    <S sid="114" ssid="9">For the February 2004 data, we used the standard split into training, development, and test sets&#8212;the annotations from sections 02&#8211;21 formed the training set, section 24 the development, and section 23 the test set.</S>
    <S sid="115" ssid="10">The set of argument labels considered is the set of core argument labels (ARG0 through ARG5) plus the modifier labels (see Figure 1).</S>
    <S sid="116" ssid="11">The training set contained 85,392 propositions, the test set 4,615, and the development set 2,626.</S>
    <S sid="117" ssid="12">We evaluate semantic role labeling models on gold-standard parse trees and parse trees produced by Charniak&#8217;s automatic parser (Charniak 2000).</S>
    <S sid="118" ssid="13">For gold-standard parse trees, we preprocess the trees to discard empty constituents and strip functional tags.</S>
    <S sid="119" ssid="14">Using the trace information provided by empty constituents is very useful for improving performance (Palmer, Gildea, and Kingsbury 2005; Pradhan, Ward et al. 2005), but we have not used this information so that we can compare our results to previous work and since automatic systems that recover it are not widely available.</S>
    <S sid="120" ssid="15">Since 2004, there has been a precise, standard evaluation measure for semantic role labeling, formulated by the organizers of the CoNLL shared tasks (Carreras and M`arquez 2004, 2005).</S>
    <S sid="121" ssid="16">An evaluation script is also distributed as part of the provided software for the shared task and can be used to evaluate systems on Propbank I data.</S>
    <S sid="122" ssid="17">For papers published between 2000 and 2005, there are several details of the evaluation measures for semantic role labeling that make it difficult to compare results obtained by different researchers, because researchers use their own implementations of evaluation measures, without making all the exact details clear in their papers.</S>
    <S sid="123" ssid="18">The first issue is the existence of arguments consisting of multiple constituents.</S>
    <S sid="124" ssid="19">In this case it is not clear whether partial credit is to be given for guessing only some of the constituents comprising the argument correctly.</S>
    <S sid="125" ssid="20">The second issue is whether the bracketing of constituents should be required to be recovered correctly, in other words, whether pairs of labelings, such as [the]ARG0 [man]ARG0 and [the man]ARG0 are to be considered the same or not.</S>
    <S sid="126" ssid="21">If they are considered the same, there are multiple labelings of nodes in a parse tree that are equivalent.</S>
    <S sid="127" ssid="22">The third issue is that when using automatic parsers, some of the constituents that are fillers of semantic roles are not recovered by the parser.</S>
    <S sid="128" ssid="23">In this case it is not clear how various research groups have scored their systems (using headword match, ignoring these arguments altogether, or using exact match).</S>
    <S sid="129" ssid="24">If we vary the choice taken for these three issues, we can come up with many (at least eight) different evaluation measures, and these details are important, because different choices can lead to rather large differences in reported performance.</S>
    <S sid="130" ssid="25">Here we describe in detail our evaluation measures for the results on the February 2004 data reported in this article.</S>
    <S sid="131" ssid="26">The measures are similar to the CoNLL evaluation measure, but report a richer set of statistics; the exact differences are discussed at the end of this section.</S>
    <S sid="132" ssid="27">For both gold-standard and automatic parses we use one evaluation measure, which we call argument-based evaluation.</S>
    <S sid="133" ssid="28">To describe the evaluation measure, we will use as an example the correct and guessed semantic role labelings shown in Figures 2(a) and 2(b).</S>
    <S sid="134" ssid="29">Both are shown as labelings on parse tree nodes with labels of the form ARGX and C-ARGX.</S>
    <S sid="135" ssid="30">The label C-ARGX is used to represent multi-constituent arguments.</S>
    <S sid="136" ssid="31">A constituent labeled C-ARGX is assumed to be a continuation of the closest constituent to the left labeled ARGX.</S>
    <S sid="137" ssid="32">Our semantic role labeling system produces labelings of this form and the gold standard Propbank annotations are converted to this form as well.4 The evaluation is carried out individually for each predicate and its associated argument frame.</S>
    <S sid="138" ssid="33">If a sentence contains several clauses, the several argument frames are evaluated separately.</S>
    <S sid="139" ssid="34">Our argument-based measures do not require exact bracketing (if the set of words constituting an argument is correct, there is no need to know how this set is broken into constituents) and do not give partial credit for labeling correctly only some of several constituents in a multi-constituent argument.</S>
    <S sid="140" ssid="35">They are illustrated in Figure 2.</S>
    <S sid="141" ssid="36">For these measures, a semantic role labeling of a sentence is viewed as a labeling on sets of words.</S>
    <S sid="142" ssid="37">These sets can encompass several non-contiguous spans.</S>
    <S sid="143" ssid="38">Figure 2(c) gives the representation of the correct and guessed labelings shown in Figures 2(a) and 2(b), in the first and second rows of the table, respectively.</S>
    <S sid="144" ssid="39">To convert a labeling on parse tree nodes to this form, we create a labeled set for each possibly multi-constituent argument.</S>
    <S sid="145" ssid="40">All remaining sets of words are implicitly labeled with NONE.</S>
    <S sid="146" ssid="41">We can see that, in this way, exact bracketing is not necessary and also no partial credit is given when only some of several constituents in a multi-constituent argument are labeled correctly.</S>
    <S sid="147" ssid="42">We will refer to word sets as &#8220;spans.&#8221; To compute the measures, we are comparing a guessed set of labeled spans to a correct set of labeled spans.</S>
    <S sid="148" ssid="43">We briefly define the various measures of comparison used herein, using the example guessed and correct Argument-based scoring measures for the guessed labeling.</S>
    <S sid="149" ssid="44">Toutanova, Haghighi, and Manning A Global Joint Model for SRL labelings shown in Figure 2(c).</S>
    <S sid="150" ssid="45">All spans not listed explicitly are assumed to have label NONE.</S>
    <S sid="151" ssid="46">The scoring measures are illustrated in Figure 2(d).</S>
    <S sid="152" ssid="47">The figure shows performance measures&#8212;F-Measure (F1) and Whole Frame Accuracy (Acc.</S>
    <S sid="153" ssid="48">)&#8212;across nine different conditions.</S>
    <S sid="154" ssid="49">When the sets of labeled spans are compared directly, we obtain the complete task measures, corresponding to the ID&amp;CLS row and ALL column in Figure 2(d).</S>
    <S sid="155" ssid="50">We also define several other measures to understand the performance of the system on different types of labels.</S>
    <S sid="156" ssid="51">We measure the performance on identification (ID), classification (CLS), and the complete task (ID&amp;CLS), when considering only the core arguments (CORE), all arguments but with a single ARGM label for the modifier arguments (COARSEARGM), and all arguments (ALL).</S>
    <S sid="157" ssid="52">This defines nine sub-tasks, which we now describe.</S>
    <S sid="158" ssid="53">For each of them, we compute the Whole Frame Accuracy and F-Measure as follows: Whole Frame Accuracy (Acc.).</S>
    <S sid="159" ssid="54">This is the percentage of propositions for which there is an exact match between the proposed and correct labelings.</S>
    <S sid="160" ssid="55">For example, the whole frame accuracy for ID&amp;CLS and ALL is 0, because the correct and guessed sets of labeled spans shown in Figure 2(c) do not match exactly.</S>
    <S sid="161" ssid="56">In the figures, &#8220;Acc.&#8221; is always an abbreviation for this whole frame accuracy.</S>
    <S sid="162" ssid="57">Even though this measure has not been used extensively in previous work, we find it useful to track.</S>
    <S sid="163" ssid="58">Most importantly, potential applications of role labeling may require correct labeling of all (or at least the core) arguments in a sentence in order to be effective, and partially correct labelings may not be very useful.</S>
    <S sid="164" ssid="59">Moreover, a joint model for semantic role labeling optimizes Whole Frame Accuracy more directly than a local model does.</S>
    <S sid="165" ssid="60">F-Measure (F1).</S>
    <S sid="166" ssid="61">Because there may be confusion about what we mean by F-Measure in this multi-class setting, we define it here.</S>
    <S sid="167" ssid="62">F-Measure is defined as the harmonic mean of precision and recall: f = 2&#215;p&#215;r&#8226; true positive r &#8211; true positive This formula uses the number of true positive, false positive, and false negative spans in a given guessed labeling.</S>
    <S sid="168" ssid="63">True positive is the number of spans whose correct label is one of the core or modifier argument labels (not NONE) and whose guessed label is the same as the correct label.</S>
    <S sid="169" ssid="64">False positive is the number of spans whose guessed label is non-NONE and whose correct label is different from the guessed label (possibly NONE).</S>
    <S sid="170" ssid="65">False negative is the number of spans whose correct label is non-NONE and whose guessed label is not the same as the correct one (possibly NONE).</S>
    <S sid="171" ssid="66">In the figures in this paper we show F-Measure multiplied by 100 so that it is in the same range as Whole Frame Accuracy.</S>
    <S sid="172" ssid="67">Core Argument Measures (CORE).</S>
    <S sid="173" ssid="68">These measures score the system on core arguments only, without regard to modifier arguments.</S>
    <S sid="174" ssid="69">They can be obtained by first mapping all non-core argument labels in the guessed and correct labelings to NONE.</S>
    <S sid="175" ssid="70">Coarse Modifier Argument Measures (COARSEARGM).</S>
    <S sid="176" ssid="71">Sometimes it is sufficient to know a given span has a modifier role, without knowledge of the specific role label.</S>
    <S sid="177" ssid="72">In addition, deciding exact modifier argument labels was one of the decisions with highest disagreement among annotators (Palmer, Gildea, and Kingsbury 2005).</S>
    <S sid="178" ssid="73">To estimate performance under this setting, we relabel all ARGM-X arguments to ARGM in the proposed and correct labeling.</S>
    <S sid="179" ssid="74">Such a performance measure was also used by Xue and Palmer (2004).</S>
    <S sid="180" ssid="75">Note that these measures do not exclude the core arguments but instead consider the core plus a coarse version of the modifier arguments.</S>
    <S sid="181" ssid="76">Thus for COARSEARGM ALL we count {0} as a true positive span, {1,2} , {3,4}, and {7,8,9} as false positive, and {1, 2, 3, 4} and {7, 8, 9} as false negative.</S>
    <S sid="182" ssid="77">Identification Measures (ID).</S>
    <S sid="183" ssid="78">These measure how well we do on the ARG vs. NONE distinction.</S>
    <S sid="184" ssid="79">For the purposes of this evaluation, all spans labeled with a non-NONE label are considered to have the generic label ARG.</S>
    <S sid="185" ssid="80">For example, to compute CORE ID, we compare the following sets of labeled spans: Classification Measures (CLS).</S>
    <S sid="186" ssid="81">These are performance on argument spans which were also guessed to be argument spans (but possibly the exact label was wrong).</S>
    <S sid="187" ssid="82">In other words, these measures ignore the ARG vs. NONE confusions.</S>
    <S sid="188" ssid="83">They ignore all spans, which were incorrectly labeled NONE, or incorrectly labeled with an argument label, when the correct label was NONE.</S>
    <S sid="189" ssid="84">This is different from &#8220;classification accuracy&#8221; used in previous work to mean the accuracy of the system in classifying spans when the correct set of argument spans is given.</S>
    <S sid="190" ssid="85">To compute CLS measures, we remove all spans from Sguessed and Scorrect that do not occur in both sets, and compare the resulting sets.</S>
    <S sid="191" ssid="86">For example, to compute the ALL CLS measures, we need to compare the following sets of labeled spans: The rest of the spans were removed from both sets because they were labeled NONE according to one of the labelings and non-NONE according to the other.</S>
    <S sid="192" ssid="87">The F-Measure is .50 and the Whole Frame Accuracy is 0%.</S>
    <S sid="193" ssid="88">As we mentioned before, we label and evaluate the semantic frame of every predicate in the sentence separately.</S>
    <S sid="194" ssid="89">It is possible for a sentence to contain several propositions&#8212;annotations of predicates occurring in the sentence.</S>
    <S sid="195" ssid="90">For example, in the sentence The spacecraft faces a six-year journey to explore Jupiter, there are two propositions, for the verbs faces and explore.</S>
    <S sid="196" ssid="91">These are: [The spacecraft]ARG0 [faces]PRED [a six-year journey to explore Jupiter]ARG1.</S>
    <S sid="197" ssid="92">[The spacecraft]ARG0 faces a six-year journey to [explore]PRED [Jupiter]ARG1.</S>
    <S sid="198" ssid="93">Our evaluation measures compare the guessed and correct set of labeled spans for each proposition.</S>
    <S sid="199" ssid="94">The CoNLL evaluation measure (Carreras and M`arquez 2004, 2005) is almost the same as our argument-based measure.</S>
    <S sid="200" ssid="95">The only difference is that the CoNLL measure introduces an additional label type for arguments, of the form R-ARGX, used for referring exToutanova, Haghighi, and Manning A Global Joint Model for SRL pressions.</S>
    <S sid="201" ssid="96">The Propbank distribution contains a specification of which multi-constituent arguments are in a coreference chain.</S>
    <S sid="202" ssid="97">The CoNLL evaluation script considers these multi-constituent arguments as several separate arguments having different labels, where one argument has an ARGX label and the others have R-ARGX labels.</S>
    <S sid="203" ssid="98">The decision of which constituents were to be labeled with referring labels was made using a set of rules expressed with regular expressions.5 A script that converts Propbank annotations to CoNLL format is available as part of the shared task software.</S>
    <S sid="204" ssid="99">For example, in the following sentence, the CoNLL specification annotates the arguments of began as follows: [The deregulation]ARG1 of railroads [that]R-ARG1 [began]PRED enabled shippers to bargain for transportation.</S>
    <S sid="205" ssid="100">In contrast, we treat all multi-constituent arguments in the same way, and do not distinguish coreferential versus non-coreferential split arguments.</S>
    <S sid="206" ssid="101">According to our argument-based evaluation, the annotation of the arguments of the verb began is: [The deregulation]ARG1 of railroads [that]C-ARG1 [began]PRED enabled shippers to bargain for transportation.</S>
    <S sid="207" ssid="102">The difference between our argument based measure and the CoNLL evaluation measure is such that we cannot say that the value of one is always higher than the value of the other.</S>
    <S sid="208" ssid="103">Either measure could be higher depending on the kinds of errors made.</S>
    <S sid="209" ssid="104">For example, if the guessed labeling is: [The deregulation]ARG0 of railroads [that]R-ARG1 [began]PRED enabled shippers to bargain for transportation, the CoNLL script would count the argument that as correct and report precision and recall of .5, whereas our argument-based measure would not count any argument correct and report precision and recall of 0.</S>
    <S sid="210" ssid="105">On the other hand, if the guessed labeling is [The deregulation]ARG1 of railroads [that]C-ARG1 [began]PRED enabled shippers to bargain for transportation, the CoNLL measure would report a precision and recall of 0, whereas our argument-based measure would report precision and recall of 1.</S>
    <S sid="211" ssid="106">If the guessed labeling is [The deregulation]ARG1 of railroads [that]R-ARG1 [began]PRED enabled shippers to bargain for transportation, both measures would report precision and recall of 1.</S>
    <S sid="212" ssid="107">(For our argument-based measure it does not make sense to propose R-ARGX labels and we assume such labels would be converted to C-ARGX labels if they are after the phrase they refer to.)</S>
    <S sid="213" ssid="108">Nevertheless, overall we expect the two measures to yield very similar results.</S>
  </SECTION>
  <SECTION title="4." number="6">
    <S sid="214" ssid="1">A classifier is local if it assigns a probability (or score) to the label of an individual parse tree node ni independently of the labels of other nodes.</S>
    <S sid="215" ssid="2">In defining our models, we use the standard separation of the task of semantic role labeling into identification and classification phases.</S>
    <S sid="216" ssid="3">Formally, let L denote a mapping of the nodes in a tree t to a label set of semantic roles (including NONE) with respect to a predicate v. Let Id(L) be the mapping which collapses L&#8217;s non-NONE values into ARG.</S>
    <S sid="217" ssid="4">5 The regular expressions look for phrases containing pronouns with part-of-speech tags WDT, WRB, WP, or WP$ (Xavier Carreras, personal communication).</S>
    <S sid="218" ssid="5">Then, like the Gildea and Jurafsky (2002) system, we decompose the probability of a labeling L into probabilities according to an identification model PID and a classification model PCLS.</S>
    <S sid="219" ssid="6">This decomposition does not encode any independence assumptions, but is a useful way of thinking about the problem.</S>
    <S sid="220" ssid="7">Our local models for semantic role labeling use this decomposition.</S>
    <S sid="221" ssid="8">We use the same features for local identification and classification models, but use the decomposition for efficiency of training.</S>
    <S sid="222" ssid="9">The identification models are trained to classify each node in a parse tree as ARG or NONE, and the classification models are trained to label each argument node in the training set with its specific label.</S>
    <S sid="223" ssid="10">In this way the training set for the classification models is smaller.</S>
    <S sid="224" ssid="11">Note that we do not do any hard pruning at the identification stage in testing and can find the exact labeling of the complete parse tree, which is the maximizer of Equation (1).</S>
    <S sid="225" ssid="12">We use log-linear models for multi-class classification for the local models.</S>
    <S sid="226" ssid="13">Because they produce probability distributions, identification and classification models can be chained in a principled way, as in Equation (1).</S>
    <S sid="227" ssid="14">The baseline features we used for the local identification and classification models are outlined in Figure 3.</S>
    <S sid="228" ssid="15">These features are a subset of the features used in previous work.</S>
    <S sid="229" ssid="16">The standard features at the top of the figure were defined by Gildea and Jurafsky (2002), and the rest are other useful lexical and structural features identified in more recent work (Surdeanu et al. 2003; Pradhan et al.</S>
    <S sid="230" ssid="17">2004; Xue and Palmer 2004).</S>
    <S sid="231" ssid="18">We also incorporated several novel features which we describe next.</S>
    <S sid="232" ssid="19">Example of displaced arguments.</S>
    <S sid="233" ssid="20">We found that a large source of errors for ARG0 and ARG1 stemmed from cases such as those illustrated in Figure 4, where arguments were dislocated by raising or control verbs.</S>
    <S sid="234" ssid="21">Here, the predicate, expected, does not have a subject in the typical position&#8212; indicated by the empty NP&#8212;because the auxiliary is has raised the subject to its current position.</S>
    <S sid="235" ssid="22">In order to capture this class of examples, we use a binary feature, MISSING SUBJECT, indicating whether the predicate is &#8220;missing&#8221; its subject, and use this feature in conjunction with the PATH feature, so that we learn typical paths to raised subjects conditioned on the absence of the subject in its typical position.6 In the particular case of Figure 4, there is another instance of an argument being quite far from its predicate.</S>
    <S sid="236" ssid="23">The predicate widen shares the phrase the trade gap with expect as an ARG1 argument.</S>
    <S sid="237" ssid="24">However, as expect is a raising verb, widen&#8217;s subject is not in its typical position either, and we should expect to find it in the same position as expected&#8217;s subject.</S>
    <S sid="238" ssid="25">This indicates it may be useful to use the path relative to expected to find arguments for widen.</S>
    <S sid="239" ssid="26">In general, to identify certain arguments of predicates embedded in auxiliary and infinitival VPs we expect it to be helpful to take the path from the maximum extended projection of the predicate&#8212;the highest VP in the chain of VPs dominating the predicate.</S>
    <S sid="240" ssid="27">We introduce a new path feature, PROJECTED PATH, which takes the path from the maximal extended projection to an argument node.</S>
    <S sid="241" ssid="28">This feature applies only when the argument is not dominated by the maximal projection (e.g., direct objects).</S>
    <S sid="242" ssid="29">These features also handle other cases of discontinuous and nonlocal dependencies, such as those arising due to control verbs.</S>
    <S sid="243" ssid="30">The performance gain from these new features was notable, especially in identification.</S>
    <S sid="244" ssid="31">The performance on ALL arguments for the model using only the features in Figure 3, and the model using the additional features as well, are shown in Figure 5.</S>
    <S sid="245" ssid="32">For these results, the constraint that argument phrases do not overlap was enforced using the algorithm presented in Section 4.2.</S>
    <S sid="246" ssid="33">The most direct way to use trained local identification and classification models in testing is to select a labeling L of the parse tree that maximizes the product of the Performance of local classifiers on ALL arguments, using the features in Figure 3 only and using the additional local features.</S>
    <S sid="247" ssid="34">Using gold standard parse trees on Section 23. probabilities according to the two models, as in Equation (1).</S>
    <S sid="248" ssid="35">Because these models are local, this is equivalent to independently maximizing the product of the probabilities of the two models for the label li of each parse tree node ni as shown below in Equation (2).</S>
    <S sid="249" ssid="36">A problem with this approach is that a maximizing labeling of the nodes could possibly violate the constraint that argument nodes should not overlap with each other.</S>
    <S sid="250" ssid="37">Therefore, to produce a consistent set of arguments with local classifiers, we must have a way of enforcing the non-overlapping constraint.</S>
    <S sid="251" ssid="38">When labeling parse tree nodes, previous work has either used greedy algorithms to find a non-overlapping assignment, or the general-purpose ILP approach of Punyakanok et al. (2004).</S>
    <S sid="252" ssid="39">For labeling chunks an exact algorithm based on shortest paths was proposed in Punyakanok and Roth (2001).</S>
    <S sid="253" ssid="40">Its complexity is quadratic in the length of the sentence.</S>
    <S sid="254" ssid="41">Here we describe a faster exact dynamic programming algorithm to find the most likely non-overlapping (consistent) labeling of all nodes in the parse tree, according to a product of probabilities from local models, as in Equation (2).</S>
    <S sid="255" ssid="42">For simplicity, we describe the dynamic program for the case where only two classes are possible: ARG and NONE.</S>
    <S sid="256" ssid="43">The generalization to more classes is straightforward.</S>
    <S sid="257" ssid="44">Intuitively, the algorithm is similar to the Viterbi algorithm for context-free grammars, because we can describe the non-overlapping constraint by a &#8220;grammar&#8221; that disallows ARG nodes having ARG descendants.</S>
    <S sid="258" ssid="45">Subsequently, we will talk about maximizing the sum of the logs of local probabilities rather than the product of local probabilities, which is equivalent.</S>
    <S sid="259" ssid="46">The dynamic program works from the leaves of the tree up and finds a best assignment for each subtree, using already computed assignments for its children.</S>
    <S sid="260" ssid="47">Suppose we want the most likely consistent assignment for subtree t with child trees t1, ... , tk each storing the most likely consistent assignment of its nodes, as well as the log-probability of the ALLNONE assignment: the assignment of NONE to all nodes in the tree.</S>
    <S sid="261" ssid="48">The most likely assignment for t is the one that corresponds to the maximum of: Performance of local model on ALL arguments when enforcing the non-overlapping constraint or not.</S>
    <S sid="262" ssid="49">The log-probability of the ALLNONE assignment for a tree t is the log-probability of assigning the root node of t to NONE plus the sum of the log-probabilities of the ALLNONE assignments of the child subtrees of t. Propagating this procedure from the leaves to the root of t we have our most likely non-overlapping assignment.</S>
    <S sid="263" ssid="50">By slightly modifying this procedure, we obtain the most likely assignment according to a product of local identification and classification models.</S>
    <S sid="264" ssid="51">We use the local models in conjunction with this search procedure to select a most-likely labeling in testing.</S>
    <S sid="265" ssid="52">The complexity of this algorithm is linear in the number of nodes in the parse tree, which is usually much less than the square of the number of words in the sentence (l2), the complexity of the Punyakanok and Roth (2001) algorithm.</S>
    <S sid="266" ssid="53">For example, for a binarybranching parse tree, the number of nodes is approximately 2l.</S>
    <S sid="267" ssid="54">The speedup is due to the fact that when we label parse tree nodes, we make use of the bracketing constraints imposed by the parse tree.</S>
    <S sid="268" ssid="55">The shortest path algorithm proposed by Punyakanok and Roth can also be adapted to achieve this lower computational complexity.</S>
    <S sid="269" ssid="56">It turns out that enforcing the non-overlapping constraint does not lead to large gains in performance.</S>
    <S sid="270" ssid="57">The results in Figure 5 are from models that use the dynamic program for selecting non-overlapping arguments.</S>
    <S sid="271" ssid="58">To evaluate the gain from enforcing the constraint, Figure 6 shows the performance of the same local model using all features, when the dynamic program is used versus when a most likely possibly overlapping assignment is chosen in testing.</S>
    <S sid="272" ssid="59">The local model with basic plus additional features is our first pass model used in re-ranking.</S>
    <S sid="273" ssid="60">The non-overlapping constraint is enforced using the dynamic program.</S>
    <S sid="274" ssid="61">This is a state-of-the-art model.</S>
    <S sid="275" ssid="62">Its F-Measure on ALL arguments is 88.4 according to our argument-based scoring measure.</S>
    <S sid="276" ssid="63">This is very similar to the best reported results (as of 2004) using gold-standard parse trees without null constituents and functional tags: 89.4 F-Measure reported for the Pradhan et al. (2004) model.7 A more detailed analysis of the results obtained by the local model is given in Figure 7(a), and the two confusion matrices in Figures 7(b) and 7(c), which display the number of errors of each type that the model made.</S>
    <S sid="277" ssid="64">The first confusion matrix concentrates on CORE arguments and merges all modifying argument labels into a single ARGM label.</S>
    <S sid="278" ssid="65">The second concentrates on confusions among modifying arguments.</S>
    <S sid="279" ssid="66">From the confusion matrix in Figure 7(b), we can see that the largest number of errors are confusions of argument labels with NONE.</S>
    <S sid="280" ssid="67">The number of confusions between pairs of core arguments is low, as is the number of confusions between core and modifier labels.</S>
    <S sid="281" ssid="68">If we ignore the column and row corresponding to NONE in Figure 7(b), the number of off-diagonal entries is very small.</S>
    <S sid="282" ssid="69">This corresponds to the high F-Measures Performance measures for local model using all local features and enforcing the non-overlapping constraint.</S>
    <S sid="283" ssid="70">Results are on Section 23 using gold standard parse trees. on COARSEARGM CLS and CORE CLS, 98.1 and 98.0 respectively, shown in Figure 7(a).</S>
    <S sid="284" ssid="71">The number of confusions of argument labels with NONE, shown in the NONE column, is larger than the number of confusions of NONE with argument labels, shown in the NONE row.</S>
    <S sid="285" ssid="72">This shows that the model generally has higher precision than recall.</S>
    <S sid="286" ssid="73">We experimented with the precision&#8211;recall tradeoff but this did not result in an increase in F-Measure.</S>
    <S sid="287" ssid="74">From the confusion matrix in Figure 7(c) we can see that the number of confusions between modifier argument labels is higher than the number of confusions between core argument labels.</S>
    <S sid="288" ssid="75">This corresponds to the ALL CLS F-Measure of 95.7 versus the CORE CLS F-Measure of 98.0.</S>
    <S sid="289" ssid="76">The per-label F-Measures in the last column show that the performance on some very frequent modifier labels is in the low sixties or seventies.</S>
    <S sid="290" ssid="77">The confusions between modifier labels and NONE are quite numerous.</S>
    <S sid="291" ssid="78">Thus, to improve the performance on CORE arguments, we need to improve recall without lowering precision.</S>
    <S sid="292" ssid="79">In particular, when the model is uncertain which of several likely CORE labels to assign, we need to find additional sources of evidence to improve its confidence.</S>
    <S sid="293" ssid="80">To improve the performance on modifier arguments, we also need to lower the confusions among different modifier arguments.</S>
    <S sid="294" ssid="81">We will see that our joint model improves the overall performance mainly by improving the performance on CORE arguments, through increasing recall and precision by looking at wider sentence context.</S>
    <S sid="295" ssid="82">As discussed in Section 3, multiple constituents can be part of the same semantic argument as specified by Propbank.</S>
    <S sid="296" ssid="83">An automatic system that has to recover such information needs to have a way of indicating when multiple constituents labeled with the same semantic role are a part of the same argument.</S>
    <S sid="297" ssid="84">Some researchers (Pradhan et al. 2004; Punyakanok et al.</S>
    <S sid="298" ssid="85">2004) have chosen to make labels of the form C-ARGX distinct argument labels that become additional classes in a multi-class constituent classifier.</S>
    <S sid="299" ssid="86">These C-ARGX are used to indicate continuing arguments as illustrated in the two trees in Figure 2.</S>
    <S sid="300" ssid="87">We chose to not introduce additional labels of this form, because they might unnecessarily fragment the training data.</S>
    <S sid="301" ssid="88">Our automatic classifiers label constituents with one of the core or modifier semantic role labels, and a simple post-processing rule is applied to the output of the system to determine which constituents that are labeled the same are to be merged as the same argument.</S>
    <S sid="302" ssid="89">The post-processing rule is the following: For every constituent that bears a core argument label ARGX, if there is a preceding constituent with the same label, re-label the current constituent C-ARGX.</S>
    <S sid="303" ssid="90">Therefore, according to our algorithm, all constituents having the same core argument label are part of the same argument, and all constituents having the same modifier labels are separate arguments by themselves.</S>
    <S sid="304" ssid="91">This rule is fairly accurate for core arguments but is not always correct; it fails more often on modifier arguments.</S>
    <S sid="305" ssid="92">An evaluation of this rule using the CoNLL data set and evaluation measure shows that our upper bound in performance because of this rule is approximately 99.0 F-Measure on ALL arguments.</S>
  </SECTION>
  <SECTION title="5." number="7">
    <S sid="306" ssid="1">We proceed to describe our models incorporating dependencies between labels of nodes in the parse tree.</S>
    <S sid="307" ssid="2">As we discussed briefly before, the dependencies we would like to model are highly non-local.</S>
    <S sid="308" ssid="3">A factorized sequence model that assumes a finite Markov horizon, such as a chain CRF (Lafferty, McCallum, and Pereira 2001), would not be able to encode such dependencies.</S>
    <S sid="309" ssid="4">We define a CRF with a much richer dependency structure.</S>
    <S sid="310" ssid="5">Motivation for Re-Ranking.</S>
    <S sid="311" ssid="6">For argument identification, the number of possible assignments for a parse tree with n nodes is 2n.</S>
    <S sid="312" ssid="7">This number can run into the hundreds of billions for a normal-sized tree.</S>
    <S sid="313" ssid="8">For argument labeling, the number of possible assignments is &#8776; 20m, if m is the number of arguments of a verb (typically between 2 and 5), and 20 is the approximate number of possible labels if considering both core and modifying arguments.</S>
    <S sid="314" ssid="9">Training a model which has such a huge number of classes is infeasible if the model does not factorize due to strong independence assumptions.</S>
    <S sid="315" ssid="10">Therefore, in order to be able to incorporate long-range dependencies in our models, we chose to adopt a re-ranking approach (Collins 2000), which selects from likely assignments generated by a model which makes stronger independence assumptions.</S>
    <S sid="316" ssid="11">We utilize the top n assignments of our local semantic role labeling model PSRL to generate likely assignments.</S>
    <S sid="317" ssid="12">As can be seen from Figure 8(a), for relatively small values of n, our re-ranking approach does not present a serious bottleneck to performance.</S>
    <S sid="318" ssid="13">We used a value of n = 10 for training.</S>
    <S sid="319" ssid="14">In Figure 8(a) we can see that if we could pick, using an oracle, the best assignment out of the top 10 assignments according to the local model, we would achieve an F-Measure of 97.3 on all arguments.</S>
    <S sid="320" ssid="15">Increasing the number of n to 30 results in a very small gain in the upper bound on performance and a large increase in memory requirements.</S>
    <S sid="321" ssid="16">We therefore selected n = 10 as a good compromise.</S>
    <S sid="322" ssid="17">Generation of top n Most Likely Joint Assignments.</S>
    <S sid="323" ssid="18">We generate the top n most likely non-overlapping joint assignments of labels to nodes in a parse tree according to a local model PSRL, using an exact dynamic programming algorithm, which is a direct generalization of the algorithm for finding the top non-overlapping assignment described in Section 4.2.</S>
    <S sid="324" ssid="19">Parametric Models.</S>
    <S sid="325" ssid="20">We learn log-linear re-ranking models for joint semantic role labeling, which use feature maps from a parse tree and label sequence to a vector space.</S>
    <S sid="326" ssid="21">The form of the models is as follows.</S>
    <S sid="327" ssid="22">Let &#934;(t,v,L) E ]IBs denote a feature map from a tree t, target verb v, and joint assignment L of the nodes of the tree, to the vector space ]IBs.</S>
    <S sid="328" ssid="23">Let L1, L2, &#183; &#183; &#183; , LN denote the top N possible joint assignments.</S>
    <S sid="329" ssid="24">We learn a log-linear model with a parameter vector W, with one weight for each of the s dimensions of the feature vector.</S>
    <S sid="330" ssid="25">The probability (or score) of an assignment L according to this re-ranking model is defined as The score of an assignment L not in the top n is zero.</S>
    <S sid="331" ssid="26">We train the model to maximize the sum of log-likelihoods of the best assignments minus a quadratic regularization term.</S>
    <S sid="332" ssid="27">In this framework, we can define arbitrary features of labeled trees that capture general properties of predicate&#8211;argument structure.</S>
    <S sid="333" ssid="28">We will introduce the features of the joint re-ranking model in the context of the example parse tree shown in Figure 9.</S>
    <S sid="334" ssid="29">We model dependencies not only between the label of a Oracle upper bounds for top n non-overlapping assignments from local model on CORE and ALL arguments, using gold-standard parse trees.</S>
    <S sid="335" ssid="30">An example tree from Propbank with semantic role annotations, for the sentence Final-hour trading accelerated to 108.1 million shares yesterday. node and the labels of other nodes, but also dependencies between the label of a node and input features of other argument nodes.</S>
    <S sid="336" ssid="31">The features are specified by instantiation of templates and the value of a feature is the number of times a particular pattern occurs in the labeled tree.</S>
    <S sid="337" ssid="32">For a tree t, predicate v, and joint assignment L of labels to the nodes of the tree, we define the candidate argument sequence as the sequence of non-NONE labeled nodes [n1, l1, ... , vPRED, ..., nm, lm] (li is the label of node ni).</S>
    <S sid="338" ssid="33">A reasonable candidate argument sequence usually contains very few of the nodes in the tree&#8212;about 2 to 7&#8212;as this is the typical number of arguments for a verb.</S>
    <S sid="339" ssid="34">To make it more convenient to express our feature templates, we include the predicate node v in the sequence.</S>
    <S sid="340" ssid="35">This sequence of labeled nodes is defined with respect to the left-to-right order of constituents in the parse tree.</S>
    <S sid="341" ssid="36">Because non-NONE labeled nodes do not overlap, there is a strict left-to-right order among these nodes.</S>
    <S sid="342" ssid="37">The candidate argument sequence that corresponds to the correct assignment in Figure 9 is then: [NP1-ARG1, VBD1-PRED, PP1-ARG4, NP3-ARGM-TMP] Features from Local Models.</S>
    <S sid="343" ssid="38">All features included in the local models are also included in our joint models.</S>
    <S sid="344" ssid="39">In particular, each template for local features is included as a joint template that concatenates the local template and the node label.</S>
    <S sid="345" ssid="40">For example, for the local feature PATH, we define a joint feature template that extracts PATH from every node in the candidate argument sequence and concatenates it with the label of the node.</S>
    <S sid="346" ssid="41">Both a feature with the specific argument label and a feature with the generic back-off ARG label are created.</S>
    <S sid="347" ssid="42">This is similar to adding features from identification and classification models.</S>
    <S sid="348" ssid="43">In the case of the example candidate argument sequence provided, for the node NP1 we have the features: {(NPTSIVPIVBD)-ARG1, (NPTSIVPIVBD)-ARG} When comparing a local and a joint model, we use the same set of local feature templates in the two models.</S>
    <S sid="349" ssid="44">If these were the only features that a joint model used, we would expect its performance to be roughly the same as the performance of a local model.</S>
    <S sid="350" ssid="45">This is because the two models will in fact be in the same parametric family but will only differ slightly in the way the parameters are estimated.</S>
    <S sid="351" ssid="46">In particular, the likelihood of an assignment according to the joint model with local features will differ from the likelihood of the same assignment according to the local model only in the denominator (the partition function).</S>
    <S sid="352" ssid="47">The joint model sums over a few likely assignments in the denominator, whereas the local model sums over all assignments; also, the joint model does not treat the decomposition into identification and classification models in exactly the same way as the local model.</S>
    <S sid="353" ssid="48">Whole Label Sequence Features.</S>
    <S sid="354" ssid="49">As observed in previous work (Gildea and Jurafsky 2002; Pradhan et al. 2004), including information about the set or sequence of labels assigned to argument nodes should be very helpful for disambiguation.</S>
    <S sid="355" ssid="50">For example, including such information will make the model less likely to pick multiple nodes to fill the same role or to come up with a labeling that does not contain an obligatory argument.</S>
    <S sid="356" ssid="51">We added a whole label sequence feature template that extracts the labels of all argument nodes, and preserves information about the position of the predicate.</S>
    <S sid="357" ssid="52">Two templates for whole label sequences were added: one having the predicate voice only, and another also including the predicate lemma.</S>
    <S sid="358" ssid="53">These templates are instantiated as follows for the example candidate argument sequence: [voice:active, ARG1, PRED, ARG4, ARGM-TMP] [voice:active, lemma:accelerate, ARG1, PRED, ARG4, ARGM-TMP] We also add variants of these templates that use a generic ARG label instead of specific labels for the arguments.</S>
    <S sid="359" ssid="54">These feature templates have the effect of counting the number of arguments to the left and right of the predicate, which provides useful global information about argument structure.</S>
    <S sid="360" ssid="55">A local model is not able to represent the count of arguments since the label of each node is decided independently.</S>
    <S sid="361" ssid="56">This feature can very directly and succinctly encode preferences for required arguments and expected number of arguments.</S>
    <S sid="362" ssid="57">As previously observed (Pradhan et al. 2004), including modifying arguments in sequence features is not helpful.</S>
    <S sid="363" ssid="58">This corresponds to the standard linguistic understanding that there are no prevalent constraints on the position or presence of adjuncts in an argument frame, and was confirmed in our experiments.</S>
    <S sid="364" ssid="59">We redefined the whole label sequence features to exclude modifying arguments.</S>
    <S sid="365" ssid="60">The whole label sequence features are the first type of features we add to relax the independence assumptions of the local model.</S>
    <S sid="366" ssid="61">Because these features look at the sequence of labels of all arguments, they capture joint information.</S>
    <S sid="367" ssid="62">There is no limit on the length of the label sequence and thus there is no n-gram Markov order independence assumption (in practice the candidate argument sequences in the top n complete assignments are rarely more than 7 nodes long).</S>
    <S sid="368" ssid="63">Additionally, the nodes in the candidate argument sequences are in general not in the same local tree in the syntactic analysis and a tree-CRF model (Cohn and Blunsom 2005) would not be able to encode these dependencies.</S>
    <S sid="369" ssid="64">Joint Syntactic&#8211;Semantic Features.</S>
    <S sid="370" ssid="65">This class of features is similar to the whole label sequence features, but in addition to labels of argument nodes, it includes syntactic features of the nodes.</S>
    <S sid="371" ssid="66">These features can capture the joint mapping from the syntactic realization of the predicate&#8217;s arguments to its semantic frame.</S>
    <S sid="372" ssid="67">The idea of these features is to capture knowledge about the label of a constituent given the syntactic realization and labels of all other arguments of the verb.</S>
    <S sid="373" ssid="68">This is helpful in capturing syntactic alternations, such as the dative alternation.</S>
    <S sid="374" ssid="69">For example, consider the sentence (i) [Shaw Publishing]ARG0 [offered]PRED [Mr. Smith]ARG2 [a reimbursement]ARG1 and the alternative realization (ii) [Shaw Publishing]ARG0 [offered]PRED [a reimbursement]ARG1 [to Mr. Smith]ARG2.</S>
    <S sid="375" ssid="70">When classifying the NP in object position, it is useful to know whether the following argument is a PP.</S>
    <S sid="376" ssid="71">If it is, the NP will more likely be an ARG1, and if not, it will more likely be an ARG2.</S>
    <S sid="377" ssid="72">A feature template that captures such information extracts, for each candidate argument node, its phrase type and label.</S>
    <S sid="378" ssid="73">For example, the instantiations of such templates in (ii), including only the predicate voice or also the predicate lemma, would be: [voice:active, NP-ARG0, PRED, NP-ARG1, PP-ARG2] [voice:active,lemma:offer, NP-ARG0, PRED, NP-ARG1, PP-ARG2] We experimented with extracting several kinds of features from each argument node and found that the phrase type and the head of a directly dominating PP&#8212;if one exists&#8212;were most helpful.</S>
    <S sid="379" ssid="74">Local models normally consider only features of the phrase being classified in addition to features of the predicate.</S>
    <S sid="380" ssid="75">They cannot take into account the features of other argument nodes, because they are only given the input (parse tree), and the identity of the argument nodes is unknown.</S>
    <S sid="381" ssid="76">It is conceivable that a local model could condition on the features of all nodes in the tree but the number of parameters (features) would be extremely large.</S>
    <S sid="382" ssid="77">The joint syntactic&#8211;semantic features proposed here encode important dependencies using a very small number of parameters, as we will show in Section 5.4.</S>
    <S sid="383" ssid="78">We should note that Xue and Palmer (2004) define a similar feature template, called syntactic frame, which often captures similar information.</S>
    <S sid="384" ssid="79">The important difference is that their template extracts contextual information from noun phrases surrounding the predicate, rather than from the sequence of argument nodes.</S>
    <S sid="385" ssid="80">Because we use a joint model, we are able to use information about other argument nodes when labeling a node.</S>
    <S sid="386" ssid="81">Repetition Features.</S>
    <S sid="387" ssid="82">We also add features that detect repetitions of the same label in a candidate argument sequence, together with the phrase types of the nodes labeled with that label.</S>
    <S sid="388" ssid="83">For example, (NP-ARG0, WHNP-ARG0) is a common pattern of this form.</S>
    <S sid="389" ssid="84">Variants of this feature template also indicate whether all repeated arguments are sisters in the parse tree, or whether all repeated arguments are adjacent in terms of word spans.</S>
    <S sid="390" ssid="85">These features can provide robustness to parser errors, making it more likely to assign the same label to adjacent phrases that may have been incorrectly split by the parser.</S>
    <S sid="391" ssid="86">In Section 5.4 we report results from the joint model and an ablation study to determine the contribution of each of the types of joint features.</S>
    <S sid="392" ssid="87">Here we describe the application in testing of a joint model for semantic role labeling, using a local model PSRL and a joint re-ranking model PrSRL.</S>
    <S sid="393" ssid="88">The local model PSRL is used to generate N non-overlapping joint assignments L1, ... , LN.</S>
    <S sid="394" ssid="89">One option is to select the best Li according to PrSRL, as in Equation (3), ignoring the score from the local model.</S>
    <S sid="395" ssid="90">In our experiments, we noticed that for larger values of N, the performance of our re-ranking model PrSRL decreased.</S>
    <S sid="396" ssid="91">This was probably due to the fact that at test time the local classifier produces very poor argument frames near the bottom of the top n for large n. Because the re-ranking model is trained on relatively few good argument frames, it cannot easily rule out very bad frames.</S>
    <S sid="397" ssid="92">It makes sense then to incorporate the local model into our final score.</S>
    <S sid="398" ssid="93">Our final score is given by: where &#945; is a tunable parameter determining the amount of influence the local score has on the final score (we found &#945; = 1.0 to work best).</S>
    <S sid="399" ssid="94">Such interpolation with a score from a first-pass model was also used for parse re-ranking in (Collins 2000).</S>
    <S sid="400" ssid="95">Given this score, at test time we choose among the top n local assignments L1,.</S>
    <S sid="401" ssid="96">.</S>
    <S sid="402" ssid="97">.</S>
    <S sid="403" ssid="98">, Ln according to: We compare the performance of joint re-ranking models and local models.</S>
    <S sid="404" ssid="99">We used n = 10 joint assignments for training re-ranking models, and n = 15 for testing.</S>
    <S sid="405" ssid="100">The weight &#945; of the local model was set to 1.</S>
    <S sid="406" ssid="101">Using different numbers of joint assignments in training and testing is in general not ideal, but due to memory requirements, we could not experiment with larger values of n for training.</S>
    <S sid="407" ssid="102">Figure 10 shows the summary performance of the local model (LOCAL), repeated from earlier figures, a joint model using only local features (JOINTLOCAL), a joint model using local + whole label sequence features (LABELSEQ), and a joint model using all described types of features (ALLJOINT).</S>
    <S sid="408" ssid="103">The evaluation is on gold-standard parse trees.</S>
    <S sid="409" ssid="104">In addition to performance measures, the figure shows the number of binary features included in the model.</S>
    <S sid="410" ssid="105">The number of features is a measure of the complexity of the hypothesis space of the parametric model.</S>
    <S sid="411" ssid="106">We can see that a joint model using only local features outperforms a local model by .5 points of F-Measure.</S>
    <S sid="412" ssid="107">The joint model using local features estimates the feature weights only using the top n consistent assignments, thus making the labels of different nodes non-independent according to the estimation procedure, which may be a cause of the improved performance.</S>
    <S sid="413" ssid="108">Another factor could be that the model JOINTLOCAL is a combination of two models as specified in Equation (4), which may lead to gains (as is usual for classifier combination).</S>
    <S sid="414" ssid="109">The label sequence features added in Model LABELSEQ result in another 1.5 points jump in F-Measure on all arguments.</S>
    <S sid="415" ssid="110">An additional .8 gain results from the inclusion of syntactic&#8211;semantic and repetition features.</S>
    <S sid="416" ssid="111">The error reduction of model ALLJOINT Performance of local and joint models on ID&amp;CLS on Section 23, using gold-standard parse trees.</S>
    <S sid="417" ssid="112">The number of features of each model is shown in thousands. over the local model is 36.8% in CORE arguments F-Measure, 33.3% in CORE arguments whole frame accuracy, 24.1% in ALL arguments F-Measure, and 21.7% in ALL arguments whole frame accuracy.</S>
    <S sid="418" ssid="113">All differences in ALL arguments F-Measure are statistically significant according to a paired Wilcoxon signed rank test.</S>
    <S sid="419" ssid="114">JOINTLOCAL is significantly better than LOCAL (p &lt; .001), LABELSEQ is significantly better than JOINTLOCAL (p &lt; .001), and ALLJOINT is significantly better than LABELSEQ (p &lt; .001).</S>
    <S sid="420" ssid="115">We performed the Wilcoxon signed rank test on per-proposition ALL arguments F-Measure for all models.</S>
    <S sid="421" ssid="116">We also note that the joint models have fewer features than the local model.</S>
    <S sid="422" ssid="117">This is due to the fact that the local model has seen many more negative examples and therefore more unique features.</S>
    <S sid="423" ssid="118">The joint features are not very numerous compared to the local features in the joint models.</S>
    <S sid="424" ssid="119">The ALLJOINT model has around 30% more features than the JOINTLOCAL model.</S>
    <S sid="425" ssid="120">These experiments showed that the label sequence features were very useful, especially on CORE arguments, increasing the F-Measure on these arguments by two points when added to the JOINTLOCAL model.</S>
    <S sid="426" ssid="121">This shows that even though the local model is optimized to use a large set of features and achieve state-of-the-art performance, it is still advantageous to model the joint information in the sequence of labels in a predicate&#8217;s argument frame.</S>
    <S sid="427" ssid="122">Additionally, the joint syntactic&#8211;semantic features improved performance further, showing that when predicting the label of an argument, it is useful to condition on the features of other arguments, in addition to their labels.</S>
    <S sid="428" ssid="123">A more detailed analysis of the results obtained by the joint model ALLJOINT is given in Figure 11(a) (Summary results), and the two confusion matrices in Figures 11(b) and 11(c), which display the number of errors of each type that the model made.</S>
    <S sid="429" ssid="124">The first confusion matrix concentrates on CORE arguments and merges all modifying argument labels into a single ARGM label.</S>
    <S sid="430" ssid="125">The second confusion matrix concentrates on confusions among modifying arguments.</S>
    <S sid="431" ssid="126">This figure can be compared to Figure 7, which summarizes the results for the local model in the same form.</S>
    <S sid="432" ssid="127">The biggest differences are in the performance on CORE arguments, which can be seen by comparing the confusion matrices in Figures 7(b) and 11(b).</S>
    <S sid="433" ssid="128">The F-Measure on each of the core argument labels has increased by at least three points: the F-Measure on ARG2 by 5.7 points, and the F-Measure on ARG3 by eight points.</S>
    <S sid="434" ssid="129">The confusions of core argument labels with NONE have gone down significantly, and also there is a large decrease in the confusions of NONE with ARG1.</S>
    <S sid="435" ssid="130">There is generally a slight increase in F-Measure on modifier labels as well, but the performance on some of the modifier labels has gone down.</S>
    <S sid="436" ssid="131">This makes sense because our joint features are targeted at capturing the dependencies among core arguments.</S>
    <S sid="437" ssid="132">There may be useful regularities for modifier arguments as well, but capturing them may require different joint feature templates.</S>
    <S sid="438" ssid="133">Figure 12 lists the frequency with which each of the top k assignments from the LOCAL model was ranked first by the re-ranking model ALLJOINT.</S>
    <S sid="439" ssid="134">For example, for 84.1% of the propositions, the re-ranking model chose the same assignment that the LOCAL model would have chosen.</S>
    <S sid="440" ssid="135">The second best assignment according to the LOCAL model was promoted to first 8.6% of the time.</S>
    <S sid="441" ssid="136">The figure shows statistics for the top ten assignments only.</S>
    <S sid="442" ssid="137">The rest of the assignments, ranked 11 through 15, were chosen as best by the re-ranking model for a total of 0.3% of the propositions.</S>
    <S sid="443" ssid="138">The labeling of the tree in Figure 9 is a specific example of the kind of errors fixed by the joint models.</S>
    <S sid="444" ssid="139">The local classifier labeled the first argument in the tree as ARG0 instead of ARG1, probably because an ARG0 label is more likely for the subject position.</S>
  </SECTION>
  <SECTION title="6." number="8">
    <S sid="445" ssid="1">We now evaluate our models when trained and tested using automatic parses produced by Charniak&#8217;s parser.</S>
    <S sid="446" ssid="2">The Propbank training set Sections 2&#8211;21 is also the training set of the parser.</S>
    <S sid="447" ssid="3">The performance of the parser is therefore better on the training set.</S>
    <S sid="448" ssid="4">When the constituents of an argument do not have corresponding constituents in an automatically produced parse tree, it will be very hard for a model to get the semantic role labeling correct.</S>
    <S sid="449" ssid="5">However, this is not impossible and systems which are more robust to parser error have been proposed (Pradhan et al. 2005; M`arquez et al.</S>
    <S sid="450" ssid="6">2005).</S>
    <S sid="451" ssid="7">Our system can also theoretically guess the correct set of words by labeling a set of constituents that cover Percentage of test set propositions for which each of the top ten assignments from the Local model was selected as best by the joint model AllJoint.</S>
    <S sid="452" ssid="8">Percentage of argument constituents that are not present in the automatic parses of Charniak&#8217;s parser.</S>
    <S sid="453" ssid="9">Constituents shows the percentage of missing constituents and Propositions shows the percentage of propositions that have missing constituents. the argument words, but we found that this rarely happens in practice.</S>
    <S sid="454" ssid="10">Figure 13 shows the percentage of argument constituents that are missing in the automatic parse trees produced by Charniak&#8217;s parser.</S>
    <S sid="455" ssid="11">We can see that the percentage of missing constituents is quite high.</S>
    <S sid="456" ssid="12">We report local and joint model results in Figures 14(a) and 14(b), respectively.</S>
    <S sid="457" ssid="13">As for gold-standard parses, we test on all arguments regardless of whether they correspond to constituents that have been recovered by the parser and use the same measures detailed in Section 3.2.</S>
    <S sid="458" ssid="14">We also compare the confusion matrices for the local and joint models, ignoring the confusions among modifier argument labels (COARSEARGM setting) in Figure 15.</S>
    <S sid="459" ssid="15">The error reduction of the joint over the local model is 10.3% in CORE arguments F-Measure and 8.3% in ALL arguments F-Measure.</S>
    <S sid="460" ssid="16">Semantic role labeling is very sensitive to the correctness of the given parse tree, as the results show.</S>
    <S sid="461" ssid="17">If an argument does not correspond to any constituent in a parse tree, or a constituent exists but is not attached or labeled correctly, our model will have a very hard time guessing the correct labeling.</S>
    <S sid="462" ssid="18">Thus, if the syntactic parser makes errors, these errors influence directly the semantic role labeling system.</S>
    <S sid="463" ssid="19">The theoretically correct way to propagate the uncertainty of the syntactic parser is to consider (sum over) multiple possible parse trees, weighted by their likelihood.</S>
    <S sid="464" ssid="20">In Finkel, Manning, and Ng (2006), this is approximated by sampling parse trees.</S>
    <S sid="465" ssid="21">We implement this idea by an argmax approximation, using the top k parse trees from the parser of Charniak (2000).</S>
    <S sid="466" ssid="22">We use these alternative parses as follows: Suppose t1, ... , tk are trees for sentence s with probabilities P(ti|s) given by the parser.</S>
    <S sid="467" ssid="23">Then for a fixed predicate v, let Li denote the best joint labeling of tree ti, with score scoreSRL(Lilti) according to our final joint model.</S>
    <S sid="468" ssid="24">Then we choose the labeling L which maximizes This method of using multiple parse trees is very simple to implement and factors in the uncertainty of the parser to some extent.</S>
    <S sid="469" ssid="25">However, according to this method (due to the argmax operation) we are choosing a single parse and a complete semantic frame derived from that parse.</S>
    <S sid="470" ssid="26">Other methods are able to derive different arguments of the semantic frame from different syntactic annotations which may make them more robust (M`arquez et al. 2005; Pradhan, Ward et al.</S>
    <S sid="471" ssid="27">2005; Punyakanok, Roth, and Yih 2005).</S>
    <S sid="472" ssid="28">Figure 16 shows summary results for the test set when using the top ten parses and the joint model.</S>
    <S sid="473" ssid="29">The weighting parameter for the parser probabilities was R = 1.</S>
    <S sid="474" ssid="30">We did not experiment extensively with different values of R. Preliminary experiments showed that considering 15 parses was a bit better, and considering the top 20 was a bit worse.</S>
    <S sid="475" ssid="31">The CoNLL 2005 data is derived from Propbank version I, which is the first official release in 2005, whereas the results we have been reporting in the previous sections used the pre-final February 2004 data.</S>
    <S sid="476" ssid="32">Using the CoNLL 2005 evaluation standard ensures that results obtained by different groups are evaluated in exactly the same way.</S>
    <S sid="477" ssid="33">In Performance of the joint model using the top ten parses from Charniak&#8217;s parser.</S>
    <S sid="478" ssid="34">Results are on Section 23.</S>
    <S sid="479" ssid="35">Propbank I, there have been several changes in the annotation conventions, as well as error fixes and addition of new propositions.</S>
    <S sid="480" ssid="36">There was also a change in the way PP arguments are annotated: In the February 2004 data some PP arguments are annotated at the head NP child, but in Propbank I all PP arguments are annotated at the PP nodes.</S>
    <S sid="481" ssid="37">In order to achieve maximal performance with respect to these annotations, it would probably be best to change the feature definitions to account for the changes.</S>
    <S sid="482" ssid="38">However, we did no adaptation of the features.</S>
    <S sid="483" ssid="39">The training set consists of the annotations in Sections 2 to 21, the development set is section 24 (Devset), and one of the test sets is section 23 (Test WSJ).</S>
    <S sid="484" ssid="40">The other test set is from the Brown corpus (Test Brown).</S>
    <S sid="485" ssid="41">The CoNLL annotations distinguish referring arguments, of the form R-ARGX, as discussed in Section 3.</S>
    <S sid="486" ssid="42">Our approach to dealing with referring arguments and deciding when multiple identically labeled constituents are part of the same argument was to label constituents with only the set of argument labels and NONE and then map some of these labels into referring or continuation labels.</S>
    <S sid="487" ssid="43">We converted an ARGX into a R-ARGX if and only if the label of the constituent began with &#8220;WH&#8221;.</S>
    <S sid="488" ssid="44">The rule for deciding when to add continuation labels was the same as for our systems for the February 2004 data described in Section 4.3: A constituent label becomes continuing if and only if it is a core argument label and there is another constituent with the same core argument label to the left.</S>
    <S sid="489" ssid="45">Therefore, for the CoNLL 2005 shared task we employ the same semantic role labeling system, just using a different post-processing rule to map to CoNLL-style labelings of sets of words.</S>
    <S sid="490" ssid="46">We tested the upper bound in performance due to our conversion scheme in the following way: Take the gold-standard CoNLL annotations for the development set (including referring and continuing labels), convert these to basic argument labels of the form ARGX, then convert the resulting labeling to CoNLL-style labeling using our rules to recover the referring and continuing annotations.</S>
    <S sid="491" ssid="47">The F-Measure obtained was 99.0.</S>
    <S sid="492" ssid="48">Figure 17 shows the performance of the local and joint model on one of the CoNLL test sets&#8212;Test WSJ (Section 23)&#8212;when using gold-standard parse trees.</S>
    <S sid="493" ssid="49">Performance on gold-standard parse trees was not measured in the CoNLL 2005 shared task, but we report it here to provide a basis for comparison with the results of other researchers.</S>
    <S sid="494" ssid="50">Next we present results using Charniak&#8217;s automatic parses on the development and two test sets.</S>
    <S sid="495" ssid="51">We present results for the local and joint models using the maxscoring Charniak parse tree.</S>
    <S sid="496" ssid="52">Additionally, we report results for the joint model using the top five Charniak parse trees according to the algorithm described in Section 6.1.</S>
    <S sid="497" ssid="53">The performance measures reported here are higher than the results of our submission in the CoNLL 2005 shared task (Haghighi, Toutanova, and Manning 2005), because of two changes.</S>
    <S sid="498" ssid="54">One was changing the rule that produces continuing arguments to only add continuation labels to core argument labels; in the previous version the rule added continuation labels to all repeated labels.</S>
    <S sid="499" ssid="55">Another was fixing a bug in the way the sentences were passed in as input to Charniak&#8217;s parser, leading to incorrect analyses of forward quotes.8 We first present results of our local and joint model using the parses provided as part of the CoNLL 2005 data (and having wrong forward quotes) in Figure 18.</S>
    <S sid="500" ssid="56">We then report results from the same local and joint model, and the joint model using the top five Charniak parses, where the parses have correct representation of the forward quotes in Figure 19.</S>
    <S sid="501" ssid="57">For these results we used the version of the Charniak parser from 4 May 2005.</S>
    <S sid="502" ssid="58">The results were very similar to the results we obtained with the version from 18 March 2005.</S>
    <S sid="503" ssid="59">We did not experiment with the new re-ranking model of Charniak and Johnson (2005), even though it improves upon Charniak (2000) significantly.</S>
    <S sid="504" ssid="60">For comparison, the system we submitted to CoNLL 2005 had an F-Measure of 78.45 on the WSJ Test set.</S>
    <S sid="505" ssid="61">The winning system (Punyakanok, Roth, and Yih 2005) had an F-Measure of 79.44 and our current system has an F-Measure of 80.32.</S>
    <S sid="506" ssid="62">For the Brown Test set, our submitted version had an F-Measure of 67.71, the winning system had 67.75, and our current system has 68.81.</S>
    <S sid="507" ssid="63">Figure 20 shows the per-label performance of our joint model using the top five Charniak parse trees on the Test WSJ test set.</S>
    <S sid="508" ssid="64">The columns show the Precision, Recall, F-Measure, and the total number of arguments for each label.</S>
  </SECTION>
  <SECTION title="7." number="9">
    <S sid="509" ssid="1">In accord with standard linguistic assumptions, we have shown that there are substantial gains to be had by jointly modeling the argument frames of verbs.</S>
    <S sid="510" ssid="2">This is especially true when we model the dependencies with discriminative models capable of incorporating non-local features.</S>
    <S sid="511" ssid="3">We incorporated joint information by using two types of features: features of the complete sequence of argument labels and features modeling dependencies between the labels of arguments and syntactic features of other arguments.</S>
    <S sid="512" ssid="4">We showed that both types of features yielded significant performance gains over a state-of-the-art local model.</S>
    <S sid="513" ssid="5">For further improving performance in the presence of perfect syntactic parses, we see at least three promising avenues for improvement.</S>
    <S sid="514" ssid="6">First, one could improve the identification of argument nodes, by better handling of long-distance dependencies; for example, by incorporating models which recover the trace and null element information in Penn Treebank parse trees, as in Levy and Manning (2004).</S>
    <S sid="515" ssid="7">Second, it may be possible to improve the accuracy on modifier labels, by enhancing the knowledge about the semantic characteristics of specific words and phrases, such as by improving lexical statistics; for instance, our performance on ARGM-TMP roles is rather worse than that of some other groups.</S>
    <S sid="516" ssid="8">Finally, it is worth exploring alternative handling of multiconstituent arguments; our current model uses a simple rule in a post-processing step to decide which constituents given the same label are part of the same argument.</S>
    <S sid="517" ssid="9">This could be done more intelligently by the machine learning model.</S>
    <S sid="518" ssid="10">Because perfect syntactic parsers do not yet exist and the major bottleneck to the performance of current semantic role labeling systems is syntactic parser performance, the more important question is how to improve performance in the presence of parser errors.</S>
    <S sid="519" ssid="11">We explored a simple approach of choosing from among the top k parses from Charniak&#8217;s parser, which resulted in an improvement.</S>
    <S sid="520" ssid="12">Other methods have also been proposed, as we discussed in Section 2 (M`arquez et al. 2005; Pradhan, Ward et al.</S>
    <S sid="521" ssid="13">2005; Punyakanok, Roth, and Yih 2005; Yi and Palmer 2005; Finkel, Manning, and Ng 2006).</S>
    <S sid="522" ssid="14">This is a very promising line of research.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="10">
    <S sid="523" ssid="1">This research was carried out while all the authors were at Stanford University.</S>
    <S sid="524" ssid="2">We thank the journal reviewers and the reviewers and audience at ACL 2005 and CoNLL 2005 for their helpful comments.</S>
    <S sid="525" ssid="3">We also thank Dan Jurafsky for his insightful comments and useful discussions.</S>
    <S sid="526" ssid="4">This work was supported in part by the Disruptive Technology Organization (DTO)&#8217;s Advanced Question Answering for Intelligence (AQUAINT) Program.</S>
  </SECTION>
</PAPER>
