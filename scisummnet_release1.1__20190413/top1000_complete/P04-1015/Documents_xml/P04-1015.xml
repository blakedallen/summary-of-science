<PAPER>
  <S sid="0">Incremental Parsing With The Perceptron Algorithm</S>
  <ABSTRACT>
    <S sid="1" ssid="1">This paper describes an incremental parsing approach where parameters are estimated using a variant of the perceptron algorithm.</S>
    <S sid="2" ssid="2">A beam-search algorithm is used during both training and decoding phases of the method.</S>
    <S sid="3" ssid="3">The perceptron approach was implemented with the same feature set as that of an existing generative model (Roark, 2001a), and experimental results show that it gives competitive performance to the generative model on parsing the Penn treebank.</S>
    <S sid="4" ssid="4">We demonstrate that training a perceptron model to combine with the generative model during search provides a 2.1 percent F-measure improvement over the generative model alone, to 88.8 percent.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="5" ssid="1">In statistical approaches to NLP problems such as tagging or parsing, it seems clear that the representation used as input to a learning algorithm is central to the accuracy of an approach.</S>
    <S sid="6" ssid="2">In an ideal world, the designer of a parser or tagger would be free to choose any features which might be useful in discriminating good from bad structures, without concerns about how the features interact with the problems of training (parameter estimation) or decoding (search for the most plausible candidate under the model).</S>
    <S sid="7" ssid="3">To this end, a number of recently proposed methods allow a model to incorporate &#8220;arbitrary&#8221; global features of candidate analyses or parses.</S>
    <S sid="8" ssid="4">Examples of such techniques are Markov Random Fields (Ratnaparkhi et al., 1994; Abney, 1997; Della Pietra et al., 1997; Johnson et al., 1999), and boosting or perceptron approaches to reranking (Freund et al., 1998; Collins, 2000; Collins and Duffy, 2002).</S>
    <S sid="9" ssid="5">A drawback of these approaches is that in the general case, they can require exhaustive enumeration of the set of candidates for each input sentence in both the training and decoding phases'.</S>
    <S sid="10" ssid="6">For example, Johnson et al. (1999) and Riezler et al.</S>
    <S sid="11" ssid="7">(2002) use all parses generated by an LFG parser as input to an MRF approach &#8211; given the level of ambiguity in natural language, this set can presumably become extremely large.</S>
    <S sid="12" ssid="8">Collins (2000) and Collins and Duffy (2002) rerank the top N parses from an existing generative parser, but this kind of approach presupposes that there is an existing baseline model with reasonable performance.</S>
    <S sid="13" ssid="9">Many of these baseline models are themselves used with heuristic search techniques, so that the potential gain through the use of discriminative re-ranking techniques is further dependent on effective search.</S>
    <S sid="14" ssid="10">This paper explores an alternative approach to parsing, based on the perceptron training algorithm introduced in Collins (2002).</S>
    <S sid="15" ssid="11">In this approach the training and decoding problems are very closely related &#8211; the training method decodes training examples in sequence, and makes simple corrective updates to the parameters when errors are made.</S>
    <S sid="16" ssid="12">Thus the main complexity of the method is isolated to the decoding problem.</S>
    <S sid="17" ssid="13">We describe an approach that uses an incremental, left-to-right parser, with beam search, to find the highest scoring analysis under the model.</S>
    <S sid="18" ssid="14">The same search method is used in both training and decoding.</S>
    <S sid="19" ssid="15">We implemented the perceptron approach with the same feature set as that of an existing generative model (Roark, 2001a), and show that the perceptron model gives performance competitive to that of the generative model on parsing the Penn treebank, thus demonstrating that an unnormalized discriminative parsing model can be applied with heuristic search.</S>
    <S sid="20" ssid="16">We also describe several refinements to the training algorithm, and demonstrate their impact on convergence properties of the method.</S>
    <S sid="21" ssid="17">Finally, we describe training the perceptron model with the negative log probability given by the generative model as another feature.</S>
    <S sid="22" ssid="18">This provides the perceptron algorithm with a better starting point, leading to large improvements over using either the generative model or the perceptron algorithm in isolation (the hybrid model achieves 88.8% f-measure on the WSJ treebank, compared to figures of 86.7% and 86.6% for the separate generative and perceptron models).</S>
    <S sid="23" ssid="19">The approach is an extremely simple method for integrating new features into the generative model: essentially all that is needed is a definition of feature-vector representations of entire parse trees, and then the existing parsing algorithms can be used for both training and decoding with the models.</S>
  </SECTION>
  <SECTION title="2 The General Framework" number="2">
    <S sid="24" ssid="1">In this section we describe a general framework &#8211; linear models for NLP &#8211; that could be applied to a diverse range of tasks, including parsing and tagging.</S>
    <S sid="25" ssid="2">We then describe a particular method for parameter estimation, which is a generalization of the perceptron algorithm.</S>
    <S sid="26" ssid="3">Finally, we give an abstract description of an incremental parser, and describe how it can be used with the perceptron algorithm.</S>
    <S sid="27" ssid="4">We follow the framework outlined in Collins (2002; 2004).</S>
    <S sid="28" ssid="5">The task is to learn a mapping from inputs x &#8712; X to outputs y &#8712; Y.</S>
    <S sid="29" ssid="6">For example, X might be a set of sentences, with Y being a set of possible parse trees.</S>
    <S sid="30" ssid="7">We assume: The components GEN, 4) and &#945;&#175; define a mapping from an input x to an output F(x) through where 4)(x, y) &#183; &#945;&#175; is the inner product Es &#945;s4)s(x, y).</S>
    <S sid="31" ssid="8">The learning task is to set the parameter values &#945;&#175; using the training examples as evidence.</S>
    <S sid="32" ssid="9">The decoding algorithm is a method for searching for the arg max in Eq.</S>
    <S sid="33" ssid="10">1.</S>
    <S sid="34" ssid="11">This framework is general enough to encompass several tasks in NLP.</S>
    <S sid="35" ssid="12">In this paper we are interested in parsing, where (xi, yi), GEN, and 4) can be defined as follows: Note that the difficulty of finding the arg max in Eq.</S>
    <S sid="36" ssid="13">1 is dependent on the interaction of GEN and 4).</S>
    <S sid="37" ssid="14">In many cases GEN(x) could grow exponentially with the size of x, making brute force enumeration of the members of GEN(x) intractable.</S>
    <S sid="38" ssid="15">For example, a context-free grammar could easily produce an exponentially growing number of analyses with sentence length.</S>
    <S sid="39" ssid="16">For some representations, such as the &#8220;rule-based&#8221; representation described above, the arg max in the set enumerated by the CFG can be found efficiently, using dynamic programming algorithms, without having to explicitly enumerate all members of GEN(x).</S>
    <S sid="40" ssid="17">However in many cases we may be interested in representations which do not allow efficient dynamic programming solutions.</S>
    <S sid="41" ssid="18">One way around this problem is to adopt a two-pass approach, where GEN(x) is the top N analyses under some initial model, as in the reranking approach of Collins (2000).</S>
    <S sid="42" ssid="19">In the current paper we explore alternatives to reranking approaches, namely heuristic methods for finding the arg max, specifically incremental beam-search strategies related to the parsers of Roark (2001a) and Ratnaparkhi (1999).</S>
    <S sid="43" ssid="20">We now consider the problem of setting the parameters, &#175;&#945;, given training examples (xi, yi).</S>
    <S sid="44" ssid="21">We will briefly review the perceptron algorithm, and its convergence properties &#8211; see Collins (2002) for a full description.</S>
    <S sid="45" ssid="22">The algorithm and theorems are based on the approach to classification problems described in Freund and Schapire (1999).</S>
    <S sid="46" ssid="23">Figure 1 shows the algorithm.</S>
    <S sid="47" ssid="24">Note that the most complex step of the method is finding zi = arg maxz&#8712;GEN(x;) 4)(xi, z)&#183; &#945;&#175; &#8211; and this is precisely the decoding problem.</S>
    <S sid="48" ssid="25">Thus the training algorithm is in principle a simple part of the parser: any system will need a decoding method, and once the decoding algorithm is implemented the training algorithm is relatively straightforward.</S>
    <S sid="49" ssid="26">We will now give a first theorem regarding the convergence of this algorithm.</S>
    <S sid="50" ssid="27">First, we need the following definition: Definition 1 Let GEN(xi) = GEN(xi) &#8722; {yi}.</S>
    <S sid="51" ssid="28">In other words GEN(xi) is the set of incorrect candidates for an example xi.</S>
    <S sid="52" ssid="29">We will say that a training sequence (xi, yi) for i = 1... n is separable with margin S &gt; 0 if there exists some vector U with ||U ||= 1 such that Next, define Ne to be the number of times an error is made by the algorithm in figure 1 &#8211; that is, the number of times that zi =6 yi for some (t, i) pair.</S>
    <S sid="53" ssid="30">We can then state the following theorem (see (Collins, 2002) for a proof): This theorem implies that if there is a parameter vector U which makes zero errors on the training set, then after a finite number of iterations the training algorithm will converge to parameter values with zero training error.</S>
    <S sid="54" ssid="31">A crucial point is that the number of mistakes is independent of the number of candidates for each example Inputs: Training examples (xi, yi) Algorithm: (i.e. the size of GEN(xi) for each i), depending only on the separation of the training data, where separation is defined above.</S>
    <S sid="55" ssid="32">This is important because in many NLP problems GEN(x) can be exponential in the size of the inputs.</S>
    <S sid="56" ssid="33">All of the convergence and generalization results in Collins (2002) depend on notions of separability rather than the size of GEN. Two questions come to mind.</S>
    <S sid="57" ssid="34">First, are there guarantees for the algorithm if the training data is not separable?</S>
    <S sid="58" ssid="35">Second, performance on a training sample is all very well, but what does this guarantee about how well the algorithm generalizes to newly drawn test examples?</S>
    <S sid="59" ssid="36">Freund and Schapire (1999) discuss how the theory for classification problems can be extended to deal with both of these questions; Collins (2002) describes how these results apply to NLP problems.</S>
    <S sid="60" ssid="37">As a final note, following Collins (2002), we used the averaged parameters from the training algorithm in decoding test examples in our experiments.</S>
    <S sid="61" ssid="38">Say &#175;&#945;ti is the parameter vector after the i&#8217;th example is processed on the t&#8217;th pass through the data in the algorithm in figure 1.</S>
    <S sid="62" ssid="39">Then the averaged parameters &#175;&#945;AV G are defined as &#175;&#945;AV G = Ei,t &#175;&#945;ti/NT.</S>
    <S sid="63" ssid="40">Freund and Schapire (1999) originally proposed the averaged parameter method; it was shown to give substantial improvements in accuracy for tagging tasks in Collins (2002).</S>
    <S sid="64" ssid="41">This section gives a description of the basic incremental parsing approach.</S>
    <S sid="65" ssid="42">The input to the parser is a sentence x with length n. A hypothesis is a triple (x, t, i) such that x is the sentence being parsed, t is a partial or full analysis of that sentence, and i is an integer specifying the number of words of the sentence which have been processed.</S>
    <S sid="66" ssid="43">Each full parse for a sentence will have the form (x, t, n).</S>
    <S sid="67" ssid="44">The initial state is (x, 0, 0) where 0 is a &#8220;null&#8221; or empty analysis.</S>
    <S sid="68" ssid="45">We assume an &#8220;advance&#8221; function ADV which takes a hypothesis triple as input, and returns a set of new hypotheses as output.</S>
    <S sid="69" ssid="46">The advance function will absorb another word in the sentence: this means that if the input to ADV is (x, t, i), then each member of ADV((x, t, i)) will have the form (x, t',i+1).</S>
    <S sid="70" ssid="47">Each new analysis t' will be formed by somehow incorporating the i+1&#8217;th word into the previous analysis t. With these definitions in place, we can iteratively define the full set of partial analyses Hi for the first i words of the sentence as H0(x) = {(x, 0, 0)}, and Hi(x) = Uh'EHi&#8722;1(x)ADV(h') for i = 1... n. The full set of parses for a sentence x is then GEN(x) = Hn(x) where n is the length of x.</S>
    <S sid="71" ssid="48">Under this definition GEN(x) can include a huge number of parses, and searching for the highest scoring parse, arg maxhEHn(x) &#934;(h) &#183; &#175;&#945;, will be intractable.</S>
    <S sid="72" ssid="49">For this reason we introduce one additional function, FILTER(H), which takes a set of hypotheses H, and returns a much smaller set of &#8220;filtered&#8221; hypotheses.</S>
    <S sid="73" ssid="50">Typically, FILTER will calculate the score &#934;(h) &#183; &#945;&#175; for each h E H, and then eliminate partial analyses which have low scores under this criterion.</S>
    <S sid="74" ssid="51">For example, a simple version of FILTER would take the top N highest scoring members of H for some constant N. We can then redefine the set of partial analyses as follows (we use .77i(x) to denote the set of filtered partial analyses for the first i words of the sentence): The parsing algorithm returns arg maxhEyn &#934;(h) &#183; &#175;&#945;.</S>
    <S sid="75" ssid="52">Note that this is a heuristic, in that there is no guarantee that this procedure will find the highest scoring parse, arg maxhEHn &#934;(h) &#183; &#175;&#945;.</S>
    <S sid="76" ssid="53">Search errors, where arg maxhEyn &#934;(h) &#183; &#945;&#175; =&#65533; arg maxhEHn &#934;(h) &#183; &#175;&#945;, will create errors in decoding test sentences, and also errors in implementing the perceptron training algorithm in Figure 1.</S>
    <S sid="77" ssid="54">In this paper we give empirical results that suggest that FILTER can be chosen in such a way as to give efficient parsing performance together with high parsing accuracy.</S>
    <S sid="78" ssid="55">The exact implementation of the parser will depend on the definition of partial analyses, of ADV and FILTER, and of the representation &#934;.</S>
    <S sid="79" ssid="56">The next section describes our instantiation of these choices.</S>
  </SECTION>
  <SECTION title="3 A full description of the parsing approach" number="3">
    <S sid="80" ssid="1">The parser is an incremental beam-search parser very similar to the sort described in Roark (2001a; 2004), with some changes in the search strategy to accommodate the perceptron feature weights.</S>
    <S sid="81" ssid="2">We first describe the parsing algorithm, and then move on to the baseline feature set for the perceptron model.</S>
    <S sid="82" ssid="3">The input to the parser is a string wn0 , a grammar G, a mapping &#934; from derivations to feature vectors, and a parameter vector &#175;&#945;.</S>
    <S sid="83" ssid="4">The grammar G = (V, T, S&#8224;, &#175;S, C, B) consists of a set of non-terminal symbols V , a set of terminal symbols T, a start symbol S&#8224; E V , an end-ofconstituent symbol S&#175; E V , a set of &#8220;allowable chains&#8221; C, and a set of &#8220;allowable triples&#8221; B. S&#175; is a special empty non-terminal that marks the end of a constituent.</S>
    <S sid="84" ssid="5">Each chain is a sequence of non-terminals followed by a terminal symbol, for example (S&#8224; &#8594; S &#8594; NP &#8594; NN &#8594; Trash).</S>
    <S sid="85" ssid="6">Each &#8220;allowable triple&#8221; is a tuple (X, Y, Z) where X, Y, Z E V .</S>
    <S sid="86" ssid="7">The triples specify which nonterminals Z are allowed to follow a non-terminal Y under a parent X.</S>
    <S sid="87" ssid="8">For example, the triple (S,NP,VP) specifies that a VP can follow an NP under an S. The triple (NP,NN,&#175;S) would specify that the S&#175; symbol can follow an NN under an NP &#8211; i.e., that the symbol NN is allowed to be the final child of a rule with parent NP The initial state of the parser is the input string alone, wn0 .</S>
    <S sid="88" ssid="9">In absorbing the first word, we add all chains of the form S&#8224; ... , w0.</S>
    <S sid="89" ssid="10">For example, in figure 2 the chain (S&#8224; , S , NP , NN , Trash) is used to construct an analysis for the first word alone.</S>
    <S sid="90" ssid="11">Other chains which start with S&#8224; and end with Trash would give competing analyses for the first word of the string.</S>
    <S sid="91" ssid="12">Figure 2 shows an example of how the next word in a sentence can be incorporated into a partial analysis for the previous words.</S>
    <S sid="92" ssid="13">For any partial analysis there will be a set of potential attachment sites: in the example, the attachment sites are under the NP or the S. There will also be a set of possible chains terminating in the next word &#8211; there are three in the example.</S>
    <S sid="93" ssid="14">Each chain could potentially be attached at each attachment site, giving 6 ways of incorporating the next word in the example.</S>
    <S sid="94" ssid="15">For illustration, assume that the set B is {(S,NP,VP), (NP,NN,NN), (NP,NN,&#175;S), (S,NP,VP)}.</S>
    <S sid="95" ssid="16">Then some of the 6 possible attachments may be disallowed because they create triples that are not in the set B.</S>
    <S sid="96" ssid="17">For example, in figure 2 attaching either of the VP chains under the NP is disallowed because the triple (NP,NN,VP) is not in B.</S>
    <S sid="97" ssid="18">Similarly, attaching the NN chain under the S will be disallowed if the triple (S,NP,NN) is not in B.</S>
    <S sid="98" ssid="19">In contrast, adjoining (NN , can) under the NP creates a single triple, (NP,NN,NN), which is allowed.</S>
    <S sid="99" ssid="20">Adjoining either of the VP chains under the S creates two triples, (S,NP,VP) and (NP,NN,&#175;S), which are both in the set B.</S>
    <S sid="100" ssid="21">Note that the &#8220;allowable chains&#8221; in our grammar are what Costa et al. (2001) call &#8220;connection paths&#8221; from the partial parse to the next word.</S>
    <S sid="101" ssid="22">It can be shown that the method is equivalent to parsing with a transformed context-free grammar (a first-order &#8220;Markov&#8221; grammar) &#8211; for brevity we omit the details here.</S>
    <S sid="102" ssid="23">In this way, given a set of candidates .77i(x) for the first i words of the string, we can generate a set of candidates Table 1: Left-child chain type counts (of length &gt; 2) for sections of the Wall St. Journal Treebank, and out-ofvocabulary (OOV) rate on the held-out corpus. for the first i + 1 words, Uh1EY-,(x)ADV(h'), where the ADV function uses the grammar as described above.</S>
    <S sid="103" ssid="24">We then calculate &#934;(h)&#183; &#945;&#175; for all of these partial hypotheses, and rank the set from best to worst.</S>
    <S sid="104" ssid="25">A FILTER function is then applied to this ranked set to give .77i+1.</S>
    <S sid="105" ssid="26">Let hk be the kth ranked hypothesis in Hi+1(x).</S>
    <S sid="106" ssid="27">Then hk E .77i+1 if and only if &#934;(hk) &#183; &#945;&#175; &gt; &#952;k.</S>
    <S sid="107" ssid="28">In our case, we parameterize the calculation of &#952;k with y as follows: The problem with using left-child chains is limiting them in number.</S>
    <S sid="108" ssid="29">With a left-recursive grammar, of course, the set of all possible left-child chains is infinite.</S>
    <S sid="109" ssid="30">We use two techniques to reduce the number of left-child chains: first, we remove some (but not all) of the recursion from the grammar through a tree transform; next, we limit the left-child chains consisting of more than two non-terminal categories to those actually observed in the training data more than once.</S>
    <S sid="110" ssid="31">Left-child chains of length less than or equal to two are all those observed in training data.</S>
    <S sid="111" ssid="32">As a practical matter, the set of leftchild chains for a terminal x is taken to be the union of the sets of left-child chains for all pre-terminal part-ofspeech (POS) tags T for x.</S>
    <S sid="112" ssid="33">Before inducing the left-child chains and allowable triples from the treebank, the trees are transformed with a selective left-corner transformation (Johnson and Roark, 2000) that has been flattened as presented in Roark (2001b).</S>
    <S sid="113" ssid="34">This transform is only applied to left-recursive productions, i.e. productions of the form A , Ay.</S>
    <S sid="114" ssid="35">The transformed trees look as in figure 3.</S>
    <S sid="115" ssid="36">The transform has the benefit of dramatically reducing the number of left-child chains, without unduly disrupting the immediate dominance relationships that provide features for the model.</S>
    <S sid="116" ssid="37">The parse trees that are returned by the parser are then de-transformed to the original form of the grammar for evaluation2.</S>
    <S sid="117" ssid="38">Table 1 presents the number of left-child chains of length greater than 2 in sections 2-21 and 24 of the Penn Wall St. Journal Treebank, both with and without the flattened selective left-corner transformation (FSLC), for gold-standard part-of-speech (POS) tags and automatically tagged POS tags.</S>
    <S sid="118" ssid="39">When the FSLC has been applied and the set is restricted to those occurring more than once ZSee Johnson (1998) for a presentation of the transform/detransform paradigm in parsing.</S>
    <S sid="119" ssid="40">Table 2: Baseline feature set.</S>
    <S sid="120" ssid="41">Features F0 &#8722; F10 fire at non-terminal nodes.</S>
    <S sid="121" ssid="42">Features F0, F11 &#8722; F15 fire at terminal nodes. in the training corpus, we can reduce the total number of left-child chains of length greater than 2 by half, while leaving the number of words in the held-out corpus with an unobserved left-child chain (out-of-vocabulary rate &#8211; OOV) to just one in every thousand words.</S>
    <S sid="122" ssid="43">For this paper, we wanted to compare the results of a perceptron model with a generative model for a comparable feature set.</S>
    <S sid="123" ssid="44">Unlike in Roark (2001a; 2004), there is no look-ahead statistic, so we modified the feature set from those papers to explicitly include the lexical item and POS tag of the next word.</S>
    <S sid="124" ssid="45">Otherwise the features are basically the same as in those papers.</S>
    <S sid="125" ssid="46">We then built a generative model with this feature set and the same tree transform, for use with the beam-search parser from Roark (2004) to compare against our baseline perceptron model.</S>
    <S sid="126" ssid="47">To concisely present the baseline feature set, let us establish a notation.</S>
    <S sid="127" ssid="48">Features will fire whenever a new node is built in the tree.</S>
    <S sid="128" ssid="49">The features are labels from the left-context, i.e. the already built part of the tree.</S>
    <S sid="129" ssid="50">All of the labels that we will include in our feature sets are i levels above the current node in the tree, and j nodes to the left, which we will denote Lij.</S>
    <S sid="130" ssid="51">Hence, L00 is the node label itself; L10 is the label of parent of the current node; L01 is the label of the sibling of the node, immediately to its left; L11 is the label of the sibling of the parent node, etc.</S>
    <S sid="131" ssid="52">We also include: the lexical head of the current constituent (CL); the c-commanding lexical head (CC) and its POS (CCP); and the look-ahead word (LK) and its POS (LKP).</S>
    <S sid="132" ssid="53">All of these features are discussed at more length in the citations above.</S>
    <S sid="133" ssid="54">Table 2 presents the baseline feature set.</S>
    <S sid="134" ssid="55">In addition to the baseline feature set, we will also present results using features that would be more difficult to embed in a generative model.</S>
    <S sid="135" ssid="56">We included some punctuation-oriented features, which included (i) a Boolean feature indicating whether the final punctuation is a question mark or not; (ii) the POS label of the word after the current look-ahead, if the current lookahead is punctuation or a coordinating conjunction; and (iii) a Boolean feature indicating whether the look-ahead is punctuation or not, that fires when the category immediately to the left of the current position is immediately preceded by punctuation.</S>
  </SECTION>
  <SECTION title="4 Refinements to the Training Algorithm" number="4">
    <S sid="136" ssid="1">This section describes two modifications to the &#8220;basic&#8221; training algorithm in figure 1.</S>
    <S sid="137" ssid="2">Figure 4 shows a modified algorithm for parameter estimation.</S>
    <S sid="138" ssid="3">The input to the function is a gold standard parse, together with a set of candidates F generated by the incremental parser.</S>
    <S sid="139" ssid="4">There are two steps.</S>
    <S sid="140" ssid="5">First, the model is updated as usual with the current example, which is then added to a cache of examples.</S>
    <S sid="141" ssid="6">Second, the method repeatedly iterates over the cache, updating the model at each cached example if the gold standard parse is not the best scoring parse from among the stored candidates for that example.</S>
    <S sid="142" ssid="7">In our experiments, the cache was restricted to contain the parses from up to N previously processed sentences, where N was set to be the size of the training set.</S>
    <S sid="143" ssid="8">The motivation for these changes is primarily efficiency.</S>
    <S sid="144" ssid="9">One way to think about the algorithms in this paper is as methods for finding parameter values that satisfy a set of linear constraints &#8211; one constraint for each incorrect parse in training data.</S>
    <S sid="145" ssid="10">The incremental parser is Input: A gold-standard parse = g for sentence k of N. A set of candidate parses T. Current parameters &#175;&#945;.</S>
    <S sid="146" ssid="11">A Cache of triples (gj, Tj, cj) for j = 1... N where each gj is a previously generated gold standard parse, Tj is a previously generated set of candidate parses, and cj is a counter of the number of times that &#945;&#175; has been updated due to this particular triple.</S>
    <S sid="147" ssid="12">Parameters T1 and T2 controlling the number of iterations below.</S>
    <S sid="148" ssid="13">In our experiments, T1 = 5 and T2 = 50.</S>
    <S sid="149" ssid="14">Initialize the Cache to include, for j = 1... N, (gj, 0, T2).</S>
    <S sid="150" ssid="15">Calculate z = arg maxtEY &#934;(t) &#945;&#175;Fort = 1... T1, j = 1... N If (z =&#65533; g) then &#945;&#175; = &#945;&#175; + &#934;(g) &#8722; &#934;(z) If cj &lt; T2 then Set the kth triple in the Cache to (g, T, 0) Calculate z = arg maxtEY,f &#934;(t) &#945;&#175; a method for dynamically generating constraints (i.e. incorrect parses) which are violated, or close to being violated, under the current parameter settings.</S>
    <S sid="151" ssid="16">The basic algorithm in Figure 1 is extremely wasteful with the generated constraints, in that it only looks at one constraint on each sentence (the arg max), and it ignores constraints implied by previously parsed sentences.</S>
    <S sid="152" ssid="17">This is inefficient because the generation of constraints (i.e., parsing an input sentence), is computationally quite demanding.</S>
    <S sid="153" ssid="18">More formally, it can be shown that the algorithm in figure 4 also has the upper bound in theorem 1 on the number of parameter updates performed.</S>
    <S sid="154" ssid="19">If the cost of steps 1 and 2 of the method are negligible compared to the cost of parsing a sentence, then the refined algorithm will certainly converge no more slowly than the basic algorithm, and may well converge more quickly.</S>
    <S sid="155" ssid="20">As a final note, we used the parameters T1 and T2 to limit the number of passes over examples, the aim being to prevent repeated updates based on outlier examples which are not separable.</S>
    <S sid="156" ssid="21">As before, define yi to be the gold standard parse for the i&#8217;th sentence, and also define yji to be the partial analysis under the gold-standard parse for the first j words of the i&#8217;th sentence.</S>
    <S sid="157" ssid="22">Then if yji V Tj(xi) a search error has been made, and there is no possibility of the gold standard parse yi being in the final set of parses, Tn(xi).</S>
    <S sid="158" ssid="23">We call the following modification to the parsing algorithm during training &#8220;early update&#8221;: if yji V Tj(xi), exit the parsing process, pass yji , Tj(xi) to the parameter estimation method, and move on to the next string in the training set.</S>
    <S sid="159" ssid="24">Intuitively, the motivation behind this is clear.</S>
    <S sid="160" ssid="25">It makes sense to make a correction to the parameter values at the point that a search error has been made, rather than allowing the parser to continue to the end of the sentence.</S>
    <S sid="161" ssid="26">This is likely to lead to less noisy input to the parameter estimation algorithm; and early update will also improve efficiency, as at the early stages of training the parser will frequently give up after a small proportion of each sentence is processed.</S>
    <S sid="162" ssid="27">It is more difficult to justify from a formal point of view, we leave this to future work.</S>
    <S sid="163" ssid="28">Figure 5 shows the convergence of the training algorithm with neither of the two refinements presented; with just early update; and with both.</S>
    <S sid="164" ssid="29">Early update makes Number of passes over training data an enormous difference in the quality of the resulting model; repeated use of examples gives a small improvement, mainly in recall.</S>
  </SECTION>
  <SECTION title="5 Empirical results" number="5">
    <S sid="165" ssid="1">The parsing models were trained and tested on treebanks from the Penn Wall St. Journal Treebank: sections 2-21 were kept training data; section 24 was held-out development data; and section 23 was for evaluation.</S>
    <S sid="166" ssid="2">After each pass over the training data, the averaged perceptron model was scored on the development data, and the best performing model was used for test evaluation.</S>
    <S sid="167" ssid="3">For this paper, we used POS tags that were provided either by the Treebank itself (gold standard tags) or by the perceptron POS tagger3 presented in Collins (2002).</S>
    <S sid="168" ssid="4">The former gives us an upper bound on the improvement that we might expect if we integrated the POS tagging with the parsing.</S>
    <S sid="169" ssid="5">Table 3 shows results on section 23, when either goldstandard or POS-tagger tags are provided to the parser4.</S>
    <S sid="170" ssid="6">With the base features, the generative model outperforms the perceptron parser by between a half and one point, but with the additional punctuation features, the perceptron model matches the generative model performance.</S>
    <S sid="171" ssid="7">Of course, using the generative model and using the perceptron algorithm are not necessarily mutually exclusive.</S>
    <S sid="172" ssid="8">Another training scenario would be to include the generative model score as another feature, with some weight in the linear model learned by the perceptron algorithm.</S>
    <S sid="173" ssid="9">This sort of scenario was used in Roark et al. (2004) for training an n-gram language model using the perceptron algorithm.</S>
    <S sid="174" ssid="10">We follow that paper in fixing the weight of the generative model, rather than learning the weight along the the weights of the other perceptron features.</S>
    <S sid="175" ssid="11">The value of the weight was empirically optimized on the held-out set by performing trials with several values.</S>
    <S sid="176" ssid="12">Our optimal value was 10.</S>
    <S sid="177" ssid="13">In order to train this model, we had to provide generative model scores for strings in the training set.</S>
    <S sid="178" ssid="14">Of course, to be similar to the testing conditions, we cannot use the standard generative model trained on every sentence, since then the generative score would be from a model that had already seen that string in the training data.</S>
    <S sid="179" ssid="15">To control for this, we built ten generative models, each trained on 90 percent of the training data, and used each of the ten to score the remaining 10 percent that was not seen in that training set.</S>
    <S sid="180" ssid="16">For the held-out and testing conditions, we used the generative model trained on all of sections 2-21.</S>
    <S sid="181" ssid="17">In table 4 we present the results of including the generative model score along with the other perceptron features, just for the run with POS-tagger tags.</S>
    <S sid="182" ssid="18">The generative model score (negative log probability) effectively provides a much better initial starting point for the perceptron algorithm.</S>
    <S sid="183" ssid="19">The resulting F-measure on section 23 is 2.1 percent higher than either the generative model or perceptron-trained model used in isolation.</S>
  </SECTION>
  <SECTION title="6 Conclusions" number="6">
    <S sid="184" ssid="1">In this paper we have presented a discriminative training approach, based on the perceptron algorithm with a couple of effective refinements, that provides a model capable of effective heuristic search over a very difficult search space.</S>
    <S sid="185" ssid="2">In such an approach, the unnormalized discriminative parsing model can be applied without either cluding labeled precision (LP), labeled recall (LR), and F-measure an external model to present it with candidates, or potentially expensive dynamic programming.</S>
    <S sid="186" ssid="3">When the training algorithm is provided the generative model scores as an additional feature, the resulting parser is quite competitive on this task.</S>
    <S sid="187" ssid="4">The improvement that was derived from the additional punctuation features demonstrates the flexibility of the approach in incorporating novel features in the model.</S>
    <S sid="188" ssid="5">Future research will look in two directions.</S>
    <S sid="189" ssid="6">First, we will look to include more useful features that are difficult for a generative model to include.</S>
    <S sid="190" ssid="7">This paper was intended to compare search with the generative model and the perceptron model with roughly similar feature sets.</S>
    <S sid="191" ssid="8">Much improvement could potentially be had by looking for other features that could improve the models.</S>
    <S sid="192" ssid="9">Secondly, combining with the generative model can be done in several ways.</S>
    <S sid="193" ssid="10">Some of the constraints on the search technique that were required in the absence of the generative model can be relaxed if the generative model score is included as another feature.</S>
    <S sid="194" ssid="11">In the current paper, the generative score was simply added as another feature.</S>
    <S sid="195" ssid="12">Another approach might be to use the generative model to produce candidates at a word, then assign perceptron features for those candidates.</S>
    <S sid="196" ssid="13">Such variants deserve investigation.</S>
    <S sid="197" ssid="14">Overall, these results show much promise in the use of discriminative learning techniques such as the perceptron algorithm to help perform heuristic search in difficult domains such as statistical parsing.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="7">
    <S sid="198" ssid="1">The work by Michael Collins was supported by the National Science Foundation under Grant No.</S>
    <S sid="199" ssid="2">0347631.</S>
  </SECTION>
</PAPER>
