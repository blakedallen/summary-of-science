<PAPER>
  <S sid="0">Three Generative Lexicalized Models For Statistical Parsing</S>
  <ABSTRACT>
    <S sid="1" ssid="1">In this paper we first propose a new statistical parsing model, which is a generative model of lexicalised context-free grammar.</S>
    <S sid="2" ssid="2">We then extend the model to include a probabilistic treatment of both subcategorisation and wh-movement.</S>
    <S sid="3" ssid="3">Results on Wall Street Journal text show that the parser performs at 88.1/87.5% constituent precision/recall, an average improvement of 2.3% over (Collins 96).</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="4" ssid="1">Generative models of syntax have been central in linguistics since they were introduced in (Chomsky 57).</S>
    <S sid="5" ssid="2">Each sentence-tree pair (S, T) in a language has an associated top-down derivation consisting of a sequence of rule applications of a grammar.</S>
    <S sid="6" ssid="3">These models can be extended to be statistical by defining probability distributions at points of non-determinism in the derivations, thereby assigning a probability 'P(S,T) to each (S, T) pair.</S>
    <S sid="7" ssid="4">Probabilistic context free grammar (Booth and Thompson 73) was an early example of a statistical grammar.</S>
    <S sid="8" ssid="5">A PCFG can be lexicalised by associating a headword with each non-terminal in a parse tree; thus far, (Magerman 95; Jelinek et al. 94) and (Collins 96), which both make heavy use of lexical information, have reported the best statistical parsing performance on Wall Street Journal text.</S>
    <S sid="9" ssid="6">Neither of these models is generative, instead they both estimate 'P(T 1 S) directly.</S>
    <S sid="10" ssid="7">This paper proposes three new parsing models.</S>
    <S sid="11" ssid="8">Model 1 is essentially a generative version of the model described in (Collins 96).</S>
    <S sid="12" ssid="9">In Model 2, we extend the parser to make the complement/adjunct distinction by adding probabilities over subcategorisation frames for head-words.</S>
    <S sid="13" ssid="10">In Model 3 we give a probabilistic treatment of wh-movement, which is derived from the analysis given in Generalized Phrase Structure Grammar (Gazdar et al. 95).</S>
    <S sid="14" ssid="11">The work makes two advances over previous models: First, Model 1 performs significantly better than (Collins 96), and Models 2 and 3 give further improvements &#8212; our final results are 88.1/87.5% constituent precision/recall, an average improvement of 2.3% over (Collins 96).</S>
    <S sid="15" ssid="12">Second, the parsers in (Collins 96) and (NIagerman 95; Jelinek et al. 94) produce trees without information about whmovement or subcategorisation.</S>
    <S sid="16" ssid="13">Most NLP applications will need this information to extract predicateargument structure from parse trees.</S>
    <S sid="17" ssid="14">In the remainder of this paper we describe the 3 models in section 2, discuss practical issues in section 3, give results in section 4, and give conclusions in section 5.</S>
  </SECTION>
  <SECTION title="2 The Three Parsing Models" number="2">
    <S sid="18" ssid="1">In general, a statistical parsing model defines the conditional probability, P(T S), for each candidate parse tree T for a sentence S. The parser itself is an algorithm which searches for the tree, Tb&#8222;t, that maximises 'P(T 1 S).</S>
    <S sid="19" ssid="2">A generative model uses the observation that maximising P(T, S) is equivalent to maximising P(T I S): 1 to a top-down derivation of the tree.</S>
    <S sid="20" ssid="3">In a PCFG, for a tree derived by n applications of context-free re-write rules LH Si RHS, 1 i n, The re-write rules are either internal to the tree, where LHS is a non-terminal and RHS is a string of one or more non-terminals; or lexical, where LHS is a part of speech tag and RHS is a word.</S>
    <S sid="21" ssid="4">A PCFG can be lexicalised2 by associating a word w and a part-of-speech (POS) tag t with each nonterminal X in the tree.</S>
    <S sid="22" ssid="5">Thus we write a nonterminal as X(x), where x = (w,t), and X is a constituent label.</S>
    <S sid="23" ssid="6">Each rule now has the form3: H is the head-child of the phrase, which inherits the head-word h from its parent P. L1...L7, and are left and right modifiers of H. Either n or m may be zero, and n = m = 0 for unary rules.</S>
    <S sid="24" ssid="7">Figure 1 shows a tree which will be used as an example throughout this paper.</S>
    <S sid="25" ssid="8">The addition of lexical heads leads to an enormous number of potential rules, making direct estimation of P(RHS I LHS) infeasible because of sparse data problems.</S>
    <S sid="26" ssid="9">We decompose the generation of the RHS of a rule such as (3), given the LHS, into three steps &#8212; first generating the head, then making the independence assumptions that the left and right modifiers are generated by separate 0th-order markov processes 4. .</S>
    <S sid="27" ssid="10">For example, the probability of the rule S (bought) -&gt; NP (week) NP (Marks) VP (bought) would be estimated as but in general the probabilities could be conditioned on any of the preceding modifiers.</S>
    <S sid="28" ssid="11">In fact, if the derivation order is fixed to be depth-first &#8212; that is, each modifier recursively generates the sub-tree below it before the next modifier is generated &#8212; then the model can also condition on any structure below the preceding modifiers.</S>
    <S sid="29" ssid="12">For the moment we exploit this by making the approximations where distancei and distance,. are functions of the surface string from the head word to the edge of the constituent (see figure 2).</S>
    <S sid="30" ssid="13">The distance measure is the same as in (Collins 96), a vector with the following 3 elements: (1) is the string of zero length?</S>
    <S sid="31" ssid="14">(Allowing the model to learn a preference for rightbranching structures); (2) does the string contain a verb?</S>
    <S sid="32" ssid="15">(Allowing the model to learn a preference for modification of the most recent verb).</S>
    <S sid="33" ssid="16">(3) Does the string contain 0, 1, 2 or &gt; 2 commas?</S>
    <S sid="34" ssid="17">(where a comma is anything tagged as &amp;quot;,&amp;quot; or probability P(R3(r3) I P, H, h, distance, (2)).</S>
    <S sid="35" ssid="18">The distance is a function of the surface string from the word after h to the last word of R2, inclusive.</S>
    <S sid="36" ssid="19">In principle the model could condition on any structure dominated by H, R1 or R2. distinction and subcategorisation The tree in figure 1 is an example of the importance of the complement/adjunct distinction.</S>
    <S sid="37" ssid="20">It would be useful to identify &amp;quot;Marks&amp;quot; as a subject, and &amp;quot;Last week&amp;quot; as an adjunct (temporal modifier), but this distinction is not made in the tree, as both NPs are in the same position' (sisters to a VP under an S node).</S>
    <S sid="38" ssid="21">From here on we will identify complements by attaching a &amp;quot;-C&amp;quot; suffix to non-terminals &#8212; figure 3 gives an example tree.</S>
    <S sid="39" ssid="22">A post-processing stage could add this detail to the parser output, but we give two reasons for making the distinction while parsing: First, identifying complements is complex enough to warrant a probabilistic treatment.</S>
    <S sid="40" ssid="23">Lexical information is needed &#8212; for example, knowledge that &amp;quot;week&amp;quot; is likely to be a temporal modifier.</S>
    <S sid="41" ssid="24">Knowledge about subcategorisation preferences &#8212; for example that a verb takes exactly one subject &#8212; is also required.</S>
    <S sid="42" ssid="25">These problems are not restricted to NPs, compare &amp;quot;The spokeswoman said (SBAR that the asbestos was dangerous)&amp;quot; vs. &amp;quot;Bonds beat short-term investments (SBAR because the market is down)&amp;quot;, where an SBAR headed by &amp;quot;that&amp;quot; is a complement, but an SBAR headed by &amp;quot;because&amp;quot; is an adjunct.</S>
    <S sid="43" ssid="26">The second reason for making the complement/adjunct distinction while parsing is that it may help parsing accuracy.</S>
    <S sid="44" ssid="27">The assumption that complements are generated independently of each other often leads to incorrect parses &#8212; see figure 4 for further explanation.</S>
    <S sid="45" ssid="28">Adjuncts in the Penn Treebank We add the &amp;quot;-C&amp;quot; suffix to all non-terminals in training data which satisfy the following conditions: In addition, the first child following the head of a prepositional phrase is marked as a complement.</S>
    <S sid="46" ssid="29">The model could be retrained on training data with the enhanced set of non-terminals, and it might learn the lexical properties which distinguish complements and adjuncts (&amp;quot;Marks&amp;quot; vs -week&amp;quot;, or &amp;quot;that&amp;quot; vs. &amp;quot;because&amp;quot;).</S>
    <S sid="47" ssid="30">However, it would still suffer from the bad independence assumptions illustrated in figure 4.</S>
    <S sid="48" ssid="31">To solve these kinds of problems, the generative process is extended to include a probabilistic choice of left and right subcategorisation frames: other leads to errors.</S>
    <S sid="49" ssid="32">In (1) the probability of generating both &amp;quot;Dreyfus&amp;quot; and &amp;quot;fund&amp;quot; as subjects, P(NP-C(Dreyf us) I S , VP , was) * P(NP-C(fund) I S ,VP , was) is unreasonably high.</S>
    <S sid="50" ssid="33">(2) is similar: P(NP-C (bill) , VP-C (funding) I VP , VB , was) = P(NP-C (bill) I VP , VB , was) *'P(VP-C (funding) I VP , VB , was) is a bad independence assumption.</S>
    <S sid="51" ssid="34">Prc(RC I P,H,h).</S>
    <S sid="52" ssid="35">Each subcat frame is a multiset6 specifying the complements which the head requires in its left or right modifiers. spectively.</S>
    <S sid="53" ssid="36">Thus the subcat requirements are added to the conditioning context.</S>
    <S sid="54" ssid="37">As complements are generated they are removed from the appropriate subcat multiset.</S>
    <S sid="55" ssid="38">Most importantly, the probability of generating the STOP symbol will be 0 when the subcat frame is non-empty, and the probability of generating a complement will be 0 when it is not in the subcat frame; thus all and only the required complements will be generated.</S>
    <S sid="56" ssid="39">The probability of the phrase S (bought) -&gt; NP (week) NP-C(Marks) VP (bought) is now: Here the head initially decides to take a single NP-C (subject) to its left, and no complements to its right.</S>
    <S sid="57" ssid="40">NP-C(Marks) is immediately generated as the required subject, and NP-C is removed from LC, leaving it empty when the next modifier, NP (week) is generated.</S>
    <S sid="58" ssid="41">The incorrect structures in figure 4 should now have low probability because Pic({NP-C , NP-C} I S , VP ,bought) and P&#8222;({NP-C ,VP-C} I VP , VB , was) are small.</S>
    <S sid="59" ssid="42">Another obstacle to extracting predicate-argument structure from parse trees is wh-movement.</S>
    <S sid="60" ssid="43">This section describes a probabilistic treatment of extraction from relative clauses.</S>
    <S sid="61" ssid="44">Noun phrases are most often extracted from subject position, object position, or from within PPs: It might be possible to write rule-based patterns which identify traces in a parse tree.</S>
    <S sid="62" ssid="45">However, we argue again that this task is best integrated into the parser: the task is complex enough to warrant a probabilistic treatment, and integration may help parsing accuracy.</S>
    <S sid="63" ssid="46">A couple of complexities are that modification by an SBAR does not always involve extraction (e.g., &amp;quot;the fact (SBAR that besoboru is played with a ball and a bat)&amp;quot;), and it is not uncommon for extraction to occur through several constituents, (e.g., &amp;quot;The changes (SBAR that he said the government was prepared to make TRACE)&amp;quot;).</S>
    <S sid="64" ssid="47">The second reason for an integrated treatment of traces is to improve the parameterisation of the model.</S>
    <S sid="65" ssid="48">In particular, the subcategorisation probabilities are smeared by extraction.</S>
    <S sid="66" ssid="49">In examples 1, 2 and 3 above 'bought' is a transitive verb, but without knowledge of traces example 2 in training data will contribute to the probability of 'bought' being an intransitive verb.</S>
    <S sid="67" ssid="50">Formalisms similar to GPSG (Gazdar et al. 95) handle NP extraction by adding a gap feature to each non-terminal in the tree, and propagating gaps through the tree until they are finally discharged as a trace complement (see figure 5).</S>
    <S sid="68" ssid="51">In extraction cases the Penn treebank annotation co-indexes a TRACE with the WHNP head of the SBAR, so it is straightforward to add this information to trees in training data.</S>
    <S sid="69" ssid="52">Given that the LHS of the rule has a gap, there are 3 ways that the gap can be passed down to the RHS: Head The gap is passed to the head of the phrase, as in rule (3) in figure 5.</S>
    <S sid="70" ssid="53">Left, Right The gap is passed on recursively to one of the left or right modifiers of the head, or is discharged as a trace argument to the left/right of the head.</S>
    <S sid="71" ssid="54">In rule (2) it is passed on to a right modifier, the S complement.</S>
    <S sid="72" ssid="55">In rule (4) a trace is generated to the right of the head VB.</S>
    <S sid="73" ssid="56">We specify a parameter PG(G I P, h, H) where G is either Head, Left or Right.</S>
    <S sid="74" ssid="57">The generative process is extended to choose between these cases after generating the head of the phrase.</S>
    <S sid="75" ssid="58">The rest of the phrase is then generated in different ways depending on how the gap is propagated: In the Head case the left and right modifiers are generated as normal.</S>
    <S sid="76" ssid="59">In the Left, Right cases a gap requirement is added to either the left or right SUBCAT variable.</S>
    <S sid="77" ssid="60">This requirement is fulfilled (and removed from the subcat list) when a trace or a modifier non-terminal which has the +gap feature is generated.</S>
    <S sid="78" ssid="61">For example, Rule (2), SBAR(that) (+gap) -&gt; WHNP (that ) S-C (bought ) (+gap) , has probability In rule (2) Right is chosen, so the +gap requirement is added to RC.</S>
    <S sid="79" ssid="62">Generation of S-C (bought) (+gap) :ulfills both the S-C and +gap requirements in RC.</S>
    <S sid="80" ssid="63">In rule (4) Right is chosen again.</S>
    <S sid="81" ssid="64">Note that generation of trace satisfies both the NP-C and +gap subcat requirements.</S>
  </SECTION>
  <SECTION title="3 Practical Issues" number="3">
    <S sid="82" ssid="1">Table 1 shows the various levels of back-off for each type of parameter in the model.</S>
    <S sid="83" ssid="2">Note that we decompose P L(L,(1ws, Its) I P, H, w, t, A, LC) (where /wi and /t, are the word and POS tag generated with non-terminal Ls, A is the distance measure) into the product 'PLI(Li(itz) I P,H,w,t,A,LC) x PL,2(hoi I Ls, its, P, H, w, t, A, LC), and then smooth these two probabilities separately (Jason Eisner, p.c.).</S>
    <S sid="84" ssid="3">In each case' the final estimate is where e1, e2 and e3 are maximum likelihood estimates with the context at levels 1, 2 and 3 in the table, and Ai , A2 and A3 are smoothing parameters where 0 &lt; Ai &lt; 1.</S>
    <S sid="85" ssid="4">All words occurring less than 5 times in training data, and words in test data which have never been seen in training, are replaced with the &amp;quot;UNKNOWN&amp;quot; token.</S>
    <S sid="86" ssid="5">This allows the model to robustly handle the statistics for rare or new words.</S>
    <S sid="87" ssid="6">Part of speech tags are generated along with the words in this model.</S>
    <S sid="88" ssid="7">When parsing, the POS tags allowed for each word are limited to those which have been seen in training data for that word.</S>
    <S sid="89" ssid="8">For unknown words, the output from the tagger described in (Ratnaparkhi 96) is used as the single possible tag for that word.</S>
    <S sid="90" ssid="9">A CKY style dynamic programming chart parser is used to find the maximum probability tree for each sentence (see figure 6).</S>
  </SECTION>
  <SECTION title="4 Results" number="4">
    <S sid="91" ssid="1">The parser was trained on sections 02 - 21 of the Wall Street Journal portion of the Penn Treebank (Marcus et al. 93) (approximately 40,000 sentences), and tested on section 23 (2,416 sentences).</S>
    <S sid="92" ssid="2">We use the PARSEVAL measures (Black et al. 91) to compare performance: number of correct constituents in proposed parse number of constituents in proposed parse number of correct constituents in proposed parse number of constituents in treebank parse Crossing Brackets = number of constituents which violate constituent boundaries with a constituent in the treebank parse.</S>
    <S sid="93" ssid="3">For a constituent to be 'correct' it must span the same set of words (ignoring punctuation, i.e. all tokens tagged as commas, colons or quotes) and have the same label' as a constituent in the treebank parse.</S>
    <S sid="94" ssid="4">Table 2 shows the results for Models 1, 2 and 3.</S>
    <S sid="95" ssid="5">The precision/recall of the traces found by Model 3 was 93.3%/90.1% (out of 436 cases in section 23 of the treebank), where three criteria must be met for a trace to be &amp;quot;correct&amp;quot;: (1) it must be an argument to the correct head-word; (2) it must be in the correct position in relation to that head word (preceding or following); (3) it must be dominated by the correct non-terminal label.</S>
    <S sid="96" ssid="6">For example, in figure 5 the trace is an argument to bought, which it follows, and it is dominated by a VP.</S>
    <S sid="97" ssid="7">Of the 436 cases, 342 were string-vacuous extraction from subject position, recovered with 97.1%/98.2% precision/recall; and 94 were longer distance cases, recovered with 76%/60.6% precision/recall 9.</S>
    <S sid="98" ssid="8">Model 1 is similar in structure to (Collins 96) the major differences being that the &amp;quot;score&amp;quot; for each bigram dependency is Ps (Li, 1,IH , P, h, distances) 8(Magerman 95) collapses ADVP and PRT to the same label, for comparison we also removed this distinction when calculating scores.</S>
    <S sid="99" ssid="9">9We exclude infinitival relative clauses from these figures, for example &amp;quot;I called a plumber TRACE to fix the sink&amp;quot; where 'plumber' is co-indexed with the trace subject of the infinitival.</S>
    <S sid="100" ssid="10">The algorithm scored 41%/18% precision/recall on the 60 cases in section 23 - but infinitival relatives are extremely difficult even for human annotators to distinguish from purpose clauses (in this case, the infinitival could be a purpose clause modifying 'called') (Ann Taylor, p.c.) rather than Ps(Li, P, H I I, h, distances), and that there are the additional probabilities of generating the head and the STOP symbols for each constituent.</S>
    <S sid="101" ssid="11">However, Model 1 has some advantages which may account for the improved performance.</S>
    <S sid="102" ssid="12">The model in (Collins 96) is deficient, that is for most sentences S, ET P(T I S) &lt; 1, because probability mass is lost to dependency structures which violate the hard constraint that no links may cross.</S>
    <S sid="103" ssid="13">For reasons we do not have space to describe here, Model 1 has advantages in its treatment of unary rules and the distance measure.</S>
    <S sid="104" ssid="14">The generative model can condition on any structure that has been previously generated - we exploit this in models 2 and 3 - whereas (Collins 96) is restricted to conditioning on features of the surface string alone.</S>
    <S sid="105" ssid="15">(Charniak 95) also uses a lexicalised generative model.</S>
    <S sid="106" ssid="16">In our notation, he decomposes P(RHSi I LHS) as P(R,,...R1HL1..L, I P,h) x Penn treebank annotation style leads to a very large number of context-free rules, so that directly estimating 'P(R7,...R1HL1..Lin I P, h) may lead to sparse data problems, or problems with coverage (a rule which has never been seen in training may be required for a test data sentence).</S>
    <S sid="107" ssid="17">The complement/adjunct distinction and traces increase the number of rules, compounding this problem.</S>
    <S sid="108" ssid="18">(Eisner 96) proposes 3 dependency models, and gives results that show that a generative model similar to Model 1 performs best of the three.</S>
    <S sid="109" ssid="19">However, a pure dependency model omits non-terminal information, which is important.</S>
    <S sid="110" ssid="20">For example, &amp;quot;hope&amp;quot; is likely to generate a VP (TO) modifier (e.g., I hope [VP to sleep]) whereas &amp;quot;require&amp;quot; is likely to generate an S(TO) modifier (e.g., I require [S Jim to sleep]), but omitting non-terminals conflates these two cases, giving high probability to incorrect structures such as &amp;quot;I hope [Jim to sleep]&amp;quot; or &amp;quot;I require [to sleep]&amp;quot;.</S>
    <S sid="111" ssid="21">(Alshawi 96) extends a generative dependency model to include an additional state variable which is equivalent to having non-terminals - his suggestions may be close to our models 1 and 2, but he does not fully specify the details of his model, and doesn't give results for parsing accuracy.</S>
    <S sid="112" ssid="22">(Miller et al. 96) describe a model where the RHS of a rule is generated by a Markov process, although the process is not head-centered.</S>
    <S sid="113" ssid="23">They increase the set of non-terminals by adding semantic labels rather than by adding lexical head-words.</S>
    <S sid="114" ssid="24">(Magerman 95; Jelinek et al. 94) describe a history-based approach which uses decision trees to estimate P(TIS).</S>
    <S sid="115" ssid="25">Our models use much less sophisticated n-gram estimation methods, and might well benefit from methods such as decision-tree estimation which could condition on richer history than just surface distance.</S>
    <S sid="116" ssid="26">There has recently been interest in using dependency-based parsing models in speech recognition, for example (Stolcke 96).</S>
    <S sid="117" ssid="27">It is interesting to note that Models 1, 2 or 3 could be used as language models.</S>
    <S sid="118" ssid="28">The probability for any sentence can be estimated as P(S) = ET P(T, s), or (making a Viterbi approximation for efficiency reasons) as P(S) P(Tbest, S).</S>
    <S sid="119" ssid="29">We intend to perform experiments to compare the perplexity of the various models, and a structurally similar 'pure' PCFG1&#176;.</S>
  </SECTION>
  <SECTION title="5 Conclusions" number="5">
    <S sid="120" ssid="1">This paper has proposed a generative, lexicalised, probabilistic parsing model.</S>
    <S sid="121" ssid="2">We have shown that linguistically fundamental ideas, namely subcategorisation and wh-movement, can be given a statistical interpretation.</S>
    <S sid="122" ssid="3">This improves parsing performance, and, more importantly, adds useful information to the parser's output.</S>
  </SECTION>
  <SECTION title="6 Acknowledgements" number="6">
    <S sid="123" ssid="1">I would like to thank Mitch Marcus, Jason Eisner, Dan Melamed and Adwait Ratnaparkhi for many useful discussions, and comments on earlier versions of this paper.</S>
    <S sid="124" ssid="2">This work has also benefited greatly from suggestions and advice from Scott Miller.</S>
  </SECTION>
</PAPER>
