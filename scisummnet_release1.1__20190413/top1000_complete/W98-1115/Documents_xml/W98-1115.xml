<PAPER>
  <S sid="0">Edge-Based Best-First Chart Parsing</S>
  <ABSTRACT>
    <S sid="1" ssid="1">Best-first probabilistic chart parsing attempts to parse efficiently by working on edges that are judged &amp;quot;best&amp;quot; by some probabilistic figure of merit (FOM).</S>
    <S sid="2" ssid="2">Recent work has used probabilistic context-free grammars (PCFGs) to assign probabilities to constituents, and to use these probabilities as the starting point for the FOM.</S>
    <S sid="3" ssid="3">This paper extends this approach to using a probabilistic FOM to judge edges (incomplete constituents), thereby giving a much finergrained control over parsing effort.</S>
    <S sid="4" ssid="4">We show how this can be accomplished in a particularly simple way using the common idea of binarizing the PCFG.</S>
    <S sid="5" ssid="5">The results obtained are about a facof twenty improvement over the best results &#8212; that is, our parser achieves equivalent results using one twentieth the number of edges.</S>
    <S sid="6" ssid="6">Furthermore we show that this improvement is obtained with parsing precision and recall levels superior to those achieved by exhaustive parsing.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="7" ssid="1">Finding one (or all) parses for a sentence according to a context-free grammar requires search.</S>
    <S sid="8" ssid="2">Fortunately, there are well known 0(n3) algorithms for parsing, where n is the length of the sentence.</S>
    <S sid="9" ssid="3">Unfortunately, for large grammars (such as the PCFG induced from the Penn II WSJ corpus, which contains around 1.6 &#8226; 104 rules) and longish sentences (say, 40 words and punctuation), even 0(713) looks pretty bleak.</S>
    <S sid="10" ssid="4">One well-known 0(n3) parsing method (Kay, 1980) is chart parsing.</S>
    <S sid="11" ssid="5">In this approach one maintains an agenda of items remaining to be processed, one of which is processed during each iteration.</S>
    <S sid="12" ssid="6">As each item is pulled off the agenda, it is added to the chart (unless it is already there, in which case it can be discarded) and used to extend and create additional items.</S>
    <S sid="13" ssid="7">In &amp;quot;exhaustive&amp;quot; chart parsing one removes items from the agenda in some relatively simple way (last-in, first-out is common), and continues to do so until nothing remains.</S>
    <S sid="14" ssid="8">A commonly discussed alternative is to remove the constituents from the agenda according to a figure of merit (FOM).</S>
    <S sid="15" ssid="9">The idea is that the FOM selects &amp;quot;good&amp;quot; items to be processed, leaving the &amp;quot;bad&amp;quot; ones&#8212; the ones that are not, in fact, part of the correct parse&#8212; sitting on the agenda.</S>
    <S sid="16" ssid="10">When one has a completed parse, or perhaps several possible parses, one simply stops parsing, leaving items remaining on the agenda.</S>
    <S sid="17" ssid="11">The time that would have been spent processing these remaining items is time saved, and thus time earned.</S>
    <S sid="18" ssid="12">In our work we have found that exhaustively parsing maximum-40-word sentences from the Penn II treebank requires an average of about 1.2 million edges per sentence.</S>
    <S sid="19" ssid="13">Numbers like this suggest that any approach that offers the possibility of reducing the work load is well worth pursuing, a fact that has been noted by several researchers.</S>
    <S sid="20" ssid="14">Early on, Kay (1980) suggested the use of the chart agenda for this purpose.</S>
    <S sid="21" ssid="15">More recently, the statistical approach to language processing and the use of probabilistic context-free grammars (PCFGs) has suggested using the PCFG probabilities to create a FOM.</S>
    <S sid="22" ssid="16">Bobrow (1990) and Chitrao and Grishman (1990) introduced best-first PCFG parsing, the approach taken here.</S>
    <S sid="23" ssid="17">Subsequent work has suggested different FOMs built from PCFG probabilities (Miller and Fox.</S>
    <S sid="24" ssid="18">1994: Kochman and Kupin.</S>
    <S sid="25" ssid="19">1991: N1agerman and Marcus, 1991).</S>
    <S sid="26" ssid="20">Probably the most extensive comparison of possible metrics for best-first PCFG parsing is that of Caraballo and Charniak (henceforth C&amp;C) (Forthcoming).</S>
    <S sid="27" ssid="21">They consider a large number of FOMs, and view them as approximations of some &amp;quot;ideal&amp;quot; (but only computable after the fact) FOM.</S>
    <S sid="28" ssid="22">Of these they recommend one as the best of the lot.</S>
    <S sid="29" ssid="23">In this paper we basically adopt both their framework and their recommended FOM.</S>
    <S sid="30" ssid="24">The next section describes their work in more detail, Besides C&amp;C the work that is most directly comparable to ours is that of Goodman (1997) and Ratnaparki (1997).</S>
    <S sid="31" ssid="25">Goodman uses an FOM that is similar to that of C&amp;C but one that should, in general, be somewhat more accurate.</S>
    <S sid="32" ssid="26">However, both Goodman's and Ratnaparki's work assumes that one is doing a beam search of some sort, rather than a best-first search, and their FOM are unfortunately tied to their frameworks and thus cannot be adopted here.</S>
    <S sid="33" ssid="27">We briefly compare our results to theirs in Section 5.</S>
    <S sid="34" ssid="28">As noted, our paper takes off from that of C&amp;C and uses the same FOM.</S>
    <S sid="35" ssid="29">The major difference is simply that our parser uses the FOM to rank edges (including incomplete edges), rather than simply completed constituents, as was done by C&amp;C.</S>
    <S sid="36" ssid="30">What is interesting about our approach is that such a seemingly simple change can produce rather dramatic results.</S>
    <S sid="37" ssid="31">Rather than the thousands of edges required by C&amp;C, the parser presented here requires hundreds, or even, if one is willing to pay a small price in accuracy, tens.</S>
  </SECTION>
  <SECTION title="2 Constituent-Based Best-First" number="2">
    <S sid="38" ssid="1">In the approach taken in C&amp;C, only completed edges, i.e., constituents, are entered into the agenda; incomplete edges are always processed as soon as they are constructed.</S>
    <S sid="39" ssid="2">At each iteration the constituent with the highest figure of merit is removed from the agenda, added to the chart, and used to extend current partially completed constituents.</S>
    <S sid="40" ssid="3">Thus we characterize their work as constituent-based best-first chart parsing.</S>
    <S sid="41" ssid="4">C&amp;C take as an &amp;quot;ideal&amp;quot; FOM the quantity to,,).</S>
    <S sid="42" ssid="5">Here NJ, is a constituent of type i (e.g., NP, VP, etc.) that spans the constituents from j up to but not including k, and tom are the n parts-of-speech (tags) of the sentence.</S>
    <S sid="43" ssid="6">Note that C&amp;C simplify parsing by assuming that the input is a sequence of tags, not words.</S>
    <S sid="44" ssid="7">We make the same assumption in this paper.</S>
    <S sid="45" ssid="8">Thus taking p(N;rk I to,,) as an FOM says that one should work on the constituent that is most likely to be correct .given the tags of the sentence.</S>
    <S sid="46" ssid="9">As p(N;,k to,n) can only be computed precisely after a full parse of the sentence, C&amp;C derive several approximations, in each case starting from the well known equation for p(Nlk I tom) in terms of the inside and outside probabilities, /3(1V.1,k) and where fi(Mjkj ) and a(N'k ) are defined as follows: (4) Informally, this can be obtained by approximating the outside probability a(N.;,k) in Equation 1 with a bitag estimate.</S>
    <S sid="47" ssid="10">Of the five terms in Equation 4, two can be directly estimated from training data: the &amp;quot;boundary statistics&amp;quot; p(N.:,k I tj) (the probability of a constituent of type NIAstarting just after the tag tj) and p(tk I NIA) (the probability of tk appearing just after the end of a constituent of type N.4).</S>
    <S sid="48" ssid="11">The tag sequence probabilitiy in the denominator is approximated using a bi-tag approximation: The basic algorithm then is quite simple.</S>
    <S sid="49" ssid="12">One uses the standard chart-parsing algorithm, except at each iteration one takes from the agenda the constituent that maximizes the FOM described in Equation 4.</S>
    <S sid="50" ssid="13">There are, however, two minor complexities that need to be noted.</S>
    <S sid="51" ssid="14">The first relates to the inside probability 0(N:4).</S>
    <S sid="52" ssid="15">C&amp;C approximate it with the sum of the probabilities of all the parses for Nlk found at that point in the parse.</S>
    <S sid="53" ssid="16">This in turn requires a somewhat complicated scheme to avoid repeatedly re-evaluating Equation 4 whenever a new parse is found.</S>
    <S sid="54" ssid="17">In this paper we adopt a slightly simpler method.</S>
    <S sid="55" ssid="18">We approximate )3(Nk) by the most probable parse for Ni,k, rather than the sum of all the parses. j We justify this on the grounds that our parser eventually returns the most probable parse, so it seems reasonable to base our metric on its value.</S>
    <S sid="56" ssid="19">This also simplifies updating 13(N3,k) when new parses are found for Nk.</S>
    <S sid="57" ssid="20">Our algorithm compares the probability of the new parse to the best already found for Ni 4.</S>
    <S sid="58" ssid="21">If the old one is higher, nothing need be done.</S>
    <S sid="59" ssid="22">If the new one is higher, it is simply added to the agenda.</S>
    <S sid="60" ssid="23">The second complexity has to do with the fact that in Equation 4 the probability of the tags t3,k are approximated using two different distributions, once in the numerator where we use the PCFG probabilities, and once in the denominator, where we use the bi-tag probabilities.</S>
    <S sid="61" ssid="24">One fact noted by C&amp;C, but not discussed in their paper, is that typically the bitag model gives higher probabilities for a tag sequence than does the PCFG distribution.</S>
    <S sid="62" ssid="25">For any single tag t3, the difference is not much, but as we use Equation 4 to compute our FOM for larger constituents, the numerator becomes smaller and smaller with respect to the denominator, effectively favoring smaller constituents.</S>
    <S sid="63" ssid="26">To avoid this one needs to normalize the two distributions to produce more similar results.</S>
    <S sid="64" ssid="27">We have empirically measured the normalization factor and found that the bi-tag distribution produces probabilities that are approximately 1.3 times those produced by the PCFG distribution, on a per-word basis.</S>
    <S sid="65" ssid="28">We correct for this by making the PCFG probability of a known tag ri &gt; 1.</S>
    <S sid="66" ssid="29">This has the effect of multiplying the inside probability /3(N.4) by rik-J.</S>
    <S sid="67" ssid="30">In Section 4 we show how the behavior of our algorithm changes for is between 1.0 and 2.4.</S>
  </SECTION>
  <SECTION title="3 Chart parsing and binarization" number="3">
    <S sid="68" ssid="1">Informally, our algorithm differs from the one presented in C&amp;C primarily in that we rank all edges, incomplete as well as complete, with respect to the FOM.</S>
    <S sid="69" ssid="2">A straight-forward way to extend C&amp;C in this fashion is to transform the grammar so that all productions are either unary or binary.</S>
    <S sid="70" ssid="3">Once this has been done there is no need for incomplete edges at all in bottomup parsing, and parsing can be performed using the CKY algorithm, suitably extended to handle unary productions.</S>
    <S sid="71" ssid="4">One way to convert a PCFG into this form is left-factoring (Hoperoft and Ullman, 1979).</S>
    <S sid="72" ssid="5">Left-factoring replaces each production A -4 : p, where p is the production probability and 101 = n&gt; 2, with the following set of binary productions: In these productions A is the ith element of /3 and `13i,j' is the subsequence A of 0, but treated as a 'new' single non-terminal in the left-factored grammar (the quote marks indicate that this subsequence is to be considered a single symbol).</S>
    <S sid="73" ssid="6">For example, the production VP -4 V NP NP PP :0.7 left-factors to the following productions: VP --4 NP NP' PP :0.7 NP NP' NP' PP : 1.0 NP' -4 V NP :1.0 It is not difficult to show that the left-factored grammar defines the same probability distribution over strings as the original grammar, and to devise a tree transformation that maps each parse tree of the original grammar into a unique parse tree of the left-factored grammar of the same probability.</S>
    <S sid="74" ssid="7">In fact, the assumption that all productions are at most binary is not extraordinary, since tabular parsers that construct complete parse forests in worst-case 0(n3) time explicitly or implicitly convert their grammars into binary branching form (Lang, 1974; Lang, 1991).</S>
    <S sid="75" ssid="8">Sikkel and Nijholt (1997) describe in detail the close relationship between the CKY algorithm, the Earley algorithm and a bottom-up variant of the Earley algorithm.</S>
    <S sid="76" ssid="9">The key observation is that the 'new' non-terminals `01,i' in a CKY parse using a left-factored grammar correspond to the set of non-empty incomplete edges A -4 01,z.</S>
    <S sid="77" ssid="10">13z+1,n in the bottom-up variant of the Earley algorithm, where A -&gt; 131,, is a production of the original grammar.</S>
    <S sid="78" ssid="11">Specifically, the fundamental rule of chart parsing (Kay, 1980), which combines an incomplete edge A --* a &#8226; BO with a complete edge B 7- to yield the edge A -+ a B &#8226; 0, corresponds to the left-factored productions `aB' --+ a B if /3 is non-empty or A 'a' B if i3 is empty.</S>
    <S sid="79" ssid="12">Thus in general a single 'new' non-terminal in a CKY parse using the left-factored grammar abbreviates several incomplete edges in the Earley algorithm.</S>
  </SECTION>
  <SECTION title="4 The Experiment" number="4">
    <S sid="80" ssid="1">For our experiment, we used a tree-bank grammar induced from sections 2-21 of the Penn Wall Street Journal text (Marcus et al., 1993), with section 22 reserved for testing.</S>
    <S sid="81" ssid="2">All sentences of length greater than 40 were ignored for testing purposes as done in both C&amp;C and Goodman (1997).</S>
    <S sid="82" ssid="3">We applied the binarization technique described above to the grammar.</S>
    <S sid="83" ssid="4">We chose to measure the amount of work done by the parser in terms of the average number of edges popped off the agenda before finding a parse.</S>
    <S sid="84" ssid="5">This method has the advantage of being platform independent, as well as providing a measure of &amp;quot;perfection&amp;quot;.</S>
    <S sid="85" ssid="6">Here, perfection is the minimum number of edges we would need to pop off the agenda in order to create the correct parse.</S>
    <S sid="86" ssid="7">For the binarized grammar, where each popped edge is a completed constituent, this number is simply the number of terminals plus nonterminals in the sentence&#8212; on average, 47.5.</S>
    <S sid="87" ssid="8">Our algorithm includes some measures to reduce the number of items on the agenda, and thus (presumably) the number of popped edges.</S>
    <S sid="88" ssid="9">Each time we add a constituent to the chart, we combine it with the constituents on either side of it, potentially creating several new edges.</S>
    <S sid="89" ssid="10">For each of these new edges, we check to see if a matching constituent (i.e. a constituent with the same head, start, and end points) already exists in either the agenda or the chart.</S>
    <S sid="90" ssid="11">If there is no match, we simply add the new edge to the agenda.</S>
    <S sid="91" ssid="12">If there is a match but the old parse of Nild, is better than the new one, we discard the new parse.</S>
    <S sid="92" ssid="13">Finally, if we have found a better parse of N.4, we add the new edge to the agenda, removing the old one if it has not already been popped.</S>
    <S sid="93" ssid="14">We tested the parser on section section 22 of the WSJ text with various normalization constants .77, working on each sentence only until we reached the first full parse.</S>
    <S sid="94" ssid="15">For each sentence we recorded the number of popped edges needed to reach the first parse, and the precision and recall of that parse.</S>
    <S sid="95" ssid="16">The average number of popped edges to first parse as a function of q is shown in Figure 1, and the average precision and recall are shown in Figure 2.</S>
    <S sid="96" ssid="17">The number of popped edges decreases as ij increases from 1.0 to 1.7, then begins to increase again.</S>
    <S sid="97" ssid="18">See Section 5 for discussion of these results.</S>
    <S sid="98" ssid="19">The precision and recall also decrease as 77 increases.</S>
    <S sid="99" ssid="20">Note that, because we used a binarized grammer for parsing, the trees produced by the parser contain binarized labels rather than the labels in the treebank.</S>
    <S sid="100" ssid="21">In order to calculate precision and recall. we &amp;quot;debinarized&amp;quot; the parser's output and then calculated the figures as usual.</S>
    <S sid="101" ssid="22">These results suggest two further questions: Is the higher accuracy with lower 77 due in part to the higher number of edges popped?</S>
    <S sid="102" ssid="23">If so, can we gain accuracy with higher i by letting the parser continue past the first parse (i.e. pop more edges)?</S>
    <S sid="103" ssid="24">To answer these questions, we ran the parser again, this time allowing it to continue parsing until it had popped 20 times as many edges as needed to reach the first parse.</S>
    <S sid="104" ssid="25">The results of this experiment are shown in Figure 3, where we plot (precision + recall)/2 (henceforth &amp;quot;accuracy&amp;quot;) as a function of edges.</S>
    <S sid="105" ssid="26">Note that regardless of 7/ the accuracy of the parse increases given extra time, but that all of the increase is achieved with only 1.5 to 2 times as many edges as needed for the first parse.</S>
    <S sid="106" ssid="27">For ij between 1.0 and 1.2, the highest accuracy is almost the same, about 75.2, but this value is reached with an average of slightly under 400 edges when 77 = 1.2, compared to about 650 when 7/ = 1.0.</S>
  </SECTION>
  <SECTION title="5 Results" number="5">
    <S sid="107" ssid="1">To better understand the experimental results it first behooves us to compare them to those achieved previously.</S>
    <S sid="108" ssid="2">Goodman's results (1997) are hard to compare against ours because his parser returns more than a singe best parse and because he measures processing time, not edges.</S>
    <S sid="109" ssid="3">However he does give edges/second for one of his 2000 4000 6000 8000 10000 parsers and this plus his parsing times suggests that for him edges/sentence will measure in the tens of thousands &#8212; a far cry from our hundreds.</S>
    <S sid="110" ssid="4">Ratnaparki's (1997) beam search parsing procedure produces higher accuracy results than our PCFG model, and achieves this with a beam width of 20.</S>
    <S sid="111" ssid="5">Unfortunately his paper does not give statistics which can be directly compared with ours.</S>
    <S sid="112" ssid="6">The work by C&amp;C is easier to compare.</S>
    <S sid="113" ssid="7">In Figure 4 we reproduce C&amp;C's results on the percentage of sentences (length 18-26) parsed as a function of number of edges used.</S>
    <S sid="114" ssid="8">We performed the same experiment, and our results are included there as well.</S>
    <S sid="115" ssid="9">This figure makes dramatic the order of magnitude improvement provided by our new scheme, but it is not too easy to read numbers off of it.</S>
    <S sid="116" ssid="10">Such numbers are provided in Table 1.</S>
    <S sid="117" ssid="11">Our figures were obtained using ri = 1.2.</S>
    <S sid="118" ssid="12">As can be seen, our parser requires about one twentieth the number of edges required by C&amp;C.</S>
    <S sid="119" ssid="13">Indeed, the low average number of edges to first parse is probably the most striking thing about our results.</S>
    <S sid="120" ssid="14">Even allowing for the fact that considerably more edges must be pushed than are popped, the total number of edges required to first parse is quite small.</S>
    <S sid="121" ssid="15">Since the average number of edges required to construct just the (left-factored) test corpus trees is 47.5, our parsing system considers as few as 3 times as many edges as are required to actually produce the output tree.</S>
    <S sid="122" ssid="16">Almost as interesting, if i is below 1.4, the precision and recall scores of the first parse are better than those obtained by running the parser to exhaustion, even though the probability of the first parses our algorithm returns cannot be higher than that found by the exhaustive version.</S>
    <S sid="123" ssid="17">Furthermore, as seen in Figure 3, running our parser past the first parse by a small amount (150% of the edges required for the first parse) produces still more accurate parses.</S>
    <S sid="124" ssid="18">At 150% of the minimum number of edges and I) = 1.2 the precision/recall figures are about 2% above those for the maximum likelihood parse.</S>
    <S sid="125" ssid="19">We have two (possibly related) theories of these phenomona.</S>
    <S sid="126" ssid="20">It may be that the FOM metric used to select constituents forces our parser to concentrate on edges which are plausible given their surrounding preterminals; information which is ignored by the exhaustive maximum likelihood parser.</S>
    <S sid="127" ssid="21">Alternatively, it may be that because our FOM causes our parser to prefer edges with a high inside times (estimated) outside probability, it is in fact partially mimicking Goodman's (Goodman, 1996) 'Labelled Recall' parsing algorithm, which does not return the highest probability parse but attempts to maximize labelled bracket recall with the test set.</S>
    <S sid="128" ssid="22">Finally, it is interesting to note that the minimum number of edges per parse is reached when 77 1.65, which is considerably larger than the theoretical estimate of 1.3 given earlier.</S>
    <S sid="129" ssid="23">Notice that one effect of increasing r/ is to raise the FOM for longer constituents.</S>
    <S sid="130" ssid="24">It may be that on average a partial parse is completed fastest if larger constituents receive more attention since they are more likely to lead quickly to a complete analysis, which would be one consequence of the larger than expected n. This last hypothesis is also consistent with the observation that average precision and recall sharply falls off when 77 is increased beyond its theoretically optimal value, since then the parser is presumably focusing on relatively larger constituents and ignoring other, strictly more plausible, smaller ones.</S>
  </SECTION>
  <SECTION title="6 Conclusion" number="6">
    <S sid="131" ssid="1">It is worth noting that while we have presented the use of edge-based best-first chart parsing in the service of a rather pure form of PCFG parsing, there is no particular reason to assume that the technique is so limited in its domain of applicability.</S>
    <S sid="132" ssid="2">One can imagine the same techniques coupled with more informative probability distributions, such as lexicalized PCFGs (Charniak, 1997), or even grammars not based upon literal rules, but probability distributions that describe how rules are built up from smaller components (Magerman, 1995; Collins, 1997).</S>
    <S sid="133" ssid="3">Clearly further research is warranted.</S>
    <S sid="134" ssid="4">Be this as it may, the take-home lesson from this paper is simple: combining an edge-based agenda with the figure of merit from C&amp;C To the best of our knowledge this is currently the most effecient parsing technique for PCFG grammars induced from large tree-banks.</S>
    <S sid="135" ssid="5">As such we strongly recommend this technique to others interested in PCFG parsing.</S>
  </SECTION>
</PAPER>
